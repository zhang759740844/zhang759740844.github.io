{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ec96daee2969482d7606e4846a11fcdf92207933","modified":1482580187000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1480754667000},{"_id":"themes/landscape/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1480754667000},{"_id":"themes/landscape/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1480754667000},{"_id":"themes/landscape/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1480754667000},{"_id":"themes/landscape/_config.yml","hash":"1271b0145e45aa13904dbdb0efd1f25c8b94043b","modified":1480754667000},{"_id":"themes/landscape/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1480754667000},{"_id":"themes/landscape/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1480754667000},{"_id":"themes/landscape/.DS_Store","hash":"74c89c0044ddbf2aa8b2c033ee6459869e92edd9","modified":1482580187000},{"_id":"source/about/index.md","hash":"0d3d216cb610b10447e97566fe3789d313cbbad4","modified":1480754667000},{"_id":"source/_posts/.DS_Store","hash":"7ca487dbb020abefc62fcc4dd5406909809db837","modified":1481822303000},{"_id":"source/_posts/Block基础.md","hash":"cc6f03e8f1cee6fb30c4c86729923c5c22347bae","modified":1480754667000},{"_id":"source/_posts/CALayer学习小结.md","hash":"5b47a6f0818bc555c0c29b347180dd0b558a5bbe","modified":1480754667000},{"_id":"source/_posts/GCD队列.md","hash":"659d830d4fe422948f2863cec63068e6e62b68e8","modified":1483424501000},{"_id":"source/_posts/HTTP的构成.md","hash":"d10bfc717a4fff14bfe10628606bf9ebd8d14680","modified":1482767589000},{"_id":"source/_posts/CALayer的transform属性.md","hash":"17b77ce8b52cfc653f46c70f5fe6dd11888273f0","modified":1480754667000},{"_id":"source/_posts/IPhone6全屏黑边处理.md","hash":"3a7e5eddc998a8f19c48b26092f0353096fefcc3","modified":1480754667000},{"_id":"source/_posts/Effective_oc2笔记.md","hash":"0b3a818ed0ec7abdcdb3db1ec7028401d4d680a9","modified":1480754667000},{"_id":"source/_posts/EventLoop.md","hash":"66ccf93da12f0715f597efeea92d0f75eecce3a5","modified":1482907744000},{"_id":"source/_posts/JavaScript基本语法.md","hash":"fabcae452875d81364a92c891b9deea1b25b6cc8","modified":1480754667000},{"_id":"source/_posts/NSLayoutConstraint.md","hash":"7ab084a07c18a71fc58cbf380ad170f31a8a8a79","modified":1480754667000},{"_id":"source/_posts/KVO.md","hash":"9f5181a5fb296bf778233d18218b59fd87a57955","modified":1480754667000},{"_id":"source/_posts/NSNotification基本使用.md","hash":"d6e8f3de1d16f7f51883420002d39c74dea0ce5d","modified":1480754667000},{"_id":"source/_posts/RN使用技巧.md","hash":"300cbb7cdc279d7f58ebdeebc12abb900d2f4521","modified":1482742234000},{"_id":"source/_posts/Nodejs学习笔记.md","hash":"5456bf11b35047cb4c040bde92cbeca29f3427e9","modified":1480754667000},{"_id":"source/_posts/RN使用方式.md","hash":"26d245395397ed1ce35707d1f5af374894122ebe","modified":1481822642000},{"_id":"source/_posts/UIButton基础.md","hash":"656be2725ae0b9db4739b4c627d0ff8cd96bbc59","modified":1480754667000},{"_id":"source/_posts/Scrollview使用详解.md","hash":"7fefe02a023012ecc460b83ab7d5ca5e95a1d805","modified":1480754667000},{"_id":"source/_posts/UICollectionView.md","hash":"dc3810ff6cbb82639b847edf7bdce085cb6d4033","modified":1480754667000},{"_id":"source/_posts/UILabel的高度计算.md","hash":"e18d3df75622bff1109c85495f5f5bf650ead059","modified":1480754667000},{"_id":"source/_posts/UITableView基础.md","hash":"0b9caae87521e89bc31b143ab4d3d18b9c6694b0","modified":1481106348000},{"_id":"source/_posts/coding总结.md","hash":"b26b266183f3a5f2e5a0fad759db812bdd2e34be","modified":1483184081000},{"_id":"source/_posts/UITableview自适应高度.md","hash":"03dc9a34a724818c817fef83863189cd75395b19","modified":1480754667000},{"_id":"source/_posts/UIGestureRecognizer.md","hash":"66ccfa564124d13f8d531abee5967d012839ab46","modified":1480754667000},{"_id":"source/_posts/Xcode的使用.md","hash":"50aef785bd6f5db9593c6802909cc2d702f621d5","modified":1481822023000},{"_id":"source/_posts/hello-world.md","hash":"db9406da75d11f33966a5062fb12e51bb169796f","modified":1480754667000},{"_id":"source/_posts/git技巧.md","hash":"c49b01cdb8976bf1cfbe71101703ccc78867fece","modified":1481642406000},{"_id":"source/_posts/hexo爬过的坑.md","hash":"865d8e4c64352dab256e98c97c05f88a939852f9","modified":1481336613000},{"_id":"source/_posts/iOS多线程学习.md","hash":"aacdb504781c4a19060edf302d014ab7b06361e3","modified":1480754667000},{"_id":"source/_posts/ios响应事件.md","hash":"e6c0f07b51d7f99547850fcf5a0bea3a893e8cbd","modified":1480754667000},{"_id":"source/_posts/ios动画.md","hash":"53324ea7d15a12621725b28f19933ba53d728d51","modified":1480754667000},{"_id":"source/_posts/ios编程（第四版.md","hash":"9a813a0aedd0d7fbd944071f1ca5e9efed0db66c","modified":1480754667000},{"_id":"source/_posts/objectice-c.md","hash":"31999c1c7a6f03c7829e7157b854219ece7bdf70","modified":1483184042000},{"_id":"source/_posts/lldb调试方法.md","hash":"827ec3f40af05719740589afd860321984385e18","modified":1480754667000},{"_id":"source/_posts/oc中的枚举.md","hash":"9e910ec936c9e0811ebe629843358f5b7b757518","modified":1480754667000},{"_id":"source/_posts/python_IO编程.md","hash":"15da4be02bcef3f90d853117ad32bf03a3da6c9e","modified":1480754667000},{"_id":"source/_posts/oc新特性.md","hash":"48e8e9981b49cd808e60a417b6eb187f8831bc06","modified":1480754667000},{"_id":"source/_posts/python_函数.md","hash":"084198f2cb3626bc9a3ef50db7760337524077cd","modified":1480754667000},{"_id":"source/_posts/python_函数式编程.md","hash":"22304a78a1b470030c1012e20ab734ae9fc4bed5","modified":1480754667000},{"_id":"source/_posts/python_常用內建模块.md","hash":"7e801b0e8bd8c12ddaf2cb5776953547ca6d8964","modified":1480754667000},{"_id":"source/_posts/python_正则表达式.md","hash":"39f4251fb405473c5503dc7ce261ef776d88d480","modified":1480754667000},{"_id":"source/_posts/python_模块.md","hash":"7f8cf8d9bc7920b9c8312b7f990e03262cd39f51","modified":1480754667000},{"_id":"source/_posts/python_进程与线程.md","hash":"5a381198303b993cfea4082d72a7faecdbeae0e3","modified":1480754667000},{"_id":"source/_posts/python_面向对象编程.md","hash":"b86af2a2356d378b6b676ef0f3afeddb7b1e7012","modified":1480754667000},{"_id":"source/_posts/python_面向对象高级编程.md","hash":"dce673aa2e6b47d3edd7ac9b5853a73deb46032a","modified":1480754667000},{"_id":"source/_posts/python_高级特性.md","hash":"c60b5961314b3af6c4ba0b2afd0db0f3ab988179","modified":1480754667000},{"_id":"source/_posts/runtime原理.md","hash":"259b50e2b89f33589c5758ca68e50c44be5e819c","modified":1480754667000},{"_id":"source/_posts/runtime应用.md","hash":"79d3ea661f13ed18a480be29a9c0589807a545c2","modified":1480754667000},{"_id":"source/_posts/python语法.md","hash":"cb240a83635f406f9b06de98ff5c3a43b05cf087","modified":1480754667000},{"_id":"source/_posts/xib设置border.md","hash":"f78236b925636fc85573e8338e8d215a02936151","modified":1480754667000},{"_id":"source/_posts/storyboard基础.md","hash":"4286d707134addd34318fd139afe19710909a23b","modified":1480754667000},{"_id":"source/_posts/runloop.md","hash":"6ab8ae78669435e47d7e55ffd66c4f1140b6897b","modified":1480754667000},{"_id":"source/_posts/初识Provisioning_Profile.md","hash":"da4903de4a2165f68c6e4f153c87250ca409b10b","modified":1480754667000},{"_id":"source/_posts/删除storyboard.md","hash":"4132f5b0370e1c419d877df444113bf5defa1b2c","modified":1480754667000},{"_id":"source/_posts/打包静态库.md","hash":"d085a201cd19de5a461115647e04f574d4cdfea5","modified":1480754667000},{"_id":"source/_posts/重新开始.md","hash":"f15af7b5856cb41faaa7f77546581c8f3424639b","modified":1480754667000},{"_id":"source/categories/index.md","hash":"ca9ce2d6c165e3826b6fe70c4d6f21af059b99a2","modified":1480754667000},{"_id":"source/tags/index.md","hash":"5a034eac201382d18d2e8f7b53e7868e6bd948e2","modified":1480754667000},{"_id":"source/_posts/图解TCP_IP.md","hash":"50d1304151fa80af5120b588cbddbb258ae57674","modified":1480754667000},{"_id":"source/备份/NodeJs_Web.md","hash":"4451f54465efcbc3ac369f7e961d2fd878acf19d","modified":1480754667000},{"_id":"themes/landscape/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1480754667000},{"_id":"themes/landscape/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1480754667000},{"_id":"themes/landscape/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1480754667000},{"_id":"themes/landscape/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1480754667000},{"_id":"themes/landscape/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1480754667000},{"_id":"themes/landscape/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1480754667000},{"_id":"themes/landscape/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1480754667000},{"_id":"themes/landscape/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1480754667000},{"_id":"themes/landscape/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1480754667000},{"_id":"themes/landscape/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1480754667000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1480754667000},{"_id":"themes/landscape/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1480754667000},{"_id":"themes/landscape/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1480754667000},{"_id":"themes/landscape/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1480754667000},{"_id":"themes/landscape/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1480754667000},{"_id":"themes/landscape/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1480754667000},{"_id":"themes/landscape/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1480754667000},{"_id":"themes/landscape/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1480754667000},{"_id":"themes/landscape/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1480754667000},{"_id":"themes/landscape/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1480754667000},{"_id":"themes/landscape/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1480754667000},{"_id":"themes/landscape/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1480754667000},{"_id":"themes/landscape/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1480754667000},{"_id":"themes/landscape/images/author.png","hash":"5b9e9293ad03091a3094ee299ce2e36231b961dd","modified":1480754667000},{"_id":"themes/landscape/images/logo.png","hash":"44201457192532a1ecadb7aacf85d987a67903e2","modified":1480754667000},{"_id":"themes/landscape/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1480754667000},{"_id":"themes/landscape/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1480754667000},{"_id":"themes/landscape/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1480754667000},{"_id":"themes/landscape/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1480754667000},{"_id":"themes/landscape/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1480754667000},{"_id":"themes/landscape/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1480754667000},{"_id":"themes/landscape/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1480754667000},{"_id":"themes/landscape/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1480754667000},{"_id":"themes/landscape/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1480754667000},{"_id":"themes/landscape/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1480754667000},{"_id":"themes/landscape/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1480754667000},{"_id":"themes/landscape/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480754667000},{"_id":"themes/landscape/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1480754667000},{"_id":"themes/landscape/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1480754667000},{"_id":"themes/landscape/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1480754667000},{"_id":"themes/landscape/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1480754667000},{"_id":"themes/landscape/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1480754667000},{"_id":"themes/landscape/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1480754667000},{"_id":"themes/landscape/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1480754667000},{"_id":"themes/landscape/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1480754667000},{"_id":"themes/landscape/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1480754667000},{"_id":"themes/landscape/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1480754667000},{"_id":"themes/landscape/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1480754667000},{"_id":"themes/landscape/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1480754667000},{"_id":"themes/landscape/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1480754667000},{"_id":"themes/landscape/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1480754667000},{"_id":"themes/landscape/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1480754667000},{"_id":"themes/landscape/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1480754667000},{"_id":"themes/landscape/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1480754667000},{"_id":"themes/landscape/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1480754667000},{"_id":"themes/landscape/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1480754667000},{"_id":"themes/landscape/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1480754667000},{"_id":"themes/landscape/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1480754667000},{"_id":"themes/landscape/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1480754667000},{"_id":"themes/landscape/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1480754667000},{"_id":"themes/landscape/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1480754667000},{"_id":"themes/landscape/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1480754667000},{"_id":"themes/landscape/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1480754667000},{"_id":"themes/landscape/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1480754667000},{"_id":"themes/landscape/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1480754667000},{"_id":"themes/landscape/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1480754667000},{"_id":"public/search.xml","hash":"24073c5ed5c85cd10457544a03837cbc4721140e","modified":1483424512706},{"_id":"public/about/index.html","hash":"75549488fd5603b83d6a444577994c3ab00b221e","modified":1483423484547},{"_id":"public/categories/index.html","hash":"01c026939ae5ff26d4b37a2628de22f14db708d0","modified":1483423484548},{"_id":"public/categories/计算机/index.html","hash":"3b91c12e8f4d1ae49b4a8b6b4baeb717f834c882","modified":1483423484548},{"_id":"public/categories/Javascript/index.html","hash":"8f712c222a3a17e2e3126cd183a1725f77eeb182","modified":1483423484548},{"_id":"public/categories/JavaScript/index.html","hash":"3c5ebbaa091fe0f43825f7a0abd877966717ab9d","modified":1483423484548},{"_id":"public/categories/React-Native/index.html","hash":"13d55fe60a4c74f18b5b041294442090af4bd6cb","modified":1483423484548},{"_id":"public/categories/无处置放/index.html","hash":"6fb9f656dacfadc5be63a354f7d01a6212e45b35","modified":1483423484548},{"_id":"public/categories/Git/index.html","hash":"e4db470975e9b4af664306299ba8fb5978940cbd","modified":1483423484548},{"_id":"public/categories/python/page/2/index.html","hash":"9ea215d5087c47373ea0cd3bb6d8146deb4abfa7","modified":1483423484549},{"_id":"public/tag/Block/index.html","hash":"1e6b6dff1155edf7b12967f8fa2385b6dfdd88ea","modified":1483423484549},{"_id":"public/tag/GCD/index.html","hash":"beb98e7ba318b3c491795ec1f7ab15baf49e5be7","modified":1483423484549},{"_id":"public/tag/AutoLayout/index.html","hash":"d0ad64ec7e155e38f0e934f99298a063ef3c3639","modified":1483423484549},{"_id":"public/tag/NSNotification/index.html","hash":"19dd7ba8ff75512c73d5ec5191a264334a2a535e","modified":1483423484549},{"_id":"public/tag/React-Native/index.html","hash":"d4502e322bf6e971f1b99db1651eb7067f4752c2","modified":1483423484549},{"_id":"public/tag/NodeJs/index.html","hash":"a7b90f6c0fcf46b1a9456f4f768c7faa7aa27e50","modified":1483423484549},{"_id":"public/tag/UIGesture/index.html","hash":"cac705ef6c084f6a124425a80634083d452a836f","modified":1483423484549},{"_id":"public/tag/Vim/index.html","hash":"a2042453775c4a8a9c1b1d35e9cf1f0c9368b1f2","modified":1483423484549},{"_id":"public/tag/Cocoapods/index.html","hash":"409da8df6e129a273e40e6265d3247208e57a6e5","modified":1483423484549},{"_id":"public/tag/Hexo/index.html","hash":"7bbc24423b0844e8a60e40b7a5e836e08ad0d45a","modified":1483423484549},{"_id":"public/tag/Git/index.html","hash":"b7c729943a4028db824d28c2f964787d09729c36","modified":1483423484549},{"_id":"public/tag/UIResponder/index.html","hash":"578f508669a8ca38907fcb339dd8ff6313815325","modified":1483423484549},{"_id":"public/tag/Debug/index.html","hash":"bd29ecb56d573ddfa10b0a4f1db131c709c962e2","modified":1483423484549},{"_id":"public/tag/杂谈/index.html","hash":"00267e48a8fc022d130638f147db77dd5ff50d36","modified":1483423484549},{"_id":"public/tags/index.html","hash":"66fd8445104dd2ad4ce7c0f4891caffc6235f5bb","modified":1483423484549},{"_id":"public/备份/NodeJs_Web.html","hash":"47b7ad37231465f420d692d2d3939fc4240fbb8b","modified":1483423484549},{"_id":"public/2016/12/24/HTTP的构成/index.html","hash":"23c31c9e1b2fb0cac9dc8b9fecfc26469548401c","modified":1483423484549},{"_id":"public/2016/12/03/hexo爬过的坑/index.html","hash":"33b64f955082298dd7c88f270b64e23b2c03e301","modified":1483423484549},{"_id":"public/2016/11/25/RN使用方式/index.html","hash":"7e2ea05842fe6a0eb57168a406b65ed65591190c","modified":1483423484549},{"_id":"public/2016/11/25/RN使用技巧/index.html","hash":"82f9ed53096dcb9d2738ff81f69687e2f4a4f2db","modified":1483423484549},{"_id":"public/2016/11/17/KVO/index.html","hash":"6ff3c2d43adec5af690c5f301e67ae85e9f4238f","modified":1483423484549},{"_id":"public/2016/11/11/Effective_oc2笔记/index.html","hash":"297685115bf948fe76f4442c2eeb3b5b87c13476","modified":1483423484550},{"_id":"public/2016/11/01/runloop/index.html","hash":"9f31fd31e1a265b792e8fd32e66ac69623ccb4c7","modified":1483423484550},{"_id":"public/2016/11/01/iOS多线程学习/index.html","hash":"a2d9b74f42dfc2b072ec66e349cba1d25ae03fee","modified":1483423484550},{"_id":"public/2016/10/17/打包静态库/index.html","hash":"92c44931e2d3d29e95b291f16cff6c41f9d6c5d4","modified":1483423484550},{"_id":"public/2016/10/13/storyboard基础/index.html","hash":"a7cf16c4a6dda2fd7cbbad55cd655bec3f75ac5f","modified":1483423484550},{"_id":"public/2016/09/28/oc新特性/index.html","hash":"b4014c3d482f12d7fa8da094237a4732bcf52333","modified":1483423484550},{"_id":"public/2016/09/23/Xcode的使用/index.html","hash":"e9210815778ffcbd03088433cdc0c3eac73155a1","modified":1483423484550},{"_id":"public/2016/09/22/Nodejs学习笔记/index.html","hash":"41b648d7946d6b5cb94a67cda37e31cb3a57b23a","modified":1483423484550},{"_id":"public/2016/09/21/lldb调试方法/index.html","hash":"f503a816a8e624b303f44c4b5a72cbd5a4e31fb1","modified":1483423484550},{"_id":"public/2016/09/18/Scrollview使用详解/index.html","hash":"98c165404d090a452320305dc6ef9584bed6a032","modified":1483423484550},{"_id":"public/2016/09/13/NSNotification基本使用/index.html","hash":"9e1426561e7af8bd0b92967f9c9c273defc6d2d1","modified":1483423484550},{"_id":"public/2016/09/12/UILabel的高度计算/index.html","hash":"905f12dcbf620d9c4f38ce028610b269dfe287cb","modified":1483423484550},{"_id":"public/2016/09/09/JavaScript基本语法/index.html","hash":"604c8f9a1e21acf381fc54e13dd6f51047340ff2","modified":1483423484550},{"_id":"public/2016/09/08/NSLayoutConstraint/index.html","hash":"813747d3ecebe99b2578fdd606bf525a7924ca24","modified":1483423484550},{"_id":"public/2016/09/07/oc中的枚举/index.html","hash":"b1eb54f8dfb44e6818f80f947539f4363d87dcc2","modified":1483423484550},{"_id":"public/2016/09/05/IPhone6全屏黑边处理/index.html","hash":"e5e9cf95e1daf3fe4b9a38906b1d4aa827704ab9","modified":1483423484550},{"_id":"public/2016/09/05/UIGestureRecognizer/index.html","hash":"deb79d04648d5b12272da3e96a68f8214624a68e","modified":1483423484550},{"_id":"public/2016/09/03/ios响应事件/index.html","hash":"8c4e09b3f5d4fbae7668c8b31460045944b0df12","modified":1483423484550},{"_id":"public/2016/09/02/CALayer的transform属性/index.html","hash":"9755a7695cb8a2ff2cde7de8f28bf1032c52f8de","modified":1483423484550},{"_id":"public/2016/09/01/Block基础/index.html","hash":"7a5b5bfe7a35885f653fbafbc207e33ceb4aae0a","modified":1483423484550},{"_id":"public/2016/08/30/UITableView基础/index.html","hash":"09653b98729549b6fc7a5358d8179a6536dc662e","modified":1483423484551},{"_id":"public/2016/08/29/UIButton基础/index.html","hash":"74d86742315f89f0b227d597338428e75a08423f","modified":1483423484551},{"_id":"public/2016/08/27/git技巧/index.html","hash":"a30fd0b4f5a91cb3891c46f745688cf25767feb0","modified":1483423484551},{"_id":"public/2016/08/26/初识Provisioning_Profile/index.html","hash":"415fc1afa7a2eab2ee67a4fd8279384dd8a002c9","modified":1483423484551},{"_id":"public/2016/08/26/UITableview自适应高度/index.html","hash":"09a58429c57aac3a2177a966a1d75a5b36a7bec2","modified":1483423484551},{"_id":"public/2016/08/23/runtime应用/index.html","hash":"2258e2ed05ef873654357e79909f8647a7802063","modified":1483423484551},{"_id":"public/2016/08/23/python_常用內建模块/index.html","hash":"b0a8e707ecf8d4142ecb0ef987936a239a74581b","modified":1483423484551},{"_id":"public/2016/08/22/runtime原理/index.html","hash":"e46c6fae5dc1eaf92d3ec9a71f9d8f47c995e5ee","modified":1483423484551},{"_id":"public/2016/08/20/python_正则表达式/index.html","hash":"82153b004f372382eebac41764ec564d024bf7d3","modified":1483423484551},{"_id":"public/2016/08/18/python_进程与线程/index.html","hash":"fc0d1ebc2590901812db16206eeea8d5b183039f","modified":1483423484551},{"_id":"public/2016/08/16/ios动画/index.html","hash":"1352b21617ccbc6808778cc4aec66b78b1393d8c","modified":1483423484551},{"_id":"public/2016/08/15/python_IO编程/index.html","hash":"a7dc2397786b3577adb5499229a4cfa13111fbfc","modified":1483423484551},{"_id":"public/2016/08/12/CALayer学习小结/index.html","hash":"cb23c5c787cf46b9454e348216f1b37cb8528151","modified":1483423484551},{"_id":"public/2016/08/11/删除storyboard/index.html","hash":"616288d6ae5f5954e52045d5b8d43db2e8aaa32a","modified":1483423484551},{"_id":"public/2016/08/10/xib设置border/index.html","hash":"7a6122e0228b32d5c694ac1044d425001c4f613a","modified":1483423484551},{"_id":"public/2016/08/10/python_面向对象高级编程/index.html","hash":"b459a41b45d49d5e433baf768cc2c1172ddf4c2a","modified":1483423484551},{"_id":"public/2016/08/09/python_模块/index.html","hash":"f49a8284c7fb2ee10a325d94679e9fc00d23e64c","modified":1483423484551},{"_id":"public/2016/08/09/python_面向对象编程/index.html","hash":"3185286429e9c5401cb178024adc4745cf11b756","modified":1483423484552},{"_id":"public/2016/08/08/python_高级特性/index.html","hash":"a918cdd522ea39706a1590ac2a6e1b02f58558c0","modified":1483423484552},{"_id":"public/2016/08/08/python_函数式编程/index.html","hash":"5186dc0b1f8137949d409d4d22b529767e1ea25e","modified":1483423484552},{"_id":"public/2016/08/07/python语法/index.html","hash":"e426cdc97fd43cd1d51228353a27c5bddeba49e3","modified":1483423484552},{"_id":"public/2016/08/07/python_函数/index.html","hash":"7c84f3420953ea922d939f5a5f367d0c8e73b761","modified":1483423484552},{"_id":"public/2016/08/05/UICollectionView/index.html","hash":"5d2353a67f8605fcaafb5334210067c96da971d3","modified":1483423484552},{"_id":"public/2016/08/02/GCD队列/index.html","hash":"779c666dfd3a4bede2279ce907f285be3e97c876","modified":1483424512771},{"_id":"public/2016/07/31/图解TCP_IP/index.html","hash":"3f4539fb6a386a6d87c0a969c442e3ce377826f8","modified":1483423484552},{"_id":"public/2016/07/31/ios编程（第四版/index.html","hash":"bb2f15bc1cfd377a80fb63e59df50277729c00b3","modified":1483423484552},{"_id":"public/2016/07/31/objectice-c/index.html","hash":"a7e09fec86aa1c06e73cc740c7af310b79bca293","modified":1483423484552},{"_id":"public/2016/07/30/重新开始/index.html","hash":"55be08efc23894b6411b61a18506a41135fdc092","modified":1483423484552},{"_id":"public/2016/07/29/hello-world/index.html","hash":"2451d6d0c3f4928018a090a2a034131796cf1cf3","modified":1483423484552},{"_id":"public/categories/iOS/index.html","hash":"62488f93ba24229074a31d72979435cebe09628e","modified":1483423484552},{"_id":"public/categories/iOS/page/2/index.html","hash":"bbfd5824695df554e656d2dd379b36f8cba5645a","modified":1483423484552},{"_id":"public/categories/iOS/page/3/index.html","hash":"9edf2620991c1c7e321485be694744d972126658","modified":1483423484552},{"_id":"public/categories/iOS/page/4/index.html","hash":"1f84f988f09b1edbf32c826f6a09a5add8151106","modified":1483423484552},{"_id":"public/categories/python/index.html","hash":"620275749cbc5441176db04484f72fb3149517ac","modified":1483423484552},{"_id":"public/archives/index.html","hash":"2f90a8e140a2aad931ad45b704428f8a1beb518f","modified":1483423484552},{"_id":"public/archives/page/2/index.html","hash":"188ea71c47a62302b8587a19b396810e7264eed1","modified":1483423484553},{"_id":"public/archives/page/3/index.html","hash":"4b249278bd0aaf4683bb71d4258419faaeb476e3","modified":1483423484553},{"_id":"public/archives/page/4/index.html","hash":"2de9187caa75644e4d8efa2eb5f931bcb0b0c3aa","modified":1483423484553},{"_id":"public/archives/page/5/index.html","hash":"84c16cf78ffd8a6bd2c5f74ba5cadd8a5bbd2aff","modified":1483423484553},{"_id":"public/archives/page/6/index.html","hash":"e7697d30a70ca6b1ff2b1ab4e6a396875de431cb","modified":1483423484553},{"_id":"public/archives/2016/index.html","hash":"cbcf002a415a87a82efa3cde06dc96104791cf63","modified":1483423484553},{"_id":"public/archives/2016/page/2/index.html","hash":"fa7ecd4a454ab4092cd52e652614dee83175ecaa","modified":1483423484553},{"_id":"public/archives/2016/page/3/index.html","hash":"5b11d4bc1bcd07236d21d8bbc34288bf948d6656","modified":1483423484553},{"_id":"public/archives/2016/page/4/index.html","hash":"4fbfe4e5d0f8779565a590412452f333936be310","modified":1483423484553},{"_id":"public/archives/2016/page/5/index.html","hash":"05089a73610fdd3efd0d5ff3783bf27bc293fe75","modified":1483423484553},{"_id":"public/archives/2016/page/6/index.html","hash":"f272a580c8c6b4649f81475eb202d26aa04c9884","modified":1483423484553},{"_id":"public/archives/2016/07/index.html","hash":"d494ce52fd8f814124472599e5eae25c121f3e8e","modified":1483423484553},{"_id":"public/archives/2016/08/index.html","hash":"f401cdfaf92e503bb3643ea2dab9f130baec12db","modified":1483423484553},{"_id":"public/archives/2016/08/page/2/index.html","hash":"67672a0d77178a02bafe411d912a7e7b3f24119c","modified":1483423484553},{"_id":"public/archives/2016/08/page/3/index.html","hash":"0d8addcf28feb42d2a73f6861b7d66378c19892d","modified":1483423484553},{"_id":"public/archives/2016/09/index.html","hash":"f49eec9144a12006cc75f4d44bfde79db4a87b3f","modified":1483423484553},{"_id":"public/archives/2016/09/page/2/index.html","hash":"dcddc8b8a19e4038425c4f291f5767eee29ad578","modified":1483423484553},{"_id":"public/archives/2016/10/index.html","hash":"4ec77d968fb3b625e790100d6a32343241df9bf8","modified":1483423484553},{"_id":"public/archives/2016/11/index.html","hash":"86e844bd8b68f05eff4cbb031c2af9a29f31f2f3","modified":1483423484553},{"_id":"public/archives/2016/12/index.html","hash":"3c849bdd1c1f23b5cfc31212cf4017186c29bcf4","modified":1483423484553},{"_id":"public/index.html","hash":"36bed642f27bf1b7227382021a43ff793f344cae","modified":1483423484553},{"_id":"public/page/2/index.html","hash":"5cd8584fb21ad25a96de0c3ded199b02daa06a4e","modified":1483423484553},{"_id":"public/page/3/index.html","hash":"de82220b13b7d255d3d654d13ea6f621021f3e51","modified":1483423484553},{"_id":"public/page/4/index.html","hash":"aecebc46e1e713d01841b00130d15444e6456471","modified":1483423484553},{"_id":"public/page/5/index.html","hash":"444a5f1bed3ed477c79a5ad05d749251b9b5e0e7","modified":1483423484553},{"_id":"public/page/6/index.html","hash":"f25ebf97415ea16810be0440fa3ecb6f70e4561b","modified":1483423484554},{"_id":"public/tag/Animation/index.html","hash":"91b0fe8ad6e32ef22afa14abec239b0f65fcc6fa","modified":1483423484554},{"_id":"public/tag/UI/index.html","hash":"cc620a73932a16086c4e524f63ae36b0f6c16d63","modified":1483423484554},{"_id":"public/tag/学习笔记/index.html","hash":"d35379305ab0c1cbf48bed85a1607444b2d06313","modified":1483423484554},{"_id":"public/tag/学习笔记/page/2/index.html","hash":"8ddf0321ed1bf84ff6281909065ff998560e0c19","modified":1483423484554},{"_id":"public/tag/Xcode/index.html","hash":"7c8e515ae4d8b8a4e5a72236f4447979f5e7ebb4","modified":1483423484554},{"_id":"public/tag/Objective-C/index.html","hash":"5c093be63707cae1a34b64994920b17201700661","modified":1483423484554},{"_id":"public/tag/爬坑/index.html","hash":"e63ce60d09150c84c7fcac02cf9a804fefc75586","modified":1483423484554},{"_id":"public/tag/基本控件/index.html","hash":"74423c05d294d436eac1419fa0ec3d0a640aa534","modified":1483423484554},{"_id":"public/tag/Runtime/index.html","hash":"b422dc8e2b2bebe31d43a50deff7a2d5c97f9a4b","modified":1483423484554},{"_id":"public/tag/学习笔记/page/3/index.html","hash":"56056a9e98469e1314438df6c9322f5f734a57bd","modified":1483423484566},{"_id":"public/tag/Principle/index.html","hash":"255feac6baff3af1e165f48e57ed4dc05c016d43","modified":1483423484566},{"_id":"public/2016/12/28/EventLoop/index.html","hash":"90b5b38ce5979eb1f467c7bb6c8df1fe8df80e40","modified":1483423484567},{"_id":"public/2016/07/31/coding总结/index.html","hash":"ca0c7c9d22c0414f9ae230dbb6ffff3ce5516336","modified":1483423484567},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1483423484575},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483423484576},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483423484576},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483423484576},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483423484576},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483423484576},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483423484576},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483423484576},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483423484577},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1483423484577},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1483423484577},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1483423484578},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1483423484578},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1483423484578},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1483423484578},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483423484578},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483423484578},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483423484578},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483423484578},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483423484578},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483423484578},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1483423484578},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1483423484578},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483423484579},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1483423485519},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1483423485526},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1483423485527},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1483423485538},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1483423485538},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1483423485538},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1483423485538},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1483423485538},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1483423485538},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1483423485538},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1483423485538},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1483423485538},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1483423485538},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1483423485538},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1483423485538},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1483423485538},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1483423485538},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1483423485538},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1483423485538},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1483423485538},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1483423485538},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483423485538},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1483423485538},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1483423485538},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1483423485538},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483423485538},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483423485538},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483423485538},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483423485538},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483423485538},{"_id":"public/css/main.css","hash":"e52e5fc0938a7fd727ae3a342313abf99e677ffa","modified":1483423485538},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1483423485538},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1483423485539},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1483423485539},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483423485539},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1483423485539},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483423485539},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1483423485539},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1483423485539},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1483423485539},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1483423485539},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1483423485546}],"Category":[{"name":"iOS","_id":"cixh41do400047hzg9ejqyy6e"},{"name":"计算机","_id":"cixh41dot000k7hzgmzmtxw9l"},{"name":"Javascript","_id":"cixh41doy000s7hzgm623ugqg"},{"name":"JavaScript","_id":"cixh41dph000z7hzgyqpdx899"},{"name":"React-Native","_id":"cixh41dpm00167hzg6m72rvqo"},{"name":"无处置放","_id":"cixh41dqm00287hzgbsf5nlz4"},{"name":"Git","_id":"cixh41dqy002h7hzgomxrz4av"},{"name":"python","_id":"cixh41drm003c7hzgk6p1xad3"}],"Data":[],"Page":[{"title":"about","date":"2016-07-29T15:19:36.000Z","type":"about","_content":"\n欢迎来到我的空间。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-07-29 23:19:36\ntype: \"about\"\n\n---\n\n欢迎来到我的空间。","updated":"2016-12-03T08:44:27.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cixh41dnr00007hzg5j15t1gz","content":"<p>欢迎来到我的空间。</p>\n","excerpt":"","more":"<p>欢迎来到我的空间。</p>\n"},{"title":"categories","date":"2016-07-29T15:21:33.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-29 23:21:33\ntype: \"categories\"\n\n---\n","updated":"2016-12-03T08:44:27.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cixh41dwg004n7hzgm3kf58nz","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-07-29T10:08:03.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-29 18:08:03\ntype: \"tags\"\n\n\n---\n\n","updated":"2016-12-03T08:44:27.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cixh41dwk004p7hzg94milzi3","content":"","excerpt":"","more":""},{"title":"NodeJs Web开发","date":"2016-10-05T02:07:12.000Z","categories":"JavaScript","tags":["学习笔记","NodeJs"],"_content":"\n本篇是NodeJs的学习笔记，参考自[廖雪峰的博客](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501579966ab03decb0dd246e1a6799dd653a15e1b000)\n\n<!--more-->\n\n## koa\nkoa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。和koa 1相比，koa2完全使用Promise并配合`async`来实现异步。\n\n### koa入门\n#### 创建koa2工程\n首先，创建一个目录文件夹`hello-koa`,然后创建`app.js`,写入：\n\n```javascript\n// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\nconst Koa = require('koa');\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\n\n```javascript\nasync (ctx, next) => {\n    await next();\n    // 设置response的Content-Type:\n    ctx.response.type = 'text/html';\n    // 设置response的内容:\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n}\n```\n\n其中，参数`ctx`是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，`next`是koa传入的将要处理的下一个异步函数。 \n上面的异步函数中，我们首先用`await next();`处理下一个异步函数，然后，设置response的Content-Type和内容。 \n由`async`标记的函数称为异步函数，在异步函数中，可以用`await`调用另一个异步函数，这两个关键字将在ES7中引入。\n\n那么koa这个包怎么装，`app.js`才能正常导入它？\n在`hello-koa`这个目录下创建一个`package.json`，这个文件描述了我们的`hello-koa`工程会用到哪些包:\n\n```javascript\n{\n\t\"name\": \"hello-koa2\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Hello Koa 2 example with async\",\n    \"main\": \"start.js\",\n    \"scripts\": {\n        \"start\": \"node start.js\"\n    },\n    \"dependencies\": {\n        \"babel-core\": \"6.13.2\",\n        \"babel-polyfill\": \"6.13.0\",\n        \"babel-preset-es2015-node6\": \"0.3.0\",\n        \"babel-preset-stage-3\": \"6.5.0\",\n        \"koa\": \"2.0.0\"\n    }\n}\n```\n\n其中，`dependencies`描述了我们的工程依赖的包以及版本号。然后，我们在`hello-koa`目录下执行`npm install`就可以把所需包以及依赖包一次性全部装好。\n注意，任何时候都可以直接删除整个`node_modules`目录，因为用`npm install`命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。\n\n另外，这里的`\"main\": \"start.js\"`将在下面讲到。\n\n但是由于现在的Node.js只支持ES6，不支持ES7，无法识别新的`async`语法。需要使用Babel把ES7代码“转换”为ES6代码。\n\n#### Bebel\nBabel是一个JavaScript编写的转码器，它可以把高版本的JavaScript代码转换成低版本的JavaScript代码，并保持逻辑不变，这样就可以在低版本的JavaScript环境下运行。\n\n例如，我们用ES7编写的JavaScript代码，用Babel转换成ES6以后，就可以在Node环境下执行。如果某些JavaScript代码需要在更低版本的环境下执行，例如IE 6，就可以用Babel转换成ES5的代码。\n\n用Babel转码时，需要指定presets和plugins。\npresets是规则，我们`stage-3`规则，`stage-3`规则是ES7的stage 0~3的第3阶段规则。\nplugins可以指定插件来定制转码过程，一个preset就包含了一组指定的plugin。\n\n我们编写一个`start.js`文件，在这个文件中，先加载`babel-core/register`，再加载`app.js`：\n\n```javascript\nvar register = require('babel-core/register');\n\nregister({\n    presets: ['stage-3']\n});\n\nrequire('./app.js');\n```\n\n现在我们在`hello-koa`目录下又多了一个`start.js`文件。在`npm install`后，可以直接执行`node start.js`也可以用`npm start`启动。`npm start`命令会让npm执行定义在`package.json`文件中的`start`对应命令\n\n为什么先加载`babel-core/register`，再加载`app.js`，魔法就会生效？原因是第一个`require()`是Node正常加载`babel-core/register`的过程，然后，Babel会用自己的`require()`替换掉Node的`require()`，随后用`require()`加载的所有代码均会被Babel自动转码后再加载。\n\n#### koa middleware\nkoa的核心代码是：\n\n```javascript\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n\n每收到一个http请求，koa就会调用通过`app.use()`注册的`async`函数，并传入`ctx`和`next`参数。\n\n我们可以对`ctx`操作，并设置返回内容。但是为什么要调用`await next()`？\n原因是`koa`把很多`async`函数组成一个处理链，每个`async`函数都可以做一些自己的事情，然后用`await next()`来调用下一个`async`函数。我们把每个`async`函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\n\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\n\n```javascript\napp.use(async (ctx, next) => {\n    console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\n    await next(); // 调用下一个middleware\n});\n\napp.use(async (ctx, next) => {\n    const start = new Date().getTime(); // 当前时间\n    await next(); // 调用下一个middleware\n    const ms = new Date().getTime() - start; // 耗费时间\n    console.log(`Time: ${ms}ms`); // 打印耗费时间\n});\n\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n\nmiddleware的顺序很重要，也就是调用`app.use()`的顺序决定了middleware的顺序。如果一个middleware没有调用`await next()`，后续的middleware将不再执行。\n\n### 处理URL\n前面的工程中，没有对URL进行判定，实际上，一个网站，对于不同的网页`request`应该返回不同的`response`。譬如像这样：\n\n```javacsript\napp.use(async (ctx, next) => {\n    if (ctx.request.path === '/') {\n        ctx.response.body = 'index page';\n    } else {\n        await next();\n    }\n});\n```\n\n但是实际使用中，不能一个个去判断`request.path`，应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数。\n\n#### koa-router\n使用`koa-router`这个中间件，来处理URL映射。\n\n先在`package.json`中添加依赖项，并`npm install`:\n\n```javascript\n\"koa-router\": \"7.0.0\"\n```\n\n接下来，我们修改`app.js`，使用`koa-router`来处理URL：\n\n```javascript\nconst Koa = require('koa');\n\n// 注意require('koa-router')返回的是函数:\nconst router = require('koa-router')();\n\nconst app = new Koa();\n\n// log request URL:\napp.use(async (ctx, next) => {\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n    await next();\n});\n\n// add url-route:\nrouter.get('/hello/:name', async (ctx, next) => {\n    var name = ctx.params.name;\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n});\n\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = '<h1>Index</h1>';\n});\n\n// add router middleware:\napp.use(router.routes());\n\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n注意导入`koa-router`的语句最后的`()`是函数调用。\n\n#### 处理post请求\n用`router.get('/path', async fn)`处理的是get请求。如果要处理post请求，可以用`router.post('/path', async fn)`。\n\npost请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！所以，又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到`ctx.request.body`中。\n\n`koa-bodyparser`可以实现解析功能，我们在`package.json`中添加依赖项：\n\n```javascript\n\"koa-bodyparser\": \"3.2.0\"\n```\n\n下面，修改`app.js`，引入`koa-bodyparser`：\n\n```javascript\nconst bodyParser = require('koa-bodyparser');\n```\n\n在合适的位置加上注册，由于middleware的顺序很重要，这个`koa-bodyparser`必须在`router`之前被注册到`app`对象上:\n\n```javacsript\napp.use(bodyParser());\n```\n\n现在我们就可以处理post请求了。写一个简单的登录表单：\n\n```javascript\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = `<h1>Index</h1>\n        <form action=\"/signin\" method=\"post\">\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\n            <p>Password: <input name=\"password\" type=\"password\"></p>\n            <p><input type=\"submit\" value=\"Submit\"></p>\n        </form>`;\n});\n\nrouter.post('/signin', async (ctx, next) => {\n    var\n        name = ctx.request.body.name || '',\n        password = ctx.request.body.password || '';\n    console.log(`signin with name: ${name}, password: ${password}`);\n    if (name === 'koa' && password === '12345') {\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n    } else {\n        ctx.response.body = `<h1>Login failed!</h1>\n        <p><a href=\"/\">Try again</a></p>`;\n    }\n});\n```\n\n用`var name = ctx.request.body.name || ''`拿到表单的`name`字段，如果该字段不存在，默认值设置为`''`。\n\n#### 重构\n`app.js`是工程的入口，不可能将所有的`post``get`注册以及回调都放在该文件内，可以自己创建一个`controllers `文件夹，将各个注册及回调放在其中，譬如新建一个有关登录的`index.js`:\n\n```javascript\nvar fn_index = async (ctx, next) => {\n    ctx.response.body = `<h1>Index</h1>\n        <form action=\"/signin\" method=\"post\">\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\n            <p>Password: <input name=\"password\" type=\"password\"></p>\n            <p><input type=\"submit\" value=\"Submit\"></p>\n        </form>`;\n};\n\nvar fn_signin = async (ctx, next) => {\n    var\n        name = ctx.request.body.name || '',\n        password = ctx.request.body.password || '';\n    console.log(`signin with name: ${name}, password: ${password}`);\n    if (name === 'koa' && password === '12345') {\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n    } else {\n        ctx.response.body = `<h1>Login failed!</h1>\n        <p><a href=\"/\">Try again</a></p>`;\n    }\n};\n\nmodule.exports = {\n    'GET /': fn_index,\n    'POST /signin': fn_signin\n};\n```\n\n这个`index.js`通过`module.exports`把两个URL处理函数暴露出来。\n\n那么现在应该要做的是在`app.js`中，让它自动扫描`controllers`目录，找到所有`js`文件，导入，然后注册每个URL：\n\n```javascript\n// 先导入fs模块，然后用readdirSync列出文件\n// 这里可以用sync是因为启动时只运行一次，不存在性能问题:\nvar files = fs.readdirSync(__dirname + '/controllers');\n\n// 过滤出.js文件:\nvar js_files = files.filter((f)=>{\n    return f.endsWith('.js');\n}, files);\n\n// 处理每个js文件:\nfor (var f of js_files) {\n    console.log(`process controller: ${f}...`);\n    // 导入js文件:\n    let mapping = require(__dirname + '/controllers/' + f);\n    for (var url in mapping) {\n        if (url.startsWith('GET ')) {\n            // 如果url类似\"GET xxx\":\n            var path = url.substring(4);\n            router.get(path, mapping[url]);\n            console.log(`register URL mapping: GET ${path}`);\n        } else if (url.startsWith('POST ')) {\n            // 如果url类似\"GET xxx\":\n            var path = url.substring(5);\n            router.post(path, mapping[url]);\n            console.log(`register URL mapping: POST ${path}`);\n        } else {\n            // 无效的URL:\n            console.log(`invalid URL: ${url}`);\n        }\n    }\n}\n```\n\n#### Controller Middleware\n最后，我们把扫描`controllers`目录和创建`router`的代码从`app.js`中提取出来，作为一个简单的`middleware`使用，命名为`controller.js`：\n\n```javascript\nconst fs = require('fs');\n\nfunction addMapping(router, mapping) {\n    ...\n}\n\nfunction addControllers(router, dir) {\n    ...\n}\n\nmodule.exports = function (dir) {\n    let\n        controllers_dir = dir || 'controllers', // 如果不传参数，扫描目录默认为'controllers'\n        router = require('koa-router')();\n    addControllers(router, controllers_dir);\n    return router.routes();\n};\n```\n\n这样一来，我们在`app.js`的代码又简化了：\n\n```javascript\n...\n\n// 导入controller middleware:\nconst controller = require('./controller');\n\n...\n\n// 使用middleware:\napp.use(controller());\n\n...\n```\n\n经过重新整理后的工程`url2-koa`目前具备非常好的模块化，所有处理URL的函数按功能组存放在`controllers`目录，今后我们也只需要不断往这个目录下加东西就可以了，`app.js`保持不变。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"备份/NodeJs_Web.md","raw":"title: NodeJs Web开发\ndate: 2016/10/5 10:07:12  \ncategories: JavaScript\ntags:\n\t- 学习笔记\n\t- NodeJs\n\n---\n\n本篇是NodeJs的学习笔记，参考自[廖雪峰的博客](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501579966ab03decb0dd246e1a6799dd653a15e1b000)\n\n<!--more-->\n\n## koa\nkoa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。和koa 1相比，koa2完全使用Promise并配合`async`来实现异步。\n\n### koa入门\n#### 创建koa2工程\n首先，创建一个目录文件夹`hello-koa`,然后创建`app.js`,写入：\n\n```javascript\n// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\nconst Koa = require('koa');\n\n// 创建一个Koa对象表示web app本身:\nconst app = new Koa();\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\n\n```javascript\nasync (ctx, next) => {\n    await next();\n    // 设置response的Content-Type:\n    ctx.response.type = 'text/html';\n    // 设置response的内容:\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n}\n```\n\n其中，参数`ctx`是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，`next`是koa传入的将要处理的下一个异步函数。 \n上面的异步函数中，我们首先用`await next();`处理下一个异步函数，然后，设置response的Content-Type和内容。 \n由`async`标记的函数称为异步函数，在异步函数中，可以用`await`调用另一个异步函数，这两个关键字将在ES7中引入。\n\n那么koa这个包怎么装，`app.js`才能正常导入它？\n在`hello-koa`这个目录下创建一个`package.json`，这个文件描述了我们的`hello-koa`工程会用到哪些包:\n\n```javascript\n{\n\t\"name\": \"hello-koa2\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Hello Koa 2 example with async\",\n    \"main\": \"start.js\",\n    \"scripts\": {\n        \"start\": \"node start.js\"\n    },\n    \"dependencies\": {\n        \"babel-core\": \"6.13.2\",\n        \"babel-polyfill\": \"6.13.0\",\n        \"babel-preset-es2015-node6\": \"0.3.0\",\n        \"babel-preset-stage-3\": \"6.5.0\",\n        \"koa\": \"2.0.0\"\n    }\n}\n```\n\n其中，`dependencies`描述了我们的工程依赖的包以及版本号。然后，我们在`hello-koa`目录下执行`npm install`就可以把所需包以及依赖包一次性全部装好。\n注意，任何时候都可以直接删除整个`node_modules`目录，因为用`npm install`命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。\n\n另外，这里的`\"main\": \"start.js\"`将在下面讲到。\n\n但是由于现在的Node.js只支持ES6，不支持ES7，无法识别新的`async`语法。需要使用Babel把ES7代码“转换”为ES6代码。\n\n#### Bebel\nBabel是一个JavaScript编写的转码器，它可以把高版本的JavaScript代码转换成低版本的JavaScript代码，并保持逻辑不变，这样就可以在低版本的JavaScript环境下运行。\n\n例如，我们用ES7编写的JavaScript代码，用Babel转换成ES6以后，就可以在Node环境下执行。如果某些JavaScript代码需要在更低版本的环境下执行，例如IE 6，就可以用Babel转换成ES5的代码。\n\n用Babel转码时，需要指定presets和plugins。\npresets是规则，我们`stage-3`规则，`stage-3`规则是ES7的stage 0~3的第3阶段规则。\nplugins可以指定插件来定制转码过程，一个preset就包含了一组指定的plugin。\n\n我们编写一个`start.js`文件，在这个文件中，先加载`babel-core/register`，再加载`app.js`：\n\n```javascript\nvar register = require('babel-core/register');\n\nregister({\n    presets: ['stage-3']\n});\n\nrequire('./app.js');\n```\n\n现在我们在`hello-koa`目录下又多了一个`start.js`文件。在`npm install`后，可以直接执行`node start.js`也可以用`npm start`启动。`npm start`命令会让npm执行定义在`package.json`文件中的`start`对应命令\n\n为什么先加载`babel-core/register`，再加载`app.js`，魔法就会生效？原因是第一个`require()`是Node正常加载`babel-core/register`的过程，然后，Babel会用自己的`require()`替换掉Node的`require()`，随后用`require()`加载的所有代码均会被Babel自动转码后再加载。\n\n#### koa middleware\nkoa的核心代码是：\n\n```javascript\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n\n每收到一个http请求，koa就会调用通过`app.use()`注册的`async`函数，并传入`ctx`和`next`参数。\n\n我们可以对`ctx`操作，并设置返回内容。但是为什么要调用`await next()`？\n原因是`koa`把很多`async`函数组成一个处理链，每个`async`函数都可以做一些自己的事情，然后用`await next()`来调用下一个`async`函数。我们把每个`async`函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\n\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\n\n```javascript\napp.use(async (ctx, next) => {\n    console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\n    await next(); // 调用下一个middleware\n});\n\napp.use(async (ctx, next) => {\n    const start = new Date().getTime(); // 当前时间\n    await next(); // 调用下一个middleware\n    const ms = new Date().getTime() - start; // 耗费时间\n    console.log(`Time: ${ms}ms`); // 打印耗费时间\n});\n\napp.use(async (ctx, next) => {\n    await next();\n    ctx.response.type = 'text/html';\n    ctx.response.body = '<h1>Hello, koa2!</h1>';\n});\n```\n\nmiddleware的顺序很重要，也就是调用`app.use()`的顺序决定了middleware的顺序。如果一个middleware没有调用`await next()`，后续的middleware将不再执行。\n\n### 处理URL\n前面的工程中，没有对URL进行判定，实际上，一个网站，对于不同的网页`request`应该返回不同的`response`。譬如像这样：\n\n```javacsript\napp.use(async (ctx, next) => {\n    if (ctx.request.path === '/') {\n        ctx.response.body = 'index page';\n    } else {\n        await next();\n    }\n});\n```\n\n但是实际使用中，不能一个个去判断`request.path`，应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数。\n\n#### koa-router\n使用`koa-router`这个中间件，来处理URL映射。\n\n先在`package.json`中添加依赖项，并`npm install`:\n\n```javascript\n\"koa-router\": \"7.0.0\"\n```\n\n接下来，我们修改`app.js`，使用`koa-router`来处理URL：\n\n```javascript\nconst Koa = require('koa');\n\n// 注意require('koa-router')返回的是函数:\nconst router = require('koa-router')();\n\nconst app = new Koa();\n\n// log request URL:\napp.use(async (ctx, next) => {\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\n    await next();\n});\n\n// add url-route:\nrouter.get('/hello/:name', async (ctx, next) => {\n    var name = ctx.params.name;\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\n});\n\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = '<h1>Index</h1>';\n});\n\n// add router middleware:\napp.use(router.routes());\n\napp.listen(3000);\nconsole.log('app started at port 3000...');\n```\n\n注意导入`koa-router`的语句最后的`()`是函数调用。\n\n#### 处理post请求\n用`router.get('/path', async fn)`处理的是get请求。如果要处理post请求，可以用`router.post('/path', async fn)`。\n\npost请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！所以，又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到`ctx.request.body`中。\n\n`koa-bodyparser`可以实现解析功能，我们在`package.json`中添加依赖项：\n\n```javascript\n\"koa-bodyparser\": \"3.2.0\"\n```\n\n下面，修改`app.js`，引入`koa-bodyparser`：\n\n```javascript\nconst bodyParser = require('koa-bodyparser');\n```\n\n在合适的位置加上注册，由于middleware的顺序很重要，这个`koa-bodyparser`必须在`router`之前被注册到`app`对象上:\n\n```javacsript\napp.use(bodyParser());\n```\n\n现在我们就可以处理post请求了。写一个简单的登录表单：\n\n```javascript\nrouter.get('/', async (ctx, next) => {\n    ctx.response.body = `<h1>Index</h1>\n        <form action=\"/signin\" method=\"post\">\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\n            <p>Password: <input name=\"password\" type=\"password\"></p>\n            <p><input type=\"submit\" value=\"Submit\"></p>\n        </form>`;\n});\n\nrouter.post('/signin', async (ctx, next) => {\n    var\n        name = ctx.request.body.name || '',\n        password = ctx.request.body.password || '';\n    console.log(`signin with name: ${name}, password: ${password}`);\n    if (name === 'koa' && password === '12345') {\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n    } else {\n        ctx.response.body = `<h1>Login failed!</h1>\n        <p><a href=\"/\">Try again</a></p>`;\n    }\n});\n```\n\n用`var name = ctx.request.body.name || ''`拿到表单的`name`字段，如果该字段不存在，默认值设置为`''`。\n\n#### 重构\n`app.js`是工程的入口，不可能将所有的`post``get`注册以及回调都放在该文件内，可以自己创建一个`controllers `文件夹，将各个注册及回调放在其中，譬如新建一个有关登录的`index.js`:\n\n```javascript\nvar fn_index = async (ctx, next) => {\n    ctx.response.body = `<h1>Index</h1>\n        <form action=\"/signin\" method=\"post\">\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\n            <p>Password: <input name=\"password\" type=\"password\"></p>\n            <p><input type=\"submit\" value=\"Submit\"></p>\n        </form>`;\n};\n\nvar fn_signin = async (ctx, next) => {\n    var\n        name = ctx.request.body.name || '',\n        password = ctx.request.body.password || '';\n    console.log(`signin with name: ${name}, password: ${password}`);\n    if (name === 'koa' && password === '12345') {\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\n    } else {\n        ctx.response.body = `<h1>Login failed!</h1>\n        <p><a href=\"/\">Try again</a></p>`;\n    }\n};\n\nmodule.exports = {\n    'GET /': fn_index,\n    'POST /signin': fn_signin\n};\n```\n\n这个`index.js`通过`module.exports`把两个URL处理函数暴露出来。\n\n那么现在应该要做的是在`app.js`中，让它自动扫描`controllers`目录，找到所有`js`文件，导入，然后注册每个URL：\n\n```javascript\n// 先导入fs模块，然后用readdirSync列出文件\n// 这里可以用sync是因为启动时只运行一次，不存在性能问题:\nvar files = fs.readdirSync(__dirname + '/controllers');\n\n// 过滤出.js文件:\nvar js_files = files.filter((f)=>{\n    return f.endsWith('.js');\n}, files);\n\n// 处理每个js文件:\nfor (var f of js_files) {\n    console.log(`process controller: ${f}...`);\n    // 导入js文件:\n    let mapping = require(__dirname + '/controllers/' + f);\n    for (var url in mapping) {\n        if (url.startsWith('GET ')) {\n            // 如果url类似\"GET xxx\":\n            var path = url.substring(4);\n            router.get(path, mapping[url]);\n            console.log(`register URL mapping: GET ${path}`);\n        } else if (url.startsWith('POST ')) {\n            // 如果url类似\"GET xxx\":\n            var path = url.substring(5);\n            router.post(path, mapping[url]);\n            console.log(`register URL mapping: POST ${path}`);\n        } else {\n            // 无效的URL:\n            console.log(`invalid URL: ${url}`);\n        }\n    }\n}\n```\n\n#### Controller Middleware\n最后，我们把扫描`controllers`目录和创建`router`的代码从`app.js`中提取出来，作为一个简单的`middleware`使用，命名为`controller.js`：\n\n```javascript\nconst fs = require('fs');\n\nfunction addMapping(router, mapping) {\n    ...\n}\n\nfunction addControllers(router, dir) {\n    ...\n}\n\nmodule.exports = function (dir) {\n    let\n        controllers_dir = dir || 'controllers', // 如果不传参数，扫描目录默认为'controllers'\n        router = require('koa-router')();\n    addControllers(router, controllers_dir);\n    return router.routes();\n};\n```\n\n这样一来，我们在`app.js`的代码又简化了：\n\n```javascript\n...\n\n// 导入controller middleware:\nconst controller = require('./controller');\n\n...\n\n// 使用middleware:\napp.use(controller());\n\n...\n```\n\n经过重新整理后的工程`url2-koa`目前具备非常好的模块化，所有处理URL的函数按功能组存放在`controllers`目录，今后我们也只需要不断往这个目录下加东西就可以了，`app.js`保持不变。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","updated":"2016-12-03T08:44:27.000Z","path":"备份/NodeJs_Web.html","comments":1,"layout":"page","_id":"cixh41dwt004s7hzgb6ba7zgc","content":"<p>本篇是NodeJs的学习笔记，参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501579966ab03decb0dd246e1a6799dd653a15e1b000\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a></p>\n<a id=\"more\"></a>\n<h2 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h2><p>koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。和koa 1相比，koa2完全使用Promise并配合<code>async</code>来实现异步。</p>\n<h3 id=\"koa入门\"><a href=\"#koa入门\" class=\"headerlink\" title=\"koa入门\"></a>koa入门</h3><h4 id=\"创建koa2工程\"><a href=\"#创建koa2工程\" class=\"headerlink\" title=\"创建koa2工程\"></a>创建koa2工程</h4><p>首先，创建一个目录文件夹<code>hello-koa</code>,然后创建<code>app.js</code>,写入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个Koa对象表示web app本身:</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对于任何请求，app将调用该异步函数处理请求：</span></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在端口3000监听:</span></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'app started at port 3000...'</span>);</div></pre></td></tr></table></figure>\n<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    <span class=\"comment\">// 设置response的Content-Type:</span></div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    <span class=\"comment\">// 设置response的内容:</span></div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，参数<code>ctx</code>是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，<code>next</code>是koa传入的将要处理的下一个异步函数。<br>上面的异步函数中，我们首先用<code>await next();</code>处理下一个异步函数，然后，设置response的Content-Type和内容。<br>由<code>async</code>标记的函数称为异步函数，在异步函数中，可以用<code>await</code>调用另一个异步函数，这两个关键字将在ES7中引入。</p>\n<p>那么koa这个包怎么装，<code>app.js</code>才能正常导入它？<br>在<code>hello-koa</code>这个目录下创建一个<code>package.json</code>，这个文件描述了我们的<code>hello-koa</code>工程会用到哪些包:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"name\"</span>: <span class=\"string\">\"hello-koa2\"</span>,</div><div class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"Hello Koa 2 example with async\"</span>,</div><div class=\"line\">    <span class=\"string\">\"main\"</span>: <span class=\"string\">\"start.js\"</span>,</div><div class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node start.js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"babel-core\"</span>: <span class=\"string\">\"6.13.2\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-polyfill\"</span>: <span class=\"string\">\"6.13.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-preset-es2015-node6\"</span>: <span class=\"string\">\"0.3.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-preset-stage-3\"</span>: <span class=\"string\">\"6.5.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"koa\"</span>: <span class=\"string\">\"2.0.0\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<code>dependencies</code>描述了我们的工程依赖的包以及版本号。然后，我们在<code>hello-koa</code>目录下执行<code>npm install</code>就可以把所需包以及依赖包一次性全部装好。<br>注意，任何时候都可以直接删除整个<code>node_modules</code>目录，因为用<code>npm install</code>命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。</p>\n<p>另外，这里的<code>&quot;main&quot;: &quot;start.js&quot;</code>将在下面讲到。</p>\n<p>但是由于现在的Node.js只支持ES6，不支持ES7，无法识别新的<code>async</code>语法。需要使用Babel把ES7代码“转换”为ES6代码。</p>\n<h4 id=\"Bebel\"><a href=\"#Bebel\" class=\"headerlink\" title=\"Bebel\"></a>Bebel</h4><p>Babel是一个JavaScript编写的转码器，它可以把高版本的JavaScript代码转换成低版本的JavaScript代码，并保持逻辑不变，这样就可以在低版本的JavaScript环境下运行。</p>\n<p>例如，我们用ES7编写的JavaScript代码，用Babel转换成ES6以后，就可以在Node环境下执行。如果某些JavaScript代码需要在更低版本的环境下执行，例如IE 6，就可以用Babel转换成ES5的代码。</p>\n<p>用Babel转码时，需要指定presets和plugins。<br>presets是规则，我们<code>stage-3</code>规则，<code>stage-3</code>规则是ES7的stage 0~3的第3阶段规则。<br>plugins可以指定插件来定制转码过程，一个preset就包含了一组指定的plugin。</p>\n<p>我们编写一个<code>start.js</code>文件，在这个文件中，先加载<code>babel-core/register</code>，再加载<code>app.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> register = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-core/register'</span>);</div><div class=\"line\"></div><div class=\"line\">register(&#123;</div><div class=\"line\">    presets: [<span class=\"string\">'stage-3'</span>]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./app.js'</span>);</div></pre></td></tr></table></figure>\n<p>现在我们在<code>hello-koa</code>目录下又多了一个<code>start.js</code>文件。在<code>npm install</code>后，可以直接执行<code>node start.js</code>也可以用<code>npm start</code>启动。<code>npm start</code>命令会让npm执行定义在<code>package.json</code>文件中的<code>start</code>对应命令</p>\n<p>为什么先加载<code>babel-core/register</code>，再加载<code>app.js</code>，魔法就会生效？原因是第一个<code>require()</code>是Node正常加载<code>babel-core/register</code>的过程，然后，Babel会用自己的<code>require()</code>替换掉Node的<code>require()</code>，随后用<code>require()</code>加载的所有代码均会被Babel自动转码后再加载。</p>\n<h4 id=\"koa-middleware\"><a href=\"#koa-middleware\" class=\"headerlink\" title=\"koa middleware\"></a>koa middleware</h4><p>koa的核心代码是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>每收到一个http请求，koa就会调用通过<code>app.use()</code>注册的<code>async</code>函数，并传入<code>ctx</code>和<code>next</code>参数。</p>\n<p>我们可以对<code>ctx</code>操作，并设置返回内容。但是为什么要调用<code>await next()</code>？<br>原因是<code>koa</code>把很多<code>async</code>函数组成一个处理链，每个<code>async</code>函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个<code>async</code>函数。我们把每个<code>async</code>函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>\n<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>`</span>); <span class=\"comment\">// 打印URL</span></div><div class=\"line\">    <span class=\"keyword\">await</span> next(); <span class=\"comment\">// 调用下一个middleware</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(); <span class=\"comment\">// 当前时间</span></div><div class=\"line\">    <span class=\"keyword\">await</span> next(); <span class=\"comment\">// 调用下一个middleware</span></div><div class=\"line\">    <span class=\"keyword\">const</span> ms = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() - start; <span class=\"comment\">// 耗费时间</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Time: <span class=\"subst\">$&#123;ms&#125;</span>ms`</span>); <span class=\"comment\">// 打印耗费时间</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>middleware的顺序很重要，也就是调用<code>app.use()</code>的顺序决定了middleware的顺序。如果一个middleware没有调用<code>await next()</code>，后续的middleware将不再执行。</p>\n<h3 id=\"处理URL\"><a href=\"#处理URL\" class=\"headerlink\" title=\"处理URL\"></a>处理URL</h3><p>前面的工程中，没有对URL进行判定，实际上，一个网站，对于不同的网页<code>request</code>应该返回不同的<code>response</code>。譬如像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async (ctx, next) =&gt; &#123;</div><div class=\"line\">    if (ctx.request.path === &apos;/&apos;) &#123;</div><div class=\"line\">        ctx.response.body = &apos;index page&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        await next();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是实际使用中，不能一个个去判断<code>request.path</code>，应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数。</p>\n<h4 id=\"koa-router\"><a href=\"#koa-router\" class=\"headerlink\" title=\"koa-router\"></a>koa-router</h4><p>使用<code>koa-router</code>这个中间件，来处理URL映射。</p>\n<p>先在<code>package.json</code>中添加依赖项，并<code>npm install</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"koa-router\"</span>: <span class=\"string\">\"7.0.0\"</span></div></pre></td></tr></table></figure>\n<p>接下来，我们修改<code>app.js</code>，使用<code>koa-router</code>来处理URL：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注意require('koa-router')返回的是函数:</span></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// log request URL:</span></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Process <span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>...`</span>);</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// add url-route:</span></div><div class=\"line\">router.get(<span class=\"string\">'/hello/:name'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = ctx.params.name;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Hello, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Index&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// add router middleware:</span></div><div class=\"line\">app.use(router.routes());</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'app started at port 3000...'</span>);</div></pre></td></tr></table></figure>\n<p>注意导入<code>koa-router</code>的语句最后的<code>()</code>是函数调用。</p>\n<h4 id=\"处理post请求\"><a href=\"#处理post请求\" class=\"headerlink\" title=\"处理post请求\"></a>处理post请求</h4><p>用<code>router.get(&#39;/path&#39;, async fn)</code>处理的是get请求。如果要处理post请求，可以用<code>router.post(&#39;/path&#39;, async fn)</code>。</p>\n<p>post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！所以，又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到<code>ctx.request.body</code>中。</p>\n<p><code>koa-bodyparser</code>可以实现解析功能，我们在<code>package.json</code>中添加依赖项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"koa-bodyparser\"</span>: <span class=\"string\">\"3.2.0\"</span></div></pre></td></tr></table></figure>\n<p>下面，修改<code>app.js</code>，引入<code>koa-bodyparser</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</div></pre></td></tr></table></figure>\n<p>在合适的位置加上注册，由于middleware的顺序很重要，这个<code>koa-bodyparser</code>必须在<code>router</code>之前被注册到<code>app</code>对象上:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(bodyParser());</div></pre></td></tr></table></figure>\n<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Index&lt;/h1&gt;</span></div><div class=\"line\">        &lt;form action=\"/signin\" method=\"post\"&gt;</div><div class=\"line\">            &lt;p&gt;Name: &lt;input name=\"name\" value=\"koa\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;Password: &lt;input name=\"password\" type=\"password\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/p&gt;</div><div class=\"line\">        &lt;/form&gt;`;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/signin'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span></div><div class=\"line\">        name = ctx.request.body.name || <span class=\"string\">''</span>,</div><div class=\"line\">        password = ctx.request.body.password || <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`signin with name: <span class=\"subst\">$&#123;name&#125;</span>, password: <span class=\"subst\">$&#123;password&#125;</span>`</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'koa'</span> &amp;&amp; password === <span class=\"string\">'12345'</span>) &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Welcome, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Login failed!&lt;/h1&gt;</span></div><div class=\"line\">        &lt;p&gt;&lt;a href=\"/\"&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>用<code>var name = ctx.request.body.name || &#39;&#39;</code>拿到表单的<code>name</code>字段，如果该字段不存在，默认值设置为<code>&#39;&#39;</code>。</p>\n<h4 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h4><p><code>app.js</code>是工程的入口，不可能将所有的<code>post``get</code>注册以及回调都放在该文件内，可以自己创建一个<code>controllers</code>文件夹，将各个注册及回调放在其中，譬如新建一个有关登录的<code>index.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn_index = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Index&lt;/h1&gt;</span></div><div class=\"line\">        &lt;form action=\"/signin\" method=\"post\"&gt;</div><div class=\"line\">            &lt;p&gt;Name: &lt;input name=\"name\" value=\"koa\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;Password: &lt;input name=\"password\" type=\"password\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/p&gt;</div><div class=\"line\">        &lt;/form&gt;`;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fn_signin = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span></div><div class=\"line\">        name = ctx.request.body.name || <span class=\"string\">''</span>,</div><div class=\"line\">        password = ctx.request.body.password || <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`signin with name: <span class=\"subst\">$&#123;name&#125;</span>, password: <span class=\"subst\">$&#123;password&#125;</span>`</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'koa'</span> &amp;&amp; password === <span class=\"string\">'12345'</span>) &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Welcome, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Login failed!&lt;/h1&gt;</span></div><div class=\"line\">        &lt;p&gt;&lt;a href=\"/\"&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"string\">'GET /'</span>: fn_index,</div><div class=\"line\">    <span class=\"string\">'POST /signin'</span>: fn_signin</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个<code>index.js</code>通过<code>module.exports</code>把两个URL处理函数暴露出来。</p>\n<p>那么现在应该要做的是在<code>app.js</code>中，让它自动扫描<code>controllers</code>目录，找到所有<code>js</code>文件，导入，然后注册每个URL：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先导入fs模块，然后用readdirSync列出文件</span></div><div class=\"line\"><span class=\"comment\">// 这里可以用sync是因为启动时只运行一次，不存在性能问题:</span></div><div class=\"line\"><span class=\"keyword\">var</span> files = fs.readdirSync(__dirname + <span class=\"string\">'/controllers'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 过滤出.js文件:</span></div><div class=\"line\"><span class=\"keyword\">var</span> js_files = files.filter((f)=&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> f.endsWith(<span class=\"string\">'.js'</span>);</div><div class=\"line\">&#125;, files);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理每个js文件:</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">of</span> js_files) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`process controller: <span class=\"subst\">$&#123;f&#125;</span>...`</span>);</div><div class=\"line\">    <span class=\"comment\">// 导入js文件:</span></div><div class=\"line\">    <span class=\"keyword\">let</span> mapping = <span class=\"built_in\">require</span>(__dirname + <span class=\"string\">'/controllers/'</span> + f);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> url <span class=\"keyword\">in</span> mapping) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (url.startsWith(<span class=\"string\">'GET '</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果url类似\"GET xxx\":</span></div><div class=\"line\">            <span class=\"keyword\">var</span> path = url.substring(<span class=\"number\">4</span>);</div><div class=\"line\">            router.get(path, mapping[url]);</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`register URL mapping: GET <span class=\"subst\">$&#123;path&#125;</span>`</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (url.startsWith(<span class=\"string\">'POST '</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果url类似\"GET xxx\":</span></div><div class=\"line\">            <span class=\"keyword\">var</span> path = url.substring(<span class=\"number\">5</span>);</div><div class=\"line\">            router.post(path, mapping[url]);</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`register URL mapping: POST <span class=\"subst\">$&#123;path&#125;</span>`</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 无效的URL:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`invalid URL: <span class=\"subst\">$&#123;url&#125;</span>`</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Controller-Middleware\"><a href=\"#Controller-Middleware\" class=\"headerlink\" title=\"Controller Middleware\"></a>Controller Middleware</h4><p>最后，我们把扫描<code>controllers</code>目录和创建<code>router</code>的代码从<code>app.js</code>中提取出来，作为一个简单的<code>middleware</code>使用，命名为<code>controller.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addMapping</span>(<span class=\"params\">router, mapping</span>) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addControllers</span>(<span class=\"params\">router, dir</span>) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dir</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span></div><div class=\"line\">        controllers_dir = dir || <span class=\"string\">'controllers'</span>, <span class=\"comment\">// 如果不传参数，扫描目录默认为'controllers'</span></div><div class=\"line\">        router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</div><div class=\"line\">    addControllers(router, controllers_dir);</div><div class=\"line\">    <span class=\"keyword\">return</span> router.routes();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样一来，我们在<code>app.js</code>的代码又简化了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入controller middleware:</span></div><div class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"built_in\">require</span>(<span class=\"string\">'./controller'</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用middleware:</span></div><div class=\"line\">app.use(controller());</div><div class=\"line\"></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>经过重新整理后的工程<code>url2-koa</code>目前具备非常好的模块化，所有处理URL的函数按功能组存放在<code>controllers</code>目录，今后我们也只需要不断往这个目录下加东西就可以了，<code>app.js</code>保持不变。</p>\n","excerpt":"<p>本篇是NodeJs的学习笔记，参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501579966ab03decb0dd246e1a6799dd653a15e1b000\">廖雪峰的博客</a></p>","more":"<h2 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h2><p>koa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。和koa 1相比，koa2完全使用Promise并配合<code>async</code>来实现异步。</p>\n<h3 id=\"koa入门\"><a href=\"#koa入门\" class=\"headerlink\" title=\"koa入门\"></a>koa入门</h3><h4 id=\"创建koa2工程\"><a href=\"#创建koa2工程\" class=\"headerlink\" title=\"创建koa2工程\"></a>创建koa2工程</h4><p>首先，创建一个目录文件夹<code>hello-koa</code>,然后创建<code>app.js</code>,写入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个Koa对象表示web app本身:</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对于任何请求，app将调用该异步函数处理请求：</span></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在端口3000监听:</span></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'app started at port 3000...'</span>);</div></pre></td></tr></table></figure>\n<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    <span class=\"comment\">// 设置response的Content-Type:</span></div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    <span class=\"comment\">// 设置response的内容:</span></div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，参数<code>ctx</code>是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，<code>next</code>是koa传入的将要处理的下一个异步函数。<br>上面的异步函数中，我们首先用<code>await next();</code>处理下一个异步函数，然后，设置response的Content-Type和内容。<br>由<code>async</code>标记的函数称为异步函数，在异步函数中，可以用<code>await</code>调用另一个异步函数，这两个关键字将在ES7中引入。</p>\n<p>那么koa这个包怎么装，<code>app.js</code>才能正常导入它？<br>在<code>hello-koa</code>这个目录下创建一个<code>package.json</code>，这个文件描述了我们的<code>hello-koa</code>工程会用到哪些包:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"name\"</span>: <span class=\"string\">\"hello-koa2\"</span>,</div><div class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"Hello Koa 2 example with async\"</span>,</div><div class=\"line\">    <span class=\"string\">\"main\"</span>: <span class=\"string\">\"start.js\"</span>,</div><div class=\"line\">    <span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"start\"</span>: <span class=\"string\">\"node start.js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"dependencies\"</span>: &#123;</div><div class=\"line\">        <span class=\"string\">\"babel-core\"</span>: <span class=\"string\">\"6.13.2\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-polyfill\"</span>: <span class=\"string\">\"6.13.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-preset-es2015-node6\"</span>: <span class=\"string\">\"0.3.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"babel-preset-stage-3\"</span>: <span class=\"string\">\"6.5.0\"</span>,</div><div class=\"line\">        <span class=\"string\">\"koa\"</span>: <span class=\"string\">\"2.0.0\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<code>dependencies</code>描述了我们的工程依赖的包以及版本号。然后，我们在<code>hello-koa</code>目录下执行<code>npm install</code>就可以把所需包以及依赖包一次性全部装好。<br>注意，任何时候都可以直接删除整个<code>node_modules</code>目录，因为用<code>npm install</code>命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。</p>\n<p>另外，这里的<code>&quot;main&quot;: &quot;start.js&quot;</code>将在下面讲到。</p>\n<p>但是由于现在的Node.js只支持ES6，不支持ES7，无法识别新的<code>async</code>语法。需要使用Babel把ES7代码“转换”为ES6代码。</p>\n<h4 id=\"Bebel\"><a href=\"#Bebel\" class=\"headerlink\" title=\"Bebel\"></a>Bebel</h4><p>Babel是一个JavaScript编写的转码器，它可以把高版本的JavaScript代码转换成低版本的JavaScript代码，并保持逻辑不变，这样就可以在低版本的JavaScript环境下运行。</p>\n<p>例如，我们用ES7编写的JavaScript代码，用Babel转换成ES6以后，就可以在Node环境下执行。如果某些JavaScript代码需要在更低版本的环境下执行，例如IE 6，就可以用Babel转换成ES5的代码。</p>\n<p>用Babel转码时，需要指定presets和plugins。<br>presets是规则，我们<code>stage-3</code>规则，<code>stage-3</code>规则是ES7的stage 0~3的第3阶段规则。<br>plugins可以指定插件来定制转码过程，一个preset就包含了一组指定的plugin。</p>\n<p>我们编写一个<code>start.js</code>文件，在这个文件中，先加载<code>babel-core/register</code>，再加载<code>app.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> register = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-core/register'</span>);</div><div class=\"line\"></div><div class=\"line\">register(&#123;</div><div class=\"line\">    presets: [<span class=\"string\">'stage-3'</span>]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./app.js'</span>);</div></pre></td></tr></table></figure>\n<p>现在我们在<code>hello-koa</code>目录下又多了一个<code>start.js</code>文件。在<code>npm install</code>后，可以直接执行<code>node start.js</code>也可以用<code>npm start</code>启动。<code>npm start</code>命令会让npm执行定义在<code>package.json</code>文件中的<code>start</code>对应命令</p>\n<p>为什么先加载<code>babel-core/register</code>，再加载<code>app.js</code>，魔法就会生效？原因是第一个<code>require()</code>是Node正常加载<code>babel-core/register</code>的过程，然后，Babel会用自己的<code>require()</code>替换掉Node的<code>require()</code>，随后用<code>require()</code>加载的所有代码均会被Babel自动转码后再加载。</p>\n<h4 id=\"koa-middleware\"><a href=\"#koa-middleware\" class=\"headerlink\" title=\"koa middleware\"></a>koa middleware</h4><p>koa的核心代码是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>每收到一个http请求，koa就会调用通过<code>app.use()</code>注册的<code>async</code>函数，并传入<code>ctx</code>和<code>next</code>参数。</p>\n<p>我们可以对<code>ctx</code>操作，并设置返回内容。但是为什么要调用<code>await next()</code>？<br>原因是<code>koa</code>把很多<code>async</code>函数组成一个处理链，每个<code>async</code>函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个<code>async</code>函数。我们把每个<code>async</code>函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>\n<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>`</span>); <span class=\"comment\">// 打印URL</span></div><div class=\"line\">    <span class=\"keyword\">await</span> next(); <span class=\"comment\">// 调用下一个middleware</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(); <span class=\"comment\">// 当前时间</span></div><div class=\"line\">    <span class=\"keyword\">await</span> next(); <span class=\"comment\">// 调用下一个middleware</span></div><div class=\"line\">    <span class=\"keyword\">const</span> ms = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() - start; <span class=\"comment\">// 耗费时间</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Time: <span class=\"subst\">$&#123;ms&#125;</span>ms`</span>); <span class=\"comment\">// 打印耗费时间</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">    ctx.response.type = <span class=\"string\">'text/html'</span>;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Hello, koa2!&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>middleware的顺序很重要，也就是调用<code>app.use()</code>的顺序决定了middleware的顺序。如果一个middleware没有调用<code>await next()</code>，后续的middleware将不再执行。</p>\n<h3 id=\"处理URL\"><a href=\"#处理URL\" class=\"headerlink\" title=\"处理URL\"></a>处理URL</h3><p>前面的工程中，没有对URL进行判定，实际上，一个网站，对于不同的网页<code>request</code>应该返回不同的<code>response</code>。譬如像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(async (ctx, next) =&gt; &#123;</div><div class=\"line\">    if (ctx.request.path === &apos;/&apos;) &#123;</div><div class=\"line\">        ctx.response.body = &apos;index page&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        await next();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是实际使用中，不能一个个去判断<code>request.path</code>，应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数。</p>\n<h4 id=\"koa-router\"><a href=\"#koa-router\" class=\"headerlink\" title=\"koa-router\"></a>koa-router</h4><p>使用<code>koa-router</code>这个中间件，来处理URL映射。</p>\n<p>先在<code>package.json</code>中添加依赖项，并<code>npm install</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"koa-router\"</span>: <span class=\"string\">\"7.0.0\"</span></div></pre></td></tr></table></figure>\n<p>接下来，我们修改<code>app.js</code>，使用<code>koa-router</code>来处理URL：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 注意require('koa-router')返回的是函数:</span></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// log request URL:</span></div><div class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Process <span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>...`</span>);</div><div class=\"line\">    <span class=\"keyword\">await</span> next();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// add url-route:</span></div><div class=\"line\">router.get(<span class=\"string\">'/hello/:name'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name = ctx.params.name;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Hello, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;h1&gt;Index&lt;/h1&gt;'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// add router middleware:</span></div><div class=\"line\">app.use(router.routes());</div><div class=\"line\"></div><div class=\"line\">app.listen(<span class=\"number\">3000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'app started at port 3000...'</span>);</div></pre></td></tr></table></figure>\n<p>注意导入<code>koa-router</code>的语句最后的<code>()</code>是函数调用。</p>\n<h4 id=\"处理post请求\"><a href=\"#处理post请求\" class=\"headerlink\" title=\"处理post请求\"></a>处理post请求</h4><p>用<code>router.get(&#39;/path&#39;, async fn)</code>处理的是get请求。如果要处理post请求，可以用<code>router.post(&#39;/path&#39;, async fn)</code>。</p>\n<p>post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！所以，又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到<code>ctx.request.body</code>中。</p>\n<p><code>koa-bodyparser</code>可以实现解析功能，我们在<code>package.json</code>中添加依赖项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"koa-bodyparser\"</span>: <span class=\"string\">\"3.2.0\"</span></div></pre></td></tr></table></figure>\n<p>下面，修改<code>app.js</code>，引入<code>koa-bodyparser</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-bodyparser'</span>);</div></pre></td></tr></table></figure>\n<p>在合适的位置加上注册，由于middleware的顺序很重要，这个<code>koa-bodyparser</code>必须在<code>router</code>之前被注册到<code>app</code>对象上:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">app.use(bodyParser());</div></pre></td></tr></table></figure>\n<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">router.get(<span class=\"string\">'/'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Index&lt;/h1&gt;</div><div class=\"line\">        &lt;form action=\"/signin\" method=\"post\"&gt;</div><div class=\"line\">            &lt;p&gt;Name: &lt;input name=\"name\" value=\"koa\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;Password: &lt;input name=\"password\" type=\"password\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/p&gt;</div><div class=\"line\">        &lt;/form&gt;`</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">router.post(<span class=\"string\">'/signin'</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span></div><div class=\"line\">        name = ctx.request.body.name || <span class=\"string\">''</span>,</div><div class=\"line\">        password = ctx.request.body.password || <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`signin with name: <span class=\"subst\">$&#123;name&#125;</span>, password: <span class=\"subst\">$&#123;password&#125;</span>`</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'koa'</span> &amp;&amp; password === <span class=\"string\">'12345'</span>) &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Welcome, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Login failed!&lt;/h1&gt;</div><div class=\"line\">        &lt;p&gt;&lt;a href=\"/\"&gt;Try again&lt;/a&gt;&lt;/p&gt;`</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>用<code>var name = ctx.request.body.name || &#39;&#39;</code>拿到表单的<code>name</code>字段，如果该字段不存在，默认值设置为<code>&#39;&#39;</code>。</p>\n<h4 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h4><p><code>app.js</code>是工程的入口，不可能将所有的<code>post``get</code>注册以及回调都放在该文件内，可以自己创建一个<code>controllers</code>文件夹，将各个注册及回调放在其中，譬如新建一个有关登录的<code>index.js</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn_index = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    ctx.response.body = <span class=\"string\">`&lt;h1&gt;Index&lt;/h1&gt;</div><div class=\"line\">        &lt;form action=\"/signin\" method=\"post\"&gt;</div><div class=\"line\">            &lt;p&gt;Name: &lt;input name=\"name\" value=\"koa\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;Password: &lt;input name=\"password\" type=\"password\"&gt;&lt;/p&gt;</div><div class=\"line\">            &lt;p&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/p&gt;</div><div class=\"line\">        &lt;/form&gt;`</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> fn_signin = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span></div><div class=\"line\">        name = ctx.request.body.name || <span class=\"string\">''</span>,</div><div class=\"line\">        password = ctx.request.body.password || <span class=\"string\">''</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`signin with name: <span class=\"subst\">$&#123;name&#125;</span>, password: <span class=\"subst\">$&#123;password&#125;</span>`</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'koa'</span> &amp;&amp; password === <span class=\"string\">'12345'</span>) &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Welcome, <span class=\"subst\">$&#123;name&#125;</span>!&lt;/h1&gt;`</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ctx.response.body = <span class=\"string\">`&lt;h1&gt;Login failed!&lt;/h1&gt;</div><div class=\"line\">        &lt;p&gt;&lt;a href=\"/\"&gt;Try again&lt;/a&gt;&lt;/p&gt;`</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"string\">'GET /'</span>: fn_index,</div><div class=\"line\">    <span class=\"string\">'POST /signin'</span>: fn_signin</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个<code>index.js</code>通过<code>module.exports</code>把两个URL处理函数暴露出来。</p>\n<p>那么现在应该要做的是在<code>app.js</code>中，让它自动扫描<code>controllers</code>目录，找到所有<code>js</code>文件，导入，然后注册每个URL：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 先导入fs模块，然后用readdirSync列出文件</span></div><div class=\"line\"><span class=\"comment\">// 这里可以用sync是因为启动时只运行一次，不存在性能问题:</span></div><div class=\"line\"><span class=\"keyword\">var</span> files = fs.readdirSync(__dirname + <span class=\"string\">'/controllers'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 过滤出.js文件:</span></div><div class=\"line\"><span class=\"keyword\">var</span> js_files = files.filter((f)=&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> f.endsWith(<span class=\"string\">'.js'</span>);</div><div class=\"line\">&#125;, files);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 处理每个js文件:</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">of</span> js_files) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`process controller: <span class=\"subst\">$&#123;f&#125;</span>...`</span>);</div><div class=\"line\">    <span class=\"comment\">// 导入js文件:</span></div><div class=\"line\">    <span class=\"keyword\">let</span> mapping = <span class=\"built_in\">require</span>(__dirname + <span class=\"string\">'/controllers/'</span> + f);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> url <span class=\"keyword\">in</span> mapping) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (url.startsWith(<span class=\"string\">'GET '</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果url类似\"GET xxx\":</span></div><div class=\"line\">            <span class=\"keyword\">var</span> path = url.substring(<span class=\"number\">4</span>);</div><div class=\"line\">            router.get(path, mapping[url]);</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`register URL mapping: GET <span class=\"subst\">$&#123;path&#125;</span>`</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (url.startsWith(<span class=\"string\">'POST '</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果url类似\"GET xxx\":</span></div><div class=\"line\">            <span class=\"keyword\">var</span> path = url.substring(<span class=\"number\">5</span>);</div><div class=\"line\">            router.post(path, mapping[url]);</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`register URL mapping: POST <span class=\"subst\">$&#123;path&#125;</span>`</span>);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 无效的URL:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`invalid URL: <span class=\"subst\">$&#123;url&#125;</span>`</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Controller-Middleware\"><a href=\"#Controller-Middleware\" class=\"headerlink\" title=\"Controller Middleware\"></a>Controller Middleware</h4><p>最后，我们把扫描<code>controllers</code>目录和创建<code>router</code>的代码从<code>app.js</code>中提取出来，作为一个简单的<code>middleware</code>使用，命名为<code>controller.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addMapping</span>(<span class=\"params\">router, mapping</span>) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addControllers</span>(<span class=\"params\">router, dir</span>) </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dir</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span></div><div class=\"line\">        controllers_dir = dir || <span class=\"string\">'controllers'</span>, <span class=\"comment\">// 如果不传参数，扫描目录默认为'controllers'</span></div><div class=\"line\">        router = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-router'</span>)();</div><div class=\"line\">    addControllers(router, controllers_dir);</div><div class=\"line\">    <span class=\"keyword\">return</span> router.routes();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样一来，我们在<code>app.js</code>的代码又简化了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 导入controller middleware:</span></div><div class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"built_in\">require</span>(<span class=\"string\">'./controller'</span>);</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用middleware:</span></div><div class=\"line\">app.use(controller());</div><div class=\"line\"></div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>经过重新整理后的工程<code>url2-koa</code>目前具备非常好的模块化，所有处理URL的函数按功能组存放在<code>controllers</code>目录，今后我们也只需要不断往这个目录下加东西就可以了，<code>app.js</code>保持不变。</p>"}],"Post":[{"title":"Block 的使用","date":"2016-09-01T02:07:12.000Z","_content":"\n类似于匿名函数，oc中提供`block`,可以将一段代码块像对象一样作为参数传递、执行。\n\n<!--more-->\n\n## Block的使用\n### Block实例\n```objc\n^(double dividend){\n\tdouble quotient = dividend / divisor;\n\treturn quotient;\n}\n```\nBlock对象可以被当做一个实参来传递给可以接收block的方法。\n\n### 声明block变量:\n```objc \nvoid (^devowelizer)(id, NSUInteger, BOOL*);\n```\n`void` 表示返回类型  \n`^` 表示是一个block对象  \n`devowelizer` 表示block变量的名称  \n后面的是实参类型  \n方法的调用参数类型为`^(id  string, NSUInteger i, BOOL *stop)block`\n\n### 编写Block对象\n```objc\ndevowelizer = ^(id string,NSUInteger i, BOOL *stop){\n\t……\n};\n```\n\n### 调用block变量\n```objc\ndevowelizer(string,i,stop);\n```\n### typedef\n不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。\n```objc\ntypedef void(^ArrayEnumerationBlock)(id,NSUInteger,BOOL *);\n```\n需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。\n```objc\nArrayEnumerationBlock devowelizer；\n```\n\n### 外部变量\n在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。\n\n**当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。**\n\n### 修改外部变量\n如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。\n\n**__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。**\n\n### 在Block中使用self\n如果要写一个使用self的Block对象，需要避免强引用循环。  \n在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。\n```objc\n_weak BNREmployee *weakSelf = self;\t//弱引用指针\n\tmyBlock = ^{\n\t\tNSLog(@“Employee:%@”,weakSelf);\n\t};\n```\n\n\n## block的实现\nblock的实现主要参考[唐巧谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#)\n\n### block的结构\nblock的结构如下:\n```objc\nstruct Block_descriptor {\n    unsigned long int reserved;\n    unsigned long int size;\n    void (*copy)(void *dst, void *src);\n    void (*dispose)(void *);\n};\n\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\n\n结构图如下：\n![block结构图](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true)\n\n通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：\n1. `isa` 指针，所有对象都有该指针，用于实现对象相关的功能。\n2. `flags`，用于按 bit 位表示一些 block 的附加信息。\n3. `reserved`，保留变量。\n4. `invoke`，函数指针，指向具体的 block 实现的函数调用地址。\n5. `descriptor`， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。\n6. 各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。\n\n### block种类\nblock的isa是以下三个的一种：\n1. `_NSConcreteGlobalBlock` 全局的静态 block，不会访问任何外部变量。\n2. `_NSConcreteStackBlock` 保存在栈中的 block，当函数返回时会被销毁。\n3. `_NSConcreteMallocBlock` 保存在堆中的 block，当引用计数为 0 时会被销毁。\n\n在 ARC 开启的情况下，将只会有 `NSConcreteGlobalBlock` 和 `NSConcreteMallocBlock`类型的 block。原本的 `NSConcreteStackBlock` 的 block 会被 `NSConcreteMallocBlock` 类型的 block 替代。\n\n### 研究工具：clang\nclang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是\n```objc\nclang -rewrite-objc xxxx\n```\n","source":"_posts/Block基础.md","raw":"title: Block 的使用\ndate: 2016/9/1 10:07:12  \ncategories: iOS\ntags:\n\t- Block\n\n---\n\n类似于匿名函数，oc中提供`block`,可以将一段代码块像对象一样作为参数传递、执行。\n\n<!--more-->\n\n## Block的使用\n### Block实例\n```objc\n^(double dividend){\n\tdouble quotient = dividend / divisor;\n\treturn quotient;\n}\n```\nBlock对象可以被当做一个实参来传递给可以接收block的方法。\n\n### 声明block变量:\n```objc \nvoid (^devowelizer)(id, NSUInteger, BOOL*);\n```\n`void` 表示返回类型  \n`^` 表示是一个block对象  \n`devowelizer` 表示block变量的名称  \n后面的是实参类型  \n方法的调用参数类型为`^(id  string, NSUInteger i, BOOL *stop)block`\n\n### 编写Block对象\n```objc\ndevowelizer = ^(id string,NSUInteger i, BOOL *stop){\n\t……\n};\n```\n\n### 调用block变量\n```objc\ndevowelizer(string,i,stop);\n```\n### typedef\n不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。\n```objc\ntypedef void(^ArrayEnumerationBlock)(id,NSUInteger,BOOL *);\n```\n需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。\n```objc\nArrayEnumerationBlock devowelizer；\n```\n\n### 外部变量\n在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。\n\n**当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。**\n\n### 修改外部变量\n如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。\n\n**__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。**\n\n### 在Block中使用self\n如果要写一个使用self的Block对象，需要避免强引用循环。  \n在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。\n```objc\n_weak BNREmployee *weakSelf = self;\t//弱引用指针\n\tmyBlock = ^{\n\t\tNSLog(@“Employee:%@”,weakSelf);\n\t};\n```\n\n\n## block的实现\nblock的实现主要参考[唐巧谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#)\n\n### block的结构\nblock的结构如下:\n```objc\nstruct Block_descriptor {\n    unsigned long int reserved;\n    unsigned long int size;\n    void (*copy)(void *dst, void *src);\n    void (*dispose)(void *);\n};\n\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\n\n结构图如下：\n![block结构图](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true)\n\n通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：\n1. `isa` 指针，所有对象都有该指针，用于实现对象相关的功能。\n2. `flags`，用于按 bit 位表示一些 block 的附加信息。\n3. `reserved`，保留变量。\n4. `invoke`，函数指针，指向具体的 block 实现的函数调用地址。\n5. `descriptor`， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。\n6. 各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。\n\n### block种类\nblock的isa是以下三个的一种：\n1. `_NSConcreteGlobalBlock` 全局的静态 block，不会访问任何外部变量。\n2. `_NSConcreteStackBlock` 保存在栈中的 block，当函数返回时会被销毁。\n3. `_NSConcreteMallocBlock` 保存在堆中的 block，当引用计数为 0 时会被销毁。\n\n在 ARC 开启的情况下，将只会有 `NSConcreteGlobalBlock` 和 `NSConcreteMallocBlock`类型的 block。原本的 `NSConcreteStackBlock` 的 block 会被 `NSConcreteMallocBlock` 类型的 block 替代。\n\n### 研究工具：clang\nclang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是\n```objc\nclang -rewrite-objc xxxx\n```\n","slug":"Block基础","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dnu00017hzglj3547t2","content":"<p>类似于匿名函数，oc中提供<code>block</code>,可以将一段代码块像对象一样作为参数传递、执行。</p>\n<a id=\"more\"></a>\n<h2 id=\"Block的使用\"><a href=\"#Block的使用\" class=\"headerlink\" title=\"Block的使用\"></a>Block的使用</h2><h3 id=\"Block实例\"><a href=\"#Block实例\" class=\"headerlink\" title=\"Block实例\"></a>Block实例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">^(<span class=\"keyword\">double</span> dividend)&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span> quotient = dividend / divisor;</div><div class=\"line\">\t<span class=\"keyword\">return</span> quotient;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Block对象可以被当做一个实参来传递给可以接收block的方法。</p>\n<h3 id=\"声明block变量\"><a href=\"#声明block变量\" class=\"headerlink\" title=\"声明block变量:\"></a>声明block变量:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^devowelizer)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">BOOL</span>*);</div></pre></td></tr></table></figure>\n<p><code>void</code> 表示返回类型<br><code>^</code> 表示是一个block对象<br><code>devowelizer</code> 表示block变量的名称<br>后面的是实参类型<br>方法的调用参数类型为<code>^(id  string, NSUInteger i, BOOL *stop)block</code></p>\n<h3 id=\"编写Block对象\"><a href=\"#编写Block对象\" class=\"headerlink\" title=\"编写Block对象\"></a>编写Block对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer = ^(<span class=\"keyword\">id</span> string,<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">BOOL</span> *stop)&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"调用block变量\"><a href=\"#调用block变量\" class=\"headerlink\" title=\"调用block变量\"></a>调用block变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer(string,i,stop);</div></pre></td></tr></table></figure>\n<h3 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h3><p>不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ArrayEnumerationBlock)(<span class=\"keyword\">id</span>,<span class=\"built_in\">NSUInteger</span>,<span class=\"built_in\">BOOL</span> *);</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ArrayEnumerationBlock devowelizer；</div></pre></td></tr></table></figure></p>\n<h3 id=\"外部变量\"><a href=\"#外部变量\" class=\"headerlink\" title=\"外部变量\"></a>外部变量</h3><p>在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。</p>\n<p><strong>当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。</strong></p>\n<h3 id=\"修改外部变量\"><a href=\"#修改外部变量\" class=\"headerlink\" title=\"修改外部变量\"></a>修改外部变量</h3><p>如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。</p>\n<p><strong>__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。</strong></p>\n<h3 id=\"在Block中使用self\"><a href=\"#在Block中使用self\" class=\"headerlink\" title=\"在Block中使用self\"></a>在Block中使用self</h3><p>如果要写一个使用self的Block对象，需要避免强引用循环。<br>在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_<span class=\"keyword\">weak</span> BNREmployee *weakSelf = <span class=\"keyword\">self</span>;\t<span class=\"comment\">//弱引用指针</span></div><div class=\"line\">\tmyBlock = ^&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“Employee:%@”,weakSelf);</div><div class=\"line\">\t&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"block的实现\"><a href=\"#block的实现\" class=\"headerlink\" title=\"block的实现\"></a>block的实现</h2><p>block的实现主要参考<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#\" target=\"_blank\" rel=\"external\">唐巧谈Objective-C block的实现</a></p>\n<h3 id=\"block的结构\"><a href=\"#block的结构\" class=\"headerlink\" title=\"block的结构\"></a>block的结构</h3><p>block的结构如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_descriptor &#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"keyword\">copy</span>)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(<span class=\"keyword\">void</span> *);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> Block_layout &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa;</div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor *descriptor;</div><div class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>结构图如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true\" alt=\"block结构图\"></p>\n<p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p>\n<ol>\n<li><code>isa</code> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>\n<li><code>flags</code>，用于按 bit 位表示一些 block 的附加信息。</li>\n<li><code>reserved</code>，保留变量。</li>\n<li><code>invoke</code>，函数指针，指向具体的 block 实现的函数调用地址。</li>\n<li><code>descriptor</code>， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>\n<li>各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>\n</ol>\n<h3 id=\"block种类\"><a href=\"#block种类\" class=\"headerlink\" title=\"block种类\"></a>block种类</h3><p>block的isa是以下三个的一种：</p>\n<ol>\n<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量。</li>\n<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁。</li>\n<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>\n</ol>\n<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和 <code>NSConcreteMallocBlock</code>类型的 block。原本的 <code>NSConcreteStackBlock</code> 的 block 会被 <code>NSConcreteMallocBlock</code> 类型的 block 替代。</p>\n<h3 id=\"研究工具：clang\"><a href=\"#研究工具：clang\" class=\"headerlink\" title=\"研究工具：clang\"></a>研究工具：clang</h3><p>clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc xxxx</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>类似于匿名函数，oc中提供<code>block</code>,可以将一段代码块像对象一样作为参数传递、执行。</p>","more":"<h2 id=\"Block的使用\"><a href=\"#Block的使用\" class=\"headerlink\" title=\"Block的使用\"></a>Block的使用</h2><h3 id=\"Block实例\"><a href=\"#Block实例\" class=\"headerlink\" title=\"Block实例\"></a>Block实例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">^(<span class=\"keyword\">double</span> dividend)&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span> quotient = dividend / divisor;</div><div class=\"line\">\t<span class=\"keyword\">return</span> quotient;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Block对象可以被当做一个实参来传递给可以接收block的方法。</p>\n<h3 id=\"声明block变量\"><a href=\"#声明block变量\" class=\"headerlink\" title=\"声明block变量:\"></a>声明block变量:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^devowelizer)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">BOOL</span>*);</div></pre></td></tr></table></figure>\n<p><code>void</code> 表示返回类型<br><code>^</code> 表示是一个block对象<br><code>devowelizer</code> 表示block变量的名称<br>后面的是实参类型<br>方法的调用参数类型为<code>^(id  string, NSUInteger i, BOOL *stop)block</code></p>\n<h3 id=\"编写Block对象\"><a href=\"#编写Block对象\" class=\"headerlink\" title=\"编写Block对象\"></a>编写Block对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer = ^(<span class=\"keyword\">id</span> string,<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">BOOL</span> *stop)&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"调用block变量\"><a href=\"#调用block变量\" class=\"headerlink\" title=\"调用block变量\"></a>调用block变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer(string,i,stop);</div></pre></td></tr></table></figure>\n<h3 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h3><p>不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ArrayEnumerationBlock)(<span class=\"keyword\">id</span>,<span class=\"built_in\">NSUInteger</span>,<span class=\"built_in\">BOOL</span> *);</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ArrayEnumerationBlock devowelizer；</div></pre></td></tr></table></figure></p>\n<h3 id=\"外部变量\"><a href=\"#外部变量\" class=\"headerlink\" title=\"外部变量\"></a>外部变量</h3><p>在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。</p>\n<p><strong>当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。</strong></p>\n<h3 id=\"修改外部变量\"><a href=\"#修改外部变量\" class=\"headerlink\" title=\"修改外部变量\"></a>修改外部变量</h3><p>如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。</p>\n<p><strong>__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。</strong></p>\n<h3 id=\"在Block中使用self\"><a href=\"#在Block中使用self\" class=\"headerlink\" title=\"在Block中使用self\"></a>在Block中使用self</h3><p>如果要写一个使用self的Block对象，需要避免强引用循环。<br>在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_<span class=\"keyword\">weak</span> BNREmployee *weakSelf = <span class=\"keyword\">self</span>;\t<span class=\"comment\">//弱引用指针</span></div><div class=\"line\">\tmyBlock = ^&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“Employee:%@”,weakSelf);</div><div class=\"line\">\t&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"block的实现\"><a href=\"#block的实现\" class=\"headerlink\" title=\"block的实现\"></a>block的实现</h2><p>block的实现主要参考<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#\">唐巧谈Objective-C block的实现</a></p>\n<h3 id=\"block的结构\"><a href=\"#block的结构\" class=\"headerlink\" title=\"block的结构\"></a>block的结构</h3><p>block的结构如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_descriptor &#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"keyword\">copy</span>)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(<span class=\"keyword\">void</span> *);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> Block_layout &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa;</div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor *descriptor;</div><div class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>结构图如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true\" alt=\"block结构图\"></p>\n<p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p>\n<ol>\n<li><code>isa</code> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>\n<li><code>flags</code>，用于按 bit 位表示一些 block 的附加信息。</li>\n<li><code>reserved</code>，保留变量。</li>\n<li><code>invoke</code>，函数指针，指向具体的 block 实现的函数调用地址。</li>\n<li><code>descriptor</code>， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>\n<li>各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>\n</ol>\n<h3 id=\"block种类\"><a href=\"#block种类\" class=\"headerlink\" title=\"block种类\"></a>block种类</h3><p>block的isa是以下三个的一种：</p>\n<ol>\n<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量。</li>\n<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁。</li>\n<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>\n</ol>\n<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和 <code>NSConcreteMallocBlock</code>类型的 block。原本的 <code>NSConcreteStackBlock</code> 的 block 会被 <code>NSConcreteMallocBlock</code> 类型的 block 替代。</p>\n<h3 id=\"研究工具：clang\"><a href=\"#研究工具：clang\" class=\"headerlink\" title=\"研究工具：clang\"></a>研究工具：clang</h3><p>clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc xxxx</div></pre></td></tr></table></figure></p>"},{"title":"CALayer学习小结","date":"2016-08-12T06:07:12.000Z","_content":"\n这两天想大致学习下animation的使用方法。看了[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)专题，写的很好，学习了很多。再摘录部分，以作备忘。\n\n<!--more-->\n\n## CALayer简介\n### 简介\nUIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\nUIView本身不具备显示的功能，拥有显示功能的是它内部的图层。\n\n### 使用\n通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。\n```objc\n//设置边框的宽度为20\nself.customView.layer.borderWidth=20;\n//设置边框的颜色(borderColor是CGColor类型)\nself.customView.layer.borderColor=[UIColor greenColor].CGColor;\n\n//设置layer的圆角\nself.customView.layer.cornerRadius=20;\n//设置超过子图层的部分裁减掉\nself.iconView.layer.masksToBounds=YES;\n\n//在view的图层上添加一个image，contents表示接受内容\nself.customView.layer.contents=(id)[UIImage imageNamed:@\"cat\"].CGImage;\n\n//设置阴影的颜色\nself.customView.layer.shadowColor=[UIColor blackColor].CGColor;\n//设置阴影的偏移量，如果为正数，则代表为往右边偏移\nself.customView.layer.shadowOffset=CGSizeMake(15, 5);\n//设置阴影的透明度(0~1之间，0表示完全透明)\nself.customView.layer.shadowOpacity=0.6;\n\n//通过uiview设置（2D效果）\nself.customView.transform=CGAffineTransformMakeTranslation(0, -100);\n//通过layer来设置（3D效果,x，y，z三个方向）\nself.iconView.layer.transform=CATransform3DMakeTranslation(100, 20, 0);\n//旋转\nself.iconView.layer.transform=CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);\n```\n\n## 创建图层\n### 基本方法\n```objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //创建一个layer\n    CALayer *Mylayer=[CALayer layer];\n    //设置layer的属性\n    Mylayer.bounds=CGRectMake(100, 100, 100, 100);\n    Mylayer.position=CGPointMake(100, 100);\n    \n    //设置需要显示的图片\n    Mylayer.contents=(id)[UIImage imageNamed:@\"me\"].CGImage;\n    //设置圆角半径为10\n    Mylayer.cornerRadius=10;\n    //如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果\n    Mylayer.masksToBounds=YES;\n    //设置边框\n    Mylayer.borderWidth=3;\n    Mylayer.borderColor=[UIColor brownColor].CGColor;\n    \n    //把layer添加到界面上\n    [self.view.layer addSublayer:Mylayer];\n}\n```\n\n### 总结\n对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。\n如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以\n\n## CAlayer属性\n### position和anchorPoint\n- position:设置CALayer在父层中的位置，这个位置要和锚点重合。\n- anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，**默认值为（0.5, 0.5）**\n\n### 隐式动画\n每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。\n\n常见的动画属性：\n- bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画\n- backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画\n- position：用于设置CALayer的位置。修改这个属性会产生平移动画\n\n## 自定义layer\n### 第一种方式：新建layer类\n想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。\n\n如果在layer上画东西，与上面的过程类似。\n```objc\n#import \"YYMylayer.h\"\n@implementation YYMylayer\n//重写该方法，在该方法内绘制图形\n-(void)drawInContext:(CGContextRef)ctx\n{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n//    [[UIColor yellowColor]set];\t不能这样设置\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n     //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类\n2. 在自定义layer中`drawInContext:`方法不会自己调用，只能自己通过`setNeedDisplay`方法调用，在view中画东西`DrawRect:`方法在view第一次显示的时候会自动调用。\n\n在view中绘图：\n```objc\n#import \"YYVIEW.h\"\n@implementation YYVIEW\n- (void)drawRect:(CGRect)rect\n{\n    //1.获取上下文\n    CGContextRef ctx=UIGraphicsGetCurrentContext();\n    //2.绘制图形\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    //3.渲染\n    CGContextFillPath(ctx);\n    //在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法\n    //[self.layer drawInContext:ctx];\n}\n```\n\n### 第二种方式：实现delegate方法\n设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n```objc\n@implementation YYViewController\n- (void)viewDidLoad{\n    [super viewDidLoad];\n    //1.创建自定义的layer\n    CALayer *layer=[CALayer layer];\n    //2.设置layer的属性\n\t...\n    //设置代理\n    layer.delegate=self;\n    [layer setNeedsDisplay];\n    //3.添加layer\n    [self.view.layer addSublayer:layer];\n}\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);   \n    //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。\n2. 不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。\n\n### 补充\n1. 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n2. **当UIView需要显示时**，它内部的层会准备好一个CGContextRef(图形上下文)，然后**调用delegate(这里就是UIView)**的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。\n\n>Demo 详见 CALayer-transform\n","source":"_posts/CALayer学习小结.md","raw":"title: CALayer学习小结\ndate: 2016/8/12 14:07:12  \ncategories: iOS\ntags: \n\t- Animation\n\t- UI\n\t\n---\n\n这两天想大致学习下animation的使用方法。看了[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)专题，写的很好，学习了很多。再摘录部分，以作备忘。\n\n<!--more-->\n\n## CALayer简介\n### 简介\nUIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\nUIView本身不具备显示的功能，拥有显示功能的是它内部的图层。\n\n### 使用\n通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。\n```objc\n//设置边框的宽度为20\nself.customView.layer.borderWidth=20;\n//设置边框的颜色(borderColor是CGColor类型)\nself.customView.layer.borderColor=[UIColor greenColor].CGColor;\n\n//设置layer的圆角\nself.customView.layer.cornerRadius=20;\n//设置超过子图层的部分裁减掉\nself.iconView.layer.masksToBounds=YES;\n\n//在view的图层上添加一个image，contents表示接受内容\nself.customView.layer.contents=(id)[UIImage imageNamed:@\"cat\"].CGImage;\n\n//设置阴影的颜色\nself.customView.layer.shadowColor=[UIColor blackColor].CGColor;\n//设置阴影的偏移量，如果为正数，则代表为往右边偏移\nself.customView.layer.shadowOffset=CGSizeMake(15, 5);\n//设置阴影的透明度(0~1之间，0表示完全透明)\nself.customView.layer.shadowOpacity=0.6;\n\n//通过uiview设置（2D效果）\nself.customView.transform=CGAffineTransformMakeTranslation(0, -100);\n//通过layer来设置（3D效果,x，y，z三个方向）\nself.iconView.layer.transform=CATransform3DMakeTranslation(100, 20, 0);\n//旋转\nself.iconView.layer.transform=CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);\n```\n\n## 创建图层\n### 基本方法\n```objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //创建一个layer\n    CALayer *Mylayer=[CALayer layer];\n    //设置layer的属性\n    Mylayer.bounds=CGRectMake(100, 100, 100, 100);\n    Mylayer.position=CGPointMake(100, 100);\n    \n    //设置需要显示的图片\n    Mylayer.contents=(id)[UIImage imageNamed:@\"me\"].CGImage;\n    //设置圆角半径为10\n    Mylayer.cornerRadius=10;\n    //如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果\n    Mylayer.masksToBounds=YES;\n    //设置边框\n    Mylayer.borderWidth=3;\n    Mylayer.borderColor=[UIColor brownColor].CGColor;\n    \n    //把layer添加到界面上\n    [self.view.layer addSublayer:Mylayer];\n}\n```\n\n### 总结\n对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。\n如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以\n\n## CAlayer属性\n### position和anchorPoint\n- position:设置CALayer在父层中的位置，这个位置要和锚点重合。\n- anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，**默认值为（0.5, 0.5）**\n\n### 隐式动画\n每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。\n\n常见的动画属性：\n- bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画\n- backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画\n- position：用于设置CALayer的位置。修改这个属性会产生平移动画\n\n## 自定义layer\n### 第一种方式：新建layer类\n想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。\n\n如果在layer上画东西，与上面的过程类似。\n```objc\n#import \"YYMylayer.h\"\n@implementation YYMylayer\n//重写该方法，在该方法内绘制图形\n-(void)drawInContext:(CGContextRef)ctx\n{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n//    [[UIColor yellowColor]set];\t不能这样设置\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n     //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类\n2. 在自定义layer中`drawInContext:`方法不会自己调用，只能自己通过`setNeedDisplay`方法调用，在view中画东西`DrawRect:`方法在view第一次显示的时候会自动调用。\n\n在view中绘图：\n```objc\n#import \"YYVIEW.h\"\n@implementation YYVIEW\n- (void)drawRect:(CGRect)rect\n{\n    //1.获取上下文\n    CGContextRef ctx=UIGraphicsGetCurrentContext();\n    //2.绘制图形\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    //3.渲染\n    CGContextFillPath(ctx);\n    //在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法\n    //[self.layer drawInContext:ctx];\n}\n```\n\n### 第二种方式：实现delegate方法\n设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n```objc\n@implementation YYViewController\n- (void)viewDidLoad{\n    [super viewDidLoad];\n    //1.创建自定义的layer\n    CALayer *layer=[CALayer layer];\n    //2.设置layer的属性\n\t...\n    //设置代理\n    layer.delegate=self;\n    [layer setNeedsDisplay];\n    //3.添加layer\n    [self.view.layer addSublayer:layer];\n}\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);   \n    //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。\n2. 不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。\n\n### 补充\n1. 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n2. **当UIView需要显示时**，它内部的层会准备好一个CGContextRef(图形上下文)，然后**调用delegate(这里就是UIView)**的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。\n\n>Demo 详见 CALayer-transform\n","slug":"CALayer学习小结","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dny00027hzgydal7nxu","content":"<p>这两天想大致学习下animation的使用方法。看了<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\" target=\"_blank\" rel=\"external\">文顶顶的ios开发UI篇</a>专题，写的很好，学习了很多。再摘录部分，以作备忘。</p>\n<a id=\"more\"></a>\n<h2 id=\"CALayer简介\"><a href=\"#CALayer简介\" class=\"headerlink\" title=\"CALayer简介\"></a>CALayer简介</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。<br>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。<br>UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置边框的宽度为20</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderWidth=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置边框的颜色(borderColor是CGColor类型)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderColor=[<span class=\"built_in\">UIColor</span> greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置layer的圆角</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置超过子图层的部分裁减掉</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在view的图层上添加一个image，contents表示接受内容</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"cat\"</span>].CGImage;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置阴影的颜色</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowColor=[<span class=\"built_in\">UIColor</span> blackColor].CGColor;</div><div class=\"line\"><span class=\"comment\">//设置阴影的偏移量，如果为正数，则代表为往右边偏移</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOffset=<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">15</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//设置阴影的透明度(0~1之间，0表示完全透明)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOpacity=<span class=\"number\">0.6</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过uiview设置（2D效果）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.transform=<span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-100</span>);</div><div class=\"line\"><span class=\"comment\">//通过layer来设置（3D效果,x，y，z三个方向）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">100</span>, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">//旋转</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeRotation</span>(M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"创建图层\"><a href=\"#创建图层\" class=\"headerlink\" title=\"创建图层\"></a>创建图层</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//创建一个layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *Mylayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    Mylayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    Mylayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置需要显示的图片</span></div><div class=\"line\">    Mylayer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"me\"</span>].CGImage;</div><div class=\"line\">    <span class=\"comment\">//设置圆角半径为10</span></div><div class=\"line\">    Mylayer.cornerRadius=<span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"comment\">//如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果</span></div><div class=\"line\">    Mylayer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"comment\">//设置边框</span></div><div class=\"line\">    Mylayer.borderWidth=<span class=\"number\">3</span>;</div><div class=\"line\">    Mylayer.borderColor=[<span class=\"built_in\">UIColor</span> brownColor].CGColor;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//把layer添加到界面上</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:Mylayer];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。<br>如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>\n<h2 id=\"CAlayer属性\"><a href=\"#CAlayer属性\" class=\"headerlink\" title=\"CAlayer属性\"></a>CAlayer属性</h2><h3 id=\"position和anchorPoint\"><a href=\"#position和anchorPoint\" class=\"headerlink\" title=\"position和anchorPoint\"></a>position和anchorPoint</h3><ul>\n<li>position:设置CALayer在父层中的位置，这个位置要和锚点重合。</li>\n<li>anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，<strong>默认值为（0.5, 0.5）</strong></li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。</p>\n<p>常见的动画属性：</p>\n<ul>\n<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>\n<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>\n<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>\n</ul>\n<h2 id=\"自定义layer\"><a href=\"#自定义layer\" class=\"headerlink\" title=\"自定义layer\"></a>自定义layer</h2><h3 id=\"第一种方式：新建layer类\"><a href=\"#第一种方式：新建layer类\" class=\"headerlink\" title=\"第一种方式：新建layer类\"></a>第一种方式：新建layer类</h3><p>想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。</p>\n<p>如果在layer上画东西，与上面的过程类似。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYMylayer.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMylayer</span></span></div><div class=\"line\"><span class=\"comment\">//重写该方法，在该方法内绘制图形</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawInContext:(<span class=\"built_in\">CGContextRef</span>)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\"><span class=\"comment\">//    [[UIColor yellowColor]set];\t不能这样设置</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">     <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类</li>\n<li>在自定义layer中<code>drawInContext:</code>方法不会自己调用，只能自己通过<code>setNeedDisplay</code>方法调用，在view中画东西<code>DrawRect:</code>方法在view第一次显示的时候会自动调用。</li>\n</ol>\n<p>在view中绘图：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYVIEW.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYVIEW</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.获取上下文</span></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> ctx=<span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\">    <span class=\"comment\">//2.绘制图形</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//3.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">//在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法</span></div><div class=\"line\">    <span class=\"comment\">//[self.layer drawInContext:ctx];</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：实现delegate方法\"><a href=\"#第二种方式：实现delegate方法\" class=\"headerlink\" title=\"第二种方式：实现delegate方法\"></a>第二种方式：实现delegate方法</h3><p>设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//1.创建自定义的layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//2.设置layer的属性</span></div><div class=\"line\">\t...</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    layer.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    [layer setNeedsDisplay];</div><div class=\"line\">    <span class=\"comment\">//3.添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);   </div><div class=\"line\">    <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。</li>\n<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。</li>\n</ol>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n<li><strong>当UIView需要显示时</strong>，它内部的层会准备好一个CGContextRef(图形上下文)，然后<strong>调用delegate(这里就是UIView)</strong>的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。</li>\n</ol>\n<blockquote>\n<p>Demo 详见 CALayer-transform</p>\n</blockquote>\n","excerpt":"<p>这两天想大致学习下animation的使用方法。看了<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\">文顶顶的ios开发UI篇</a>专题，写的很好，学习了很多。再摘录部分，以作备忘。</p>","more":"<h2 id=\"CALayer简介\"><a href=\"#CALayer简介\" class=\"headerlink\" title=\"CALayer简介\"></a>CALayer简介</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。<br>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。<br>UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置边框的宽度为20</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderWidth=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置边框的颜色(borderColor是CGColor类型)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderColor=[<span class=\"built_in\">UIColor</span> greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置layer的圆角</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置超过子图层的部分裁减掉</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在view的图层上添加一个image，contents表示接受内容</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"cat\"</span>].CGImage;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置阴影的颜色</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowColor=[<span class=\"built_in\">UIColor</span> blackColor].CGColor;</div><div class=\"line\"><span class=\"comment\">//设置阴影的偏移量，如果为正数，则代表为往右边偏移</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOffset=<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">15</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//设置阴影的透明度(0~1之间，0表示完全透明)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOpacity=<span class=\"number\">0.6</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过uiview设置（2D效果）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.transform=<span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-100</span>);</div><div class=\"line\"><span class=\"comment\">//通过layer来设置（3D效果,x，y，z三个方向）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">100</span>, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">//旋转</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeRotation</span>(M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"创建图层\"><a href=\"#创建图层\" class=\"headerlink\" title=\"创建图层\"></a>创建图层</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//创建一个layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *Mylayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    Mylayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    Mylayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置需要显示的图片</span></div><div class=\"line\">    Mylayer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"me\"</span>].CGImage;</div><div class=\"line\">    <span class=\"comment\">//设置圆角半径为10</span></div><div class=\"line\">    Mylayer.cornerRadius=<span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"comment\">//如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果</span></div><div class=\"line\">    Mylayer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"comment\">//设置边框</span></div><div class=\"line\">    Mylayer.borderWidth=<span class=\"number\">3</span>;</div><div class=\"line\">    Mylayer.borderColor=[<span class=\"built_in\">UIColor</span> brownColor].CGColor;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//把layer添加到界面上</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:Mylayer];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。<br>如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>\n<h2 id=\"CAlayer属性\"><a href=\"#CAlayer属性\" class=\"headerlink\" title=\"CAlayer属性\"></a>CAlayer属性</h2><h3 id=\"position和anchorPoint\"><a href=\"#position和anchorPoint\" class=\"headerlink\" title=\"position和anchorPoint\"></a>position和anchorPoint</h3><ul>\n<li>position:设置CALayer在父层中的位置，这个位置要和锚点重合。</li>\n<li>anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，<strong>默认值为（0.5, 0.5）</strong></li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。</p>\n<p>常见的动画属性：</p>\n<ul>\n<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>\n<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>\n<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>\n</ul>\n<h2 id=\"自定义layer\"><a href=\"#自定义layer\" class=\"headerlink\" title=\"自定义layer\"></a>自定义layer</h2><h3 id=\"第一种方式：新建layer类\"><a href=\"#第一种方式：新建layer类\" class=\"headerlink\" title=\"第一种方式：新建layer类\"></a>第一种方式：新建layer类</h3><p>想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。</p>\n<p>如果在layer上画东西，与上面的过程类似。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYMylayer.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMylayer</span></span></div><div class=\"line\"><span class=\"comment\">//重写该方法，在该方法内绘制图形</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawInContext:(<span class=\"built_in\">CGContextRef</span>)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\"><span class=\"comment\">//    [[UIColor yellowColor]set];\t不能这样设置</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">     <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类</li>\n<li>在自定义layer中<code>drawInContext:</code>方法不会自己调用，只能自己通过<code>setNeedDisplay</code>方法调用，在view中画东西<code>DrawRect:</code>方法在view第一次显示的时候会自动调用。</li>\n</ol>\n<p>在view中绘图：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYVIEW.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYVIEW</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.获取上下文</span></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> ctx=<span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\">    <span class=\"comment\">//2.绘制图形</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//3.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">//在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法</span></div><div class=\"line\">    <span class=\"comment\">//[self.layer drawInContext:ctx];</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：实现delegate方法\"><a href=\"#第二种方式：实现delegate方法\" class=\"headerlink\" title=\"第二种方式：实现delegate方法\"></a>第二种方式：实现delegate方法</h3><p>设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//1.创建自定义的layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//2.设置layer的属性</span></div><div class=\"line\">\t...</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    layer.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    [layer setNeedsDisplay];</div><div class=\"line\">    <span class=\"comment\">//3.添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);   </div><div class=\"line\">    <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。</li>\n<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。</li>\n</ol>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n<li><strong>当UIView需要显示时</strong>，它内部的层会准备好一个CGContextRef(图形上下文)，然后<strong>调用delegate(这里就是UIView)</strong>的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。</li>\n</ol>\n<blockquote>\n<p>Demo 详见 CALayer-transform</p>\n</blockquote>"},{"title":"GCD队列 学习与整理","date":"2016-08-02T06:07:12.000Z","_content":"\nGrand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。\n\n<!--more-->\n\n### 基本概念\n- **Serial vs. Concurrent 串行 vs. 并发**\n这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。\n- **Synchronous vs. Asynchronous 同步 vs. 异步**\n在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。\n\n### 队列分类\n1. **Serial Queues 串行队列**\n这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。\n由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。\n2. **Concurrent Queues 并发队列**\n在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。\n\n### 队列类型\n1. **The main queue**\n与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。\n2. **Global queues**\n全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。\n3. **用户队列**\n用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。\n\n### 队列创建方式\n1. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.serial\", DISPATCH_QUEUE_SERIAL);**\n生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。\n2. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.concurrent\", DISPATCH_QUEUE_CONCURRENT);**\n生成一个并发执行队列。\n3. **dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);**\n获得全局队列。\n4. **dispatch_queue_t queue = dispatch_get_main_queue()**\n获得主线程队列。\n\n### 提交 Job\n向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。\n\n1. **dispatch_async**\ndispatch_async 函数会立即返回, block会在后台异步执行。\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        NSLog(@\"Done doing something long and involved\");\n});\n```\n\t在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [textField setStringValue:@\"Done doing something long and involved\"];\n        });\n});\n```\n2. **dispatch_sync**\ndispatch_sync 同步执行 block，函数不返回，一直等到 block 执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。\n\n实际编程经验告诉我们，尽可能避免使用 dispatch_sync，嵌套使用同一个队列时极易产生程序死锁，比如嵌套调用主线程：\n\n![gcd_死锁](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true)\n\n### 总结\n**队列是串行或并发的，操作队列的函数是同步或者异步执行的（也就是在当前线程执行完返回和立即返回另开线程执行的区别）。串行队列其实就相当于加了一个资源锁，无论在多少个线程里，只有当队列中前一个元素执行完，后一个元素的代码块才能继续执行，并行队列则没有任何要求，有需要执行就立即执行。** \n\n比如下面写在主线程里的示例的四种组合：\n\n```objc\nfor (int i = 1; i < 10; i++) {  \n    dispatch_(a)sync(queue, ^{  \n        NSLog(@\"%d___%@\",i, [NSThread currentThread]);  \n    });  \n} \n\nNSLog(@\"over\");\n```\n\n结论:\n- 串行同步队列：运行在主线程里，先依次打印 `i` 后，再打印 `over`。\n- 串行异步队列：先打印 `over`，再依次打印 `i`。由于是异步的，`over` 执行在主线程里毋庸置疑，打印 `i` 时，新建了一个线程。为什么是一个呢？因为串行队列，代码块依次执行。创建新线程，执行，销毁，再创建新线程的操作太耗时。所以编译器优化后，仅创建了一个新线程。\n- 并行同步队列：运行在主线程里，先依次打印 `i` 后，再打印 `over`。现在看起来和串行同步队列一样对不对？那么什么时候才不同呢？假如你手动开了一个线程，并且在那个线程里，又运行了一遍上面的代码。串行同步队列由于有锁，执行当前代码块的时候，另一个线程处于阻塞状态，只能等到当前代码块执行完毕才能跳到另一个线程；并行同步队列没有锁，可能代码块没有执行完，由于线程的时间片用完了，就立即跳到另外一个线程上去执行了。\n- 并行异步队列：先打印 `over`，然后瞎JB打印`i`。\n\n\n\n\n\n\n\n\n### 常用方法\n#### dispatch_apply\n重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n\n``` objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_apply([array count], queue, ^(size_t index){\n    [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n});\n[self doSomethingWith:array];\n```\n\n如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_async(queue, ^{\n    dispatch_apply([array count], queue, ^(size_t index){\n        [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n    });\n    [self doSomethingWith:array];\n});\n```\n\n那何时才适合用 dispatch_apply 呢？\n\n- 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。\n- 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。\n- 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。\n\n\n#### dispatch_after\n延迟提交 block：\n\n```objc\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n     // code to be executed on the main queue after delay\n});\n```\n\ndispatch_after 是延迟提交，不是延迟运行，**不是在特定的时间后立即运行！**：\n\n```objc\n//创建串行队列\ndispatch_queue_t queue = dispatch_queue_create(\"me.tutuge.test.gcd\", DISPATCH_QUEUE_SERIAL);\n\n//立即打印一条信息\nNSLog(@\"Begin add block...\");\n\n//提交一个block\ndispatch_async(queue, ^{\n    //Sleep 10秒\n    [NSThread sleepForTimeInterval:10];\n    NSLog(@\"First block done...\");\n});\n\n//5 秒以后提交block\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), queue, ^{\n    NSLog(@\"After...\");\n});\n```\n\n结果如下:\n\n```objc\n2015-03-31 20:57:27.122 GCDTest[45633:1812016] Begin add block...\n2015-03-31 20:57:37.127 GCDTest[45633:1812041] First block done...\n2015-03-31 20:57:37.127 GCDTest[45633:1812041] After...\n```\n\n对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。\n\n#### dispatch_once\n保证在APP运行期间，block中的代码只执行一次\n```objc\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    // code to be executed once\n});\n```\n\n一定要注意的是 `dispatch_once_t` **必须是全局或 static 变量**。否则使用时会导致非常不好排查的 bug。\n\n#### dispatch_group\n一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。\n- *dispatch_group_create*创建一个调度任务组\n- *dispatch_group_async* 把一个任务异步提交到任务组里\n- *dispatch_group_notify* 用来监听任务组事件的执行完毕\n- *dispatch_group_wait* 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\nfor(id obj in array)\n    dispatch_group_async(group, queue, ^{\n        [self doSomethingIntensiveWith:obj];\n    });\ndispatch_group_notify(group, queue, ^{\n    [self doSomethingWith:array];\n});\n```\n\n\n还有一个参考文章：\n[GCD使用经验与技巧浅谈](http://tutuge.me/2015/04/03/something-about-gcd/)\n\n","source":"_posts/GCD队列.md","raw":"title: GCD队列 学习与整理\ndate: 2016/8/2 14:07:12  \ncategories: iOS\ntags: [GCD]\n\n---\n\nGrand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。\n\n<!--more-->\n\n### 基本概念\n- **Serial vs. Concurrent 串行 vs. 并发**\n这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。\n- **Synchronous vs. Asynchronous 同步 vs. 异步**\n在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。\n\n### 队列分类\n1. **Serial Queues 串行队列**\n这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。\n由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。\n2. **Concurrent Queues 并发队列**\n在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。\n\n### 队列类型\n1. **The main queue**\n与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。\n2. **Global queues**\n全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。\n3. **用户队列**\n用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。\n\n### 队列创建方式\n1. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.serial\", DISPATCH_QUEUE_SERIAL);**\n生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。\n2. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.concurrent\", DISPATCH_QUEUE_CONCURRENT);**\n生成一个并发执行队列。\n3. **dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);**\n获得全局队列。\n4. **dispatch_queue_t queue = dispatch_get_main_queue()**\n获得主线程队列。\n\n### 提交 Job\n向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。\n\n1. **dispatch_async**\ndispatch_async 函数会立即返回, block会在后台异步执行。\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        NSLog(@\"Done doing something long and involved\");\n});\n```\n\t在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [textField setStringValue:@\"Done doing something long and involved\"];\n        });\n});\n```\n2. **dispatch_sync**\ndispatch_sync 同步执行 block，函数不返回，一直等到 block 执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。\n\n实际编程经验告诉我们，尽可能避免使用 dispatch_sync，嵌套使用同一个队列时极易产生程序死锁，比如嵌套调用主线程：\n\n![gcd_死锁](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true)\n\n### 总结\n**队列是串行或并发的，操作队列的函数是同步或者异步执行的（也就是在当前线程执行完返回和立即返回另开线程执行的区别）。串行队列其实就相当于加了一个资源锁，无论在多少个线程里，只有当队列中前一个元素执行完，后一个元素的代码块才能继续执行，并行队列则没有任何要求，有需要执行就立即执行。** \n\n比如下面写在主线程里的示例的四种组合：\n\n```objc\nfor (int i = 1; i < 10; i++) {  \n    dispatch_(a)sync(queue, ^{  \n        NSLog(@\"%d___%@\",i, [NSThread currentThread]);  \n    });  \n} \n\nNSLog(@\"over\");\n```\n\n结论:\n- 串行同步队列：运行在主线程里，先依次打印 `i` 后，再打印 `over`。\n- 串行异步队列：先打印 `over`，再依次打印 `i`。由于是异步的，`over` 执行在主线程里毋庸置疑，打印 `i` 时，新建了一个线程。为什么是一个呢？因为串行队列，代码块依次执行。创建新线程，执行，销毁，再创建新线程的操作太耗时。所以编译器优化后，仅创建了一个新线程。\n- 并行同步队列：运行在主线程里，先依次打印 `i` 后，再打印 `over`。现在看起来和串行同步队列一样对不对？那么什么时候才不同呢？假如你手动开了一个线程，并且在那个线程里，又运行了一遍上面的代码。串行同步队列由于有锁，执行当前代码块的时候，另一个线程处于阻塞状态，只能等到当前代码块执行完毕才能跳到另一个线程；并行同步队列没有锁，可能代码块没有执行完，由于线程的时间片用完了，就立即跳到另外一个线程上去执行了。\n- 并行异步队列：先打印 `over`，然后瞎JB打印`i`。\n\n\n\n\n\n\n\n\n### 常用方法\n#### dispatch_apply\n重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n\n``` objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_apply([array count], queue, ^(size_t index){\n    [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n});\n[self doSomethingWith:array];\n```\n\n如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。\n\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_async(queue, ^{\n    dispatch_apply([array count], queue, ^(size_t index){\n        [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n    });\n    [self doSomethingWith:array];\n});\n```\n\n那何时才适合用 dispatch_apply 呢？\n\n- 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。\n- 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。\n- 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。\n\n\n#### dispatch_after\n延迟提交 block：\n\n```objc\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n     // code to be executed on the main queue after delay\n});\n```\n\ndispatch_after 是延迟提交，不是延迟运行，**不是在特定的时间后立即运行！**：\n\n```objc\n//创建串行队列\ndispatch_queue_t queue = dispatch_queue_create(\"me.tutuge.test.gcd\", DISPATCH_QUEUE_SERIAL);\n\n//立即打印一条信息\nNSLog(@\"Begin add block...\");\n\n//提交一个block\ndispatch_async(queue, ^{\n    //Sleep 10秒\n    [NSThread sleepForTimeInterval:10];\n    NSLog(@\"First block done...\");\n});\n\n//5 秒以后提交block\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), queue, ^{\n    NSLog(@\"After...\");\n});\n```\n\n结果如下:\n\n```objc\n2015-03-31 20:57:27.122 GCDTest[45633:1812016] Begin add block...\n2015-03-31 20:57:37.127 GCDTest[45633:1812041] First block done...\n2015-03-31 20:57:37.127 GCDTest[45633:1812041] After...\n```\n\n对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。\n\n#### dispatch_once\n保证在APP运行期间，block中的代码只执行一次\n```objc\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    // code to be executed once\n});\n```\n\n一定要注意的是 `dispatch_once_t` **必须是全局或 static 变量**。否则使用时会导致非常不好排查的 bug。\n\n#### dispatch_group\n一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。\n- *dispatch_group_create*创建一个调度任务组\n- *dispatch_group_async* 把一个任务异步提交到任务组里\n- *dispatch_group_notify* 用来监听任务组事件的执行完毕\n- *dispatch_group_wait* 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\nfor(id obj in array)\n    dispatch_group_async(group, queue, ^{\n        [self doSomethingIntensiveWith:obj];\n    });\ndispatch_group_notify(group, queue, ^{\n    [self doSomethingWith:array];\n});\n```\n\n\n还有一个参考文章：\n[GCD使用经验与技巧浅谈](http://tutuge.me/2015/04/03/something-about-gcd/)\n\n","slug":"GCD队列","published":1,"updated":"2017-01-03T06:21:41.000Z","_id":"cixh41do400057hzgrwfaok2a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><strong>Serial vs. Concurrent 串行 vs. 并发</strong><br>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</li>\n<li><strong>Synchronous vs. Asynchronous 同步 vs. 异步</strong><br>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</li>\n</ul>\n<h3 id=\"队列分类\"><a href=\"#队列分类\" class=\"headerlink\" title=\"队列分类\"></a>队列分类</h3><ol>\n<li><strong>Serial Queues 串行队列</strong><br>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。<br>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。</li>\n<li><strong>Concurrent Queues 并发队列</strong><br>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</li>\n</ol>\n<h3 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h3><ol>\n<li><strong>The main queue</strong><br>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。</li>\n<li><strong>Global queues</strong><br>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。</li>\n<li><strong>用户队列</strong><br>用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。</li>\n</ol>\n<h3 id=\"队列创建方式\"><a href=\"#队列创建方式\" class=\"headerlink\" title=\"队列创建方式\"></a>队列创建方式</h3><ol>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);</strong><br>生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。</li>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);</strong><br>生成一个并发执行队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</strong><br>获得全局队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_main_queue()</strong><br>获得主线程队列。</li>\n</ol>\n<h3 id=\"提交-Job\"><a href=\"#提交-Job\" class=\"headerlink\" title=\"提交 Job\"></a>提交 Job</h3><p>向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。</p>\n<ol>\n<li><p><strong>dispatch_async</strong><br>dispatch_async 函数会立即返回, block会在后台异步执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Done doing something long and involved\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [textField setStringValue:<span class=\"string\">@\"Done doing something long and involved\"</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_sync</strong><br>dispatch_sync 同步执行 block，函数不返回，一直等到 block 执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。</p>\n</li>\n</ol>\n<p>实际编程经验告诉我们，尽可能避免使用 dispatch_sync，嵌套使用同一个队列时极易产生程序死锁，比如嵌套调用主线程：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true\" alt=\"gcd_死锁\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>队列是串行或并发的，操作队列的函数是同步或者异步执行的（也就是在当前线程执行完返回和立即返回另开线程执行的区别）。串行队列其实就相当于加了一个资源锁，无论在多少个线程里，只有当队列中前一个元素执行完，后一个元素的代码块才能继续执行，并行队列则没有任何要求，有需要执行就立即执行。</strong> </p>\n<p>比如下面写在主线程里的示例的四种组合：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;  </div><div class=\"line\">    dispatch_(a)sync(queue, ^&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d___%@\"</span>,i, [<span class=\"built_in\">NSThread</span> currentThread]);  </div><div class=\"line\">    &#125;);  </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"over\"</span>);</div></pre></td></tr></table></figure>\n<p>结论:</p>\n<ul>\n<li>串行同步队列：运行在主线程里，先依次打印 <code>i</code> 后，再打印 <code>over</code>。</li>\n<li>串行异步队列：先打印 <code>over</code>，再依次打印 <code>i</code>。由于是异步的，<code>over</code> 执行在主线程里毋庸置疑，打印 <code>i</code> 时，新建了一个线程。为什么是一个呢？因为串行队列，代码块依次执行。创建新线程，执行，销毁，再创建新线程的操作太耗时。所以编译器优化后，仅创建了一个新线程。</li>\n<li>并行同步队列：运行在主线程里，先依次打印 <code>i</code> 后，再打印 <code>over</code>。现在看起来和串行同步队列一样对不对？那么什么时候才不同呢？假如你手动开了一个线程，并且在那个线程里，又运行了一遍上面的代码。串行同步队列由于有锁，执行当前代码块的时候，另一个线程处于阻塞状态，只能等到当前代码块执行完毕才能跳到另一个线程；并行同步队列没有锁，可能代码块没有执行完，由于线程的时间片用完了，就立即跳到另外一个线程上去执行了。</li>\n<li>并行异步队列：先打印 <code>over</code>，然后瞎JB打印<code>i</code>。</li>\n</ul>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h4><p>重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">&#125;);</div><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWith:array];</div></pre></td></tr></table></figure>\n<p>如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>那何时才适合用 dispatch_apply 呢？</p>\n<ul>\n<li>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</li>\n<li>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</li>\n<li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li>\n</ul>\n<h4 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h4><p>延迟提交 block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> delayInSeconds = <span class=\"number\">1.0</span>; </div><div class=\"line\">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">     <span class=\"comment\">// code to be executed on the main queue after delay</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>dispatch_after 是延迟提交，不是延迟运行，<strong>不是在特定的时间后立即运行！</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建串行队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"me.tutuge.test.gcd\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//立即打印一条信息</span></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Begin add block...\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//提交一个block</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    <span class=\"comment\">//Sleep 10秒</span></div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"First block done...\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//5 秒以后提交block</span></div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"After...\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>结果如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">27.122</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812016</span>] Begin add block...</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.127</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812041</span>] First block done...</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.127</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812041</span>] After...</div></pre></td></tr></table></figure>\n<p>对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。</p>\n<h4 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h4><p>保证在APP运行期间，block中的代码只执行一次<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// code to be executed once</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>一定要注意的是 <code>dispatch_once_t</code> <strong>必须是全局或 static 变量</strong>。否则使用时会导致非常不好排查的 bug。</p>\n<h4 id=\"dispatch-group\"><a href=\"#dispatch-group\" class=\"headerlink\" title=\"dispatch_group\"></a>dispatch_group</h4><p>一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。</p>\n<ul>\n<li><em>dispatch_group_create</em>创建一个调度任务组</li>\n<li><em>dispatch_group_async</em> 把一个任务异步提交到任务组里</li>\n<li><em>dispatch_group_notify</em> 用来监听任务组事件的执行完毕</li>\n<li><em>dispatch_group_wait</em> 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array)</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:obj];</div><div class=\"line\">    &#125;);</div><div class=\"line\">dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>还有一个参考文章：<br><a href=\"http://tutuge.me/2015/04/03/something-about-gcd/\" target=\"_blank\" rel=\"external\">GCD使用经验与技巧浅谈</a></p>\n","excerpt":"<p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><strong>Serial vs. Concurrent 串行 vs. 并发</strong><br>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</li>\n<li><strong>Synchronous vs. Asynchronous 同步 vs. 异步</strong><br>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</li>\n</ul>\n<h3 id=\"队列分类\"><a href=\"#队列分类\" class=\"headerlink\" title=\"队列分类\"></a>队列分类</h3><ol>\n<li><strong>Serial Queues 串行队列</strong><br>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。<br>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。</li>\n<li><strong>Concurrent Queues 并发队列</strong><br>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</li>\n</ol>\n<h3 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h3><ol>\n<li><strong>The main queue</strong><br>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。</li>\n<li><strong>Global queues</strong><br>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。</li>\n<li><strong>用户队列</strong><br>用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。</li>\n</ol>\n<h3 id=\"队列创建方式\"><a href=\"#队列创建方式\" class=\"headerlink\" title=\"队列创建方式\"></a>队列创建方式</h3><ol>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);</strong><br>生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。</li>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);</strong><br>生成一个并发执行队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</strong><br>获得全局队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_main_queue()</strong><br>获得主线程队列。</li>\n</ol>\n<h3 id=\"提交-Job\"><a href=\"#提交-Job\" class=\"headerlink\" title=\"提交 Job\"></a>提交 Job</h3><p>向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。</p>\n<ol>\n<li><p><strong>dispatch_async</strong><br>dispatch_async 函数会立即返回, block会在后台异步执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Done doing something long and involved\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [textField setStringValue:<span class=\"string\">@\"Done doing something long and involved\"</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_sync</strong><br>dispatch_sync 同步执行 block，函数不返回，一直等到 block 执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。</p>\n</li>\n</ol>\n<p>实际编程经验告诉我们，尽可能避免使用 dispatch_sync，嵌套使用同一个队列时极易产生程序死锁，比如嵌套调用主线程：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true\" alt=\"gcd_死锁\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>队列是串行或并发的，操作队列的函数是同步或者异步执行的（也就是在当前线程执行完返回和立即返回另开线程执行的区别）。串行队列其实就相当于加了一个资源锁，无论在多少个线程里，只有当队列中前一个元素执行完，后一个元素的代码块才能继续执行，并行队列则没有任何要求，有需要执行就立即执行。</strong> </p>\n<p>比如下面写在主线程里的示例的四种组合：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;  </div><div class=\"line\">    dispatch_(a)sync(queue, ^&#123;  </div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d___%@\"</span>,i, [<span class=\"built_in\">NSThread</span> currentThread]);  </div><div class=\"line\">    &#125;);  </div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"over\"</span>);</div></pre></td></tr></table></figure>\n<p>结论:</p>\n<ul>\n<li>串行同步队列：运行在主线程里，先依次打印 <code>i</code> 后，再打印 <code>over</code>。</li>\n<li>串行异步队列：先打印 <code>over</code>，再依次打印 <code>i</code>。由于是异步的，<code>over</code> 执行在主线程里毋庸置疑，打印 <code>i</code> 时，新建了一个线程。为什么是一个呢？因为串行队列，代码块依次执行。创建新线程，执行，销毁，再创建新线程的操作太耗时。所以编译器优化后，仅创建了一个新线程。</li>\n<li>并行同步队列：运行在主线程里，先依次打印 <code>i</code> 后，再打印 <code>over</code>。现在看起来和串行同步队列一样对不对？那么什么时候才不同呢？假如你手动开了一个线程，并且在那个线程里，又运行了一遍上面的代码。串行同步队列由于有锁，执行当前代码块的时候，另一个线程处于阻塞状态，只能等到当前代码块执行完毕才能跳到另一个线程；并行同步队列没有锁，可能代码块没有执行完，由于线程的时间片用完了，就立即跳到另外一个线程上去执行了。</li>\n<li>并行异步队列：先打印 <code>over</code>，然后瞎JB打印<code>i</code>。</li>\n</ul>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h4><p>重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">&#125;);</div><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWith:array];</div></pre></td></tr></table></figure>\n<p>如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>那何时才适合用 dispatch_apply 呢？</p>\n<ul>\n<li>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</li>\n<li>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</li>\n<li>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</li>\n</ul>\n<h4 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h4><p>延迟提交 block：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> delayInSeconds = <span class=\"number\">1.0</span>; </div><div class=\"line\">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">     <span class=\"comment\">// code to be executed on the main queue after delay</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>dispatch_after 是延迟提交，不是延迟运行，<strong>不是在特定的时间后立即运行！</strong>：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建串行队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">\"me.tutuge.test.gcd\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//立即打印一条信息</span></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Begin add block...\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//提交一个block</span></div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    <span class=\"comment\">//Sleep 10秒</span></div><div class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">10</span>];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"First block done...\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//5 秒以后提交block</span></div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5</span> * <span class=\"built_in\">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"After...\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>结果如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">27.122</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812016</span>] Begin add block...</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.127</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812041</span>] First block done...</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-03</span><span class=\"number\">-31</span> <span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.127</span> GCDTest[<span class=\"number\">45633</span>:<span class=\"number\">1812041</span>] After...</div></pre></td></tr></table></figure>\n<p>对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。</p>\n<h4 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h4><p>保证在APP运行期间，block中的代码只执行一次<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// code to be executed once</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>一定要注意的是 <code>dispatch_once_t</code> <strong>必须是全局或 static 变量</strong>。否则使用时会导致非常不好排查的 bug。</p>\n<h4 id=\"dispatch-group\"><a href=\"#dispatch-group\" class=\"headerlink\" title=\"dispatch_group\"></a>dispatch_group</h4><p>一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。</p>\n<ul>\n<li><em>dispatch_group_create</em>创建一个调度任务组</li>\n<li><em>dispatch_group_async</em> 把一个任务异步提交到任务组里</li>\n<li><em>dispatch_group_notify</em> 用来监听任务组事件的执行完毕</li>\n<li><em>dispatch_group_wait</em> 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array)</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:obj];</div><div class=\"line\">    &#125;);</div><div class=\"line\">dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>还有一个参考文章：<br><a href=\"http://tutuge.me/2015/04/03/something-about-gcd/\">GCD使用经验与技巧浅谈</a></p>"},{"title":"HTTP详解","date":"2016-12-24T08:07:12.000Z","_content":"\n网络协议这块一直没有搞透彻，趁着苹果强制 ATS（App Transport Security）未果，学习一下这方面的知识。\n\n<!--more-->\n\n## HTTP的构成\n### HTTP Request\nhttp 请求主要分为三部分，如下图所示。`request line`，`header` 和 `body`，中间的CRLF为换行符。\n\n![http请求组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http请求.png?raw=true)\n\n下面将以一个实际的 http 请求来详细看看其内部构造。假设我们的请求URL为：\n`http://www.baidu.com/res/static/thirdparty/connect.jpg?t=1480992153433`\n\n#### Request Line\n\n请求行的结构为：\n\n```\nRequest-Line   = Method SP Request-URI SP HTTP-Version CRLF\n```\n\n- **Method**:请求类型，例如 `post/get`。\n- **SP**:分隔符，一般就是空格。\n- **Request-URI**:对应上述请求为：`/res/static/thirdparty/connect.jpg?t=1480992153.564331`。注意，Request-URI 也可以是带 host 的完整 uri。不带的话，就要在 `Header` 里添加 host。\n- **HTTP-Version**:代表我们当前使用的版本，例如 `HTTP/1.1`\n- **CRLF**:`CR` 对应回车键，`LF`对应换行键，合起来就是我们平常所说的 `\\r\\n`。\n\n所以上述请求的 Request-Line 的文本展示：\n>GET /res/static/thirdparty/connect.jpg?t=1480992153.564331 HTTP/1.1CRLF\n\n#### Header\nheader 其本质上是一些文本键值对，一个典型的例子如下图所示：\n\n![header](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_header.png?raw=true)\n\n结构为：\n\n```\nKey:空格ValueCRLF\n```\n\n上面讲述 Request-URI 的时候，缺失的 `Host` 就以键值对的形式存在于 header 中，比如， `Host： pan.baidu.com`。\n\n将若干个上述格式的键值对组合起来，就成了我们 HTTP 请求的完整 header。最后一个键值对之后再跟一个 `CRLF`，就表示我们的 header 结束了。\n\n#### Body\nbody 里面包含请求的实际数据。\n\n对于 `Method=GET` 的请求来说，body 体是为空的，Header 最后的两个 `CRLF` 就标识着请求的结尾。我们一般调用请求的业务参数是通过 Request Line 当中的 Request-URI 来传递的，比如上述请求中的 `?t=1480992153.564331`，也就是 URI 的 query string 部分。这部分同样是以键值对的形式存在，不过是位于 Request Line 当中。\n\n对于 `Method=POST` 的请求来说，实际的业务数据都存放于 body 当中。**POST 请求可以根据 Header 中的 `Content-Type` 值，以不同的形式将数据保存在 body 体中。获取到请求后，可以仍然通过 Header 中的 `Content-Length` 值，读取固定长度的body体，直接传递给应用层** \n\n### HTTP Response\nresponse 的结构和 request 大致相似，不过是将 Request Line 换成了 Status Line 。\n\n![http_response](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_response.png?raw=true)\n\nStatus Line 的结构如下：\n```\nStatus-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n```\n\n### Content-Type\nContent-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定**请求和响应**的 HTTP 内容类型。如果未指定  ContentType，默认为 `text/html`。\n\n一些常见的 Content-Type:\n- text/html\n- text/plain\n- text/css\n- text/javascript\n- application/x-www-form-urlencoded\n- multipart/form-data\n- application/json\n- application/xml\n\n前面几个都很好理解，都是 html，css，javascript 的文件类型，**后面四个是POST 的发包方式**。\n\n那我们什么时候用 `application/x-www-form-urlencoded`，什么时候用 `multipart/form-data` 呢？大文件如文件图片用后者，小文件如键值对用前者。\n\n## HTTPS\n### 基本介绍\nHTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。比如运营商可以轻易劫持你的 http 请求，在 response 中注入 js代码（如网页上弹窗广告、流量球等），甚至是重定向。为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。之后对 SSL 进行了升级为 TLS（Transport Layer Security）。我们现在的 HTTPS 都是用的 TLS 协议。\n\n### 工作原理\n总共分为以下几步：\n1. 浏览器将自己支持的一套加密规则发送给网站。\n2. 网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。\n3. 获得网站证书之后浏览器要做以下工作：\n\t1. 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。\n\t2. 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。\n\t3. 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。\n4. 网站接收浏览器发来的数据之后要做以下的操作：\n\t1. 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。\n\t2. 使用密码加密一段握手消息，发送给浏览器。\n5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。\n\n这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。\n\n其中**非对称加密算法用于在握手过程中加密生成的密码**，**对称加密算法用于对真正传输的数据进行加密**，而 **HASH 算法用于验证数据的完整性**。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。\n\n为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。\n\n### 证书的验证过程\n证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书。\n\n### SSL劫持\nSSL 劫持也就是 SSL 证书欺骗攻击，攻击者为了获得 HTTPS 传输的明文数据，需要先将自己接入到浏览器与目标网站之间（中间人），在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输中的数据，简单的图示如下：\n\n>[浏览器] <======> [目标网站] （正常情况）\n>[浏览器] <======> 中间人 <======> [目标网站] （中间人攻击）\n\n中间人攻击最好的环境是在局域网中，局域网中所有的计算机需要通过一个固定的出口（网关）来接入互联网，因此攻击者只需要在局域网中实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。\n\n**中间人攻击(Man-in-the-Middle Attack，缩写 MITM)**。\n\n[参考链接:HTTPS那些事（一）HTTPS原理](http://www.guokr.com/post/114121/)\n\n\n\n## 抓包工具 mitmproxy 使用\nmitmproxy 是一款命令行抓包工具，它除了可以抓包查看 http/https 请求，还可以拦截并修改 request 或者 response。\n\n### 安装\n首先需要安装 python 的包管理工具 pip。 OSX El Capitan 及以上的系统版本在安装时会出现 six 模块依赖错误，所以需要执行以下命令进行安装：\n\n```\nsudo pip install mitmproxy --ignore-installed six\n```\n\n### 配置\n手机和电脑在同一局域网下，设置手机的 http 代理。服务器为电脑当前的 ip，如 192.168.3.10；端口可任意设置，一般设置为8080。网络环境配置好后，在终端输入 `mitmproxy -p 8080`，进入抓包模式。\n\n如果想要抓取 https 的包，需要进一步配置。用 iPhone 打开 Safari 浏览器并输入 mitm.it，这时你会看到如下页面，选择对应平台并安装证书，安装完成后就可以抓 https 的包了。注意，用浏览器打开时需要已经在抓包模式，否则是无法看到上述页面的。\n\n抓包软件相当于在用户和服务器间增加了一个中间人。安装抓包软件的证书，这样中间人就可以获得用户端生成的密钥，就能够解密用户和服务器间的信息。**注意，一定不可随意下载信任不明的证书**\n\n![下载证书](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/httpproxy_certificate.png?raw=true)\n\n### 使用\n随便打开一个 app，就可以看到如下的一个请求列表。\n![http请求列表](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_request.png?raw=true)\n\n常用快捷键：\n- enter: 查看详细请求\n- Tab: 切换顶部导航栏\n- z: 清空列表\n- f: 过滤请求。可以参照帮助中的 Filter expression 对过滤关键字进行编辑。删除过滤就是将过滤关键字清空。\n- d: 删除请求\n- C: 复制请求。直接选中复制可能会复制进空格非常麻烦，可以通过 C 来选择复制的内容。\n\n关于如何拦截和修改 request 和 response 可以参见[抓包教程](http://ios.jobbole.com/90841/)","source":"_posts/HTTP的构成.md","raw":"\ntitle: HTTP详解\ndate: 2016/12/24 16:07:12  \ncategories: 计算机\ntags:\n\t- 学习笔记\n\n---\n\n网络协议这块一直没有搞透彻，趁着苹果强制 ATS（App Transport Security）未果，学习一下这方面的知识。\n\n<!--more-->\n\n## HTTP的构成\n### HTTP Request\nhttp 请求主要分为三部分，如下图所示。`request line`，`header` 和 `body`，中间的CRLF为换行符。\n\n![http请求组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http请求.png?raw=true)\n\n下面将以一个实际的 http 请求来详细看看其内部构造。假设我们的请求URL为：\n`http://www.baidu.com/res/static/thirdparty/connect.jpg?t=1480992153433`\n\n#### Request Line\n\n请求行的结构为：\n\n```\nRequest-Line   = Method SP Request-URI SP HTTP-Version CRLF\n```\n\n- **Method**:请求类型，例如 `post/get`。\n- **SP**:分隔符，一般就是空格。\n- **Request-URI**:对应上述请求为：`/res/static/thirdparty/connect.jpg?t=1480992153.564331`。注意，Request-URI 也可以是带 host 的完整 uri。不带的话，就要在 `Header` 里添加 host。\n- **HTTP-Version**:代表我们当前使用的版本，例如 `HTTP/1.1`\n- **CRLF**:`CR` 对应回车键，`LF`对应换行键，合起来就是我们平常所说的 `\\r\\n`。\n\n所以上述请求的 Request-Line 的文本展示：\n>GET /res/static/thirdparty/connect.jpg?t=1480992153.564331 HTTP/1.1CRLF\n\n#### Header\nheader 其本质上是一些文本键值对，一个典型的例子如下图所示：\n\n![header](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_header.png?raw=true)\n\n结构为：\n\n```\nKey:空格ValueCRLF\n```\n\n上面讲述 Request-URI 的时候，缺失的 `Host` 就以键值对的形式存在于 header 中，比如， `Host： pan.baidu.com`。\n\n将若干个上述格式的键值对组合起来，就成了我们 HTTP 请求的完整 header。最后一个键值对之后再跟一个 `CRLF`，就表示我们的 header 结束了。\n\n#### Body\nbody 里面包含请求的实际数据。\n\n对于 `Method=GET` 的请求来说，body 体是为空的，Header 最后的两个 `CRLF` 就标识着请求的结尾。我们一般调用请求的业务参数是通过 Request Line 当中的 Request-URI 来传递的，比如上述请求中的 `?t=1480992153.564331`，也就是 URI 的 query string 部分。这部分同样是以键值对的形式存在，不过是位于 Request Line 当中。\n\n对于 `Method=POST` 的请求来说，实际的业务数据都存放于 body 当中。**POST 请求可以根据 Header 中的 `Content-Type` 值，以不同的形式将数据保存在 body 体中。获取到请求后，可以仍然通过 Header 中的 `Content-Length` 值，读取固定长度的body体，直接传递给应用层** \n\n### HTTP Response\nresponse 的结构和 request 大致相似，不过是将 Request Line 换成了 Status Line 。\n\n![http_response](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_response.png?raw=true)\n\nStatus Line 的结构如下：\n```\nStatus-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n```\n\n### Content-Type\nContent-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定**请求和响应**的 HTTP 内容类型。如果未指定  ContentType，默认为 `text/html`。\n\n一些常见的 Content-Type:\n- text/html\n- text/plain\n- text/css\n- text/javascript\n- application/x-www-form-urlencoded\n- multipart/form-data\n- application/json\n- application/xml\n\n前面几个都很好理解，都是 html，css，javascript 的文件类型，**后面四个是POST 的发包方式**。\n\n那我们什么时候用 `application/x-www-form-urlencoded`，什么时候用 `multipart/form-data` 呢？大文件如文件图片用后者，小文件如键值对用前者。\n\n## HTTPS\n### 基本介绍\nHTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。比如运营商可以轻易劫持你的 http 请求，在 response 中注入 js代码（如网页上弹窗广告、流量球等），甚至是重定向。为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。之后对 SSL 进行了升级为 TLS（Transport Layer Security）。我们现在的 HTTPS 都是用的 TLS 协议。\n\n### 工作原理\n总共分为以下几步：\n1. 浏览器将自己支持的一套加密规则发送给网站。\n2. 网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。\n3. 获得网站证书之后浏览器要做以下工作：\n\t1. 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。\n\t2. 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。\n\t3. 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。\n4. 网站接收浏览器发来的数据之后要做以下的操作：\n\t1. 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。\n\t2. 使用密码加密一段握手消息，发送给浏览器。\n5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。\n\n这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。\n\n其中**非对称加密算法用于在握手过程中加密生成的密码**，**对称加密算法用于对真正传输的数据进行加密**，而 **HASH 算法用于验证数据的完整性**。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。\n\n为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。\n\n### 证书的验证过程\n证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书。\n\n### SSL劫持\nSSL 劫持也就是 SSL 证书欺骗攻击，攻击者为了获得 HTTPS 传输的明文数据，需要先将自己接入到浏览器与目标网站之间（中间人），在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输中的数据，简单的图示如下：\n\n>[浏览器] <======> [目标网站] （正常情况）\n>[浏览器] <======> 中间人 <======> [目标网站] （中间人攻击）\n\n中间人攻击最好的环境是在局域网中，局域网中所有的计算机需要通过一个固定的出口（网关）来接入互联网，因此攻击者只需要在局域网中实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。\n\n**中间人攻击(Man-in-the-Middle Attack，缩写 MITM)**。\n\n[参考链接:HTTPS那些事（一）HTTPS原理](http://www.guokr.com/post/114121/)\n\n\n\n## 抓包工具 mitmproxy 使用\nmitmproxy 是一款命令行抓包工具，它除了可以抓包查看 http/https 请求，还可以拦截并修改 request 或者 response。\n\n### 安装\n首先需要安装 python 的包管理工具 pip。 OSX El Capitan 及以上的系统版本在安装时会出现 six 模块依赖错误，所以需要执行以下命令进行安装：\n\n```\nsudo pip install mitmproxy --ignore-installed six\n```\n\n### 配置\n手机和电脑在同一局域网下，设置手机的 http 代理。服务器为电脑当前的 ip，如 192.168.3.10；端口可任意设置，一般设置为8080。网络环境配置好后，在终端输入 `mitmproxy -p 8080`，进入抓包模式。\n\n如果想要抓取 https 的包，需要进一步配置。用 iPhone 打开 Safari 浏览器并输入 mitm.it，这时你会看到如下页面，选择对应平台并安装证书，安装完成后就可以抓 https 的包了。注意，用浏览器打开时需要已经在抓包模式，否则是无法看到上述页面的。\n\n抓包软件相当于在用户和服务器间增加了一个中间人。安装抓包软件的证书，这样中间人就可以获得用户端生成的密钥，就能够解密用户和服务器间的信息。**注意，一定不可随意下载信任不明的证书**\n\n![下载证书](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/httpproxy_certificate.png?raw=true)\n\n### 使用\n随便打开一个 app，就可以看到如下的一个请求列表。\n![http请求列表](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_request.png?raw=true)\n\n常用快捷键：\n- enter: 查看详细请求\n- Tab: 切换顶部导航栏\n- z: 清空列表\n- f: 过滤请求。可以参照帮助中的 Filter expression 对过滤关键字进行编辑。删除过滤就是将过滤关键字清空。\n- d: 删除请求\n- C: 复制请求。直接选中复制可能会复制进空格非常麻烦，可以通过 C 来选择复制的内容。\n\n关于如何拦截和修改 request 和 response 可以参见[抓包教程](http://ios.jobbole.com/90841/)","slug":"HTTP的构成","published":1,"updated":"2016-12-26T15:53:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41do800067hzg9t6jhewu","content":"<p>网络协议这块一直没有搞透彻，趁着苹果强制 ATS（App Transport Security）未果，学习一下这方面的知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"HTTP的构成\"><a href=\"#HTTP的构成\" class=\"headerlink\" title=\"HTTP的构成\"></a>HTTP的构成</h2><h3 id=\"HTTP-Request\"><a href=\"#HTTP-Request\" class=\"headerlink\" title=\"HTTP Request\"></a>HTTP Request</h3><p>http 请求主要分为三部分，如下图所示。<code>request line</code>，<code>header</code> 和 <code>body</code>，中间的CRLF为换行符。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http请求.png?raw=true\" alt=\"http请求组成\"></p>\n<p>下面将以一个实际的 http 请求来详细看看其内部构造。假设我们的请求URL为：<br><code>http://www.baidu.com/res/static/thirdparty/connect.jpg?t=1480992153433</code></p>\n<h4 id=\"Request-Line\"><a href=\"#Request-Line\" class=\"headerlink\" title=\"Request Line\"></a>Request Line</h4><p>请求行的结构为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Method</strong>:请求类型，例如 <code>post/get</code>。</li>\n<li><strong>SP</strong>:分隔符，一般就是空格。</li>\n<li><strong>Request-URI</strong>:对应上述请求为：<code>/res/static/thirdparty/connect.jpg?t=1480992153.564331</code>。注意，Request-URI 也可以是带 host 的完整 uri。不带的话，就要在 <code>Header</code> 里添加 host。</li>\n<li><strong>HTTP-Version</strong>:代表我们当前使用的版本，例如 <code>HTTP/1.1</code></li>\n<li><strong>CRLF</strong>:<code>CR</code> 对应回车键，<code>LF</code>对应换行键，合起来就是我们平常所说的 <code>\\r\\n</code>。</li>\n</ul>\n<p>所以上述请求的 Request-Line 的文本展示：</p>\n<blockquote>\n<p>GET /res/static/thirdparty/connect.jpg?t=1480992153.564331 HTTP/1.1CRLF</p>\n</blockquote>\n<h4 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h4><p>header 其本质上是一些文本键值对，一个典型的例子如下图所示：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_header.png?raw=true\" alt=\"header\"></p>\n<p>结构为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Key:空格ValueCRLF</div></pre></td></tr></table></figure>\n<p>上面讲述 Request-URI 的时候，缺失的 <code>Host</code> 就以键值对的形式存在于 header 中，比如， <code>Host： pan.baidu.com</code>。</p>\n<p>将若干个上述格式的键值对组合起来，就成了我们 HTTP 请求的完整 header。最后一个键值对之后再跟一个 <code>CRLF</code>，就表示我们的 header 结束了。</p>\n<h4 id=\"Body\"><a href=\"#Body\" class=\"headerlink\" title=\"Body\"></a>Body</h4><p>body 里面包含请求的实际数据。</p>\n<p>对于 <code>Method=GET</code> 的请求来说，body 体是为空的，Header 最后的两个 <code>CRLF</code> 就标识着请求的结尾。我们一般调用请求的业务参数是通过 Request Line 当中的 Request-URI 来传递的，比如上述请求中的 <code>?t=1480992153.564331</code>，也就是 URI 的 query string 部分。这部分同样是以键值对的形式存在，不过是位于 Request Line 当中。</p>\n<p>对于 <code>Method=POST</code> 的请求来说，实际的业务数据都存放于 body 当中。<strong>POST 请求可以根据 Header 中的 <code>Content-Type</code> 值，以不同的形式将数据保存在 body 体中。获取到请求后，可以仍然通过 Header 中的 <code>Content-Length</code> 值，读取固定长度的body体，直接传递给应用层</strong> </p>\n<h3 id=\"HTTP-Response\"><a href=\"#HTTP-Response\" class=\"headerlink\" title=\"HTTP Response\"></a>HTTP Response</h3><p>response 的结构和 request 大致相似，不过是将 Request Line 换成了 Status Line 。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_response.png?raw=true\" alt=\"http_response\"></p>\n<p>Status Line 的结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</div></pre></td></tr></table></figure></p>\n<h3 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h3><p>Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定<strong>请求和响应</strong>的 HTTP 内容类型。如果未指定  ContentType，默认为 <code>text/html</code>。</p>\n<p>一些常见的 Content-Type:</p>\n<ul>\n<li>text/html</li>\n<li>text/plain</li>\n<li>text/css</li>\n<li>text/javascript</li>\n<li>application/x-www-form-urlencoded</li>\n<li>multipart/form-data</li>\n<li>application/json</li>\n<li>application/xml</li>\n</ul>\n<p>前面几个都很好理解，都是 html，css，javascript 的文件类型，<strong>后面四个是POST 的发包方式</strong>。</p>\n<p>那我们什么时候用 <code>application/x-www-form-urlencoded</code>，什么时候用 <code>multipart/form-data</code> 呢？大文件如文件图片用后者，小文件如键值对用前者。</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。比如运营商可以轻易劫持你的 http 请求，在 response 中注入 js代码（如网页上弹窗广告、流量球等），甚至是重定向。为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。之后对 SSL 进行了升级为 TLS（Transport Layer Security）。我们现在的 HTTPS 都是用的 TLS 协议。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>总共分为以下几步：</p>\n<ol>\n<li>浏览器将自己支持的一套加密规则发送给网站。</li>\n<li>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>\n<li>获得网站证书之后浏览器要做以下工作：<ol>\n<li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li>\n<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>\n<li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li>\n</ol>\n</li>\n<li>网站接收浏览器发来的数据之后要做以下的操作：<ol>\n<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li>\n<li>使用密码加密一段握手消息，发送给浏览器。</li>\n</ol>\n</li>\n<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>\n</ol>\n<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p>\n<p>其中<strong>非对称加密算法用于在握手过程中加密生成的密码</strong>，<strong>对称加密算法用于对真正传输的数据进行加密</strong>，而 <strong>HASH 算法用于验证数据的完整性</strong>。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>\n<p>为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。</p>\n<h3 id=\"证书的验证过程\"><a href=\"#证书的验证过程\" class=\"headerlink\" title=\"证书的验证过程\"></a>证书的验证过程</h3><p>证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书。</p>\n<h3 id=\"SSL劫持\"><a href=\"#SSL劫持\" class=\"headerlink\" title=\"SSL劫持\"></a>SSL劫持</h3><p>SSL 劫持也就是 SSL 证书欺骗攻击，攻击者为了获得 HTTPS 传输的明文数据，需要先将自己接入到浏览器与目标网站之间（中间人），在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输中的数据，简单的图示如下：</p>\n<blockquote>\n<p>[浏览器] &lt;======&gt; [目标网站] （正常情况）<br>[浏览器] &lt;======&gt; 中间人 &lt;======&gt; [目标网站] （中间人攻击）</p>\n</blockquote>\n<p>中间人攻击最好的环境是在局域网中，局域网中所有的计算机需要通过一个固定的出口（网关）来接入互联网，因此攻击者只需要在局域网中实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。</p>\n<p><strong>中间人攻击(Man-in-the-Middle Attack，缩写 MITM)</strong>。</p>\n<p><a href=\"http://www.guokr.com/post/114121/\" target=\"_blank\" rel=\"external\">参考链接:HTTPS那些事（一）HTTPS原理</a></p>\n<h2 id=\"抓包工具-mitmproxy-使用\"><a href=\"#抓包工具-mitmproxy-使用\" class=\"headerlink\" title=\"抓包工具 mitmproxy 使用\"></a>抓包工具 mitmproxy 使用</h2><p>mitmproxy 是一款命令行抓包工具，它除了可以抓包查看 http/https 请求，还可以拦截并修改 request 或者 response。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先需要安装 python 的包管理工具 pip。 OSX El Capitan 及以上的系统版本在安装时会出现 six 模块依赖错误，所以需要执行以下命令进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install mitmproxy --ignore-installed six</div></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>手机和电脑在同一局域网下，设置手机的 http 代理。服务器为电脑当前的 ip，如 192.168.3.10；端口可任意设置，一般设置为8080。网络环境配置好后，在终端输入 <code>mitmproxy -p 8080</code>，进入抓包模式。</p>\n<p>如果想要抓取 https 的包，需要进一步配置。用 iPhone 打开 Safari 浏览器并输入 mitm.it，这时你会看到如下页面，选择对应平台并安装证书，安装完成后就可以抓 https 的包了。注意，用浏览器打开时需要已经在抓包模式，否则是无法看到上述页面的。</p>\n<p>抓包软件相当于在用户和服务器间增加了一个中间人。安装抓包软件的证书，这样中间人就可以获得用户端生成的密钥，就能够解密用户和服务器间的信息。<strong>注意，一定不可随意下载信任不明的证书</strong></p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/httpproxy_certificate.png?raw=true\" alt=\"下载证书\"></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>随便打开一个 app，就可以看到如下的一个请求列表。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_request.png?raw=true\" alt=\"http请求列表\"></p>\n<p>常用快捷键：</p>\n<ul>\n<li>enter: 查看详细请求</li>\n<li>Tab: 切换顶部导航栏</li>\n<li>z: 清空列表</li>\n<li>f: 过滤请求。可以参照帮助中的 Filter expression 对过滤关键字进行编辑。删除过滤就是将过滤关键字清空。</li>\n<li>d: 删除请求</li>\n<li>C: 复制请求。直接选中复制可能会复制进空格非常麻烦，可以通过 C 来选择复制的内容。</li>\n</ul>\n<p>关于如何拦截和修改 request 和 response 可以参见<a href=\"http://ios.jobbole.com/90841/\" target=\"_blank\" rel=\"external\">抓包教程</a></p>\n","excerpt":"<p>网络协议这块一直没有搞透彻，趁着苹果强制 ATS（App Transport Security）未果，学习一下这方面的知识。</p>","more":"<h2 id=\"HTTP的构成\"><a href=\"#HTTP的构成\" class=\"headerlink\" title=\"HTTP的构成\"></a>HTTP的构成</h2><h3 id=\"HTTP-Request\"><a href=\"#HTTP-Request\" class=\"headerlink\" title=\"HTTP Request\"></a>HTTP Request</h3><p>http 请求主要分为三部分，如下图所示。<code>request line</code>，<code>header</code> 和 <code>body</code>，中间的CRLF为换行符。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http请求.png?raw=true\" alt=\"http请求组成\"></p>\n<p>下面将以一个实际的 http 请求来详细看看其内部构造。假设我们的请求URL为：<br><code>http://www.baidu.com/res/static/thirdparty/connect.jpg?t=1480992153433</code></p>\n<h4 id=\"Request-Line\"><a href=\"#Request-Line\" class=\"headerlink\" title=\"Request Line\"></a>Request Line</h4><p>请求行的结构为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>Method</strong>:请求类型，例如 <code>post/get</code>。</li>\n<li><strong>SP</strong>:分隔符，一般就是空格。</li>\n<li><strong>Request-URI</strong>:对应上述请求为：<code>/res/static/thirdparty/connect.jpg?t=1480992153.564331</code>。注意，Request-URI 也可以是带 host 的完整 uri。不带的话，就要在 <code>Header</code> 里添加 host。</li>\n<li><strong>HTTP-Version</strong>:代表我们当前使用的版本，例如 <code>HTTP/1.1</code></li>\n<li><strong>CRLF</strong>:<code>CR</code> 对应回车键，<code>LF</code>对应换行键，合起来就是我们平常所说的 <code>\\r\\n</code>。</li>\n</ul>\n<p>所以上述请求的 Request-Line 的文本展示：</p>\n<blockquote>\n<p>GET /res/static/thirdparty/connect.jpg?t=1480992153.564331 HTTP/1.1CRLF</p>\n</blockquote>\n<h4 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h4><p>header 其本质上是一些文本键值对，一个典型的例子如下图所示：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_header.png?raw=true\" alt=\"header\"></p>\n<p>结构为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Key:空格ValueCRLF</div></pre></td></tr></table></figure>\n<p>上面讲述 Request-URI 的时候，缺失的 <code>Host</code> 就以键值对的形式存在于 header 中，比如， <code>Host： pan.baidu.com</code>。</p>\n<p>将若干个上述格式的键值对组合起来，就成了我们 HTTP 请求的完整 header。最后一个键值对之后再跟一个 <code>CRLF</code>，就表示我们的 header 结束了。</p>\n<h4 id=\"Body\"><a href=\"#Body\" class=\"headerlink\" title=\"Body\"></a>Body</h4><p>body 里面包含请求的实际数据。</p>\n<p>对于 <code>Method=GET</code> 的请求来说，body 体是为空的，Header 最后的两个 <code>CRLF</code> 就标识着请求的结尾。我们一般调用请求的业务参数是通过 Request Line 当中的 Request-URI 来传递的，比如上述请求中的 <code>?t=1480992153.564331</code>，也就是 URI 的 query string 部分。这部分同样是以键值对的形式存在，不过是位于 Request Line 当中。</p>\n<p>对于 <code>Method=POST</code> 的请求来说，实际的业务数据都存放于 body 当中。<strong>POST 请求可以根据 Header 中的 <code>Content-Type</code> 值，以不同的形式将数据保存在 body 体中。获取到请求后，可以仍然通过 Header 中的 <code>Content-Length</code> 值，读取固定长度的body体，直接传递给应用层</strong> </p>\n<h3 id=\"HTTP-Response\"><a href=\"#HTTP-Response\" class=\"headerlink\" title=\"HTTP Response\"></a>HTTP Response</h3><p>response 的结构和 request 大致相似，不过是将 Request Line 换成了 Status Line 。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_response.png?raw=true\" alt=\"http_response\"></p>\n<p>Status Line 的结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</div></pre></td></tr></table></figure></p>\n<h3 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h3><p>Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定<strong>请求和响应</strong>的 HTTP 内容类型。如果未指定  ContentType，默认为 <code>text/html</code>。</p>\n<p>一些常见的 Content-Type:</p>\n<ul>\n<li>text/html</li>\n<li>text/plain</li>\n<li>text/css</li>\n<li>text/javascript</li>\n<li>application/x-www-form-urlencoded</li>\n<li>multipart/form-data</li>\n<li>application/json</li>\n<li>application/xml</li>\n</ul>\n<p>前面几个都很好理解，都是 html，css，javascript 的文件类型，<strong>后面四个是POST 的发包方式</strong>。</p>\n<p>那我们什么时候用 <code>application/x-www-form-urlencoded</code>，什么时候用 <code>multipart/form-data</code> 呢？大文件如文件图片用后者，小文件如键值对用前者。</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。比如运营商可以轻易劫持你的 http 请求，在 response 中注入 js代码（如网页上弹窗广告、流量球等），甚至是重定向。为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。之后对 SSL 进行了升级为 TLS（Transport Layer Security）。我们现在的 HTTPS 都是用的 TLS 协议。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>总共分为以下几步：</p>\n<ol>\n<li>浏览器将自己支持的一套加密规则发送给网站。</li>\n<li>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>\n<li>获得网站证书之后浏览器要做以下工作：<ol>\n<li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li>\n<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>\n<li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li>\n</ol>\n</li>\n<li>网站接收浏览器发来的数据之后要做以下的操作：<ol>\n<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li>\n<li>使用密码加密一段握手消息，发送给浏览器。</li>\n</ol>\n</li>\n<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>\n</ol>\n<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p>\n<p>其中<strong>非对称加密算法用于在握手过程中加密生成的密码</strong>，<strong>对称加密算法用于对真正传输的数据进行加密</strong>，而 <strong>HASH 算法用于验证数据的完整性</strong>。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>\n<p>为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。</p>\n<h3 id=\"证书的验证过程\"><a href=\"#证书的验证过程\" class=\"headerlink\" title=\"证书的验证过程\"></a>证书的验证过程</h3><p>证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书。</p>\n<h3 id=\"SSL劫持\"><a href=\"#SSL劫持\" class=\"headerlink\" title=\"SSL劫持\"></a>SSL劫持</h3><p>SSL 劫持也就是 SSL 证书欺骗攻击，攻击者为了获得 HTTPS 传输的明文数据，需要先将自己接入到浏览器与目标网站之间（中间人），在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输中的数据，简单的图示如下：</p>\n<blockquote>\n<p>[浏览器] &lt;======&gt; [目标网站] （正常情况）<br>[浏览器] &lt;======&gt; 中间人 &lt;======&gt; [目标网站] （中间人攻击）</p>\n</blockquote>\n<p>中间人攻击最好的环境是在局域网中，局域网中所有的计算机需要通过一个固定的出口（网关）来接入互联网，因此攻击者只需要在局域网中实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。</p>\n<p><strong>中间人攻击(Man-in-the-Middle Attack，缩写 MITM)</strong>。</p>\n<p><a href=\"http://www.guokr.com/post/114121/\">参考链接:HTTPS那些事（一）HTTPS原理</a></p>\n<h2 id=\"抓包工具-mitmproxy-使用\"><a href=\"#抓包工具-mitmproxy-使用\" class=\"headerlink\" title=\"抓包工具 mitmproxy 使用\"></a>抓包工具 mitmproxy 使用</h2><p>mitmproxy 是一款命令行抓包工具，它除了可以抓包查看 http/https 请求，还可以拦截并修改 request 或者 response。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先需要安装 python 的包管理工具 pip。 OSX El Capitan 及以上的系统版本在安装时会出现 six 模块依赖错误，所以需要执行以下命令进行安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install mitmproxy --ignore-installed six</div></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>手机和电脑在同一局域网下，设置手机的 http 代理。服务器为电脑当前的 ip，如 192.168.3.10；端口可任意设置，一般设置为8080。网络环境配置好后，在终端输入 <code>mitmproxy -p 8080</code>，进入抓包模式。</p>\n<p>如果想要抓取 https 的包，需要进一步配置。用 iPhone 打开 Safari 浏览器并输入 mitm.it，这时你会看到如下页面，选择对应平台并安装证书，安装完成后就可以抓 https 的包了。注意，用浏览器打开时需要已经在抓包模式，否则是无法看到上述页面的。</p>\n<p>抓包软件相当于在用户和服务器间增加了一个中间人。安装抓包软件的证书，这样中间人就可以获得用户端生成的密钥，就能够解密用户和服务器间的信息。<strong>注意，一定不可随意下载信任不明的证书</strong></p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/httpproxy_certificate.png?raw=true\" alt=\"下载证书\"></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>随便打开一个 app，就可以看到如下的一个请求列表。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/http_request.png?raw=true\" alt=\"http请求列表\"></p>\n<p>常用快捷键：</p>\n<ul>\n<li>enter: 查看详细请求</li>\n<li>Tab: 切换顶部导航栏</li>\n<li>z: 清空列表</li>\n<li>f: 过滤请求。可以参照帮助中的 Filter expression 对过滤关键字进行编辑。删除过滤就是将过滤关键字清空。</li>\n<li>d: 删除请求</li>\n<li>C: 复制请求。直接选中复制可能会复制进空格非常麻烦，可以通过 C 来选择复制的内容。</li>\n</ul>\n<p>关于如何拦截和修改 request 和 response 可以参见<a href=\"http://ios.jobbole.com/90841/\">抓包教程</a></p>"},{"title":"CALayer的transform","date":"2016-09-02T06:07:12.000Z","_content":"\n在[CollectionView的使用](https://zhang759740844.github.io/2016/08/05/UICollectionView/)中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。\n\n\n<!--more-->\n\n## UIView的transform属性\ntransform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是`CGAffineTransform`类型的。\n\n### transform结构\ntransform是一个`CGAffineTransform`类型，结构如下：\n```objc\nstruct CGAffineTransform {\n  CGFloat a, b, c, d;\n  CGFloat tx, ty;\n};\n```\n\nCGAffineTransform实际上是一个矩阵\n```objc\n| a,  b,  0 |\n| c,  d,  0 |\n| tx, ty, 1 |\n```\n由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。\n\n坐标变换过程：\n```objc\n                    | a,  b,  0 |\n{x',y',1}={x,y,1} x | c,  d,  0 |\n                    | tx, ty, 1 |\n                    \n==>\n\nxn=ax+cy+tx;\nyn=bx+dy+ty;\n\n```\n\n这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。\n\n### transform方法\n在`CGAffineTransform`的生成函数中，大多是两两对应的，一个带\nmake字样，一个不带。带make字样的是直接生成一个新的`CGAffineTransform`，不带make字样的则是在一个`CGAffineTransform`的基础上生成新的。函数返回值均是`CGAffineTransform`类型。\n\n多个`CGAffineTransform`对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。\n\n\n#### scale\n实现的是放大和缩小:\n```objc\nCGAffineTransformScale(CGAffineTransform t,\n  CGFloat sx, CGFloat sy)；\nCGAffineTransformMakeScale(CGFloat sx, CGFloat sy)；\n```\n生成新的transform相当于将`t' = [sx ，0 ，0，sy ，0， 0]`这六个参数代入矩阵中,即改变a和d。\n\n#### rotate\n实现的是旋转：\n```objc\nCGAffineTransformRotate(CGAffineTransform t,\n  CGFloat angle)\nCGAffineTransformMakeRotation(CGFloat angle)；\n```\nangle为角度，angle=π则旋转180度。矩阵的六个参数为`t' =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；`\n\n#### translate\n实现的是平移：\n```objc\nCGAffineTransformTranslate(CGAffineTransform t,\n  CGFloat tx, CGFloat ty)；\nCGAffineTransformMakeTranslation(CGFloat tx,\n  CGFloat ty)；\n```\n矩阵的六个参数为`t' = [1，0，0，1，tx，ty] ；`代入公式，`xn=x+tx,yn=y+ty`\n\n#### 复原\n```objc\nview.transform＝CGAffineTransformIdentity;\n```\n上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。`CGAffineTransformIdentity`将view从当前状态复原回view最初始的状态。\n\n## CALayer的transform属性\n### transform结构\nCALayer的transform是一个`CATransform3D`结构：\n```objc\nstruct CATransform3D\n{\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n};\n```\n有别于`CGAffineTransform`,`CATransform3D`是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。\n\n### transform方法\nCALayer的transform方法和View的transform基本一致。举几点不同：\n\n- CALayer由于有z轴，因此对不同图层使用`CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)`方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。\n\n- 由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变`m34`(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。`m34`的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。\n\n- 如果想要直接改变矩阵里的值，可以先使用`CATransform3DIdentity`的方式，初始化一个`CATransform3D`实例，然后再赋值。\n\n\n\n","source":"_posts/CALayer的transform属性.md","raw":"title: CALayer的transform\ndate: 2016/9/2 14:07:12  \ncategories: iOS\ntags: \n\t- Animation\n\t- UI\n\n---\n\n在[CollectionView的使用](https://zhang759740844.github.io/2016/08/05/UICollectionView/)中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。\n\n\n<!--more-->\n\n## UIView的transform属性\ntransform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是`CGAffineTransform`类型的。\n\n### transform结构\ntransform是一个`CGAffineTransform`类型，结构如下：\n```objc\nstruct CGAffineTransform {\n  CGFloat a, b, c, d;\n  CGFloat tx, ty;\n};\n```\n\nCGAffineTransform实际上是一个矩阵\n```objc\n| a,  b,  0 |\n| c,  d,  0 |\n| tx, ty, 1 |\n```\n由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。\n\n坐标变换过程：\n```objc\n                    | a,  b,  0 |\n{x',y',1}={x,y,1} x | c,  d,  0 |\n                    | tx, ty, 1 |\n                    \n==>\n\nxn=ax+cy+tx;\nyn=bx+dy+ty;\n\n```\n\n这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。\n\n### transform方法\n在`CGAffineTransform`的生成函数中，大多是两两对应的，一个带\nmake字样，一个不带。带make字样的是直接生成一个新的`CGAffineTransform`，不带make字样的则是在一个`CGAffineTransform`的基础上生成新的。函数返回值均是`CGAffineTransform`类型。\n\n多个`CGAffineTransform`对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。\n\n\n#### scale\n实现的是放大和缩小:\n```objc\nCGAffineTransformScale(CGAffineTransform t,\n  CGFloat sx, CGFloat sy)；\nCGAffineTransformMakeScale(CGFloat sx, CGFloat sy)；\n```\n生成新的transform相当于将`t' = [sx ，0 ，0，sy ，0， 0]`这六个参数代入矩阵中,即改变a和d。\n\n#### rotate\n实现的是旋转：\n```objc\nCGAffineTransformRotate(CGAffineTransform t,\n  CGFloat angle)\nCGAffineTransformMakeRotation(CGFloat angle)；\n```\nangle为角度，angle=π则旋转180度。矩阵的六个参数为`t' =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；`\n\n#### translate\n实现的是平移：\n```objc\nCGAffineTransformTranslate(CGAffineTransform t,\n  CGFloat tx, CGFloat ty)；\nCGAffineTransformMakeTranslation(CGFloat tx,\n  CGFloat ty)；\n```\n矩阵的六个参数为`t' = [1，0，0，1，tx，ty] ；`代入公式，`xn=x+tx,yn=y+ty`\n\n#### 复原\n```objc\nview.transform＝CGAffineTransformIdentity;\n```\n上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。`CGAffineTransformIdentity`将view从当前状态复原回view最初始的状态。\n\n## CALayer的transform属性\n### transform结构\nCALayer的transform是一个`CATransform3D`结构：\n```objc\nstruct CATransform3D\n{\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n};\n```\n有别于`CGAffineTransform`,`CATransform3D`是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。\n\n### transform方法\nCALayer的transform方法和View的transform基本一致。举几点不同：\n\n- CALayer由于有z轴，因此对不同图层使用`CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)`方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。\n\n- 由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变`m34`(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。`m34`的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。\n\n- 如果想要直接改变矩阵里的值，可以先使用`CATransform3DIdentity`的方式，初始化一个`CATransform3D`实例，然后再赋值。\n\n\n\n","slug":"CALayer的transform属性","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41doe00087hzgeme71w6j","content":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/05/UICollectionView/\">CollectionView的使用</a>中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。</p>\n<a id=\"more\"></a>\n<h2 id=\"UIView的transform属性\"><a href=\"#UIView的transform属性\" class=\"headerlink\" title=\"UIView的transform属性\"></a>UIView的transform属性</h2><p>transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是<code>CGAffineTransform</code>类型的。</p>\n<h3 id=\"transform结构\"><a href=\"#transform结构\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>transform是一个<code>CGAffineTransform</code>类型，结构如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CGAffineTransform</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> a, b, c, d;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, ty;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>CGAffineTransform实际上是一个矩阵<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">| a,  b,  <span class=\"number\">0</span> |</div><div class=\"line\">| c,  d,  <span class=\"number\">0</span> |</div><div class=\"line\">| tx, ty, <span class=\"number\">1</span> |</div></pre></td></tr></table></figure></p>\n<p>由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。</p>\n<p>坐标变换过程：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">                    | a,  b,  0 |</div><div class=\"line\">&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c,  d,  0 |</div><div class=\"line\">                    | tx, ty, 1 |</div><div class=\"line\">                    </div><div class=\"line\">==&gt;</div><div class=\"line\"></div><div class=\"line\">xn=ax+cy+tx;</div><div class=\"line\">yn=bx+dy+ty;</div></pre></td></tr></table></figure></p>\n<p>这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。</p>\n<h3 id=\"transform方法\"><a href=\"#transform方法\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>在<code>CGAffineTransform</code>的生成函数中，大多是两两对应的，一个带<br>make字样，一个不带。带make字样的是直接生成一个新的<code>CGAffineTransform</code>，不带make字样的则是在一个<code>CGAffineTransform</code>的基础上生成新的。函数返回值均是<code>CGAffineTransform</code>类型。</p>\n<p>多个<code>CGAffineTransform</code>对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。</p>\n<h4 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h4><p>实现的是放大和缩小:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div></pre></td></tr></table></figure></p>\n<p>生成新的transform相当于将<code>t&#39; = [sx ，0 ，0，sy ，0， 0]</code>这六个参数代入矩阵中,即改变a和d。</p>\n<h4 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h4><p>实现的是旋转：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> angle)</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"built_in\">CGFloat</span> angle)；</div></pre></td></tr></table></figure></p>\n<p>angle为角度，angle=π则旋转180度。矩阵的六个参数为<code>t&#39; =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；</code></p>\n<h4 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a>translate</h4><p>实现的是平移：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, <span class=\"built_in\">CGFloat</span> ty)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"built_in\">CGFloat</span> tx,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> ty)；</div></pre></td></tr></table></figure></p>\n<p>矩阵的六个参数为<code>t&#39; = [1，0，0，1，tx，ty] ；</code>代入公式，<code>xn=x+tx,yn=y+ty</code></p>\n<h4 id=\"复原\"><a href=\"#复原\" class=\"headerlink\" title=\"复原\"></a>复原</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.transform＝<span class=\"built_in\">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure>\n<p>上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。<code>CGAffineTransformIdentity</code>将view从当前状态复原回view最初始的状态。</p>\n<h2 id=\"CALayer的transform属性\"><a href=\"#CALayer的transform属性\" class=\"headerlink\" title=\"CALayer的transform属性\"></a>CALayer的transform属性</h2><h3 id=\"transform结构-1\"><a href=\"#transform结构-1\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>CALayer的transform是一个<code>CATransform3D</code>结构：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m11, m12, m13, m14;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m21, m22, m23, m24;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m31, m32, m33, m34;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m41, m42, m43, m44;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>有别于<code>CGAffineTransform</code>,<code>CATransform3D</code>是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。</p>\n<h3 id=\"transform方法-1\"><a href=\"#transform方法-1\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>CALayer的transform方法和View的transform基本一致。举几点不同：</p>\n<ul>\n<li><p>CALayer由于有z轴，因此对不同图层使用<code>CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</code>方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。</p>\n</li>\n<li><p>由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变<code>m34</code>(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。<code>m34</code>的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。</p>\n</li>\n<li><p>如果想要直接改变矩阵里的值，可以先使用<code>CATransform3DIdentity</code>的方式，初始化一个<code>CATransform3D</code>实例，然后再赋值。</p>\n</li>\n</ul>\n","excerpt":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/05/UICollectionView/\">CollectionView的使用</a>中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。</p>","more":"<h2 id=\"UIView的transform属性\"><a href=\"#UIView的transform属性\" class=\"headerlink\" title=\"UIView的transform属性\"></a>UIView的transform属性</h2><p>transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是<code>CGAffineTransform</code>类型的。</p>\n<h3 id=\"transform结构\"><a href=\"#transform结构\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>transform是一个<code>CGAffineTransform</code>类型，结构如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CGAffineTransform</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> a, b, c, d;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, ty;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>CGAffineTransform实际上是一个矩阵<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">| a,  b,  <span class=\"number\">0</span> |</div><div class=\"line\">| c,  d,  <span class=\"number\">0</span> |</div><div class=\"line\">| tx, ty, <span class=\"number\">1</span> |</div></pre></td></tr></table></figure></p>\n<p>由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。</p>\n<p>坐标变换过程：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">                    | a,  b,  0 |</div><div class=\"line\">&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c,  d,  0 |</div><div class=\"line\">                    | tx, ty, 1 |</div><div class=\"line\">                    </div><div class=\"line\">==&gt;</div><div class=\"line\"></div><div class=\"line\">xn=ax+cy+tx;</div><div class=\"line\">yn=bx+dy+ty;</div></pre></td></tr></table></figure></p>\n<p>这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。</p>\n<h3 id=\"transform方法\"><a href=\"#transform方法\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>在<code>CGAffineTransform</code>的生成函数中，大多是两两对应的，一个带<br>make字样，一个不带。带make字样的是直接生成一个新的<code>CGAffineTransform</code>，不带make字样的则是在一个<code>CGAffineTransform</code>的基础上生成新的。函数返回值均是<code>CGAffineTransform</code>类型。</p>\n<p>多个<code>CGAffineTransform</code>对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。</p>\n<h4 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h4><p>实现的是放大和缩小:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div></pre></td></tr></table></figure></p>\n<p>生成新的transform相当于将<code>t&#39; = [sx ，0 ，0，sy ，0， 0]</code>这六个参数代入矩阵中,即改变a和d。</p>\n<h4 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h4><p>实现的是旋转：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> angle)</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"built_in\">CGFloat</span> angle)；</div></pre></td></tr></table></figure></p>\n<p>angle为角度，angle=π则旋转180度。矩阵的六个参数为<code>t&#39; =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；</code></p>\n<h4 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a>translate</h4><p>实现的是平移：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, <span class=\"built_in\">CGFloat</span> ty)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"built_in\">CGFloat</span> tx,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> ty)；</div></pre></td></tr></table></figure></p>\n<p>矩阵的六个参数为<code>t&#39; = [1，0，0，1，tx，ty] ；</code>代入公式，<code>xn=x+tx,yn=y+ty</code></p>\n<h4 id=\"复原\"><a href=\"#复原\" class=\"headerlink\" title=\"复原\"></a>复原</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.transform＝<span class=\"built_in\">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure>\n<p>上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。<code>CGAffineTransformIdentity</code>将view从当前状态复原回view最初始的状态。</p>\n<h2 id=\"CALayer的transform属性\"><a href=\"#CALayer的transform属性\" class=\"headerlink\" title=\"CALayer的transform属性\"></a>CALayer的transform属性</h2><h3 id=\"transform结构-1\"><a href=\"#transform结构-1\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>CALayer的transform是一个<code>CATransform3D</code>结构：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m11, m12, m13, m14;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m21, m22, m23, m24;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m31, m32, m33, m34;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m41, m42, m43, m44;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>有别于<code>CGAffineTransform</code>,<code>CATransform3D</code>是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。</p>\n<h3 id=\"transform方法-1\"><a href=\"#transform方法-1\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>CALayer的transform方法和View的transform基本一致。举几点不同：</p>\n<ul>\n<li><p>CALayer由于有z轴，因此对不同图层使用<code>CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</code>方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。</p>\n</li>\n<li><p>由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变<code>m34</code>(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。<code>m34</code>的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。</p>\n</li>\n<li><p>如果想要直接改变矩阵里的值，可以先使用<code>CATransform3DIdentity</code>的方式，初始化一个<code>CATransform3D</code>实例，然后再赋值。</p>\n</li>\n</ul>"},{"title":"IPhone6全屏黑边处理","date":"2016-09-05T06:07:12.000Z","_content":"\n写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。\n\n<!--more-->\n\n检查了许久，代码里都是直接设置的`UIScreen`的`bounds`。因此，不可能是代码的问题。那么需要在设置中找原因。\n\n通过和正确的demo进行对比，发现了差异所在。\n\n这是有黑边情况下的设置：\n\n![错误设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true)\n\n这是没有黑边情况下的设置：\n![正确设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true)\n\n通过比较可以发现：\n出现黑边的原因是在设置里设置了`Launch Images Source`为`LaunchImage`,但是在Images.xcassets中并没有`LaunchImage`资源。所以，需要给`LaunchImage`设置图片资源。\n也可以像上面的那样设置`Launch Images Source`为`Use Asset Catalog`,并且将`Launch Screen File`设置为`LaunchImage`即可解决。","source":"_posts/IPhone6全屏黑边处理.md","raw":"title: IPhone6全屏黑边处理\ndate: 2016/9/5 14:07:12  \ncategories: iOS\ntags: \n\t- Xcode\n\t\n---\n\n写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。\n\n<!--more-->\n\n检查了许久，代码里都是直接设置的`UIScreen`的`bounds`。因此，不可能是代码的问题。那么需要在设置中找原因。\n\n通过和正确的demo进行对比，发现了差异所在。\n\n这是有黑边情况下的设置：\n\n![错误设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true)\n\n这是没有黑边情况下的设置：\n![正确设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true)\n\n通过比较可以发现：\n出现黑边的原因是在设置里设置了`Launch Images Source`为`LaunchImage`,但是在Images.xcassets中并没有`LaunchImage`资源。所以，需要给`LaunchImage`设置图片资源。\n也可以像上面的那样设置`Launch Images Source`为`Use Asset Catalog`,并且将`Launch Screen File`设置为`LaunchImage`即可解决。","slug":"IPhone6全屏黑边处理","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41doh000b7hzgh6zdb7qt","content":"<p>写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。</p>\n<a id=\"more\"></a>\n<p>检查了许久，代码里都是直接设置的<code>UIScreen</code>的<code>bounds</code>。因此，不可能是代码的问题。那么需要在设置中找原因。</p>\n<p>通过和正确的demo进行对比，发现了差异所在。</p>\n<p>这是有黑边情况下的设置：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true\" alt=\"错误设置\"></p>\n<p>这是没有黑边情况下的设置：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true\" alt=\"正确设置\"></p>\n<p>通过比较可以发现：<br>出现黑边的原因是在设置里设置了<code>Launch Images Source</code>为<code>LaunchImage</code>,但是在Images.xcassets中并没有<code>LaunchImage</code>资源。所以，需要给<code>LaunchImage</code>设置图片资源。<br>也可以像上面的那样设置<code>Launch Images Source</code>为<code>Use Asset Catalog</code>,并且将<code>Launch Screen File</code>设置为<code>LaunchImage</code>即可解决。</p>\n","excerpt":"<p>写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。</p>","more":"<p>检查了许久，代码里都是直接设置的<code>UIScreen</code>的<code>bounds</code>。因此，不可能是代码的问题。那么需要在设置中找原因。</p>\n<p>通过和正确的demo进行对比，发现了差异所在。</p>\n<p>这是有黑边情况下的设置：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true\" alt=\"错误设置\"></p>\n<p>这是没有黑边情况下的设置：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true\" alt=\"正确设置\"></p>\n<p>通过比较可以发现：<br>出现黑边的原因是在设置里设置了<code>Launch Images Source</code>为<code>LaunchImage</code>,但是在Images.xcassets中并没有<code>LaunchImage</code>资源。所以，需要给<code>LaunchImage</code>设置图片资源。<br>也可以像上面的那样设置<code>Launch Images Source</code>为<code>Use Asset Catalog</code>,并且将<code>Launch Screen File</code>设置为<code>LaunchImage</code>即可解决。</p>"},{"title":"Effective Objective-C 学习笔记","date":"2016-11-11T02:07:12.000Z","_content":"\n拜读一下 Effective Objective-C 这本书，做一些笔记\n\n<!--more-->\n\n## 熟悉OC\n### 第1条：了解Objective-C的起源\n\n对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由**运行期组件（runtime component）**完成，使用 Objective-C 的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。\n\n运行期组件本质上是一种与开发者所编写的代码相链接的**动态库（dynamic library）**，其代码能把开发者所编写的所有程序粘合起来。\n\n### 第2条： 在类的头文件中尽量少引用其他头文件\n\n有时，类A需要将类B的实例变量作为它公共 API 的属性。这个时候，我们不应该引入类B的头文件，而应该使用**向前声明（forward declaring）** 使用 `@class` 关键字，并且**在 A 的实现文件引用 B 的头文件**。(继承或者协议必须引入完整头文件，不能使用向前声明)\n\n```objc\n// EOCPerson.h\n#import <Foundation/Foundation.h>\n\n@class EOCEmployer;\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy) NSString *firstName;\n@property (nonatomic, copy) NSString *lastName;\n@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性\n\n@end\n\n// EOCPerson.m\n#import \"EOCEmployer.h\"\n```\n\n这样做有什么优点呢：\n1. 不在A的头文件中引入B的头文件，那么A的实现文件引入A的头文件时，就不会一并引入B的全部内容，这样就减少了编译时间。只有在A的实现里需要用到B时，再在A的实现里引用B的头文件。\n2. 使用 `#import` 而不是 `#include` 可以避免死循环，但仍会导致相互引用的两个类中的一哥无法正确编译。使用 `@class` 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。\n\n### 第3条：多用字面量语法，少用与之等价的方法\n声明时多用字面量：\n\n```objc\nNSNumber *intNumber = @1;\nNSNumber *floatNumber = @2.5f;\nNSArray *animals =@[@\"cat\", @\"dog\",@\"mouse\", @\"badger\"];\nDictionary *dict = @{@\"animal\":@\"tiger\",@\"phone\":@\"iPhone 6\"};\n\nNSString *cat = animals[0];\nNSString *iphone = dict[@\"phone\"];\n```\n\n少用 `alloc`、`init` 的方式创建，以及 `objectAtIndex`、`objectForKey` 的方式取数组字典。\n\n优点：\n1. 简洁\n2. `NSArray` 以 `nil` 结尾，所以一般不允许数组中的元素为 `nil`，如果使用等价方法，那么数组元素为 `nil` 不报错，会出现难以排查的错误；而同样的情况，字面量语法会抛出异常。\n\n### 第4条：多用类型常量，少用#define预处理命令\n预处理与类型常量的优缺点：\n- 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。\n- 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。\n\n#### 预处理命令\n\n```objc\n#define W_LABEL (W_SCREEN - 2*GAP)\n```\n\n这里，`(W_SCREEN - 2*GAP)` 替换了 `W_LABEL`，它不具备 `W_LABEL` 的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。\n\n#### 类型常量\n\n```objc\nstatic const NSTimeIntervalDuration = 0.3;\n```\n\n`const` 将其设置为常量，不可更改。`static` 意味着该变量仅仅在定义此变量的编译单元(`.m` 实现文件)中可见。如果不声明 `static`,编译器会为它创建一个**外部符号（external symbol）**。会出现什么问题呢？如果在其他类中也声明了同名变量，即使没有相互引用，编译器也会抛出一个异常。\n\n#### 全局常量\n如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量，即全局常量。在头文件中声明外部常量，在实现文件中完成变量的赋值。\n\n```objc\n//header file\nextern NSString *const NotificationString;\n\n//implementation file\nNSString *const  NotificationString = @\"Finish Download\";\n```\n\n注意这里的 `const`, 如果在 `*` 前面，表示指针指向的堆上的内容不能改变，如果在 `*` 后面，表示指针指向的地址是不能改变的。（这里有个助记方法，以 `*` 为分解，`const` 在左边就是修饰 `NSString`，表示不能修改值，在右边就表示修饰指针对象，表示不能修改指针指向的地址。）\n\n### 第5条：用枚举表示状态，选项，状态码\n我们经常需要给类定义几个状态，这些状态码可以用枚举来管理：\n\n```objc\ntypedef NS_ENUM(NSUInteger, EOCConnectionState) {\n  EOCConnectionStateDisconnected,\n  EOCConnectionStateConnecting,\n  EOCConnectionStateConnected,\n};\n\ntypedef NS_OPTION(NSUInteger, EOCPermittedDirection) {\n\tEOCPermittedDirectionUp    = 1 << 0,\n\tEOCPermittedDirectionDown  = 1 << 1,\n\tEOCPermittedDirectionLeft  = 1 << 2,\n\tEOCPermittedDirectionRight = 1 << 3\n}\n```\n\n`NS_ENUM` 和 `NS_OPTION` 是 Foundation 框架中定义的辅助宏。需要注意这两者使用场景的不同。\n\n在枚举类型的 switch 语句中不要实现 default 分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch 语句并未处理所有的枚举。否则添加了枚举却没有实现 switch 将可能导致严重的崩溃。\n\n## 对象、消息、运行期\n### 第6条：理解“属性”这一概念\n#### 属性\n在 Java 以及 C++ 中，对象布局在编译期就已经固定了。只要访问变量的代码，编译器就会把其替换成为“偏移量”。这个偏移量是**硬编码（hardcode）**，表示该对象距离存放对象的内存区域的起始地址有多远。这样做的问题是，如果再添加一个实例变量，那么其他实例变量的就要变化了，那么就要重新编译，否则就会出错。\n\nObjective-C 的做法是，把实例变量当做一种存储偏移量所用的**“特殊变量”（special variable）**，交由**“类对象”（class object）**保管。偏移量会在运行期查找，那么类的定义变了，存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。\n\n#### 存取方法\n在设置完属性后，编译器会自动向类中添加适当类型的实例变量，并且为其写出一套存取方法。访问属性，可以使用点语法，编译器会把点语法转换为对存取方法的调用；也可直接使用实例变量，使用实例变量的方式更快。\n\n```objc\n//存取方法设置属性\nself.firstName = @\"Zachary\";\n//实例变量设置属性\n_firstName = @\"Zachary\";\n```\n\n\n#### 属相特质\n原子性：\n- nonatomic：不使用同步锁\n- atomic：加同步锁，确保其原子性\n\n读写:\n- readwrite:同时存在存取方法\n- readonly:只有获取方法\n\n内存管理:\n- assign:纯量类型(scalar type)的简单赋值操作\n- strong:拥有关系保留新值，释放旧值，再设置新值\n- weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空\n- copy：当赋给其可变对象，返回不可变对象；当赋给其不可变对象，返回原对象。\n\n### 第7条： 在对象内部尽量直接访问实例变量\n关于实例变量的访问，可以直接访问 `_firstName`，也可以通过属性的方式(点语法) `self.firstName` 来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。（这部分比较重要）\n\n直接访问实例变量的特点：\n- 不经过**“方法派发”(method dispatch)**，会直接访问保存对象实例变量的那块内存，速度快。\n\n通过属性访问实例变量的特点：\n- 不会绕过属性定义的**内存管理语义**。其实也就是说，编译期在设置 set 方法的时候，会根据属性特质做一些操作。比如一个声明为 `copy` 的属性，如果直接访问实例变量，那么这个实例变量就会直接指向堆中的对象；而如果通过属性来操作，就会先将堆中的对象 copy 一份，然后将实例变量指向 copy 出来的对象。\n- 可以触发KVO\n\n不过有两个特例：\n1. `init` 方法和 `dealloc` 方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作(比如上面说的**内存管理语义**所要进行的操作)。\n2. 如果使用**懒加载**的获取方法要用属性的方式获取。\n\n其实，到底用什么很简单，如果 get，set 方法里没有其他的乱七八糟的东西，比如:\n\n```objc\n- (NSString *)firstName{\n\treturn _firstName;\n}\n\n- (void) setFirstName:(NSString *)firstName{\n\t_firstName = firstName;\n}\n```\n\n上面这种，那就直接用实例变量操作了，用属性就是多此一举；如果有乱七八糟的东西，那么就要用属性的方式。\n\n### 第8条：理解“对象等同性”这一概念\n`NSObject` 类中有两个用于判断等同性的方法：\n- `- (BOOL)isEqual:(id)object;`\n- `- (NSUInteger)hash;`\n\n`NSObject` 类中默认的实现是：当且仅当其内存地址完全相等时，两个对象才相等。自定义对象中可以覆写这两个方法（其实好像没必要重写 hash 方法，因为我们重写的 `isEqual:` 方法里根本没有用到 hash 方法，重写了也没啥用），完成自己的相等判断。如果 `isEqual:` 方法判断对象相等，那么其 hash 方法也必须返回同一个值；反之，如果 hash 方法返回了同一个值，`isEqual:` 方法未必认为两者相等。\n\n如果已知两个对象是字符串，最好通过 `isEqualToString:` 方法来比较。对于数组和字典，也有 `isEqualToArray:` 方法和 `isEqualToDictionary:`方法。\n\n如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的 `isEqual:` 方法：\n```objc\n- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson {\n\n     //先比较对象类型，然后比较每个属性\n     if (self == object) return YES;\n     if (![_firstName isEqualToString:otherPerson.firstName])\n         return NO;\n     if (![_lastName isEqualToString:otherPerson.lastName])\n         return NO;\n     if (_age != otherPerson.age)\n         return NO;\n     return YES;\n}\n\n\n- (BOOL)isEqual:(id)object {\n    //如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法\n     if ([self class] == [object class]) {    \n         return [self isEqualToPerson:(EOCPerson*)object];\n    } else {    \n         return [super isEqual:object];\n    }\n}\n```\n\n### 第9条 以“类族模式“隐藏实现细节\n其实就是通过抽象类完成工厂模式。\n\n例如,对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：\n\n```objc\n//EOCEmployee.h\n\ntypedef NS_ENUM(NSUInteger, EOCEmployeeType) {\n    EOCEmployeeTypeDeveloper,\n    EOCEmployeeTypeDesigner,\n    EOCEmployeeTypeFinance,\n};\n\n@interface EOCEmployee : NSObject\n\n@property (copy) NSString *name;\n@property NSUInteger salary;\n\n\n// Helper for creating Employee objects\n+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;\n\n// Make Employees do their respective day's work\n- (void)doADaysWork;\n\n@end\n```\n\n```objc\n//EOCEmployee.m\n\n@implementation EOCEmployee\n\n+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type {\n     switch (type) {\n         case EOCEmployeeTypeDeveloper:\n            return [EOCEmployeeDeveloper new];\n         break; \n\n        case EOCEmployeeTypeDesigner:\n             return [EOCEmployeeDesigner new];\n         break;\n\n        case EOCEmployeeTypeFinance:\n             return [EOCEmployeeFinance new];\n         break;\n    }\n}\n\n- (void)doADaysWork {\n // 需要子类来实现\n}\n\n@end\n```\n\n```objc\n@interface EOCEmployeeDeveloper : EOCEmployee\n@end\n\n@implementation EOCEmployeeDeveloper\n\n- (void)doADaysWork {\n    [self writeCode];\n}\n\n@end\n```\n\n这样，表面上对象是 `EOCEmployee`，但是实际上操作的是 `EOCEmployeeDeveloper`。\n\n这里需要注意一点：对于这种类族，不能通过以下方式判断：\n\n```objc\nif ([employeeDeveloper class] == [EOCEmployee class]){\n\t// will do\n}\n```\n\n因为 `employeeDeveloper` 对象是 `EOCEmployee` 类的一个子集，需要使用 `isKindOfClass:` 方法：\n\n```objc\nif ([employeeDeveloper isKindOfClass:[EOCEmployee class]]){\n\t// will do\n}\n```\n\n### 第10条：在既有类中使用关联对象存放自定义数据\n\n这一条和 runtime 息息相关。背景是，我们可以通过 category 为系统类添加方法，但是无法添加属性。当需要为系统类添加属性时，可以使用下面的方法：\n\n```objc\n//为某个对象设置关联对象的值，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义\nvoid objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)\n\n//根据给定的键从某对象中获取相应的关联对象值\nid objc_getAssociatedObject(id object, void *key)\n\n//移除指定对象的关联对象\nvoid objc_removeAssociatedObjects(id object)\n```\n\n这里要强调的是，要拿到设置的属性，键必须要完全相等。因此，需要设置成静态全局变量：\n\n```objc\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n```\n\n\n### 第11条：理解objc_msgSend的作用\n这部分在[runtime](https://zhang759740844.github.io/2016/08/22/runtime原理/)中已经写得很详细了，参见就行了。\n\n### 第12条：理解消息转发机制\n这部分在[runtime](https://zhang759740844.github.io/2016/08/23/runtime应用/)中已经写得很详细了，参见就行了。\n\n### 第13条：用“方法调配技术”调试“黑盒方法”\n这部分在[runtime](https://zhang759740844.github.io/2016/08/23/runtime应用/)中也介绍了。\n\n### 第14条：理解“类对象”的用意\n这部分在[runtime](https://zhang759740844.github.io/2016/08/22/runtime原理/)中也介绍了。\n\n## 接口与API设计\n### 第15条：用前缀 避免命名空间冲突\nApple 宣称其保留使用所有\"两字母前缀\"的权利，所以我们选用的前缀应该是三个字母的。而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。\n\n### 第16条：提供\"全能初始化方法\"\n所谓全能初始化方法，就是所有初始化方法都要调用的初始化方法。这个初始化方法初始化方法是初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。\n\n算是一种写代码的技巧吧。平时写代码的时候也都是这样的，不具体说明了。\n\n### 第17条：实现description方法\n自定义的类调用 `NSLog();` 的时候，往往不能返回想要的结果。需要重写 `NSObject` 类中的 `description` 方法，返回需要的字符串。\n```objc\n- (NSString*)description {\n     return [NSString stringWithFormat:@\"<%@: %p, %@ %@>\", [self class], self, firstName, lastName];\n}\n```\n\n其中，`%p` 表示对象的内存地址。\n\n### 第18条：尽量使用不可变对象\n尽量使用不可变对象。没啥可说的。\n里面推荐的方法没用过，感觉并不好，就不写了。\n\n### 第19条：使用清晰而协调的命名方式\n没啥好说的，注意就好\n\n### 第20条：为私有方法名加前缀\n建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCObject : NSObject\n\n- (void)publicMethod;\n\n@end\n\n\n@implementation EOCObject\n\n- (void)publicMethod {\n /* ... */\n}\n\n- (void)p_privateMethod {\n /* ... */\n}\n\n@end\n```\n\n很有用的建议，注意不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。\n\n### 第21条：理解Objective-C错误类型\nOC 中仅在及其严重的错误情况下抛出异常。比如一个抽象基类。由于 OC 中没办法将某个类标识为抽象类。如果想要实现抽象类的功能，那么就要在必须要覆写的方法里抛出异常：\n\n```objc\n- (void)mustOverrideMethod{\n\tNSString *reason = [NSString stringWithFormat:@\"%@ must be overridden\", NSStringFromeSelector(_cmd)];\n\t@throw [NSException exceptionWithName:NSInternalInconsistencyException\n\t\t\t\t\t\t\t\t\t    reason:reason\n\t\t\t\t\t\t\t\t\t  userInfo:nil];\n}\n```\n\n对于不严重的异常，可以使用返回 `nil` 或者 `NSError` 的方式(其实也没啥用，这些都是手动设置的，我都知道哪里会出现问题了，还要新建 `NSError` 对象干嘛(可能我的理解有偏差))。\n\n### 第22条：理解NSCopying协议\n#### 自定义拷贝\n如果我们想令自己的类支持拷贝操作，那就要实现 `NSCopying` 协议，该协议只有一个方法：\n\n```objc\n- (id)copyWithZone:(NSZone*)zone\n```\n\n比如要拷贝一个 `EOCPerson` 对象：\n\n```objc\n- (id)copyWithZone:(NSZone*)zone {\n     EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];\n    copy->_friends = [_friends mutableCopy];\n     return copy;\n}\n``` \n\n这里面的 `NSZone *zone` 对象不用在意是什么，现在已经没用了。其实也就是新建一个 `EOCPerson` 对象，然后调用它的构造函数把东西全都塞进去。这里的 `->` 用箭头是因为定义的时候这个 `_friends` 不是一个属性(代码没有贴出来，详见书)，而只是在实现文件中定义的一个实例变量，没有 get/set 方法，所以不能用 `.` \n\n这里的 `mutableCopy` 方法也可以自定义，就是下面方法的实现 \n```objc\n- (id)mutableCopyWithZone:(NSZone*)zone；\n```\n\n#### 浅拷贝与深拷贝\n浅拷贝和深拷贝应该并不陌生。浅拷贝只增加引用计数，深拷贝将创建另一个一模一样的对象。\n\n- 不可变对象的 `copy` 是浅拷贝。\n- 可变对象的 `copy` 是深拷贝，返回不可变对象。\n- 不可变对象的 `mutableCopy` 是深拷贝，返回可变对象。\n- 可变对象的 `mutableCopy` 是浅拷贝。\n\n容器对象(`NSArray`)本身也遵循上面的规则。但是需要注意的是，**容器对象内的元素是浅拷贝**。因此上面的自定义 copy 方法如果想让 `_friends` 内的元素深拷贝，就不能用 `[_friends mutableCopy]` 方法，需要新建一个 Set:\n\n```objc\n- (id)deepCopy {\n   EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];\n\tcopy->_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];\n   return copy;\n}\n```\n\n## 协议与分类\n### 第23条：通过委托与数据源协议进行对象间通信\n其实也是老生常谈的东西了，不过也有一些注意点。\n\n受代理对象内持有代理对象的实例时要写成这样：\n\n```objc\n@property (nonatomic, weak) id <NetworkDelegate> delegate;\n```\n\n这里书中指明了要用 `weak`，不能用 `strong`，否则会引起引用循环。比如系统中的 `TableViewCellDelegate`，在 `TableViewController` 作为代理类确实拥有被代理对象 `TableViewCell`，用 `weak` 确实是合理的，但是所有情况都这样吗？不知道，不过确实基本上的代理对象都是 `ViewController`，所以用 `weak` 肯定是不会有问题的。\n\n实现委托对象的方法是声明某个类遵从委托协议：\n\n```objc\n@implementation EOCDataModel () <EOCNetworkFetcherDelegate>\n@end\n@implementation EOCDataModel\n// 各个实现方法\n@end\n```\n\n基本所有的 Delegate 都在 `.m` 文件中的类拓展中声明，之前一直没有留意，看了书后才问自己，为什么不在 `.h` 中声明？两者有什么差别吗？其实也没什么差别，在实现文件中声明的好处是能隐藏细节。如果只是自己用可能没什么区别，但是如果打包给别人用，那么就不应该让别人看到你的实现细节了，因此，就把这个 Delegate 的声明放到了实现文件中。\n好吧。一个简单的道理。只是我一开始没想明白。\n\n### 第24条：将类的实现代码分散到便于管理的数个分类中\n当一个类越来越大时，就变得不利于管理，因此需要将类代码按照逻辑划分入几个分区中，可以通过范畴的方式实现。书中有一个例子：\n\n无分类:\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy, readonly) NSString *firstName;\n@property (nonatomic, copy, readonly) NSString *lastName;\n@property (nonatomic, strong, readonly) NSArray *friends;\n\n- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;\n\n/* Friendship methods */\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n\n/* Work methods */\n- (void)performDaysWork;\n- (void)takeVacationFromWork;\n\n\n/* Play methods */\n- (void)goToTheCinema;\n- (void)goToSportsGame;\n\n\n@end \n```\n分类后:\n```objc\n\n#import <Foundation/Foundation.h>\n\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy, readonly) NSString *firstName;\n@property (nonatomic, copy, readonly) NSString *lastName;\n@property (nonatomic, strong, readonly) NSArray *friends;\n\n\n\n- (id)initWithFirstName:(NSString*)firstName\n\nandLastName:(NSString*)lastName;\n\n@end\n\n\n\n@interface EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n@end\n\n\n\n@interface EOCPerson (Work)\n\n- (void)performDaysWork;\n- (void)takeVacationFromWork;\n\n@end\n\n\n\n@interface EOCPerson (Play)\n\n- (void)goToTheCinema;\n- (void)goToSportsGame;\n\n@end\n```\n\n如果觉得写在一个实现文件中太长了，可以拆开，比如将其中的 `Friendship` 拆开。\n\n```objc\n// EOCPerson+Friendship.h\n#import \"EOCPerson.h\"\n\n\n@interface EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n@end\n\n\n// EOCPerson+Friendship.m\n#import \"EOCPerson+Friendship.h\"\n\n\n@implementation EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person {\n /* ... */\n}\n\n- (void)removeFriend:(EOCPerson*)person {\n /* ... */\n}\n\n- (BOOL)isFriendsWith:(EOCPerson*)person {\n /* ... */\n}\n\n@end\n```\n\n不过要注意，在新建分类文件时，一定要引入被分类的类文件。\n\n这个技巧说有用也有用，说没用，也没用，看具体实际情况吧。另外，还有一个技巧是将所有\"私有\"方法都归入名叫 Private 的分类中，以隐藏实现细节，好像是个挺有意思的想法。\n\n### 第25条：总是为第三方类的分类名称加前缀\n如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。否则可能会替换掉系统的方法。\n\n### 第26条:勿在分类中声明属性\n这本书要是早点看到就好了，当时纠结这个很久，走了很多弯路。\n\n分类机制，目标在于扩展类的功能，而不是封装数据。\n\n### 第27条：使用class-continuation分类 隐藏实现细节\n通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用 class-continuation 分类的特性来补偿：\n- 可以在 class-continuation 分类中增加实例变量。\n- 可以在 class-continuation 分类中将公共接口的只读属性设置为读写。\n- 可以在 class-continuation 分类中遵循协议，使其不为人知。\n\n### 第28条:通过协议提供匿名对象\nOC 里的**匿名对象**和 Java 里的匿名对象不同，这里的匿名对象没有类型。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。它的表示方法为：`id<protocol>`。\n\n通过协议提供匿名对象的主要使用场景有两个：\n- 作为属性\n- 作为方法参数\n\n#### 匿名对象作为属性\n在设定某个类为自己的代理属性时，可以不声明代理的类，而是用 `id<protocol>`，因为成为代理的终点并不是某个类的实例，而是遵循了某个协议。\n\n```objc\n@property (nonatomic, weak) id <EOCDelegate> delegate;\n```\n\n在这里使用匿名对象的原因有两个：\n1. 将来可能会有很多不同类的实例对象作为该类的代理。\n2. 我们不想指明具体要使用哪个类来作为这个类的代理。\n\n\n也就是说，能作为该类的代理的条件只有一个：它遵从了 `<EOCDelegate>` 协议。\n\n#### 匿名对象作为方法参数\n有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。\n\n```objc\n- (void)setObject:(id)object forKey:(id<NSCopying>)key;\n```\n\n这个方法是 NSDictionary 的设值方法，它的参数只要遵从了 `<NSCopying>` 协议，就可以作为参数传进去,作为 NSDictionary 的键。\n\n## 内存管理\n### 第29条：理解引用计数\n将对象放入自动释放池之后，不会马上使其引用计数 -1，而是在当前线程的下一次事件循环时递减。\n\n其他没什么好说的。\n\n### 第30条：以ARC简化引用计数\n使用ARC，可以省略对于引用计数的操作，没太多好说的。\n\n需要了解一个修饰符 `__weak`。块内引用外部变量时，会自动保留其所捕获的全部对象，如果这其中有某个对象保留了块本身（如将 ViewController 传入），将会形成“保留环”。所以要用 `__weak` 局部变量来打破这种保留环。\n\n```objc\nEOCNetwork * __weak weakFetcher = fetcher;\n```\n\n因此，我们可以定义一个 `weakSelf` 来简化这种声明方式：\n\n```objc\n#define WEAKSELF typeof(self) __weak weakSelf = self;\n```\n\n这样，在 ViewController 中用到 `self` 时，就可以直接用 `weakSelf` 替代。\n\n### 第31条：在dealloc方法中只释放引用并解除监听\n对象在经历生命期后，最终会被系统回收，这里就是执行 `dealloc` 方法了。永远不要自己调用 `dealloc` 方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在 `dealloc` 方法中做一些操作。那么我们可以在 `dealloc` 方法里做什么呢？\n- 释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。\n- 对象拥有的其他非OC对象也要释放（CoreFoundation 对象就必须手动释放）\n- 释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。\n\n例如：\n```objc\n- (void)dealloc {\n     CFRelease(coreFoundationObject);\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n```\n\n除了释放引用和注销通知，不要在 `dealloc` 中做其他任何事（比如调用属性的存取方法，以及异步操作）。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类要和使用者约定，用完资源后必须调用 `close` 方法。\n\n### 第32条：编写“异常安全代码”时留意内存管理问题\n在发生异常时的内存管理需要仔细考虑内存管理的问题：在 try 块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在 catch 块中能处理此问题，否则对象所占内存就将泄漏。\n\n```objc\n@try {\n     EOCSomeClass *object = [[EOCSomeClass alloc] init];\n     [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n但是在 ARC 状态下，我们不能手动释放对象，解决办法是使用：`-fobjc-arc-exceptions` 标志来让系统自动加入清理代码，不过会导致应用程序变大，而且会降低运行效率。\n\n### 第33条：以弱引用避免保留环\n对象之间都用强指针引用对方的话会造成保留环。如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。不像 Java 那种处理方式，OC 中孤立的保留环不能被自动释放。\n\n![保留环](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/effective_oc1.png?raw=true)\n\n\n那么就要用弱引用的方式：\n\n```objc\n//EOCClassB.m\n//第一种弱引用：unsafe_unretained\n@property (nonatomic, unsafe_unretained) EOCClassA *other;\n\n\n//第二种弱引用：weak\n@property (nonatomic, weak) EOCClassA *other;\n```\n\n这两种弱引用有什么区别呢？\n当指向 `EOCClassA` 实例的引用移除后，`unsafe_unretained` 属性仍然指向那个已经回收的实例，而 `weak` 指向 `nil`。显然，用 `weak` 字段应该是更安全的，因为不再使用的对象按理说应该设置为 `nil`,而不应该产生依赖。\n\n所以只要用 `weak` 就行了。\n\n### 第34条：以“自动释放池快”降低内存峰值\n这个部分在 `runloop` 相关文章中有学习过。主要用的是这样一个例子：\n\n```objc\nfor (int i = 0; i < 100000; i++) {\n      [self doSomethingWithInt:i];\n}\n```\n\n由于线程自动释放池在 event loop 时，进行清空，上面的代码将可能造成内存峰值。因此，可以手动添加一个自动释放池，把循环内的代码包裹在内，那么循环中自动释放的独享就会在这个池中，而不是在线程的主池中。\n\n```objc\nNSArray *databaseRecords = /* ... */;\nNSMutableArray *people = [NSMutableArray new];\nfor (NSDictionary *record in databaseRecords) {\n     @autoreleasepool {\n             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];\n            [people addObject:person];\n      }\n}\n```\n\n\n### 第35条：用“僵尸对象”调试内存管理问题\n\n某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。如果程序没有崩溃，可能是因为：\n\n- 该内存的部分原数据没有被覆写。\n- 该内存恰好被另一个对象占据，而这个对象可以应答这个方法。\n\n如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。因此，我们希望可以通过一种方法捕捉到对象被释放后收到消息的情况。这种方法就是利用僵尸对象！\n\nCocoa 提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改 isa 指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。\n\n(感觉好像没什么用的样子，不知道这和让程序直接 crash 比，有什么优势)\n### 第36条：不要使用retainCount\nARC 后，这个 `retainCount` 方法就废弃了。反正从来没用过，也就没啥好看的了。\n\n## 块与大小枢派发\n### 第37条：理解“块”这一概念\n基本概念无需多说，这里强调一下块的种类。\n\n块分为三类：\n- 栈块\n- 堆块\n- 全局块\n\n#### 栈块\n这是比较容易被忽略的一块。定义块的时候，其所占内存区域是**分配在栈中**的，而且只在定义它的那个范围内有效：\n\n```objc\nvoid (^block)();\n\nif ( /* some condition */ ) {\n    block = ^{\n     NSLog(@\"Block A\");\n    };\n\n} else {\n    block = ^{\n     NSLog(@\"Block B\");\n    };\n}\n\nblock();\n```\n\n上面定义的两个块只在 `if else` 语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。\n\n并不明白把块保存在栈上是个什么机制。应该可以这么理解吧:`block` 是一个指向栈上内存的指针，栈和堆的引用机制不同，在代码块运行结束后就会将代码块中的局部变量出栈，这个时候 `block` 指向的地方就被回收，`block` 就成了野指针，因此就会 crash 了。\n\n一般情况下，我们平时要么就定义完就传出去了，要么就把 `block` 定义成了类的属性，所以就没有发生过这种情况。 \n\n#### 堆块\n平时对块的操作肯定不能以栈块的形式来存储啊。堆块，要在原来的基础上执行 `copy`，让代码保存在堆上。\n\n```objc\nvoid (^block)();\n\nif ( /* some condition */ ) {\n    block = [^{\n         NSLog(@\"Block A\");\n   } copy];\n} else {\n    block = [^{\n         NSLog(@\"Block B\");\n    } copy];\n}\n\nblock();\n```\n\n至于 `copy` 怎么让栈上的东西保存到堆上就不得而知了，反正就是保存过去了。然后 `block` 就能指向堆上的地址了。\n\n平时我们用属性方式保存块的时候都是这样声明的：\n\n```objc\n@property (nonatomic,copy) Block block;\n```\n\n这个属性里暗含了 `copy` 操作了。\n\n#### 全局块\n在全局内存里声明的就是全局块，没用过。不知道有什么好处。\n\n### 第38条：为常用的块类型创建typedef\n如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型：\n\n```objc\nint (^variableName)(BOOL flag, int value) =^(BOOL flag, int value){\n     // Implementation\n     return someInt;\n}\n\n- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError *error))completion;\n```\n\n这个块有一个 bool 参数和一个 int 参数，并返回 int 类型。我们可以给它定义类型：\n\n```objc\ntypedef int(^EOCSomeBlock)(BOOL flag, int value);\ntypedef void(^EOCCompletionHandler)(NSData *data, NSError *error);\n\nEOCSomeBlock block = ^(BOOL flag, int value){\n     // Implementation\n};\n\n- (void)startWithCompletionHandler:(EOCCompletionHandler)completion;\n```\n\n### 第39条：用handler块降低代码分散程度\n可以通过块的方式代替代理模式。\n\n代理模式主要是为了让其他类在必要时候调用自己类的方法。而使用块的方式可以直接将方法内容作为参数或者属性传入调用块。这样设计业务逻辑更加直观清晰。\n\n### 第40条：用块引用其所属对象时不要出现保留环\n注意使用块的时候不要产生保留环，要在块执行完成后，将块置为 `nil`。\n\n### 第41条：多用派发队列，少用同步锁\n多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用 GCD 来为代码加锁的方式解决这个问题。\n\n#### 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\n```objc\n_syncQueue = dispatch_queue_create(\"com.effectiveobjectivec.syncQueue\", NULL);\n\n//读取字符串\n- (NSString*)someString {\n    __block NSString *localSomeString;\n    dispatch_sync(_syncQueue, ^{\n        localSomeString = _someString;\n    });\n    return localSomeString;\n}\n\n//设置字符串\n- (void)setSomeString:(NSString*)someString {\n    dispatch_sync(_syncQueue, ^{\n        _someString = someString;\n    });\n}\n```\n\n这里，用了一个串行队列，保证了读写操作都加了锁，是一种解决方式。但是，我们要明确一点，数据的正确性主要取决于写入操作，只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。因此，我们要加以改进，读操作并行，写操作串行。可以通过  `dispatch_barrier_async`、`dispatch_barrier_sync` 完成。\n\n#### 将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\n在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行。并发队列如果发现接下来要处理的块是个栅栏块，那么就一直等到当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。**相当于给并行队列里加个锁**\n\n```objc\n_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//读取字符串\n- (NSString*)someString {\n    __block NSString *localSomeString;\n    dispatch_sync(_syncQueue, ^{\n       localSomeString = _someString;\n    });\n    return localSomeString;\n}\n\n//设置字符串\n- (void)setSomeString:(NSString*)someString {\n\n    dispatch_barrier_async(_syncQueue, ^{\n        _someString = someString;\n    });\n}\n```\n\n这里解释下为什么读取用的是 `sync`，写入用的是 `async`，因为读取是要有返回值的，要将值返回给调用的对象，总不能还没有拿到值，就已经 `return` 了吧；而写入操作没有返回值，那么就让它立即 `return` 执行后面的代码，另开线程写入。\n\n### 第42条：多用GCD，少用performSelector系列方法\n在iOS开发中，有时会使用 `performSelector` 来执行某个方法，但是 `performSelector` 系列的方法能处理的选择子很局限，最好使用 GCD：\n- 它无法处理带有多个参数的选择子（有最多支持两个选择子的方法）\n- 返回值只能是void或者对象类型\n- 会引起内存泄露\n\n但是如果将方法放在块中，通过 GCD 来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 `performSelector` 方法。\n\n#### 延后执行某个任务的方法\n```objc\n// 使用 performSelector:withObject:afterDelay:\n[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];\n\n\n// 使用 dispatch_after\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));\ndispatch_after(time, dispatch_get_main_queue(), ^(void){\n    [self doSomething];\n});\n```\n\n#### 将任务放在主线程执行\n```\n// 使用 performSelectorOnMainThread:withObject:waitUntilDone:\n[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];\n\n\n// 使用 dispatch_async\n// (or if waitUntilDone is YES, then dispatch_sync)\ndispatch_async(dispatch_get_main_queue(), ^{\n        [self doSomething];\n});\n```\n\n如果 `waitUntilDone` 的参数是 `Yes`，那么就对应 GCD 的 `dispatch_sync` 方法。我们可以看到，使用 GCD 的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。\n\n### 第43条：掌握GCD及操作队列的使用时机\n除了 GCD，**操作队列（NSOperationQueue）**也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用 GCD 好些，有时则是使用操作队列更加合理。（并不清楚操作队列怎么用的，反正就抄一下哪里好）\n\n- 可以取消操作：在运行任务前，可以在NSOperation对象调用 `cancel` 方法，标明此任务不需要执行。但是 GCD 队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。\n- 可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。\n- 监控 `NSOperation` 对象的属性：可以通过 KVO 来监听 `NSOperation` 的属性：可以通过 `isCancelled` 属性来判断任务是否已取消；通过 `isFinished` 属性来判断任务是否已经完成。\n- 可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。\n\n### 第44条：通过Dispath Group机制，根据系统资源状况来执行任务\n有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用 `dispath group` 函数来实现这个需求：\n\n通过 `dispath group` 函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。\n\n```objc\n//一个优先级低的并发队列\ndispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n\n//一个优先级高的并发队列\ndispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//创建dispatch_group\ndispatch_group_t dispatchGroup = dispatch_group_create();\n\n//将优先级低的队列放入dispatch_group\nfor (id object in lowPriorityObjects) {\n dispatch_group_async(dispatchGroup,lowPriorityQueue,^{ [object performTask]; });\n}\n\n//将优先级高的队列放入dispatch_group\nfor (id object in highPriorityObjects) {\n dispatch_group_async(dispatchGroup,highPriorityQueue,^{ [object performTask]; });\n}\n\n//dispatch_group里的任务都结束后调用块中的代码\ndispatch_queue_t notifyQueue = dispatch_get_main_queue();\ndispatch_group_notify(dispatchGroup,notifyQueue,^{\n     // Continue processing after completing tasks\n});\n```\n\n想要更详细的了解，还是看之前的 GCD 介绍文章吧。\n\n### 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n有时我们可能只需要将某段代码执行一次，这时可以通过 `dispatch_once` 函数来解决。\n\n`dispatch_once` 函数比较重要的使用例子是单例模式：\n我们在创建单例模式的实例时，可以使用 `dispatch_once` 函数来令初始化代码只执行一次，并且内部是线程安全的。\n\n而且，对于执行一次的 `block` 来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在 `static` 或 `global` 作用域里。\n\n```objc\n+ (id)sharedInstance {\n     static EOCClass *sharedInstance = nil;\n     static dispatch_once_t onceToken;\n     dispatch_once(&onceToken, ^{\n﻿            sharedInstance = [[self alloc] init];\n    });\n     return sharedInstance;\n}\n```\n\n### 第46条：不要使用dispatch_get_current_queue\n已经被废弃的 API，不说了。\n\n## 系统框架\n### 第47条：熟悉系统框架\n主要的系统框架：\n- Foundation  :NSObject,NSArray,NSDictionary 等\n- CFoundation :C 语言 API，Foundation 框架中的许多功能，都可以在这里找到对应的 C 语言 API\n- CFNetwork   :C 语言 API，提供了 C 语言级别的网络通信能力 \n- CoreAudio   :C 语言 API，操作设备上的音频硬件\n- AVFoundation:提供的 OC 对象可以回放并录制音频和视频\n- CoreData    :OC 的 API，将对象写入数据库\n- CoreText    :C 语言 API，高效执行文字排版和渲染操作\n\n\n### 第48条：多用块枚举，少用for循环\n#### 传统的for遍历\n```objc\nNSArray *anArray = /* ... */;\nfor (int i = 0; i < anArray.count; i++) {\n   id object = anArray[i];\n   // Do something with 'object'\n}\n\n\n\n// Dictionary\nNSDictionary *aDictionary = /* ... */;\nNSArray *keys = [aDictionary allKeys];\nfor (int i = 0; i < keys.count; i++) {\n   id key = keys[i];\n   id value = aDictionary[key];\n   // Do something with 'key' and 'value'\n}\n\n\n// Set\nNSSet *aSet = /* ... */;\nNSArray *objects = [aSet allObjects];\nfor (int i = 0; i < objects.count; i++) {\n   id object = objects[i];\n   // Do something with 'object'\n\n}\n```\n\n我们可以看到，在遍历 NSDictionary,和 NSet 时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。\n\n#### 利用快速遍历\n```objc\nNSArray *anArray = /* ... */;\nfor (id object in anArray) {\n // Do something with 'object'\n}\n\n// Dictionary\nNSDictionary *aDictionary = /* ... */;\nfor (id key in aDictionary) {\n id value = aDictionary[key];\n // Do something with 'key' and 'value'\n\n}\n\n\nNSSet *aSet = /* ... */;\nfor (id object in aSet) {\n // Do something with 'object'\n}\n```\n\n这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。\n\n#### 利用基于块（block）的遍历\n其实我觉得没啥用，不看也罢。\n\n### 第49条：对自定义其内存管理语义的collection使用无缝桥接\n通过无缝桥接技术，可以在 Foundation 框架中的 OC 对象和 CoreFoundation 框架中的 C 语言数据结构之间来回转换。\n\n为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。\n\n具体怎么用，用在什么场景呢？ 没看懂。呵呵\n\n### 第50条：构建缓存时选用 NSCache 而非 NSDictionary\n不知道有啥用，用到时候再说。\n\n### 第51条: 精简initialize 与 load的实现代码\n每个类和分类在**加入运行期系统时**，都会调用 `load` 方法，而且仅仅调用一次。`load` 方法不遵循继承规则，某个类本身没有重写 `load`，那也不会调用超类的 `load` 方法。可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。\n\n`initialize` 方法与 `load` 方法类似，区别是这个方法会在程序首次调用这个类的时候调用（**惰性调用**），而且只调用一次（绝对不能主动使用代码调用）。如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。如果在 `initialize` 方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在 `initialize` 方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的 bug。\n\n### 第52条: 别忘了NSTimer会保留其目标对象\n在使用 `NSTimer` 的时候，`NSTimer` 会生成指向其使用者的引用，而其使用者如果也引用了 `NSTimer`，那么就会生成保留环。\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCClass : NSObject\n- (void)startPolling;\n- (void)stopPolling;\n@end\n\n\n@implementation EOCClass {\n     NSTimer *_pollTimer;\n}\n\n\n- (id)init {\n     return [super init];\n}\n\n\n- (void)dealloc {\n    [_pollTimer invalidate];\n}\n\n\n- (void)stopPolling {\n\n    [_pollTimer invalidate];\n    _pollTimer = nil;\n}\n\n\n- (void)startPolling {\n   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0\n                                                 target:self\n                                               selector:@selector(p_doPoll)\n                                               userInfo:nil\n                                                repeats:YES];\n}\n\n- (void)p_doPoll {\n    // Poll the resource\n}\n\n@end\n```\n\n这里可以看到 `EOCClass` 和 `_pollTimer` 之间由于 `target:self` 的存在，相互形成了保留环，如果不主动调用 `stopPolling` 方法将 `_pollTimer`取消并清空就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。这可能是一个极其危险的情况，因为 NSTimer 没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。\n\n那么如何解决呢？\n\n我觉得文章里举的方法简直脱裤子放屁，所以就不列出来了。直接将 `target:self` 设置成 `target:weakSelf` 不就行了？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Effective_oc2笔记.md","raw":"title: Effective Objective-C 学习笔记\ndate: 2016/11/11 10:07:12  \ncategories: iOS\ntags:\n\t- Objective-C\n\n---\n\n拜读一下 Effective Objective-C 这本书，做一些笔记\n\n<!--more-->\n\n## 熟悉OC\n### 第1条：了解Objective-C的起源\n\n对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由**运行期组件（runtime component）**完成，使用 Objective-C 的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。\n\n运行期组件本质上是一种与开发者所编写的代码相链接的**动态库（dynamic library）**，其代码能把开发者所编写的所有程序粘合起来。\n\n### 第2条： 在类的头文件中尽量少引用其他头文件\n\n有时，类A需要将类B的实例变量作为它公共 API 的属性。这个时候，我们不应该引入类B的头文件，而应该使用**向前声明（forward declaring）** 使用 `@class` 关键字，并且**在 A 的实现文件引用 B 的头文件**。(继承或者协议必须引入完整头文件，不能使用向前声明)\n\n```objc\n// EOCPerson.h\n#import <Foundation/Foundation.h>\n\n@class EOCEmployer;\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy) NSString *firstName;\n@property (nonatomic, copy) NSString *lastName;\n@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性\n\n@end\n\n// EOCPerson.m\n#import \"EOCEmployer.h\"\n```\n\n这样做有什么优点呢：\n1. 不在A的头文件中引入B的头文件，那么A的实现文件引入A的头文件时，就不会一并引入B的全部内容，这样就减少了编译时间。只有在A的实现里需要用到B时，再在A的实现里引用B的头文件。\n2. 使用 `#import` 而不是 `#include` 可以避免死循环，但仍会导致相互引用的两个类中的一哥无法正确编译。使用 `@class` 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。\n\n### 第3条：多用字面量语法，少用与之等价的方法\n声明时多用字面量：\n\n```objc\nNSNumber *intNumber = @1;\nNSNumber *floatNumber = @2.5f;\nNSArray *animals =@[@\"cat\", @\"dog\",@\"mouse\", @\"badger\"];\nDictionary *dict = @{@\"animal\":@\"tiger\",@\"phone\":@\"iPhone 6\"};\n\nNSString *cat = animals[0];\nNSString *iphone = dict[@\"phone\"];\n```\n\n少用 `alloc`、`init` 的方式创建，以及 `objectAtIndex`、`objectForKey` 的方式取数组字典。\n\n优点：\n1. 简洁\n2. `NSArray` 以 `nil` 结尾，所以一般不允许数组中的元素为 `nil`，如果使用等价方法，那么数组元素为 `nil` 不报错，会出现难以排查的错误；而同样的情况，字面量语法会抛出异常。\n\n### 第4条：多用类型常量，少用#define预处理命令\n预处理与类型常量的优缺点：\n- 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。\n- 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。\n\n#### 预处理命令\n\n```objc\n#define W_LABEL (W_SCREEN - 2*GAP)\n```\n\n这里，`(W_SCREEN - 2*GAP)` 替换了 `W_LABEL`，它不具备 `W_LABEL` 的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。\n\n#### 类型常量\n\n```objc\nstatic const NSTimeIntervalDuration = 0.3;\n```\n\n`const` 将其设置为常量，不可更改。`static` 意味着该变量仅仅在定义此变量的编译单元(`.m` 实现文件)中可见。如果不声明 `static`,编译器会为它创建一个**外部符号（external symbol）**。会出现什么问题呢？如果在其他类中也声明了同名变量，即使没有相互引用，编译器也会抛出一个异常。\n\n#### 全局常量\n如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量，即全局常量。在头文件中声明外部常量，在实现文件中完成变量的赋值。\n\n```objc\n//header file\nextern NSString *const NotificationString;\n\n//implementation file\nNSString *const  NotificationString = @\"Finish Download\";\n```\n\n注意这里的 `const`, 如果在 `*` 前面，表示指针指向的堆上的内容不能改变，如果在 `*` 后面，表示指针指向的地址是不能改变的。（这里有个助记方法，以 `*` 为分解，`const` 在左边就是修饰 `NSString`，表示不能修改值，在右边就表示修饰指针对象，表示不能修改指针指向的地址。）\n\n### 第5条：用枚举表示状态，选项，状态码\n我们经常需要给类定义几个状态，这些状态码可以用枚举来管理：\n\n```objc\ntypedef NS_ENUM(NSUInteger, EOCConnectionState) {\n  EOCConnectionStateDisconnected,\n  EOCConnectionStateConnecting,\n  EOCConnectionStateConnected,\n};\n\ntypedef NS_OPTION(NSUInteger, EOCPermittedDirection) {\n\tEOCPermittedDirectionUp    = 1 << 0,\n\tEOCPermittedDirectionDown  = 1 << 1,\n\tEOCPermittedDirectionLeft  = 1 << 2,\n\tEOCPermittedDirectionRight = 1 << 3\n}\n```\n\n`NS_ENUM` 和 `NS_OPTION` 是 Foundation 框架中定义的辅助宏。需要注意这两者使用场景的不同。\n\n在枚举类型的 switch 语句中不要实现 default 分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch 语句并未处理所有的枚举。否则添加了枚举却没有实现 switch 将可能导致严重的崩溃。\n\n## 对象、消息、运行期\n### 第6条：理解“属性”这一概念\n#### 属性\n在 Java 以及 C++ 中，对象布局在编译期就已经固定了。只要访问变量的代码，编译器就会把其替换成为“偏移量”。这个偏移量是**硬编码（hardcode）**，表示该对象距离存放对象的内存区域的起始地址有多远。这样做的问题是，如果再添加一个实例变量，那么其他实例变量的就要变化了，那么就要重新编译，否则就会出错。\n\nObjective-C 的做法是，把实例变量当做一种存储偏移量所用的**“特殊变量”（special variable）**，交由**“类对象”（class object）**保管。偏移量会在运行期查找，那么类的定义变了，存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。\n\n#### 存取方法\n在设置完属性后，编译器会自动向类中添加适当类型的实例变量，并且为其写出一套存取方法。访问属性，可以使用点语法，编译器会把点语法转换为对存取方法的调用；也可直接使用实例变量，使用实例变量的方式更快。\n\n```objc\n//存取方法设置属性\nself.firstName = @\"Zachary\";\n//实例变量设置属性\n_firstName = @\"Zachary\";\n```\n\n\n#### 属相特质\n原子性：\n- nonatomic：不使用同步锁\n- atomic：加同步锁，确保其原子性\n\n读写:\n- readwrite:同时存在存取方法\n- readonly:只有获取方法\n\n内存管理:\n- assign:纯量类型(scalar type)的简单赋值操作\n- strong:拥有关系保留新值，释放旧值，再设置新值\n- weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空\n- copy：当赋给其可变对象，返回不可变对象；当赋给其不可变对象，返回原对象。\n\n### 第7条： 在对象内部尽量直接访问实例变量\n关于实例变量的访问，可以直接访问 `_firstName`，也可以通过属性的方式(点语法) `self.firstName` 来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。（这部分比较重要）\n\n直接访问实例变量的特点：\n- 不经过**“方法派发”(method dispatch)**，会直接访问保存对象实例变量的那块内存，速度快。\n\n通过属性访问实例变量的特点：\n- 不会绕过属性定义的**内存管理语义**。其实也就是说，编译期在设置 set 方法的时候，会根据属性特质做一些操作。比如一个声明为 `copy` 的属性，如果直接访问实例变量，那么这个实例变量就会直接指向堆中的对象；而如果通过属性来操作，就会先将堆中的对象 copy 一份，然后将实例变量指向 copy 出来的对象。\n- 可以触发KVO\n\n不过有两个特例：\n1. `init` 方法和 `dealloc` 方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作(比如上面说的**内存管理语义**所要进行的操作)。\n2. 如果使用**懒加载**的获取方法要用属性的方式获取。\n\n其实，到底用什么很简单，如果 get，set 方法里没有其他的乱七八糟的东西，比如:\n\n```objc\n- (NSString *)firstName{\n\treturn _firstName;\n}\n\n- (void) setFirstName:(NSString *)firstName{\n\t_firstName = firstName;\n}\n```\n\n上面这种，那就直接用实例变量操作了，用属性就是多此一举；如果有乱七八糟的东西，那么就要用属性的方式。\n\n### 第8条：理解“对象等同性”这一概念\n`NSObject` 类中有两个用于判断等同性的方法：\n- `- (BOOL)isEqual:(id)object;`\n- `- (NSUInteger)hash;`\n\n`NSObject` 类中默认的实现是：当且仅当其内存地址完全相等时，两个对象才相等。自定义对象中可以覆写这两个方法（其实好像没必要重写 hash 方法，因为我们重写的 `isEqual:` 方法里根本没有用到 hash 方法，重写了也没啥用），完成自己的相等判断。如果 `isEqual:` 方法判断对象相等，那么其 hash 方法也必须返回同一个值；反之，如果 hash 方法返回了同一个值，`isEqual:` 方法未必认为两者相等。\n\n如果已知两个对象是字符串，最好通过 `isEqualToString:` 方法来比较。对于数组和字典，也有 `isEqualToArray:` 方法和 `isEqualToDictionary:`方法。\n\n如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的 `isEqual:` 方法：\n```objc\n- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson {\n\n     //先比较对象类型，然后比较每个属性\n     if (self == object) return YES;\n     if (![_firstName isEqualToString:otherPerson.firstName])\n         return NO;\n     if (![_lastName isEqualToString:otherPerson.lastName])\n         return NO;\n     if (_age != otherPerson.age)\n         return NO;\n     return YES;\n}\n\n\n- (BOOL)isEqual:(id)object {\n    //如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法\n     if ([self class] == [object class]) {    \n         return [self isEqualToPerson:(EOCPerson*)object];\n    } else {    \n         return [super isEqual:object];\n    }\n}\n```\n\n### 第9条 以“类族模式“隐藏实现细节\n其实就是通过抽象类完成工厂模式。\n\n例如,对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：\n\n```objc\n//EOCEmployee.h\n\ntypedef NS_ENUM(NSUInteger, EOCEmployeeType) {\n    EOCEmployeeTypeDeveloper,\n    EOCEmployeeTypeDesigner,\n    EOCEmployeeTypeFinance,\n};\n\n@interface EOCEmployee : NSObject\n\n@property (copy) NSString *name;\n@property NSUInteger salary;\n\n\n// Helper for creating Employee objects\n+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;\n\n// Make Employees do their respective day's work\n- (void)doADaysWork;\n\n@end\n```\n\n```objc\n//EOCEmployee.m\n\n@implementation EOCEmployee\n\n+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type {\n     switch (type) {\n         case EOCEmployeeTypeDeveloper:\n            return [EOCEmployeeDeveloper new];\n         break; \n\n        case EOCEmployeeTypeDesigner:\n             return [EOCEmployeeDesigner new];\n         break;\n\n        case EOCEmployeeTypeFinance:\n             return [EOCEmployeeFinance new];\n         break;\n    }\n}\n\n- (void)doADaysWork {\n // 需要子类来实现\n}\n\n@end\n```\n\n```objc\n@interface EOCEmployeeDeveloper : EOCEmployee\n@end\n\n@implementation EOCEmployeeDeveloper\n\n- (void)doADaysWork {\n    [self writeCode];\n}\n\n@end\n```\n\n这样，表面上对象是 `EOCEmployee`，但是实际上操作的是 `EOCEmployeeDeveloper`。\n\n这里需要注意一点：对于这种类族，不能通过以下方式判断：\n\n```objc\nif ([employeeDeveloper class] == [EOCEmployee class]){\n\t// will do\n}\n```\n\n因为 `employeeDeveloper` 对象是 `EOCEmployee` 类的一个子集，需要使用 `isKindOfClass:` 方法：\n\n```objc\nif ([employeeDeveloper isKindOfClass:[EOCEmployee class]]){\n\t// will do\n}\n```\n\n### 第10条：在既有类中使用关联对象存放自定义数据\n\n这一条和 runtime 息息相关。背景是，我们可以通过 category 为系统类添加方法，但是无法添加属性。当需要为系统类添加属性时，可以使用下面的方法：\n\n```objc\n//为某个对象设置关联对象的值，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义\nvoid objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)\n\n//根据给定的键从某对象中获取相应的关联对象值\nid objc_getAssociatedObject(id object, void *key)\n\n//移除指定对象的关联对象\nvoid objc_removeAssociatedObjects(id object)\n```\n\n这里要强调的是，要拿到设置的属性，键必须要完全相等。因此，需要设置成静态全局变量：\n\n```objc\nstatic void *EOCMyAlertViewKey = \"EOCMyAlertViewKey\";\n```\n\n\n### 第11条：理解objc_msgSend的作用\n这部分在[runtime](https://zhang759740844.github.io/2016/08/22/runtime原理/)中已经写得很详细了，参见就行了。\n\n### 第12条：理解消息转发机制\n这部分在[runtime](https://zhang759740844.github.io/2016/08/23/runtime应用/)中已经写得很详细了，参见就行了。\n\n### 第13条：用“方法调配技术”调试“黑盒方法”\n这部分在[runtime](https://zhang759740844.github.io/2016/08/23/runtime应用/)中也介绍了。\n\n### 第14条：理解“类对象”的用意\n这部分在[runtime](https://zhang759740844.github.io/2016/08/22/runtime原理/)中也介绍了。\n\n## 接口与API设计\n### 第15条：用前缀 避免命名空间冲突\nApple 宣称其保留使用所有\"两字母前缀\"的权利，所以我们选用的前缀应该是三个字母的。而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。\n\n### 第16条：提供\"全能初始化方法\"\n所谓全能初始化方法，就是所有初始化方法都要调用的初始化方法。这个初始化方法初始化方法是初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。\n\n算是一种写代码的技巧吧。平时写代码的时候也都是这样的，不具体说明了。\n\n### 第17条：实现description方法\n自定义的类调用 `NSLog();` 的时候，往往不能返回想要的结果。需要重写 `NSObject` 类中的 `description` 方法，返回需要的字符串。\n```objc\n- (NSString*)description {\n     return [NSString stringWithFormat:@\"<%@: %p, %@ %@>\", [self class], self, firstName, lastName];\n}\n```\n\n其中，`%p` 表示对象的内存地址。\n\n### 第18条：尽量使用不可变对象\n尽量使用不可变对象。没啥可说的。\n里面推荐的方法没用过，感觉并不好，就不写了。\n\n### 第19条：使用清晰而协调的命名方式\n没啥好说的，注意就好\n\n### 第20条：为私有方法名加前缀\n建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCObject : NSObject\n\n- (void)publicMethod;\n\n@end\n\n\n@implementation EOCObject\n\n- (void)publicMethod {\n /* ... */\n}\n\n- (void)p_privateMethod {\n /* ... */\n}\n\n@end\n```\n\n很有用的建议，注意不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。\n\n### 第21条：理解Objective-C错误类型\nOC 中仅在及其严重的错误情况下抛出异常。比如一个抽象基类。由于 OC 中没办法将某个类标识为抽象类。如果想要实现抽象类的功能，那么就要在必须要覆写的方法里抛出异常：\n\n```objc\n- (void)mustOverrideMethod{\n\tNSString *reason = [NSString stringWithFormat:@\"%@ must be overridden\", NSStringFromeSelector(_cmd)];\n\t@throw [NSException exceptionWithName:NSInternalInconsistencyException\n\t\t\t\t\t\t\t\t\t    reason:reason\n\t\t\t\t\t\t\t\t\t  userInfo:nil];\n}\n```\n\n对于不严重的异常，可以使用返回 `nil` 或者 `NSError` 的方式(其实也没啥用，这些都是手动设置的，我都知道哪里会出现问题了，还要新建 `NSError` 对象干嘛(可能我的理解有偏差))。\n\n### 第22条：理解NSCopying协议\n#### 自定义拷贝\n如果我们想令自己的类支持拷贝操作，那就要实现 `NSCopying` 协议，该协议只有一个方法：\n\n```objc\n- (id)copyWithZone:(NSZone*)zone\n```\n\n比如要拷贝一个 `EOCPerson` 对象：\n\n```objc\n- (id)copyWithZone:(NSZone*)zone {\n     EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];\n    copy->_friends = [_friends mutableCopy];\n     return copy;\n}\n``` \n\n这里面的 `NSZone *zone` 对象不用在意是什么，现在已经没用了。其实也就是新建一个 `EOCPerson` 对象，然后调用它的构造函数把东西全都塞进去。这里的 `->` 用箭头是因为定义的时候这个 `_friends` 不是一个属性(代码没有贴出来，详见书)，而只是在实现文件中定义的一个实例变量，没有 get/set 方法，所以不能用 `.` \n\n这里的 `mutableCopy` 方法也可以自定义，就是下面方法的实现 \n```objc\n- (id)mutableCopyWithZone:(NSZone*)zone；\n```\n\n#### 浅拷贝与深拷贝\n浅拷贝和深拷贝应该并不陌生。浅拷贝只增加引用计数，深拷贝将创建另一个一模一样的对象。\n\n- 不可变对象的 `copy` 是浅拷贝。\n- 可变对象的 `copy` 是深拷贝，返回不可变对象。\n- 不可变对象的 `mutableCopy` 是深拷贝，返回可变对象。\n- 可变对象的 `mutableCopy` 是浅拷贝。\n\n容器对象(`NSArray`)本身也遵循上面的规则。但是需要注意的是，**容器对象内的元素是浅拷贝**。因此上面的自定义 copy 方法如果想让 `_friends` 内的元素深拷贝，就不能用 `[_friends mutableCopy]` 方法，需要新建一个 Set:\n\n```objc\n- (id)deepCopy {\n   EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];\n\tcopy->_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];\n   return copy;\n}\n```\n\n## 协议与分类\n### 第23条：通过委托与数据源协议进行对象间通信\n其实也是老生常谈的东西了，不过也有一些注意点。\n\n受代理对象内持有代理对象的实例时要写成这样：\n\n```objc\n@property (nonatomic, weak) id <NetworkDelegate> delegate;\n```\n\n这里书中指明了要用 `weak`，不能用 `strong`，否则会引起引用循环。比如系统中的 `TableViewCellDelegate`，在 `TableViewController` 作为代理类确实拥有被代理对象 `TableViewCell`，用 `weak` 确实是合理的，但是所有情况都这样吗？不知道，不过确实基本上的代理对象都是 `ViewController`，所以用 `weak` 肯定是不会有问题的。\n\n实现委托对象的方法是声明某个类遵从委托协议：\n\n```objc\n@implementation EOCDataModel () <EOCNetworkFetcherDelegate>\n@end\n@implementation EOCDataModel\n// 各个实现方法\n@end\n```\n\n基本所有的 Delegate 都在 `.m` 文件中的类拓展中声明，之前一直没有留意，看了书后才问自己，为什么不在 `.h` 中声明？两者有什么差别吗？其实也没什么差别，在实现文件中声明的好处是能隐藏细节。如果只是自己用可能没什么区别，但是如果打包给别人用，那么就不应该让别人看到你的实现细节了，因此，就把这个 Delegate 的声明放到了实现文件中。\n好吧。一个简单的道理。只是我一开始没想明白。\n\n### 第24条：将类的实现代码分散到便于管理的数个分类中\n当一个类越来越大时，就变得不利于管理，因此需要将类代码按照逻辑划分入几个分区中，可以通过范畴的方式实现。书中有一个例子：\n\n无分类:\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy, readonly) NSString *firstName;\n@property (nonatomic, copy, readonly) NSString *lastName;\n@property (nonatomic, strong, readonly) NSArray *friends;\n\n- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;\n\n/* Friendship methods */\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n\n/* Work methods */\n- (void)performDaysWork;\n- (void)takeVacationFromWork;\n\n\n/* Play methods */\n- (void)goToTheCinema;\n- (void)goToSportsGame;\n\n\n@end \n```\n分类后:\n```objc\n\n#import <Foundation/Foundation.h>\n\n\n@interface EOCPerson : NSObject\n\n@property (nonatomic, copy, readonly) NSString *firstName;\n@property (nonatomic, copy, readonly) NSString *lastName;\n@property (nonatomic, strong, readonly) NSArray *friends;\n\n\n\n- (id)initWithFirstName:(NSString*)firstName\n\nandLastName:(NSString*)lastName;\n\n@end\n\n\n\n@interface EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n@end\n\n\n\n@interface EOCPerson (Work)\n\n- (void)performDaysWork;\n- (void)takeVacationFromWork;\n\n@end\n\n\n\n@interface EOCPerson (Play)\n\n- (void)goToTheCinema;\n- (void)goToSportsGame;\n\n@end\n```\n\n如果觉得写在一个实现文件中太长了，可以拆开，比如将其中的 `Friendship` 拆开。\n\n```objc\n// EOCPerson+Friendship.h\n#import \"EOCPerson.h\"\n\n\n@interface EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person;\n- (void)removeFriend:(EOCPerson*)person;\n- (BOOL)isFriendsWith:(EOCPerson*)person;\n\n@end\n\n\n// EOCPerson+Friendship.m\n#import \"EOCPerson+Friendship.h\"\n\n\n@implementation EOCPerson (Friendship)\n\n- (void)addFriend:(EOCPerson*)person {\n /* ... */\n}\n\n- (void)removeFriend:(EOCPerson*)person {\n /* ... */\n}\n\n- (BOOL)isFriendsWith:(EOCPerson*)person {\n /* ... */\n}\n\n@end\n```\n\n不过要注意，在新建分类文件时，一定要引入被分类的类文件。\n\n这个技巧说有用也有用，说没用，也没用，看具体实际情况吧。另外，还有一个技巧是将所有\"私有\"方法都归入名叫 Private 的分类中，以隐藏实现细节，好像是个挺有意思的想法。\n\n### 第25条：总是为第三方类的分类名称加前缀\n如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。否则可能会替换掉系统的方法。\n\n### 第26条:勿在分类中声明属性\n这本书要是早点看到就好了，当时纠结这个很久，走了很多弯路。\n\n分类机制，目标在于扩展类的功能，而不是封装数据。\n\n### 第27条：使用class-continuation分类 隐藏实现细节\n通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用 class-continuation 分类的特性来补偿：\n- 可以在 class-continuation 分类中增加实例变量。\n- 可以在 class-continuation 分类中将公共接口的只读属性设置为读写。\n- 可以在 class-continuation 分类中遵循协议，使其不为人知。\n\n### 第28条:通过协议提供匿名对象\nOC 里的**匿名对象**和 Java 里的匿名对象不同，这里的匿名对象没有类型。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。它的表示方法为：`id<protocol>`。\n\n通过协议提供匿名对象的主要使用场景有两个：\n- 作为属性\n- 作为方法参数\n\n#### 匿名对象作为属性\n在设定某个类为自己的代理属性时，可以不声明代理的类，而是用 `id<protocol>`，因为成为代理的终点并不是某个类的实例，而是遵循了某个协议。\n\n```objc\n@property (nonatomic, weak) id <EOCDelegate> delegate;\n```\n\n在这里使用匿名对象的原因有两个：\n1. 将来可能会有很多不同类的实例对象作为该类的代理。\n2. 我们不想指明具体要使用哪个类来作为这个类的代理。\n\n\n也就是说，能作为该类的代理的条件只有一个：它遵从了 `<EOCDelegate>` 协议。\n\n#### 匿名对象作为方法参数\n有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。\n\n```objc\n- (void)setObject:(id)object forKey:(id<NSCopying>)key;\n```\n\n这个方法是 NSDictionary 的设值方法，它的参数只要遵从了 `<NSCopying>` 协议，就可以作为参数传进去,作为 NSDictionary 的键。\n\n## 内存管理\n### 第29条：理解引用计数\n将对象放入自动释放池之后，不会马上使其引用计数 -1，而是在当前线程的下一次事件循环时递减。\n\n其他没什么好说的。\n\n### 第30条：以ARC简化引用计数\n使用ARC，可以省略对于引用计数的操作，没太多好说的。\n\n需要了解一个修饰符 `__weak`。块内引用外部变量时，会自动保留其所捕获的全部对象，如果这其中有某个对象保留了块本身（如将 ViewController 传入），将会形成“保留环”。所以要用 `__weak` 局部变量来打破这种保留环。\n\n```objc\nEOCNetwork * __weak weakFetcher = fetcher;\n```\n\n因此，我们可以定义一个 `weakSelf` 来简化这种声明方式：\n\n```objc\n#define WEAKSELF typeof(self) __weak weakSelf = self;\n```\n\n这样，在 ViewController 中用到 `self` 时，就可以直接用 `weakSelf` 替代。\n\n### 第31条：在dealloc方法中只释放引用并解除监听\n对象在经历生命期后，最终会被系统回收，这里就是执行 `dealloc` 方法了。永远不要自己调用 `dealloc` 方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在 `dealloc` 方法中做一些操作。那么我们可以在 `dealloc` 方法里做什么呢？\n- 释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。\n- 对象拥有的其他非OC对象也要释放（CoreFoundation 对象就必须手动释放）\n- 释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。\n\n例如：\n```objc\n- (void)dealloc {\n     CFRelease(coreFoundationObject);\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n```\n\n除了释放引用和注销通知，不要在 `dealloc` 中做其他任何事（比如调用属性的存取方法，以及异步操作）。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类要和使用者约定，用完资源后必须调用 `close` 方法。\n\n### 第32条：编写“异常安全代码”时留意内存管理问题\n在发生异常时的内存管理需要仔细考虑内存管理的问题：在 try 块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在 catch 块中能处理此问题，否则对象所占内存就将泄漏。\n\n```objc\n@try {\n     EOCSomeClass *object = [[EOCSomeClass alloc] init];\n     [object doSomethingThatMayThrow];\n}\n@catch (...) {\n NSLog(@\"Whoops, there was an error. Oh well...\");\n}\n```\n\n但是在 ARC 状态下，我们不能手动释放对象，解决办法是使用：`-fobjc-arc-exceptions` 标志来让系统自动加入清理代码，不过会导致应用程序变大，而且会降低运行效率。\n\n### 第33条：以弱引用避免保留环\n对象之间都用强指针引用对方的话会造成保留环。如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。不像 Java 那种处理方式，OC 中孤立的保留环不能被自动释放。\n\n![保留环](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/effective_oc1.png?raw=true)\n\n\n那么就要用弱引用的方式：\n\n```objc\n//EOCClassB.m\n//第一种弱引用：unsafe_unretained\n@property (nonatomic, unsafe_unretained) EOCClassA *other;\n\n\n//第二种弱引用：weak\n@property (nonatomic, weak) EOCClassA *other;\n```\n\n这两种弱引用有什么区别呢？\n当指向 `EOCClassA` 实例的引用移除后，`unsafe_unretained` 属性仍然指向那个已经回收的实例，而 `weak` 指向 `nil`。显然，用 `weak` 字段应该是更安全的，因为不再使用的对象按理说应该设置为 `nil`,而不应该产生依赖。\n\n所以只要用 `weak` 就行了。\n\n### 第34条：以“自动释放池快”降低内存峰值\n这个部分在 `runloop` 相关文章中有学习过。主要用的是这样一个例子：\n\n```objc\nfor (int i = 0; i < 100000; i++) {\n      [self doSomethingWithInt:i];\n}\n```\n\n由于线程自动释放池在 event loop 时，进行清空，上面的代码将可能造成内存峰值。因此，可以手动添加一个自动释放池，把循环内的代码包裹在内，那么循环中自动释放的独享就会在这个池中，而不是在线程的主池中。\n\n```objc\nNSArray *databaseRecords = /* ... */;\nNSMutableArray *people = [NSMutableArray new];\nfor (NSDictionary *record in databaseRecords) {\n     @autoreleasepool {\n             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];\n            [people addObject:person];\n      }\n}\n```\n\n\n### 第35条：用“僵尸对象”调试内存管理问题\n\n某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。如果程序没有崩溃，可能是因为：\n\n- 该内存的部分原数据没有被覆写。\n- 该内存恰好被另一个对象占据，而这个对象可以应答这个方法。\n\n如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。因此，我们希望可以通过一种方法捕捉到对象被释放后收到消息的情况。这种方法就是利用僵尸对象！\n\nCocoa 提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改 isa 指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。\n\n(感觉好像没什么用的样子，不知道这和让程序直接 crash 比，有什么优势)\n### 第36条：不要使用retainCount\nARC 后，这个 `retainCount` 方法就废弃了。反正从来没用过，也就没啥好看的了。\n\n## 块与大小枢派发\n### 第37条：理解“块”这一概念\n基本概念无需多说，这里强调一下块的种类。\n\n块分为三类：\n- 栈块\n- 堆块\n- 全局块\n\n#### 栈块\n这是比较容易被忽略的一块。定义块的时候，其所占内存区域是**分配在栈中**的，而且只在定义它的那个范围内有效：\n\n```objc\nvoid (^block)();\n\nif ( /* some condition */ ) {\n    block = ^{\n     NSLog(@\"Block A\");\n    };\n\n} else {\n    block = ^{\n     NSLog(@\"Block B\");\n    };\n}\n\nblock();\n```\n\n上面定义的两个块只在 `if else` 语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。\n\n并不明白把块保存在栈上是个什么机制。应该可以这么理解吧:`block` 是一个指向栈上内存的指针，栈和堆的引用机制不同，在代码块运行结束后就会将代码块中的局部变量出栈，这个时候 `block` 指向的地方就被回收，`block` 就成了野指针，因此就会 crash 了。\n\n一般情况下，我们平时要么就定义完就传出去了，要么就把 `block` 定义成了类的属性，所以就没有发生过这种情况。 \n\n#### 堆块\n平时对块的操作肯定不能以栈块的形式来存储啊。堆块，要在原来的基础上执行 `copy`，让代码保存在堆上。\n\n```objc\nvoid (^block)();\n\nif ( /* some condition */ ) {\n    block = [^{\n         NSLog(@\"Block A\");\n   } copy];\n} else {\n    block = [^{\n         NSLog(@\"Block B\");\n    } copy];\n}\n\nblock();\n```\n\n至于 `copy` 怎么让栈上的东西保存到堆上就不得而知了，反正就是保存过去了。然后 `block` 就能指向堆上的地址了。\n\n平时我们用属性方式保存块的时候都是这样声明的：\n\n```objc\n@property (nonatomic,copy) Block block;\n```\n\n这个属性里暗含了 `copy` 操作了。\n\n#### 全局块\n在全局内存里声明的就是全局块，没用过。不知道有什么好处。\n\n### 第38条：为常用的块类型创建typedef\n如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型：\n\n```objc\nint (^variableName)(BOOL flag, int value) =^(BOOL flag, int value){\n     // Implementation\n     return someInt;\n}\n\n- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError *error))completion;\n```\n\n这个块有一个 bool 参数和一个 int 参数，并返回 int 类型。我们可以给它定义类型：\n\n```objc\ntypedef int(^EOCSomeBlock)(BOOL flag, int value);\ntypedef void(^EOCCompletionHandler)(NSData *data, NSError *error);\n\nEOCSomeBlock block = ^(BOOL flag, int value){\n     // Implementation\n};\n\n- (void)startWithCompletionHandler:(EOCCompletionHandler)completion;\n```\n\n### 第39条：用handler块降低代码分散程度\n可以通过块的方式代替代理模式。\n\n代理模式主要是为了让其他类在必要时候调用自己类的方法。而使用块的方式可以直接将方法内容作为参数或者属性传入调用块。这样设计业务逻辑更加直观清晰。\n\n### 第40条：用块引用其所属对象时不要出现保留环\n注意使用块的时候不要产生保留环，要在块执行完成后，将块置为 `nil`。\n\n### 第41条：多用派发队列，少用同步锁\n多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用 GCD 来为代码加锁的方式解决这个问题。\n\n#### 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\n```objc\n_syncQueue = dispatch_queue_create(\"com.effectiveobjectivec.syncQueue\", NULL);\n\n//读取字符串\n- (NSString*)someString {\n    __block NSString *localSomeString;\n    dispatch_sync(_syncQueue, ^{\n        localSomeString = _someString;\n    });\n    return localSomeString;\n}\n\n//设置字符串\n- (void)setSomeString:(NSString*)someString {\n    dispatch_sync(_syncQueue, ^{\n        _someString = someString;\n    });\n}\n```\n\n这里，用了一个串行队列，保证了读写操作都加了锁，是一种解决方式。但是，我们要明确一点，数据的正确性主要取决于写入操作，只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。因此，我们要加以改进，读操作并行，写操作串行。可以通过  `dispatch_barrier_async`、`dispatch_barrier_sync` 完成。\n\n#### 将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\n在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行。并发队列如果发现接下来要处理的块是个栅栏块，那么就一直等到当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。**相当于给并行队列里加个锁**\n\n```objc\n_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//读取字符串\n- (NSString*)someString {\n    __block NSString *localSomeString;\n    dispatch_sync(_syncQueue, ^{\n       localSomeString = _someString;\n    });\n    return localSomeString;\n}\n\n//设置字符串\n- (void)setSomeString:(NSString*)someString {\n\n    dispatch_barrier_async(_syncQueue, ^{\n        _someString = someString;\n    });\n}\n```\n\n这里解释下为什么读取用的是 `sync`，写入用的是 `async`，因为读取是要有返回值的，要将值返回给调用的对象，总不能还没有拿到值，就已经 `return` 了吧；而写入操作没有返回值，那么就让它立即 `return` 执行后面的代码，另开线程写入。\n\n### 第42条：多用GCD，少用performSelector系列方法\n在iOS开发中，有时会使用 `performSelector` 来执行某个方法，但是 `performSelector` 系列的方法能处理的选择子很局限，最好使用 GCD：\n- 它无法处理带有多个参数的选择子（有最多支持两个选择子的方法）\n- 返回值只能是void或者对象类型\n- 会引起内存泄露\n\n但是如果将方法放在块中，通过 GCD 来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 `performSelector` 方法。\n\n#### 延后执行某个任务的方法\n```objc\n// 使用 performSelector:withObject:afterDelay:\n[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];\n\n\n// 使用 dispatch_after\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));\ndispatch_after(time, dispatch_get_main_queue(), ^(void){\n    [self doSomething];\n});\n```\n\n#### 将任务放在主线程执行\n```\n// 使用 performSelectorOnMainThread:withObject:waitUntilDone:\n[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];\n\n\n// 使用 dispatch_async\n// (or if waitUntilDone is YES, then dispatch_sync)\ndispatch_async(dispatch_get_main_queue(), ^{\n        [self doSomething];\n});\n```\n\n如果 `waitUntilDone` 的参数是 `Yes`，那么就对应 GCD 的 `dispatch_sync` 方法。我们可以看到，使用 GCD 的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。\n\n### 第43条：掌握GCD及操作队列的使用时机\n除了 GCD，**操作队列（NSOperationQueue）**也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用 GCD 好些，有时则是使用操作队列更加合理。（并不清楚操作队列怎么用的，反正就抄一下哪里好）\n\n- 可以取消操作：在运行任务前，可以在NSOperation对象调用 `cancel` 方法，标明此任务不需要执行。但是 GCD 队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。\n- 可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。\n- 监控 `NSOperation` 对象的属性：可以通过 KVO 来监听 `NSOperation` 的属性：可以通过 `isCancelled` 属性来判断任务是否已取消；通过 `isFinished` 属性来判断任务是否已经完成。\n- 可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。\n\n### 第44条：通过Dispath Group机制，根据系统资源状况来执行任务\n有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用 `dispath group` 函数来实现这个需求：\n\n通过 `dispath group` 函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。\n\n```objc\n//一个优先级低的并发队列\ndispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n\n//一个优先级高的并发队列\ndispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//创建dispatch_group\ndispatch_group_t dispatchGroup = dispatch_group_create();\n\n//将优先级低的队列放入dispatch_group\nfor (id object in lowPriorityObjects) {\n dispatch_group_async(dispatchGroup,lowPriorityQueue,^{ [object performTask]; });\n}\n\n//将优先级高的队列放入dispatch_group\nfor (id object in highPriorityObjects) {\n dispatch_group_async(dispatchGroup,highPriorityQueue,^{ [object performTask]; });\n}\n\n//dispatch_group里的任务都结束后调用块中的代码\ndispatch_queue_t notifyQueue = dispatch_get_main_queue();\ndispatch_group_notify(dispatchGroup,notifyQueue,^{\n     // Continue processing after completing tasks\n});\n```\n\n想要更详细的了解，还是看之前的 GCD 介绍文章吧。\n\n### 第45条：使用dispatch_once来执行只需运行一次的线程安全代码\n有时我们可能只需要将某段代码执行一次，这时可以通过 `dispatch_once` 函数来解决。\n\n`dispatch_once` 函数比较重要的使用例子是单例模式：\n我们在创建单例模式的实例时，可以使用 `dispatch_once` 函数来令初始化代码只执行一次，并且内部是线程安全的。\n\n而且，对于执行一次的 `block` 来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在 `static` 或 `global` 作用域里。\n\n```objc\n+ (id)sharedInstance {\n     static EOCClass *sharedInstance = nil;\n     static dispatch_once_t onceToken;\n     dispatch_once(&onceToken, ^{\n﻿            sharedInstance = [[self alloc] init];\n    });\n     return sharedInstance;\n}\n```\n\n### 第46条：不要使用dispatch_get_current_queue\n已经被废弃的 API，不说了。\n\n## 系统框架\n### 第47条：熟悉系统框架\n主要的系统框架：\n- Foundation  :NSObject,NSArray,NSDictionary 等\n- CFoundation :C 语言 API，Foundation 框架中的许多功能，都可以在这里找到对应的 C 语言 API\n- CFNetwork   :C 语言 API，提供了 C 语言级别的网络通信能力 \n- CoreAudio   :C 语言 API，操作设备上的音频硬件\n- AVFoundation:提供的 OC 对象可以回放并录制音频和视频\n- CoreData    :OC 的 API，将对象写入数据库\n- CoreText    :C 语言 API，高效执行文字排版和渲染操作\n\n\n### 第48条：多用块枚举，少用for循环\n#### 传统的for遍历\n```objc\nNSArray *anArray = /* ... */;\nfor (int i = 0; i < anArray.count; i++) {\n   id object = anArray[i];\n   // Do something with 'object'\n}\n\n\n\n// Dictionary\nNSDictionary *aDictionary = /* ... */;\nNSArray *keys = [aDictionary allKeys];\nfor (int i = 0; i < keys.count; i++) {\n   id key = keys[i];\n   id value = aDictionary[key];\n   // Do something with 'key' and 'value'\n}\n\n\n// Set\nNSSet *aSet = /* ... */;\nNSArray *objects = [aSet allObjects];\nfor (int i = 0; i < objects.count; i++) {\n   id object = objects[i];\n   // Do something with 'object'\n\n}\n```\n\n我们可以看到，在遍历 NSDictionary,和 NSet 时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。\n\n#### 利用快速遍历\n```objc\nNSArray *anArray = /* ... */;\nfor (id object in anArray) {\n // Do something with 'object'\n}\n\n// Dictionary\nNSDictionary *aDictionary = /* ... */;\nfor (id key in aDictionary) {\n id value = aDictionary[key];\n // Do something with 'key' and 'value'\n\n}\n\n\nNSSet *aSet = /* ... */;\nfor (id object in aSet) {\n // Do something with 'object'\n}\n```\n\n这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。\n\n#### 利用基于块（block）的遍历\n其实我觉得没啥用，不看也罢。\n\n### 第49条：对自定义其内存管理语义的collection使用无缝桥接\n通过无缝桥接技术，可以在 Foundation 框架中的 OC 对象和 CoreFoundation 框架中的 C 语言数据结构之间来回转换。\n\n为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。\n\n具体怎么用，用在什么场景呢？ 没看懂。呵呵\n\n### 第50条：构建缓存时选用 NSCache 而非 NSDictionary\n不知道有啥用，用到时候再说。\n\n### 第51条: 精简initialize 与 load的实现代码\n每个类和分类在**加入运行期系统时**，都会调用 `load` 方法，而且仅仅调用一次。`load` 方法不遵循继承规则，某个类本身没有重写 `load`，那也不会调用超类的 `load` 方法。可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。\n\n`initialize` 方法与 `load` 方法类似，区别是这个方法会在程序首次调用这个类的时候调用（**惰性调用**），而且只调用一次（绝对不能主动使用代码调用）。如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。如果在 `initialize` 方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在 `initialize` 方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的 bug。\n\n### 第52条: 别忘了NSTimer会保留其目标对象\n在使用 `NSTimer` 的时候，`NSTimer` 会生成指向其使用者的引用，而其使用者如果也引用了 `NSTimer`，那么就会生成保留环。\n\n```objc\n#import <Foundation/Foundation.h>\n\n@interface EOCClass : NSObject\n- (void)startPolling;\n- (void)stopPolling;\n@end\n\n\n@implementation EOCClass {\n     NSTimer *_pollTimer;\n}\n\n\n- (id)init {\n     return [super init];\n}\n\n\n- (void)dealloc {\n    [_pollTimer invalidate];\n}\n\n\n- (void)stopPolling {\n\n    [_pollTimer invalidate];\n    _pollTimer = nil;\n}\n\n\n- (void)startPolling {\n   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0\n                                                 target:self\n                                               selector:@selector(p_doPoll)\n                                               userInfo:nil\n                                                repeats:YES];\n}\n\n- (void)p_doPoll {\n    // Poll the resource\n}\n\n@end\n```\n\n这里可以看到 `EOCClass` 和 `_pollTimer` 之间由于 `target:self` 的存在，相互形成了保留环，如果不主动调用 `stopPolling` 方法将 `_pollTimer`取消并清空就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。这可能是一个极其危险的情况，因为 NSTimer 没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。\n\n那么如何解决呢？\n\n我觉得文章里举的方法简直脱裤子放屁，所以就不列出来了。直接将 `target:self` 设置成 `target:weakSelf` 不就行了？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Effective_oc2笔记","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dom000d7hzgbmur3srv","content":"<p>拜读一下 Effective Objective-C 这本书，做一些笔记</p>\n<a id=\"more\"></a>\n<h2 id=\"熟悉OC\"><a href=\"#熟悉OC\" class=\"headerlink\" title=\"熟悉OC\"></a>熟悉OC</h2><h3 id=\"第1条：了解Objective-C的起源\"><a href=\"#第1条：了解Objective-C的起源\" class=\"headerlink\" title=\"第1条：了解Objective-C的起源\"></a>第1条：了解Objective-C的起源</h3><p>对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由<strong>运行期组件（runtime component）</strong>完成，使用 Objective-C 的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。</p>\n<p>运行期组件本质上是一种与开发者所编写的代码相链接的<strong>动态库（dynamic library）</strong>，其代码能把开发者所编写的所有程序粘合起来。</p>\n<h3 id=\"第2条：-在类的头文件中尽量少引用其他头文件\"><a href=\"#第2条：-在类的头文件中尽量少引用其他头文件\" class=\"headerlink\" title=\"第2条： 在类的头文件中尽量少引用其他头文件\"></a>第2条： 在类的头文件中尽量少引用其他头文件</h3><p>有时，类A需要将类B的实例变量作为它公共 API 的属性。这个时候，我们不应该引入类B的头文件，而应该使用<strong>向前声明（forward declaring）</strong> 使用 <code>@class</code> 关键字，并且<strong>在 A 的实现文件引用 B 的头文件</strong>。(继承或者协议必须引入完整头文件，不能使用向前声明)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EOCPerson.h</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">EOCEmployer</span>;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) EOCEmployer *employer;<span class=\"comment\">//将EOCEmployer作为属性</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// EOCPerson.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCEmployer.h\"</span></span></div></pre></td></tr></table></figure>\n<p>这样做有什么优点呢：</p>\n<ol>\n<li>不在A的头文件中引入B的头文件，那么A的实现文件引入A的头文件时，就不会一并引入B的全部内容，这样就减少了编译时间。只有在A的实现里需要用到B时，再在A的实现里引用B的头文件。</li>\n<li>使用 <code>#import</code> 而不是 <code>#include</code> 可以避免死循环，但仍会导致相互引用的两个类中的一哥无法正确编译。使用 <code>@class</code> 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>\n</ol>\n<h3 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h3><p>声明时多用字面量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSNumber</span> *intNumber = @<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *floatNumber = @<span class=\"number\">2.5</span>f;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *animals =@[<span class=\"string\">@\"cat\"</span>, <span class=\"string\">@\"dog\"</span>,<span class=\"string\">@\"mouse\"</span>, <span class=\"string\">@\"badger\"</span>];</div><div class=\"line\">Dictionary *dict = @&#123;<span class=\"string\">@\"animal\"</span>:<span class=\"string\">@\"tiger\"</span>,<span class=\"string\">@\"phone\"</span>:<span class=\"string\">@\"iPhone 6\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> *cat = animals[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"built_in\">NSString</span> *iphone = dict[<span class=\"string\">@\"phone\"</span>];</div></pre></td></tr></table></figure>\n<p>少用 <code>alloc</code>、<code>init</code> 的方式创建，以及 <code>objectAtIndex</code>、<code>objectForKey</code> 的方式取数组字典。</p>\n<p>优点：</p>\n<ol>\n<li>简洁</li>\n<li><code>NSArray</code> 以 <code>nil</code> 结尾，所以一般不允许数组中的元素为 <code>nil</code>，如果使用等价方法，那么数组元素为 <code>nil</code> 不报错，会出现难以排查的错误；而同样的情况，字面量语法会抛出异常。</li>\n</ol>\n<h3 id=\"第4条：多用类型常量，少用-define预处理命令\"><a href=\"#第4条：多用类型常量，少用-define预处理命令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理命令\"></a>第4条：多用类型常量，少用#define预处理命令</h3><p>预处理与类型常量的优缺点：</p>\n<ul>\n<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>\n<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>\n</ul>\n<h4 id=\"预处理命令\"><a href=\"#预处理命令\" class=\"headerlink\" title=\"预处理命令\"></a>预处理命令</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define W_LABEL (W_SCREEN - 2*GAP)</span></div></pre></td></tr></table></figure>\n<p>这里，<code>(W_SCREEN - 2*GAP)</code> 替换了 <code>W_LABEL</code>，它不具备 <code>W_LABEL</code> 的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。</p>\n<h4 id=\"类型常量\"><a href=\"#类型常量\" class=\"headerlink\" title=\"类型常量\"></a>类型常量</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">NSTimeIntervalDuration</span> = <span class=\"number\">0.3</span>;</div></pre></td></tr></table></figure>\n<p><code>const</code> 将其设置为常量，不可更改。<code>static</code> 意味着该变量仅仅在定义此变量的编译单元(<code>.m</code> 实现文件)中可见。如果不声明 <code>static</code>,编译器会为它创建一个<strong>外部符号（external symbol）</strong>。会出现什么问题呢？如果在其他类中也声明了同名变量，即使没有相互引用，编译器也会抛出一个异常。</p>\n<h4 id=\"全局常量\"><a href=\"#全局常量\" class=\"headerlink\" title=\"全局常量\"></a>全局常量</h4><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量，即全局常量。在头文件中声明外部常量，在实现文件中完成变量的赋值。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//header file</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> NotificationString;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//implementation file</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span>  NotificationString = <span class=\"string\">@\"Finish Download\"</span>;</div></pre></td></tr></table></figure>\n<p>注意这里的 <code>const</code>, 如果在 <code>*</code> 前面，表示指针指向的堆上的内容不能改变，如果在 <code>*</code> 后面，表示指针指向的地址是不能改变的。（这里有个助记方法，以 <code>*</code> 为分解，<code>const</code> 在左边就是修饰 <code>NSString</code>，表示不能修改值，在右边就表示修饰指针对象，表示不能修改指针指向的地址。）</p>\n<h3 id=\"第5条：用枚举表示状态，选项，状态码\"><a href=\"#第5条：用枚举表示状态，选项，状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态，选项，状态码\"></a>第5条：用枚举表示状态，选项，状态码</h3><p>我们经常需要给类定义几个状态，这些状态码可以用枚举来管理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EOCConnectionState) &#123;</div><div class=\"line\">  EOCConnectionStateDisconnected,</div><div class=\"line\">  EOCConnectionStateConnecting,</div><div class=\"line\">  EOCConnectionStateConnected,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTION</span>(<span class=\"built_in\">NSUInteger</span>, EOCPermittedDirection) &#123;</div><div class=\"line\">\tEOCPermittedDirectionUp    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">\tEOCPermittedDirectionDown  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">\tEOCPermittedDirectionLeft  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">\tEOCPermittedDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>NS_ENUM</code> 和 <code>NS_OPTION</code> 是 Foundation 框架中定义的辅助宏。需要注意这两者使用场景的不同。</p>\n<p>在枚举类型的 switch 语句中不要实现 default 分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch 语句并未处理所有的枚举。否则添加了枚举却没有实现 switch 将可能导致严重的崩溃。</p>\n<h2 id=\"对象、消息、运行期\"><a href=\"#对象、消息、运行期\" class=\"headerlink\" title=\"对象、消息、运行期\"></a>对象、消息、运行期</h2><h3 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>在 Java 以及 C++ 中，对象布局在编译期就已经固定了。只要访问变量的代码，编译器就会把其替换成为“偏移量”。这个偏移量是<strong>硬编码（hardcode）</strong>，表示该对象距离存放对象的内存区域的起始地址有多远。这样做的问题是，如果再添加一个实例变量，那么其他实例变量的就要变化了，那么就要重新编译，否则就会出错。</p>\n<p>Objective-C 的做法是，把实例变量当做一种存储偏移量所用的<strong>“特殊变量”（special variable）</strong>，交由<strong>“类对象”（class object）</strong>保管。偏移量会在运行期查找，那么类的定义变了，存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。</p>\n<h4 id=\"存取方法\"><a href=\"#存取方法\" class=\"headerlink\" title=\"存取方法\"></a>存取方法</h4><p>在设置完属性后，编译器会自动向类中添加适当类型的实例变量，并且为其写出一套存取方法。访问属性，可以使用点语法，编译器会把点语法转换为对存取方法的调用；也可直接使用实例变量，使用实例变量的方式更快。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//存取方法设置属性</span></div><div class=\"line\"><span class=\"keyword\">self</span>.firstName = <span class=\"string\">@\"Zachary\"</span>;</div><div class=\"line\"><span class=\"comment\">//实例变量设置属性</span></div><div class=\"line\">_firstName = <span class=\"string\">@\"Zachary\"</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"属相特质\"><a href=\"#属相特质\" class=\"headerlink\" title=\"属相特质\"></a>属相特质</h4><p>原子性：</p>\n<ul>\n<li>nonatomic：不使用同步锁</li>\n<li>atomic：加同步锁，确保其原子性</li>\n</ul>\n<p>读写:</p>\n<ul>\n<li>readwrite:同时存在存取方法</li>\n<li>readonly:只有获取方法</li>\n</ul>\n<p>内存管理:</p>\n<ul>\n<li>assign:纯量类型(scalar type)的简单赋值操作</li>\n<li>strong:拥有关系保留新值，释放旧值，再设置新值</li>\n<li>weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</li>\n<li>copy：当赋给其可变对象，返回不可变对象；当赋给其不可变对象，返回原对象。</li>\n</ul>\n<h3 id=\"第7条：-在对象内部尽量直接访问实例变量\"><a href=\"#第7条：-在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条： 在对象内部尽量直接访问实例变量\"></a>第7条： 在对象内部尽量直接访问实例变量</h3><p>关于实例变量的访问，可以直接访问 <code>_firstName</code>，也可以通过属性的方式(点语法) <code>self.firstName</code> 来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。（这部分比较重要）</p>\n<p>直接访问实例变量的特点：</p>\n<ul>\n<li>不经过<strong>“方法派发”(method dispatch)</strong>，会直接访问保存对象实例变量的那块内存，速度快。</li>\n</ul>\n<p>通过属性访问实例变量的特点：</p>\n<ul>\n<li>不会绕过属性定义的<strong>内存管理语义</strong>。其实也就是说，编译期在设置 set 方法的时候，会根据属性特质做一些操作。比如一个声明为 <code>copy</code> 的属性，如果直接访问实例变量，那么这个实例变量就会直接指向堆中的对象；而如果通过属性来操作，就会先将堆中的对象 copy 一份，然后将实例变量指向 copy 出来的对象。</li>\n<li>可以触发KVO</li>\n</ul>\n<p>不过有两个特例：</p>\n<ol>\n<li><code>init</code> 方法和 <code>dealloc</code> 方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作(比如上面说的<strong>内存管理语义</strong>所要进行的操作)。</li>\n<li>如果使用<strong>懒加载</strong>的获取方法要用属性的方式获取。</li>\n</ol>\n<p>其实，到底用什么很简单，如果 get，set 方法里没有其他的乱七八糟的东西，比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)firstName&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _firstName;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) setFirstName:(<span class=\"built_in\">NSString</span> *)firstName&#123;</div><div class=\"line\">\t_firstName = firstName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种，那就直接用实例变量操作了，用属性就是多此一举；如果有乱七八糟的东西，那么就要用属性的方式。</p>\n<h3 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h3><p><code>NSObject</code> 类中有两个用于判断等同性的方法：</p>\n<ul>\n<li><code>- (BOOL)isEqual:(id)object;</code></li>\n<li><code>- (NSUInteger)hash;</code></li>\n</ul>\n<p><code>NSObject</code> 类中默认的实现是：当且仅当其内存地址完全相等时，两个对象才相等。自定义对象中可以覆写这两个方法（其实好像没必要重写 hash 方法，因为我们重写的 <code>isEqual:</code> 方法里根本没有用到 hash 方法，重写了也没啥用），完成自己的相等判断。如果 <code>isEqual:</code> 方法判断对象相等，那么其 hash 方法也必须返回同一个值；反之，如果 hash 方法返回了同一个值，<code>isEqual:</code> 方法未必认为两者相等。</p>\n<p>如果已知两个对象是字符串，最好通过 <code>isEqualToString:</code> 方法来比较。对于数组和字典，也有 <code>isEqualToArray:</code> 方法和 <code>isEqualToDictionary:</code>方法。</p>\n<p>如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的 <code>isEqual:</code> 方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqualToPerson:(EOCPerson*)otherPerson &#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//先比较对象类型，然后比较每个属性</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == object) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (![_firstName isEqualToString:otherPerson.firstName])</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (![_lastName isEqualToString:otherPerson.lastName])</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (_age != otherPerson.age)</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqual:(<span class=\"keyword\">id</span>)object &#123;</div><div class=\"line\">    <span class=\"comment\">//如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法</span></div><div class=\"line\">     <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] == [object <span class=\"keyword\">class</span>]) &#123;    </div><div class=\"line\">         <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> isEqualToPerson:(EOCPerson*)object];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">         <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> isEqual:object];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第9条-以“类族模式“隐藏实现细节\"><a href=\"#第9条-以“类族模式“隐藏实现细节\" class=\"headerlink\" title=\"第9条 以“类族模式“隐藏实现细节\"></a>第9条 以“类族模式“隐藏实现细节</h3><p>其实就是通过抽象类完成工厂模式。</p>\n<p>例如,对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCEmployee.h</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EOCEmployeeType) &#123;</div><div class=\"line\">    EOCEmployeeTypeDeveloper,</div><div class=\"line\">    EOCEmployeeTypeDesigner,</div><div class=\"line\">    EOCEmployeeTypeFinance,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployee</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> salary;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Helper for creating Employee objects</span></div><div class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Make Employees do their respective day's work</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCEmployee.m</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployee</span></span></div><div class=\"line\"></div><div class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</div><div class=\"line\">     <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">         <span class=\"keyword\">case</span> EOCEmployeeTypeDeveloper:</div><div class=\"line\">            <span class=\"keyword\">return</span> [EOCEmployeeDeveloper new];</div><div class=\"line\">         <span class=\"keyword\">break</span>; </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeDesigner:</div><div class=\"line\">             <span class=\"keyword\">return</span> [EOCEmployeeDesigner new];</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeFinance:</div><div class=\"line\">             <span class=\"keyword\">return</span> [EOCEmployeeFinance new];</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork &#123;</div><div class=\"line\"> <span class=\"comment\">// 需要子类来实现</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployeeDeveloper</span> : <span class=\"title\">EOCEmployee</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployeeDeveloper</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> writeCode];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，表面上对象是 <code>EOCEmployee</code>，但是实际上操作的是 <code>EOCEmployeeDeveloper</code>。</p>\n<p>这里需要注意一点：对于这种类族，不能通过以下方式判断：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ([employeeDeveloper <span class=\"keyword\">class</span>] == [EOCEmployee <span class=\"keyword\">class</span>])&#123;</div><div class=\"line\">\t<span class=\"comment\">// will do</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为 <code>employeeDeveloper</code> 对象是 <code>EOCEmployee</code> 类的一个子集，需要使用 <code>isKindOfClass:</code> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ([employeeDeveloper isKindOfClass:[EOCEmployee <span class=\"keyword\">class</span>]])&#123;</div><div class=\"line\">\t<span class=\"comment\">// will do</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h3><p>这一条和 runtime 息息相关。背景是，我们可以通过 category 为系统类添加方法，但是无法添加属性。当需要为系统类添加属性时，可以使用下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//为某个对象设置关联对象的值，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义</span></div><div class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//根据给定的键从某对象中获取相应的关联对象值</span></div><div class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移除指定对象的关联对象</span></div><div class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObjects(<span class=\"keyword\">id</span> object)</div></pre></td></tr></table></figure>\n<p>这里要强调的是，要拿到设置的属性，键必须要完全相等。因此，需要设置成静态全局变量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</div></pre></td></tr></table></figure>\n<h3 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime</a>中已经写得很详细了，参见就行了。</p>\n<h3 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/23/runtime应用/\">runtime</a>中已经写得很详细了，参见就行了。</p>\n<h3 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/23/runtime应用/\">runtime</a>中也介绍了。</p>\n<h3 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime</a>中也介绍了。</p>\n<h2 id=\"接口与API设计\"><a href=\"#接口与API设计\" class=\"headerlink\" title=\"接口与API设计\"></a>接口与API设计</h2><h3 id=\"第15条：用前缀-避免命名空间冲突\"><a href=\"#第15条：用前缀-避免命名空间冲突\" class=\"headerlink\" title=\"第15条：用前缀 避免命名空间冲突\"></a>第15条：用前缀 避免命名空间冲突</h3><p>Apple 宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。</p>\n<h3 id=\"第16条：提供”全能初始化方法”\"><a href=\"#第16条：提供”全能初始化方法”\" class=\"headerlink\" title=\"第16条：提供”全能初始化方法”\"></a>第16条：提供”全能初始化方法”</h3><p>所谓全能初始化方法，就是所有初始化方法都要调用的初始化方法。这个初始化方法初始化方法是初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。</p>\n<p>算是一种写代码的技巧吧。平时写代码的时候也都是这样的，不具体说明了。</p>\n<h3 id=\"第17条：实现description方法\"><a href=\"#第17条：实现description方法\" class=\"headerlink\" title=\"第17条：实现description方法\"></a>第17条：实现description方法</h3><p>自定义的类调用 <code>NSLog();</code> 的时候，往往不能返回想要的结果。需要重写 <code>NSObject</code> 类中的 <code>description</code> 方法，返回需要的字符串。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)description &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"&lt;%@: %p, %@ %@&gt;\"</span>, [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">self</span>, firstName, lastName];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>%p</code> 表示对象的内存地址。</p>\n<h3 id=\"第18条：尽量使用不可变对象\"><a href=\"#第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"第18条：尽量使用不可变对象\"></a>第18条：尽量使用不可变对象</h3><p>尽量使用不可变对象。没啥可说的。<br>里面推荐的方法没用过，感觉并不好，就不写了。</p>\n<h3 id=\"第19条：使用清晰而协调的命名方式\"><a href=\"#第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"第19条：使用清晰而协调的命名方式\"></a>第19条：使用清晰而协调的命名方式</h3><p>没啥好说的，注意就好</p>\n<h3 id=\"第20条：为私有方法名加前缀\"><a href=\"#第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"第20条：为私有方法名加前缀\"></a>第20条：为私有方法名加前缀</h3><p>建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCObject</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)publicMethod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)publicMethod &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)p_privateMethod &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>很有用的建议，注意不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。</p>\n<h3 id=\"第21条：理解Objective-C错误类型\"><a href=\"#第21条：理解Objective-C错误类型\" class=\"headerlink\" title=\"第21条：理解Objective-C错误类型\"></a>第21条：理解Objective-C错误类型</h3><p>OC 中仅在及其严重的错误情况下抛出异常。比如一个抽象基类。由于 OC 中没办法将某个类标识为抽象类。如果想要实现抽象类的功能，那么就要在必须要覆写的方法里抛出异常：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)mustOverrideMethod&#123;</div><div class=\"line\">\t<span class=\"built_in\">NSString</span> *reason = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@ must be overridden\"</span>, <span class=\"built_in\">NSStringFromeSelector</span>(_cmd)];</div><div class=\"line\">\t<span class=\"keyword\">@throw</span> [<span class=\"built_in\">NSException</span> exceptionWithName:<span class=\"built_in\">NSInternalInconsistencyException</span></div><div class=\"line\">\t\t\t\t\t\t\t\t\t    reason:reason</div><div class=\"line\">\t\t\t\t\t\t\t\t\t  userInfo:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于不严重的异常，可以使用返回 <code>nil</code> 或者 <code>NSError</code> 的方式(其实也没啥用，这些都是手动设置的，我都知道哪里会出现问题了，还要新建 <code>NSError</code> 对象干嘛(可能我的理解有偏差))。</p>\n<h3 id=\"第22条：理解NSCopying协议\"><a href=\"#第22条：理解NSCopying协议\" class=\"headerlink\" title=\"第22条：理解NSCopying协议\"></a>第22条：理解NSCopying协议</h3><h4 id=\"自定义拷贝\"><a href=\"#自定义拷贝\" class=\"headerlink\" title=\"自定义拷贝\"></a>自定义拷贝</h4><p>如果我们想令自己的类支持拷贝操作，那就要实现 <code>NSCopying</code> 协议，该协议只有一个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span>*)zone</div></pre></td></tr></table></figure>\n<p>比如要拷贝一个 <code>EOCPerson</code> 对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span>*)zone &#123;</div><div class=\"line\">     EOCPerson *<span class=\"keyword\">copy</span> = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];</div><div class=\"line\">    <span class=\"keyword\">copy</span>-&gt;_friends = [_friends mutableCopy];</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">copy</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">这里面的 `<span class=\"built_in\">NSZone</span> *zone` 对象不用在意是什么，现在已经没用了。其实也就是新建一个 `EOCPerson` 对象，然后调用它的构造函数把东西全都塞进去。这里的 `-&gt;` 用箭头是因为定义的时候这个 `_friends` 不是一个属性(代码没有贴出来，详见书)，而只是在实现文件中定义的一个实例变量，没有 get/set 方法，所以不能用 `.` </div><div class=\"line\"></div><div class=\"line\">这里的 `mutableCopy` 方法也可以自定义，就是下面方法的实现 </div><div class=\"line\">```objc</div><div class=\"line\">- (<span class=\"keyword\">id</span>)mutableCopyWithZone:(<span class=\"built_in\">NSZone</span>*)zone；</div></pre></td></tr></table></figure>\n<h4 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h4><p>浅拷贝和深拷贝应该并不陌生。浅拷贝只增加引用计数，深拷贝将创建另一个一模一样的对象。</p>\n<ul>\n<li>不可变对象的 <code>copy</code> 是浅拷贝。</li>\n<li>可变对象的 <code>copy</code> 是深拷贝，返回不可变对象。</li>\n<li>不可变对象的 <code>mutableCopy</code> 是深拷贝，返回可变对象。</li>\n<li>可变对象的 <code>mutableCopy</code> 是浅拷贝。</li>\n</ul>\n<p>容器对象(<code>NSArray</code>)本身也遵循上面的规则。但是需要注意的是，<strong>容器对象内的元素是浅拷贝</strong>。因此上面的自定义 copy 方法如果想让 <code>_friends</code> 内的元素深拷贝，就不能用 <code>[_friends mutableCopy]</code> 方法，需要新建一个 Set:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)deepCopy &#123;</div><div class=\"line\">   EOCPerson *<span class=\"keyword\">copy</span> = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] alloc] initWithFirstName:_firstName andLastName:_lastName];</div><div class=\"line\">\t<span class=\"keyword\">copy</span>-&gt;_friends = [[<span class=\"built_in\">NSMutableSet</span> alloc] initWithSet:_friends copyItems:<span class=\"literal\">YES</span>];</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">copy</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"协议与分类\"><a href=\"#协议与分类\" class=\"headerlink\" title=\"协议与分类\"></a>协议与分类</h2><h3 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h3><p>其实也是老生常谈的东西了，不过也有一些注意点。</p>\n<p>受代理对象内持有代理对象的实例时要写成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;NetworkDelegate&gt; delegate;</div></pre></td></tr></table></figure>\n<p>这里书中指明了要用 <code>weak</code>，不能用 <code>strong</code>，否则会引起引用循环。比如系统中的 <code>TableViewCellDelegate</code>，在 <code>TableViewController</code> 作为代理类确实拥有被代理对象 <code>TableViewCell</code>，用 <code>weak</code> 确实是合理的，但是所有情况都这样吗？不知道，不过确实基本上的代理对象都是 <code>ViewController</code>，所以用 <code>weak</code> 肯定是不会有问题的。</p>\n<p>实现委托对象的方法是声明某个类遵从委托协议：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCDataModel</span> () &lt;<span class=\"title\">EOCNetworkFetcherDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCDataModel</span></span></div><div class=\"line\"><span class=\"comment\">// 各个实现方法</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>基本所有的 Delegate 都在 <code>.m</code> 文件中的类拓展中声明，之前一直没有留意，看了书后才问自己，为什么不在 <code>.h</code> 中声明？两者有什么差别吗？其实也没什么差别，在实现文件中声明的好处是能隐藏细节。如果只是自己用可能没什么区别，但是如果打包给别人用，那么就不应该让别人看到你的实现细节了，因此，就把这个 Delegate 的声明放到了实现文件中。<br>好吧。一个简单的道理。只是我一开始没想明白。</p>\n<h3 id=\"第24条：将类的实现代码分散到便于管理的数个分类中\"><a href=\"#第24条：将类的实现代码分散到便于管理的数个分类中\" class=\"headerlink\" title=\"第24条：将类的实现代码分散到便于管理的数个分类中\"></a>第24条：将类的实现代码分散到便于管理的数个分类中</h3><p>当一个类越来越大时，就变得不利于管理，因此需要将类代码按照逻辑划分入几个分区中，可以通过范畴的方式实现。书中有一个例子：</p>\n<p>无分类:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithFirstName:(<span class=\"built_in\">NSString</span>*)firstName andLastName:(<span class=\"built_in\">NSString</span>*)lastName;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Friendship methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Work methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)performDaysWork;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)takeVacationFromWork;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Play methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToTheCinema;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToSportsGame;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>分类后:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithFirstName:(<span class=\"built_in\">NSString</span>*)firstName</div><div class=\"line\"></div><div class=\"line\">andLastName:(<span class=\"built_in\">NSString</span>*)lastName;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Work</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)performDaysWork;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)takeVacationFromWork;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Play</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToTheCinema;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToSportsGame;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>如果觉得写在一个实现文件中太长了，可以拆开，比如将其中的 <code>Friendship</code> 拆开。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EOCPerson+Friendship.h</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// EOCPerson+Friendship.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCPerson+Friendship.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>不过要注意，在新建分类文件时，一定要引入被分类的类文件。</p>\n<p>这个技巧说有用也有用，说没用，也没用，看具体实际情况吧。另外，还有一个技巧是将所有”私有”方法都归入名叫 Private 的分类中，以隐藏实现细节，好像是个挺有意思的想法。</p>\n<h3 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h3><p>如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。否则可能会替换掉系统的方法。</p>\n<h3 id=\"第26条-勿在分类中声明属性\"><a href=\"#第26条-勿在分类中声明属性\" class=\"headerlink\" title=\"第26条:勿在分类中声明属性\"></a>第26条:勿在分类中声明属性</h3><p>这本书要是早点看到就好了，当时纠结这个很久，走了很多弯路。</p>\n<p>分类机制，目标在于扩展类的功能，而不是封装数据。</p>\n<h3 id=\"第27条：使用class-continuation分类-隐藏实现细节\"><a href=\"#第27条：使用class-continuation分类-隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用class-continuation分类 隐藏实现细节\"></a>第27条：使用class-continuation分类 隐藏实现细节</h3><p>通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用 class-continuation 分类的特性来补偿：</p>\n<ul>\n<li>可以在 class-continuation 分类中增加实例变量。</li>\n<li>可以在 class-continuation 分类中将公共接口的只读属性设置为读写。</li>\n<li>可以在 class-continuation 分类中遵循协议，使其不为人知。</li>\n</ul>\n<h3 id=\"第28条-通过协议提供匿名对象\"><a href=\"#第28条-通过协议提供匿名对象\" class=\"headerlink\" title=\"第28条:通过协议提供匿名对象\"></a>第28条:通过协议提供匿名对象</h3><p>OC 里的<strong>匿名对象</strong>和 Java 里的匿名对象不同，这里的匿名对象没有类型。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。它的表示方法为：<code>id&lt;protocol&gt;</code>。</p>\n<p>通过协议提供匿名对象的主要使用场景有两个：</p>\n<ul>\n<li>作为属性</li>\n<li>作为方法参数</li>\n</ul>\n<h4 id=\"匿名对象作为属性\"><a href=\"#匿名对象作为属性\" class=\"headerlink\" title=\"匿名对象作为属性\"></a>匿名对象作为属性</h4><p>在设定某个类为自己的代理属性时，可以不声明代理的类，而是用 <code>id&lt;protocol&gt;</code>，因为成为代理的终点并不是某个类的实例，而是遵循了某个协议。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;EOCDelegate&gt; delegate;</div></pre></td></tr></table></figure>\n<p>在这里使用匿名对象的原因有两个：</p>\n<ol>\n<li>将来可能会有很多不同类的实例对象作为该类的代理。</li>\n<li>我们不想指明具体要使用哪个类来作为这个类的代理。</li>\n</ol>\n<p>也就是说，能作为该类的代理的条件只有一个：它遵从了 <code>&lt;EOCDelegate&gt;</code> 协议。</p>\n<h4 id=\"匿名对象作为方法参数\"><a href=\"#匿名对象作为方法参数\" class=\"headerlink\" title=\"匿名对象作为方法参数\"></a>匿名对象作为方法参数</h4><p>有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCopying</span>&gt;)key;</div></pre></td></tr></table></figure>\n<p>这个方法是 NSDictionary 的设值方法，它的参数只要遵从了 <code>&lt;NSCopying&gt;</code> 协议，就可以作为参数传进去,作为 NSDictionary 的键。</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h3 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h3><p>将对象放入自动释放池之后，不会马上使其引用计数 -1，而是在当前线程的下一次事件循环时递减。</p>\n<p>其他没什么好说的。</p>\n<h3 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h3><p>使用ARC，可以省略对于引用计数的操作，没太多好说的。</p>\n<p>需要了解一个修饰符 <code>__weak</code>。块内引用外部变量时，会自动保留其所捕获的全部对象，如果这其中有某个对象保留了块本身（如将 ViewController 传入），将会形成“保留环”。所以要用 <code>__weak</code> 局部变量来打破这种保留环。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">EOCNetwork * __<span class=\"keyword\">weak</span> weakFetcher = fetcher;</div></pre></td></tr></table></figure>\n<p>因此，我们可以定义一个 <code>weakSelf</code> 来简化这种声明方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WEAKSELF typeof(self) __weak weakSelf = self;</span></div></pre></td></tr></table></figure>\n<p>这样，在 ViewController 中用到 <code>self</code> 时，就可以直接用 <code>weakSelf</code> 替代。</p>\n<h3 id=\"第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"第31条：在dealloc方法中只释放引用并解除监听\"></a>第31条：在dealloc方法中只释放引用并解除监听</h3><p>对象在经历生命期后，最终会被系统回收，这里就是执行 <code>dealloc</code> 方法了。永远不要自己调用 <code>dealloc</code> 方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在 <code>dealloc</code> 方法中做一些操作。那么我们可以在 <code>dealloc</code> 方法里做什么呢？</p>\n<ul>\n<li>释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。</li>\n<li>对象拥有的其他非OC对象也要释放（CoreFoundation 对象就必须手动释放）</li>\n<li>释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。</li>\n</ul>\n<p>例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\">     <span class=\"built_in\">CFRelease</span>(coreFoundationObject);</div><div class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除了释放引用和注销通知，不要在 <code>dealloc</code> 中做其他任何事（比如调用属性的存取方法，以及异步操作）。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类要和使用者约定，用完资源后必须调用 <code>close</code> 方法。</p>\n<h3 id=\"第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"第32条：编写“异常安全代码”时留意内存管理问题\"></a>第32条：编写“异常安全代码”时留意内存管理问题</h3><p>在发生异常时的内存管理需要仔细考虑内存管理的问题：在 try 块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在 catch 块中能处理此问题，否则对象所占内存就将泄漏。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">     EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class=\"line\">     [object doSomethingThatMayThrow];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是在 ARC 状态下，我们不能手动释放对象，解决办法是使用：<code>-fobjc-arc-exceptions</code> 标志来让系统自动加入清理代码，不过会导致应用程序变大，而且会降低运行效率。</p>\n<h3 id=\"第33条：以弱引用避免保留环\"><a href=\"#第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"第33条：以弱引用避免保留环\"></a>第33条：以弱引用避免保留环</h3><p>对象之间都用强指针引用对方的话会造成保留环。如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。不像 Java 那种处理方式，OC 中孤立的保留环不能被自动释放。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/effective_oc1.png?raw=true\" alt=\"保留环\"></p>\n<p>那么就要用弱引用的方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCClassB.m</span></div><div class=\"line\"><span class=\"comment\">//第一种弱引用：unsafe_unretained</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">unsafe_unretained</span>) EOCClassA *other;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种弱引用：weak</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) EOCClassA *other;</div></pre></td></tr></table></figure>\n<p>这两种弱引用有什么区别呢？<br>当指向 <code>EOCClassA</code> 实例的引用移除后，<code>unsafe_unretained</code> 属性仍然指向那个已经回收的实例，而 <code>weak</code> 指向 <code>nil</code>。显然，用 <code>weak</code> 字段应该是更安全的，因为不再使用的对象按理说应该设置为 <code>nil</code>,而不应该产生依赖。</p>\n<p>所以只要用 <code>weak</code> 就行了。</p>\n<h3 id=\"第34条：以“自动释放池快”降低内存峰值\"><a href=\"#第34条：以“自动释放池快”降低内存峰值\" class=\"headerlink\" title=\"第34条：以“自动释放池快”降低内存峰值\"></a>第34条：以“自动释放池快”降低内存峰值</h3><p>这个部分在 <code>runloop</code> 相关文章中有学习过。主要用的是这样一个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span> doSomethingWithInt:i];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于线程自动释放池在 event loop 时，进行清空，上面的代码将可能造成内存峰值。因此，可以手动添加一个自动释放池，把循环内的代码包裹在内，那么循环中自动释放的独享就会在这个池中，而不是在线程的主池中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *databaseRecords = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span> *people = [<span class=\"built_in\">NSMutableArray</span> new];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *record <span class=\"keyword\">in</span> databaseRecords) &#123;</div><div class=\"line\">     <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class=\"line\">            [people addObject:person];</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"第35条：用“僵尸对象”调试内存管理问题\"></a>第35条：用“僵尸对象”调试内存管理问题</h3><p>某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。如果程序没有崩溃，可能是因为：</p>\n<ul>\n<li>该内存的部分原数据没有被覆写。</li>\n<li>该内存恰好被另一个对象占据，而这个对象可以应答这个方法。</li>\n</ul>\n<p>如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。因此，我们希望可以通过一种方法捕捉到对象被释放后收到消息的情况。这种方法就是利用僵尸对象！</p>\n<p>Cocoa 提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改 isa 指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。</p>\n<p>(感觉好像没什么用的样子，不知道这和让程序直接 crash 比，有什么优势)</p>\n<h3 id=\"第36条：不要使用retainCount\"><a href=\"#第36条：不要使用retainCount\" class=\"headerlink\" title=\"第36条：不要使用retainCount\"></a>第36条：不要使用retainCount</h3><p>ARC 后，这个 <code>retainCount</code> 方法就废弃了。反正从来没用过，也就没啥好看的了。</p>\n<h2 id=\"块与大小枢派发\"><a href=\"#块与大小枢派发\" class=\"headerlink\" title=\"块与大小枢派发\"></a>块与大小枢派发</h2><h3 id=\"第37条：理解“块”这一概念\"><a href=\"#第37条：理解“块”这一概念\" class=\"headerlink\" title=\"第37条：理解“块”这一概念\"></a>第37条：理解“块”这一概念</h3><p>基本概念无需多说，这里强调一下块的种类。</p>\n<p>块分为三类：</p>\n<ul>\n<li>栈块</li>\n<li>堆块</li>\n<li>全局块</li>\n</ul>\n<h4 id=\"栈块\"><a href=\"#栈块\" class=\"headerlink\" title=\"栈块\"></a>栈块</h4><p>这是比较容易被忽略的一块。定义块的时候，其所占内存区域是<strong>分配在栈中</strong>的，而且只在定义它的那个范围内有效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"comment\">/* some condition */</span> ) &#123;</div><div class=\"line\">    block = ^&#123;</div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block A\"</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    block = ^&#123;</div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block B\"</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">block();</div></pre></td></tr></table></figure>\n<p>上面定义的两个块只在 <code>if else</code> 语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。</p>\n<p>并不明白把块保存在栈上是个什么机制。应该可以这么理解吧:<code>block</code> 是一个指向栈上内存的指针，栈和堆的引用机制不同，在代码块运行结束后就会将代码块中的局部变量出栈，这个时候 <code>block</code> 指向的地方就被回收，<code>block</code> 就成了野指针，因此就会 crash 了。</p>\n<p>一般情况下，我们平时要么就定义完就传出去了，要么就把 <code>block</code> 定义成了类的属性，所以就没有发生过这种情况。 </p>\n<h4 id=\"堆块\"><a href=\"#堆块\" class=\"headerlink\" title=\"堆块\"></a>堆块</h4><p>平时对块的操作肯定不能以栈块的形式来存储啊。堆块，要在原来的基础上执行 <code>copy</code>，让代码保存在堆上。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"comment\">/* some condition */</span> ) &#123;</div><div class=\"line\">    block = [^&#123;</div><div class=\"line\">         <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block A\"</span>);</div><div class=\"line\">   &#125; <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    block = [^&#123;</div><div class=\"line\">         <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block B\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">block();</div></pre></td></tr></table></figure>\n<p>至于 <code>copy</code> 怎么让栈上的东西保存到堆上就不得而知了，反正就是保存过去了。然后 <code>block</code> 就能指向堆上的地址了。</p>\n<p>平时我们用属性方式保存块的时候都是这样声明的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) Block block;</div></pre></td></tr></table></figure>\n<p>这个属性里暗含了 <code>copy</code> 操作了。</p>\n<h4 id=\"全局块\"><a href=\"#全局块\" class=\"headerlink\" title=\"全局块\"></a>全局块</h4><p>在全局内存里声明的就是全局块，没用过。不知道有什么好处。</p>\n<h3 id=\"第38条：为常用的块类型创建typedef\"><a href=\"#第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"第38条：为常用的块类型创建typedef\"></a>第38条：为常用的块类型创建typedef</h3><p>如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (^variableName)(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value) =^(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value)&#123;</div><div class=\"line\">     <span class=\"comment\">// Implementation</span></div><div class=\"line\">     <span class=\"keyword\">return</span> someInt;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler: (<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSError</span> *error))completion;</div></pre></td></tr></table></figure>\n<p>这个块有一个 bool 参数和一个 int 参数，并返回 int 类型。我们可以给它定义类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(^EOCSomeBlock)(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value);</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCCompletionHandler)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSError</span> *error);</div><div class=\"line\"></div><div class=\"line\">EOCSomeBlock block = ^(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value)&#123;</div><div class=\"line\">     <span class=\"comment\">// Implementation</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCCompletionHandler)completion;</div></pre></td></tr></table></figure>\n<h3 id=\"第39条：用handler块降低代码分散程度\"><a href=\"#第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"第39条：用handler块降低代码分散程度\"></a>第39条：用handler块降低代码分散程度</h3><p>可以通过块的方式代替代理模式。</p>\n<p>代理模式主要是为了让其他类在必要时候调用自己类的方法。而使用块的方式可以直接将方法内容作为参数或者属性传入调用块。这样设计业务逻辑更加直观清晰。</p>\n<h3 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h3><p>注意使用块的时候不要产生保留环，要在块执行完成后，将块置为 <code>nil</code>。</p>\n<h3 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h3><p>多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用 GCD 来为代码加锁的方式解决这个问题。</p>\n<h4 id=\"方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\"><a href=\"#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\" class=\"headerlink\" title=\"方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\"></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">_syncQueue = dispatch_queue_create(<span class=\"string\">\"com.effectiveobjectivec.syncQueue\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取字符串</span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSString</span> *localSomeString;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">        localSomeString = _someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> localSomeString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置字符串</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">        _someString = someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里，用了一个串行队列，保证了读写操作都加了锁，是一种解决方式。但是，我们要明确一点，数据的正确性主要取决于写入操作，只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。因此，我们要加以改进，读操作并行，写操作串行。可以通过  <code>dispatch_barrier_async</code>、<code>dispatch_barrier_sync</code> 完成。</p>\n<h4 id=\"将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\"><a href=\"#将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\" class=\"headerlink\" title=\"将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\"></a>将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行</h4><p>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行。并发队列如果发现接下来要处理的块是个栅栏块，那么就一直等到当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。<strong>相当于给并行队列里加个锁</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取字符串</span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSString</span> *localSomeString;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">       localSomeString = _someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> localSomeString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置字符串</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\"></div><div class=\"line\">    dispatch_barrier_async(_syncQueue, ^&#123;</div><div class=\"line\">        _someString = someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里解释下为什么读取用的是 <code>sync</code>，写入用的是 <code>async</code>，因为读取是要有返回值的，要将值返回给调用的对象，总不能还没有拿到值，就已经 <code>return</code> 了吧；而写入操作没有返回值，那么就让它立即 <code>return</code> 执行后面的代码，另开线程写入。</p>\n<h3 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h3><p>在iOS开发中，有时会使用 <code>performSelector</code> 来执行某个方法，但是 <code>performSelector</code> 系列的方法能处理的选择子很局限，最好使用 GCD：</p>\n<ul>\n<li>它无法处理带有多个参数的选择子（有最多支持两个选择子的方法）</li>\n<li>返回值只能是void或者对象类型</li>\n<li>会引起内存泄露</li>\n</ul>\n<p>但是如果将方法放在块中，通过 GCD 来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 <code>performSelector</code> 方法。</p>\n<h4 id=\"延后执行某个任务的方法\"><a href=\"#延后执行某个任务的方法\" class=\"headerlink\" title=\"延后执行某个任务的方法\"></a>延后执行某个任务的方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用 performSelector:withObject:afterDelay:</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(doSomething) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 dispatch_after</span></div><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomething];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"将任务放在主线程执行\"><a href=\"#将任务放在主线程执行\" class=\"headerlink\" title=\"将任务放在主线程执行\"></a>将任务放在主线程执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用 performSelectorOnMainThread:withObject:waitUntilDone:</div><div class=\"line\">[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 使用 dispatch_async</div><div class=\"line\">// (or if waitUntilDone is YES, then dispatch_sync)</div><div class=\"line\">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [self doSomething];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果 <code>waitUntilDone</code> 的参数是 <code>Yes</code>，那么就对应 GCD 的 <code>dispatch_sync</code> 方法。我们可以看到，使用 GCD 的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。</p>\n<h3 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h3><p>除了 GCD，<strong>操作队列（NSOperationQueue）</strong>也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用 GCD 好些，有时则是使用操作队列更加合理。（并不清楚操作队列怎么用的，反正就抄一下哪里好）</p>\n<ul>\n<li>可以取消操作：在运行任务前，可以在NSOperation对象调用 <code>cancel</code> 方法，标明此任务不需要执行。但是 GCD 队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>\n<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>\n<li>监控 <code>NSOperation</code> 对象的属性：可以通过 KVO 来监听 <code>NSOperation</code> 的属性：可以通过 <code>isCancelled</code> 属性来判断任务是否已取消；通过 <code>isFinished</code> 属性来判断任务是否已经完成。</li>\n<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>\n</ul>\n<h3 id=\"第44条：通过Dispath-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispath-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispath Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispath Group机制，根据系统资源状况来执行任务</h3><p>有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用 <code>dispath group</code> 函数来实现这个需求：</p>\n<p>通过 <code>dispath group</code> 函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个优先级低的并发队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//一个优先级高的并发队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建dispatch_group</span></div><div class=\"line\">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将优先级低的队列放入dispatch_group</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> lowPriorityObjects) &#123;</div><div class=\"line\"> dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将优先级高的队列放入dispatch_group</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> highPriorityObjects) &#123;</div><div class=\"line\"> dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dispatch_group里的任务都结束后调用块中的代码</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> notifyQueue = dispatch_get_main_queue();</div><div class=\"line\">dispatch_group_notify(dispatchGroup,notifyQueue,^&#123;</div><div class=\"line\">     <span class=\"comment\">// Continue processing after completing tasks</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>想要更详细的了解，还是看之前的 GCD 介绍文章吧。</p>\n<h3 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h3><p>有时我们可能只需要将某段代码执行一次，这时可以通过 <code>dispatch_once</code> 函数来解决。</p>\n<p><code>dispatch_once</code> 函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用 <code>dispatch_once</code> 函数来令初始化代码只执行一次，并且内部是线程安全的。</p>\n<p>而且，对于执行一次的 <code>block</code> 来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在 <code>static</code> 或 <code>global</code> 作用域里。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance &#123;</div><div class=\"line\">     <span class=\"keyword\">static</span> EOCClass *sharedInstance = <span class=\"literal\">nil</span>;</div><div class=\"line\">     <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\">     <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">﻿            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">     <span class=\"keyword\">return</span> sharedInstance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用dispatch_get_current_queue</h3><p>已经被废弃的 API，不说了。</p>\n<h2 id=\"系统框架\"><a href=\"#系统框架\" class=\"headerlink\" title=\"系统框架\"></a>系统框架</h2><h3 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h3><p>主要的系统框架：</p>\n<ul>\n<li>Foundation  :NSObject,NSArray,NSDictionary 等</li>\n<li>CFoundation :C 语言 API，Foundation 框架中的许多功能，都可以在这里找到对应的 C 语言 API</li>\n<li>CFNetwork   :C 语言 API，提供了 C 语言级别的网络通信能力 </li>\n<li>CoreAudio   :C 语言 API，操作设备上的音频硬件</li>\n<li>AVFoundation:提供的 OC 对象可以回放并录制音频和视频</li>\n<li>CoreData    :OC 的 API，将对象写入数据库</li>\n<li>CoreText    :C 语言 API，高效执行文字排版和渲染操作</li>\n</ul>\n<h3 id=\"第48条：多用块枚举，少用for循环\"><a href=\"#第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"第48条：多用块枚举，少用for循环\"></a>第48条：多用块枚举，少用for循环</h3><h4 id=\"传统的for遍历\"><a href=\"#传统的for遍历\" class=\"headerlink\" title=\"传统的for遍历\"></a>传统的for遍历</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *anArray = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; anArray.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> object = anArray[i];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Dictionary</span></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *aDictionary = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *keys = [aDictionary allKeys];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; keys.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> key = keys[i];</div><div class=\"line\">   <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'key' and 'value'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set</span></div><div class=\"line\"><span class=\"built_in\">NSSet</span> *aSet = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *objects = [aSet allObjects];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; objects.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> object = objects[i];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，在遍历 NSDictionary,和 NSet 时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>\n<h4 id=\"利用快速遍历\"><a href=\"#利用快速遍历\" class=\"headerlink\" title=\"利用快速遍历\"></a>利用快速遍历</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *anArray = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> anArray) &#123;</div><div class=\"line\"> <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Dictionary</span></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *aDictionary = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> key <span class=\"keyword\">in</span> aDictionary) &#123;</div><div class=\"line\"> <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\"> <span class=\"comment\">// Do something with 'key' and 'value'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSSet</span> *aSet = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> aSet) &#123;</div><div class=\"line\"> <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>\n<h4 id=\"利用基于块（block）的遍历\"><a href=\"#利用基于块（block）的遍历\" class=\"headerlink\" title=\"利用基于块（block）的遍历\"></a>利用基于块（block）的遍历</h4><p>其实我觉得没啥用，不看也罢。</p>\n<h3 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h3><p>通过无缝桥接技术，可以在 Foundation 框架中的 OC 对象和 CoreFoundation 框架中的 C 语言数据结构之间来回转换。</p>\n<p>为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。</p>\n<p>具体怎么用，用在什么场景呢？ 没看懂。呵呵</p>\n<h3 id=\"第50条：构建缓存时选用-NSCache-而非-NSDictionary\"><a href=\"#第50条：构建缓存时选用-NSCache-而非-NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用 NSCache 而非 NSDictionary\"></a>第50条：构建缓存时选用 NSCache 而非 NSDictionary</h3><p>不知道有啥用，用到时候再说。</p>\n<h3 id=\"第51条-精简initialize-与-load的实现代码\"><a href=\"#第51条-精简initialize-与-load的实现代码\" class=\"headerlink\" title=\"第51条: 精简initialize 与 load的实现代码\"></a>第51条: 精简initialize 与 load的实现代码</h3><p>每个类和分类在<strong>加入运行期系统时</strong>，都会调用 <code>load</code> 方法，而且仅仅调用一次。<code>load</code> 方法不遵循继承规则，某个类本身没有重写 <code>load</code>，那也不会调用超类的 <code>load</code> 方法。可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。</p>\n<p><code>initialize</code> 方法与 <code>load</code> 方法类似，区别是这个方法会在程序首次调用这个类的时候调用（<strong>惰性调用</strong>），而且只调用一次（绝对不能主动使用代码调用）。如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。如果在 <code>initialize</code> 方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在 <code>initialize</code> 方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的 bug。</p>\n<h3 id=\"第52条-别忘了NSTimer会保留其目标对象\"><a href=\"#第52条-别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条: 别忘了NSTimer会保留其目标对象\"></a>第52条: 别忘了NSTimer会保留其目标对象</h3><p>在使用 <code>NSTimer</code> 的时候，<code>NSTimer</code> 会生成指向其使用者的引用，而其使用者如果也引用了 <code>NSTimer</code>，那么就会生成保留环。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCClass</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startPolling;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)stopPolling;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span> </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">NSTimer</span> *_pollTimer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> init];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\">    [_pollTimer invalidate];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)stopPolling &#123;</div><div class=\"line\"></div><div class=\"line\">    [_pollTimer invalidate];</div><div class=\"line\">    _pollTimer = <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startPolling &#123;</div><div class=\"line\">   _pollTimer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">5.0</span></div><div class=\"line\">                                                 target:<span class=\"keyword\">self</span></div><div class=\"line\">                                               selector:<span class=\"keyword\">@selector</span>(p_doPoll)</div><div class=\"line\">                                               userInfo:<span class=\"literal\">nil</span></div><div class=\"line\">                                                repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)p_doPoll &#123;</div><div class=\"line\">    <span class=\"comment\">// Poll the resource</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里可以看到 <code>EOCClass</code> 和 <code>_pollTimer</code> 之间由于 <code>target:self</code> 的存在，相互形成了保留环，如果不主动调用 <code>stopPolling</code> 方法将 <code>_pollTimer</code>取消并清空就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。这可能是一个极其危险的情况，因为 NSTimer 没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。</p>\n<p>那么如何解决呢？</p>\n<p>我觉得文章里举的方法简直脱裤子放屁，所以就不列出来了。直接将 <code>target:self</code> 设置成 <code>target:weakSelf</code> 不就行了？</p>\n","excerpt":"<p>拜读一下 Effective Objective-C 这本书，做一些笔记</p>","more":"<h2 id=\"熟悉OC\"><a href=\"#熟悉OC\" class=\"headerlink\" title=\"熟悉OC\"></a>熟悉OC</h2><h3 id=\"第1条：了解Objective-C的起源\"><a href=\"#第1条：了解Objective-C的起源\" class=\"headerlink\" title=\"第1条：了解Objective-C的起源\"></a>第1条：了解Objective-C的起源</h3><p>对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由<strong>运行期组件（runtime component）</strong>完成，使用 Objective-C 的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。</p>\n<p>运行期组件本质上是一种与开发者所编写的代码相链接的<strong>动态库（dynamic library）</strong>，其代码能把开发者所编写的所有程序粘合起来。</p>\n<h3 id=\"第2条：-在类的头文件中尽量少引用其他头文件\"><a href=\"#第2条：-在类的头文件中尽量少引用其他头文件\" class=\"headerlink\" title=\"第2条： 在类的头文件中尽量少引用其他头文件\"></a>第2条： 在类的头文件中尽量少引用其他头文件</h3><p>有时，类A需要将类B的实例变量作为它公共 API 的属性。这个时候，我们不应该引入类B的头文件，而应该使用<strong>向前声明（forward declaring）</strong> 使用 <code>@class</code> 关键字，并且<strong>在 A 的实现文件引用 B 的头文件</strong>。(继承或者协议必须引入完整头文件，不能使用向前声明)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EOCPerson.h</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">EOCEmployer</span>;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) EOCEmployer *employer;<span class=\"comment\">//将EOCEmployer作为属性</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// EOCPerson.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCEmployer.h\"</span></span></div></pre></td></tr></table></figure>\n<p>这样做有什么优点呢：</p>\n<ol>\n<li>不在A的头文件中引入B的头文件，那么A的实现文件引入A的头文件时，就不会一并引入B的全部内容，这样就减少了编译时间。只有在A的实现里需要用到B时，再在A的实现里引用B的头文件。</li>\n<li>使用 <code>#import</code> 而不是 <code>#include</code> 可以避免死循环，但仍会导致相互引用的两个类中的一哥无法正确编译。使用 <code>@class</code> 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>\n</ol>\n<h3 id=\"第3条：多用字面量语法，少用与之等价的方法\"><a href=\"#第3条：多用字面量语法，少用与之等价的方法\" class=\"headerlink\" title=\"第3条：多用字面量语法，少用与之等价的方法\"></a>第3条：多用字面量语法，少用与之等价的方法</h3><p>声明时多用字面量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSNumber</span> *intNumber = @<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">NSNumber</span> *floatNumber = @<span class=\"number\">2.5</span>f;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *animals =@[<span class=\"string\">@\"cat\"</span>, <span class=\"string\">@\"dog\"</span>,<span class=\"string\">@\"mouse\"</span>, <span class=\"string\">@\"badger\"</span>];</div><div class=\"line\">Dictionary *dict = @&#123;<span class=\"string\">@\"animal\"</span>:<span class=\"string\">@\"tiger\"</span>,<span class=\"string\">@\"phone\"</span>:<span class=\"string\">@\"iPhone 6\"</span>&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSString</span> *cat = animals[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"built_in\">NSString</span> *iphone = dict[<span class=\"string\">@\"phone\"</span>];</div></pre></td></tr></table></figure>\n<p>少用 <code>alloc</code>、<code>init</code> 的方式创建，以及 <code>objectAtIndex</code>、<code>objectForKey</code> 的方式取数组字典。</p>\n<p>优点：</p>\n<ol>\n<li>简洁</li>\n<li><code>NSArray</code> 以 <code>nil</code> 结尾，所以一般不允许数组中的元素为 <code>nil</code>，如果使用等价方法，那么数组元素为 <code>nil</code> 不报错，会出现难以排查的错误；而同样的情况，字面量语法会抛出异常。</li>\n</ol>\n<h3 id=\"第4条：多用类型常量，少用-define预处理命令\"><a href=\"#第4条：多用类型常量，少用-define预处理命令\" class=\"headerlink\" title=\"第4条：多用类型常量，少用#define预处理命令\"></a>第4条：多用类型常量，少用#define预处理命令</h3><p>预处理与类型常量的优缺点：</p>\n<ul>\n<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>\n<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>\n</ul>\n<h4 id=\"预处理命令\"><a href=\"#预处理命令\" class=\"headerlink\" title=\"预处理命令\"></a>预处理命令</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define W_LABEL (W_SCREEN - 2*GAP)</span></div></pre></td></tr></table></figure>\n<p>这里，<code>(W_SCREEN - 2*GAP)</code> 替换了 <code>W_LABEL</code>，它不具备 <code>W_LABEL</code> 的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。</p>\n<h4 id=\"类型常量\"><a href=\"#类型常量\" class=\"headerlink\" title=\"类型常量\"></a>类型常量</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"built_in\">NSTimeIntervalDuration</span> = <span class=\"number\">0.3</span>;</div></pre></td></tr></table></figure>\n<p><code>const</code> 将其设置为常量，不可更改。<code>static</code> 意味着该变量仅仅在定义此变量的编译单元(<code>.m</code> 实现文件)中可见。如果不声明 <code>static</code>,编译器会为它创建一个<strong>外部符号（external symbol）</strong>。会出现什么问题呢？如果在其他类中也声明了同名变量，即使没有相互引用，编译器也会抛出一个异常。</p>\n<h4 id=\"全局常量\"><a href=\"#全局常量\" class=\"headerlink\" title=\"全局常量\"></a>全局常量</h4><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量，即全局常量。在头文件中声明外部常量，在实现文件中完成变量的赋值。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//header file</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span> NotificationString;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//implementation file</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> *<span class=\"keyword\">const</span>  NotificationString = <span class=\"string\">@\"Finish Download\"</span>;</div></pre></td></tr></table></figure>\n<p>注意这里的 <code>const</code>, 如果在 <code>*</code> 前面，表示指针指向的堆上的内容不能改变，如果在 <code>*</code> 后面，表示指针指向的地址是不能改变的。（这里有个助记方法，以 <code>*</code> 为分解，<code>const</code> 在左边就是修饰 <code>NSString</code>，表示不能修改值，在右边就表示修饰指针对象，表示不能修改指针指向的地址。）</p>\n<h3 id=\"第5条：用枚举表示状态，选项，状态码\"><a href=\"#第5条：用枚举表示状态，选项，状态码\" class=\"headerlink\" title=\"第5条：用枚举表示状态，选项，状态码\"></a>第5条：用枚举表示状态，选项，状态码</h3><p>我们经常需要给类定义几个状态，这些状态码可以用枚举来管理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EOCConnectionState) &#123;</div><div class=\"line\">  EOCConnectionStateDisconnected,</div><div class=\"line\">  EOCConnectionStateConnecting,</div><div class=\"line\">  EOCConnectionStateConnected,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTION</span>(<span class=\"built_in\">NSUInteger</span>, EOCPermittedDirection) &#123;</div><div class=\"line\">\tEOCPermittedDirectionUp    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">\tEOCPermittedDirectionDown  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">\tEOCPermittedDirectionLeft  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">\tEOCPermittedDirectionRight = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>NS_ENUM</code> 和 <code>NS_OPTION</code> 是 Foundation 框架中定义的辅助宏。需要注意这两者使用场景的不同。</p>\n<p>在枚举类型的 switch 语句中不要实现 default 分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch 语句并未处理所有的枚举。否则添加了枚举却没有实现 switch 将可能导致严重的崩溃。</p>\n<h2 id=\"对象、消息、运行期\"><a href=\"#对象、消息、运行期\" class=\"headerlink\" title=\"对象、消息、运行期\"></a>对象、消息、运行期</h2><h3 id=\"第6条：理解“属性”这一概念\"><a href=\"#第6条：理解“属性”这一概念\" class=\"headerlink\" title=\"第6条：理解“属性”这一概念\"></a>第6条：理解“属性”这一概念</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>在 Java 以及 C++ 中，对象布局在编译期就已经固定了。只要访问变量的代码，编译器就会把其替换成为“偏移量”。这个偏移量是<strong>硬编码（hardcode）</strong>，表示该对象距离存放对象的内存区域的起始地址有多远。这样做的问题是，如果再添加一个实例变量，那么其他实例变量的就要变化了，那么就要重新编译，否则就会出错。</p>\n<p>Objective-C 的做法是，把实例变量当做一种存储偏移量所用的<strong>“特殊变量”（special variable）</strong>，交由<strong>“类对象”（class object）</strong>保管。偏移量会在运行期查找，那么类的定义变了，存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量。</p>\n<h4 id=\"存取方法\"><a href=\"#存取方法\" class=\"headerlink\" title=\"存取方法\"></a>存取方法</h4><p>在设置完属性后，编译器会自动向类中添加适当类型的实例变量，并且为其写出一套存取方法。访问属性，可以使用点语法，编译器会把点语法转换为对存取方法的调用；也可直接使用实例变量，使用实例变量的方式更快。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//存取方法设置属性</span></div><div class=\"line\"><span class=\"keyword\">self</span>.firstName = <span class=\"string\">@\"Zachary\"</span>;</div><div class=\"line\"><span class=\"comment\">//实例变量设置属性</span></div><div class=\"line\">_firstName = <span class=\"string\">@\"Zachary\"</span>;</div></pre></td></tr></table></figure>\n<h4 id=\"属相特质\"><a href=\"#属相特质\" class=\"headerlink\" title=\"属相特质\"></a>属相特质</h4><p>原子性：</p>\n<ul>\n<li>nonatomic：不使用同步锁</li>\n<li>atomic：加同步锁，确保其原子性</li>\n</ul>\n<p>读写:</p>\n<ul>\n<li>readwrite:同时存在存取方法</li>\n<li>readonly:只有获取方法</li>\n</ul>\n<p>内存管理:</p>\n<ul>\n<li>assign:纯量类型(scalar type)的简单赋值操作</li>\n<li>strong:拥有关系保留新值，释放旧值，再设置新值</li>\n<li>weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</li>\n<li>copy：当赋给其可变对象，返回不可变对象；当赋给其不可变对象，返回原对象。</li>\n</ul>\n<h3 id=\"第7条：-在对象内部尽量直接访问实例变量\"><a href=\"#第7条：-在对象内部尽量直接访问实例变量\" class=\"headerlink\" title=\"第7条： 在对象内部尽量直接访问实例变量\"></a>第7条： 在对象内部尽量直接访问实例变量</h3><p>关于实例变量的访问，可以直接访问 <code>_firstName</code>，也可以通过属性的方式(点语法) <code>self.firstName</code> 来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。（这部分比较重要）</p>\n<p>直接访问实例变量的特点：</p>\n<ul>\n<li>不经过<strong>“方法派发”(method dispatch)</strong>，会直接访问保存对象实例变量的那块内存，速度快。</li>\n</ul>\n<p>通过属性访问实例变量的特点：</p>\n<ul>\n<li>不会绕过属性定义的<strong>内存管理语义</strong>。其实也就是说，编译期在设置 set 方法的时候，会根据属性特质做一些操作。比如一个声明为 <code>copy</code> 的属性，如果直接访问实例变量，那么这个实例变量就会直接指向堆中的对象；而如果通过属性来操作，就会先将堆中的对象 copy 一份，然后将实例变量指向 copy 出来的对象。</li>\n<li>可以触发KVO</li>\n</ul>\n<p>不过有两个特例：</p>\n<ol>\n<li><code>init</code> 方法和 <code>dealloc</code> 方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作(比如上面说的<strong>内存管理语义</strong>所要进行的操作)。</li>\n<li>如果使用<strong>懒加载</strong>的获取方法要用属性的方式获取。</li>\n</ol>\n<p>其实，到底用什么很简单，如果 get，set 方法里没有其他的乱七八糟的东西，比如:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)firstName&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> _firstName;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) setFirstName:(<span class=\"built_in\">NSString</span> *)firstName&#123;</div><div class=\"line\">\t_firstName = firstName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种，那就直接用实例变量操作了，用属性就是多此一举；如果有乱七八糟的东西，那么就要用属性的方式。</p>\n<h3 id=\"第8条：理解“对象等同性”这一概念\"><a href=\"#第8条：理解“对象等同性”这一概念\" class=\"headerlink\" title=\"第8条：理解“对象等同性”这一概念\"></a>第8条：理解“对象等同性”这一概念</h3><p><code>NSObject</code> 类中有两个用于判断等同性的方法：</p>\n<ul>\n<li><code>- (BOOL)isEqual:(id)object;</code></li>\n<li><code>- (NSUInteger)hash;</code></li>\n</ul>\n<p><code>NSObject</code> 类中默认的实现是：当且仅当其内存地址完全相等时，两个对象才相等。自定义对象中可以覆写这两个方法（其实好像没必要重写 hash 方法，因为我们重写的 <code>isEqual:</code> 方法里根本没有用到 hash 方法，重写了也没啥用），完成自己的相等判断。如果 <code>isEqual:</code> 方法判断对象相等，那么其 hash 方法也必须返回同一个值；反之，如果 hash 方法返回了同一个值，<code>isEqual:</code> 方法未必认为两者相等。</p>\n<p>如果已知两个对象是字符串，最好通过 <code>isEqualToString:</code> 方法来比较。对于数组和字典，也有 <code>isEqualToArray:</code> 方法和 <code>isEqualToDictionary:</code>方法。</p>\n<p>如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的 <code>isEqual:</code> 方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqualToPerson:(EOCPerson*)otherPerson &#123;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//先比较对象类型，然后比较每个属性</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> == object) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (![_firstName isEqualToString:otherPerson.firstName])</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (![_lastName isEqualToString:otherPerson.lastName])</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">if</span> (_age != otherPerson.age)</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isEqual:(<span class=\"keyword\">id</span>)object &#123;</div><div class=\"line\">    <span class=\"comment\">//如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法</span></div><div class=\"line\">     <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] == [object <span class=\"keyword\">class</span>]) &#123;    </div><div class=\"line\">         <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span> isEqualToPerson:(EOCPerson*)object];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    </div><div class=\"line\">         <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> isEqual:object];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第9条-以“类族模式“隐藏实现细节\"><a href=\"#第9条-以“类族模式“隐藏实现细节\" class=\"headerlink\" title=\"第9条 以“类族模式“隐藏实现细节\"></a>第9条 以“类族模式“隐藏实现细节</h3><p>其实就是通过抽象类完成工厂模式。</p>\n<p>例如,对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCEmployee.h</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSUInteger</span>, EOCEmployeeType) &#123;</div><div class=\"line\">    EOCEmployeeTypeDeveloper,</div><div class=\"line\">    EOCEmployeeTypeDesigner,</div><div class=\"line\">    EOCEmployeeTypeFinance,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployee</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</div><div class=\"line\"><span class=\"keyword\">@property</span> <span class=\"built_in\">NSUInteger</span> salary;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Helper for creating Employee objects</span></div><div class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Make Employees do their respective day's work</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCEmployee.m</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployee</span></span></div><div class=\"line\"></div><div class=\"line\">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</div><div class=\"line\">     <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">         <span class=\"keyword\">case</span> EOCEmployeeTypeDeveloper:</div><div class=\"line\">            <span class=\"keyword\">return</span> [EOCEmployeeDeveloper new];</div><div class=\"line\">         <span class=\"keyword\">break</span>; </div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeDesigner:</div><div class=\"line\">             <span class=\"keyword\">return</span> [EOCEmployeeDesigner new];</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> EOCEmployeeTypeFinance:</div><div class=\"line\">             <span class=\"keyword\">return</span> [EOCEmployeeFinance new];</div><div class=\"line\">         <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork &#123;</div><div class=\"line\"> <span class=\"comment\">// 需要子类来实现</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCEmployeeDeveloper</span> : <span class=\"title\">EOCEmployee</span></span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCEmployeeDeveloper</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)doADaysWork &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> writeCode];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这样，表面上对象是 <code>EOCEmployee</code>，但是实际上操作的是 <code>EOCEmployeeDeveloper</code>。</p>\n<p>这里需要注意一点：对于这种类族，不能通过以下方式判断：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ([employeeDeveloper <span class=\"keyword\">class</span>] == [EOCEmployee <span class=\"keyword\">class</span>])&#123;</div><div class=\"line\">\t<span class=\"comment\">// will do</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为 <code>employeeDeveloper</code> 对象是 <code>EOCEmployee</code> 类的一个子集，需要使用 <code>isKindOfClass:</code> 方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> ([employeeDeveloper isKindOfClass:[EOCEmployee <span class=\"keyword\">class</span>]])&#123;</div><div class=\"line\">\t<span class=\"comment\">// will do</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第10条：在既有类中使用关联对象存放自定义数据\"><a href=\"#第10条：在既有类中使用关联对象存放自定义数据\" class=\"headerlink\" title=\"第10条：在既有类中使用关联对象存放自定义数据\"></a>第10条：在既有类中使用关联对象存放自定义数据</h3><p>这一条和 runtime 息息相关。背景是，我们可以通过 category 为系统类添加方法，但是无法添加属性。当需要为系统类添加属性时，可以使用下面的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//为某个对象设置关联对象的值，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义</span></div><div class=\"line\"><span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//根据给定的键从某对象中获取相应的关联对象值</span></div><div class=\"line\"><span class=\"keyword\">id</span> objc_getAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">void</span> *key)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移除指定对象的关联对象</span></div><div class=\"line\"><span class=\"keyword\">void</span> objc_removeAssociatedObjects(<span class=\"keyword\">id</span> object)</div></pre></td></tr></table></figure>\n<p>这里要强调的是，要拿到设置的属性，键必须要完全相等。因此，需要设置成静态全局变量：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *EOCMyAlertViewKey = <span class=\"string\">\"EOCMyAlertViewKey\"</span>;</div></pre></td></tr></table></figure>\n<h3 id=\"第11条：理解objc-msgSend的作用\"><a href=\"#第11条：理解objc-msgSend的作用\" class=\"headerlink\" title=\"第11条：理解objc_msgSend的作用\"></a>第11条：理解objc_msgSend的作用</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime</a>中已经写得很详细了，参见就行了。</p>\n<h3 id=\"第12条：理解消息转发机制\"><a href=\"#第12条：理解消息转发机制\" class=\"headerlink\" title=\"第12条：理解消息转发机制\"></a>第12条：理解消息转发机制</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/23/runtime应用/\">runtime</a>中已经写得很详细了，参见就行了。</p>\n<h3 id=\"第13条：用“方法调配技术”调试“黑盒方法”\"><a href=\"#第13条：用“方法调配技术”调试“黑盒方法”\" class=\"headerlink\" title=\"第13条：用“方法调配技术”调试“黑盒方法”\"></a>第13条：用“方法调配技术”调试“黑盒方法”</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/23/runtime应用/\">runtime</a>中也介绍了。</p>\n<h3 id=\"第14条：理解“类对象”的用意\"><a href=\"#第14条：理解“类对象”的用意\" class=\"headerlink\" title=\"第14条：理解“类对象”的用意\"></a>第14条：理解“类对象”的用意</h3><p>这部分在<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime</a>中也介绍了。</p>\n<h2 id=\"接口与API设计\"><a href=\"#接口与API设计\" class=\"headerlink\" title=\"接口与API设计\"></a>接口与API设计</h2><h3 id=\"第15条：用前缀-避免命名空间冲突\"><a href=\"#第15条：用前缀-避免命名空间冲突\" class=\"headerlink\" title=\"第15条：用前缀 避免命名空间冲突\"></a>第15条：用前缀 避免命名空间冲突</h3><p>Apple 宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。</p>\n<h3 id=\"第16条：提供”全能初始化方法”\"><a href=\"#第16条：提供”全能初始化方法”\" class=\"headerlink\" title=\"第16条：提供”全能初始化方法”\"></a>第16条：提供”全能初始化方法”</h3><p>所谓全能初始化方法，就是所有初始化方法都要调用的初始化方法。这个初始化方法初始化方法是初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。</p>\n<p>算是一种写代码的技巧吧。平时写代码的时候也都是这样的，不具体说明了。</p>\n<h3 id=\"第17条：实现description方法\"><a href=\"#第17条：实现description方法\" class=\"headerlink\" title=\"第17条：实现description方法\"></a>第17条：实现description方法</h3><p>自定义的类调用 <code>NSLog();</code> 的时候，往往不能返回想要的结果。需要重写 <code>NSObject</code> 类中的 <code>description</code> 方法，返回需要的字符串。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)description &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"&lt;%@: %p, %@ %@&gt;\"</span>, [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"keyword\">self</span>, firstName, lastName];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>%p</code> 表示对象的内存地址。</p>\n<h3 id=\"第18条：尽量使用不可变对象\"><a href=\"#第18条：尽量使用不可变对象\" class=\"headerlink\" title=\"第18条：尽量使用不可变对象\"></a>第18条：尽量使用不可变对象</h3><p>尽量使用不可变对象。没啥可说的。<br>里面推荐的方法没用过，感觉并不好，就不写了。</p>\n<h3 id=\"第19条：使用清晰而协调的命名方式\"><a href=\"#第19条：使用清晰而协调的命名方式\" class=\"headerlink\" title=\"第19条：使用清晰而协调的命名方式\"></a>第19条：使用清晰而协调的命名方式</h3><p>没啥好说的，注意就好</p>\n<h3 id=\"第20条：为私有方法名加前缀\"><a href=\"#第20条：为私有方法名加前缀\" class=\"headerlink\" title=\"第20条：为私有方法名加前缀\"></a>第20条：为私有方法名加前缀</h3><p>建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCObject</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)publicMethod;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCObject</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)publicMethod &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)p_privateMethod &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>很有用的建议，注意不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。</p>\n<h3 id=\"第21条：理解Objective-C错误类型\"><a href=\"#第21条：理解Objective-C错误类型\" class=\"headerlink\" title=\"第21条：理解Objective-C错误类型\"></a>第21条：理解Objective-C错误类型</h3><p>OC 中仅在及其严重的错误情况下抛出异常。比如一个抽象基类。由于 OC 中没办法将某个类标识为抽象类。如果想要实现抽象类的功能，那么就要在必须要覆写的方法里抛出异常：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)mustOverrideMethod&#123;</div><div class=\"line\">\t<span class=\"built_in\">NSString</span> *reason = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@ must be overridden\"</span>, <span class=\"built_in\">NSStringFromeSelector</span>(_cmd)];</div><div class=\"line\">\t<span class=\"keyword\">@throw</span> [<span class=\"built_in\">NSException</span> exceptionWithName:<span class=\"built_in\">NSInternalInconsistencyException</span></div><div class=\"line\">\t\t\t\t\t\t\t\t\t    reason:reason</div><div class=\"line\">\t\t\t\t\t\t\t\t\t  userInfo:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于不严重的异常，可以使用返回 <code>nil</code> 或者 <code>NSError</code> 的方式(其实也没啥用，这些都是手动设置的，我都知道哪里会出现问题了，还要新建 <code>NSError</code> 对象干嘛(可能我的理解有偏差))。</p>\n<h3 id=\"第22条：理解NSCopying协议\"><a href=\"#第22条：理解NSCopying协议\" class=\"headerlink\" title=\"第22条：理解NSCopying协议\"></a>第22条：理解NSCopying协议</h3><h4 id=\"自定义拷贝\"><a href=\"#自定义拷贝\" class=\"headerlink\" title=\"自定义拷贝\"></a>自定义拷贝</h4><p>如果我们想令自己的类支持拷贝操作，那就要实现 <code>NSCopying</code> 协议，该协议只有一个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span>*)zone</div></pre></td></tr></table></figure>\n<p>比如要拷贝一个 <code>EOCPerson</code> 对象：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)copyWithZone:(<span class=\"built_in\">NSZone</span>*)zone &#123;</div><div class=\"line\">     EOCPerson *<span class=\"keyword\">copy</span> = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];</div><div class=\"line\">    <span class=\"keyword\">copy</span>-&gt;_friends = [_friends mutableCopy];</div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">copy</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">这里面的 `<span class=\"built_in\">NSZone</span> *zone` 对象不用在意是什么，现在已经没用了。其实也就是新建一个 `EOCPerson` 对象，然后调用它的构造函数把东西全都塞进去。这里的 `-&gt;` 用箭头是因为定义的时候这个 `_friends` 不是一个属性(代码没有贴出来，详见书)，而只是在实现文件中定义的一个实例变量，没有 get/set 方法，所以不能用 `.` </div><div class=\"line\"></div><div class=\"line\">这里的 `mutableCopy` 方法也可以自定义，就是下面方法的实现 </div><div class=\"line\">```objc</div><div class=\"line\">- (<span class=\"keyword\">id</span>)mutableCopyWithZone:(<span class=\"built_in\">NSZone</span>*)zone；</div></pre></td></tr></table></figure>\n<h4 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h4><p>浅拷贝和深拷贝应该并不陌生。浅拷贝只增加引用计数，深拷贝将创建另一个一模一样的对象。</p>\n<ul>\n<li>不可变对象的 <code>copy</code> 是浅拷贝。</li>\n<li>可变对象的 <code>copy</code> 是深拷贝，返回不可变对象。</li>\n<li>不可变对象的 <code>mutableCopy</code> 是深拷贝，返回可变对象。</li>\n<li>可变对象的 <code>mutableCopy</code> 是浅拷贝。</li>\n</ul>\n<p>容器对象(<code>NSArray</code>)本身也遵循上面的规则。但是需要注意的是，<strong>容器对象内的元素是浅拷贝</strong>。因此上面的自定义 copy 方法如果想让 <code>_friends</code> 内的元素深拷贝，就不能用 <code>[_friends mutableCopy]</code> 方法，需要新建一个 Set:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">id</span>)deepCopy &#123;</div><div class=\"line\">   EOCPerson *<span class=\"keyword\">copy</span> = [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] alloc] initWithFirstName:_firstName andLastName:_lastName];</div><div class=\"line\">\t<span class=\"keyword\">copy</span>-&gt;_friends = [[<span class=\"built_in\">NSMutableSet</span> alloc] initWithSet:_friends copyItems:<span class=\"literal\">YES</span>];</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">copy</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"协议与分类\"><a href=\"#协议与分类\" class=\"headerlink\" title=\"协议与分类\"></a>协议与分类</h2><h3 id=\"第23条：通过委托与数据源协议进行对象间通信\"><a href=\"#第23条：通过委托与数据源协议进行对象间通信\" class=\"headerlink\" title=\"第23条：通过委托与数据源协议进行对象间通信\"></a>第23条：通过委托与数据源协议进行对象间通信</h3><p>其实也是老生常谈的东西了，不过也有一些注意点。</p>\n<p>受代理对象内持有代理对象的实例时要写成这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;NetworkDelegate&gt; delegate;</div></pre></td></tr></table></figure>\n<p>这里书中指明了要用 <code>weak</code>，不能用 <code>strong</code>，否则会引起引用循环。比如系统中的 <code>TableViewCellDelegate</code>，在 <code>TableViewController</code> 作为代理类确实拥有被代理对象 <code>TableViewCell</code>，用 <code>weak</code> 确实是合理的，但是所有情况都这样吗？不知道，不过确实基本上的代理对象都是 <code>ViewController</code>，所以用 <code>weak</code> 肯定是不会有问题的。</p>\n<p>实现委托对象的方法是声明某个类遵从委托协议：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCDataModel</span> () &lt;<span class=\"title\">EOCNetworkFetcherDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCDataModel</span></span></div><div class=\"line\"><span class=\"comment\">// 各个实现方法</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>基本所有的 Delegate 都在 <code>.m</code> 文件中的类拓展中声明，之前一直没有留意，看了书后才问自己，为什么不在 <code>.h</code> 中声明？两者有什么差别吗？其实也没什么差别，在实现文件中声明的好处是能隐藏细节。如果只是自己用可能没什么区别，但是如果打包给别人用，那么就不应该让别人看到你的实现细节了，因此，就把这个 Delegate 的声明放到了实现文件中。<br>好吧。一个简单的道理。只是我一开始没想明白。</p>\n<h3 id=\"第24条：将类的实现代码分散到便于管理的数个分类中\"><a href=\"#第24条：将类的实现代码分散到便于管理的数个分类中\" class=\"headerlink\" title=\"第24条：将类的实现代码分散到便于管理的数个分类中\"></a>第24条：将类的实现代码分散到便于管理的数个分类中</h3><p>当一个类越来越大时，就变得不利于管理，因此需要将类代码按照逻辑划分入几个分区中，可以通过范畴的方式实现。书中有一个例子：</p>\n<p>无分类:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithFirstName:(<span class=\"built_in\">NSString</span>*)firstName andLastName:(<span class=\"built_in\">NSString</span>*)lastName;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Friendship methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Work methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)performDaysWork;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)takeVacationFromWork;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Play methods */</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToTheCinema;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToSportsGame;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>分类后:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *firstName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *lastName;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span> *friends;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithFirstName:(<span class=\"built_in\">NSString</span>*)firstName</div><div class=\"line\"></div><div class=\"line\">andLastName:(<span class=\"built_in\">NSString</span>*)lastName;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Work</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)performDaysWork;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)takeVacationFromWork;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Play</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToTheCinema;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)goToSportsGame;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>如果觉得写在一个实现文件中太长了，可以拆开，比如将其中的 <code>Friendship</code> 拆开。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EOCPerson+Friendship.h</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCPerson.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person;</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// EOCPerson+Friendship.m</span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"EOCPerson+Friendship.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCPerson</span> (<span class=\"title\">Friendship</span>)</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addFriend:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeFriend:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)isFriendsWith:(EOCPerson*)person &#123;</div><div class=\"line\"> <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>不过要注意，在新建分类文件时，一定要引入被分类的类文件。</p>\n<p>这个技巧说有用也有用，说没用，也没用，看具体实际情况吧。另外，还有一个技巧是将所有”私有”方法都归入名叫 Private 的分类中，以隐藏实现细节，好像是个挺有意思的想法。</p>\n<h3 id=\"第25条：总是为第三方类的分类名称加前缀\"><a href=\"#第25条：总是为第三方类的分类名称加前缀\" class=\"headerlink\" title=\"第25条：总是为第三方类的分类名称加前缀\"></a>第25条：总是为第三方类的分类名称加前缀</h3><p>如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。否则可能会替换掉系统的方法。</p>\n<h3 id=\"第26条-勿在分类中声明属性\"><a href=\"#第26条-勿在分类中声明属性\" class=\"headerlink\" title=\"第26条:勿在分类中声明属性\"></a>第26条:勿在分类中声明属性</h3><p>这本书要是早点看到就好了，当时纠结这个很久，走了很多弯路。</p>\n<p>分类机制，目标在于扩展类的功能，而不是封装数据。</p>\n<h3 id=\"第27条：使用class-continuation分类-隐藏实现细节\"><a href=\"#第27条：使用class-continuation分类-隐藏实现细节\" class=\"headerlink\" title=\"第27条：使用class-continuation分类 隐藏实现细节\"></a>第27条：使用class-continuation分类 隐藏实现细节</h3><p>通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用 class-continuation 分类的特性来补偿：</p>\n<ul>\n<li>可以在 class-continuation 分类中增加实例变量。</li>\n<li>可以在 class-continuation 分类中将公共接口的只读属性设置为读写。</li>\n<li>可以在 class-continuation 分类中遵循协议，使其不为人知。</li>\n</ul>\n<h3 id=\"第28条-通过协议提供匿名对象\"><a href=\"#第28条-通过协议提供匿名对象\" class=\"headerlink\" title=\"第28条:通过协议提供匿名对象\"></a>第28条:通过协议提供匿名对象</h3><p>OC 里的<strong>匿名对象</strong>和 Java 里的匿名对象不同，这里的匿名对象没有类型。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。它的表示方法为：<code>id&lt;protocol&gt;</code>。</p>\n<p>通过协议提供匿名对象的主要使用场景有两个：</p>\n<ul>\n<li>作为属性</li>\n<li>作为方法参数</li>\n</ul>\n<h4 id=\"匿名对象作为属性\"><a href=\"#匿名对象作为属性\" class=\"headerlink\" title=\"匿名对象作为属性\"></a>匿名对象作为属性</h4><p>在设定某个类为自己的代理属性时，可以不声明代理的类，而是用 <code>id&lt;protocol&gt;</code>，因为成为代理的终点并不是某个类的实例，而是遵循了某个协议。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;EOCDelegate&gt; delegate;</div></pre></td></tr></table></figure>\n<p>在这里使用匿名对象的原因有两个：</p>\n<ol>\n<li>将来可能会有很多不同类的实例对象作为该类的代理。</li>\n<li>我们不想指明具体要使用哪个类来作为这个类的代理。</li>\n</ol>\n<p>也就是说，能作为该类的代理的条件只有一个：它遵从了 <code>&lt;EOCDelegate&gt;</code> 协议。</p>\n<h4 id=\"匿名对象作为方法参数\"><a href=\"#匿名对象作为方法参数\" class=\"headerlink\" title=\"匿名对象作为方法参数\"></a>匿名对象作为方法参数</h4><p>有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setObject:(<span class=\"keyword\">id</span>)object forKey:(<span class=\"keyword\">id</span>&lt;<span class=\"built_in\">NSCopying</span>&gt;)key;</div></pre></td></tr></table></figure>\n<p>这个方法是 NSDictionary 的设值方法，它的参数只要遵从了 <code>&lt;NSCopying&gt;</code> 协议，就可以作为参数传进去,作为 NSDictionary 的键。</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h3 id=\"第29条：理解引用计数\"><a href=\"#第29条：理解引用计数\" class=\"headerlink\" title=\"第29条：理解引用计数\"></a>第29条：理解引用计数</h3><p>将对象放入自动释放池之后，不会马上使其引用计数 -1，而是在当前线程的下一次事件循环时递减。</p>\n<p>其他没什么好说的。</p>\n<h3 id=\"第30条：以ARC简化引用计数\"><a href=\"#第30条：以ARC简化引用计数\" class=\"headerlink\" title=\"第30条：以ARC简化引用计数\"></a>第30条：以ARC简化引用计数</h3><p>使用ARC，可以省略对于引用计数的操作，没太多好说的。</p>\n<p>需要了解一个修饰符 <code>__weak</code>。块内引用外部变量时，会自动保留其所捕获的全部对象，如果这其中有某个对象保留了块本身（如将 ViewController 传入），将会形成“保留环”。所以要用 <code>__weak</code> 局部变量来打破这种保留环。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">EOCNetwork * __<span class=\"keyword\">weak</span> weakFetcher = fetcher;</div></pre></td></tr></table></figure>\n<p>因此，我们可以定义一个 <code>weakSelf</code> 来简化这种声明方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#define WEAKSELF typeof(self) __weak weakSelf = self;</span></div></pre></td></tr></table></figure>\n<p>这样，在 ViewController 中用到 <code>self</code> 时，就可以直接用 <code>weakSelf</code> 替代。</p>\n<h3 id=\"第31条：在dealloc方法中只释放引用并解除监听\"><a href=\"#第31条：在dealloc方法中只释放引用并解除监听\" class=\"headerlink\" title=\"第31条：在dealloc方法中只释放引用并解除监听\"></a>第31条：在dealloc方法中只释放引用并解除监听</h3><p>对象在经历生命期后，最终会被系统回收，这里就是执行 <code>dealloc</code> 方法了。永远不要自己调用 <code>dealloc</code> 方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在 <code>dealloc</code> 方法中做一些操作。那么我们可以在 <code>dealloc</code> 方法里做什么呢？</p>\n<ul>\n<li>释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。</li>\n<li>对象拥有的其他非OC对象也要释放（CoreFoundation 对象就必须手动释放）</li>\n<li>释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。</li>\n</ul>\n<p>例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\">     <span class=\"built_in\">CFRelease</span>(coreFoundationObject);</div><div class=\"line\">    [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除了释放引用和注销通知，不要在 <code>dealloc</code> 中做其他任何事（比如调用属性的存取方法，以及异步操作）。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类要和使用者约定，用完资源后必须调用 <code>close</code> 方法。</p>\n<h3 id=\"第32条：编写“异常安全代码”时留意内存管理问题\"><a href=\"#第32条：编写“异常安全代码”时留意内存管理问题\" class=\"headerlink\" title=\"第32条：编写“异常安全代码”时留意内存管理问题\"></a>第32条：编写“异常安全代码”时留意内存管理问题</h3><p>在发生异常时的内存管理需要仔细考虑内存管理的问题：在 try 块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在 catch 块中能处理此问题，否则对象所占内存就将泄漏。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@try</span> &#123;</div><div class=\"line\">     EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class=\"line\">     [object doSomethingThatMayThrow];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@catch</span> (...) &#123;</div><div class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Whoops, there was an error. Oh well...\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是在 ARC 状态下，我们不能手动释放对象，解决办法是使用：<code>-fobjc-arc-exceptions</code> 标志来让系统自动加入清理代码，不过会导致应用程序变大，而且会降低运行效率。</p>\n<h3 id=\"第33条：以弱引用避免保留环\"><a href=\"#第33条：以弱引用避免保留环\" class=\"headerlink\" title=\"第33条：以弱引用避免保留环\"></a>第33条：以弱引用避免保留环</h3><p>对象之间都用强指针引用对方的话会造成保留环。如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。不像 Java 那种处理方式，OC 中孤立的保留环不能被自动释放。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/effective_oc1.png?raw=true\" alt=\"保留环\"></p>\n<p>那么就要用弱引用的方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//EOCClassB.m</span></div><div class=\"line\"><span class=\"comment\">//第一种弱引用：unsafe_unretained</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">unsafe_unretained</span>) EOCClassA *other;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二种弱引用：weak</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) EOCClassA *other;</div></pre></td></tr></table></figure>\n<p>这两种弱引用有什么区别呢？<br>当指向 <code>EOCClassA</code> 实例的引用移除后，<code>unsafe_unretained</code> 属性仍然指向那个已经回收的实例，而 <code>weak</code> 指向 <code>nil</code>。显然，用 <code>weak</code> 字段应该是更安全的，因为不再使用的对象按理说应该设置为 <code>nil</code>,而不应该产生依赖。</p>\n<p>所以只要用 <code>weak</code> 就行了。</p>\n<h3 id=\"第34条：以“自动释放池快”降低内存峰值\"><a href=\"#第34条：以“自动释放池快”降低内存峰值\" class=\"headerlink\" title=\"第34条：以“自动释放池快”降低内存峰值\"></a>第34条：以“自动释放池快”降低内存峰值</h3><p>这个部分在 <code>runloop</code> 相关文章中有学习过。主要用的是这样一个例子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span> doSomethingWithInt:i];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于线程自动释放池在 event loop 时，进行清空，上面的代码将可能造成内存峰值。因此，可以手动添加一个自动释放池，把循环内的代码包裹在内，那么循环中自动释放的独享就会在这个池中，而不是在线程的主池中。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *databaseRecords = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSMutableArray</span> *people = [<span class=\"built_in\">NSMutableArray</span> new];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *record <span class=\"keyword\">in</span> databaseRecords) &#123;</div><div class=\"line\">     <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class=\"line\">            [people addObject:person];</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第35条：用“僵尸对象”调试内存管理问题\"><a href=\"#第35条：用“僵尸对象”调试内存管理问题\" class=\"headerlink\" title=\"第35条：用“僵尸对象”调试内存管理问题\"></a>第35条：用“僵尸对象”调试内存管理问题</h3><p>某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。如果程序没有崩溃，可能是因为：</p>\n<ul>\n<li>该内存的部分原数据没有被覆写。</li>\n<li>该内存恰好被另一个对象占据，而这个对象可以应答这个方法。</li>\n</ul>\n<p>如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。因此，我们希望可以通过一种方法捕捉到对象被释放后收到消息的情况。这种方法就是利用僵尸对象！</p>\n<p>Cocoa 提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改 isa 指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。</p>\n<p>(感觉好像没什么用的样子，不知道这和让程序直接 crash 比，有什么优势)</p>\n<h3 id=\"第36条：不要使用retainCount\"><a href=\"#第36条：不要使用retainCount\" class=\"headerlink\" title=\"第36条：不要使用retainCount\"></a>第36条：不要使用retainCount</h3><p>ARC 后，这个 <code>retainCount</code> 方法就废弃了。反正从来没用过，也就没啥好看的了。</p>\n<h2 id=\"块与大小枢派发\"><a href=\"#块与大小枢派发\" class=\"headerlink\" title=\"块与大小枢派发\"></a>块与大小枢派发</h2><h3 id=\"第37条：理解“块”这一概念\"><a href=\"#第37条：理解“块”这一概念\" class=\"headerlink\" title=\"第37条：理解“块”这一概念\"></a>第37条：理解“块”这一概念</h3><p>基本概念无需多说，这里强调一下块的种类。</p>\n<p>块分为三类：</p>\n<ul>\n<li>栈块</li>\n<li>堆块</li>\n<li>全局块</li>\n</ul>\n<h4 id=\"栈块\"><a href=\"#栈块\" class=\"headerlink\" title=\"栈块\"></a>栈块</h4><p>这是比较容易被忽略的一块。定义块的时候，其所占内存区域是<strong>分配在栈中</strong>的，而且只在定义它的那个范围内有效：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"comment\">/* some condition */</span> ) &#123;</div><div class=\"line\">    block = ^&#123;</div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block A\"</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    block = ^&#123;</div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block B\"</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">block();</div></pre></td></tr></table></figure>\n<p>上面定义的两个块只在 <code>if else</code> 语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。</p>\n<p>并不明白把块保存在栈上是个什么机制。应该可以这么理解吧:<code>block</code> 是一个指向栈上内存的指针，栈和堆的引用机制不同，在代码块运行结束后就会将代码块中的局部变量出栈，这个时候 <code>block</code> 指向的地方就被回收，<code>block</code> 就成了野指针，因此就会 crash 了。</p>\n<p>一般情况下，我们平时要么就定义完就传出去了，要么就把 <code>block</code> 定义成了类的属性，所以就没有发生过这种情况。 </p>\n<h4 id=\"堆块\"><a href=\"#堆块\" class=\"headerlink\" title=\"堆块\"></a>堆块</h4><p>平时对块的操作肯定不能以栈块的形式来存储啊。堆块，要在原来的基础上执行 <code>copy</code>，让代码保存在堆上。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^block)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"comment\">/* some condition */</span> ) &#123;</div><div class=\"line\">    block = [^&#123;</div><div class=\"line\">         <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block A\"</span>);</div><div class=\"line\">   &#125; <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    block = [^&#123;</div><div class=\"line\">         <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Block B\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">copy</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">block();</div></pre></td></tr></table></figure>\n<p>至于 <code>copy</code> 怎么让栈上的东西保存到堆上就不得而知了，反正就是保存过去了。然后 <code>block</code> 就能指向堆上的地址了。</p>\n<p>平时我们用属性方式保存块的时候都是这样声明的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) Block block;</div></pre></td></tr></table></figure>\n<p>这个属性里暗含了 <code>copy</code> 操作了。</p>\n<h4 id=\"全局块\"><a href=\"#全局块\" class=\"headerlink\" title=\"全局块\"></a>全局块</h4><p>在全局内存里声明的就是全局块，没用过。不知道有什么好处。</p>\n<h3 id=\"第38条：为常用的块类型创建typedef\"><a href=\"#第38条：为常用的块类型创建typedef\" class=\"headerlink\" title=\"第38条：为常用的块类型创建typedef\"></a>第38条：为常用的块类型创建typedef</h3><p>如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> (^variableName)(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value) =^(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value)&#123;</div><div class=\"line\">     <span class=\"comment\">// Implementation</span></div><div class=\"line\">     <span class=\"keyword\">return</span> someInt;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler: (<span class=\"keyword\">void</span>(^)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSError</span> *error))completion;</div></pre></td></tr></table></figure>\n<p>这个块有一个 bool 参数和一个 int 参数，并返回 int 类型。我们可以给它定义类型：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span>(^EOCSomeBlock)(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value);</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^EOCCompletionHandler)(<span class=\"built_in\">NSData</span> *data, <span class=\"built_in\">NSError</span> *error);</div><div class=\"line\"></div><div class=\"line\">EOCSomeBlock block = ^(<span class=\"built_in\">BOOL</span> flag, <span class=\"keyword\">int</span> value)&#123;</div><div class=\"line\">     <span class=\"comment\">// Implementation</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startWithCompletionHandler:(EOCCompletionHandler)completion;</div></pre></td></tr></table></figure>\n<h3 id=\"第39条：用handler块降低代码分散程度\"><a href=\"#第39条：用handler块降低代码分散程度\" class=\"headerlink\" title=\"第39条：用handler块降低代码分散程度\"></a>第39条：用handler块降低代码分散程度</h3><p>可以通过块的方式代替代理模式。</p>\n<p>代理模式主要是为了让其他类在必要时候调用自己类的方法。而使用块的方式可以直接将方法内容作为参数或者属性传入调用块。这样设计业务逻辑更加直观清晰。</p>\n<h3 id=\"第40条：用块引用其所属对象时不要出现保留环\"><a href=\"#第40条：用块引用其所属对象时不要出现保留环\" class=\"headerlink\" title=\"第40条：用块引用其所属对象时不要出现保留环\"></a>第40条：用块引用其所属对象时不要出现保留环</h3><p>注意使用块的时候不要产生保留环，要在块执行完成后，将块置为 <code>nil</code>。</p>\n<h3 id=\"第41条：多用派发队列，少用同步锁\"><a href=\"#第41条：多用派发队列，少用同步锁\" class=\"headerlink\" title=\"第41条：多用派发队列，少用同步锁\"></a>第41条：多用派发队列，少用同步锁</h3><p>多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用 GCD 来为代码加锁的方式解决这个问题。</p>\n<h4 id=\"方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\"><a href=\"#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\" class=\"headerlink\" title=\"方案一：使用串行同步队列来将读写操作都安排到同一个队列里：\"></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">_syncQueue = dispatch_queue_create(<span class=\"string\">\"com.effectiveobjectivec.syncQueue\"</span>, <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取字符串</span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSString</span> *localSomeString;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">        localSomeString = _someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> localSomeString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置字符串</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">        _someString = someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里，用了一个串行队列，保证了读写操作都加了锁，是一种解决方式。但是，我们要明确一点，数据的正确性主要取决于写入操作，只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。因此，我们要加以改进，读操作并行，写操作串行。可以通过  <code>dispatch_barrier_async</code>、<code>dispatch_barrier_sync</code> 完成。</p>\n<h4 id=\"将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\"><a href=\"#将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\" class=\"headerlink\" title=\"将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行\"></a>将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行</h4><p>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行。并发队列如果发现接下来要处理的块是个栅栏块，那么就一直等到当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。<strong>相当于给并行队列里加个锁</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//读取字符串</span></div><div class=\"line\">- (<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\">    __block <span class=\"built_in\">NSString</span> *localSomeString;</div><div class=\"line\">    <span class=\"built_in\">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class=\"line\">       localSomeString = _someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> localSomeString;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置字符串</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setSomeString:(<span class=\"built_in\">NSString</span>*)someString &#123;</div><div class=\"line\"></div><div class=\"line\">    dispatch_barrier_async(_syncQueue, ^&#123;</div><div class=\"line\">        _someString = someString;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里解释下为什么读取用的是 <code>sync</code>，写入用的是 <code>async</code>，因为读取是要有返回值的，要将值返回给调用的对象，总不能还没有拿到值，就已经 <code>return</code> 了吧；而写入操作没有返回值，那么就让它立即 <code>return</code> 执行后面的代码，另开线程写入。</p>\n<h3 id=\"第42条：多用GCD，少用performSelector系列方法\"><a href=\"#第42条：多用GCD，少用performSelector系列方法\" class=\"headerlink\" title=\"第42条：多用GCD，少用performSelector系列方法\"></a>第42条：多用GCD，少用performSelector系列方法</h3><p>在iOS开发中，有时会使用 <code>performSelector</code> 来执行某个方法，但是 <code>performSelector</code> 系列的方法能处理的选择子很局限，最好使用 GCD：</p>\n<ul>\n<li>它无法处理带有多个参数的选择子（有最多支持两个选择子的方法）</li>\n<li>返回值只能是void或者对象类型</li>\n<li>会引起内存泄露</li>\n</ul>\n<p>但是如果将方法放在块中，通过 GCD 来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 <code>performSelector</code> 方法。</p>\n<h4 id=\"延后执行某个任务的方法\"><a href=\"#延后执行某个任务的方法\" class=\"headerlink\" title=\"延后执行某个任务的方法\"></a>延后执行某个任务的方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用 performSelector:withObject:afterDelay:</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(doSomething) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">5.0</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 dispatch_after</span></div><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">5.0</span> * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomething];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"将任务放在主线程执行\"><a href=\"#将任务放在主线程执行\" class=\"headerlink\" title=\"将任务放在主线程执行\"></a>将任务放在主线程执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 使用 performSelectorOnMainThread:withObject:waitUntilDone:</div><div class=\"line\">[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 使用 dispatch_async</div><div class=\"line\">// (or if waitUntilDone is YES, then dispatch_sync)</div><div class=\"line\">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        [self doSomething];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果 <code>waitUntilDone</code> 的参数是 <code>Yes</code>，那么就对应 GCD 的 <code>dispatch_sync</code> 方法。我们可以看到，使用 GCD 的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。</p>\n<h3 id=\"第43条：掌握GCD及操作队列的使用时机\"><a href=\"#第43条：掌握GCD及操作队列的使用时机\" class=\"headerlink\" title=\"第43条：掌握GCD及操作队列的使用时机\"></a>第43条：掌握GCD及操作队列的使用时机</h3><p>除了 GCD，<strong>操作队列（NSOperationQueue）</strong>也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用 GCD 好些，有时则是使用操作队列更加合理。（并不清楚操作队列怎么用的，反正就抄一下哪里好）</p>\n<ul>\n<li>可以取消操作：在运行任务前，可以在NSOperation对象调用 <code>cancel</code> 方法，标明此任务不需要执行。但是 GCD 队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>\n<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>\n<li>监控 <code>NSOperation</code> 对象的属性：可以通过 KVO 来监听 <code>NSOperation</code> 的属性：可以通过 <code>isCancelled</code> 属性来判断任务是否已取消；通过 <code>isFinished</code> 属性来判断任务是否已经完成。</li>\n<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>\n</ul>\n<h3 id=\"第44条：通过Dispath-Group机制，根据系统资源状况来执行任务\"><a href=\"#第44条：通过Dispath-Group机制，根据系统资源状况来执行任务\" class=\"headerlink\" title=\"第44条：通过Dispath Group机制，根据系统资源状况来执行任务\"></a>第44条：通过Dispath Group机制，根据系统资源状况来执行任务</h3><p>有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用 <code>dispath group</code> 函数来实现这个需求：</p>\n<p>通过 <code>dispath group</code> 函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个优先级低的并发队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//一个优先级高的并发队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建dispatch_group</span></div><div class=\"line\">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将优先级低的队列放入dispatch_group</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> lowPriorityObjects) &#123;</div><div class=\"line\"> dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将优先级高的队列放入dispatch_group</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> highPriorityObjects) &#123;</div><div class=\"line\"> dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//dispatch_group里的任务都结束后调用块中的代码</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> notifyQueue = dispatch_get_main_queue();</div><div class=\"line\">dispatch_group_notify(dispatchGroup,notifyQueue,^&#123;</div><div class=\"line\">     <span class=\"comment\">// Continue processing after completing tasks</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>想要更详细的了解，还是看之前的 GCD 介绍文章吧。</p>\n<h3 id=\"第45条：使用dispatch-once来执行只需运行一次的线程安全代码\"><a href=\"#第45条：使用dispatch-once来执行只需运行一次的线程安全代码\" class=\"headerlink\" title=\"第45条：使用dispatch_once来执行只需运行一次的线程安全代码\"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h3><p>有时我们可能只需要将某段代码执行一次，这时可以通过 <code>dispatch_once</code> 函数来解决。</p>\n<p><code>dispatch_once</code> 函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用 <code>dispatch_once</code> 函数来令初始化代码只执行一次，并且内部是线程安全的。</p>\n<p>而且，对于执行一次的 <code>block</code> 来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在 <code>static</code> 或 <code>global</code> 作用域里。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">id</span>)sharedInstance &#123;</div><div class=\"line\">     <span class=\"keyword\">static</span> EOCClass *sharedInstance = <span class=\"literal\">nil</span>;</div><div class=\"line\">     <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\">     <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">﻿            sharedInstance = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">     <span class=\"keyword\">return</span> sharedInstance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"第46条：不要使用dispatch-get-current-queue\"><a href=\"#第46条：不要使用dispatch-get-current-queue\" class=\"headerlink\" title=\"第46条：不要使用dispatch_get_current_queue\"></a>第46条：不要使用dispatch_get_current_queue</h3><p>已经被废弃的 API，不说了。</p>\n<h2 id=\"系统框架\"><a href=\"#系统框架\" class=\"headerlink\" title=\"系统框架\"></a>系统框架</h2><h3 id=\"第47条：熟悉系统框架\"><a href=\"#第47条：熟悉系统框架\" class=\"headerlink\" title=\"第47条：熟悉系统框架\"></a>第47条：熟悉系统框架</h3><p>主要的系统框架：</p>\n<ul>\n<li>Foundation  :NSObject,NSArray,NSDictionary 等</li>\n<li>CFoundation :C 语言 API，Foundation 框架中的许多功能，都可以在这里找到对应的 C 语言 API</li>\n<li>CFNetwork   :C 语言 API，提供了 C 语言级别的网络通信能力 </li>\n<li>CoreAudio   :C 语言 API，操作设备上的音频硬件</li>\n<li>AVFoundation:提供的 OC 对象可以回放并录制音频和视频</li>\n<li>CoreData    :OC 的 API，将对象写入数据库</li>\n<li>CoreText    :C 语言 API，高效执行文字排版和渲染操作</li>\n</ul>\n<h3 id=\"第48条：多用块枚举，少用for循环\"><a href=\"#第48条：多用块枚举，少用for循环\" class=\"headerlink\" title=\"第48条：多用块枚举，少用for循环\"></a>第48条：多用块枚举，少用for循环</h3><h4 id=\"传统的for遍历\"><a href=\"#传统的for遍历\" class=\"headerlink\" title=\"传统的for遍历\"></a>传统的for遍历</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *anArray = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; anArray.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> object = anArray[i];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Dictionary</span></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *aDictionary = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *keys = [aDictionary allKeys];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; keys.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> key = keys[i];</div><div class=\"line\">   <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'key' and 'value'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set</span></div><div class=\"line\"><span class=\"built_in\">NSSet</span> *aSet = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"built_in\">NSArray</span> *objects = [aSet allObjects];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; objects.count; i++) &#123;</div><div class=\"line\">   <span class=\"keyword\">id</span> object = objects[i];</div><div class=\"line\">   <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，在遍历 NSDictionary,和 NSet 时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>\n<h4 id=\"利用快速遍历\"><a href=\"#利用快速遍历\" class=\"headerlink\" title=\"利用快速遍历\"></a>利用快速遍历</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *anArray = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> anArray) &#123;</div><div class=\"line\"> <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Dictionary</span></div><div class=\"line\"><span class=\"built_in\">NSDictionary</span> *aDictionary = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> key <span class=\"keyword\">in</span> aDictionary) &#123;</div><div class=\"line\"> <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\"> <span class=\"comment\">// Do something with 'key' and 'value'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSSet</span> *aSet = <span class=\"comment\">/* ... */</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">id</span> object <span class=\"keyword\">in</span> aSet) &#123;</div><div class=\"line\"> <span class=\"comment\">// Do something with 'object'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>\n<h4 id=\"利用基于块（block）的遍历\"><a href=\"#利用基于块（block）的遍历\" class=\"headerlink\" title=\"利用基于块（block）的遍历\"></a>利用基于块（block）的遍历</h4><p>其实我觉得没啥用，不看也罢。</p>\n<h3 id=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"><a href=\"#第49条：对自定义其内存管理语义的collection使用无缝桥接\" class=\"headerlink\" title=\"第49条：对自定义其内存管理语义的collection使用无缝桥接\"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h3><p>通过无缝桥接技术，可以在 Foundation 框架中的 OC 对象和 CoreFoundation 框架中的 C 语言数据结构之间来回转换。</p>\n<p>为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。</p>\n<p>具体怎么用，用在什么场景呢？ 没看懂。呵呵</p>\n<h3 id=\"第50条：构建缓存时选用-NSCache-而非-NSDictionary\"><a href=\"#第50条：构建缓存时选用-NSCache-而非-NSDictionary\" class=\"headerlink\" title=\"第50条：构建缓存时选用 NSCache 而非 NSDictionary\"></a>第50条：构建缓存时选用 NSCache 而非 NSDictionary</h3><p>不知道有啥用，用到时候再说。</p>\n<h3 id=\"第51条-精简initialize-与-load的实现代码\"><a href=\"#第51条-精简initialize-与-load的实现代码\" class=\"headerlink\" title=\"第51条: 精简initialize 与 load的实现代码\"></a>第51条: 精简initialize 与 load的实现代码</h3><p>每个类和分类在<strong>加入运行期系统时</strong>，都会调用 <code>load</code> 方法，而且仅仅调用一次。<code>load</code> 方法不遵循继承规则，某个类本身没有重写 <code>load</code>，那也不会调用超类的 <code>load</code> 方法。可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。</p>\n<p><code>initialize</code> 方法与 <code>load</code> 方法类似，区别是这个方法会在程序首次调用这个类的时候调用（<strong>惰性调用</strong>），而且只调用一次（绝对不能主动使用代码调用）。如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码。如果在 <code>initialize</code> 方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在 <code>initialize</code> 方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的 bug。</p>\n<h3 id=\"第52条-别忘了NSTimer会保留其目标对象\"><a href=\"#第52条-别忘了NSTimer会保留其目标对象\" class=\"headerlink\" title=\"第52条: 别忘了NSTimer会保留其目标对象\"></a>第52条: 别忘了NSTimer会保留其目标对象</h3><p>在使用 <code>NSTimer</code> 的时候，<code>NSTimer</code> 会生成指向其使用者的引用，而其使用者如果也引用了 <code>NSTimer</code>，那么就会生成保留环。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">EOCClass</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startPolling;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)stopPolling;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">EOCClass</span> </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">NSTimer</span> *_pollTimer;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> init];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</div><div class=\"line\">    [_pollTimer invalidate];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)stopPolling &#123;</div><div class=\"line\"></div><div class=\"line\">    [_pollTimer invalidate];</div><div class=\"line\">    _pollTimer = <span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startPolling &#123;</div><div class=\"line\">   _pollTimer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">5.0</span></div><div class=\"line\">                                                 target:<span class=\"keyword\">self</span></div><div class=\"line\">                                               selector:<span class=\"keyword\">@selector</span>(p_doPoll)</div><div class=\"line\">                                               userInfo:<span class=\"literal\">nil</span></div><div class=\"line\">                                                repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)p_doPoll &#123;</div><div class=\"line\">    <span class=\"comment\">// Poll the resource</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这里可以看到 <code>EOCClass</code> 和 <code>_pollTimer</code> 之间由于 <code>target:self</code> 的存在，相互形成了保留环，如果不主动调用 <code>stopPolling</code> 方法将 <code>_pollTimer</code>取消并清空就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。这可能是一个极其危险的情况，因为 NSTimer 没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。</p>\n<p>那么如何解决呢？</p>\n<p>我觉得文章里举的方法简直脱裤子放屁，所以就不列出来了。直接将 <code>target:self</code> 设置成 <code>target:weakSelf</code> 不就行了？</p>"},{"title":"从 setTimeout() 看js的 Event Loop 执行过程","date":"2016-12-28T02:07:12.000Z","_content":"\n通过 `setTimeout()` 方法，来了解 js 中的代码执行。本文参照[干货 | 原来你是这样的 setTimeout](https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&mid=2649515867&idx=1&sn=971a3e41da08ddf2da200d9d07af0fb0&chksm=f1efe7d0c6986ec688a746ece15f52c8df78bca37ca2609e75199f5c3fbbabd3fbcc00179885&scene=0&key=564c3e9811aee0abcc036cb111e6e7bdbe3938a8756b5bf3b98a1696b2f16c1e6e3a1b4af159d1ae1dd3e71ee5fae4e0b6655bd9f37cc81efb1174bf3ef39b43f874bc6a0482348422cc5245dfae917f&ascene=0&uin=MzIxNTY1NTU%3D&devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.12.1+build(16B2555)&version=12010210&nettype=WIFI&fontScale=100&pass_ticket=g24dIjS%2F70EF4QPCYwRMInMa218z6XagvevxLr5Mbzc%3D)\n\n<!--more-->\n\n## Event Loop\nJs 引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的，但是实际开发中我们却可以使用异步代码来解决。Js 为了引入异步的特性，引申出一个重要的东西，Event Loop（事件循环）。\n\n当异步方法，比如 `setTimeout()` 执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。\n\n## 第一个 setTimeout 例子\n### 例子\n```javascript\nconsole.log('start');\n\nsetTimeout(() => {\n    console.log('hello');\n},300);\n\nsetTimeout(()=>{\n    console.log('world');\n},200);\n\nconsole.log('end');\n```\n\n运行结果为：\n```\nstart\nend\nworld\nhello\n```\n\n### 过程\n首先第一个 `console.log()` 入栈执行，执行完毕控制台打印 `start` 后出栈，紧接着执行到 `setTimeout` 定时器，此时 JS 引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做 Timer 模块），然后主线程继续向下执行，紧接着将第二个定时器也交给 Timer 模块，然后执行到第二个 `console.log()`，控制台打印 `end`，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer 模块会检查其中的异步代码，**一旦满足触发条件，就会将它添加到任务队列中**(注意，是满足触发条件了再放到任务队列中)。Timer2 延迟 200ms，所以会早于 Timer1 被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将 Timer2 回调中的 `console.log()` 执行，控制台打印 `world`，然后执行栈空闲后继续检查任务队列，将 Timer1 的代码压入执行栈中执行，控制台打印 `hello`，清空执行栈，此时任务队列为空，执行结束。\n\n##第二个 setTimeout 例子\n### 例子\n```javascript\nconsole.log('start');\n\nsetTimeout(() => {\n    console.log('hello');\n},300);\n\nsetTimeout(()=>{\n    console.log('world');\n},200);\n\nfor (var i=0;i<100000;i++){\n    console.log(1)\n}\n\nsetTimeout(()=>{\n    console.log('i am run');\n},100);\n\nconsole.log('end');\n```\n\n结果：\n```\nstart\n...\nend\nhello\nworld\nI am run\n```\n\n### 过程\nTimer3 仅仅延迟了 100ms，反而在另外两个 Timer 之后执行了。其实这里原因很简单，因为在 Timer1 和 Timer2 加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的 Timer1 和 Timer2 并不会得以执行。**当for循环结束，这时才将 Timer3 交由 Timer 模块去管理**(注意，代码顺序执行，for循环的时候， Timer3 的 `setTimeout()` 还没有执行，所以也就还没有被 Timer 模块管理)，继续执行后续代码打印 `end`，清空执行栈。虽然在这里 Timer3 的延迟时间最短，但是**加入任务队列后**还是会排在 Timer1 和 Timer2 的后面，所以此时按**顺序执行任务队列中的代码**，依次打印。\n\n需要注意的是，执行完 `console.log('end');` 后，立刻执行了 Timer1 和 Timer2，但是 Timer3 执行时间约在之后 100ms，这是因为for循环执行的时间超过了300ms。如果for循环在100ms以内完成，那么 `console.log('i am run');` 仍然是最先执行的。如果for循环在100ms到200ms之间，那么 `console.log('i am run');` 在 `console.log('world');` 之后，`console.log('hello');` 之间执行。\n","source":"_posts/EventLoop.md","raw":"title: 从 setTimeout() 看js的 Event Loop 执行过程 \ndate: 2016/12/28 10:07:12 \ncategories: Javascript\ntags:\n\t- Principle\n\n---\n\n通过 `setTimeout()` 方法，来了解 js 中的代码执行。本文参照[干货 | 原来你是这样的 setTimeout](https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&mid=2649515867&idx=1&sn=971a3e41da08ddf2da200d9d07af0fb0&chksm=f1efe7d0c6986ec688a746ece15f52c8df78bca37ca2609e75199f5c3fbbabd3fbcc00179885&scene=0&key=564c3e9811aee0abcc036cb111e6e7bdbe3938a8756b5bf3b98a1696b2f16c1e6e3a1b4af159d1ae1dd3e71ee5fae4e0b6655bd9f37cc81efb1174bf3ef39b43f874bc6a0482348422cc5245dfae917f&ascene=0&uin=MzIxNTY1NTU%3D&devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.12.1+build(16B2555)&version=12010210&nettype=WIFI&fontScale=100&pass_ticket=g24dIjS%2F70EF4QPCYwRMInMa218z6XagvevxLr5Mbzc%3D)\n\n<!--more-->\n\n## Event Loop\nJs 引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的，但是实际开发中我们却可以使用异步代码来解决。Js 为了引入异步的特性，引申出一个重要的东西，Event Loop（事件循环）。\n\n当异步方法，比如 `setTimeout()` 执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。\n\n## 第一个 setTimeout 例子\n### 例子\n```javascript\nconsole.log('start');\n\nsetTimeout(() => {\n    console.log('hello');\n},300);\n\nsetTimeout(()=>{\n    console.log('world');\n},200);\n\nconsole.log('end');\n```\n\n运行结果为：\n```\nstart\nend\nworld\nhello\n```\n\n### 过程\n首先第一个 `console.log()` 入栈执行，执行完毕控制台打印 `start` 后出栈，紧接着执行到 `setTimeout` 定时器，此时 JS 引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做 Timer 模块），然后主线程继续向下执行，紧接着将第二个定时器也交给 Timer 模块，然后执行到第二个 `console.log()`，控制台打印 `end`，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer 模块会检查其中的异步代码，**一旦满足触发条件，就会将它添加到任务队列中**(注意，是满足触发条件了再放到任务队列中)。Timer2 延迟 200ms，所以会早于 Timer1 被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将 Timer2 回调中的 `console.log()` 执行，控制台打印 `world`，然后执行栈空闲后继续检查任务队列，将 Timer1 的代码压入执行栈中执行，控制台打印 `hello`，清空执行栈，此时任务队列为空，执行结束。\n\n##第二个 setTimeout 例子\n### 例子\n```javascript\nconsole.log('start');\n\nsetTimeout(() => {\n    console.log('hello');\n},300);\n\nsetTimeout(()=>{\n    console.log('world');\n},200);\n\nfor (var i=0;i<100000;i++){\n    console.log(1)\n}\n\nsetTimeout(()=>{\n    console.log('i am run');\n},100);\n\nconsole.log('end');\n```\n\n结果：\n```\nstart\n...\nend\nhello\nworld\nI am run\n```\n\n### 过程\nTimer3 仅仅延迟了 100ms，反而在另外两个 Timer 之后执行了。其实这里原因很简单，因为在 Timer1 和 Timer2 加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的 Timer1 和 Timer2 并不会得以执行。**当for循环结束，这时才将 Timer3 交由 Timer 模块去管理**(注意，代码顺序执行，for循环的时候， Timer3 的 `setTimeout()` 还没有执行，所以也就还没有被 Timer 模块管理)，继续执行后续代码打印 `end`，清空执行栈。虽然在这里 Timer3 的延迟时间最短，但是**加入任务队列后**还是会排在 Timer1 和 Timer2 的后面，所以此时按**顺序执行任务队列中的代码**，依次打印。\n\n需要注意的是，执行完 `console.log('end');` 后，立刻执行了 Timer1 和 Timer2，但是 Timer3 执行时间约在之后 100ms，这是因为for循环执行的时间超过了300ms。如果for循环在100ms以内完成，那么 `console.log('i am run');` 仍然是最先执行的。如果for循环在100ms到200ms之间，那么 `console.log('i am run');` 在 `console.log('world');` 之后，`console.log('hello');` 之间执行。\n","slug":"EventLoop","published":1,"updated":"2016-12-28T06:49:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dop000h7hzgeyvnz4sz","content":"<p>通过 <code>setTimeout()</code> 方法，来了解 js 中的代码执行。本文参照<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649515867&amp;idx=1&amp;sn=971a3e41da08ddf2da200d9d07af0fb0&amp;chksm=f1efe7d0c6986ec688a746ece15f52c8df78bca37ca2609e75199f5c3fbbabd3fbcc00179885&amp;scene=0&amp;key=564c3e9811aee0abcc036cb111e6e7bdbe3938a8756b5bf3b98a1696b2f16c1e6e3a1b4af159d1ae1dd3e71ee5fae4e0b6655bd9f37cc81efb1174bf3ef39b43f874bc6a0482348422cc5245dfae917f&amp;ascene=0&amp;uin=MzIxNTY1NTU%3D&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.12.1+build(16B2555\" target=\"_blank\" rel=\"external\">干货 | 原来你是这样的 setTimeout</a>&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=g24dIjS%2F70EF4QPCYwRMInMa218z6XagvevxLr5Mbzc%3D)</p>\n<a id=\"more\"></a>\n<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>Js 引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的，但是实际开发中我们却可以使用异步代码来解决。Js 为了引入异步的特性，引申出一个重要的东西，Event Loop（事件循环）。</p>\n<p>当异步方法，比如 <code>setTimeout()</code> 执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。</p>\n<h2 id=\"第一个-setTimeout-例子\"><a href=\"#第一个-setTimeout-例子\" class=\"headerlink\" title=\"第一个 setTimeout 例子\"></a>第一个 setTimeout 例子</h2><h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">end</div><div class=\"line\">world</div><div class=\"line\">hello</div></pre></td></tr></table></figure></p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>首先第一个 <code>console.log()</code> 入栈执行，执行完毕控制台打印 <code>start</code> 后出栈，紧接着执行到 <code>setTimeout</code> 定时器，此时 JS 引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做 Timer 模块），然后主线程继续向下执行，紧接着将第二个定时器也交给 Timer 模块，然后执行到第二个 <code>console.log()</code>，控制台打印 <code>end</code>，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer 模块会检查其中的异步代码，<strong>一旦满足触发条件，就会将它添加到任务队列中</strong>(注意，是满足触发条件了再放到任务队列中)。Timer2 延迟 200ms，所以会早于 Timer1 被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将 Timer2 回调中的 <code>console.log()</code> 执行，控制台打印 <code>world</code>，然后执行栈空闲后继续检查任务队列，将 Timer1 的代码压入执行栈中执行，控制台打印 <code>hello</code>，清空执行栈，此时任务队列为空，执行结束。</p>\n<p>##第二个 setTimeout 例子</p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">100000</span>;i++)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am run'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">...</div><div class=\"line\">end</div><div class=\"line\">hello</div><div class=\"line\">world</div><div class=\"line\">I am run</div></pre></td></tr></table></figure></p>\n<h3 id=\"过程-1\"><a href=\"#过程-1\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>Timer3 仅仅延迟了 100ms，反而在另外两个 Timer 之后执行了。其实这里原因很简单，因为在 Timer1 和 Timer2 加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的 Timer1 和 Timer2 并不会得以执行。<strong>当for循环结束，这时才将 Timer3 交由 Timer 模块去管理</strong>(注意，代码顺序执行，for循环的时候， Timer3 的 <code>setTimeout()</code> 还没有执行，所以也就还没有被 Timer 模块管理)，继续执行后续代码打印 <code>end</code>，清空执行栈。虽然在这里 Timer3 的延迟时间最短，但是<strong>加入任务队列后</strong>还是会排在 Timer1 和 Timer2 的后面，所以此时按<strong>顺序执行任务队列中的代码</strong>，依次打印。</p>\n<p>需要注意的是，执行完 <code>console.log(&#39;end&#39;);</code> 后，立刻执行了 Timer1 和 Timer2，但是 Timer3 执行时间约在之后 100ms，这是因为for循环执行的时间超过了300ms。如果for循环在100ms以内完成，那么 <code>console.log(&#39;i am run&#39;);</code> 仍然是最先执行的。如果for循环在100ms到200ms之间，那么 <code>console.log(&#39;i am run&#39;);</code> 在 <code>console.log(&#39;world&#39;);</code> 之后，<code>console.log(&#39;hello&#39;);</code> 之间执行。</p>\n","excerpt":"<p>通过 <code>setTimeout()</code> 方法，来了解 js 中的代码执行。本文参照<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTE2NTE1Ng==&amp;mid=2649515867&amp;idx=1&amp;sn=971a3e41da08ddf2da200d9d07af0fb0&amp;chksm=f1efe7d0c6986ec688a746ece15f52c8df78bca37ca2609e75199f5c3fbbabd3fbcc00179885&amp;scene=0&amp;key=564c3e9811aee0abcc036cb111e6e7bdbe3938a8756b5bf3b98a1696b2f16c1e6e3a1b4af159d1ae1dd3e71ee5fae4e0b6655bd9f37cc81efb1174bf3ef39b43f874bc6a0482348422cc5245dfae917f&amp;ascene=0&amp;uin=MzIxNTY1NTU%3D&amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.12.1+build(16B2555\">干货 | 原来你是这样的 setTimeout</a>&amp;version=12010210&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=g24dIjS%2F70EF4QPCYwRMInMa218z6XagvevxLr5Mbzc%3D)</p>","more":"<h2 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h2><p>Js 引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的，但是实际开发中我们却可以使用异步代码来解决。Js 为了引入异步的特性，引申出一个重要的东西，Event Loop（事件循环）。</p>\n<p>当异步方法，比如 <code>setTimeout()</code> 执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。</p>\n<h2 id=\"第一个-setTimeout-例子\"><a href=\"#第一个-setTimeout-例子\" class=\"headerlink\" title=\"第一个 setTimeout 例子\"></a>第一个 setTimeout 例子</h2><h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>运行结果为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">end</div><div class=\"line\">world</div><div class=\"line\">hello</div></pre></td></tr></table></figure></p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>首先第一个 <code>console.log()</code> 入栈执行，执行完毕控制台打印 <code>start</code> 后出栈，紧接着执行到 <code>setTimeout</code> 定时器，此时 JS 引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做 Timer 模块），然后主线程继续向下执行，紧接着将第二个定时器也交给 Timer 模块，然后执行到第二个 <code>console.log()</code>，控制台打印 <code>end</code>，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer 模块会检查其中的异步代码，<strong>一旦满足触发条件，就会将它添加到任务队列中</strong>(注意，是满足触发条件了再放到任务队列中)。Timer2 延迟 200ms，所以会早于 Timer1 被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将 Timer2 回调中的 <code>console.log()</code> 执行，控制台打印 <code>world</code>，然后执行栈空闲后继续检查任务队列，将 Timer1 的代码压入执行栈中执行，控制台打印 <code>hello</code>，清空执行栈，此时任务队列为空，执行结束。</p>\n<p>##第二个 setTimeout 例子</p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">100000</span>;i++)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">setTimeout(()=&gt;&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i am run'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">start</div><div class=\"line\">...</div><div class=\"line\">end</div><div class=\"line\">hello</div><div class=\"line\">world</div><div class=\"line\">I am run</div></pre></td></tr></table></figure></p>\n<h3 id=\"过程-1\"><a href=\"#过程-1\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>Timer3 仅仅延迟了 100ms，反而在另外两个 Timer 之后执行了。其实这里原因很简单，因为在 Timer1 和 Timer2 加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的 Timer1 和 Timer2 并不会得以执行。<strong>当for循环结束，这时才将 Timer3 交由 Timer 模块去管理</strong>(注意，代码顺序执行，for循环的时候， Timer3 的 <code>setTimeout()</code> 还没有执行，所以也就还没有被 Timer 模块管理)，继续执行后续代码打印 <code>end</code>，清空执行栈。虽然在这里 Timer3 的延迟时间最短，但是<strong>加入任务队列后</strong>还是会排在 Timer1 和 Timer2 的后面，所以此时按<strong>顺序执行任务队列中的代码</strong>，依次打印。</p>\n<p>需要注意的是，执行完 <code>console.log(&#39;end&#39;);</code> 后，立刻执行了 Timer1 和 Timer2，但是 Timer3 执行时间约在之后 100ms，这是因为for循环执行的时间超过了300ms。如果for循环在100ms以内完成，那么 <code>console.log(&#39;i am run&#39;);</code> 仍然是最先执行的。如果for循环在100ms到200ms之间，那么 <code>console.log(&#39;i am run&#39;);</code> 在 <code>console.log(&#39;world&#39;);</code> 之后，<code>console.log(&#39;hello&#39;);</code> 之间执行。</p>"},{"title":"JavaScript基本语法","date":"2016-09-09T02:07:12.000Z","_content":"\n参考自[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n\n<!--more-->\n\n## 基础语法\n### 数据类型和变量\n#### Number\nJS不区分整数浮点数，统一用`Number`表示：\n```javascript\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n`Number`可以直接运算：\n```javascript\n(1 + 2) * 5 / 2; // 7.5\n2 / 0; // Infinity\n0 / 0; // NaN\n10 % 3; // 1 (取余)\n10.5 % 3; // 1.5\n```\n\n#### 字符串\n以单引号`'`或双引号`\"`括起来的任意文本.如`'abc'` \n\n#### 布尔值\n用`true`和`false`表示。\n\n#### 比较运算符\nJavaScript在设计时，有两种比较运算符：\n第一种是`==`比较，它会自动转换数据类型再比较.\n第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n`NaN`这个特殊的`Number`与所有其他值都不相等，包括它自己：\n```javascript\nNaN == NaN; // false\nNaN === NaN; // false\n```\n唯一能判断`NaN`的方法是通过`isNaN()`函数：\n```javascript\nisNaN(NaN); // true\n```\n\n浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n\n#### 数组\nJavaScript的数组可以包括任意数据类型。例如：\n```javascript\n[1, 2, 3.14, 'Hello', null, true];\n```\n\n另一种创建数组的方法是通过Array()函数实现：\n```javascript\nnew Array(1, 2, 3); // 创建了数组[1, 2, 3]\n```\n然而，出于代码的可读性考虑，强烈建议直接使用`[]`。\n\n数组的元素可以通过索引来访问。请注意，索引的起始值为0：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr[0]; // 返回索引为0的元素，即1\narr[5]; // 返回索引为5的元素，即true\narr[6]; // 索引超出了范围，返回undefined\n```\n\n#### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\nJavaScript对象的键都是**字符串类型**，值可以是任意数据类型。\n\n要获取一个对象的属性，我们用对象变量.属性名的方式：\n```javascript\nperson.name; // 'Bob'\nperson.zipcode; // null\n```\n\n#### 变量\n申明一个变量用var语句，比如：\n```javascript\nvar a; // 申明了变量a，此时a的值为undefined\nvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1\nvar s_007 = '007'; // s_007是一个字符串\nvar Answer = true; // Answer是一个布尔值true\nvar t = null; // t的值是null\n```\n注意只能用var申明一次。\n\n#### strict模式\n为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。\n\n启用strict模式的方法是在JavaScript代码的第一行写上：\n```javascript\n'use strict';\n```\n不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。\n\n### 字符串\n#### 模板字符串\n要把多个字符串连接起来，可以用`+`号连接：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = '你好, ' + name + ', 你今年' + age + '岁了!';\nalert(message);\n```\n\n如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nalert(message);\n```\n\n#### 操作字符串\n字符串常见的操作如下：\n```javascript\nvar s = 'Hello, world!';\ns.length; // 13\n```\n\n要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：\n```javascript\nvar s = 'Hello, world!';\n\ns[0]; // 'H'\ns[6]; // ' '\ns[7]; // 'w'\ns[12]; // '!'\ns[13]; // undefined 超出范围的索引不会报错，但一律返回undefined\n```\n需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.\n\n#### toUpperCase\n`toUpperCase()`返回一个全大写的字符串\n\n#### toLowerCase\n`toLowerCase()`f返回一个全小写的字符串\n\n#### indexOf\n`indexOf()`会搜索指定字符串出现的位置:\n```javascript\nvar s = 'hello, world';\ns.indexOf('world'); // 返回7\ns.indexOf('World'); // 没有找到指定的子串，返回-1\n```\n\n#### substring\n`substring()`返回指定索引区间的子串：\n```javascript\nvar s = 'hello, world'\ns.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'\ns.substring(7); // 从索引7开始到结束，返回'world'\n```\n\n### 数组\n要取得`Array`的长度，直接访问`length`属性：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr.length; // 6\n```\n\n**请注意**，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr.length; // 3\narr.length = 6;\narr; // arr变为[1, 2, 3, undefined, undefined, undefined]\narr.length = 2;\narr; // arr变为[1, 2]\n```\n\n**请注意**，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr[5] = 'x';\narr; // arr变为[1, 2, 3, undefined, undefined, 'x']\n```\n\n**大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。**\n\n#### indexOf\n与`String`类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：\n```javascript\nvar arr = [10, 20, '30', 'xyz'];\narr.indexOf(10); // 元素10的索引为0\narr.indexOf(20); // 元素20的索引为1\narr.indexOf(30); // 元素30没有找到，返回-1\narr.indexOf('30'); // 元素'30'的索引为2\n```\n\n#### slice\n`slice()`就是对应`String`的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\narr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']\narr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']\n```\n\n如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`\n\n#### push和pop\n`push()`向`Array`的末尾添加**若干**元素，`pop()`则把`Array`的最后一个元素删除掉：\n```javascript\nvar arr = [1, 2];\narr.push('A', 'B'); // 返回Array新的长度: 4\narr; // [1, 2, 'A', 'B']\narr.pop(); // pop()返回'B'\narr; // [1, 2, 'A']\narr.pop(); arr.pop(); arr.pop(); // 连续pop 3次\narr; // []\narr.pop(); // 空数组继续pop不会报错，而是返回undefined\narr; // []\n```\n\n#### unshift和shift\n如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：\n```javascript\nvar arr = [1, 2];\narr.unshift('A', 'B'); // 返回Array新的长度: 4\narr; // ['A', 'B', 1, 2]\narr.shift(); // 'A'\narr; // ['B', 1, 2]\narr.shift(); arr.shift(); arr.shift(); // 连续shift 3次\narr; // []\narr.shift(); // 空数组继续shift不会报错，而是返回undefined\narr; // []\n```\n\n#### sort\n`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：\n\n#### reverse\nreverse()把整个Array的元素给掉个个，也就是反转.\n\n#### splice\n`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\n````javascript\nvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n// 从索引2开始删除3个元素,然后再添加两个元素:\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n// 只删除,不添加:\narr.splice(2, 2); // ['Google', 'Facebook']\narr; // ['Microsoft', 'Apple', 'Oracle']\n// 只添加,不删除:\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n```\n\n#### concat\n`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C'];\nvar added = arr.concat([1, 2, 3]);\nadded; // ['A', 'B', 'C', 1, 2, 3]\narr; // ['A', 'B', 'C']\n```\n请注意，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。\n实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：\n```javascript\nvar arr = ['A', 'B', 'C'];\narr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]\n```\n\n#### join\n`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：\n```javascript\nvar arr = ['A', 'B', 'C', 1, 2, 3];\narr.join('-'); // 'A-B-C-1-2-3'\n```\n如果`Array`的元素不是字符串，将自动转换为字符串后再连接。\n\n### 对象\n```javascript\nvar xiaohong = {\n    name: '小红',\n    'middle-school': 'No.1 Middle School'\n};\n```\n`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：\n```javascript\nxiaohong['middle-school']; // 'No.1 Middle School'\nxiaohong['name']; // '小红'\nxiaohong.name; // '小红'\n```\n\n如果属性名是其他对象，那么需要用`[]`将其括起来，表示对外部对象执行`toString()`操作：\n```javascript\nvar weight = function () {\n    return \"1weight\"\n};\n\nvar xiaoming = {\n    name :  \"小明\",\n    [weight()] :\"属性名是返回值1weight\",\n    [weight]:\"属性名是整个function\"\n};\n\nconsole.log(xiaoming)\n返回：\n{ name: '小明',\n  '1weight': '属性名是返回值1weight',\n  'function () {\\n    return \"1weight\"\\n}': '属性名是整个function' }\n```\n\n由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.age; // undefined\nxiaoming.age = 18; // 新增一个age属性\nxiaoming.age; // 18\ndelete xiaoming.age; // 删除age属性\nxiaoming.age; // undefined\ndelete xiaoming['name']; // 删除name属性\nxiaoming.name; // undefined\ndelete xiaoming.school; // 删除一个不存在的school属性也不会报错\n```\n\n如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符,不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：\n```javascript\n'name' in xiaoming; // true\n'toString' in xiaoming; // true\n```\n要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.hasOwnProperty('name'); // true\nxiaoming.hasOwnProperty('toString'); // false\n```\n\n### Map和Set\nJS中默认对象表达方式`{}`可以视为其他语言中的`Map`或`Dictionary`的数据结构，即一组键值对。\n但是JavaScript的对象有个小问题，就是**键必须是字符串**。但实际上Number或者其他数据类型作为键也是非常合理的。\n为了解决这个问题，最新的ES6规范引入了新的数据类型`Map`。\n\n#### Map\n```javascript\nvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Michael'); // 95\nm.set('Zachary', 100);\n```\n\n#### Set\n重复元素在Set中自动被过滤：\n```javascript\nvar s = new Set([1, 2, 3, 3, '3']);\ns; // Set {1, 2, 3, \"3\"}\n```\n注意数字`3`和字符串`'3'`是不同的元素。\n\n通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果：\n```javascript\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n通过delete(key)方法可以删除元素：\n```javascript\nvar s = new Set([1, 2, 3]);\ns; // Set {1, 2, 3}\ns.delete(3);\ns; // Set {1, 2}\n```\n\n### iterable\nES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。\n具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。\n\n用`for ... of`循环遍历集合，用法如下：\n```javascript\nvar a = ['A', 'B', 'C'];\nvar s = new Set(['A', 'B', 'C']);\nvar m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + '=' + x[1]);\n}\n```\n\n**`for ... of`循环和`for ... in`循环有何区别？**\n`for ... in`实际上是**对象的属性名称(注意，是键，不是值)**。不要用在`Array`,`Set`,`Map`上，会出现奇怪的问题。\n`for ... of`循环则完全修复了这些问题，它**只循环得到集合内该出现的元素(注意，是值，不是键)**，例如：\n```javascript\nvar a = ['A', 'B', 'C'];\na.name = 'Hello';\na['4'] = 'D';\nconsole.log(a);\nfor (var num of a){\n    console.log(num)\n}\n输出：\n[ 'A', 'B', 'C', , 'D', name: 'Hello' ]\nA\nB\nC\nundefined\nD\n```\n`name`由于不是正常`Array`该有的，所以在`for ... of`循环时，其对应的值不会被输出。\n\n然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：\n```javascript\nvar a = ['A', 'B', 'C'];\na.forEach(function (element, index, array) {\n    // element: 指向当前元素的值\n    // index: 指向当前索引\n    // array: 指向Array对象本身\n    alert(element);\n});\n```\n对于`Set`来说，由于没有索引，`index`也是指当前元素。\n对于`Map`来说，`element`和`index`分别对应`Value`和`Key`.\n\n## 函数\n### 函数定义和调用\n#### 定义函数\n方式一：\n```javascript\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。\n\n方式二：\n```javascript\nvar abs = function (x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n};\n```\n在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。\n\n上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个`;`，表示赋值语句结束。\n\n#### 调用函数\n由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：\n```javascript\nabs(10, 'blablabla'); // 返回10\nabs(-9, 'haha', 'hehe', null); // 返回9\n```\n\n传入的参数比定义的少也没有问题：\n```javascript\nabs(); // 返回NaN\n```\n此时`abs(x)`函数的参数`x`将收到`undefined`，计算结果为`NaN`。\n\n要避免收到undefined，可以对参数进行检查：\n```javascript\nfunction abs(x) {\n    if ((typeof x) !== 'number') {\n        throw 'Not a number';\n    }\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n\n#### arguments\nJavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`：\n```javascript\nfunction foo(x) {\n    alert(x); // 10\n    for (var i=0; i<arguments.length; i++) {\n        alert(arguments[i]); // 10, 20, 30\n    }\n}\nfoo(10, 20, 30);\n```\n利用`arguments`，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。\n\n#### rest参数\n由于JavaScript函数允许接收任意个参数，于是我们就不得不用`arguments`来获取所有参数.\nES6标准引入了`rest`参数，可以将剩余的参数放在`rest`中：\n```javascript\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]\n\nfoo(1);\n// 结果:\n// a = 1\n// b = undefined\n// Array []\n```\n\n`rest`参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`，所以，不再需要`arguments`我们就获取了全部参数。\n如果传入的参数连正常定义的参数都没填满，也不要紧，`rest`参数会接收一个空数组（注意不是`undefined`）。\n\n\n### 变量作用域\n在JavaScript中，用var申明的变量实际上是有作用域的。\n- 如果一个变量在函数体内部申明，则该变量的作用域为整个**函数体**(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。\n- 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量\n- 如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\n\n#### 变量提升\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：\n```javascript\n'use strict';\n\nfunction foo() {\n    var x = 'Hello, ' + y;\n    alert(x);\n    var y = 'Bob';\n}\n\nfoo();\n```\n\n虽然是`strict`模式，但语句`var x = 'Hello, ' + y;`并不报错，原因是变量`y`在稍后申明了。但是`alert`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。\n\n#### 全局作用域\n不在任何函数内定义的变量就具有全局作用域。\n\n#### 名字空间\n不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n```javascript\n// 唯一的全局变量MYAPP:\nvar MYAPP = {};\n\n// 其他变量:\nMYAPP.name = 'myapp';\nMYAPP.version = 1.0;\n\n// 其他函数:\nMYAPP.foo = function () {\n    return 'foo';\n};\n```\n\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\n\n#### 局部作用域\n由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：\n```javascript\n'use strict';\n\nfunction foo() {\n    for (var i=0; i<100; i++) {\n        //\n    }\n    i += 100; // 仍然可以引用变量i\n}\n```\n\n为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：\n```javascript\n'use strict';\n\nfunction foo() {\n    var sum = 0;\n    for (let i=0; i<100; i++) {\n        sum += i;\n    }\n    i += 1; // SyntaxError\n}\n```\n\n#### 常量\n由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.\n\nES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：\n```javascript\n'use strict';\n\nconst PI = 3.14;\nPI = 3; // 某些浏览器不报错，但是无效果！\nPI; // 3.14\n```\n\n注意，一定要加上`use strict`,否则会报错。\n\n### 方法\n绑定到对象上的函数称为方法:\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var y = new Date().getFullYear();\n        return y - this.birth;\n    }\n};\n\nxiaoming.age; // function xiaoming.age()\nxiaoming.age(); // 今年调用是25,明年调用就变成26了\n```\n\n和普通函数也没啥区别，但是它在内部使用了一个`this`关键字.\n在一个方法内部，`this`是一个特殊变量，**它始终指向当前对象**，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。\n\n让我们拆开写：\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25, 正常结果\ngetAge(); // NaN\n```\n\n单独调用函数`getAge()`怎么返回了`NaN`？请注意，我们已经进入到了JavaScript的一个大坑里。\nJavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？\n答案是，视情况而定！\n如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。\n如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向**全局对象**.\n\n更坑爹的是，如果这么写：\n```javascript\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数\nfn(); // NaN\n```\n也是不行的！要保证`this`指向正确，必须要给出明确的上下文，必须用`obj.xxx()`的形式调用！谁调用，`this`就是指谁。上面仅仅相当于将`age`方法赋给`fn`.\n\n如果是这种情况：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - this.birth;\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); \n```\n\n又不对了。原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！需要这样修改：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var that = this; // 在方法内部一开始就捕获this\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - that.birth; // 用that而不是this\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); // 25\n```\n\n用`var that = this`;将`age`中的`this`捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\n\n#### apply\n我们还是可以控制`this`的指向的！\n\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\n\n用`apply`修复`getAge()`调用:\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25\ngetAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\n```\n\n再举一个例子：\n\n```javascript\nvar numbers = {  \n   numberA: 5,\n   numberB: 10,\n   sum: function() {\n     console.log(this === numbers); // => true\n     function calculate() {\n       // this is window or undefined in strict mode\n       console.log(this === numbers); // => false\n       return this.numberA + this.numberB;\n     }\n     return calculate();\n   }\n};\nnumbers.sum(); // => NaN or throws TypeError in strict mode  \n\nvar numbers = {  \n   numberA: 5,\n   numberB: 10,\n   sum: function() {\n     console.log(this === numbers); // => true\n     function calculate() {\n       console.log(this === numbers); // => true\n       return this.numberA + this.numberB;\n     }\n     // use .call() method to modify the context\n     return calculate.call(this);\n   }\n};\nnumbers.sum(); // => 15\n\n```\n\n\n上面的`call()`与`apply()`是类似的方法，唯一区别是：\n- `apply()`把参数打包成`Array`再传入；\n- `call()`把参数按顺序传入。 \n\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\n```javascript\nMath.max.apply(null, [3, 5, 4]); // 5\nMath.max.call(null, 3, 5, 4); // 5\n```\n对普通函数调用，我们通常把this绑定为null。\n\n#### .bind()\n\n对比方法 `.apply()` 和 `.call()`，它俩都立即执行了函数，而 `.bind()` 函数返回了一个新方法，绑定了预先指定好的 `this` ，并可以延后调用。`.bind()` 方法的作用是创建一个新的函数，执行时的上下文环境为 `.bind()` 传递的第一个参数，它允许创建预先设置好 `this` 的函数。\n\n```javascript\nvar numbers = {  \n  array: [3, 5, 10],\n  getNumbers: function() {\n    return this.array;    \n  }\n};\n// Create a bound function\nvar boundGetNumbers = numbers.getNumbers.bind(numbers);  \nboundGetNumbers(); // => [3, 5, 10]  \n// Extract method from object\nvar simpleGetNumbers = numbers.getNumbers;  \nsimpleGetNumbers(); // => undefined or throws an error in strict mode  \n```\n\n使用 `.bind()` 时应该注意，`.bind()` 创建了一个永恒的上下文链并不可修改。一个绑定函数即使使用 `.call()` 或者 `.apply()`传入其他不同的上下文环境，也不会更改它之前连接的上下文环境，重新绑定也不会起任何作用。\n\n\n#### 装饰器\n利用`apply()`，我们还可以动态改变函数的行为。\n\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以**重新指向新的函数**。\n\n现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：\n```javascript\nvar count = 0;\nvar oldParseInt = parseInt; // 保存原函数\n\nwindow.parseInt = function () {\n    count += 1;\n    return oldParseInt.apply(null, arguments); // 调用原函数\n};\n\n// 测试:\nparseInt('10');\nparseInt('20');\nparseInt('30');\ncount; // 3\n```\n\n### 高阶函数\n一个可以接收另一个函数作为参的函数，称为高阶函数。\n#### map\n`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：\n```javascript\nfunction pow(x) {\n    return x * x;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n`map()`将传入的函数一一作用在数组的每一个元素上。\n\n#### reduce\n`Array`的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n```javascipt\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n```\n\n比如对`Array`求和：\n```javascript\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n}); // 25\n```\n\n#### filter\n用于把`Array`的某些元素过滤掉，然后返回剩下的元素\n`Array`的`filter()`接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：\n```javascript\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\nvar r = arr.filter(function (x) {\n    return x % 2 !== 0;\n});\nr; // [1, 5, 9, 15]\n```\n\n#### sort\n可以接收一个比较函数来实现自定义的排序\n要按数字大小排序，我们可以这么写：\n```javascript\nvar arr = [10, 20, 1, 2];\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n}); // [1, 2, 10, 20]\n```\n\n**注意**：`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`\n\n### 闭包\n#### 函数作为返回值\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n比如返回一个求和的函数：\n```javascript\nfunction lazy_sum(arr) {\n    var sum = function () {\n        return arr.reduce(function (x, y) {\n            return x + y;\n        });\n    }\n    return sum;\n}\n```\n当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：\n```javascript\nvar f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n```\n调用函数f时，才真正计算求和的结果：\n```javascript\nf(); // 15\n```\n当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中`this`不遵循闭包)\n\n#### 闭包\n需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push(function () {\n            return i * i;\n        });\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n```\n\n上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，**或者说返回了三个闭包**.\n调用的结果全是`16`,因为返回函数都引用了变量`i`，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了`4`。\n\n**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function (n) {\n            return function () {\n                return n * n;\n            }\n        })(i));\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n\nf1(); // 1\nf2(); // 4\nf3(); // 9\n```\n\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\n```\n(function (x) {\n    return x * x;\n})(3); // 9\n``` \n\n**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            var n =i\n            return function () {\n                return n*n;\n            }\n        })());\n    }\n    return arr;\n}\n```\n相反的，如果内存函数还是用的`i`，那么结果就会全是`16`.\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            // var n =i\n            return function () {\n                return i*i;\n            }\n        })());\n    }\n    return arr;\n}\n```\n\n### 箭头函数\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\n```javascript\nx => x*x\n```\n相当于一个输入为`x`输出为`x*x`的匿名函数\n```\nfunction (x) {\n    return x * x;\n}\n```\n如果参数不是一个，就需要用括号()括起来：\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n语法糖，类似于python中的lambda函数\n\n当然，箭头函数还是有点用处的，由于是es6的新特性，**箭头函数内部的this是词法作用域**，由上下文确定。\n试做比较：\n```\n//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = function () {\n            return new Date().getFullYear() - this.birth; // this指向window或undefined\n        };\n        return fn();\n    }\n};\n//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25\n```\n如果使用箭头函数,以前 `var that = this;` 以及 `.apply()` 和 `.call()` 这种写法就不需要了。\n\n箭头函数并不创建它自身执行的上下文，使得 `this` 取决于它在定义时的外部函数。**箭头函数一次绑定上下文后便不可更改，即使使用了上下文更改的方法**：\n\n```javascript\n    var numbers = [1, 2];  \n    (function() {  \n      var get = () => {\n        console.log(this === numbers); // => true\n        return this;\n      };\n      console.log(this === numbers); // => true\n      get(); // => [1, 2]\n      // 箭头函数使用 .apply() 和 .call()\n      get.call([0]);  // => [1, 2]\n      get.apply([0]); // => [1, 2]\n      // Bind\n      get.bind([0])(); // => [1, 2]\n    }).call(numbers);\n```\n\n这是因为箭头函数拥有静态的上下文环境，不会因为不同的调用而改变。但是要注意：\n\n```javascript\n\tfunction Period (hours, minutes) {  \n      this.hours = hours;\n      this.minutes = minutes;\n    }\n    Period.prototype.format = () => {  \n      console.log(this === window); // => true\n      return this.hours + ' hours and ' + this.minutes + ' minutes';\n    };\n    var walkPeriod = new Period(2, 30);  \n    walkPeriod.format(); // => 'undefined hours and undefined minutes' \n```\n\n注意这里的 `this === window` 返回的是 `true`。\n\n### generator\ngenerator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。\n\n定义如下：\n```javascript\nfunction* foo(x) {\n    yield x + 1;\n    yield x + 2;\n    return x + 3;\n}\n```\ngenerator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。好处就是**函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。**(其实这东西很像调试函数时候的断点！)\n\n执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：\n```javascript\nvar f = fib(5);\nf.next(); // {value: 0, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 1, done: true}\n```\n`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。\n\n第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：\n```javascript\nfor (var x of fib(5)) {\n    console.log(x); // 依次输出0, 1, 1\n}\n```\n\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。**看起来蛮有用的**\n\n举个例子，要生成一个自增的ID，可以编写一个next_id()函数：\n```javascript\nvar current_id = 0;\n\nfunction next_id() {\n    current_id ++;\n    return current_id;\n}\n```\n\n由于函数无法保存状态，故需要一个全局变量`current_id`来保存数字。现在改用generator：\n```javascript\nfunction* next_id() {\n\tvar i = 0;\n\twhile (true){\n    \tyield ++i;\n   \t}\n}\n```\n\n## 标准对象\n一些原则：\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\n- 判断`Array`要使用`Array.isArray(arr)`；\n- 判断`null`请使用`myVar === null`；\n- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；\n\n### Date\n在JavaScript中，`Date`对象用来表示日期和时间。\n\n要获取系统当前时间，用：\n```javascript\nvar now = new Date();\nnow; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\nnow.getFullYear(); // 2015, 年份\nnow.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月\nnow.getDate(); // 24, 表示24号\nnow.getDay(); // 3, 表示星期三\nnow.getHours(); // 19, 24小时制\nnow.getMinutes(); // 49, 分钟\nnow.getSeconds(); // 22, 秒\nnow.getMilliseconds(); // 875, 毫秒数\nnow.getTime(); // 1435146562875, 以number形式表示的时间戳\n```\n\n如果要创建一个指定日期和时间的Date对象，可以用：\n```javascript\nvar d = new Date(2015, 5, 19, 20, 15, 30, 123);\nd; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)\n```\n\n一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是`0~11`，`0`表示一月，`1`表示二月……，所以要表示`6`月，我们传入的是`5`！\n\n第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：\n```javascript\nvar d = Date.parse('2015-06-24T19:49:22.875+08:00');\nd; // 1435146562875\n```\n但它返回的不是`Date`对象，而是一个**时间戳**。不过有时间戳就可以很容易地把它转换为一个`Date`：\n```javascript\nvar d = new Date(1435146562875);\nd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\n```\n\n时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。\n\n要获取当前时间戳，可以用：\n```javascript\nif (Date.now) {\n    alert(Date.now()); // 老版本IE没有now()方法\n} else {\n    alert(new Date().getTime());\n}\n```\n\n### Json\nJSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：\n- number：和JavaScript的`number`完全一致；\n- boolean：就是JavaScript的`true`或`false`；\n- string：就是JavaScript的`string`；\n- null：就是JavaScript的`null`；\n- array：就是JavaScript的`Array`表示方式——`[]`；\n- object：就是JavaScript的`{ ... }`表示方式。\n\n#### 序列化\n先把小明这个对象序列化成JSON格式的字符串：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\n};\n\nJSON.stringify(xiaoming); // '{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]}'\n```\n\n要输出得好看一些，可以加上参数，按缩进输出：\n```javascript\nJSON.stringify(xiaoming, null, '  ');\n```\n结果：\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：\n```javacript\nJSON.stringify(xiaoming, ['name', 'skills'], '  ');\n```\n结果:\n```javascript\n{\n  \"name\": \"小明\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n还可以传入一个函数，这样对象的每个键值对都会被函数先处理：\n```javascript\nfunction convert(key, value) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value;\n}\n\nJSON.stringify(xiaoming, convert, '  ');\n```\n上面的代码把所有属性值都变成大写：\n\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\n  \"skills\": [\n    \"JAVASCRIPT\",\n    \"JAVA\",\n    \"PYTHON\",\n    \"LISP\"\n  ]\n}\n```\n如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],\n    toJSON: function () {\n        return { // 只输出name和age，并且改变了key：\n            'Name': this.name,\n            'Age': this.age\n        };\n    }\n};\n\nJSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}'\n```\n\n#### 反序列化\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：\n```javascript\nJSON.parse('[1,2,3,true]'); // [1, 2, 3, true]\nJSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}\nJSON.parse('true'); // true\nJSON.parse('123.45'); // 123.45\n```\n`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：\n```javascript\nJSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) {\n    // 把number * 2:\n    if (key === 'name') {\n        return value + '同学';\n    }\n    return value;\n}); // Object {name: '小明同学', age: 14}\n```\n\n## 面向对象编程\nJavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\n\nprototype有点类似于继承，`A`的原型是`B`，意味着，`A`拥有`B`的全部属性。\n```javascript\n// 原型对象:\nvar Student = {\n    name: 'Robot',\n    height: 1.2,\n    run: function () {\n        console.log(this.name + ' is running...');\n    }\n};\n\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 创建对象\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\n\n例如，创建一个`Array`对象：\n```javascript\nvar arr = [1, 2, 3];\n```\n其原型链是：\n```javascript\narr ----> Array.prototype ----> Object.prototype ----> null\n```\n`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。\n\n当我们创建一个函数时：\n```javascript\nfunction foo() {\n    return 0;\n}\n```\n函数也是一个对象，它的原型链是：\n```javascript\nfoo ----> Function.prototype ----> Object.prototype ----> null\n```\n由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。\n\n#### 构造函数\n除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\n```\n注意，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\n\n用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\n\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\n\nxiaoming instanceof Student; // true\n```\n他们之间的关系就是:\n![constructor](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true)\n\n红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。\n\n另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\n\n不过还有一个小问题，注意观察：\n```javascript\nxiaoming.name; // '小明'\nxiaohong.name; // '小红'\nxiaoming.hello; // function: Student.hello()\nxiaohong.hello; // function: Student.hello()\nxiaoming.hello === xiaohong.hello; // false\n```\n`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！\n\n如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。\n要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：\n![constructor2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true)\n修改代码如下：\n```javascript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n### class继承\n新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n我们先回顾用函数实现`Student`的方法：\n```javscript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n\n如果用新的`class`关键字来编写`Student`，可以这样写：\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，`class`的定义包含了**构造函数**`constructor`和定义在原型对象上的函数`hello()`（注意没有`function`关键字），这样就避免了`Student.prototype.hello = function () {...}`这样分散的代码。\n\n最后，创建一个Student对象代码和前面章节完全一样：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.hello();\n```\n\n#### class继承\n用`class`定义对象的另一个巨大的好处是继承更方便了,直接通过`extends`来实现：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n通过`super(name)`来调用父类的构造函数。`PrimaryStudent`已经自动获得了父类`Student`的`hello`方法，我们又在子类中定义了新的`myGrade`方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaScript基本语法.md","raw":"title: JavaScript基本语法\ndate: 2016/9/9 10:07:12  \ncategories: JavaScript\ntags:\n\t- 学习笔记\n\n---\n\n参考自[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n\n<!--more-->\n\n## 基础语法\n### 数据类型和变量\n#### Number\nJS不区分整数浮点数，统一用`Number`表示：\n```javascript\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n`Number`可以直接运算：\n```javascript\n(1 + 2) * 5 / 2; // 7.5\n2 / 0; // Infinity\n0 / 0; // NaN\n10 % 3; // 1 (取余)\n10.5 % 3; // 1.5\n```\n\n#### 字符串\n以单引号`'`或双引号`\"`括起来的任意文本.如`'abc'` \n\n#### 布尔值\n用`true`和`false`表示。\n\n#### 比较运算符\nJavaScript在设计时，有两种比较运算符：\n第一种是`==`比较，它会自动转换数据类型再比较.\n第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n`NaN`这个特殊的`Number`与所有其他值都不相等，包括它自己：\n```javascript\nNaN == NaN; // false\nNaN === NaN; // false\n```\n唯一能判断`NaN`的方法是通过`isNaN()`函数：\n```javascript\nisNaN(NaN); // true\n```\n\n浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n\n#### 数组\nJavaScript的数组可以包括任意数据类型。例如：\n```javascript\n[1, 2, 3.14, 'Hello', null, true];\n```\n\n另一种创建数组的方法是通过Array()函数实现：\n```javascript\nnew Array(1, 2, 3); // 创建了数组[1, 2, 3]\n```\n然而，出于代码的可读性考虑，强烈建议直接使用`[]`。\n\n数组的元素可以通过索引来访问。请注意，索引的起始值为0：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr[0]; // 返回索引为0的元素，即1\narr[5]; // 返回索引为5的元素，即true\narr[6]; // 索引超出了范围，返回undefined\n```\n\n#### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\nJavaScript对象的键都是**字符串类型**，值可以是任意数据类型。\n\n要获取一个对象的属性，我们用对象变量.属性名的方式：\n```javascript\nperson.name; // 'Bob'\nperson.zipcode; // null\n```\n\n#### 变量\n申明一个变量用var语句，比如：\n```javascript\nvar a; // 申明了变量a，此时a的值为undefined\nvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1\nvar s_007 = '007'; // s_007是一个字符串\nvar Answer = true; // Answer是一个布尔值true\nvar t = null; // t的值是null\n```\n注意只能用var申明一次。\n\n#### strict模式\n为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。\n\n启用strict模式的方法是在JavaScript代码的第一行写上：\n```javascript\n'use strict';\n```\n不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。\n\n### 字符串\n#### 模板字符串\n要把多个字符串连接起来，可以用`+`号连接：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = '你好, ' + name + ', 你今年' + age + '岁了!';\nalert(message);\n```\n\n如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nalert(message);\n```\n\n#### 操作字符串\n字符串常见的操作如下：\n```javascript\nvar s = 'Hello, world!';\ns.length; // 13\n```\n\n要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：\n```javascript\nvar s = 'Hello, world!';\n\ns[0]; // 'H'\ns[6]; // ' '\ns[7]; // 'w'\ns[12]; // '!'\ns[13]; // undefined 超出范围的索引不会报错，但一律返回undefined\n```\n需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.\n\n#### toUpperCase\n`toUpperCase()`返回一个全大写的字符串\n\n#### toLowerCase\n`toLowerCase()`f返回一个全小写的字符串\n\n#### indexOf\n`indexOf()`会搜索指定字符串出现的位置:\n```javascript\nvar s = 'hello, world';\ns.indexOf('world'); // 返回7\ns.indexOf('World'); // 没有找到指定的子串，返回-1\n```\n\n#### substring\n`substring()`返回指定索引区间的子串：\n```javascript\nvar s = 'hello, world'\ns.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'\ns.substring(7); // 从索引7开始到结束，返回'world'\n```\n\n### 数组\n要取得`Array`的长度，直接访问`length`属性：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr.length; // 6\n```\n\n**请注意**，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr.length; // 3\narr.length = 6;\narr; // arr变为[1, 2, 3, undefined, undefined, undefined]\narr.length = 2;\narr; // arr变为[1, 2]\n```\n\n**请注意**，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr[5] = 'x';\narr; // arr变为[1, 2, 3, undefined, undefined, 'x']\n```\n\n**大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。**\n\n#### indexOf\n与`String`类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：\n```javascript\nvar arr = [10, 20, '30', 'xyz'];\narr.indexOf(10); // 元素10的索引为0\narr.indexOf(20); // 元素20的索引为1\narr.indexOf(30); // 元素30没有找到，返回-1\narr.indexOf('30'); // 元素'30'的索引为2\n```\n\n#### slice\n`slice()`就是对应`String`的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\narr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']\narr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']\n```\n\n如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`\n\n#### push和pop\n`push()`向`Array`的末尾添加**若干**元素，`pop()`则把`Array`的最后一个元素删除掉：\n```javascript\nvar arr = [1, 2];\narr.push('A', 'B'); // 返回Array新的长度: 4\narr; // [1, 2, 'A', 'B']\narr.pop(); // pop()返回'B'\narr; // [1, 2, 'A']\narr.pop(); arr.pop(); arr.pop(); // 连续pop 3次\narr; // []\narr.pop(); // 空数组继续pop不会报错，而是返回undefined\narr; // []\n```\n\n#### unshift和shift\n如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：\n```javascript\nvar arr = [1, 2];\narr.unshift('A', 'B'); // 返回Array新的长度: 4\narr; // ['A', 'B', 1, 2]\narr.shift(); // 'A'\narr; // ['B', 1, 2]\narr.shift(); arr.shift(); arr.shift(); // 连续shift 3次\narr; // []\narr.shift(); // 空数组继续shift不会报错，而是返回undefined\narr; // []\n```\n\n#### sort\n`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：\n\n#### reverse\nreverse()把整个Array的元素给掉个个，也就是反转.\n\n#### splice\n`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\n````javascript\nvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n// 从索引2开始删除3个元素,然后再添加两个元素:\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n// 只删除,不添加:\narr.splice(2, 2); // ['Google', 'Facebook']\narr; // ['Microsoft', 'Apple', 'Oracle']\n// 只添加,不删除:\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n```\n\n#### concat\n`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C'];\nvar added = arr.concat([1, 2, 3]);\nadded; // ['A', 'B', 'C', 1, 2, 3]\narr; // ['A', 'B', 'C']\n```\n请注意，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。\n实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：\n```javascript\nvar arr = ['A', 'B', 'C'];\narr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]\n```\n\n#### join\n`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：\n```javascript\nvar arr = ['A', 'B', 'C', 1, 2, 3];\narr.join('-'); // 'A-B-C-1-2-3'\n```\n如果`Array`的元素不是字符串，将自动转换为字符串后再连接。\n\n### 对象\n```javascript\nvar xiaohong = {\n    name: '小红',\n    'middle-school': 'No.1 Middle School'\n};\n```\n`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：\n```javascript\nxiaohong['middle-school']; // 'No.1 Middle School'\nxiaohong['name']; // '小红'\nxiaohong.name; // '小红'\n```\n\n如果属性名是其他对象，那么需要用`[]`将其括起来，表示对外部对象执行`toString()`操作：\n```javascript\nvar weight = function () {\n    return \"1weight\"\n};\n\nvar xiaoming = {\n    name :  \"小明\",\n    [weight()] :\"属性名是返回值1weight\",\n    [weight]:\"属性名是整个function\"\n};\n\nconsole.log(xiaoming)\n返回：\n{ name: '小明',\n  '1weight': '属性名是返回值1weight',\n  'function () {\\n    return \"1weight\"\\n}': '属性名是整个function' }\n```\n\n由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.age; // undefined\nxiaoming.age = 18; // 新增一个age属性\nxiaoming.age; // 18\ndelete xiaoming.age; // 删除age属性\nxiaoming.age; // undefined\ndelete xiaoming['name']; // 删除name属性\nxiaoming.name; // undefined\ndelete xiaoming.school; // 删除一个不存在的school属性也不会报错\n```\n\n如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符,不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：\n```javascript\n'name' in xiaoming; // true\n'toString' in xiaoming; // true\n```\n要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.hasOwnProperty('name'); // true\nxiaoming.hasOwnProperty('toString'); // false\n```\n\n### Map和Set\nJS中默认对象表达方式`{}`可以视为其他语言中的`Map`或`Dictionary`的数据结构，即一组键值对。\n但是JavaScript的对象有个小问题，就是**键必须是字符串**。但实际上Number或者其他数据类型作为键也是非常合理的。\n为了解决这个问题，最新的ES6规范引入了新的数据类型`Map`。\n\n#### Map\n```javascript\nvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Michael'); // 95\nm.set('Zachary', 100);\n```\n\n#### Set\n重复元素在Set中自动被过滤：\n```javascript\nvar s = new Set([1, 2, 3, 3, '3']);\ns; // Set {1, 2, 3, \"3\"}\n```\n注意数字`3`和字符串`'3'`是不同的元素。\n\n通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果：\n```javascript\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n通过delete(key)方法可以删除元素：\n```javascript\nvar s = new Set([1, 2, 3]);\ns; // Set {1, 2, 3}\ns.delete(3);\ns; // Set {1, 2}\n```\n\n### iterable\nES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。\n具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。\n\n用`for ... of`循环遍历集合，用法如下：\n```javascript\nvar a = ['A', 'B', 'C'];\nvar s = new Set(['A', 'B', 'C']);\nvar m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + '=' + x[1]);\n}\n```\n\n**`for ... of`循环和`for ... in`循环有何区别？**\n`for ... in`实际上是**对象的属性名称(注意，是键，不是值)**。不要用在`Array`,`Set`,`Map`上，会出现奇怪的问题。\n`for ... of`循环则完全修复了这些问题，它**只循环得到集合内该出现的元素(注意，是值，不是键)**，例如：\n```javascript\nvar a = ['A', 'B', 'C'];\na.name = 'Hello';\na['4'] = 'D';\nconsole.log(a);\nfor (var num of a){\n    console.log(num)\n}\n输出：\n[ 'A', 'B', 'C', , 'D', name: 'Hello' ]\nA\nB\nC\nundefined\nD\n```\n`name`由于不是正常`Array`该有的，所以在`for ... of`循环时，其对应的值不会被输出。\n\n然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：\n```javascript\nvar a = ['A', 'B', 'C'];\na.forEach(function (element, index, array) {\n    // element: 指向当前元素的值\n    // index: 指向当前索引\n    // array: 指向Array对象本身\n    alert(element);\n});\n```\n对于`Set`来说，由于没有索引，`index`也是指当前元素。\n对于`Map`来说，`element`和`index`分别对应`Value`和`Key`.\n\n## 函数\n### 函数定义和调用\n#### 定义函数\n方式一：\n```javascript\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。\n\n方式二：\n```javascript\nvar abs = function (x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n};\n```\n在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。\n\n上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个`;`，表示赋值语句结束。\n\n#### 调用函数\n由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：\n```javascript\nabs(10, 'blablabla'); // 返回10\nabs(-9, 'haha', 'hehe', null); // 返回9\n```\n\n传入的参数比定义的少也没有问题：\n```javascript\nabs(); // 返回NaN\n```\n此时`abs(x)`函数的参数`x`将收到`undefined`，计算结果为`NaN`。\n\n要避免收到undefined，可以对参数进行检查：\n```javascript\nfunction abs(x) {\n    if ((typeof x) !== 'number') {\n        throw 'Not a number';\n    }\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n\n#### arguments\nJavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`：\n```javascript\nfunction foo(x) {\n    alert(x); // 10\n    for (var i=0; i<arguments.length; i++) {\n        alert(arguments[i]); // 10, 20, 30\n    }\n}\nfoo(10, 20, 30);\n```\n利用`arguments`，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。\n\n#### rest参数\n由于JavaScript函数允许接收任意个参数，于是我们就不得不用`arguments`来获取所有参数.\nES6标准引入了`rest`参数，可以将剩余的参数放在`rest`中：\n```javascript\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]\n\nfoo(1);\n// 结果:\n// a = 1\n// b = undefined\n// Array []\n```\n\n`rest`参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`，所以，不再需要`arguments`我们就获取了全部参数。\n如果传入的参数连正常定义的参数都没填满，也不要紧，`rest`参数会接收一个空数组（注意不是`undefined`）。\n\n\n### 变量作用域\n在JavaScript中，用var申明的变量实际上是有作用域的。\n- 如果一个变量在函数体内部申明，则该变量的作用域为整个**函数体**(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。\n- 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量\n- 如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\n\n#### 变量提升\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：\n```javascript\n'use strict';\n\nfunction foo() {\n    var x = 'Hello, ' + y;\n    alert(x);\n    var y = 'Bob';\n}\n\nfoo();\n```\n\n虽然是`strict`模式，但语句`var x = 'Hello, ' + y;`并不报错，原因是变量`y`在稍后申明了。但是`alert`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。\n\n#### 全局作用域\n不在任何函数内定义的变量就具有全局作用域。\n\n#### 名字空间\n不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n```javascript\n// 唯一的全局变量MYAPP:\nvar MYAPP = {};\n\n// 其他变量:\nMYAPP.name = 'myapp';\nMYAPP.version = 1.0;\n\n// 其他函数:\nMYAPP.foo = function () {\n    return 'foo';\n};\n```\n\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\n\n#### 局部作用域\n由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：\n```javascript\n'use strict';\n\nfunction foo() {\n    for (var i=0; i<100; i++) {\n        //\n    }\n    i += 100; // 仍然可以引用变量i\n}\n```\n\n为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：\n```javascript\n'use strict';\n\nfunction foo() {\n    var sum = 0;\n    for (let i=0; i<100; i++) {\n        sum += i;\n    }\n    i += 1; // SyntaxError\n}\n```\n\n#### 常量\n由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.\n\nES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：\n```javascript\n'use strict';\n\nconst PI = 3.14;\nPI = 3; // 某些浏览器不报错，但是无效果！\nPI; // 3.14\n```\n\n注意，一定要加上`use strict`,否则会报错。\n\n### 方法\n绑定到对象上的函数称为方法:\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var y = new Date().getFullYear();\n        return y - this.birth;\n    }\n};\n\nxiaoming.age; // function xiaoming.age()\nxiaoming.age(); // 今年调用是25,明年调用就变成26了\n```\n\n和普通函数也没啥区别，但是它在内部使用了一个`this`关键字.\n在一个方法内部，`this`是一个特殊变量，**它始终指向当前对象**，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。\n\n让我们拆开写：\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25, 正常结果\ngetAge(); // NaN\n```\n\n单独调用函数`getAge()`怎么返回了`NaN`？请注意，我们已经进入到了JavaScript的一个大坑里。\nJavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？\n答案是，视情况而定！\n如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。\n如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向**全局对象**.\n\n更坑爹的是，如果这么写：\n```javascript\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数\nfn(); // NaN\n```\n也是不行的！要保证`this`指向正确，必须要给出明确的上下文，必须用`obj.xxx()`的形式调用！谁调用，`this`就是指谁。上面仅仅相当于将`age`方法赋给`fn`.\n\n如果是这种情况：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - this.birth;\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); \n```\n\n又不对了。原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！需要这样修改：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var that = this; // 在方法内部一开始就捕获this\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - that.birth; // 用that而不是this\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); // 25\n```\n\n用`var that = this`;将`age`中的`this`捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\n\n#### apply\n我们还是可以控制`this`的指向的！\n\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\n\n用`apply`修复`getAge()`调用:\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25\ngetAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\n```\n\n再举一个例子：\n\n```javascript\nvar numbers = {  \n   numberA: 5,\n   numberB: 10,\n   sum: function() {\n     console.log(this === numbers); // => true\n     function calculate() {\n       // this is window or undefined in strict mode\n       console.log(this === numbers); // => false\n       return this.numberA + this.numberB;\n     }\n     return calculate();\n   }\n};\nnumbers.sum(); // => NaN or throws TypeError in strict mode  \n\nvar numbers = {  \n   numberA: 5,\n   numberB: 10,\n   sum: function() {\n     console.log(this === numbers); // => true\n     function calculate() {\n       console.log(this === numbers); // => true\n       return this.numberA + this.numberB;\n     }\n     // use .call() method to modify the context\n     return calculate.call(this);\n   }\n};\nnumbers.sum(); // => 15\n\n```\n\n\n上面的`call()`与`apply()`是类似的方法，唯一区别是：\n- `apply()`把参数打包成`Array`再传入；\n- `call()`把参数按顺序传入。 \n\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\n```javascript\nMath.max.apply(null, [3, 5, 4]); // 5\nMath.max.call(null, 3, 5, 4); // 5\n```\n对普通函数调用，我们通常把this绑定为null。\n\n#### .bind()\n\n对比方法 `.apply()` 和 `.call()`，它俩都立即执行了函数，而 `.bind()` 函数返回了一个新方法，绑定了预先指定好的 `this` ，并可以延后调用。`.bind()` 方法的作用是创建一个新的函数，执行时的上下文环境为 `.bind()` 传递的第一个参数，它允许创建预先设置好 `this` 的函数。\n\n```javascript\nvar numbers = {  \n  array: [3, 5, 10],\n  getNumbers: function() {\n    return this.array;    \n  }\n};\n// Create a bound function\nvar boundGetNumbers = numbers.getNumbers.bind(numbers);  \nboundGetNumbers(); // => [3, 5, 10]  \n// Extract method from object\nvar simpleGetNumbers = numbers.getNumbers;  \nsimpleGetNumbers(); // => undefined or throws an error in strict mode  \n```\n\n使用 `.bind()` 时应该注意，`.bind()` 创建了一个永恒的上下文链并不可修改。一个绑定函数即使使用 `.call()` 或者 `.apply()`传入其他不同的上下文环境，也不会更改它之前连接的上下文环境，重新绑定也不会起任何作用。\n\n\n#### 装饰器\n利用`apply()`，我们还可以动态改变函数的行为。\n\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以**重新指向新的函数**。\n\n现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：\n```javascript\nvar count = 0;\nvar oldParseInt = parseInt; // 保存原函数\n\nwindow.parseInt = function () {\n    count += 1;\n    return oldParseInt.apply(null, arguments); // 调用原函数\n};\n\n// 测试:\nparseInt('10');\nparseInt('20');\nparseInt('30');\ncount; // 3\n```\n\n### 高阶函数\n一个可以接收另一个函数作为参的函数，称为高阶函数。\n#### map\n`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：\n```javascript\nfunction pow(x) {\n    return x * x;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n`map()`将传入的函数一一作用在数组的每一个元素上。\n\n#### reduce\n`Array`的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n```javascipt\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n```\n\n比如对`Array`求和：\n```javascript\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n}); // 25\n```\n\n#### filter\n用于把`Array`的某些元素过滤掉，然后返回剩下的元素\n`Array`的`filter()`接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：\n```javascript\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\nvar r = arr.filter(function (x) {\n    return x % 2 !== 0;\n});\nr; // [1, 5, 9, 15]\n```\n\n#### sort\n可以接收一个比较函数来实现自定义的排序\n要按数字大小排序，我们可以这么写：\n```javascript\nvar arr = [10, 20, 1, 2];\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n}); // [1, 2, 10, 20]\n```\n\n**注意**：`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`\n\n### 闭包\n#### 函数作为返回值\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n比如返回一个求和的函数：\n```javascript\nfunction lazy_sum(arr) {\n    var sum = function () {\n        return arr.reduce(function (x, y) {\n            return x + y;\n        });\n    }\n    return sum;\n}\n```\n当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：\n```javascript\nvar f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n```\n调用函数f时，才真正计算求和的结果：\n```javascript\nf(); // 15\n```\n当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中`this`不遵循闭包)\n\n#### 闭包\n需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push(function () {\n            return i * i;\n        });\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n```\n\n上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，**或者说返回了三个闭包**.\n调用的结果全是`16`,因为返回函数都引用了变量`i`，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了`4`。\n\n**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function (n) {\n            return function () {\n                return n * n;\n            }\n        })(i));\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n\nf1(); // 1\nf2(); // 4\nf3(); // 9\n```\n\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\n```\n(function (x) {\n    return x * x;\n})(3); // 9\n``` \n\n**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            var n =i\n            return function () {\n                return n*n;\n            }\n        })());\n    }\n    return arr;\n}\n```\n相反的，如果内存函数还是用的`i`，那么结果就会全是`16`.\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            // var n =i\n            return function () {\n                return i*i;\n            }\n        })());\n    }\n    return arr;\n}\n```\n\n### 箭头函数\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\n```javascript\nx => x*x\n```\n相当于一个输入为`x`输出为`x*x`的匿名函数\n```\nfunction (x) {\n    return x * x;\n}\n```\n如果参数不是一个，就需要用括号()括起来：\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n语法糖，类似于python中的lambda函数\n\n当然，箭头函数还是有点用处的，由于是es6的新特性，**箭头函数内部的this是词法作用域**，由上下文确定。\n试做比较：\n```\n//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = function () {\n            return new Date().getFullYear() - this.birth; // this指向window或undefined\n        };\n        return fn();\n    }\n};\n//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25\n```\n如果使用箭头函数,以前 `var that = this;` 以及 `.apply()` 和 `.call()` 这种写法就不需要了。\n\n箭头函数并不创建它自身执行的上下文，使得 `this` 取决于它在定义时的外部函数。**箭头函数一次绑定上下文后便不可更改，即使使用了上下文更改的方法**：\n\n```javascript\n    var numbers = [1, 2];  \n    (function() {  \n      var get = () => {\n        console.log(this === numbers); // => true\n        return this;\n      };\n      console.log(this === numbers); // => true\n      get(); // => [1, 2]\n      // 箭头函数使用 .apply() 和 .call()\n      get.call([0]);  // => [1, 2]\n      get.apply([0]); // => [1, 2]\n      // Bind\n      get.bind([0])(); // => [1, 2]\n    }).call(numbers);\n```\n\n这是因为箭头函数拥有静态的上下文环境，不会因为不同的调用而改变。但是要注意：\n\n```javascript\n\tfunction Period (hours, minutes) {  \n      this.hours = hours;\n      this.minutes = minutes;\n    }\n    Period.prototype.format = () => {  \n      console.log(this === window); // => true\n      return this.hours + ' hours and ' + this.minutes + ' minutes';\n    };\n    var walkPeriod = new Period(2, 30);  \n    walkPeriod.format(); // => 'undefined hours and undefined minutes' \n```\n\n注意这里的 `this === window` 返回的是 `true`。\n\n### generator\ngenerator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。\n\n定义如下：\n```javascript\nfunction* foo(x) {\n    yield x + 1;\n    yield x + 2;\n    return x + 3;\n}\n```\ngenerator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。好处就是**函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。**(其实这东西很像调试函数时候的断点！)\n\n执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：\n```javascript\nvar f = fib(5);\nf.next(); // {value: 0, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 1, done: true}\n```\n`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。\n\n第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：\n```javascript\nfor (var x of fib(5)) {\n    console.log(x); // 依次输出0, 1, 1\n}\n```\n\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。**看起来蛮有用的**\n\n举个例子，要生成一个自增的ID，可以编写一个next_id()函数：\n```javascript\nvar current_id = 0;\n\nfunction next_id() {\n    current_id ++;\n    return current_id;\n}\n```\n\n由于函数无法保存状态，故需要一个全局变量`current_id`来保存数字。现在改用generator：\n```javascript\nfunction* next_id() {\n\tvar i = 0;\n\twhile (true){\n    \tyield ++i;\n   \t}\n}\n```\n\n## 标准对象\n一些原则：\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\n- 判断`Array`要使用`Array.isArray(arr)`；\n- 判断`null`请使用`myVar === null`；\n- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；\n\n### Date\n在JavaScript中，`Date`对象用来表示日期和时间。\n\n要获取系统当前时间，用：\n```javascript\nvar now = new Date();\nnow; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\nnow.getFullYear(); // 2015, 年份\nnow.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月\nnow.getDate(); // 24, 表示24号\nnow.getDay(); // 3, 表示星期三\nnow.getHours(); // 19, 24小时制\nnow.getMinutes(); // 49, 分钟\nnow.getSeconds(); // 22, 秒\nnow.getMilliseconds(); // 875, 毫秒数\nnow.getTime(); // 1435146562875, 以number形式表示的时间戳\n```\n\n如果要创建一个指定日期和时间的Date对象，可以用：\n```javascript\nvar d = new Date(2015, 5, 19, 20, 15, 30, 123);\nd; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)\n```\n\n一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是`0~11`，`0`表示一月，`1`表示二月……，所以要表示`6`月，我们传入的是`5`！\n\n第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：\n```javascript\nvar d = Date.parse('2015-06-24T19:49:22.875+08:00');\nd; // 1435146562875\n```\n但它返回的不是`Date`对象，而是一个**时间戳**。不过有时间戳就可以很容易地把它转换为一个`Date`：\n```javascript\nvar d = new Date(1435146562875);\nd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\n```\n\n时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。\n\n要获取当前时间戳，可以用：\n```javascript\nif (Date.now) {\n    alert(Date.now()); // 老版本IE没有now()方法\n} else {\n    alert(new Date().getTime());\n}\n```\n\n### Json\nJSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：\n- number：和JavaScript的`number`完全一致；\n- boolean：就是JavaScript的`true`或`false`；\n- string：就是JavaScript的`string`；\n- null：就是JavaScript的`null`；\n- array：就是JavaScript的`Array`表示方式——`[]`；\n- object：就是JavaScript的`{ ... }`表示方式。\n\n#### 序列化\n先把小明这个对象序列化成JSON格式的字符串：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\n};\n\nJSON.stringify(xiaoming); // '{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]}'\n```\n\n要输出得好看一些，可以加上参数，按缩进输出：\n```javascript\nJSON.stringify(xiaoming, null, '  ');\n```\n结果：\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：\n```javacript\nJSON.stringify(xiaoming, ['name', 'skills'], '  ');\n```\n结果:\n```javascript\n{\n  \"name\": \"小明\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n还可以传入一个函数，这样对象的每个键值对都会被函数先处理：\n```javascript\nfunction convert(key, value) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value;\n}\n\nJSON.stringify(xiaoming, convert, '  ');\n```\n上面的代码把所有属性值都变成大写：\n\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\n  \"skills\": [\n    \"JAVASCRIPT\",\n    \"JAVA\",\n    \"PYTHON\",\n    \"LISP\"\n  ]\n}\n```\n如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],\n    toJSON: function () {\n        return { // 只输出name和age，并且改变了key：\n            'Name': this.name,\n            'Age': this.age\n        };\n    }\n};\n\nJSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}'\n```\n\n#### 反序列化\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：\n```javascript\nJSON.parse('[1,2,3,true]'); // [1, 2, 3, true]\nJSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}\nJSON.parse('true'); // true\nJSON.parse('123.45'); // 123.45\n```\n`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：\n```javascript\nJSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) {\n    // 把number * 2:\n    if (key === 'name') {\n        return value + '同学';\n    }\n    return value;\n}); // Object {name: '小明同学', age: 14}\n```\n\n## 面向对象编程\nJavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\n\nprototype有点类似于继承，`A`的原型是`B`，意味着，`A`拥有`B`的全部属性。\n```javascript\n// 原型对象:\nvar Student = {\n    name: 'Robot',\n    height: 1.2,\n    run: function () {\n        console.log(this.name + ' is running...');\n    }\n};\n\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 创建对象\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\n\n例如，创建一个`Array`对象：\n```javascript\nvar arr = [1, 2, 3];\n```\n其原型链是：\n```javascript\narr ----> Array.prototype ----> Object.prototype ----> null\n```\n`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。\n\n当我们创建一个函数时：\n```javascript\nfunction foo() {\n    return 0;\n}\n```\n函数也是一个对象，它的原型链是：\n```javascript\nfoo ----> Function.prototype ----> Object.prototype ----> null\n```\n由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。\n\n#### 构造函数\n除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\n```\n注意，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\n\n用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\n\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\n\nxiaoming instanceof Student; // true\n```\n他们之间的关系就是:\n![constructor](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true)\n\n红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。\n\n另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\n\n不过还有一个小问题，注意观察：\n```javascript\nxiaoming.name; // '小明'\nxiaohong.name; // '小红'\nxiaoming.hello; // function: Student.hello()\nxiaohong.hello; // function: Student.hello()\nxiaoming.hello === xiaohong.hello; // false\n```\n`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！\n\n如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。\n要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：\n![constructor2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true)\n修改代码如下：\n```javascript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n### class继承\n新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n我们先回顾用函数实现`Student`的方法：\n```javscript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n\n如果用新的`class`关键字来编写`Student`，可以这样写：\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，`class`的定义包含了**构造函数**`constructor`和定义在原型对象上的函数`hello()`（注意没有`function`关键字），这样就避免了`Student.prototype.hello = function () {...}`这样分散的代码。\n\n最后，创建一个Student对象代码和前面章节完全一样：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.hello();\n```\n\n#### class继承\n用`class`定义对象的另一个巨大的好处是继承更方便了,直接通过`extends`来实现：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n通过`super(name)`来调用父类的构造函数。`PrimaryStudent`已经自动获得了父类`Student`的`hello`方法，我们又在子类中定义了新的`myGrade`方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JavaScript基本语法","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dor000j7hzg260489x7","content":"<p>参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"external\">廖雪峰的JavaScript教程</a></p>\n<a id=\"more\"></a>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p>JS不区分整数浮点数，统一用<code>Number</code>表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.2345e3</span>; <span class=\"comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class=\"line\"><span class=\"literal\">NaN</span>; <span class=\"comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class=\"line\"><span class=\"literal\">Infinity</span>; <span class=\"comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure></p>\n<p><code>Number</code>可以直接运算：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 7.5</span></div><div class=\"line\"><span class=\"number\">2</span> / <span class=\"number\">0</span>; <span class=\"comment\">// Infinity</span></div><div class=\"line\"><span class=\"number\">0</span> / <span class=\"number\">0</span>; <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"number\">10</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1 (取余)</span></div><div class=\"line\"><span class=\"number\">10.5</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1.5</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本.如<code>&#39;abc&#39;</code> </p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>用<code>true</code>和<code>false</code>表示。</p>\n<h4 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h4><p>JavaScript在设计时，有两种比较运算符：<br>第一种是<code>==</code>比较，它会自动转换数据类型再比较.<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>\n<p><code>NaN</code>这个特殊的<code>Number</code>与所有其他值都不相等，包括它自己：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span> / <span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>JavaScript的数组可以包括任意数据类型。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>另一种创建数组的方法是通过Array()函数实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure></p>\n<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>\n<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">// 返回索引为0的元素，即1</span></div><div class=\"line\">arr[<span class=\"number\">5</span>]; <span class=\"comment\">// 返回索引为5的元素，即true</span></div><div class=\"line\">arr[<span class=\"number\">6</span>]; <span class=\"comment\">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Bob'</span>,</div><div class=\"line\">    age: <span class=\"number\">20</span>,</div><div class=\"line\">    tags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</div><div class=\"line\">    city: <span class=\"string\">'Beijing'</span>,</div><div class=\"line\">    hasCar: <span class=\"literal\">true</span>,</div><div class=\"line\">    zipcode: <span class=\"literal\">null</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JavaScript对象的键都是<strong>字符串类型</strong>，值可以是任意数据类型。</p>\n<p>要获取一个对象的属性，我们用对象变量.属性名的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">person.name; <span class=\"comment\">// 'Bob'</span></div><div class=\"line\">person.zipcode; <span class=\"comment\">// null</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>申明一个变量用var语句，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// 申明了变量a，此时a的值为undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> $b = <span class=\"number\">1</span>; <span class=\"comment\">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class=\"line\"><span class=\"keyword\">var</span> s_007 = <span class=\"string\">'007'</span>; <span class=\"comment\">// s_007是一个字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> Answer = <span class=\"literal\">true</span>; <span class=\"comment\">// Answer是一个布尔值true</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"literal\">null</span>; <span class=\"comment\">// t的值是null</span></div></pre></td></tr></table></figure></p>\n<p>注意只能用var申明一次。</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。</p>\n<p>启用strict模式的方法是在JavaScript代码的第一行写上：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div></pre></td></tr></table></figure></p>\n<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>\n<h3 id=\"字符串-1\"><a href=\"#字符串-1\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好, '</span> + name + <span class=\"string\">', 你今年'</span> + age + <span class=\"string\">'岁了!'</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`你好, <span class=\"subst\">$&#123;name&#125;</span>, 你今年<span class=\"subst\">$&#123;age&#125;</span>岁了!`</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<h4 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a>操作字符串</h4><p>字符串常见的操作如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\">s.length; <span class=\"comment\">// 13</span></div></pre></td></tr></table></figure></p>\n<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s[<span class=\"number\">0</span>]; <span class=\"comment\">// 'H'</span></div><div class=\"line\">s[<span class=\"number\">6</span>]; <span class=\"comment\">// ' '</span></div><div class=\"line\">s[<span class=\"number\">7</span>]; <span class=\"comment\">// 'w'</span></div><div class=\"line\">s[<span class=\"number\">12</span>]; <span class=\"comment\">// '!'</span></div><div class=\"line\">s[<span class=\"number\">13</span>]; <span class=\"comment\">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure></p>\n<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.</p>\n<h4 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase\"></a>toUpperCase</h4><p><code>toUpperCase()</code>返回一个全大写的字符串</p>\n<h4 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase\"></a>toLowerCase</h4><p><code>toLowerCase()</code>f返回一个全小写的字符串</p>\n<h4 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p><code>indexOf()</code>会搜索指定字符串出现的位置:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span>;</div><div class=\"line\">s.indexOf(<span class=\"string\">'world'</span>); <span class=\"comment\">// 返回7</span></div><div class=\"line\">s.indexOf(<span class=\"string\">'World'</span>); <span class=\"comment\">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"substring\"><a href=\"#substring\" class=\"headerlink\" title=\"substring\"></a>substring</h4><p><code>substring()</code>返回指定索引区间的子串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span></div><div class=\"line\">s.substring(<span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class=\"line\">s.substring(<span class=\"number\">7</span>); <span class=\"comment\">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 3</span></div><div class=\"line\">arr.length = <span class=\"number\">6</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class=\"line\">arr.length = <span class=\"number\">2</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2]</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure></p>\n<p><strong>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>\n<h4 id=\"indexOf-1\"><a href=\"#indexOf-1\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p>与<code>String</code>类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</div><div class=\"line\">arr.indexOf(<span class=\"number\">10</span>); <span class=\"comment\">// 元素10的索引为0</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">20</span>); <span class=\"comment\">// 元素20的索引为1</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">30</span>); <span class=\"comment\">// 元素30没有找到，返回-1</span></div><div class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>); <span class=\"comment\">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p><code>slice()</code>就是对应<code>String</code>的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>];</div><div class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class=\"line\">arr.slice(<span class=\"number\">3</span>); <span class=\"comment\">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure></p>\n<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code></p>\n<h4 id=\"push和pop\"><a href=\"#push和pop\" class=\"headerlink\" title=\"push和pop\"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加<strong>若干</strong>元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.push(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A', 'B']</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// pop()返回'B'</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A']</span></div><div class=\"line\">arr.pop(); arr.pop(); arr.pop(); <span class=\"comment\">// 连续pop 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// 空数组继续pop不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"unshift和shift\"><a href=\"#unshift和shift\" class=\"headerlink\" title=\"unshift和shift\"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.unshift(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 1, 2]</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 'A'</span></div><div class=\"line\">arr; <span class=\"comment\">// ['B', 1, 2]</span></div><div class=\"line\">arr.shift(); arr.shift(); arr.shift(); <span class=\"comment\">// 连续shift 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 空数组继续shift不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>reverse()把整个Array的元素给掉个个，也就是反转.</p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class=\"line\">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class=\"line\">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只删除,不添加:</div><div class=\"line\">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只添加,不删除:</div><div class=\"line\">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">added; <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>\n<p>请注意，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。<br>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">arr.concat(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure></p>\n<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>\n<h3 id=\"对象-1\"><a href=\"#对象-1\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小红'</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'No.1 Middle School'</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaohong[<span class=\"string\">'middle-school'</span>]; <span class=\"comment\">// 'No.1 Middle School'</span></div><div class=\"line\">xiaohong[<span class=\"string\">'name'</span>]; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div></pre></td></tr></table></figure></p>\n<p>如果属性名是其他对象，那么需要用<code>[]</code>将其括起来，表示对外部对象执行<code>toString()</code>操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"1weight\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name :  <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">    [weight()] :<span class=\"string\">\"属性名是返回值1weight\"</span>,</div><div class=\"line\">    [weight]:<span class=\"string\">\"属性名是整个function\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xiaoming)</div><div class=\"line\">返回：</div><div class=\"line\">&#123; name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">  <span class=\"string\">'1weight'</span>: <span class=\"string\">'属性名是返回值1weight'</span>,</div><div class=\"line\">  <span class=\"string\">'function () &#123;\\n    return \"1weight\"\\n&#125;'</span>: <span class=\"string\">'属性名是整个function'</span> &#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\">xiaoming.age = <span class=\"number\">18</span>; <span class=\"comment\">// 新增一个age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// 18</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.age; <span class=\"comment\">// 删除age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming[<span class=\"string\">'name'</span>]; <span class=\"comment\">// 删除name属性</span></div><div class=\"line\">xiaoming.name; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.school; <span class=\"comment\">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure></p>\n<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符,不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'name'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'toString'</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Map和Set\"><a href=\"#Map和Set\" class=\"headerlink\" title=\"Map和Set\"></a>Map和Set</h3><p>JS中默认对象表达方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。<br>但是JavaScript的对象有个小问题，就是<strong>键必须是字符串</strong>。但实际上Number或者其他数据类型作为键也是非常合理的。<br>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">95</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">75</span>], [<span class=\"string\">'Tracy'</span>, <span class=\"number\">85</span>]]);</div><div class=\"line\">m.delete(<span class=\"string\">'Adam'</span>); <span class=\"comment\">// 删除key 'Adam'</span></div><div class=\"line\">m.get(<span class=\"string\">'Michael'</span>); <span class=\"comment\">// 95</span></div><div class=\"line\">m.set(<span class=\"string\">'Zachary'</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h4><p>重复元素在Set中自动被过滤：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"string\">'3'</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3, \"3\"&#125;</span></div></pre></td></tr></table></figure></p>\n<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>\n<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>通过delete(key)方法可以删除元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3&#125;</span></div><div class=\"line\">s.delete(<span class=\"number\">3</span>);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"iterable\"><a href=\"#iterable\" class=\"headerlink\" title=\"iterable\"></a>iterable</h3><p>ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>\n<p>用<code>for ... of</code>循环遍历集合，用法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"string\">'x'</span>], [<span class=\"number\">2</span>, <span class=\"string\">'y'</span>], [<span class=\"number\">3</span>, <span class=\"string\">'z'</span>]]);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> a) &#123; <span class=\"comment\">// 遍历Array</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> s) &#123; <span class=\"comment\">// 遍历Set</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> m) &#123; <span class=\"comment\">// 遍历Map</span></div><div class=\"line\">    alert(x[<span class=\"number\">0</span>] + <span class=\"string\">'='</span> + x[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</strong><br><code>for ... in</code>实际上是<strong>对象的属性名称(注意，是键，不是值)</strong>。不要用在<code>Array</code>,<code>Set</code>,<code>Map</code>上，会出现奇怪的问题。<br><code>for ... of</code>循环则完全修复了这些问题，它<strong>只循环得到集合内该出现的元素(注意，是值，不是键)</strong>，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.name = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">a[<span class=\"string\">'4'</span>] = <span class=\"string\">'D'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> num <span class=\"keyword\">of</span> a)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(num)</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">[ <span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, , <span class=\"string\">'D'</span>, name: <span class=\"string\">'Hello'</span> ]</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">D</div></pre></td></tr></table></figure></p>\n<p><code>name</code>由于不是正常<code>Array</code>该有的，所以在<code>for ... of</code>循环时，其对应的值不会被输出。</p>\n<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// element: 指向当前元素的值</span></div><div class=\"line\">    <span class=\"comment\">// index: 指向当前索引</span></div><div class=\"line\">    <span class=\"comment\">// array: 指向Array对象本身</span></div><div class=\"line\">    alert(element);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>Set</code>来说，由于没有索引，<code>index</code>也是指当前元素。<br>对于<code>Map</code>来说，<code>element</code>和<code>index</code>分别对应<code>Value</code>和<code>Key</code>.</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数定义和调用\"><a href=\"#函数定义和调用\" class=\"headerlink\" title=\"函数定义和调用\"></a>函数定义和调用</h3><h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><p>方式一：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>\n<p>方式二：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> abs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>\n<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>\n<h4 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h4><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(<span class=\"number\">10</span>, <span class=\"string\">'blablabla'</span>); <span class=\"comment\">// 返回10</span></div><div class=\"line\">abs(<span class=\"number\">-9</span>, <span class=\"string\">'haha'</span>, <span class=\"string\">'hehe'</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// 返回9</span></div></pre></td></tr></table></figure></p>\n<p>传入的参数比定义的少也没有问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(); <span class=\"comment\">// 返回NaN</span></div></pre></td></tr></table></figure></p>\n<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>\n<p>要避免收到undefined，可以对参数进行检查：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> x) !== <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'Not a number'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    alert(x); <span class=\"comment\">// 10</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++) &#123;</div><div class=\"line\">        alert(<span class=\"built_in\">arguments</span>[i]); <span class=\"comment\">// 10, 20, 30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</div></pre></td></tr></table></figure></p>\n<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。</p>\n<h4 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h4><p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数.<br>ES6标准引入了<code>rest</code>参数，可以将剩余的参数放在<code>rest</code>中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b, ...rest</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a = '</span> + a);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b = '</span> + b);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(rest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = 2</span></div><div class=\"line\"><span class=\"comment\">// Array [ 3, 4, 5 ]</span></div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = undefined</span></div><div class=\"line\"><span class=\"comment\">// Array []</span></div></pre></td></tr></table></figure></p>\n<p><code>rest</code>参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。<br>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code>参数会接收一个空数组（注意不是<code>undefined</code>）。</p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>\n<ul>\n<li>如果一个变量在函数体内部申明，则该变量的作用域为整个<strong>函数体</strong>(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。</li>\n<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量</li>\n<li>如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>\n</ul>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">'Hello, '</span> + y;</div><div class=\"line\">    alert(x);</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"string\">'Bob'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>虽然是<code>strict</code>模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。</p>\n<h4 id=\"名字空间\"><a href=\"#名字空间\" class=\"headerlink\" title=\"名字空间\"></a>名字空间</h4><p>不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一的全局变量MYAPP:</span></div><div class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他变量:</span></div><div class=\"line\">MYAPP.name = <span class=\"string\">'myapp'</span>;</div><div class=\"line\">MYAPP.version = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他函数:</span></div><div class=\"line\">MYAPP.foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>\n<h4 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">100</span>; <span class=\"comment\">// 仍然可以引用变量i</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        sum += i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><p>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.</p>\n<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.14</span>;</div><div class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 某些浏览器不报错，但是无效果！</span></div><div class=\"line\">PI; <span class=\"comment\">// 3.14</span></div></pre></td></tr></table></figure></p>\n<p>注意，一定要加上<code>use strict</code>,否则会报错。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>绑定到对象上的函数称为方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">        <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// function xiaoming.age()</span></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure></p>\n<p>和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.<br>在一个方法内部，<code>this</code>是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>\n<p>让我们拆开写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25, 正常结果</span></div><div class=\"line\">getAge(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？请注意，我们已经进入到了JavaScript的一个大坑里。<br>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？<br>答案是，视情况而定！<br>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。<br>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向<strong>全局对象</strong>.</p>\n<p>更坑爹的是，如果这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = xiaoming.age; <span class=\"comment\">// 先拿到xiaoming的age函数</span></div><div class=\"line\">fn(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>也是不行的！要保证<code>this</code>指向正确，必须要给出明确的上下文，必须用<code>obj.xxx()</code>的形式调用！谁调用，<code>this</code>就是指谁。上面仅仅相当于将<code>age</code>方法赋给<code>fn</code>.</p>\n<p>如果是这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age();</div></pre></td></tr></table></figure></p>\n<p>又不对了。原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！需要这样修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 在方法内部一开始就捕获this</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - that.birth; <span class=\"comment\">// 用that而不是this</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<p>用<code>var that = this</code>;将<code>age</code>中的<code>this</code>捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p>我们还是可以控制<code>this</code>的指向的！</p>\n<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>\n<p>用<code>apply</code>修复<code>getAge()</code>调用:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div><div class=\"line\">getAge.apply(xiaoming, []); <span class=\"comment\">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">   numberA: <span class=\"number\">5</span>,</div><div class=\"line\">   numberB: <span class=\"number\">10</span>,</div><div class=\"line\">   sum: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// this is window or undefined in strict mode</span></div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; false</span></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numberA + <span class=\"keyword\">this</span>.numberB;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> calculate();</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">numbers.sum(); <span class=\"comment\">// =&gt; NaN or throws TypeError in strict mode  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">   numberA: <span class=\"number\">5</span>,</div><div class=\"line\">   numberB: <span class=\"number\">10</span>,</div><div class=\"line\">   sum: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numberA + <span class=\"keyword\">this</span>.numberB;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// use .call() method to modify the context</span></div><div class=\"line\">     <span class=\"keyword\">return</span> calculate.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">numbers.sum(); <span class=\"comment\">// =&gt; 15</span></div></pre></td></tr></table></figure>\n<p>上面的<code>call()</code>与<code>apply()</code>是类似的方法，唯一区别是：</p>\n<ul>\n<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>\n<li><code>call()</code>把参数按顺序传入。 </li>\n</ul>\n<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"literal\">null</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure></p>\n<p>对普通函数调用，我们通常把this绑定为null。</p>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\".bind()\"></a>.bind()</h4><p>对比方法 <code>.apply()</code> 和 <code>.call()</code>，它俩都立即执行了函数，而 <code>.bind()</code> 函数返回了一个新方法，绑定了预先指定好的 <code>this</code> ，并可以延后调用。<code>.bind()</code> 方法的作用是创建一个新的函数，执行时的上下文环境为 <code>.bind()</code> 传递的第一个参数，它允许创建预先设置好 <code>this</code> 的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">  array: [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>],</div><div class=\"line\">  getNumbers: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.array;    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// Create a bound function</span></div><div class=\"line\"><span class=\"keyword\">var</span> boundGetNumbers = numbers.getNumbers.bind(numbers);  </div><div class=\"line\">boundGetNumbers(); <span class=\"comment\">// =&gt; [3, 5, 10]  </span></div><div class=\"line\"><span class=\"comment\">// Extract method from object</span></div><div class=\"line\"><span class=\"keyword\">var</span> simpleGetNumbers = numbers.getNumbers;  </div><div class=\"line\">simpleGetNumbers(); <span class=\"comment\">// =&gt; undefined or throws an error in strict mode</span></div></pre></td></tr></table></figure>\n<p>使用 <code>.bind()</code> 时应该注意，<code>.bind()</code> 创建了一个永恒的上下文链并不可修改。一个绑定函数即使使用 <code>.call()</code> 或者 <code>.apply()</code>传入其他不同的上下文环境，也不会更改它之前连接的上下文环境，重新绑定也不会起任何作用。</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>\n<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新指向新的函数</strong>。</p>\n<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> oldParseInt = <span class=\"built_in\">parseInt</span>; <span class=\"comment\">// 保存原函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.parseInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    count += <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> oldParseInt.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// 调用原函数</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 测试:</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'10'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'20'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'30'</span>);</div><div class=\"line\">count; <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>一个可以接收另一个函数作为参的函数，称为高阶函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p><code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pow</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.map(pow); <span class=\"comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure></p>\n<p><code>map()</code>将传入的函数一一作用在数组的每一个元素上。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p><code>Array</code>的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<p>比如对<code>Array</code>求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素<br><code>Array</code>的<code>filter()</code>接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> r = arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> !== <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">r; <span class=\"comment\">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort-1\"><a href=\"#sort-1\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>可以接收一个比较函数来实现自定义的排序<br>要按数字大小排序，我们可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;); <span class=\"comment\">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>比如返回一个求和的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazy_sum</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = lazy_sum([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// function sum()</span></div></pre></td></tr></table></figure></p>\n<p>调用函数f时，才真正计算求和的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(); <span class=\"comment\">// 15</span></div></pre></td></tr></table></figure></p>\n<p>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中<code>this</code>不遵循闭包)</p>\n<h4 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i * i;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div></pre></td></tr></table></figure></p>\n<p>上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，<strong>或者说返回了三个闭包</strong>.<br>调用的结果全是<code>16</code>,因为返回函数都引用了变量<code>i</code>，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了<code>4</code>。</p>\n<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> n * n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">f1(); <span class=\"comment\">// 1</span></div><div class=\"line\">f2(); <span class=\"comment\">// 4</span></div><div class=\"line\">f3(); <span class=\"comment\">// 9</span></div></pre></td></tr></table></figure></p>\n<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;)(3); // 9</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：</div><div class=\"line\">```javascript</div><div class=\"line\">function count() &#123;</div><div class=\"line\">    var arr = [];</div><div class=\"line\">    for (var i=1; i&lt;=3; i++) &#123;</div><div class=\"line\">        arr.push((function () &#123;</div><div class=\"line\">            var n =i</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                return n*n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>相反的，如果内存函数还是用的<code>i</code>，那么结果就会全是<code>16</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// var n =i</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> i*i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">x =&gt; x*x</div></pre></td></tr></table></figure></p>\n<p>相当于一个输入为<code>x</code>输出为<code>x*x</code>的匿名函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果参数不是一个，就需要用括号()括起来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 两个参数:</span></div><div class=\"line\">(x, y) =&gt; x * x + y * y</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 无参数:</span></div><div class=\"line\">() =&gt; <span class=\"number\">3.14</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可变参数:</span></div><div class=\"line\">(x, y, ...rest) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> i, sum = x + y;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;rest.length; i++) &#123;</div><div class=\"line\">        sum += rest[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>语法糖，类似于python中的lambda函数</p>\n<p>当然，箭头函数还是有点用处的，由于是es6的新特性，<strong>箭头函数内部的this是词法作用域</strong>，由上下文确定。<br>试做比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = function () &#123;</div><div class=\"line\">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div></pre></td></tr></table></figure></p>\n<p>如果使用箭头函数,以前 <code>var that = this;</code> 以及 <code>.apply()</code> 和 <code>.call()</code> 这种写法就不需要了。</p>\n<p>箭头函数并不创建它自身执行的上下文，使得 <code>this</code> 取决于它在定义时的外部函数。<strong>箭头函数一次绑定上下文后便不可更改，即使使用了上下文更改的方法</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];  </div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  <span class=\"keyword\">var</span> get = () =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">  get(); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  <span class=\"comment\">// 箭头函数使用 .apply() 和 .call()</span></div><div class=\"line\">  get.call([<span class=\"number\">0</span>]);  <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  get.apply([<span class=\"number\">0</span>]); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  <span class=\"comment\">// Bind</span></div><div class=\"line\">  get.bind([<span class=\"number\">0</span>])(); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">&#125;).call(numbers);</div></pre></td></tr></table></figure>\n<p>这是因为箭头函数拥有静态的上下文环境，不会因为不同的调用而改变。但是要注意：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Period</span> (<span class=\"params\">hours, minutes</span>) </span>&#123;  </div><div class=\"line\">     <span class=\"keyword\">this</span>.hours = hours;</div><div class=\"line\">     <span class=\"keyword\">this</span>.minutes = minutes;</div><div class=\"line\">   &#125;</div><div class=\"line\">   Period.prototype.format = () =&gt; &#123;  </div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.hours + <span class=\"string\">' hours and '</span> + <span class=\"keyword\">this</span>.minutes + <span class=\"string\">' minutes'</span>;</div><div class=\"line\">   &#125;;</div><div class=\"line\">   <span class=\"keyword\">var</span> walkPeriod = <span class=\"keyword\">new</span> Period(<span class=\"number\">2</span>, <span class=\"number\">30</span>);  </div><div class=\"line\">   walkPeriod.format(); <span class=\"comment\">// =&gt; 'undefined hours and undefined minutes'</span></div></pre></td></tr></table></figure>\n<p>注意这里的 <code>this === window</code> 返回的是 <code>true</code>。</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>generator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。</p>\n<p>定义如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。好处就是<strong>函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。</strong>(其实这东西很像调试函数时候的断点！)</p>\n<p>执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = fib(<span class=\"number\">5</span>);</div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 0, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: true&#125;</span></div></pre></td></tr></table></figure></p>\n<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>\n<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> fib(<span class=\"number\">5</span>)) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 依次输出0, 1, 1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<strong>看起来蛮有用的</strong></p>\n<p>举个例子，要生成一个自增的ID，可以编写一个next_id()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> current_id = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    current_id ++;</div><div class=\"line\">    <span class=\"keyword\">return</span> current_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。现在改用generator：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    \t<span class=\"keyword\">yield</span> ++i;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"标准对象\"><a href=\"#标准对象\" class=\"headerlink\" title=\"标准对象\"></a>标准对象</h2><p>一些原则：</p>\n<ul>\n<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>\n<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>\n<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>\n<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>\n<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>\n<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>\n<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>\n<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>\n<p>要获取系统当前时间，用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">now; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class=\"line\">now.getFullYear(); <span class=\"comment\">// 2015, 年份</span></div><div class=\"line\">now.getMonth(); <span class=\"comment\">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class=\"line\">now.getDate(); <span class=\"comment\">// 24, 表示24号</span></div><div class=\"line\">now.getDay(); <span class=\"comment\">// 3, 表示星期三</span></div><div class=\"line\">now.getHours(); <span class=\"comment\">// 19, 24小时制</span></div><div class=\"line\">now.getMinutes(); <span class=\"comment\">// 49, 分钟</span></div><div class=\"line\">now.getSeconds(); <span class=\"comment\">// 22, 秒</span></div><div class=\"line\">now.getMilliseconds(); <span class=\"comment\">// 875, 毫秒数</span></div><div class=\"line\">now.getTime(); <span class=\"comment\">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>\n<p>如果要创建一个指定日期和时间的Date对象，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>, <span class=\"number\">30</span>, <span class=\"number\">123</span>);</div><div class=\"line\">d; <span class=\"comment\">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是<code>0~11</code>，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示<code>6</code>月，我们传入的是<code>5</code>！</p>\n<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Date</span>.parse(<span class=\"string\">'2015-06-24T19:49:22.875+08:00'</span>);</div><div class=\"line\">d; <span class=\"comment\">// 1435146562875</span></div></pre></td></tr></table></figure></p>\n<p>但它返回的不是<code>Date</code>对象，而是一个<strong>时间戳</strong>。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1435146562875</span>);</div><div class=\"line\">d; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>\n<p>要获取当前时间戳，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Date</span>.now) &#123;</div><div class=\"line\">    alert(<span class=\"built_in\">Date</span>.now()); <span class=\"comment\">// 老版本IE没有now()方法</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>JSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>\n<ul>\n<li>number：和JavaScript的<code>number</code>完全一致；</li>\n<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>\n<li>string：就是JavaScript的<code>string</code>；</li>\n<li>null：就是JavaScript的<code>null</code>；</li>\n<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>\n<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>\n</ul>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><p>先把小明这个对象序列化成JSON格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>要输出得好看一些，可以加上参数，按缩进输出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, <span class=\"literal\">null</span>, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" Middle School\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value.toUpperCase();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, convert, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码把所有属性值都变成大写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" MIDDLE SCHOOL\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JAVASCRIPT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"JAVA\"</span>,</div><div class=\"line\">    <span class=\"string\">\"PYTHON\"</span>,</div><div class=\"line\">    <span class=\"string\">\"LISP\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>],</div><div class=\"line\">    toJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"comment\">// 只输出name和age，并且改变了key：</span></div><div class=\"line\">            <span class=\"string\">'Name'</span>: <span class=\"keyword\">this</span>.name,</div><div class=\"line\">            <span class=\"string\">'Age'</span>: <span class=\"keyword\">this</span>.age</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"Name\":\"小明\",\"Age\":14&#125;'</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1,2,3,true]'</span>); <span class=\"comment\">// [1, 2, 3, true]</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>); <span class=\"comment\">// Object &#123;name: '小明', age: 14&#125;</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'123.45'</span>); <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure></p>\n<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 把number * 2:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'name'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"string\">'同学'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;); <span class=\"comment\">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>\n<p>prototype有点类似于继承，<code>A</code>的原型是<code>B</code>，意味着，<code>A</code>拥有<code>B</code>的全部属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 原型对象:</span></div><div class=\"line\"><span class=\"keyword\">var</span> Student = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Robot'</span>,</div><div class=\"line\">    height: <span class=\"number\">1.2</span>,</div><div class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running...'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStudent</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 基于Student原型创建一个新对象:</span></div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">Object</span>.create(Student);</div><div class=\"line\">    <span class=\"comment\">// 初始化新对象:</span></div><div class=\"line\">    s.name = name;</div><div class=\"line\">    <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = createStudent(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.run(); <span class=\"comment\">// 小明 is running...</span></div><div class=\"line\">xiaoming.__proto__ === Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>\n<p>例如，创建一个<code>Array</code>对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure></p>\n<p>其原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr ----&gt; <span class=\"built_in\">Array</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>\n<p>当我们创建一个函数时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数也是一个对象，它的原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo ----&gt; <span class=\"built_in\">Function</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaoming.hello(); <span class=\"comment\">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>\n<p>注意，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>\n<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.constructor === Student.prototype.constructor; <span class=\"comment\">// true</span></div><div class=\"line\">Student.prototype.constructor === Student; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">xiaoming <span class=\"keyword\">instanceof</span> Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>他们之间的关系就是:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true\" alt=\"constructor\"></p>\n<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>\n<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>\n<p>不过还有一个小问题，注意观察：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaoming.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaohong.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaoming.hello === xiaohong.hello; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>\n<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。<br>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true\" alt=\"constructor2\"><br>修改代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h3><p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n<p>我们先回顾用函数实现<code>Student</code>的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hello() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，<code>class</code>的定义包含了<strong>构造函数</strong><code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>\n<p>最后，创建一个Student对象代码和前面章节完全一样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.hello();</div></pre></td></tr></table></figure></p>\n<h4 id=\"class继承-1\"><a href=\"#class继承-1\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了,直接通过<code>extends</code>来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimaryStudent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, grade) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name); <span class=\"comment\">// 记得用super调用父类的构造方法!</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.grade = grade;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    myGrade() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'I am at grade '</span> + <span class=\"keyword\">this</span>.grade);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>super(name)</code>来调用父类的构造函数。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>\n","excerpt":"<p>参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\">廖雪峰的JavaScript教程</a></p>","more":"<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p>JS不区分整数浮点数，统一用<code>Number</code>表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.2345e3</span>; <span class=\"comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class=\"line\"><span class=\"literal\">NaN</span>; <span class=\"comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class=\"line\"><span class=\"literal\">Infinity</span>; <span class=\"comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure></p>\n<p><code>Number</code>可以直接运算：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 7.5</span></div><div class=\"line\"><span class=\"number\">2</span> / <span class=\"number\">0</span>; <span class=\"comment\">// Infinity</span></div><div class=\"line\"><span class=\"number\">0</span> / <span class=\"number\">0</span>; <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"number\">10</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1 (取余)</span></div><div class=\"line\"><span class=\"number\">10.5</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1.5</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本.如<code>&#39;abc&#39;</code> </p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>用<code>true</code>和<code>false</code>表示。</p>\n<h4 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h4><p>JavaScript在设计时，有两种比较运算符：<br>第一种是<code>==</code>比较，它会自动转换数据类型再比较.<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>\n<p><code>NaN</code>这个特殊的<code>Number</code>与所有其他值都不相等，包括它自己：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span> / <span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>JavaScript的数组可以包括任意数据类型。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>另一种创建数组的方法是通过Array()函数实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure></p>\n<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>\n<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">// 返回索引为0的元素，即1</span></div><div class=\"line\">arr[<span class=\"number\">5</span>]; <span class=\"comment\">// 返回索引为5的元素，即true</span></div><div class=\"line\">arr[<span class=\"number\">6</span>]; <span class=\"comment\">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Bob'</span>,</div><div class=\"line\">    age: <span class=\"number\">20</span>,</div><div class=\"line\">    tags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</div><div class=\"line\">    city: <span class=\"string\">'Beijing'</span>,</div><div class=\"line\">    hasCar: <span class=\"literal\">true</span>,</div><div class=\"line\">    zipcode: <span class=\"literal\">null</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JavaScript对象的键都是<strong>字符串类型</strong>，值可以是任意数据类型。</p>\n<p>要获取一个对象的属性，我们用对象变量.属性名的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">person.name; <span class=\"comment\">// 'Bob'</span></div><div class=\"line\">person.zipcode; <span class=\"comment\">// null</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>申明一个变量用var语句，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// 申明了变量a，此时a的值为undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> $b = <span class=\"number\">1</span>; <span class=\"comment\">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class=\"line\"><span class=\"keyword\">var</span> s_007 = <span class=\"string\">'007'</span>; <span class=\"comment\">// s_007是一个字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> Answer = <span class=\"literal\">true</span>; <span class=\"comment\">// Answer是一个布尔值true</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"literal\">null</span>; <span class=\"comment\">// t的值是null</span></div></pre></td></tr></table></figure></p>\n<p>注意只能用var申明一次。</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。</p>\n<p>启用strict模式的方法是在JavaScript代码的第一行写上：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div></pre></td></tr></table></figure></p>\n<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>\n<h3 id=\"字符串-1\"><a href=\"#字符串-1\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好, '</span> + name + <span class=\"string\">', 你今年'</span> + age + <span class=\"string\">'岁了!'</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`你好, <span class=\"subst\">$&#123;name&#125;</span>, 你今年<span class=\"subst\">$&#123;age&#125;</span>岁了!`</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<h4 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a>操作字符串</h4><p>字符串常见的操作如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\">s.length; <span class=\"comment\">// 13</span></div></pre></td></tr></table></figure></p>\n<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s[<span class=\"number\">0</span>]; <span class=\"comment\">// 'H'</span></div><div class=\"line\">s[<span class=\"number\">6</span>]; <span class=\"comment\">// ' '</span></div><div class=\"line\">s[<span class=\"number\">7</span>]; <span class=\"comment\">// 'w'</span></div><div class=\"line\">s[<span class=\"number\">12</span>]; <span class=\"comment\">// '!'</span></div><div class=\"line\">s[<span class=\"number\">13</span>]; <span class=\"comment\">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure></p>\n<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.</p>\n<h4 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase\"></a>toUpperCase</h4><p><code>toUpperCase()</code>返回一个全大写的字符串</p>\n<h4 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase\"></a>toLowerCase</h4><p><code>toLowerCase()</code>f返回一个全小写的字符串</p>\n<h4 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p><code>indexOf()</code>会搜索指定字符串出现的位置:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span>;</div><div class=\"line\">s.indexOf(<span class=\"string\">'world'</span>); <span class=\"comment\">// 返回7</span></div><div class=\"line\">s.indexOf(<span class=\"string\">'World'</span>); <span class=\"comment\">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"substring\"><a href=\"#substring\" class=\"headerlink\" title=\"substring\"></a>substring</h4><p><code>substring()</code>返回指定索引区间的子串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span></div><div class=\"line\">s.substring(<span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class=\"line\">s.substring(<span class=\"number\">7</span>); <span class=\"comment\">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 3</span></div><div class=\"line\">arr.length = <span class=\"number\">6</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class=\"line\">arr.length = <span class=\"number\">2</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2]</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure></p>\n<p><strong>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>\n<h4 id=\"indexOf-1\"><a href=\"#indexOf-1\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p>与<code>String</code>类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</div><div class=\"line\">arr.indexOf(<span class=\"number\">10</span>); <span class=\"comment\">// 元素10的索引为0</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">20</span>); <span class=\"comment\">// 元素20的索引为1</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">30</span>); <span class=\"comment\">// 元素30没有找到，返回-1</span></div><div class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>); <span class=\"comment\">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p><code>slice()</code>就是对应<code>String</code>的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>];</div><div class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class=\"line\">arr.slice(<span class=\"number\">3</span>); <span class=\"comment\">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure></p>\n<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code></p>\n<h4 id=\"push和pop\"><a href=\"#push和pop\" class=\"headerlink\" title=\"push和pop\"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加<strong>若干</strong>元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.push(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A', 'B']</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// pop()返回'B'</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A']</span></div><div class=\"line\">arr.pop(); arr.pop(); arr.pop(); <span class=\"comment\">// 连续pop 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// 空数组继续pop不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"unshift和shift\"><a href=\"#unshift和shift\" class=\"headerlink\" title=\"unshift和shift\"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.unshift(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 1, 2]</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 'A'</span></div><div class=\"line\">arr; <span class=\"comment\">// ['B', 1, 2]</span></div><div class=\"line\">arr.shift(); arr.shift(); arr.shift(); <span class=\"comment\">// 连续shift 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 空数组继续shift不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>reverse()把整个Array的元素给掉个个，也就是反转.</p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class=\"line\">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class=\"line\">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只删除,不添加:</div><div class=\"line\">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只添加,不删除:</div><div class=\"line\">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">added; <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>\n<p>请注意，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。<br>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">arr.concat(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure></p>\n<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>\n<h3 id=\"对象-1\"><a href=\"#对象-1\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小红'</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'No.1 Middle School'</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaohong[<span class=\"string\">'middle-school'</span>]; <span class=\"comment\">// 'No.1 Middle School'</span></div><div class=\"line\">xiaohong[<span class=\"string\">'name'</span>]; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div></pre></td></tr></table></figure></p>\n<p>如果属性名是其他对象，那么需要用<code>[]</code>将其括起来，表示对外部对象执行<code>toString()</code>操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"1weight\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name :  <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">    [weight()] :<span class=\"string\">\"属性名是返回值1weight\"</span>,</div><div class=\"line\">    [weight]:<span class=\"string\">\"属性名是整个function\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xiaoming)</div><div class=\"line\">返回：</div><div class=\"line\">&#123; name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">  <span class=\"string\">'1weight'</span>: <span class=\"string\">'属性名是返回值1weight'</span>,</div><div class=\"line\">  <span class=\"string\">'function () &#123;\\n    return \"1weight\"\\n&#125;'</span>: <span class=\"string\">'属性名是整个function'</span> &#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\">xiaoming.age = <span class=\"number\">18</span>; <span class=\"comment\">// 新增一个age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// 18</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.age; <span class=\"comment\">// 删除age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming[<span class=\"string\">'name'</span>]; <span class=\"comment\">// 删除name属性</span></div><div class=\"line\">xiaoming.name; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.school; <span class=\"comment\">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure></p>\n<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符,不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'name'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'toString'</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Map和Set\"><a href=\"#Map和Set\" class=\"headerlink\" title=\"Map和Set\"></a>Map和Set</h3><p>JS中默认对象表达方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。<br>但是JavaScript的对象有个小问题，就是<strong>键必须是字符串</strong>。但实际上Number或者其他数据类型作为键也是非常合理的。<br>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">95</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">75</span>], [<span class=\"string\">'Tracy'</span>, <span class=\"number\">85</span>]]);</div><div class=\"line\">m.delete(<span class=\"string\">'Adam'</span>); <span class=\"comment\">// 删除key 'Adam'</span></div><div class=\"line\">m.get(<span class=\"string\">'Michael'</span>); <span class=\"comment\">// 95</span></div><div class=\"line\">m.set(<span class=\"string\">'Zachary'</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h4><p>重复元素在Set中自动被过滤：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"string\">'3'</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3, \"3\"&#125;</span></div></pre></td></tr></table></figure></p>\n<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>\n<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>通过delete(key)方法可以删除元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3&#125;</span></div><div class=\"line\">s.delete(<span class=\"number\">3</span>);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"iterable\"><a href=\"#iterable\" class=\"headerlink\" title=\"iterable\"></a>iterable</h3><p>ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>\n<p>用<code>for ... of</code>循环遍历集合，用法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"string\">'x'</span>], [<span class=\"number\">2</span>, <span class=\"string\">'y'</span>], [<span class=\"number\">3</span>, <span class=\"string\">'z'</span>]]);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> a) &#123; <span class=\"comment\">// 遍历Array</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> s) &#123; <span class=\"comment\">// 遍历Set</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> m) &#123; <span class=\"comment\">// 遍历Map</span></div><div class=\"line\">    alert(x[<span class=\"number\">0</span>] + <span class=\"string\">'='</span> + x[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</strong><br><code>for ... in</code>实际上是<strong>对象的属性名称(注意，是键，不是值)</strong>。不要用在<code>Array</code>,<code>Set</code>,<code>Map</code>上，会出现奇怪的问题。<br><code>for ... of</code>循环则完全修复了这些问题，它<strong>只循环得到集合内该出现的元素(注意，是值，不是键)</strong>，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.name = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">a[<span class=\"string\">'4'</span>] = <span class=\"string\">'D'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> num <span class=\"keyword\">of</span> a)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(num)</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">[ <span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, , <span class=\"string\">'D'</span>, name: <span class=\"string\">'Hello'</span> ]</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">D</div></pre></td></tr></table></figure></p>\n<p><code>name</code>由于不是正常<code>Array</code>该有的，所以在<code>for ... of</code>循环时，其对应的值不会被输出。</p>\n<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// element: 指向当前元素的值</span></div><div class=\"line\">    <span class=\"comment\">// index: 指向当前索引</span></div><div class=\"line\">    <span class=\"comment\">// array: 指向Array对象本身</span></div><div class=\"line\">    alert(element);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>Set</code>来说，由于没有索引，<code>index</code>也是指当前元素。<br>对于<code>Map</code>来说，<code>element</code>和<code>index</code>分别对应<code>Value</code>和<code>Key</code>.</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数定义和调用\"><a href=\"#函数定义和调用\" class=\"headerlink\" title=\"函数定义和调用\"></a>函数定义和调用</h3><h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><p>方式一：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>\n<p>方式二：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> abs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>\n<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>\n<h4 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h4><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(<span class=\"number\">10</span>, <span class=\"string\">'blablabla'</span>); <span class=\"comment\">// 返回10</span></div><div class=\"line\">abs(<span class=\"number\">-9</span>, <span class=\"string\">'haha'</span>, <span class=\"string\">'hehe'</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// 返回9</span></div></pre></td></tr></table></figure></p>\n<p>传入的参数比定义的少也没有问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(); <span class=\"comment\">// 返回NaN</span></div></pre></td></tr></table></figure></p>\n<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>\n<p>要避免收到undefined，可以对参数进行检查：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> x) !== <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'Not a number'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    alert(x); <span class=\"comment\">// 10</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++) &#123;</div><div class=\"line\">        alert(<span class=\"built_in\">arguments</span>[i]); <span class=\"comment\">// 10, 20, 30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</div></pre></td></tr></table></figure></p>\n<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。</p>\n<h4 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h4><p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数.<br>ES6标准引入了<code>rest</code>参数，可以将剩余的参数放在<code>rest</code>中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b, ...rest</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a = '</span> + a);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b = '</span> + b);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(rest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = 2</span></div><div class=\"line\"><span class=\"comment\">// Array [ 3, 4, 5 ]</span></div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = undefined</span></div><div class=\"line\"><span class=\"comment\">// Array []</span></div></pre></td></tr></table></figure></p>\n<p><code>rest</code>参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。<br>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code>参数会接收一个空数组（注意不是<code>undefined</code>）。</p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>\n<ul>\n<li>如果一个变量在函数体内部申明，则该变量的作用域为整个<strong>函数体</strong>(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。</li>\n<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量</li>\n<li>如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>\n</ul>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">'Hello, '</span> + y;</div><div class=\"line\">    alert(x);</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"string\">'Bob'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>虽然是<code>strict</code>模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。</p>\n<h4 id=\"名字空间\"><a href=\"#名字空间\" class=\"headerlink\" title=\"名字空间\"></a>名字空间</h4><p>不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一的全局变量MYAPP:</span></div><div class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他变量:</span></div><div class=\"line\">MYAPP.name = <span class=\"string\">'myapp'</span>;</div><div class=\"line\">MYAPP.version = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他函数:</span></div><div class=\"line\">MYAPP.foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>\n<h4 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">100</span>; <span class=\"comment\">// 仍然可以引用变量i</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        sum += i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><p>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.</p>\n<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.14</span>;</div><div class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 某些浏览器不报错，但是无效果！</span></div><div class=\"line\">PI; <span class=\"comment\">// 3.14</span></div></pre></td></tr></table></figure></p>\n<p>注意，一定要加上<code>use strict</code>,否则会报错。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>绑定到对象上的函数称为方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">        <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// function xiaoming.age()</span></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure></p>\n<p>和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.<br>在一个方法内部，<code>this</code>是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>\n<p>让我们拆开写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25, 正常结果</span></div><div class=\"line\">getAge(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？请注意，我们已经进入到了JavaScript的一个大坑里。<br>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？<br>答案是，视情况而定！<br>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。<br>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向<strong>全局对象</strong>.</p>\n<p>更坑爹的是，如果这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = xiaoming.age; <span class=\"comment\">// 先拿到xiaoming的age函数</span></div><div class=\"line\">fn(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>也是不行的！要保证<code>this</code>指向正确，必须要给出明确的上下文，必须用<code>obj.xxx()</code>的形式调用！谁调用，<code>this</code>就是指谁。上面仅仅相当于将<code>age</code>方法赋给<code>fn</code>.</p>\n<p>如果是这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age();</div></pre></td></tr></table></figure></p>\n<p>又不对了。原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！需要这样修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 在方法内部一开始就捕获this</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - that.birth; <span class=\"comment\">// 用that而不是this</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<p>用<code>var that = this</code>;将<code>age</code>中的<code>this</code>捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p>我们还是可以控制<code>this</code>的指向的！</p>\n<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>\n<p>用<code>apply</code>修复<code>getAge()</code>调用:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div><div class=\"line\">getAge.apply(xiaoming, []); <span class=\"comment\">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>\n<p>再举一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">   numberA: <span class=\"number\">5</span>,</div><div class=\"line\">   numberB: <span class=\"number\">10</span>,</div><div class=\"line\">   sum: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// this is window or undefined in strict mode</span></div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; false</span></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numberA + <span class=\"keyword\">this</span>.numberB;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">return</span> calculate();</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">numbers.sum(); <span class=\"comment\">// =&gt; NaN or throws TypeError in strict mode  </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">   numberA: <span class=\"number\">5</span>,</div><div class=\"line\">   numberB: <span class=\"number\">10</span>,</div><div class=\"line\">   sum: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.numberA + <span class=\"keyword\">this</span>.numberB;</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// use .call() method to modify the context</span></div><div class=\"line\">     <span class=\"keyword\">return</span> calculate.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">numbers.sum(); <span class=\"comment\">// =&gt; 15</span></div></pre></td></tr></table></figure>\n<p>上面的<code>call()</code>与<code>apply()</code>是类似的方法，唯一区别是：</p>\n<ul>\n<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>\n<li><code>call()</code>把参数按顺序传入。 </li>\n</ul>\n<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"literal\">null</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure></p>\n<p>对普通函数调用，我们通常把this绑定为null。</p>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\".bind()\"></a>.bind()</h4><p>对比方法 <code>.apply()</code> 和 <code>.call()</code>，它俩都立即执行了函数，而 <code>.bind()</code> 函数返回了一个新方法，绑定了预先指定好的 <code>this</code> ，并可以延后调用。<code>.bind()</code> 方法的作用是创建一个新的函数，执行时的上下文环境为 <code>.bind()</code> 传递的第一个参数，它允许创建预先设置好 <code>this</code> 的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = &#123;  </div><div class=\"line\">  array: [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>],</div><div class=\"line\">  getNumbers: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.array;    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// Create a bound function</span></div><div class=\"line\"><span class=\"keyword\">var</span> boundGetNumbers = numbers.getNumbers.bind(numbers);  </div><div class=\"line\">boundGetNumbers(); <span class=\"comment\">// =&gt; [3, 5, 10]  </span></div><div class=\"line\"><span class=\"comment\">// Extract method from object</span></div><div class=\"line\"><span class=\"keyword\">var</span> simpleGetNumbers = numbers.getNumbers;  </div><div class=\"line\">simpleGetNumbers(); <span class=\"comment\">// =&gt; undefined or throws an error in strict mode</span></div></pre></td></tr></table></figure>\n<p>使用 <code>.bind()</code> 时应该注意，<code>.bind()</code> 创建了一个永恒的上下文链并不可修改。一个绑定函数即使使用 <code>.call()</code> 或者 <code>.apply()</code>传入其他不同的上下文环境，也不会更改它之前连接的上下文环境，重新绑定也不会起任何作用。</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>\n<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新指向新的函数</strong>。</p>\n<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> oldParseInt = <span class=\"built_in\">parseInt</span>; <span class=\"comment\">// 保存原函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.parseInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    count += <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> oldParseInt.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// 调用原函数</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 测试:</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'10'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'20'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'30'</span>);</div><div class=\"line\">count; <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>一个可以接收另一个函数作为参的函数，称为高阶函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p><code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pow</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.map(pow); <span class=\"comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure></p>\n<p><code>map()</code>将传入的函数一一作用在数组的每一个元素上。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p><code>Array</code>的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<p>比如对<code>Array</code>求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素<br><code>Array</code>的<code>filter()</code>接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> r = arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> !== <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">r; <span class=\"comment\">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort-1\"><a href=\"#sort-1\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>可以接收一个比较函数来实现自定义的排序<br>要按数字大小排序，我们可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;); <span class=\"comment\">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>比如返回一个求和的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazy_sum</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = lazy_sum([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// function sum()</span></div></pre></td></tr></table></figure></p>\n<p>调用函数f时，才真正计算求和的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(); <span class=\"comment\">// 15</span></div></pre></td></tr></table></figure></p>\n<p>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中<code>this</code>不遵循闭包)</p>\n<h4 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i * i;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div></pre></td></tr></table></figure></p>\n<p>上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，<strong>或者说返回了三个闭包</strong>.<br>调用的结果全是<code>16</code>,因为返回函数都引用了变量<code>i</code>，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了<code>4</code>。</p>\n<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> n * n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">f1(); <span class=\"comment\">// 1</span></div><div class=\"line\">f2(); <span class=\"comment\">// 4</span></div><div class=\"line\">f3(); <span class=\"comment\">// 9</span></div></pre></td></tr></table></figure></p>\n<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;)(3); // 9</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：</div><div class=\"line\">```javascript</div><div class=\"line\">function count() &#123;</div><div class=\"line\">    var arr = [];</div><div class=\"line\">    for (var i=1; i&lt;=3; i++) &#123;</div><div class=\"line\">        arr.push((function () &#123;</div><div class=\"line\">            var n =i</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                return n*n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>相反的，如果内存函数还是用的<code>i</code>，那么结果就会全是<code>16</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// var n =i</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> i*i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">x =&gt; x*x</div></pre></td></tr></table></figure></p>\n<p>相当于一个输入为<code>x</code>输出为<code>x*x</code>的匿名函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果参数不是一个，就需要用括号()括起来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 两个参数:</span></div><div class=\"line\">(x, y) =&gt; x * x + y * y</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 无参数:</span></div><div class=\"line\">() =&gt; <span class=\"number\">3.14</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可变参数:</span></div><div class=\"line\">(x, y, ...rest) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> i, sum = x + y;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;rest.length; i++) &#123;</div><div class=\"line\">        sum += rest[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>语法糖，类似于python中的lambda函数</p>\n<p>当然，箭头函数还是有点用处的，由于是es6的新特性，<strong>箭头函数内部的this是词法作用域</strong>，由上下文确定。<br>试做比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = function () &#123;</div><div class=\"line\">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div></pre></td></tr></table></figure></p>\n<p>如果使用箭头函数,以前 <code>var that = this;</code> 以及 <code>.apply()</code> 和 <code>.call()</code> 这种写法就不需要了。</p>\n<p>箭头函数并不创建它自身执行的上下文，使得 <code>this</code> 取决于它在定义时的外部函数。<strong>箭头函数一次绑定上下文后便不可更改，即使使用了上下文更改的方法</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];  </div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  <span class=\"keyword\">var</span> get = () =&gt; &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === numbers); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">  get(); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  <span class=\"comment\">// 箭头函数使用 .apply() 和 .call()</span></div><div class=\"line\">  get.call([<span class=\"number\">0</span>]);  <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  get.apply([<span class=\"number\">0</span>]); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">  <span class=\"comment\">// Bind</span></div><div class=\"line\">  get.bind([<span class=\"number\">0</span>])(); <span class=\"comment\">// =&gt; [1, 2]</span></div><div class=\"line\">&#125;).call(numbers);</div></pre></td></tr></table></figure>\n<p>这是因为箭头函数拥有静态的上下文环境，不会因为不同的调用而改变。但是要注意：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Period</span> (<span class=\"params\">hours, minutes</span>) </span>&#123;  </div><div class=\"line\">     <span class=\"keyword\">this</span>.hours = hours;</div><div class=\"line\">     <span class=\"keyword\">this</span>.minutes = minutes;</div><div class=\"line\">   &#125;</div><div class=\"line\">   Period.prototype.format = () =&gt; &#123;  </div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === <span class=\"built_in\">window</span>); <span class=\"comment\">// =&gt; true</span></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.hours + <span class=\"string\">' hours and '</span> + <span class=\"keyword\">this</span>.minutes + <span class=\"string\">' minutes'</span>;</div><div class=\"line\">   &#125;;</div><div class=\"line\">   <span class=\"keyword\">var</span> walkPeriod = <span class=\"keyword\">new</span> Period(<span class=\"number\">2</span>, <span class=\"number\">30</span>);  </div><div class=\"line\">   walkPeriod.format(); <span class=\"comment\">// =&gt; 'undefined hours and undefined minutes'</span></div></pre></td></tr></table></figure>\n<p>注意这里的 <code>this === window</code> 返回的是 <code>true</code>。</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>generator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。</p>\n<p>定义如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。好处就是<strong>函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。</strong>(其实这东西很像调试函数时候的断点！)</p>\n<p>执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = fib(<span class=\"number\">5</span>);</div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 0, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: true&#125;</span></div></pre></td></tr></table></figure></p>\n<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>\n<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> fib(<span class=\"number\">5</span>)) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 依次输出0, 1, 1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<strong>看起来蛮有用的</strong></p>\n<p>举个例子，要生成一个自增的ID，可以编写一个next_id()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> current_id = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    current_id ++;</div><div class=\"line\">    <span class=\"keyword\">return</span> current_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。现在改用generator：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    \t<span class=\"keyword\">yield</span> ++i;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"标准对象\"><a href=\"#标准对象\" class=\"headerlink\" title=\"标准对象\"></a>标准对象</h2><p>一些原则：</p>\n<ul>\n<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>\n<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>\n<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>\n<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>\n<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>\n<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>\n<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>\n<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>\n<p>要获取系统当前时间，用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">now; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class=\"line\">now.getFullYear(); <span class=\"comment\">// 2015, 年份</span></div><div class=\"line\">now.getMonth(); <span class=\"comment\">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class=\"line\">now.getDate(); <span class=\"comment\">// 24, 表示24号</span></div><div class=\"line\">now.getDay(); <span class=\"comment\">// 3, 表示星期三</span></div><div class=\"line\">now.getHours(); <span class=\"comment\">// 19, 24小时制</span></div><div class=\"line\">now.getMinutes(); <span class=\"comment\">// 49, 分钟</span></div><div class=\"line\">now.getSeconds(); <span class=\"comment\">// 22, 秒</span></div><div class=\"line\">now.getMilliseconds(); <span class=\"comment\">// 875, 毫秒数</span></div><div class=\"line\">now.getTime(); <span class=\"comment\">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>\n<p>如果要创建一个指定日期和时间的Date对象，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>, <span class=\"number\">30</span>, <span class=\"number\">123</span>);</div><div class=\"line\">d; <span class=\"comment\">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是<code>0~11</code>，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示<code>6</code>月，我们传入的是<code>5</code>！</p>\n<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Date</span>.parse(<span class=\"string\">'2015-06-24T19:49:22.875+08:00'</span>);</div><div class=\"line\">d; <span class=\"comment\">// 1435146562875</span></div></pre></td></tr></table></figure></p>\n<p>但它返回的不是<code>Date</code>对象，而是一个<strong>时间戳</strong>。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1435146562875</span>);</div><div class=\"line\">d; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>\n<p>要获取当前时间戳，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Date</span>.now) &#123;</div><div class=\"line\">    alert(<span class=\"built_in\">Date</span>.now()); <span class=\"comment\">// 老版本IE没有now()方法</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>JSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>\n<ul>\n<li>number：和JavaScript的<code>number</code>完全一致；</li>\n<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>\n<li>string：就是JavaScript的<code>string</code>；</li>\n<li>null：就是JavaScript的<code>null</code>；</li>\n<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>\n<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>\n</ul>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><p>先把小明这个对象序列化成JSON格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>要输出得好看一些，可以加上参数，按缩进输出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, <span class=\"literal\">null</span>, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" Middle School\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value.toUpperCase();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, convert, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码把所有属性值都变成大写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" MIDDLE SCHOOL\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JAVASCRIPT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"JAVA\"</span>,</div><div class=\"line\">    <span class=\"string\">\"PYTHON\"</span>,</div><div class=\"line\">    <span class=\"string\">\"LISP\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>],</div><div class=\"line\">    toJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"comment\">// 只输出name和age，并且改变了key：</span></div><div class=\"line\">            <span class=\"string\">'Name'</span>: <span class=\"keyword\">this</span>.name,</div><div class=\"line\">            <span class=\"string\">'Age'</span>: <span class=\"keyword\">this</span>.age</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"Name\":\"小明\",\"Age\":14&#125;'</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1,2,3,true]'</span>); <span class=\"comment\">// [1, 2, 3, true]</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>); <span class=\"comment\">// Object &#123;name: '小明', age: 14&#125;</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'123.45'</span>); <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure></p>\n<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 把number * 2:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'name'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"string\">'同学'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;); <span class=\"comment\">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>\n<p>prototype有点类似于继承，<code>A</code>的原型是<code>B</code>，意味着，<code>A</code>拥有<code>B</code>的全部属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 原型对象:</span></div><div class=\"line\"><span class=\"keyword\">var</span> Student = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Robot'</span>,</div><div class=\"line\">    height: <span class=\"number\">1.2</span>,</div><div class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running...'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStudent</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 基于Student原型创建一个新对象:</span></div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">Object</span>.create(Student);</div><div class=\"line\">    <span class=\"comment\">// 初始化新对象:</span></div><div class=\"line\">    s.name = name;</div><div class=\"line\">    <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = createStudent(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.run(); <span class=\"comment\">// 小明 is running...</span></div><div class=\"line\">xiaoming.__proto__ === Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>\n<p>例如，创建一个<code>Array</code>对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure></p>\n<p>其原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr ----&gt; <span class=\"built_in\">Array</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>\n<p>当我们创建一个函数时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数也是一个对象，它的原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo ----&gt; <span class=\"built_in\">Function</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaoming.hello(); <span class=\"comment\">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>\n<p>注意，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>\n<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.constructor === Student.prototype.constructor; <span class=\"comment\">// true</span></div><div class=\"line\">Student.prototype.constructor === Student; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">xiaoming <span class=\"keyword\">instanceof</span> Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>他们之间的关系就是:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true\" alt=\"constructor\"></p>\n<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>\n<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>\n<p>不过还有一个小问题，注意观察：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaoming.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaohong.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaoming.hello === xiaohong.hello; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>\n<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。<br>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true\" alt=\"constructor2\"><br>修改代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h3><p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n<p>我们先回顾用函数实现<code>Student</code>的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hello() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，<code>class</code>的定义包含了<strong>构造函数</strong><code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>\n<p>最后，创建一个Student对象代码和前面章节完全一样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.hello();</div></pre></td></tr></table></figure></p>\n<h4 id=\"class继承-1\"><a href=\"#class继承-1\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了,直接通过<code>extends</code>来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimaryStudent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, grade) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name); <span class=\"comment\">// 记得用super调用父类的构造方法!</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.grade = grade;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    myGrade() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'I am at grade '</span> + <span class=\"keyword\">this</span>.grade);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>super(name)</code>来调用父类的构造函数。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>"},{"title":"NSLayoutConstraint 学习笔记","date":"2016-09-08T02:07:12.000Z","_content":"\n`AutoLayout`是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。\n参考与[AutoLayout详解](http://www.jianshu.com/p/79f92139ffdf)\n\n<!--more-->\n\n## 代码添加AutoLayout\n### 关闭Autoresizing\n`AutoLayout`旨在替代`Autoresizing`，所以在同一个项目中，`AutoLayout`和`Autoresizing`是不能共存的。要实现自动布局，必须关掉view的`AutoresizeingMask`\n\n```objc\nview.translatesAutoresizingMaskIntoConstraints = NO;\n```\n这里的view指的是需要添加约束的view。\n\n### NSLayoutConstraint相关\n#### 约束方法\n```objc\n+(instancetype)constraintWithItem:(id)view1                  //被约束的视图一\n                        attribute:(NSLayoutAttribute)attr1   //view1的属性\n                        relatedBy:(NSLayoutRelation)relation //左右视图的关系\n                           toItem:(id)view2                  //被约束的视图二\n                        attribute:(NSLayoutAttribute)attr2   //view2的属性\n                       multiplier:(CGFloat)multiplier        //乘数\n                         constant:(CGFloat)c;                //常量\n```\n\n公式是这样的：`view1.attr1 = view2.attr2 * multiplier + constant`\n\n#### NSLayoutAttribute属性\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    NSLayoutAttributeLeft = 1, //左边\n    NSLayoutAttributeRight,    //右边\n    NSLayoutAttributeTop,      //顶部\n    NSLayoutAttributeBottom,   //底部\n    NSLayoutAttributeLeading,  //首部\n    NSLayoutAttributeTrailing, //尾部\n    NSLayoutAttributeWidth,    //宽度\n    NSLayoutAttributeHeight,   //高度\n    NSLayoutAttributeCenterX,  //X轴中心\n    NSLayoutAttributeCenterY,  //Y轴中心\n    NSLayoutAttributeBaseline, //基线\n    NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline,\n    NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0),\n\n    //iOS8的暂时没有研究\n    NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n\n    NSLayoutAttributeNotAnAttribute = 0 //无属性\n};\n```\n\n#### NSLayoutRelation关系\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    NSLayoutRelationLessThanOrEqual = -1,   //小于等于\n    NSLayoutRelationEqual = 0,              //等于\n    NSLayoutRelationGreaterThanOrEqual = 1, //大于等于\n};\n```\n\n### 创建view\n```objc\n//创建view\nUIView *view = [[UIView alloc] init]; //这里不需要设置frame\nview.backgroundColor = [UIColor brownColor];\nview.translatesAutoresizingMaskIntoConstraints = NO; //要实现自动布局，必须把该属性设置为NO\n[self.view addSubview:view];\n\n//添加约束\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeLeft\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeLeft\n                             multiplier:1\n                               constant:20]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeRight\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeRight\n                             multiplier:1\n                               constant:-10]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeTop\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeTop\n                             multiplier:1\n                               constant:30]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeBottom\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeBottom\n                             multiplier:1\n                               constant:-20]];\n```\n\n### 添加约束的规则\n- 对于两个同层级view之间的约束关系，添加到它们的父view上\n- 对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上\n- 对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上\n\n### Autolayout来实现动画功能\n在执行动画时记得调用一下方法：\n```objc\n//在修改了约束之后，只要执行下面代码，就能做动画效果\n[UIView animateWithDuration:0.5 animations:^{\n      [self.view layoutIfNeeded];\n}];\n```\n\n## 第三方框架实现AutoLayout\nMasonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。\n### 框架导入\n这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。\n#### 创建Podfile\n在工程的目录下新建Podfile文件，写入我们需要的第三方库：\n```objc\ntarget 'NSLayoutConstraintDemo' do\npod 'Masonry'\nend\n```\n\n#### 导入第三方库\n进入终端，运行命令`pod install`,导入第三方库。\n\n### Masonry基本使用\n最基本的使用方式：\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.属性.equalTo(另一个view).with.insets(差值);\n}];\n```\n\n### Masonry属性\n```objc\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n@property (nonatomic, strong, readonly) MASConstraint *leading;\n@property (nonatomic, strong, readonly) MASConstraint *trailing;\n@property (nonatomic, strong, readonly) MASConstraint *width;\n@property (nonatomic, strong, readonly) MASConstraint *height;\n@property (nonatomic, strong, readonly) MASConstraint *centerX;\n@property (nonatomic, strong, readonly) MASConstraint *centerY;\n@property (nonatomic, strong, readonly) MASConstraint *baseline;\n```\n其中leading与left trailing与right 在正常情况下是等价的。\n### 使用实例\n居中显示一个view：\n```objc\n//从此以后基本可以抛弃CGRectMake了\nUIView *sv = [UIView new];\n\n//在做autoLayout之前 一定要先将view添加到superview上 否则会报错\n[self.view addSubview:sv];\n\n//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了\n[sv mas_makeConstraints:^(MASConstraintMaker *make) {\n\n    //将sv居中(很容易理解吧?)\n    make.center.equalTo(self.view);\n    \n    //将size设置成(300,300)\n    make.size.mas_equalTo(CGSizeMake(300, 300));\n}];\n```\n\n### 方法简析\n#### 添加autolayout约束\n有三个可以添加约束的方法：\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;\n\n/*\n    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 \n    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况\n    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束\n    \n    三种函数善加利用 就可以应对各种情况了\n*/\n```\n\n#### equalTo 和 mas_equalTo的区别\n`mas_equalTo`只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了`NSNumber`支持的那些数值类型之外 就只支持`CGPoint` `CGSize` `UIEdgeInsets`\n\n### 另一个示例\n```objc\nUIView *sv1 = [UIView new];\n[sv1 showPlaceHolder];\nsv1.backgroundColor = [UIColor redColor];\n[sv addSubview:sv1];\n[sv1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    \n    /* 等价于\n    make.top.equalTo(sv).with.offset(10);\n    make.left.equalTo(sv).with.offset(10);\n    make.bottom.equalTo(sv).with.offset(-10);\n    make.right.equalTo(sv).with.offset(-10);\n    */\n    \n    /* 也等价于\n    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    */\n}];\n```\n可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.\n\n这里and和with 两个函数什么事情都没做.\n\n### 还有一个示例\n```objc\nUIView *lastView = nil;\n    \nfor ( int i = 1 ; i <= count ; ++i ){\n    UIView *subv = [UIView new];\n    [container addSubview:subv];\n    subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 )\n                                      saturation:( arc4random() % 128 / 256.0 ) + 0.5\n                                      brightness:( arc4random() % 128 / 256.0 ) + 0.5\n                                           alpha:1];\n        \n    [subv mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.and.right.equalTo(container);\n        make.height.mas_equalTo(@(20*i));\n           \n        if ( lastView ){\n            make.top.mas_equalTo(lastView.mas_bottom);\n        }\n        else{\n            make.top.mas_equalTo(container.mas_top);\n        }\n    }];\n       \n    lastView = subv;\n}\n   \n    \n[container mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.equalTo(lastView.mas_bottom);\n}];\n```\n\n框架通过范畴为UIView添加了`mas_bottom`、`mas_top`等属性，用来表示view的上下左右的位置。这样，有利于**在view之间的约束条件的建立**，之前的示例都是view与父view的约束关系。\n\n还有一些其他的示例，可以参见[Masonry介绍与使用实践](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)\n\n>Demo 详见NSLayoutConstraintDemo\n\n\n\n\n\n","source":"_posts/NSLayoutConstraint.md","raw":"title: NSLayoutConstraint 学习笔记\ndate: 2016/9/8 10:07:12  \ncategories: iOS\ntags:\n\t- AutoLayout\n\n---\n\n`AutoLayout`是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。\n参考与[AutoLayout详解](http://www.jianshu.com/p/79f92139ffdf)\n\n<!--more-->\n\n## 代码添加AutoLayout\n### 关闭Autoresizing\n`AutoLayout`旨在替代`Autoresizing`，所以在同一个项目中，`AutoLayout`和`Autoresizing`是不能共存的。要实现自动布局，必须关掉view的`AutoresizeingMask`\n\n```objc\nview.translatesAutoresizingMaskIntoConstraints = NO;\n```\n这里的view指的是需要添加约束的view。\n\n### NSLayoutConstraint相关\n#### 约束方法\n```objc\n+(instancetype)constraintWithItem:(id)view1                  //被约束的视图一\n                        attribute:(NSLayoutAttribute)attr1   //view1的属性\n                        relatedBy:(NSLayoutRelation)relation //左右视图的关系\n                           toItem:(id)view2                  //被约束的视图二\n                        attribute:(NSLayoutAttribute)attr2   //view2的属性\n                       multiplier:(CGFloat)multiplier        //乘数\n                         constant:(CGFloat)c;                //常量\n```\n\n公式是这样的：`view1.attr1 = view2.attr2 * multiplier + constant`\n\n#### NSLayoutAttribute属性\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    NSLayoutAttributeLeft = 1, //左边\n    NSLayoutAttributeRight,    //右边\n    NSLayoutAttributeTop,      //顶部\n    NSLayoutAttributeBottom,   //底部\n    NSLayoutAttributeLeading,  //首部\n    NSLayoutAttributeTrailing, //尾部\n    NSLayoutAttributeWidth,    //宽度\n    NSLayoutAttributeHeight,   //高度\n    NSLayoutAttributeCenterX,  //X轴中心\n    NSLayoutAttributeCenterY,  //Y轴中心\n    NSLayoutAttributeBaseline, //基线\n    NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline,\n    NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0),\n\n    //iOS8的暂时没有研究\n    NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n\n    NSLayoutAttributeNotAnAttribute = 0 //无属性\n};\n```\n\n#### NSLayoutRelation关系\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    NSLayoutRelationLessThanOrEqual = -1,   //小于等于\n    NSLayoutRelationEqual = 0,              //等于\n    NSLayoutRelationGreaterThanOrEqual = 1, //大于等于\n};\n```\n\n### 创建view\n```objc\n//创建view\nUIView *view = [[UIView alloc] init]; //这里不需要设置frame\nview.backgroundColor = [UIColor brownColor];\nview.translatesAutoresizingMaskIntoConstraints = NO; //要实现自动布局，必须把该属性设置为NO\n[self.view addSubview:view];\n\n//添加约束\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeLeft\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeLeft\n                             multiplier:1\n                               constant:20]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeRight\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeRight\n                             multiplier:1\n                               constant:-10]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeTop\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeTop\n                             multiplier:1\n                               constant:30]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeBottom\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeBottom\n                             multiplier:1\n                               constant:-20]];\n```\n\n### 添加约束的规则\n- 对于两个同层级view之间的约束关系，添加到它们的父view上\n- 对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上\n- 对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上\n\n### Autolayout来实现动画功能\n在执行动画时记得调用一下方法：\n```objc\n//在修改了约束之后，只要执行下面代码，就能做动画效果\n[UIView animateWithDuration:0.5 animations:^{\n      [self.view layoutIfNeeded];\n}];\n```\n\n## 第三方框架实现AutoLayout\nMasonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。\n### 框架导入\n这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。\n#### 创建Podfile\n在工程的目录下新建Podfile文件，写入我们需要的第三方库：\n```objc\ntarget 'NSLayoutConstraintDemo' do\npod 'Masonry'\nend\n```\n\n#### 导入第三方库\n进入终端，运行命令`pod install`,导入第三方库。\n\n### Masonry基本使用\n最基本的使用方式：\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.属性.equalTo(另一个view).with.insets(差值);\n}];\n```\n\n### Masonry属性\n```objc\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n@property (nonatomic, strong, readonly) MASConstraint *leading;\n@property (nonatomic, strong, readonly) MASConstraint *trailing;\n@property (nonatomic, strong, readonly) MASConstraint *width;\n@property (nonatomic, strong, readonly) MASConstraint *height;\n@property (nonatomic, strong, readonly) MASConstraint *centerX;\n@property (nonatomic, strong, readonly) MASConstraint *centerY;\n@property (nonatomic, strong, readonly) MASConstraint *baseline;\n```\n其中leading与left trailing与right 在正常情况下是等价的。\n### 使用实例\n居中显示一个view：\n```objc\n//从此以后基本可以抛弃CGRectMake了\nUIView *sv = [UIView new];\n\n//在做autoLayout之前 一定要先将view添加到superview上 否则会报错\n[self.view addSubview:sv];\n\n//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了\n[sv mas_makeConstraints:^(MASConstraintMaker *make) {\n\n    //将sv居中(很容易理解吧?)\n    make.center.equalTo(self.view);\n    \n    //将size设置成(300,300)\n    make.size.mas_equalTo(CGSizeMake(300, 300));\n}];\n```\n\n### 方法简析\n#### 添加autolayout约束\n有三个可以添加约束的方法：\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;\n\n/*\n    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 \n    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况\n    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束\n    \n    三种函数善加利用 就可以应对各种情况了\n*/\n```\n\n#### equalTo 和 mas_equalTo的区别\n`mas_equalTo`只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了`NSNumber`支持的那些数值类型之外 就只支持`CGPoint` `CGSize` `UIEdgeInsets`\n\n### 另一个示例\n```objc\nUIView *sv1 = [UIView new];\n[sv1 showPlaceHolder];\nsv1.backgroundColor = [UIColor redColor];\n[sv addSubview:sv1];\n[sv1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    \n    /* 等价于\n    make.top.equalTo(sv).with.offset(10);\n    make.left.equalTo(sv).with.offset(10);\n    make.bottom.equalTo(sv).with.offset(-10);\n    make.right.equalTo(sv).with.offset(-10);\n    */\n    \n    /* 也等价于\n    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    */\n}];\n```\n可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.\n\n这里and和with 两个函数什么事情都没做.\n\n### 还有一个示例\n```objc\nUIView *lastView = nil;\n    \nfor ( int i = 1 ; i <= count ; ++i ){\n    UIView *subv = [UIView new];\n    [container addSubview:subv];\n    subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 )\n                                      saturation:( arc4random() % 128 / 256.0 ) + 0.5\n                                      brightness:( arc4random() % 128 / 256.0 ) + 0.5\n                                           alpha:1];\n        \n    [subv mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.and.right.equalTo(container);\n        make.height.mas_equalTo(@(20*i));\n           \n        if ( lastView ){\n            make.top.mas_equalTo(lastView.mas_bottom);\n        }\n        else{\n            make.top.mas_equalTo(container.mas_top);\n        }\n    }];\n       \n    lastView = subv;\n}\n   \n    \n[container mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.equalTo(lastView.mas_bottom);\n}];\n```\n\n框架通过范畴为UIView添加了`mas_bottom`、`mas_top`等属性，用来表示view的上下左右的位置。这样，有利于**在view之间的约束条件的建立**，之前的示例都是view与父view的约束关系。\n\n还有一些其他的示例，可以参见[Masonry介绍与使用实践](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)\n\n>Demo 详见NSLayoutConstraintDemo\n\n\n\n\n\n","slug":"NSLayoutConstraint","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dou000n7hzg6pkpoxi6","content":"<p><code>AutoLayout</code>是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。<br>参考与<a href=\"http://www.jianshu.com/p/79f92139ffdf\" target=\"_blank\" rel=\"external\">AutoLayout详解</a></p>\n<a id=\"more\"></a>\n<h2 id=\"代码添加AutoLayout\"><a href=\"#代码添加AutoLayout\" class=\"headerlink\" title=\"代码添加AutoLayout\"></a>代码添加AutoLayout</h2><h3 id=\"关闭Autoresizing\"><a href=\"#关闭Autoresizing\" class=\"headerlink\" title=\"关闭Autoresizing\"></a>关闭Autoresizing</h3><p><code>AutoLayout</code>旨在替代<code>Autoresizing</code>，所以在同一个项目中，<code>AutoLayout</code>和<code>Autoresizing</code>是不能共存的。要实现自动布局，必须关掉view的<code>AutoresizeingMask</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</div></pre></td></tr></table></figure>\n<p>这里的view指的是需要添加约束的view。</p>\n<h3 id=\"NSLayoutConstraint相关\"><a href=\"#NSLayoutConstraint相关\" class=\"headerlink\" title=\"NSLayoutConstraint相关\"></a>NSLayoutConstraint相关</h3><h4 id=\"约束方法\"><a href=\"#约束方法\" class=\"headerlink\" title=\"约束方法\"></a>约束方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"keyword\">instancetype</span>)constraintWithItem:(<span class=\"keyword\">id</span>)view1                  <span class=\"comment\">//被约束的视图一</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr1   <span class=\"comment\">//view1的属性</span></div><div class=\"line\">                        relatedBy:(<span class=\"built_in\">NSLayoutRelation</span>)relation <span class=\"comment\">//左右视图的关系</span></div><div class=\"line\">                           toItem:(<span class=\"keyword\">id</span>)view2                  <span class=\"comment\">//被约束的视图二</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr2   <span class=\"comment\">//view2的属性</span></div><div class=\"line\">                       multiplier:(<span class=\"built_in\">CGFloat</span>)multiplier        <span class=\"comment\">//乘数</span></div><div class=\"line\">                         constant:(<span class=\"built_in\">CGFloat</span>)c;                <span class=\"comment\">//常量</span></div></pre></td></tr></table></figure>\n<p>公式是这样的：<code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<h4 id=\"NSLayoutAttribute属性\"><a href=\"#NSLayoutAttribute属性\" class=\"headerlink\" title=\"NSLayoutAttribute属性\"></a>NSLayoutAttribute属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutAttribute</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeft</span> = <span class=\"number\">1</span>, <span class=\"comment\">//左边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRight</span>,    <span class=\"comment\">//右边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTop</span>,      <span class=\"comment\">//顶部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottom</span>,   <span class=\"comment\">//底部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeading</span>,  <span class=\"comment\">//首部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailing</span>, <span class=\"comment\">//尾部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeWidth</span>,    <span class=\"comment\">//宽度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeHeight</span>,   <span class=\"comment\">//高度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterX</span>,  <span class=\"comment\">//X轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterY</span>,  <span class=\"comment\">//Y轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBaseline</span>, <span class=\"comment\">//基线</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLastBaseline</span> = <span class=\"built_in\">NSLayoutAttributeBaseline</span>,</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeFirstBaseline</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//iOS8的暂时没有研究</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeftMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRightMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTopMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottomMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeadingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterXWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterYWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span> = <span class=\"number\">0</span> <span class=\"comment\">//无属性</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"NSLayoutRelation关系\"><a href=\"#NSLayoutRelation关系\" class=\"headerlink\" title=\"NSLayoutRelation关系\"></a>NSLayoutRelation关系</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutRelation</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationLessThanOrEqual</span> = <span class=\"number\">-1</span>,   <span class=\"comment\">//小于等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationEqual</span> = <span class=\"number\">0</span>,              <span class=\"comment\">//等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span> = <span class=\"number\">1</span>, <span class=\"comment\">//大于等于</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"创建view\"><a href=\"#创建view\" class=\"headerlink\" title=\"创建view\"></a>创建view</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建view</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] init]; <span class=\"comment\">//这里不需要设置frame</span></div><div class=\"line\">view.backgroundColor = [<span class=\"built_in\">UIColor</span> brownColor];</div><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>; <span class=\"comment\">//要实现自动布局，必须把该属性设置为NO</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加约束</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">20</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-10</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">30</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-20</span>]];</div></pre></td></tr></table></figure>\n<h3 id=\"添加约束的规则\"><a href=\"#添加约束的规则\" class=\"headerlink\" title=\"添加约束的规则\"></a>添加约束的规则</h3><ul>\n<li>对于两个同层级view之间的约束关系，添加到它们的父view上</li>\n<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</li>\n<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</li>\n</ul>\n<h3 id=\"Autolayout来实现动画功能\"><a href=\"#Autolayout来实现动画功能\" class=\"headerlink\" title=\"Autolayout来实现动画功能\"></a>Autolayout来实现动画功能</h3><p>在执行动画时记得调用一下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在修改了约束之后，只要执行下面代码，就能做动画效果</span></div><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> animations:^&#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span>.view layoutIfNeeded];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三方框架实现AutoLayout\"><a href=\"#第三方框架实现AutoLayout\" class=\"headerlink\" title=\"第三方框架实现AutoLayout\"></a>第三方框架实现AutoLayout</h2><p>Masonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。</p>\n<h3 id=\"框架导入\"><a href=\"#框架导入\" class=\"headerlink\" title=\"框架导入\"></a>框架导入</h3><p>这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。</p>\n<h4 id=\"创建Podfile\"><a href=\"#创建Podfile\" class=\"headerlink\" title=\"创建Podfile\"></a>创建Podfile</h4><p>在工程的目录下新建Podfile文件，写入我们需要的第三方库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target 'NSLayoutConstraintDemo' do</div><div class=\"line\">pod 'Masonry'</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"导入第三方库\"><a href=\"#导入第三方库\" class=\"headerlink\" title=\"导入第三方库\"></a>导入第三方库</h4><p>进入终端，运行命令<code>pod install</code>,导入第三方库。</p>\n<h3 id=\"Masonry基本使用\"><a href=\"#Masonry基本使用\" class=\"headerlink\" title=\"Masonry基本使用\"></a>Masonry基本使用</h3><p>最基本的使用方式：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.属性.equalTo(另一个view).with.insets(差值);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"Masonry属性\"><a href=\"#Masonry属性\" class=\"headerlink\" title=\"Masonry属性\"></a>Masonry属性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *left;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *top;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *right;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *bottom;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *leading;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *trailing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *width;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *height;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerX;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerY;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *baseline;</div></pre></td></tr></table></figure>\n<p>其中leading与left trailing与right 在正常情况下是等价的。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>居中显示一个view：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从此以后基本可以抛弃CGRectMake了</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *sv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在做autoLayout之前 一定要先将view添加到superview上 否则会报错</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:sv];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了</span></div><div class=\"line\">[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将sv居中(很容易理解吧?)</span></div><div class=\"line\">    make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//将size设置成(300,300)</span></div><div class=\"line\">    make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">300</span>, <span class=\"number\">300</span>));</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"方法简析\"><a href=\"#方法简析\" class=\"headerlink\" title=\"方法简析\"></a>方法简析</h3><h4 id=\"添加autolayout约束\"><a href=\"#添加autolayout约束\" class=\"headerlink\" title=\"添加autolayout约束\"></a>添加autolayout约束</h4><p>有三个可以添加约束的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_updateConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_remakeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class=\"line\">    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class=\"line\">    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class=\"line\">    </div><div class=\"line\">    三种函数善加利用 就可以应对各种情况了</div><div class=\"line\">*/</div></pre></td></tr></table></figure></p>\n<h4 id=\"equalTo-和-mas-equalTo的区别\"><a href=\"#equalTo-和-mas-equalTo的区别\" class=\"headerlink\" title=\"equalTo 和 mas_equalTo的区别\"></a>equalTo 和 mas_equalTo的区别</h4><p><code>mas_equalTo</code>只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了<code>NSNumber</code>支持的那些数值类型之外 就只支持<code>CGPoint</code> <code>CGSize</code> <code>UIEdgeInsets</code></p>\n<h3 id=\"另一个示例\"><a href=\"#另一个示例\" class=\"headerlink\" title=\"另一个示例\"></a>另一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *sv1 = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">[sv1 showPlaceHolder];</div><div class=\"line\">sv1.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">[sv addSubview:sv1];</div><div class=\"line\">[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.edges.equalTo(sv).with.insets(<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 等价于</span></div><div class=\"line\">    make.top.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.left.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.bottom.equalTo(sv).with.offset(-10);</div><div class=\"line\">    make.right.equalTo(sv).with.offset(-10);</div><div class=\"line\">    */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 也等价于</span></div><div class=\"line\">    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));</div><div class=\"line\">    */</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.</p>\n<p>这里and和with 两个函数什么事情都没做.</p>\n<h3 id=\"还有一个示例\"><a href=\"#还有一个示例\" class=\"headerlink\" title=\"还有一个示例\"></a>还有一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *lastView = <span class=\"literal\">nil</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= count ; ++i )&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *subv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">    [container addSubview:subv];</div><div class=\"line\">    subv.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithHue:( arc4random() % <span class=\"number\">256</span> / <span class=\"number\">256.0</span> )</div><div class=\"line\">                                      saturation:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                      brightness:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                           alpha:<span class=\"number\">1</span>];</div><div class=\"line\">        </div><div class=\"line\">    [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.and.right.equalTo(container);</div><div class=\"line\">        make.height.mas_equalTo(@(<span class=\"number\">20</span>*i));</div><div class=\"line\">           </div><div class=\"line\">        <span class=\"keyword\">if</span> ( lastView )&#123;</div><div class=\"line\">            make.top.mas_equalTo(lastView.mas_bottom);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            make.top.mas_equalTo(container.mas_top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">       </div><div class=\"line\">    lastView = subv;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\">    </div><div class=\"line\">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.bottom.equalTo(lastView.mas_bottom);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>框架通过范畴为UIView添加了<code>mas_bottom</code>、<code>mas_top</code>等属性，用来表示view的上下左右的位置。这样，有利于<strong>在view之间的约束条件的建立</strong>，之前的示例都是view与父view的约束关系。</p>\n<p>还有一些其他的示例，可以参见<a href=\"http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/\" target=\"_blank\" rel=\"external\">Masonry介绍与使用实践</a></p>\n<blockquote>\n<p>Demo 详见NSLayoutConstraintDemo</p>\n</blockquote>\n","excerpt":"<p><code>AutoLayout</code>是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。<br>参考与<a href=\"http://www.jianshu.com/p/79f92139ffdf\">AutoLayout详解</a></p>","more":"<h2 id=\"代码添加AutoLayout\"><a href=\"#代码添加AutoLayout\" class=\"headerlink\" title=\"代码添加AutoLayout\"></a>代码添加AutoLayout</h2><h3 id=\"关闭Autoresizing\"><a href=\"#关闭Autoresizing\" class=\"headerlink\" title=\"关闭Autoresizing\"></a>关闭Autoresizing</h3><p><code>AutoLayout</code>旨在替代<code>Autoresizing</code>，所以在同一个项目中，<code>AutoLayout</code>和<code>Autoresizing</code>是不能共存的。要实现自动布局，必须关掉view的<code>AutoresizeingMask</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</div></pre></td></tr></table></figure>\n<p>这里的view指的是需要添加约束的view。</p>\n<h3 id=\"NSLayoutConstraint相关\"><a href=\"#NSLayoutConstraint相关\" class=\"headerlink\" title=\"NSLayoutConstraint相关\"></a>NSLayoutConstraint相关</h3><h4 id=\"约束方法\"><a href=\"#约束方法\" class=\"headerlink\" title=\"约束方法\"></a>约束方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"keyword\">instancetype</span>)constraintWithItem:(<span class=\"keyword\">id</span>)view1                  <span class=\"comment\">//被约束的视图一</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr1   <span class=\"comment\">//view1的属性</span></div><div class=\"line\">                        relatedBy:(<span class=\"built_in\">NSLayoutRelation</span>)relation <span class=\"comment\">//左右视图的关系</span></div><div class=\"line\">                           toItem:(<span class=\"keyword\">id</span>)view2                  <span class=\"comment\">//被约束的视图二</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr2   <span class=\"comment\">//view2的属性</span></div><div class=\"line\">                       multiplier:(<span class=\"built_in\">CGFloat</span>)multiplier        <span class=\"comment\">//乘数</span></div><div class=\"line\">                         constant:(<span class=\"built_in\">CGFloat</span>)c;                <span class=\"comment\">//常量</span></div></pre></td></tr></table></figure>\n<p>公式是这样的：<code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<h4 id=\"NSLayoutAttribute属性\"><a href=\"#NSLayoutAttribute属性\" class=\"headerlink\" title=\"NSLayoutAttribute属性\"></a>NSLayoutAttribute属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutAttribute</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeft</span> = <span class=\"number\">1</span>, <span class=\"comment\">//左边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRight</span>,    <span class=\"comment\">//右边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTop</span>,      <span class=\"comment\">//顶部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottom</span>,   <span class=\"comment\">//底部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeading</span>,  <span class=\"comment\">//首部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailing</span>, <span class=\"comment\">//尾部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeWidth</span>,    <span class=\"comment\">//宽度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeHeight</span>,   <span class=\"comment\">//高度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterX</span>,  <span class=\"comment\">//X轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterY</span>,  <span class=\"comment\">//Y轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBaseline</span>, <span class=\"comment\">//基线</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLastBaseline</span> = <span class=\"built_in\">NSLayoutAttributeBaseline</span>,</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeFirstBaseline</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//iOS8的暂时没有研究</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeftMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRightMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTopMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottomMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeadingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterXWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterYWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span> = <span class=\"number\">0</span> <span class=\"comment\">//无属性</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"NSLayoutRelation关系\"><a href=\"#NSLayoutRelation关系\" class=\"headerlink\" title=\"NSLayoutRelation关系\"></a>NSLayoutRelation关系</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutRelation</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationLessThanOrEqual</span> = <span class=\"number\">-1</span>,   <span class=\"comment\">//小于等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationEqual</span> = <span class=\"number\">0</span>,              <span class=\"comment\">//等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span> = <span class=\"number\">1</span>, <span class=\"comment\">//大于等于</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"创建view\"><a href=\"#创建view\" class=\"headerlink\" title=\"创建view\"></a>创建view</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建view</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] init]; <span class=\"comment\">//这里不需要设置frame</span></div><div class=\"line\">view.backgroundColor = [<span class=\"built_in\">UIColor</span> brownColor];</div><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>; <span class=\"comment\">//要实现自动布局，必须把该属性设置为NO</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加约束</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">20</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-10</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">30</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-20</span>]];</div></pre></td></tr></table></figure>\n<h3 id=\"添加约束的规则\"><a href=\"#添加约束的规则\" class=\"headerlink\" title=\"添加约束的规则\"></a>添加约束的规则</h3><ul>\n<li>对于两个同层级view之间的约束关系，添加到它们的父view上</li>\n<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</li>\n<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</li>\n</ul>\n<h3 id=\"Autolayout来实现动画功能\"><a href=\"#Autolayout来实现动画功能\" class=\"headerlink\" title=\"Autolayout来实现动画功能\"></a>Autolayout来实现动画功能</h3><p>在执行动画时记得调用一下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在修改了约束之后，只要执行下面代码，就能做动画效果</span></div><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> animations:^&#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span>.view layoutIfNeeded];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三方框架实现AutoLayout\"><a href=\"#第三方框架实现AutoLayout\" class=\"headerlink\" title=\"第三方框架实现AutoLayout\"></a>第三方框架实现AutoLayout</h2><p>Masonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。</p>\n<h3 id=\"框架导入\"><a href=\"#框架导入\" class=\"headerlink\" title=\"框架导入\"></a>框架导入</h3><p>这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。</p>\n<h4 id=\"创建Podfile\"><a href=\"#创建Podfile\" class=\"headerlink\" title=\"创建Podfile\"></a>创建Podfile</h4><p>在工程的目录下新建Podfile文件，写入我们需要的第三方库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target 'NSLayoutConstraintDemo' do</div><div class=\"line\">pod 'Masonry'</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"导入第三方库\"><a href=\"#导入第三方库\" class=\"headerlink\" title=\"导入第三方库\"></a>导入第三方库</h4><p>进入终端，运行命令<code>pod install</code>,导入第三方库。</p>\n<h3 id=\"Masonry基本使用\"><a href=\"#Masonry基本使用\" class=\"headerlink\" title=\"Masonry基本使用\"></a>Masonry基本使用</h3><p>最基本的使用方式：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.属性.equalTo(另一个view).with.insets(差值);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"Masonry属性\"><a href=\"#Masonry属性\" class=\"headerlink\" title=\"Masonry属性\"></a>Masonry属性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *left;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *top;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *right;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *bottom;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *leading;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *trailing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *width;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *height;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerX;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerY;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *baseline;</div></pre></td></tr></table></figure>\n<p>其中leading与left trailing与right 在正常情况下是等价的。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>居中显示一个view：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从此以后基本可以抛弃CGRectMake了</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *sv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在做autoLayout之前 一定要先将view添加到superview上 否则会报错</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:sv];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了</span></div><div class=\"line\">[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将sv居中(很容易理解吧?)</span></div><div class=\"line\">    make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//将size设置成(300,300)</span></div><div class=\"line\">    make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">300</span>, <span class=\"number\">300</span>));</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"方法简析\"><a href=\"#方法简析\" class=\"headerlink\" title=\"方法简析\"></a>方法简析</h3><h4 id=\"添加autolayout约束\"><a href=\"#添加autolayout约束\" class=\"headerlink\" title=\"添加autolayout约束\"></a>添加autolayout约束</h4><p>有三个可以添加约束的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_updateConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_remakeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class=\"line\">    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class=\"line\">    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class=\"line\">    </div><div class=\"line\">    三种函数善加利用 就可以应对各种情况了</div><div class=\"line\">*/</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"equalTo-和-mas-equalTo的区别\"><a href=\"#equalTo-和-mas-equalTo的区别\" class=\"headerlink\" title=\"equalTo 和 mas_equalTo的区别\"></a>equalTo 和 mas_equalTo的区别</h4><p><code>mas_equalTo</code>只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了<code>NSNumber</code>支持的那些数值类型之外 就只支持<code>CGPoint</code> <code>CGSize</code> <code>UIEdgeInsets</code></p>\n<h3 id=\"另一个示例\"><a href=\"#另一个示例\" class=\"headerlink\" title=\"另一个示例\"></a>另一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *sv1 = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">[sv1 showPlaceHolder];</div><div class=\"line\">sv1.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">[sv addSubview:sv1];</div><div class=\"line\">[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.edges.equalTo(sv).with.insets(<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 等价于</div><div class=\"line\">    make.top.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.left.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.bottom.equalTo(sv).with.offset(-10);</div><div class=\"line\">    make.right.equalTo(sv).with.offset(-10);</div><div class=\"line\">    */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 也等价于</div><div class=\"line\">    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));</div><div class=\"line\">    */</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.</p>\n<p>这里and和with 两个函数什么事情都没做.</p>\n<h3 id=\"还有一个示例\"><a href=\"#还有一个示例\" class=\"headerlink\" title=\"还有一个示例\"></a>还有一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *lastView = <span class=\"literal\">nil</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= count ; ++i )&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *subv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">    [container addSubview:subv];</div><div class=\"line\">    subv.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithHue:( arc4random() % <span class=\"number\">256</span> / <span class=\"number\">256.0</span> )</div><div class=\"line\">                                      saturation:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                      brightness:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                           alpha:<span class=\"number\">1</span>];</div><div class=\"line\">        </div><div class=\"line\">    [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.and.right.equalTo(container);</div><div class=\"line\">        make.height.mas_equalTo(@(<span class=\"number\">20</span>*i));</div><div class=\"line\">           </div><div class=\"line\">        <span class=\"keyword\">if</span> ( lastView )&#123;</div><div class=\"line\">            make.top.mas_equalTo(lastView.mas_bottom);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            make.top.mas_equalTo(container.mas_top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">       </div><div class=\"line\">    lastView = subv;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\">    </div><div class=\"line\">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.bottom.equalTo(lastView.mas_bottom);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>框架通过范畴为UIView添加了<code>mas_bottom</code>、<code>mas_top</code>等属性，用来表示view的上下左右的位置。这样，有利于<strong>在view之间的约束条件的建立</strong>，之前的示例都是view与父view的约束关系。</p>\n<p>还有一些其他的示例，可以参见<a href=\"http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/\">Masonry介绍与使用实践</a></p>\n<blockquote>\n<p>Demo 详见NSLayoutConstraintDemo</p>\n</blockquote>"},{"title":"KVO 简介","date":"2016-11-17T06:07:12.000Z","_content":"\n本篇简单学习下如何使用 KVO。\n\n<!--more-->\n\n## KVO是什么？ \nKVO 是 Object-C 中定义的一个通知机制，其定义了一种对象间监控对方状态的改变，并做出反应的机制。对象可以为自己的属性注册观察者，当这个属性的值发生了改变，系统会对这些注册的观察者做出通知。其用途十分广泛，比方说，你的下载进度条是根据下载百分比决定的，那么，可以通过观察下载百分比的改变，刷新进度条的样式，来直观的反应下载进度等等。 \n\n## KVO的用法 \n### 为对象的属性注册观察者\n\n```objc\n- (void)addObserver:(NSObject *)observer  \n         forKeyPath:(NSString *)keyPath  \n            options:(NSKeyValueObservingOptions)options  \n            context:(void *)context  \n```\n\n- observer: 观察者对象. 其必须实现方法 `observeValueForKeyPath:ofObject:change:context:`.\n- keyPath: 被观察的属性，其不能为 `nil`.\n- options: 设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的，通常设置为 `NSKeyValueObservingOptionNew`。\n- context: 一些其他的需要传递给观察者的上下文信息，通常设置为 `nil`。\n\n### 观察者接收通知\n\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath  \n                      ofObject:(id)object  \n                        change:(NSDictionary *)change  \n                       context:(void *)context  \n```\n\n- keyPath: 被观察的属性，其不能为 `nil`.\n- object: 被观察者的对象.\n- change: 属性值，根据上面提到的 `Options` 设置，给出对应的属性值。\n- context: 上面传递的 `context` 对象。\n\n### 清除观察者\n\n```objc\n- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath  \n```\n\n### 注意事项\n\n使用KVO消息传递机制有两个要求：\n1. 观察者必须知道被观察对象，即在同一作用域。\n2. 观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。 \n\n\n","source":"_posts/KVO.md","raw":"title: KVO 简介\ndate: 2016/11/17 14:07:12  \ncategories: iOS\ntags: \n\t- 学习笔记\n\t\n---\n\n本篇简单学习下如何使用 KVO。\n\n<!--more-->\n\n## KVO是什么？ \nKVO 是 Object-C 中定义的一个通知机制，其定义了一种对象间监控对方状态的改变，并做出反应的机制。对象可以为自己的属性注册观察者，当这个属性的值发生了改变，系统会对这些注册的观察者做出通知。其用途十分广泛，比方说，你的下载进度条是根据下载百分比决定的，那么，可以通过观察下载百分比的改变，刷新进度条的样式，来直观的反应下载进度等等。 \n\n## KVO的用法 \n### 为对象的属性注册观察者\n\n```objc\n- (void)addObserver:(NSObject *)observer  \n         forKeyPath:(NSString *)keyPath  \n            options:(NSKeyValueObservingOptions)options  \n            context:(void *)context  \n```\n\n- observer: 观察者对象. 其必须实现方法 `observeValueForKeyPath:ofObject:change:context:`.\n- keyPath: 被观察的属性，其不能为 `nil`.\n- options: 设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的，通常设置为 `NSKeyValueObservingOptionNew`。\n- context: 一些其他的需要传递给观察者的上下文信息，通常设置为 `nil`。\n\n### 观察者接收通知\n\n```objc\n- (void)observeValueForKeyPath:(NSString *)keyPath  \n                      ofObject:(id)object  \n                        change:(NSDictionary *)change  \n                       context:(void *)context  \n```\n\n- keyPath: 被观察的属性，其不能为 `nil`.\n- object: 被观察者的对象.\n- change: 属性值，根据上面提到的 `Options` 设置，给出对应的属性值。\n- context: 上面传递的 `context` 对象。\n\n### 清除观察者\n\n```objc\n- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath  \n```\n\n### 注意事项\n\n使用KVO消息传递机制有两个要求：\n1. 观察者必须知道被观察对象，即在同一作用域。\n2. 观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。 \n\n\n","slug":"KVO","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dow000q7hzgs2s68odb","content":"<p>本篇简单学习下如何使用 KVO。</p>\n<a id=\"more\"></a>\n<h2 id=\"KVO是什么？\"><a href=\"#KVO是什么？\" class=\"headerlink\" title=\"KVO是什么？\"></a>KVO是什么？</h2><p>KVO 是 Object-C 中定义的一个通知机制，其定义了一种对象间监控对方状态的改变，并做出反应的机制。对象可以为自己的属性注册观察者，当这个属性的值发生了改变，系统会对这些注册的观察者做出通知。其用途十分广泛，比方说，你的下载进度条是根据下载百分比决定的，那么，可以通过观察下载百分比的改变，刷新进度条的样式，来直观的反应下载进度等等。 </p>\n<h2 id=\"KVO的用法\"><a href=\"#KVO的用法\" class=\"headerlink\" title=\"KVO的用法\"></a>KVO的用法</h2><h3 id=\"为对象的属性注册观察者\"><a href=\"#为对象的属性注册观察者\" class=\"headerlink\" title=\"为对象的属性注册观察者\"></a>为对象的属性注册观察者</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addObserver:(<span class=\"built_in\">NSObject</span> *)observer  </div><div class=\"line\">         forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath  </div><div class=\"line\">            options:(<span class=\"built_in\">NSKeyValueObservingOptions</span>)options  </div><div class=\"line\">            context:(<span class=\"keyword\">void</span> *)context</div></pre></td></tr></table></figure>\n<ul>\n<li>observer: 观察者对象. 其必须实现方法 <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>\n<li>keyPath: 被观察的属性，其不能为 <code>nil</code>.</li>\n<li>options: 设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的，通常设置为 <code>NSKeyValueObservingOptionNew</code>。</li>\n<li>context: 一些其他的需要传递给观察者的上下文信息，通常设置为 <code>nil</code>。</li>\n</ul>\n<h3 id=\"观察者接收通知\"><a href=\"#观察者接收通知\" class=\"headerlink\" title=\"观察者接收通知\"></a>观察者接收通知</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath  </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object  </div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change  </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div></pre></td></tr></table></figure>\n<ul>\n<li>keyPath: 被观察的属性，其不能为 <code>nil</code>.</li>\n<li>object: 被观察者的对象.</li>\n<li>change: 属性值，根据上面提到的 <code>Options</code> 设置，给出对应的属性值。</li>\n<li>context: 上面传递的 <code>context</code> 对象。</li>\n</ul>\n<h3 id=\"清除观察者\"><a href=\"#清除观察者\" class=\"headerlink\" title=\"清除观察者\"></a>清除观察者</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"built_in\">NSObject</span> *)anObserver forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</div></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>使用KVO消息传递机制有两个要求：</p>\n<ol>\n<li>观察者必须知道被观察对象，即在同一作用域。</li>\n<li>观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。 </li>\n</ol>\n","excerpt":"<p>本篇简单学习下如何使用 KVO。</p>","more":"<h2 id=\"KVO是什么？\"><a href=\"#KVO是什么？\" class=\"headerlink\" title=\"KVO是什么？\"></a>KVO是什么？</h2><p>KVO 是 Object-C 中定义的一个通知机制，其定义了一种对象间监控对方状态的改变，并做出反应的机制。对象可以为自己的属性注册观察者，当这个属性的值发生了改变，系统会对这些注册的观察者做出通知。其用途十分广泛，比方说，你的下载进度条是根据下载百分比决定的，那么，可以通过观察下载百分比的改变，刷新进度条的样式，来直观的反应下载进度等等。 </p>\n<h2 id=\"KVO的用法\"><a href=\"#KVO的用法\" class=\"headerlink\" title=\"KVO的用法\"></a>KVO的用法</h2><h3 id=\"为对象的属性注册观察者\"><a href=\"#为对象的属性注册观察者\" class=\"headerlink\" title=\"为对象的属性注册观察者\"></a>为对象的属性注册观察者</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addObserver:(<span class=\"built_in\">NSObject</span> *)observer  </div><div class=\"line\">         forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath  </div><div class=\"line\">            options:(<span class=\"built_in\">NSKeyValueObservingOptions</span>)options  </div><div class=\"line\">            context:(<span class=\"keyword\">void</span> *)context</div></pre></td></tr></table></figure>\n<ul>\n<li>observer: 观察者对象. 其必须实现方法 <code>observeValueForKeyPath:ofObject:change:context:</code>.</li>\n<li>keyPath: 被观察的属性，其不能为 <code>nil</code>.</li>\n<li>options: 设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的，通常设置为 <code>NSKeyValueObservingOptionNew</code>。</li>\n<li>context: 一些其他的需要传递给观察者的上下文信息，通常设置为 <code>nil</code>。</li>\n</ul>\n<h3 id=\"观察者接收通知\"><a href=\"#观察者接收通知\" class=\"headerlink\" title=\"观察者接收通知\"></a>观察者接收通知</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath  </div><div class=\"line\">                      ofObject:(<span class=\"keyword\">id</span>)object  </div><div class=\"line\">                        change:(<span class=\"built_in\">NSDictionary</span> *)change  </div><div class=\"line\">                       context:(<span class=\"keyword\">void</span> *)context</div></pre></td></tr></table></figure>\n<ul>\n<li>keyPath: 被观察的属性，其不能为 <code>nil</code>.</li>\n<li>object: 被观察者的对象.</li>\n<li>change: 属性值，根据上面提到的 <code>Options</code> 设置，给出对应的属性值。</li>\n<li>context: 上面传递的 <code>context</code> 对象。</li>\n</ul>\n<h3 id=\"清除观察者\"><a href=\"#清除观察者\" class=\"headerlink\" title=\"清除观察者\"></a>清除观察者</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"built_in\">NSObject</span> *)anObserver forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath</div></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>使用KVO消息传递机制有两个要求：</p>\n<ol>\n<li>观察者必须知道被观察对象，即在同一作用域。</li>\n<li>观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。 </li>\n</ol>"},{"title":"NSNotification的使用","date":"2016-09-13T06:07:12.000Z","_content":"\n本篇是对ios的通知使用方法的一个简单罗列。\n\n\n<!--more-->\n\n## NSNotificationCenter\n`NSNotificationCenter`就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个`NSNotificationCenter`，让我们可以很方便的进行通知的注册和移除。\n\n## 注册\n### addObserver:selector:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@\"test\" object:nil];\n```\n\n参数：\n- `addObserver`:貌似都是`controller`因为还需要`selector`来执行\n- `name`:通知名。当发送该通知名的通知是，观察者收到消息。\n- `object`:缩小接受通知的范围，只接受相对应的`object`对象发来的通知。`nil`则全部接收。\n\n### addObserverForName:object:queue:usingBlock:\n`NSNotificationCenter`消息的接受线程是基于发送消息的线程的,也就是**同步**的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。\n```objc\nid observer = [[NSNotificationCenter defaultCenter] addObserverForName:notification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(){...}];\n```\n\n参数：\n- `queue`:`block`执行所在的线程。如果是`nil`那么就在当前线程(posting thread)\n- `block`:该种方式不用`selector`而使用`block`回调。\n\n## 删除\n只要往`NSNotificationCenter`注册了，就必须有`remove`的存在。\n\n### removeObserver:\n```objc\n- (void)removeObserver:(id)notificationObserver\n```\n对应`addObserverForName`方式，直接把上面的`id observer`作为参数传入即可。\n对应`addObserver`方式，删除`controller`中全部通知.\n\n### removeObserver:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] removeObserver:self name:NotificationCitySelect object:nil]\n```\n删除指定`name`的通知。\n\n## 发送\n```objc\n[[NSNotificationCenter defaultCenter] postNotificationName:NotificationCitySelectChanged object:@{NotificationCitySelect_ObjectLocationChange:@(YES)}]\n```\n发送指定`objcet`的通知，只有注册时注册了该对象的通知才可以接收。\n\n\n","source":"_posts/NSNotification基本使用.md","raw":"title: NSNotification的使用\ndate: 2016/9/13 14:07:12  \ncategories: iOS\ntags: \n\t- NSNotification\n\t\n---\n\n本篇是对ios的通知使用方法的一个简单罗列。\n\n\n<!--more-->\n\n## NSNotificationCenter\n`NSNotificationCenter`就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个`NSNotificationCenter`，让我们可以很方便的进行通知的注册和移除。\n\n## 注册\n### addObserver:selector:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@\"test\" object:nil];\n```\n\n参数：\n- `addObserver`:貌似都是`controller`因为还需要`selector`来执行\n- `name`:通知名。当发送该通知名的通知是，观察者收到消息。\n- `object`:缩小接受通知的范围，只接受相对应的`object`对象发来的通知。`nil`则全部接收。\n\n### addObserverForName:object:queue:usingBlock:\n`NSNotificationCenter`消息的接受线程是基于发送消息的线程的,也就是**同步**的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。\n```objc\nid observer = [[NSNotificationCenter defaultCenter] addObserverForName:notification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(){...}];\n```\n\n参数：\n- `queue`:`block`执行所在的线程。如果是`nil`那么就在当前线程(posting thread)\n- `block`:该种方式不用`selector`而使用`block`回调。\n\n## 删除\n只要往`NSNotificationCenter`注册了，就必须有`remove`的存在。\n\n### removeObserver:\n```objc\n- (void)removeObserver:(id)notificationObserver\n```\n对应`addObserverForName`方式，直接把上面的`id observer`作为参数传入即可。\n对应`addObserver`方式，删除`controller`中全部通知.\n\n### removeObserver:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] removeObserver:self name:NotificationCitySelect object:nil]\n```\n删除指定`name`的通知。\n\n## 发送\n```objc\n[[NSNotificationCenter defaultCenter] postNotificationName:NotificationCitySelectChanged object:@{NotificationCitySelect_ObjectLocationChange:@(YES)}]\n```\n发送指定`objcet`的通知，只有注册时注册了该对象的通知才可以接收。\n\n\n","slug":"NSNotification基本使用","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41doz000v7hzgy9g90leg","content":"<p>本篇是对ios的通知使用方法的一个简单罗列。</p>\n<a id=\"more\"></a>\n<h2 id=\"NSNotificationCenter\"><a href=\"#NSNotificationCenter\" class=\"headerlink\" title=\"NSNotificationCenter\"></a>NSNotificationCenter</h2><p><code>NSNotificationCenter</code>就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个<code>NSNotificationCenter</code>，让我们可以很方便的进行通知的注册和移除。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><h3 id=\"addObserver-selector-name-object\"><a href=\"#addObserver-selector-name-object\" class=\"headerlink\" title=\"addObserver:selector:name:object:\"></a>addObserver:selector:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) name:<span class=\"string\">@\"test\"</span> object:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>addObserver</code>:貌似都是<code>controller</code>因为还需要<code>selector</code>来执行</li>\n<li><code>name</code>:通知名。当发送该通知名的通知是，观察者收到消息。</li>\n<li><code>object</code>:缩小接受通知的范围，只接受相对应的<code>object</code>对象发来的通知。<code>nil</code>则全部接收。</li>\n</ul>\n<h3 id=\"addObserverForName-object-queue-usingBlock\"><a href=\"#addObserverForName-object-queue-usingBlock\" class=\"headerlink\" title=\"addObserverForName:object:queue:usingBlock:\"></a>addObserverForName:object:queue:usingBlock:</h3><p><code>NSNotificationCenter</code>消息的接受线程是基于发送消息的线程的,也就是<strong>同步</strong>的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> observer = [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserverForName:notification object:<span class=\"literal\">nil</span> queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] usingBlock:^()&#123;...&#125;];</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>queue</code>:<code>block</code>执行所在的线程。如果是<code>nil</code>那么就在当前线程(posting thread)</li>\n<li><code>block</code>:该种方式不用<code>selector</code>而使用<code>block</code>回调。</li>\n</ul>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>只要往<code>NSNotificationCenter</code>注册了，就必须有<code>remove</code>的存在。</p>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver:\"></a>removeObserver:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"keyword\">id</span>)notificationObserver</div></pre></td></tr></table></figure>\n<p>对应<code>addObserverForName</code>方式，直接把上面的<code>id observer</code>作为参数传入即可。<br>对应<code>addObserver</code>方式，删除<code>controller</code>中全部通知.</p>\n<h3 id=\"removeObserver-name-object\"><a href=\"#removeObserver-name-object\" class=\"headerlink\" title=\"removeObserver:name:object:\"></a>removeObserver:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span> name:NotificationCitySelect object:<span class=\"literal\">nil</span>]</div></pre></td></tr></table></figure>\n<p>删除指定<code>name</code>的通知。</p>\n<h2 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(<span class=\"literal\">YES</span>)&#125;]</div></pre></td></tr></table></figure>\n<p>发送指定<code>objcet</code>的通知，只有注册时注册了该对象的通知才可以接收。</p>\n","excerpt":"<p>本篇是对ios的通知使用方法的一个简单罗列。</p>","more":"<h2 id=\"NSNotificationCenter\"><a href=\"#NSNotificationCenter\" class=\"headerlink\" title=\"NSNotificationCenter\"></a>NSNotificationCenter</h2><p><code>NSNotificationCenter</code>就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个<code>NSNotificationCenter</code>，让我们可以很方便的进行通知的注册和移除。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><h3 id=\"addObserver-selector-name-object\"><a href=\"#addObserver-selector-name-object\" class=\"headerlink\" title=\"addObserver:selector:name:object:\"></a>addObserver:selector:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) name:<span class=\"string\">@\"test\"</span> object:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>addObserver</code>:貌似都是<code>controller</code>因为还需要<code>selector</code>来执行</li>\n<li><code>name</code>:通知名。当发送该通知名的通知是，观察者收到消息。</li>\n<li><code>object</code>:缩小接受通知的范围，只接受相对应的<code>object</code>对象发来的通知。<code>nil</code>则全部接收。</li>\n</ul>\n<h3 id=\"addObserverForName-object-queue-usingBlock\"><a href=\"#addObserverForName-object-queue-usingBlock\" class=\"headerlink\" title=\"addObserverForName:object:queue:usingBlock:\"></a>addObserverForName:object:queue:usingBlock:</h3><p><code>NSNotificationCenter</code>消息的接受线程是基于发送消息的线程的,也就是<strong>同步</strong>的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> observer = [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserverForName:notification object:<span class=\"literal\">nil</span> queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] usingBlock:^()&#123;...&#125;];</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>queue</code>:<code>block</code>执行所在的线程。如果是<code>nil</code>那么就在当前线程(posting thread)</li>\n<li><code>block</code>:该种方式不用<code>selector</code>而使用<code>block</code>回调。</li>\n</ul>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>只要往<code>NSNotificationCenter</code>注册了，就必须有<code>remove</code>的存在。</p>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver:\"></a>removeObserver:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"keyword\">id</span>)notificationObserver</div></pre></td></tr></table></figure>\n<p>对应<code>addObserverForName</code>方式，直接把上面的<code>id observer</code>作为参数传入即可。<br>对应<code>addObserver</code>方式，删除<code>controller</code>中全部通知.</p>\n<h3 id=\"removeObserver-name-object\"><a href=\"#removeObserver-name-object\" class=\"headerlink\" title=\"removeObserver:name:object:\"></a>removeObserver:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span> name:NotificationCitySelect object:<span class=\"literal\">nil</span>]</div></pre></td></tr></table></figure>\n<p>删除指定<code>name</code>的通知。</p>\n<h2 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(<span class=\"literal\">YES</span>)&#125;]</div></pre></td></tr></table></figure>\n<p>发送指定<code>objcet</code>的通知，只有注册时注册了该对象的通知才可以接收。</p>"},{"title":"React-Native 技巧与坑总结","date":"2016-11-25T02:07:12.000Z","_content":"\n本文将收集关于 React-Native 的各种技巧与坑，不论是摘录的还是自己遇到的。\n\n<!--more-->\n\n### 上拉加载\nRN 中的 ListView 自带了上拉加载的方法：`onEndReached`。使用方法很简单，当下拉到一定阈值 `onEndReachedThreshold` 时，自动回调 `onEndReached` 传入的方法，如果加载的数据不满足一屏，也会自动回调：\n\n```jsx\n<ListView dataSource={this.state.dataSource}\n          renderRow={this._cellForRow.bind(this)}\n          onEndReached={this._pullUpToRefresh.bind(this)}\n          enableEmptySections = {true}\n          onEndReachedThreshold={100} >\n</ListView>\n```\n\n相应的网络请求方法和上拉加载方法如下：\n\n```javascript\n//默认加载数据\ncomponentDidMount() {\n    this._getRemoteData();\n}\n\n// 上拉加载更多方法\n_pullUpToRefresh() {\n    if (this._canPull) {\n        this._pageNo++;\n        this._getRemoteData();\n    }\n}\n\n// 获取数据\n_getRemoteData(){\n    this._canPull = false;\n    TravelTogether.getTravelTogetherList(this._pageNo,this._pageSize,(data) => {\n        for (let i=0;i<data.list.length;i++){\n            this._dataSources.push(data.list[i]);\n        }\n        this.setState({dataSource:this.state.dataSource.cloneWithRows(this._dataSources)});\n        if (data.list.length === this._pageSize){\n            this._canPull = true;\n        }\n\n    });\n}\n```\n\n使用的时候是与一些坑的。首先，`onEndReached` 方法在第一次加载数据的时候必定会回调，这是 RN 的一个 bug。必须要自行设置一个 `_canPull` 的 flag 来控制是否要从服务器获取数据。其次，要注意 `onEndReached` 的调用时机。它的准确调用时机是在网络请求返回执行回调，设置状态 `this.setState()` 的时候。因此，你不能在 `setState()` 前将 `_canPull` 设置为 `true`，必须如上面一样，放在 `setState()` 之后。\n\n\n\n### 关于Prop\n#### propTypes\n组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 `PropTypes` 属性，就是用来验证组件实例的属性是否符合要求。\n\n```javascript\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <Text>{this.props.name}</Text>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: React.PropTypes.string\n};\n```\n\n上面例子中，如果 `name` 不是 string 类型，那么就会产生一个警告。还可以设置 `name: React.PropTypes.string.isRequired` 表示必须传入属性 `name`。\n\n除了 string 外，还有许多类型的 PropTypes 可以设置。[参见](https://facebook.github.io/react/docs/typechecking-with-proptypes.html) 再举一个设置单一子节点的例子：\n\n```javascript\nclass MyComponent extends React.Component {\n  render() {\n    // This must be exactly one element or it will warn.\n    const children = this.props.children;\n    return (\n        {children}\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: React.PropTypes.element.isRequired\n};\n```\n\n#### defaultProps\n可以在 `defaultProps` 中注册设置默认属性值。\n\n```javscript\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <Text>{this.props.name}</Text>\n    );\n  }\n}\n\nGreeting.defaultProps = {\n  name: 'hahaha'\n};\n```\n\n结合上面这两个属性，就不必再在构造函数里设置各种值了。\n\n\n### this.props.children\n`this.props` 对象的属性与组件的属性一一对应，但是有一个例外，就是 `this.props.children` 属性。它表示组件的所有子节点。类似于 `TouchableOpaque` 里嵌入 `Text`，通过这种方式可以很方便的嵌套封装控件。\n\n```javascript\nclass NewComponent extends React.Component{\n\trender(){\n\t\treturn(\n\t\t\t{this.props.children}\n\t\t);\n\t}\n}\n\n//调用：\n<NewComponent>\n\t<Text>haha</Text>\n</NewComponent>\n```\n\n\n### 关于 import，require，export，module.exports的区别\nES6标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，使用 require 引入模块，使用 module.exports 导出接口。那么在混用的情况下到底有什么异同呢？\n\n#### export,module.exports\n首先要明确一点，现今的所有 class 都会被编译器转化为同名的 function，function 内部通过 babel 提供的方法实现 class 内的各个属性和方法。\n\n- `export xx`导出的都是 {} 括起来的对象。如果是对象，那么自动变为 `{target名:target}` 的形式；如果后面跟的是 function，那么会自动变为：`{function名:function}` 的形式。因此一般不能 export 匿名对象和方法。有一个特殊用法 `export default 对象/方法` 相当于导出了一个别名为 default 的对象/方法 `{default:对象/方法}` 一个文件内，可以使用多次 export，但只能将一个对象/方法设置为 default。\n- `module.exports = xx` 较为直接，赋值的是什么，导出的就是什么。\n\n#### import,require\n- import 一般和 export 一起使用，是一种解构的方式。如：`import a {b,c} from './xx'`，等价于 `import {default as a,b,c} from './xx'`。相当于将 default 导出，并给 default取了个别名 a。\n- require 一般和 module.exports 一起使用，直接将 module.exports 导出的对象赋给接收对象。如：`var a = require('./xx')`。\n#### 混用\n- 如果 import 和 `module.exports = xx` 一起使用，则直接 import。如:`import xx from './xx'`。\n- 如果 require 和 export 一起使用则相当于将 export 生成的导出对象付给接收对象。如：`export default funcA`,导入方式一样，`var a = require('./xx');` 但要这样使用 `a.default();`\n\n\n综上，两种export的方式，对于import都一样，但是对于 require有所不同。[参考链接](http://www.tuicool.com/articles/uuUVBv2)\n\n\n\n### 关于编译时 RCTHTTPRequestHandler.m 不存在的问题\n\n升级了一下 React-Native 的版本后（3.2=>3.8），Xcode 编译的时候出现了 `RCTHTTPRequestHandler.m not found` 的编译错误。原因应该是 `RCTHTTPRequestHandler.m` 在后面的版本变为了 `RCTHTTPRequestHandler.mm`。\n\n解决方法很简单，在 React-Native 版本升级，即使用 `npm update` 后，需要重新 `pod install` 一遍。因为 React 作为 pod 中的一项，Xcode 是通过 `pod install` 后生成的索引来定位 React 中的各个文件的。只 `npm update` 而不 `pod install`，Xcode 编译的时候通过 3.2 的文件索引，去 3.8 里找文件，就很有可能因为版本变化导致找不到文件。 \n \n\n### TextInput 隐藏键盘\nNative 中的 `UITextField` 可以通过 `resignFirstResponder` 或者 `endEditing` 的方式取消第一响应者，从而隐藏虚拟键盘。那么，react 中如何做到隐藏键盘呢？\n\n可以使用 `ScrollView` 包装我们的 `View`。\n`ScrollView` 可以设置 `keyboardDismissMode`，`keyboardShouldPersistTaps` 来控制输入法的行为。\n\n```jsx\n<ScrollView \tcontentContainerStyle={{flex:1}//非常重要，让ScrollView的子元素占满整个区域\n\t\t\t\tkeyboardDismissMode='on-drag' //拖动界面输入法退出\n\t\t\t\tkeyboardShouldPersistTaps={false} //点击输入法意外的区域，输入法退出\n\t\t\t\t>\n....\n</ScrollView>\n```\n\n### 生命周期回调函数总结\n#### componentWillMount()\n`componentWillMount` 会在组件 `render` 之前执行，并且永远都只执行一次。\n\n#### componentDidMount()\n`componentDidMount` 会在组件加载完毕之后立即执行。\n\n#### componentWillReceiveProps(object nextProps)\n在组件接收到一个新的 prop 时被执行。这个方法在初始化 `render` 时不会被调用。\n\n#### boolean shouldComponentUpdate(object nextProps, object nextState)\n返回一个布尔值。在组件的 props 或者 state 改变时被执行。在初始化时或者使用  `forceUpdate` 时不被执行。\n\n如果 `shouldComponentUpdate` 返回 `false`,`render()` 则会在下一个 state change 之前被完全跳过。(另外 `componentWillUpdate` 和  `componentDidUpdate` 也不会被执行)默认情况下 `shouldComponentUpdate` 会返回 `true`.\n\n#### componentWillUpdate(object nextProps, object nextState)\n组件接收到新的 `props` 或者 `state` 但还没有 `render` 时被执行。在初始化时不会被执行。一般用在组件发生更新之前。\n\n#### componentDidUpdate(object prevProps, object prevState)\n在组件完成更新后立即执行。在初始化时不会被执行。一般会在组件完成更新后被使用。例如清除 notification 文字等操作。\n\n#### componentWillUnmount()\n主要用来执行一些必要的清理任务。**注意，`Unmount` 的大小写。**\n\n\n### 如何判断对象是否有某个属性\n- 使用in关键字 该方法可以判断对象的自有属性和继承来的属性是否存在。\n\t\n\t```\n\tvar o={x:1};\n\t\"x\" in o; //true，自有属性存在\n\t\"y\" in o; //false\n\t\"toString\" in o; //true，是一个继承属性\n\t```\n\t\n- 使用对象的hasOwnProperty()方法 该方法只能判断自有属性是否存在，对于继承属性会返回false。\n\t\n\t```\n\tvar o={x:1};\n\to.hasOwnProperty(\"x\"); 　　 //true，自有属性中有x\n\to.hasOwnProperty(\"y\"); 　　 //false，自有属性中不存在y\n\to.hasOwnProperty(\"toString\"); //false，这是一个继承属性，但不是自有属性\n\t```\n\t\n- 用undefined判断 自有属性和继承属性均可判断。\n\t\n\t```\n\tvar o={x:1};\n\to.x!==undefined; //true\n\to.y!==undefined; //false\n\to.toString!==undefined //true\n\t```\n- 在条件语句中直接判断\n\t\n\t```\n\tvar o={};\n\tif(o.x) o.x+=1; //如果x是undefine,null,false,\" \",0或NaN,它将保持不变\n\t```\n\n\n\n### 可取消的Promise\n`Promise`是 React Native 开发过程中用于异步操作的最常用的 API，但 Promise 没有提供用于取消异步操作的方法。为了实现可取消的异步操作，我们可以为 Promise 包裹一层可取消的外衣。    \n\n```javascript\nconst makeCancelable = (promise) => {\n  let hasCanceled_ = false;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then((val) =>\n      hasCanceled_ ? reject({isCanceled: true}) : resolve(val)\n    );\n    promise.catch((error) =>\n      hasCanceled_ ? reject({isCanceled: true}) : reject(error)\n    );\n  });\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};  \n```\n\n然后可以这样使用取消操作：   \n\n```javascript\nconst somePromise = new Promise(r => setTimeout(r, 1000));//创建一个异步操作\nconst cancelable = makeCancelable(somePromise);//为异步操作添加可取消的功能\ncancelable\n  .promise\n  .then(() => console.log('resolved'))\n  .catch(({isCanceled, ...error}) => console.log('isCanceled', isCanceled));\n// 取消异步操作\ncancelable.cancel();   \n```\n\nPromise后面括号内跟的是要异步执行的操作，`.then()`里跟的是异步操作执行完后的回调函数。取消 Promise 换句话说也就是取消 `.then()` 里的回到函数的执行。\n\n这里通过创建一个辅助的 Promise 来包裹要执行的 Promise，这个设计非常的巧妙。\n\n首先，如何实现取消 `.then()` 里的毁掉函数的执行？那么就不能用 `.then(callback)` 的形式了，而要有一个标识位判断：`.then(()=>flag?执行:不执行)`。\n\n那么 `flag` 定义在哪？肯定不能直接作为一个变量定义在执行 Promise 的类里，因为这个类可能有多个 Promise 任务要处理，创建多个 `flag` 显然不是一个好的选择。那么就可以新建一个 `class`，这个 `class` 里包含 `flag` 以及这个 Promise，这就需要每次创建 Promise 的时候都 `new` 一个对象出来。这个方式可行，但是不够优雅。由于 Js 是弱类型的，我们没有必要专门定义一个 `class`，反正都是 `var`。因此，就应该像上面那样通过一个方法，直接 `return` 一个 `{}` 包裹起来的对象。因为 `return` 的这个对象用到了 `hasCanceled` 这个参数，由于有闭包性，在 `return` 的这个对象被销毁前 `hasCanceled` 都是可触及的。\n\n最后，为什么要用一个辅助的 Promise 去包裹？ 其实用一个类或者一个方法也是能达到同样的效果。这样的设计也很巧妙。将要执行的 Promise 的 `.then()` 作为 辅助的 Promise 的异步执行操作，达到的目的是在 `.then()` 完成后，辅助的 Promise 的异步操作才可能结束。当辅助的 Promise 的异步操作结束后，就可以调用其自己的 `.then()` 来通知要执行的 Promise 已经执行完毕（仔细想了想，其实用辅助 Promise 也没甚屌用，因为 `.then()` 是可以链式调用的如：`.then().then()`，我完全可以直接自己定义一个 `function`，比如：`(callbackLogical,callbackNotify)=>promise.then(()=>flag?执行callbackLogical:不执行callbackLogical).then(callbackNotify)`。只要调用了这个方法，那么不就都搞定了么。\n\n\n\n\n### AsyncStorage存储key管理小技巧   \n`AsyncStorage` 是一个简单的、异步的、持久化的 `Key-Value` 存储系统，它对于 App 来说是全局性的。它用来代替 `LocalStorage`。\n\n推荐使用封装好的第三方库[react-native-storage](https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md) 具体使用方式就不细说了。\n\n\n\n### 全局变量\n正如 web 中的 `window`，在 RN 中也有一个全局根属性可以挂载各种全局变量：`global`。比如上面推荐的 `react-native-storage` 用到的 `storage`,使用 `global.storage = storage` 就可以在各个地方拿到 `storage` 对象。\n\n但是要注意一点，一定要注意执行顺序，也就是必须要在使用 `global.storage` 前，将 `storage` 赋给 `global.storage`，所以要将这个赋值放到必须执行的文件中。\n\n### 优化切换动画卡顿的问题\n\n使用API `InteractionManager`，它的作用就是可以使本来 JS 的一些操作在动画完成之后执行，这样就可确保动画的流程性。当然这是在延迟执行为代价上来获得帧数的提高。\n```javascript\n\tInteractionManager.runAfterInteractions(()=>{\n\t\t//...耗时较长的同步任务...\n\t\t//更新state也需要时间\n\t\tthis.setState({\n\t\t\t...\n\t\t})\n\t\t//获取某些数据，需要长时间等待\n\t\tthis.fetchData(arguements)\n\t})\n```\n\n### React-Native 原生模块调用(iOS)\n在项目中遇到地图,拨打电话,清除缓存等iOS与Andiorid机制不同的功能,就需要调用原生的界面或模块。\n\n#### 创建原生模块，实现“RCTBridgeModule”协议\n```\n#import <UIKit/UIKit.h>\n#import \"RCTBridgeModule.h\"\n\n@interface LoginViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n#### 导出模块，导出方法\n不仅可以让导出 native 的方法，而且还可以在 js 中添加回调函数，供 native 调用，这样 native 就可以将前面的数据回塞给 js 了。\n```\n@implementation LoginViewController\n//导出模块\nRCT_EXPORT_MODULE()\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\nRCT_EXPORT_METHOD(showSVProgressHUDErrorWithStatus:(NSString *)state callBack:(RCTResponseSenderBlock)callback){\n  NSLog(@\"state is %@\",state);\n  NSArray *events = [[NSArray alloc] initWithObjects:@\"hello\", nil];\n  // 这里callback必须是数组\n  callback(events);\n  [SVProgressHUD showErrorWithStatus:state];\n}\n\n@end\n\n```\n\n#### js文件中调用\n```\n//创建原生模块实例\nlet LoginViewController = NativeModules.LoginViewController;\n\n//方法调用\nLoginViewController.showSVProgressHUDErrorWithStatus('请输入正确的手机号',(callbackString) => {console.log(callbackString);});     \n```\n\n\n\n\n\n### React Native 真机调试 \n开发中真机调试是必不可少的,有些功能和问题模拟器是无法重现的,所以就需要配合真机测试\n\n#### iOS 真机调试\n首先，**必须** 保证调试用电脑的和你的设备处于相同的 `WiFi` 网络环境中下。然后修改`AppDelegate.m` 文件，设置 `jsLocation` 为本地 ip 即可。\n\n```objc\nNSURL *jsCodeLocation;\n[RCTBundleURLProvider sharedSettings].jsLocation = @\"192.168.31.142\";\njsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index.ios\" fallbackResource:nil];\n\nRCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                      moduleName:@\"AwesomeProject\"\n                                               initialProperties:nil\n                                                   launchOptions:launchOptions];\n```\n\n### React Native import 文件的小技巧\n开发中经常需要 import 其他 js 文件，如果需要同时导入一些相关的 js 文件时，可以创建一个索引文件方便引用。  \n\n#### 第一步：创建index.js   \n在 `index.js` 中 import 相关的 js 文件\n\n```\n'use strict';\n\nimport Request from './network/RequestManager';\nimport AppContext from './network/AppContext';\nimport ApiServiceFactory from './network/ApiServiceFactory';\n\nmodule.exports = {\n    ApiServiceFactory,\n    Request,\n    AppContext\n};\n```\n\n#### 第二步：使用   \n如果需要使用这些类，只需要导入 `index` 文件就可以了~\n\n```\nimport {Request, ApiServiceFactory, AppContext} from '../expand/index';\n```\n\n\n### React Native 读取本地的json文件  \n可以以导入的形式，来读取本地的json文件，导入的文件可以作为一个js对象使用，这样方便调试的时候加载数据。\n\n#### 导入json文件：   \n```javascript\nvar langsData = require('./json/langs.json');\n```\n\n现在你可以操作`langsData`对象了。  \n\n#### json格式\n\n```json\n[\n  {\n    \"path\":\"\",\n    \"name\":\"123\",\n    \"checked\":false\n  },\n  {\n    \"path\":\"aa\",\n    \"name\":\"1234\",\n    \"checked\":false\n  },\n  {\n    \"path\":\"ddd\",\n    \"name\":\"123123123\",\n    \"checked\":true\n  }\n]\n```\n\n#### 使用\n```javascript\nfor (var i=0,l=langsData.length;i<l;i++){\n\tconsole.log(langsData[i]);\n}\n```\n\n\n","source":"_posts/RN使用技巧.md","raw":"title: React-Native 技巧与坑总结\ndate: 2016/11/25 10:07:12  \ncategories: React-Native\ntags:\n\t- React-Native\n\t- 爬坑\n\n---\n\n本文将收集关于 React-Native 的各种技巧与坑，不论是摘录的还是自己遇到的。\n\n<!--more-->\n\n### 上拉加载\nRN 中的 ListView 自带了上拉加载的方法：`onEndReached`。使用方法很简单，当下拉到一定阈值 `onEndReachedThreshold` 时，自动回调 `onEndReached` 传入的方法，如果加载的数据不满足一屏，也会自动回调：\n\n```jsx\n<ListView dataSource={this.state.dataSource}\n          renderRow={this._cellForRow.bind(this)}\n          onEndReached={this._pullUpToRefresh.bind(this)}\n          enableEmptySections = {true}\n          onEndReachedThreshold={100} >\n</ListView>\n```\n\n相应的网络请求方法和上拉加载方法如下：\n\n```javascript\n//默认加载数据\ncomponentDidMount() {\n    this._getRemoteData();\n}\n\n// 上拉加载更多方法\n_pullUpToRefresh() {\n    if (this._canPull) {\n        this._pageNo++;\n        this._getRemoteData();\n    }\n}\n\n// 获取数据\n_getRemoteData(){\n    this._canPull = false;\n    TravelTogether.getTravelTogetherList(this._pageNo,this._pageSize,(data) => {\n        for (let i=0;i<data.list.length;i++){\n            this._dataSources.push(data.list[i]);\n        }\n        this.setState({dataSource:this.state.dataSource.cloneWithRows(this._dataSources)});\n        if (data.list.length === this._pageSize){\n            this._canPull = true;\n        }\n\n    });\n}\n```\n\n使用的时候是与一些坑的。首先，`onEndReached` 方法在第一次加载数据的时候必定会回调，这是 RN 的一个 bug。必须要自行设置一个 `_canPull` 的 flag 来控制是否要从服务器获取数据。其次，要注意 `onEndReached` 的调用时机。它的准确调用时机是在网络请求返回执行回调，设置状态 `this.setState()` 的时候。因此，你不能在 `setState()` 前将 `_canPull` 设置为 `true`，必须如上面一样，放在 `setState()` 之后。\n\n\n\n### 关于Prop\n#### propTypes\n组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 `PropTypes` 属性，就是用来验证组件实例的属性是否符合要求。\n\n```javascript\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <Text>{this.props.name}</Text>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: React.PropTypes.string\n};\n```\n\n上面例子中，如果 `name` 不是 string 类型，那么就会产生一个警告。还可以设置 `name: React.PropTypes.string.isRequired` 表示必须传入属性 `name`。\n\n除了 string 外，还有许多类型的 PropTypes 可以设置。[参见](https://facebook.github.io/react/docs/typechecking-with-proptypes.html) 再举一个设置单一子节点的例子：\n\n```javascript\nclass MyComponent extends React.Component {\n  render() {\n    // This must be exactly one element or it will warn.\n    const children = this.props.children;\n    return (\n        {children}\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: React.PropTypes.element.isRequired\n};\n```\n\n#### defaultProps\n可以在 `defaultProps` 中注册设置默认属性值。\n\n```javscript\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <Text>{this.props.name}</Text>\n    );\n  }\n}\n\nGreeting.defaultProps = {\n  name: 'hahaha'\n};\n```\n\n结合上面这两个属性，就不必再在构造函数里设置各种值了。\n\n\n### this.props.children\n`this.props` 对象的属性与组件的属性一一对应，但是有一个例外，就是 `this.props.children` 属性。它表示组件的所有子节点。类似于 `TouchableOpaque` 里嵌入 `Text`，通过这种方式可以很方便的嵌套封装控件。\n\n```javascript\nclass NewComponent extends React.Component{\n\trender(){\n\t\treturn(\n\t\t\t{this.props.children}\n\t\t);\n\t}\n}\n\n//调用：\n<NewComponent>\n\t<Text>haha</Text>\n</NewComponent>\n```\n\n\n### 关于 import，require，export，module.exports的区别\nES6标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，使用 require 引入模块，使用 module.exports 导出接口。那么在混用的情况下到底有什么异同呢？\n\n#### export,module.exports\n首先要明确一点，现今的所有 class 都会被编译器转化为同名的 function，function 内部通过 babel 提供的方法实现 class 内的各个属性和方法。\n\n- `export xx`导出的都是 {} 括起来的对象。如果是对象，那么自动变为 `{target名:target}` 的形式；如果后面跟的是 function，那么会自动变为：`{function名:function}` 的形式。因此一般不能 export 匿名对象和方法。有一个特殊用法 `export default 对象/方法` 相当于导出了一个别名为 default 的对象/方法 `{default:对象/方法}` 一个文件内，可以使用多次 export，但只能将一个对象/方法设置为 default。\n- `module.exports = xx` 较为直接，赋值的是什么，导出的就是什么。\n\n#### import,require\n- import 一般和 export 一起使用，是一种解构的方式。如：`import a {b,c} from './xx'`，等价于 `import {default as a,b,c} from './xx'`。相当于将 default 导出，并给 default取了个别名 a。\n- require 一般和 module.exports 一起使用，直接将 module.exports 导出的对象赋给接收对象。如：`var a = require('./xx')`。\n#### 混用\n- 如果 import 和 `module.exports = xx` 一起使用，则直接 import。如:`import xx from './xx'`。\n- 如果 require 和 export 一起使用则相当于将 export 生成的导出对象付给接收对象。如：`export default funcA`,导入方式一样，`var a = require('./xx');` 但要这样使用 `a.default();`\n\n\n综上，两种export的方式，对于import都一样，但是对于 require有所不同。[参考链接](http://www.tuicool.com/articles/uuUVBv2)\n\n\n\n### 关于编译时 RCTHTTPRequestHandler.m 不存在的问题\n\n升级了一下 React-Native 的版本后（3.2=>3.8），Xcode 编译的时候出现了 `RCTHTTPRequestHandler.m not found` 的编译错误。原因应该是 `RCTHTTPRequestHandler.m` 在后面的版本变为了 `RCTHTTPRequestHandler.mm`。\n\n解决方法很简单，在 React-Native 版本升级，即使用 `npm update` 后，需要重新 `pod install` 一遍。因为 React 作为 pod 中的一项，Xcode 是通过 `pod install` 后生成的索引来定位 React 中的各个文件的。只 `npm update` 而不 `pod install`，Xcode 编译的时候通过 3.2 的文件索引，去 3.8 里找文件，就很有可能因为版本变化导致找不到文件。 \n \n\n### TextInput 隐藏键盘\nNative 中的 `UITextField` 可以通过 `resignFirstResponder` 或者 `endEditing` 的方式取消第一响应者，从而隐藏虚拟键盘。那么，react 中如何做到隐藏键盘呢？\n\n可以使用 `ScrollView` 包装我们的 `View`。\n`ScrollView` 可以设置 `keyboardDismissMode`，`keyboardShouldPersistTaps` 来控制输入法的行为。\n\n```jsx\n<ScrollView \tcontentContainerStyle={{flex:1}//非常重要，让ScrollView的子元素占满整个区域\n\t\t\t\tkeyboardDismissMode='on-drag' //拖动界面输入法退出\n\t\t\t\tkeyboardShouldPersistTaps={false} //点击输入法意外的区域，输入法退出\n\t\t\t\t>\n....\n</ScrollView>\n```\n\n### 生命周期回调函数总结\n#### componentWillMount()\n`componentWillMount` 会在组件 `render` 之前执行，并且永远都只执行一次。\n\n#### componentDidMount()\n`componentDidMount` 会在组件加载完毕之后立即执行。\n\n#### componentWillReceiveProps(object nextProps)\n在组件接收到一个新的 prop 时被执行。这个方法在初始化 `render` 时不会被调用。\n\n#### boolean shouldComponentUpdate(object nextProps, object nextState)\n返回一个布尔值。在组件的 props 或者 state 改变时被执行。在初始化时或者使用  `forceUpdate` 时不被执行。\n\n如果 `shouldComponentUpdate` 返回 `false`,`render()` 则会在下一个 state change 之前被完全跳过。(另外 `componentWillUpdate` 和  `componentDidUpdate` 也不会被执行)默认情况下 `shouldComponentUpdate` 会返回 `true`.\n\n#### componentWillUpdate(object nextProps, object nextState)\n组件接收到新的 `props` 或者 `state` 但还没有 `render` 时被执行。在初始化时不会被执行。一般用在组件发生更新之前。\n\n#### componentDidUpdate(object prevProps, object prevState)\n在组件完成更新后立即执行。在初始化时不会被执行。一般会在组件完成更新后被使用。例如清除 notification 文字等操作。\n\n#### componentWillUnmount()\n主要用来执行一些必要的清理任务。**注意，`Unmount` 的大小写。**\n\n\n### 如何判断对象是否有某个属性\n- 使用in关键字 该方法可以判断对象的自有属性和继承来的属性是否存在。\n\t\n\t```\n\tvar o={x:1};\n\t\"x\" in o; //true，自有属性存在\n\t\"y\" in o; //false\n\t\"toString\" in o; //true，是一个继承属性\n\t```\n\t\n- 使用对象的hasOwnProperty()方法 该方法只能判断自有属性是否存在，对于继承属性会返回false。\n\t\n\t```\n\tvar o={x:1};\n\to.hasOwnProperty(\"x\"); 　　 //true，自有属性中有x\n\to.hasOwnProperty(\"y\"); 　　 //false，自有属性中不存在y\n\to.hasOwnProperty(\"toString\"); //false，这是一个继承属性，但不是自有属性\n\t```\n\t\n- 用undefined判断 自有属性和继承属性均可判断。\n\t\n\t```\n\tvar o={x:1};\n\to.x!==undefined; //true\n\to.y!==undefined; //false\n\to.toString!==undefined //true\n\t```\n- 在条件语句中直接判断\n\t\n\t```\n\tvar o={};\n\tif(o.x) o.x+=1; //如果x是undefine,null,false,\" \",0或NaN,它将保持不变\n\t```\n\n\n\n### 可取消的Promise\n`Promise`是 React Native 开发过程中用于异步操作的最常用的 API，但 Promise 没有提供用于取消异步操作的方法。为了实现可取消的异步操作，我们可以为 Promise 包裹一层可取消的外衣。    \n\n```javascript\nconst makeCancelable = (promise) => {\n  let hasCanceled_ = false;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    promise.then((val) =>\n      hasCanceled_ ? reject({isCanceled: true}) : resolve(val)\n    );\n    promise.catch((error) =>\n      hasCanceled_ ? reject({isCanceled: true}) : reject(error)\n    );\n  });\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};  \n```\n\n然后可以这样使用取消操作：   \n\n```javascript\nconst somePromise = new Promise(r => setTimeout(r, 1000));//创建一个异步操作\nconst cancelable = makeCancelable(somePromise);//为异步操作添加可取消的功能\ncancelable\n  .promise\n  .then(() => console.log('resolved'))\n  .catch(({isCanceled, ...error}) => console.log('isCanceled', isCanceled));\n// 取消异步操作\ncancelable.cancel();   \n```\n\nPromise后面括号内跟的是要异步执行的操作，`.then()`里跟的是异步操作执行完后的回调函数。取消 Promise 换句话说也就是取消 `.then()` 里的回到函数的执行。\n\n这里通过创建一个辅助的 Promise 来包裹要执行的 Promise，这个设计非常的巧妙。\n\n首先，如何实现取消 `.then()` 里的毁掉函数的执行？那么就不能用 `.then(callback)` 的形式了，而要有一个标识位判断：`.then(()=>flag?执行:不执行)`。\n\n那么 `flag` 定义在哪？肯定不能直接作为一个变量定义在执行 Promise 的类里，因为这个类可能有多个 Promise 任务要处理，创建多个 `flag` 显然不是一个好的选择。那么就可以新建一个 `class`，这个 `class` 里包含 `flag` 以及这个 Promise，这就需要每次创建 Promise 的时候都 `new` 一个对象出来。这个方式可行，但是不够优雅。由于 Js 是弱类型的，我们没有必要专门定义一个 `class`，反正都是 `var`。因此，就应该像上面那样通过一个方法，直接 `return` 一个 `{}` 包裹起来的对象。因为 `return` 的这个对象用到了 `hasCanceled` 这个参数，由于有闭包性，在 `return` 的这个对象被销毁前 `hasCanceled` 都是可触及的。\n\n最后，为什么要用一个辅助的 Promise 去包裹？ 其实用一个类或者一个方法也是能达到同样的效果。这样的设计也很巧妙。将要执行的 Promise 的 `.then()` 作为 辅助的 Promise 的异步执行操作，达到的目的是在 `.then()` 完成后，辅助的 Promise 的异步操作才可能结束。当辅助的 Promise 的异步操作结束后，就可以调用其自己的 `.then()` 来通知要执行的 Promise 已经执行完毕（仔细想了想，其实用辅助 Promise 也没甚屌用，因为 `.then()` 是可以链式调用的如：`.then().then()`，我完全可以直接自己定义一个 `function`，比如：`(callbackLogical,callbackNotify)=>promise.then(()=>flag?执行callbackLogical:不执行callbackLogical).then(callbackNotify)`。只要调用了这个方法，那么不就都搞定了么。\n\n\n\n\n### AsyncStorage存储key管理小技巧   \n`AsyncStorage` 是一个简单的、异步的、持久化的 `Key-Value` 存储系统，它对于 App 来说是全局性的。它用来代替 `LocalStorage`。\n\n推荐使用封装好的第三方库[react-native-storage](https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md) 具体使用方式就不细说了。\n\n\n\n### 全局变量\n正如 web 中的 `window`，在 RN 中也有一个全局根属性可以挂载各种全局变量：`global`。比如上面推荐的 `react-native-storage` 用到的 `storage`,使用 `global.storage = storage` 就可以在各个地方拿到 `storage` 对象。\n\n但是要注意一点，一定要注意执行顺序，也就是必须要在使用 `global.storage` 前，将 `storage` 赋给 `global.storage`，所以要将这个赋值放到必须执行的文件中。\n\n### 优化切换动画卡顿的问题\n\n使用API `InteractionManager`，它的作用就是可以使本来 JS 的一些操作在动画完成之后执行，这样就可确保动画的流程性。当然这是在延迟执行为代价上来获得帧数的提高。\n```javascript\n\tInteractionManager.runAfterInteractions(()=>{\n\t\t//...耗时较长的同步任务...\n\t\t//更新state也需要时间\n\t\tthis.setState({\n\t\t\t...\n\t\t})\n\t\t//获取某些数据，需要长时间等待\n\t\tthis.fetchData(arguements)\n\t})\n```\n\n### React-Native 原生模块调用(iOS)\n在项目中遇到地图,拨打电话,清除缓存等iOS与Andiorid机制不同的功能,就需要调用原生的界面或模块。\n\n#### 创建原生模块，实现“RCTBridgeModule”协议\n```\n#import <UIKit/UIKit.h>\n#import \"RCTBridgeModule.h\"\n\n@interface LoginViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n#### 导出模块，导出方法\n不仅可以让导出 native 的方法，而且还可以在 js 中添加回调函数，供 native 调用，这样 native 就可以将前面的数据回塞给 js 了。\n```\n@implementation LoginViewController\n//导出模块\nRCT_EXPORT_MODULE()\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\nRCT_EXPORT_METHOD(showSVProgressHUDErrorWithStatus:(NSString *)state callBack:(RCTResponseSenderBlock)callback){\n  NSLog(@\"state is %@\",state);\n  NSArray *events = [[NSArray alloc] initWithObjects:@\"hello\", nil];\n  // 这里callback必须是数组\n  callback(events);\n  [SVProgressHUD showErrorWithStatus:state];\n}\n\n@end\n\n```\n\n#### js文件中调用\n```\n//创建原生模块实例\nlet LoginViewController = NativeModules.LoginViewController;\n\n//方法调用\nLoginViewController.showSVProgressHUDErrorWithStatus('请输入正确的手机号',(callbackString) => {console.log(callbackString);});     \n```\n\n\n\n\n\n### React Native 真机调试 \n开发中真机调试是必不可少的,有些功能和问题模拟器是无法重现的,所以就需要配合真机测试\n\n#### iOS 真机调试\n首先，**必须** 保证调试用电脑的和你的设备处于相同的 `WiFi` 网络环境中下。然后修改`AppDelegate.m` 文件，设置 `jsLocation` 为本地 ip 即可。\n\n```objc\nNSURL *jsCodeLocation;\n[RCTBundleURLProvider sharedSettings].jsLocation = @\"192.168.31.142\";\njsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index.ios\" fallbackResource:nil];\n\nRCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                      moduleName:@\"AwesomeProject\"\n                                               initialProperties:nil\n                                                   launchOptions:launchOptions];\n```\n\n### React Native import 文件的小技巧\n开发中经常需要 import 其他 js 文件，如果需要同时导入一些相关的 js 文件时，可以创建一个索引文件方便引用。  \n\n#### 第一步：创建index.js   \n在 `index.js` 中 import 相关的 js 文件\n\n```\n'use strict';\n\nimport Request from './network/RequestManager';\nimport AppContext from './network/AppContext';\nimport ApiServiceFactory from './network/ApiServiceFactory';\n\nmodule.exports = {\n    ApiServiceFactory,\n    Request,\n    AppContext\n};\n```\n\n#### 第二步：使用   \n如果需要使用这些类，只需要导入 `index` 文件就可以了~\n\n```\nimport {Request, ApiServiceFactory, AppContext} from '../expand/index';\n```\n\n\n### React Native 读取本地的json文件  \n可以以导入的形式，来读取本地的json文件，导入的文件可以作为一个js对象使用，这样方便调试的时候加载数据。\n\n#### 导入json文件：   \n```javascript\nvar langsData = require('./json/langs.json');\n```\n\n现在你可以操作`langsData`对象了。  \n\n#### json格式\n\n```json\n[\n  {\n    \"path\":\"\",\n    \"name\":\"123\",\n    \"checked\":false\n  },\n  {\n    \"path\":\"aa\",\n    \"name\":\"1234\",\n    \"checked\":false\n  },\n  {\n    \"path\":\"ddd\",\n    \"name\":\"123123123\",\n    \"checked\":true\n  }\n]\n```\n\n#### 使用\n```javascript\nfor (var i=0,l=langsData.length;i<l;i++){\n\tconsole.log(langsData[i]);\n}\n```\n\n\n","slug":"RN使用技巧","published":1,"updated":"2016-12-26T08:50:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpc000y7hzgy5a2ryt3","content":"<p>本文将收集关于 React-Native 的各种技巧与坑，不论是摘录的还是自己遇到的。</p>\n<a id=\"more\"></a>\n<h3 id=\"上拉加载\"><a href=\"#上拉加载\" class=\"headerlink\" title=\"上拉加载\"></a>上拉加载</h3><p>RN 中的 ListView 自带了上拉加载的方法：<code>onEndReached</code>。使用方法很简单，当下拉到一定阈值 <code>onEndReachedThreshold</code> 时，自动回调 <code>onEndReached</code> 传入的方法，如果加载的数据不满足一屏，也会自动回调：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ListView dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;<span class=\"keyword\">this</span>._cellForRow.bind(<span class=\"keyword\">this</span>)&#125;</div><div class=\"line\">          onEndReached=&#123;<span class=\"keyword\">this</span>._pullUpToRefresh.bind(<span class=\"keyword\">this</span>)&#125;</div><div class=\"line\">          enableEmptySections = &#123;<span class=\"literal\">true</span>&#125;</div><div class=\"line\">          onEndReachedThreshold=&#123;<span class=\"number\">100</span>&#125; &gt;</div><div class=\"line\">&lt;/ListView&gt;</div></pre></td></tr></table></figure>\n<p>相应的网络请求方法和上拉加载方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//默认加载数据</span></div><div class=\"line\">componentDidMount() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._getRemoteData();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 上拉加载更多方法</span></div><div class=\"line\">_pullUpToRefresh() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._canPull) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>._pageNo++;</div><div class=\"line\">        <span class=\"keyword\">this</span>._getRemoteData();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取数据</span></div><div class=\"line\">_getRemoteData()&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._canPull = <span class=\"literal\">false</span>;</div><div class=\"line\">    TravelTogether.getTravelTogetherList(<span class=\"keyword\">this</span>._pageNo,<span class=\"keyword\">this</span>._pageSize,(data) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;data.list.length;i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._dataSources.push(data.list[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;dataSource:<span class=\"keyword\">this</span>.state.dataSource.cloneWithRows(<span class=\"keyword\">this</span>._dataSources)&#125;);</div><div class=\"line\">        <span class=\"keyword\">if</span> (data.list.length === <span class=\"keyword\">this</span>._pageSize)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._canPull = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候是与一些坑的。首先，<code>onEndReached</code> 方法在第一次加载数据的时候必定会回调，这是 RN 的一个 bug。必须要自行设置一个 <code>_canPull</code> 的 flag 来控制是否要从服务器获取数据。其次，要注意 <code>onEndReached</code> 的调用时机。它的准确调用时机是在网络请求返回执行回调，设置状态 <code>this.setState()</code> 的时候。因此，你不能在 <code>setState()</code> 前将 <code>_canPull</code> 设置为 <code>true</code>，必须如上面一样，放在 <code>setState()</code> 之后。</p>\n<h3 id=\"关于Prop\"><a href=\"#关于Prop\" class=\"headerlink\" title=\"关于Prop\"></a>关于Prop</h3><h4 id=\"propTypes\"><a href=\"#propTypes\" class=\"headerlink\" title=\"propTypes\"></a>propTypes</h4><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 <code>PropTypes</code> 属性，就是用来验证组件实例的属性是否符合要求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Greeting.propTypes = &#123;</div><div class=\"line\">  name: React.PropTypes.string</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面例子中，如果 <code>name</code> 不是 string 类型，那么就会产生一个警告。还可以设置 <code>name: React.PropTypes.string.isRequired</code> 表示必须传入属性 <code>name</code>。</p>\n<p>除了 string 外，还有许多类型的 PropTypes 可以设置。<a href=\"https://facebook.github.io/react/docs/typechecking-with-proptypes.html\" target=\"_blank\" rel=\"external\">参见</a> 再举一个设置单一子节点的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// This must be exactly one element or it will warn.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> children = <span class=\"keyword\">this</span>.props.children;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &#123;children&#125;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.propTypes = &#123;</div><div class=\"line\">  children: React.PropTypes.element.isRequired</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"defaultProps\"><a href=\"#defaultProps\" class=\"headerlink\" title=\"defaultProps\"></a>defaultProps</h4><p>可以在 <code>defaultProps</code> 中注册设置默认属性值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends React.Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Greeting.defaultProps = &#123;</div><div class=\"line\">  name: &apos;hahaha&apos;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>结合上面这两个属性，就不必再在构造函数里设置各种值了。</p>\n<h3 id=\"this-props-children\"><a href=\"#this-props-children\" class=\"headerlink\" title=\"this.props.children\"></a>this.props.children</h3><p><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。类似于 <code>TouchableOpaque</code> 里嵌入 <code>Text</code>，通过这种方式可以很方便的嵌套封装控件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</div><div class=\"line\">\trender()&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>(</div><div class=\"line\">\t\t\t&#123;<span class=\"keyword\">this</span>.props.children&#125;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//调用：</span></div><div class=\"line\">&lt;NewComponent&gt;</div><div class=\"line\">\t&lt;Text&gt;haha&lt;/Text&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/NewComponent&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"关于-import，require，export，module-exports的区别\"><a href=\"#关于-import，require，export，module-exports的区别\" class=\"headerlink\" title=\"关于 import，require，export，module.exports的区别\"></a>关于 import，require，export，module.exports的区别</h3><p>ES6标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，使用 require 引入模块，使用 module.exports 导出接口。那么在混用的情况下到底有什么异同呢？</p>\n<h4 id=\"export-module-exports\"><a href=\"#export-module-exports\" class=\"headerlink\" title=\"export,module.exports\"></a>export,module.exports</h4><p>首先要明确一点，现今的所有 class 都会被编译器转化为同名的 function，function 内部通过 babel 提供的方法实现 class 内的各个属性和方法。</p>\n<ul>\n<li><code>export xx</code>导出的都是 {} 括起来的对象。如果是对象，那么自动变为 <code>{target名:target}</code> 的形式；如果后面跟的是 function，那么会自动变为：<code>{function名:function}</code> 的形式。因此一般不能 export 匿名对象和方法。有一个特殊用法 <code>export default 对象/方法</code> 相当于导出了一个别名为 default 的对象/方法 <code>{default:对象/方法}</code> 一个文件内，可以使用多次 export，但只能将一个对象/方法设置为 default。</li>\n<li><code>module.exports = xx</code> 较为直接，赋值的是什么，导出的就是什么。</li>\n</ul>\n<h4 id=\"import-require\"><a href=\"#import-require\" class=\"headerlink\" title=\"import,require\"></a>import,require</h4><ul>\n<li>import 一般和 export 一起使用，是一种解构的方式。如：<code>import a {b,c} from &#39;./xx&#39;</code>，等价于 <code>import {default as a,b,c} from &#39;./xx&#39;</code>。相当于将 default 导出，并给 default取了个别名 a。</li>\n<li>require 一般和 module.exports 一起使用，直接将 module.exports 导出的对象赋给接收对象。如：<code>var a = require(&#39;./xx&#39;)</code>。<h4 id=\"混用\"><a href=\"#混用\" class=\"headerlink\" title=\"混用\"></a>混用</h4></li>\n<li>如果 import 和 <code>module.exports = xx</code> 一起使用，则直接 import。如:<code>import xx from &#39;./xx&#39;</code>。</li>\n<li>如果 require 和 export 一起使用则相当于将 export 生成的导出对象付给接收对象。如：<code>export default funcA</code>,导入方式一样，<code>var a = require(&#39;./xx&#39;);</code> 但要这样使用 <code>a.default();</code></li>\n</ul>\n<p>综上，两种export的方式，对于import都一样，但是对于 require有所不同。<a href=\"http://www.tuicool.com/articles/uuUVBv2\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<h3 id=\"关于编译时-RCTHTTPRequestHandler-m-不存在的问题\"><a href=\"#关于编译时-RCTHTTPRequestHandler-m-不存在的问题\" class=\"headerlink\" title=\"关于编译时 RCTHTTPRequestHandler.m 不存在的问题\"></a>关于编译时 RCTHTTPRequestHandler.m 不存在的问题</h3><p>升级了一下 React-Native 的版本后（3.2=&gt;3.8），Xcode 编译的时候出现了 <code>RCTHTTPRequestHandler.m not found</code> 的编译错误。原因应该是 <code>RCTHTTPRequestHandler.m</code> 在后面的版本变为了 <code>RCTHTTPRequestHandler.mm</code>。</p>\n<p>解决方法很简单，在 React-Native 版本升级，即使用 <code>npm update</code> 后，需要重新 <code>pod install</code> 一遍。因为 React 作为 pod 中的一项，Xcode 是通过 <code>pod install</code> 后生成的索引来定位 React 中的各个文件的。只 <code>npm update</code> 而不 <code>pod install</code>，Xcode 编译的时候通过 3.2 的文件索引，去 3.8 里找文件，就很有可能因为版本变化导致找不到文件。 </p>\n<h3 id=\"TextInput-隐藏键盘\"><a href=\"#TextInput-隐藏键盘\" class=\"headerlink\" title=\"TextInput 隐藏键盘\"></a>TextInput 隐藏键盘</h3><p>Native 中的 <code>UITextField</code> 可以通过 <code>resignFirstResponder</code> 或者 <code>endEditing</code> 的方式取消第一响应者，从而隐藏虚拟键盘。那么，react 中如何做到隐藏键盘呢？</p>\n<p>可以使用 <code>ScrollView</code> 包装我们的 <code>View</code>。<br><code>ScrollView</code> 可以设置 <code>keyboardDismissMode</code>，<code>keyboardShouldPersistTaps</code> 来控制输入法的行为。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView \tcontentContainerStyle=&#123;&#123;flex:<span class=\"number\">1</span>&#125;<span class=\"comment\">//非常重要，让ScrollView的子元素占满整个区域</span></div><div class=\"line\">\t\t\t\tkeyboardDismissMode=<span class=\"string\">'on-drag'</span> <span class=\"comment\">//拖动界面输入法退出</span></div><div class=\"line\">\t\t\t\tkeyboardShouldPersistTaps=&#123;<span class=\"literal\">false</span>&#125; <span class=\"comment\">//点击输入法意外的区域，输入法退出</span></div><div class=\"line\">\t\t\t\t&gt;</div><div class=\"line\">....</div><div class=\"line\">&lt;<span class=\"regexp\">/ScrollView&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"生命周期回调函数总结\"><a href=\"#生命周期回调函数总结\" class=\"headerlink\" title=\"生命周期回调函数总结\"></a>生命周期回调函数总结</h3><h4 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h4><p><code>componentWillMount</code> 会在组件 <code>render</code> 之前执行，并且永远都只执行一次。</p>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h4><p><code>componentDidMount</code> 会在组件加载完毕之后立即执行。</p>\n<h4 id=\"componentWillReceiveProps-object-nextProps\"><a href=\"#componentWillReceiveProps-object-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps(object nextProps)\"></a>componentWillReceiveProps(object nextProps)</h4><p>在组件接收到一个新的 prop 时被执行。这个方法在初始化 <code>render</code> 时不会被调用。</p>\n<h4 id=\"boolean-shouldComponentUpdate-object-nextProps-object-nextState\"><a href=\"#boolean-shouldComponentUpdate-object-nextProps-object-nextState\" class=\"headerlink\" title=\"boolean shouldComponentUpdate(object nextProps, object nextState)\"></a>boolean shouldComponentUpdate(object nextProps, object nextState)</h4><p>返回一个布尔值。在组件的 props 或者 state 改变时被执行。在初始化时或者使用  <code>forceUpdate</code> 时不被执行。</p>\n<p>如果 <code>shouldComponentUpdate</code> 返回 <code>false</code>,<code>render()</code> 则会在下一个 state change 之前被完全跳过。(另外 <code>componentWillUpdate</code> 和  <code>componentDidUpdate</code> 也不会被执行)默认情况下 <code>shouldComponentUpdate</code> 会返回 <code>true</code>.</p>\n<h4 id=\"componentWillUpdate-object-nextProps-object-nextState\"><a href=\"#componentWillUpdate-object-nextProps-object-nextState\" class=\"headerlink\" title=\"componentWillUpdate(object nextProps, object nextState)\"></a>componentWillUpdate(object nextProps, object nextState)</h4><p>组件接收到新的 <code>props</code> 或者 <code>state</code> 但还没有 <code>render</code> 时被执行。在初始化时不会被执行。一般用在组件发生更新之前。</p>\n<h4 id=\"componentDidUpdate-object-prevProps-object-prevState\"><a href=\"#componentDidUpdate-object-prevProps-object-prevState\" class=\"headerlink\" title=\"componentDidUpdate(object prevProps, object prevState)\"></a>componentDidUpdate(object prevProps, object prevState)</h4><p>在组件完成更新后立即执行。在初始化时不会被执行。一般会在组件完成更新后被使用。例如清除 notification 文字等操作。</p>\n<h4 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount()\"></a>componentWillUnmount()</h4><p>主要用来执行一些必要的清理任务。<strong>注意，<code>Unmount</code> 的大小写。</strong></p>\n<h3 id=\"如何判断对象是否有某个属性\"><a href=\"#如何判断对象是否有某个属性\" class=\"headerlink\" title=\"如何判断对象是否有某个属性\"></a>如何判断对象是否有某个属性</h3><ul>\n<li><p>使用in关键字 该方法可以判断对象的自有属性和继承来的属性是否存在。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">&quot;x&quot; in o; //true，自有属性存在</div><div class=\"line\">&quot;y&quot; in o; //false</div><div class=\"line\">&quot;toString&quot; in o; //true，是一个继承属性</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>使用对象的hasOwnProperty()方法 该方法只能判断自有属性是否存在，对于继承属性会返回false。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">o.hasOwnProperty(&quot;x&quot;); 　　 //true，自有属性中有x</div><div class=\"line\">o.hasOwnProperty(&quot;y&quot;); 　　 //false，自有属性中不存在y</div><div class=\"line\">o.hasOwnProperty(&quot;toString&quot;); //false，这是一个继承属性，但不是自有属性</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>用undefined判断 自有属性和继承属性均可判断。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">o.x!==undefined; //true</div><div class=\"line\">o.y!==undefined; //false</div><div class=\"line\">o.toString!==undefined //true</div></pre></td></tr></table></figure>\n</li>\n<li><p>在条件语句中直接判断</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;&#125;;</div><div class=\"line\">if(o.x) o.x+=1; //如果x是undefine,null,false,&quot; &quot;,0或NaN,它将保持不变</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"可取消的Promise\"><a href=\"#可取消的Promise\" class=\"headerlink\" title=\"可取消的Promise\"></a>可取消的Promise</h3><p><code>Promise</code>是 React Native 开发过程中用于异步操作的最常用的 API，但 Promise 没有提供用于取消异步操作的方法。为了实现可取消的异步操作，我们可以为 Promise 包裹一层可取消的外衣。    </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> makeCancelable = (promise) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hasCanceled_ = <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">const</span> wrappedPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((resolve, reject) =&gt; &#123;</div><div class=\"line\">    promise.then((val) =&gt;</div><div class=\"line\">      hasCanceled_ ? reject(&#123;isCanceled: <span class=\"literal\">true</span>&#125;) : resolve(val)</div><div class=\"line\">    );</div><div class=\"line\">    promise.catch((error) =&gt;</div><div class=\"line\">      hasCanceled_ ? reject(&#123;isCanceled: <span class=\"literal\">true</span>&#125;) : reject(error)</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    promise: wrappedPromise,</div><div class=\"line\">    cancel() &#123;</div><div class=\"line\">      hasCanceled_ = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后可以这样使用取消操作：   </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> somePromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(r =&gt; setTimeout(r, <span class=\"number\">1000</span>));<span class=\"comment\">//创建一个异步操作</span></div><div class=\"line\"><span class=\"keyword\">const</span> cancelable = makeCancelable(somePromise);<span class=\"comment\">//为异步操作添加可取消的功能</span></div><div class=\"line\">cancelable</div><div class=\"line\">  .promise</div><div class=\"line\">  .then(() =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>))</div><div class=\"line\">  .catch((&#123;isCanceled, ...error&#125;) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'isCanceled'</span>, isCanceled));</div><div class=\"line\"><span class=\"comment\">// 取消异步操作</span></div><div class=\"line\">cancelable.cancel();</div></pre></td></tr></table></figure>\n<p>Promise后面括号内跟的是要异步执行的操作，<code>.then()</code>里跟的是异步操作执行完后的回调函数。取消 Promise 换句话说也就是取消 <code>.then()</code> 里的回到函数的执行。</p>\n<p>这里通过创建一个辅助的 Promise 来包裹要执行的 Promise，这个设计非常的巧妙。</p>\n<p>首先，如何实现取消 <code>.then()</code> 里的毁掉函数的执行？那么就不能用 <code>.then(callback)</code> 的形式了，而要有一个标识位判断：<code>.then(()=&gt;flag?执行:不执行)</code>。</p>\n<p>那么 <code>flag</code> 定义在哪？肯定不能直接作为一个变量定义在执行 Promise 的类里，因为这个类可能有多个 Promise 任务要处理，创建多个 <code>flag</code> 显然不是一个好的选择。那么就可以新建一个 <code>class</code>，这个 <code>class</code> 里包含 <code>flag</code> 以及这个 Promise，这就需要每次创建 Promise 的时候都 <code>new</code> 一个对象出来。这个方式可行，但是不够优雅。由于 Js 是弱类型的，我们没有必要专门定义一个 <code>class</code>，反正都是 <code>var</code>。因此，就应该像上面那样通过一个方法，直接 <code>return</code> 一个 <code>{}</code> 包裹起来的对象。因为 <code>return</code> 的这个对象用到了 <code>hasCanceled</code> 这个参数，由于有闭包性，在 <code>return</code> 的这个对象被销毁前 <code>hasCanceled</code> 都是可触及的。</p>\n<p>最后，为什么要用一个辅助的 Promise 去包裹？ 其实用一个类或者一个方法也是能达到同样的效果。这样的设计也很巧妙。将要执行的 Promise 的 <code>.then()</code> 作为 辅助的 Promise 的异步执行操作，达到的目的是在 <code>.then()</code> 完成后，辅助的 Promise 的异步操作才可能结束。当辅助的 Promise 的异步操作结束后，就可以调用其自己的 <code>.then()</code> 来通知要执行的 Promise 已经执行完毕（仔细想了想，其实用辅助 Promise 也没甚屌用，因为 <code>.then()</code> 是可以链式调用的如：<code>.then().then()</code>，我完全可以直接自己定义一个 <code>function</code>，比如：<code>(callbackLogical,callbackNotify)=&gt;promise.then(()=&gt;flag?执行callbackLogical:不执行callbackLogical).then(callbackNotify)</code>。只要调用了这个方法，那么不就都搞定了么。</p>\n<h3 id=\"AsyncStorage存储key管理小技巧\"><a href=\"#AsyncStorage存储key管理小技巧\" class=\"headerlink\" title=\"AsyncStorage存储key管理小技巧\"></a>AsyncStorage存储key管理小技巧</h3><p><code>AsyncStorage</code> 是一个简单的、异步的、持久化的 <code>Key-Value</code> 存储系统，它对于 App 来说是全局性的。它用来代替 <code>LocalStorage</code>。</p>\n<p>推荐使用封装好的第三方库<a href=\"https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md\" target=\"_blank\" rel=\"external\">react-native-storage</a> 具体使用方式就不细说了。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>正如 web 中的 <code>window</code>，在 RN 中也有一个全局根属性可以挂载各种全局变量：<code>global</code>。比如上面推荐的 <code>react-native-storage</code> 用到的 <code>storage</code>,使用 <code>global.storage = storage</code> 就可以在各个地方拿到 <code>storage</code> 对象。</p>\n<p>但是要注意一点，一定要注意执行顺序，也就是必须要在使用 <code>global.storage</code> 前，将 <code>storage</code> 赋给 <code>global.storage</code>，所以要将这个赋值放到必须执行的文件中。</p>\n<h3 id=\"优化切换动画卡顿的问题\"><a href=\"#优化切换动画卡顿的问题\" class=\"headerlink\" title=\"优化切换动画卡顿的问题\"></a>优化切换动画卡顿的问题</h3><p>使用API <code>InteractionManager</code>，它的作用就是可以使本来 JS 的一些操作在动画完成之后执行，这样就可确保动画的流程性。当然这是在延迟执行为代价上来获得帧数的提高。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">InteractionManager.runAfterInteractions(()=&gt;&#123;</div><div class=\"line\">\t<span class=\"comment\">//...耗时较长的同步任务...</span></div><div class=\"line\">\t<span class=\"comment\">//更新state也需要时间</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t<span class=\"comment\">//获取某些数据，需要长时间等待</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.fetchData(arguements)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"React-Native-原生模块调用-iOS\"><a href=\"#React-Native-原生模块调用-iOS\" class=\"headerlink\" title=\"React-Native 原生模块调用(iOS)\"></a>React-Native 原生模块调用(iOS)</h3><p>在项目中遇到地图,拨打电话,清除缓存等iOS与Andiorid机制不同的功能,就需要调用原生的界面或模块。</p>\n<h4 id=\"创建原生模块，实现“RCTBridgeModule”协议\"><a href=\"#创建原生模块，实现“RCTBridgeModule”协议\" class=\"headerlink\" title=\"创建原生模块，实现“RCTBridgeModule”协议\"></a>创建原生模块，实现“RCTBridgeModule”协议</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\">#import &quot;RCTBridgeModule.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface LoginViewController : UIViewController&lt;RCTBridgeModule&gt;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"导出模块，导出方法\"><a href=\"#导出模块，导出方法\" class=\"headerlink\" title=\"导出模块，导出方法\"></a>导出模块，导出方法</h4><p>不仅可以让导出 native 的方法，而且还可以在 js 中添加回调函数，供 native 调用，这样 native 就可以将前面的数据回塞给 js 了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation LoginViewController</div><div class=\"line\">//导出模块</div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_METHOD(showSVProgressHUDErrorWithStatus:(NSString *)state callBack:(RCTResponseSenderBlock)callback)&#123;</div><div class=\"line\">  NSLog(@&quot;state is %@&quot;,state);</div><div class=\"line\">  NSArray *events = [[NSArray alloc] initWithObjects:@&quot;hello&quot;, nil];</div><div class=\"line\">  // 这里callback必须是数组</div><div class=\"line\">  callback(events);</div><div class=\"line\">  [SVProgressHUD showErrorWithStatus:state];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"js文件中调用\"><a href=\"#js文件中调用\" class=\"headerlink\" title=\"js文件中调用\"></a>js文件中调用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建原生模块实例</div><div class=\"line\">let LoginViewController = NativeModules.LoginViewController;</div><div class=\"line\"></div><div class=\"line\">//方法调用</div><div class=\"line\">LoginViewController.showSVProgressHUDErrorWithStatus(&apos;请输入正确的手机号&apos;,(callbackString) =&gt; &#123;console.log(callbackString);&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-真机调试\"><a href=\"#React-Native-真机调试\" class=\"headerlink\" title=\"React Native 真机调试\"></a>React Native 真机调试</h3><p>开发中真机调试是必不可少的,有些功能和问题模拟器是无法重现的,所以就需要配合真机测试</p>\n<h4 id=\"iOS-真机调试\"><a href=\"#iOS-真机调试\" class=\"headerlink\" title=\"iOS 真机调试\"></a>iOS 真机调试</h4><p>首先，<strong>必须</strong> 保证调试用电脑的和你的设备处于相同的 <code>WiFi</code> 网络环境中下。然后修改<code>AppDelegate.m</code> 文件，设置 <code>jsLocation</code> 为本地 ip 即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSURL</span> *jsCodeLocation;</div><div class=\"line\">[RCTBundleURLProvider sharedSettings].jsLocation = <span class=\"string\">@\"192.168.31.142\"</span>;</div><div class=\"line\">jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:<span class=\"string\">@\"index.ios\"</span> fallbackResource:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class=\"line\">                                                      moduleName:<span class=\"string\">@\"AwesomeProject\"</span></div><div class=\"line\">                                               initialProperties:<span class=\"literal\">nil</span></div><div class=\"line\">                                                   launchOptions:launchOptions];</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-import-文件的小技巧\"><a href=\"#React-Native-import-文件的小技巧\" class=\"headerlink\" title=\"React Native import 文件的小技巧\"></a>React Native import 文件的小技巧</h3><p>开发中经常需要 import 其他 js 文件，如果需要同时导入一些相关的 js 文件时，可以创建一个索引文件方便引用。  </p>\n<h4 id=\"第一步：创建index-js\"><a href=\"#第一步：创建index-js\" class=\"headerlink\" title=\"第一步：创建index.js\"></a>第一步：创建index.js</h4><p>在 <code>index.js</code> 中 import 相关的 js 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">import Request from &apos;./network/RequestManager&apos;;</div><div class=\"line\">import AppContext from &apos;./network/AppContext&apos;;</div><div class=\"line\">import ApiServiceFactory from &apos;./network/ApiServiceFactory&apos;;</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    ApiServiceFactory,</div><div class=\"line\">    Request,</div><div class=\"line\">    AppContext</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用\"><a href=\"#第二步：使用\" class=\"headerlink\" title=\"第二步：使用\"></a>第二步：使用</h4><p>如果需要使用这些类，只需要导入 <code>index</code> 文件就可以了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123;Request, ApiServiceFactory, AppContext&#125; from &apos;../expand/index&apos;;</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-读取本地的json文件\"><a href=\"#React-Native-读取本地的json文件\" class=\"headerlink\" title=\"React Native 读取本地的json文件\"></a>React Native 读取本地的json文件</h3><p>可以以导入的形式，来读取本地的json文件，导入的文件可以作为一个js对象使用，这样方便调试的时候加载数据。</p>\n<h4 id=\"导入json文件：\"><a href=\"#导入json文件：\" class=\"headerlink\" title=\"导入json文件：\"></a>导入json文件：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> langsData = <span class=\"built_in\">require</span>(<span class=\"string\">'./json/langs.json'</span>);</div></pre></td></tr></table></figure>\n<p>现在你可以操作<code>langsData</code>对象了。  </p>\n<h4 id=\"json格式\"><a href=\"#json格式\" class=\"headerlink\" title=\"json格式\"></a>json格式</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"123\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"aa\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"1234\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"ddd\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"123123123\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,l=langsData.length;i&lt;l;i++)&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(langsData[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>本文将收集关于 React-Native 的各种技巧与坑，不论是摘录的还是自己遇到的。</p>","more":"<h3 id=\"上拉加载\"><a href=\"#上拉加载\" class=\"headerlink\" title=\"上拉加载\"></a>上拉加载</h3><p>RN 中的 ListView 自带了上拉加载的方法：<code>onEndReached</code>。使用方法很简单，当下拉到一定阈值 <code>onEndReachedThreshold</code> 时，自动回调 <code>onEndReached</code> 传入的方法，如果加载的数据不满足一屏，也会自动回调：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ListView dataSource=&#123;<span class=\"keyword\">this</span>.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;<span class=\"keyword\">this</span>._cellForRow.bind(<span class=\"keyword\">this</span>)&#125;</div><div class=\"line\">          onEndReached=&#123;<span class=\"keyword\">this</span>._pullUpToRefresh.bind(<span class=\"keyword\">this</span>)&#125;</div><div class=\"line\">          enableEmptySections = &#123;<span class=\"literal\">true</span>&#125;</div><div class=\"line\">          onEndReachedThreshold=&#123;<span class=\"number\">100</span>&#125; &gt;</div><div class=\"line\">&lt;/ListView&gt;</div></pre></td></tr></table></figure>\n<p>相应的网络请求方法和上拉加载方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//默认加载数据</span></div><div class=\"line\">componentDidMount() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._getRemoteData();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 上拉加载更多方法</span></div><div class=\"line\">_pullUpToRefresh() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._canPull) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>._pageNo++;</div><div class=\"line\">        <span class=\"keyword\">this</span>._getRemoteData();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取数据</span></div><div class=\"line\">_getRemoteData()&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._canPull = <span class=\"literal\">false</span>;</div><div class=\"line\">    TravelTogether.getTravelTogetherList(<span class=\"keyword\">this</span>._pageNo,<span class=\"keyword\">this</span>._pageSize,(data) =&gt; &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;data.list.length;i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._dataSources.push(data.list[i]);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;dataSource:<span class=\"keyword\">this</span>.state.dataSource.cloneWithRows(<span class=\"keyword\">this</span>._dataSources)&#125;);</div><div class=\"line\">        <span class=\"keyword\">if</span> (data.list.length === <span class=\"keyword\">this</span>._pageSize)&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._canPull = <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候是与一些坑的。首先，<code>onEndReached</code> 方法在第一次加载数据的时候必定会回调，这是 RN 的一个 bug。必须要自行设置一个 <code>_canPull</code> 的 flag 来控制是否要从服务器获取数据。其次，要注意 <code>onEndReached</code> 的调用时机。它的准确调用时机是在网络请求返回执行回调，设置状态 <code>this.setState()</code> 的时候。因此，你不能在 <code>setState()</code> 前将 <code>_canPull</code> 设置为 <code>true</code>，必须如上面一样，放在 <code>setState()</code> 之后。</p>\n<h3 id=\"关于Prop\"><a href=\"#关于Prop\" class=\"headerlink\" title=\"关于Prop\"></a>关于Prop</h3><h4 id=\"propTypes\"><a href=\"#propTypes\" class=\"headerlink\" title=\"propTypes\"></a>propTypes</h4><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 <code>PropTypes</code> 属性，就是用来验证组件实例的属性是否符合要求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Greeting.propTypes = &#123;</div><div class=\"line\">  name: React.PropTypes.string</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面例子中，如果 <code>name</code> 不是 string 类型，那么就会产生一个警告。还可以设置 <code>name: React.PropTypes.string.isRequired</code> 表示必须传入属性 <code>name</code>。</p>\n<p>除了 string 外，还有许多类型的 PropTypes 可以设置。<a href=\"https://facebook.github.io/react/docs/typechecking-with-proptypes.html\">参见</a> 再举一个设置单一子节点的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// This must be exactly one element or it will warn.</span></div><div class=\"line\">    <span class=\"keyword\">const</span> children = <span class=\"keyword\">this</span>.props.children;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">        &#123;children&#125;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MyComponent.propTypes = &#123;</div><div class=\"line\">  children: React.PropTypes.element.isRequired</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"defaultProps\"><a href=\"#defaultProps\" class=\"headerlink\" title=\"defaultProps\"></a>defaultProps</h4><p>可以在 <code>defaultProps</code> 中注册设置默认属性值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends React.Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Greeting.defaultProps = &#123;</div><div class=\"line\">  name: &apos;hahaha&apos;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>结合上面这两个属性，就不必再在构造函数里设置各种值了。</p>\n<h3 id=\"this-props-children\"><a href=\"#this-props-children\" class=\"headerlink\" title=\"this.props.children\"></a>this.props.children</h3><p><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。类似于 <code>TouchableOpaque</code> 里嵌入 <code>Text</code>，通过这种方式可以很方便的嵌套封装控件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</div><div class=\"line\">\trender()&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>(</div><div class=\"line\">\t\t\t&#123;<span class=\"keyword\">this</span>.props.children&#125;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//调用：</span></div><div class=\"line\">&lt;NewComponent&gt;</div><div class=\"line\">\t&lt;Text&gt;haha&lt;/Text&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/NewComponent&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"关于-import，require，export，module-exports的区别\"><a href=\"#关于-import，require，export，module-exports的区别\" class=\"headerlink\" title=\"关于 import，require，export，module.exports的区别\"></a>关于 import，require，export，module.exports的区别</h3><p>ES6标准发布后，module 成为标准，标准的使用是以 export 指令导出接口，以 import 引入模块，但是在我们一贯的 node 模块中，使用 require 引入模块，使用 module.exports 导出接口。那么在混用的情况下到底有什么异同呢？</p>\n<h4 id=\"export-module-exports\"><a href=\"#export-module-exports\" class=\"headerlink\" title=\"export,module.exports\"></a>export,module.exports</h4><p>首先要明确一点，现今的所有 class 都会被编译器转化为同名的 function，function 内部通过 babel 提供的方法实现 class 内的各个属性和方法。</p>\n<ul>\n<li><code>export xx</code>导出的都是 {} 括起来的对象。如果是对象，那么自动变为 <code>{target名:target}</code> 的形式；如果后面跟的是 function，那么会自动变为：<code>{function名:function}</code> 的形式。因此一般不能 export 匿名对象和方法。有一个特殊用法 <code>export default 对象/方法</code> 相当于导出了一个别名为 default 的对象/方法 <code>{default:对象/方法}</code> 一个文件内，可以使用多次 export，但只能将一个对象/方法设置为 default。</li>\n<li><code>module.exports = xx</code> 较为直接，赋值的是什么，导出的就是什么。</li>\n</ul>\n<h4 id=\"import-require\"><a href=\"#import-require\" class=\"headerlink\" title=\"import,require\"></a>import,require</h4><ul>\n<li>import 一般和 export 一起使用，是一种解构的方式。如：<code>import a {b,c} from &#39;./xx&#39;</code>，等价于 <code>import {default as a,b,c} from &#39;./xx&#39;</code>。相当于将 default 导出，并给 default取了个别名 a。</li>\n<li>require 一般和 module.exports 一起使用，直接将 module.exports 导出的对象赋给接收对象。如：<code>var a = require(&#39;./xx&#39;)</code>。<h4 id=\"混用\"><a href=\"#混用\" class=\"headerlink\" title=\"混用\"></a>混用</h4></li>\n<li>如果 import 和 <code>module.exports = xx</code> 一起使用，则直接 import。如:<code>import xx from &#39;./xx&#39;</code>。</li>\n<li>如果 require 和 export 一起使用则相当于将 export 生成的导出对象付给接收对象。如：<code>export default funcA</code>,导入方式一样，<code>var a = require(&#39;./xx&#39;);</code> 但要这样使用 <code>a.default();</code></li>\n</ul>\n<p>综上，两种export的方式，对于import都一样，但是对于 require有所不同。<a href=\"http://www.tuicool.com/articles/uuUVBv2\">参考链接</a></p>\n<h3 id=\"关于编译时-RCTHTTPRequestHandler-m-不存在的问题\"><a href=\"#关于编译时-RCTHTTPRequestHandler-m-不存在的问题\" class=\"headerlink\" title=\"关于编译时 RCTHTTPRequestHandler.m 不存在的问题\"></a>关于编译时 RCTHTTPRequestHandler.m 不存在的问题</h3><p>升级了一下 React-Native 的版本后（3.2=&gt;3.8），Xcode 编译的时候出现了 <code>RCTHTTPRequestHandler.m not found</code> 的编译错误。原因应该是 <code>RCTHTTPRequestHandler.m</code> 在后面的版本变为了 <code>RCTHTTPRequestHandler.mm</code>。</p>\n<p>解决方法很简单，在 React-Native 版本升级，即使用 <code>npm update</code> 后，需要重新 <code>pod install</code> 一遍。因为 React 作为 pod 中的一项，Xcode 是通过 <code>pod install</code> 后生成的索引来定位 React 中的各个文件的。只 <code>npm update</code> 而不 <code>pod install</code>，Xcode 编译的时候通过 3.2 的文件索引，去 3.8 里找文件，就很有可能因为版本变化导致找不到文件。 </p>\n<h3 id=\"TextInput-隐藏键盘\"><a href=\"#TextInput-隐藏键盘\" class=\"headerlink\" title=\"TextInput 隐藏键盘\"></a>TextInput 隐藏键盘</h3><p>Native 中的 <code>UITextField</code> 可以通过 <code>resignFirstResponder</code> 或者 <code>endEditing</code> 的方式取消第一响应者，从而隐藏虚拟键盘。那么，react 中如何做到隐藏键盘呢？</p>\n<p>可以使用 <code>ScrollView</code> 包装我们的 <code>View</code>。<br><code>ScrollView</code> 可以设置 <code>keyboardDismissMode</code>，<code>keyboardShouldPersistTaps</code> 来控制输入法的行为。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView \tcontentContainerStyle=&#123;&#123;flex:<span class=\"number\">1</span>&#125;<span class=\"comment\">//非常重要，让ScrollView的子元素占满整个区域</span></div><div class=\"line\">\t\t\t\tkeyboardDismissMode=<span class=\"string\">'on-drag'</span> <span class=\"comment\">//拖动界面输入法退出</span></div><div class=\"line\">\t\t\t\tkeyboardShouldPersistTaps=&#123;<span class=\"literal\">false</span>&#125; <span class=\"comment\">//点击输入法意外的区域，输入法退出</span></div><div class=\"line\">\t\t\t\t&gt;</div><div class=\"line\">....</div><div class=\"line\">&lt;<span class=\"regexp\">/ScrollView&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"生命周期回调函数总结\"><a href=\"#生命周期回调函数总结\" class=\"headerlink\" title=\"生命周期回调函数总结\"></a>生命周期回调函数总结</h3><h4 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h4><p><code>componentWillMount</code> 会在组件 <code>render</code> 之前执行，并且永远都只执行一次。</p>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h4><p><code>componentDidMount</code> 会在组件加载完毕之后立即执行。</p>\n<h4 id=\"componentWillReceiveProps-object-nextProps\"><a href=\"#componentWillReceiveProps-object-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps(object nextProps)\"></a>componentWillReceiveProps(object nextProps)</h4><p>在组件接收到一个新的 prop 时被执行。这个方法在初始化 <code>render</code> 时不会被调用。</p>\n<h4 id=\"boolean-shouldComponentUpdate-object-nextProps-object-nextState\"><a href=\"#boolean-shouldComponentUpdate-object-nextProps-object-nextState\" class=\"headerlink\" title=\"boolean shouldComponentUpdate(object nextProps, object nextState)\"></a>boolean shouldComponentUpdate(object nextProps, object nextState)</h4><p>返回一个布尔值。在组件的 props 或者 state 改变时被执行。在初始化时或者使用  <code>forceUpdate</code> 时不被执行。</p>\n<p>如果 <code>shouldComponentUpdate</code> 返回 <code>false</code>,<code>render()</code> 则会在下一个 state change 之前被完全跳过。(另外 <code>componentWillUpdate</code> 和  <code>componentDidUpdate</code> 也不会被执行)默认情况下 <code>shouldComponentUpdate</code> 会返回 <code>true</code>.</p>\n<h4 id=\"componentWillUpdate-object-nextProps-object-nextState\"><a href=\"#componentWillUpdate-object-nextProps-object-nextState\" class=\"headerlink\" title=\"componentWillUpdate(object nextProps, object nextState)\"></a>componentWillUpdate(object nextProps, object nextState)</h4><p>组件接收到新的 <code>props</code> 或者 <code>state</code> 但还没有 <code>render</code> 时被执行。在初始化时不会被执行。一般用在组件发生更新之前。</p>\n<h4 id=\"componentDidUpdate-object-prevProps-object-prevState\"><a href=\"#componentDidUpdate-object-prevProps-object-prevState\" class=\"headerlink\" title=\"componentDidUpdate(object prevProps, object prevState)\"></a>componentDidUpdate(object prevProps, object prevState)</h4><p>在组件完成更新后立即执行。在初始化时不会被执行。一般会在组件完成更新后被使用。例如清除 notification 文字等操作。</p>\n<h4 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount()\"></a>componentWillUnmount()</h4><p>主要用来执行一些必要的清理任务。<strong>注意，<code>Unmount</code> 的大小写。</strong></p>\n<h3 id=\"如何判断对象是否有某个属性\"><a href=\"#如何判断对象是否有某个属性\" class=\"headerlink\" title=\"如何判断对象是否有某个属性\"></a>如何判断对象是否有某个属性</h3><ul>\n<li><p>使用in关键字 该方法可以判断对象的自有属性和继承来的属性是否存在。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">&quot;x&quot; in o; //true，自有属性存在</div><div class=\"line\">&quot;y&quot; in o; //false</div><div class=\"line\">&quot;toString&quot; in o; //true，是一个继承属性</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>使用对象的hasOwnProperty()方法 该方法只能判断自有属性是否存在，对于继承属性会返回false。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">o.hasOwnProperty(&quot;x&quot;); 　　 //true，自有属性中有x</div><div class=\"line\">o.hasOwnProperty(&quot;y&quot;); 　　 //false，自有属性中不存在y</div><div class=\"line\">o.hasOwnProperty(&quot;toString&quot;); //false，这是一个继承属性，但不是自有属性</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>用undefined判断 自有属性和继承属性均可判断。</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;x:1&#125;;</div><div class=\"line\">o.x!==undefined; //true</div><div class=\"line\">o.y!==undefined; //false</div><div class=\"line\">o.toString!==undefined //true</div></pre></td></tr></table></figure>\n</li>\n<li><p>在条件语句中直接判断</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var o=&#123;&#125;;</div><div class=\"line\">if(o.x) o.x+=1; //如果x是undefine,null,false,&quot; &quot;,0或NaN,它将保持不变</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"可取消的Promise\"><a href=\"#可取消的Promise\" class=\"headerlink\" title=\"可取消的Promise\"></a>可取消的Promise</h3><p><code>Promise</code>是 React Native 开发过程中用于异步操作的最常用的 API，但 Promise 没有提供用于取消异步操作的方法。为了实现可取消的异步操作，我们可以为 Promise 包裹一层可取消的外衣。    </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> makeCancelable = (promise) =&gt; &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> hasCanceled_ = <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">const</span> wrappedPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((resolve, reject) =&gt; &#123;</div><div class=\"line\">    promise.then((val) =&gt;</div><div class=\"line\">      hasCanceled_ ? reject(&#123;isCanceled: <span class=\"literal\">true</span>&#125;) : resolve(val)</div><div class=\"line\">    );</div><div class=\"line\">    promise.catch((error) =&gt;</div><div class=\"line\">      hasCanceled_ ? reject(&#123;isCanceled: <span class=\"literal\">true</span>&#125;) : reject(error)</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    promise: wrappedPromise,</div><div class=\"line\">    cancel() &#123;</div><div class=\"line\">      hasCanceled_ = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后可以这样使用取消操作：   </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> somePromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(r =&gt; setTimeout(r, <span class=\"number\">1000</span>));<span class=\"comment\">//创建一个异步操作</span></div><div class=\"line\"><span class=\"keyword\">const</span> cancelable = makeCancelable(somePromise);<span class=\"comment\">//为异步操作添加可取消的功能</span></div><div class=\"line\">cancelable</div><div class=\"line\">  .promise</div><div class=\"line\">  .then(() =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>))</div><div class=\"line\">  .catch((&#123;isCanceled, ...error&#125;) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'isCanceled'</span>, isCanceled));</div><div class=\"line\"><span class=\"comment\">// 取消异步操作</span></div><div class=\"line\">cancelable.cancel();</div></pre></td></tr></table></figure>\n<p>Promise后面括号内跟的是要异步执行的操作，<code>.then()</code>里跟的是异步操作执行完后的回调函数。取消 Promise 换句话说也就是取消 <code>.then()</code> 里的回到函数的执行。</p>\n<p>这里通过创建一个辅助的 Promise 来包裹要执行的 Promise，这个设计非常的巧妙。</p>\n<p>首先，如何实现取消 <code>.then()</code> 里的毁掉函数的执行？那么就不能用 <code>.then(callback)</code> 的形式了，而要有一个标识位判断：<code>.then(()=&gt;flag?执行:不执行)</code>。</p>\n<p>那么 <code>flag</code> 定义在哪？肯定不能直接作为一个变量定义在执行 Promise 的类里，因为这个类可能有多个 Promise 任务要处理，创建多个 <code>flag</code> 显然不是一个好的选择。那么就可以新建一个 <code>class</code>，这个 <code>class</code> 里包含 <code>flag</code> 以及这个 Promise，这就需要每次创建 Promise 的时候都 <code>new</code> 一个对象出来。这个方式可行，但是不够优雅。由于 Js 是弱类型的，我们没有必要专门定义一个 <code>class</code>，反正都是 <code>var</code>。因此，就应该像上面那样通过一个方法，直接 <code>return</code> 一个 <code>{}</code> 包裹起来的对象。因为 <code>return</code> 的这个对象用到了 <code>hasCanceled</code> 这个参数，由于有闭包性，在 <code>return</code> 的这个对象被销毁前 <code>hasCanceled</code> 都是可触及的。</p>\n<p>最后，为什么要用一个辅助的 Promise 去包裹？ 其实用一个类或者一个方法也是能达到同样的效果。这样的设计也很巧妙。将要执行的 Promise 的 <code>.then()</code> 作为 辅助的 Promise 的异步执行操作，达到的目的是在 <code>.then()</code> 完成后，辅助的 Promise 的异步操作才可能结束。当辅助的 Promise 的异步操作结束后，就可以调用其自己的 <code>.then()</code> 来通知要执行的 Promise 已经执行完毕（仔细想了想，其实用辅助 Promise 也没甚屌用，因为 <code>.then()</code> 是可以链式调用的如：<code>.then().then()</code>，我完全可以直接自己定义一个 <code>function</code>，比如：<code>(callbackLogical,callbackNotify)=&gt;promise.then(()=&gt;flag?执行callbackLogical:不执行callbackLogical).then(callbackNotify)</code>。只要调用了这个方法，那么不就都搞定了么。</p>\n<h3 id=\"AsyncStorage存储key管理小技巧\"><a href=\"#AsyncStorage存储key管理小技巧\" class=\"headerlink\" title=\"AsyncStorage存储key管理小技巧\"></a>AsyncStorage存储key管理小技巧</h3><p><code>AsyncStorage</code> 是一个简单的、异步的、持久化的 <code>Key-Value</code> 存储系统，它对于 App 来说是全局性的。它用来代替 <code>LocalStorage</code>。</p>\n<p>推荐使用封装好的第三方库<a href=\"https://github.com/sunnylqm/react-native-storage/blob/master/README-CHN.md\">react-native-storage</a> 具体使用方式就不细说了。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>正如 web 中的 <code>window</code>，在 RN 中也有一个全局根属性可以挂载各种全局变量：<code>global</code>。比如上面推荐的 <code>react-native-storage</code> 用到的 <code>storage</code>,使用 <code>global.storage = storage</code> 就可以在各个地方拿到 <code>storage</code> 对象。</p>\n<p>但是要注意一点，一定要注意执行顺序，也就是必须要在使用 <code>global.storage</code> 前，将 <code>storage</code> 赋给 <code>global.storage</code>，所以要将这个赋值放到必须执行的文件中。</p>\n<h3 id=\"优化切换动画卡顿的问题\"><a href=\"#优化切换动画卡顿的问题\" class=\"headerlink\" title=\"优化切换动画卡顿的问题\"></a>优化切换动画卡顿的问题</h3><p>使用API <code>InteractionManager</code>，它的作用就是可以使本来 JS 的一些操作在动画完成之后执行，这样就可确保动画的流程性。当然这是在延迟执行为代价上来获得帧数的提高。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">InteractionManager.runAfterInteractions(()=&gt;&#123;</div><div class=\"line\">\t<span class=\"comment\">//...耗时较长的同步任务...</span></div><div class=\"line\">\t<span class=\"comment\">//更新state也需要时间</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t<span class=\"comment\">//获取某些数据，需要长时间等待</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.fetchData(arguements)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"React-Native-原生模块调用-iOS\"><a href=\"#React-Native-原生模块调用-iOS\" class=\"headerlink\" title=\"React-Native 原生模块调用(iOS)\"></a>React-Native 原生模块调用(iOS)</h3><p>在项目中遇到地图,拨打电话,清除缓存等iOS与Andiorid机制不同的功能,就需要调用原生的界面或模块。</p>\n<h4 id=\"创建原生模块，实现“RCTBridgeModule”协议\"><a href=\"#创建原生模块，实现“RCTBridgeModule”协议\" class=\"headerlink\" title=\"创建原生模块，实现“RCTBridgeModule”协议\"></a>创建原生模块，实现“RCTBridgeModule”协议</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\">#import &quot;RCTBridgeModule.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface LoginViewController : UIViewController&lt;RCTBridgeModule&gt;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"导出模块，导出方法\"><a href=\"#导出模块，导出方法\" class=\"headerlink\" title=\"导出模块，导出方法\"></a>导出模块，导出方法</h4><p>不仅可以让导出 native 的方法，而且还可以在 js 中添加回调函数，供 native 调用，这样 native 就可以将前面的数据回塞给 js 了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation LoginViewController</div><div class=\"line\">//导出模块</div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_METHOD(showSVProgressHUDErrorWithStatus:(NSString *)state callBack:(RCTResponseSenderBlock)callback)&#123;</div><div class=\"line\">  NSLog(@&quot;state is %@&quot;,state);</div><div class=\"line\">  NSArray *events = [[NSArray alloc] initWithObjects:@&quot;hello&quot;, nil];</div><div class=\"line\">  // 这里callback必须是数组</div><div class=\"line\">  callback(events);</div><div class=\"line\">  [SVProgressHUD showErrorWithStatus:state];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"js文件中调用\"><a href=\"#js文件中调用\" class=\"headerlink\" title=\"js文件中调用\"></a>js文件中调用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建原生模块实例</div><div class=\"line\">let LoginViewController = NativeModules.LoginViewController;</div><div class=\"line\"></div><div class=\"line\">//方法调用</div><div class=\"line\">LoginViewController.showSVProgressHUDErrorWithStatus(&apos;请输入正确的手机号&apos;,(callbackString) =&gt; &#123;console.log(callbackString);&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-真机调试\"><a href=\"#React-Native-真机调试\" class=\"headerlink\" title=\"React Native 真机调试\"></a>React Native 真机调试</h3><p>开发中真机调试是必不可少的,有些功能和问题模拟器是无法重现的,所以就需要配合真机测试</p>\n<h4 id=\"iOS-真机调试\"><a href=\"#iOS-真机调试\" class=\"headerlink\" title=\"iOS 真机调试\"></a>iOS 真机调试</h4><p>首先，<strong>必须</strong> 保证调试用电脑的和你的设备处于相同的 <code>WiFi</code> 网络环境中下。然后修改<code>AppDelegate.m</code> 文件，设置 <code>jsLocation</code> 为本地 ip 即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSURL</span> *jsCodeLocation;</div><div class=\"line\">[RCTBundleURLProvider sharedSettings].jsLocation = <span class=\"string\">@\"192.168.31.142\"</span>;</div><div class=\"line\">jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:<span class=\"string\">@\"index.ios\"</span> fallbackResource:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class=\"line\">                                                      moduleName:<span class=\"string\">@\"AwesomeProject\"</span></div><div class=\"line\">                                               initialProperties:<span class=\"literal\">nil</span></div><div class=\"line\">                                                   launchOptions:launchOptions];</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-import-文件的小技巧\"><a href=\"#React-Native-import-文件的小技巧\" class=\"headerlink\" title=\"React Native import 文件的小技巧\"></a>React Native import 文件的小技巧</h3><p>开发中经常需要 import 其他 js 文件，如果需要同时导入一些相关的 js 文件时，可以创建一个索引文件方便引用。  </p>\n<h4 id=\"第一步：创建index-js\"><a href=\"#第一步：创建index-js\" class=\"headerlink\" title=\"第一步：创建index.js\"></a>第一步：创建index.js</h4><p>在 <code>index.js</code> 中 import 相关的 js 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">import Request from &apos;./network/RequestManager&apos;;</div><div class=\"line\">import AppContext from &apos;./network/AppContext&apos;;</div><div class=\"line\">import ApiServiceFactory from &apos;./network/ApiServiceFactory&apos;;</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    ApiServiceFactory,</div><div class=\"line\">    Request,</div><div class=\"line\">    AppContext</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用\"><a href=\"#第二步：使用\" class=\"headerlink\" title=\"第二步：使用\"></a>第二步：使用</h4><p>如果需要使用这些类，只需要导入 <code>index</code> 文件就可以了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123;Request, ApiServiceFactory, AppContext&#125; from &apos;../expand/index&apos;;</div></pre></td></tr></table></figure>\n<h3 id=\"React-Native-读取本地的json文件\"><a href=\"#React-Native-读取本地的json文件\" class=\"headerlink\" title=\"React Native 读取本地的json文件\"></a>React Native 读取本地的json文件</h3><p>可以以导入的形式，来读取本地的json文件，导入的文件可以作为一个js对象使用，这样方便调试的时候加载数据。</p>\n<h4 id=\"导入json文件：\"><a href=\"#导入json文件：\" class=\"headerlink\" title=\"导入json文件：\"></a>导入json文件：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> langsData = <span class=\"built_in\">require</span>(<span class=\"string\">'./json/langs.json'</span>);</div></pre></td></tr></table></figure>\n<p>现在你可以操作<code>langsData</code>对象了。  </p>\n<h4 id=\"json格式\"><a href=\"#json格式\" class=\"headerlink\" title=\"json格式\"></a>json格式</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"123\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"aa\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"1234\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">false</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"attr\">\"path\"</span>:<span class=\"string\">\"ddd\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"name\"</span>:<span class=\"string\">\"123123123\"</span>,</div><div class=\"line\">    <span class=\"attr\">\"checked\"</span>:<span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,l=langsData.length;i&lt;l;i++)&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(langsData[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"NodeJs学习笔记","date":"2016-09-22T02:07:12.000Z","_content":"\n本篇是NodeJs的学习笔记\n\n<!--more-->\n## 单线程\nnode 中，所有的任务都**在一个线程中完成(I/O等除外)**，在 node.js 执行的时候维护着一个事件队列；程序在执行时进入**事件循环**等待下一个事件到来，每个异步 I/O 请求完成后都会被推送到事件队列中的等待执行。\n\n优势是避免了频繁的切换线程带来的消耗，缺点是面对 cpu 密集型模型(比如 while 循环)，就会造成阻塞。\n\n所谓事件循环是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。\nnode.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。node.js的事件循环对开发者不可见，由libev库实现，libev不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。\n\n[Node.js机制及原理理解初步](http://blog.csdn.net/leftfist/article/details/41891407)\n\n## 模块\n### 实现\n模块化的好处不多说，下面看看Node中如何模块化.我们编写了一个`hello.js`文件，这个`hello.js`文件就是一个模块，模块的名字就是文件名（去掉`.js`后缀），所以`hello.js`文件就是名为`hello`的模块:\n\n```javascript\nvar s = 'Hello';\n\nfunction greet(name) {\n    console.log(s + ', ' + name + '!');\n}\n\nmodule.exports = greet;\n```\n\n上面定义了一个函数`greet()`，`module.exports = greet`的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。\n\n其他模块怎么使用`hello`模块的这个`greet`函数呢？我们再编写一个`main.js`文件，调用`hello`模块的`greet`函数：\n\n```javascript\n// 引入hello模块:\nvar greet = require('./hello');\n\nvar s = 'Michael';\n\ngreet(s); // Hello, Michael!\n```\n\n`greet`变量就是上面`module.exports = greet`输出的`greet`。在使用`require()`引入模块的时候，请注意模块的相对路径。\n\n一个模块想要对外暴露变量（函数也是变量），可以用`module.exports = variable;`，一个模块要引用其他模块暴露的变量，用`var ref = require('module_name');`就拿到了引用模块的变量。\n\n### 原理\n模块化保证不同模块可以使用相同的变量名，那么这是如何实现的呢？\n\n```javascript\n// 准备module对象,require就是根据id获得相应module的exports:\nvar module = {\n    id: 'hello',\n    exports: {}\n};\nvar load = function (module) {\n    // 读取的hello.js代码:\n    function greet(name) {\n        console.log('Hello, ' + name + '!');\n    }\n\n    module.exports = greet;\n    // hello.js代码结束\n    return module.exports;\n};\nvar exported = load(module);\n// 保存module:\nsave(module, exported);\n```\n\n全局变量现在变成了匿名函数内部的局部变量，所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。\n\n变量`module`是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在`hello.js`中可以直接使用变量`module`原因就在于它实际上是函数的一个参数.\n\n通过把参数`module`传递给`load()`函数，`hello.js`就顺利地把一个变量传递给了Node执行环境，Node会把`module`变量保存到某个地方。\n\n由于Node保存了所有导入的`module`，当我们用`require()`获取`module`时，Node找到对应的`module`，把这个`module`的`exports`变量返回，这样，另一个模块就顺利拿到了模块的输出。\n\n\n## 基本模块\n### 基本模块\n#### global\nJavaScript有且仅有一个全局对象，在浏览器中，叫`window`对象。而在Node.js环境中，也有唯一的全局对象，叫`global`。\n\n#### process\n`process`也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用信息：\n\n```javascript\n> process === global.process;\ntrue\n> process.version;\n'v4.5.0'\n> process.platform;\n'darwin'\n> process.arch;\n'x64'\n> process.cwd(); //返回当前工作目录\n'/Users/michael'\n> process.chdir('/private/tmp'); // 切换当前工作目录\nundefined\n> process.cwd();\n'/private/tmp'\n```\n\nJavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。如果我们想要在下一次事件响应中执行代码，可以调用`process.nextTick()`：\n\n```javscripipt\n// process.nextTick()将在下一轮事件循环中调用:\nprocess.nextTick(function () {\n    console.log('nextTick callback!');\n});\nconsole.log('nextTick was set!');\n```\n\n用Node执行上面的代码`node test.js`，你会看到，打印输出是：\n\n```javascript\nnextTick was set!\nnextTick callback!\n```\n\n这说明传入`process.nextTick()`的函数不是立刻执行，而是要等到下一次事件循环。\n\nNode.js进程本身的事件就由`process`对象来处理。如果我们响应`exit`事件，就可以在程序即将退出时执行某个回调函数：\n\n```javascript\n// 程序即将退出时的回调函数:\nprocess.on('exit', function (code) {\n    console.log('about to exit with code: ' + code);\n});\n```\n\n#### 判断JavaScript执行环境\n有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\n\n```javscript\nif (typeof(window) === 'undefined') {\n    console.log('node.js');\n} else {\n    console.log('browser');\n}\n```\n\n### fs\n#### 异步读取文件\n```javascript\nvar fs = require('fs');\n\nfs.readFile('sample.txt', 'utf-8', function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n    }\n});\n```\n\n`sample.txt`文件必须在当前目录下，且文件编码为`utf-8`。异步读取时，传入的回调函数接收两个参数，当正常读取时，`err`参数为`null`，`data`参数为读取到的`String`。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。\n\n当读取二进制文件时，不传入文件编码时，回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中，`Buffer`对象就是一个包含零个或任意个字节的数组（注意和`Array`不同）。\n\n```javascript\nvar fs = require('fs');\n\nfs.readFile('sample.png', function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n        console.log(data.length + ' bytes');\n    }\n});\n```\n\n`Buffer`对象可以和`String`作转换，例如，把一个`Buffer`对象转换成`String`：\n\n```javascript\n// Buffer -> String\nvar text = data.toString('utf-8');\nconsole.log(text);\n```\n\n或者把一个`String`转换成`Buffer`：\n\n```javascript\n// String -> Buffer\nvar buf = new Buffer(text, 'utf-8');\nconsole.log(buf);\n```\n\n#### 同步读取文件\nfs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果:\n\n```javascript\nvar fs = require('fs');\n\nvar data = fs.readFileSync('sample.txt', 'utf-8');\nconsole.log(data);\n```\n\n#### 写文件\n将数据写入文件是通过`fs.writeFile()`实现的：\n\n```javascript\nvar fs = require('fs');\n\nvar data = 'Hello, Node.js';\nfs.writeFile('output.txt', data, function (err) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log('ok.');\n    }\n});\n```\n\n和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：\n\n```javascript\nvar fs = require('fs');\n\nvar data = 'Hello, Node.js';\nfs.writeFileSync('output.txt', data);\n```\n\n#### stat\n如果我们要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`Stat`对象，能告诉我们文件或目录的详细信息：\n\n```javascript\nvar fs = require('fs');\n\nfs.stat('sample.txt', function (err, stat) {\n    if (err) {\n        console.log(err);\n    } else {\n        // 是否是文件:\n        console.log('isFile: ' + stat.isFile());\n        // 是否是目录:\n        console.log('isDirectory: ' + stat.isDirectory());\n        if (stat.isFile()) {\n            // 文件大小:\n            console.log('size: ' + stat.size);\n            // 创建时间, Date对象:\n            console.log('birth time: ' + stat.birthtime);\n            // 修改时间, Date对象:\n            console.log('modified time: ' + stat.mtime);\n        }\n    }\n});\n```\n\n#### 同步还是异步\n同步方法是为了方便使用,但是一般情况下还是使用异步的方式。服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次。\n\n### stream\n在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。\n\n#### 流读取文件\n```javascript\nvar fs = require('fs');\n\n// 打开一个流:\nvar rs = fs.createReadStream('sample.txt', 'utf-8');\n\nrs.on('data', function (chunk) {\n    console.log('DATA:')\n    console.log(chunk);\n});\n\nrs.on('end', function () {\n    console.log('END');\n});\n\nrs.on('error', function (err) {\n    console.log('ERROR: ' + err);\n});\n```\n\n#### 流写入文件\n要以流的形式写入文件，只需要不断调用`write()`方法，最后以`end()`结束：\n\n```javascript\nvar fs = require('fs');\n\nvar ws1 = fs.createWriteStream('output1.txt', 'utf-8');\nws1.write('使用Stream写入文本数据...\\n');\nws1.write('END.');\nws1.end();\n\nvar ws2 = fs.createWriteStream('output2.txt');\nws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));\nws2.write(new Buffer('END.', 'utf-8'));\nws2.end();\n```\n\n#### pipe\n就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。\n\n让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：\n\n```javascript\nvar fs = require('fs');\n\nvar rs = fs.createReadStream('sample.txt');\nvar ws = fs.createWriteStream('copied.txt');\n\nrs.pipe(ws);\n```\n\n### http\n#### Http服务器\nNode.js自带的`http`模块完成了对http协议的解析。直接操作`http`模块提供的`request`和`response`对象。\n\n`request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；\n`response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。\n\n我们来实现一个最简单的Web程序`hello.js`，它对于所有请求，都返回`Hello world!`：\n\n```javascript\n// 导入http模块:\nvar http = require('http');\n\n// 创建http server，并传入回调函数:\nvar server = http.createServer(function (request, response) {\n    // 回调函数接收request和response对象,\n    // 获得HTTP请求的method和url:\n    console.log(request.method + ': ' + request.url);\n    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\n    response.writeHead(200, {'Content-Type': 'text/html'});\n    // 将HTTP响应的HTML内容写入response:\n    response.end('<h1>Hello world!</h1>');\n});\n\n// 让服务器监听8080端口:\nserver.listen(8080);\n\nconsole.log('Server is running at http://127.0.0.1:8080/');\n```\n\n可以看到以下输出：\n\n```javascript\n$ node hello.js \nServer is running at http://127.0.0.1:8080/\n```\n\n打开浏览器，输入`http://localhost:8080`即可看到输出。\n\n#### 文件服务器\n我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析`request.url`中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\n\n解析URL需要用到Node.js提供的`url`模块，它使用起来非常简单，通过`parse()`将一个字符串解析为一个`Url`对象：\n\n```javascript\nvar url = require('url');\n\nconsole.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));\n```\n\n结果如下：\n\n```javascript\nUrl {\n  protocol: 'http:',\n  slashes: true,\n  auth: 'user:pass',\n  host: 'host.com:8080',\n  port: '8080',\n  hostname: 'host.com',\n  hash: '#hash',\n  search: '?query=string',\n  query: 'query=string',\n  pathname: '/path/to/file',\n  path: '/path/to/file?query=string',\n  href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }\n```\n\n处理本地文件目录需要使用Node.js提供的`path`模块，它可以方便地构造目录：\n\n```javacript\nvar path = require('path');\n\n// 解析当前目录:\nvar workDir = path.resolve('.'); // '/Users/michael'\n\n// 组合完整的文件路径:当前目录+'pub'+'index.html':\nvar filePath = path.join(workDir, 'pub', 'index.html');\n// '/Users/michael/pub/index.html'\n```\n\n最后，我们实现一个文件服务器`file_server.js`：\n\n```javascript\nvar\n    fs = require('fs'),\n    url = require('url'),\n    path = require('path'),\n    http = require('http');\n\n// 从命令行参数获取root目录，默认是当前目录:\n//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。\nvar root = path.resolve(process.argv[2] || '.');\n\nconsole.log('Static root dir: ' + root);\n\n// 创建服务器:\nvar server = http.createServer(function (request, response) {\n    // 获得URL的path，类似 '/css/bootstrap.css':\n    var pathname = url.parse(request.url).pathname;\n    // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':\n    var filepath = path.join(root, pathname);\n    // 获取文件状态:\n    fs.stat(filepath, function (err, stats) {\n        if (!err && stats.isFile()) {\n            // 没有出错并且文件存在:\n            console.log('200 ' + request.url);\n            // 发送200响应:\n            response.writeHead(200);\n            // 将文件流导向response:\n            fs.createReadStream(filepath).pipe(response);\n        } else {\n            // 出错了或者文件不存在:\n            console.log('404 ' + request.url);\n            // 发送404响应:\n            response.writeHead(404);\n            response.end('404 Not Found');\n        }\n    });\n});\n\nserver.listen(8080);\n\nconsole.log('Server is running at http://127.0.0.1:8080/');\n```\n\n没有必要手动读取文件内容。由于`response`对象本身是一个`Writable Stream`，直接用`pipe()`方法就实现了自动读取文件内容并输出到HTTP响应。\n\n在命令行运行`node file_server.js /path/to/dir`，把`/path/to/dir`改成你本地的一个有效的目录，然后在浏览器中输入`http://localhost:8080/index.html`。只要当前目录下存在文件`index.html`，服务器就可以把文件内容发送给浏览器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Nodejs学习笔记.md","raw":"title: NodeJs学习笔记\ndate: 2016/9/22 10:07:12  \ncategories: JavaScript\ntags:\n\t- 学习笔记\n\t- NodeJs\n\n---\n\n本篇是NodeJs的学习笔记\n\n<!--more-->\n## 单线程\nnode 中，所有的任务都**在一个线程中完成(I/O等除外)**，在 node.js 执行的时候维护着一个事件队列；程序在执行时进入**事件循环**等待下一个事件到来，每个异步 I/O 请求完成后都会被推送到事件队列中的等待执行。\n\n优势是避免了频繁的切换线程带来的消耗，缺点是面对 cpu 密集型模型(比如 while 循环)，就会造成阻塞。\n\n所谓事件循环是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。\nnode.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。node.js的事件循环对开发者不可见，由libev库实现，libev不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。\n\n[Node.js机制及原理理解初步](http://blog.csdn.net/leftfist/article/details/41891407)\n\n## 模块\n### 实现\n模块化的好处不多说，下面看看Node中如何模块化.我们编写了一个`hello.js`文件，这个`hello.js`文件就是一个模块，模块的名字就是文件名（去掉`.js`后缀），所以`hello.js`文件就是名为`hello`的模块:\n\n```javascript\nvar s = 'Hello';\n\nfunction greet(name) {\n    console.log(s + ', ' + name + '!');\n}\n\nmodule.exports = greet;\n```\n\n上面定义了一个函数`greet()`，`module.exports = greet`的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。\n\n其他模块怎么使用`hello`模块的这个`greet`函数呢？我们再编写一个`main.js`文件，调用`hello`模块的`greet`函数：\n\n```javascript\n// 引入hello模块:\nvar greet = require('./hello');\n\nvar s = 'Michael';\n\ngreet(s); // Hello, Michael!\n```\n\n`greet`变量就是上面`module.exports = greet`输出的`greet`。在使用`require()`引入模块的时候，请注意模块的相对路径。\n\n一个模块想要对外暴露变量（函数也是变量），可以用`module.exports = variable;`，一个模块要引用其他模块暴露的变量，用`var ref = require('module_name');`就拿到了引用模块的变量。\n\n### 原理\n模块化保证不同模块可以使用相同的变量名，那么这是如何实现的呢？\n\n```javascript\n// 准备module对象,require就是根据id获得相应module的exports:\nvar module = {\n    id: 'hello',\n    exports: {}\n};\nvar load = function (module) {\n    // 读取的hello.js代码:\n    function greet(name) {\n        console.log('Hello, ' + name + '!');\n    }\n\n    module.exports = greet;\n    // hello.js代码结束\n    return module.exports;\n};\nvar exported = load(module);\n// 保存module:\nsave(module, exported);\n```\n\n全局变量现在变成了匿名函数内部的局部变量，所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。\n\n变量`module`是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在`hello.js`中可以直接使用变量`module`原因就在于它实际上是函数的一个参数.\n\n通过把参数`module`传递给`load()`函数，`hello.js`就顺利地把一个变量传递给了Node执行环境，Node会把`module`变量保存到某个地方。\n\n由于Node保存了所有导入的`module`，当我们用`require()`获取`module`时，Node找到对应的`module`，把这个`module`的`exports`变量返回，这样，另一个模块就顺利拿到了模块的输出。\n\n\n## 基本模块\n### 基本模块\n#### global\nJavaScript有且仅有一个全局对象，在浏览器中，叫`window`对象。而在Node.js环境中，也有唯一的全局对象，叫`global`。\n\n#### process\n`process`也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用信息：\n\n```javascript\n> process === global.process;\ntrue\n> process.version;\n'v4.5.0'\n> process.platform;\n'darwin'\n> process.arch;\n'x64'\n> process.cwd(); //返回当前工作目录\n'/Users/michael'\n> process.chdir('/private/tmp'); // 切换当前工作目录\nundefined\n> process.cwd();\n'/private/tmp'\n```\n\nJavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。如果我们想要在下一次事件响应中执行代码，可以调用`process.nextTick()`：\n\n```javscripipt\n// process.nextTick()将在下一轮事件循环中调用:\nprocess.nextTick(function () {\n    console.log('nextTick callback!');\n});\nconsole.log('nextTick was set!');\n```\n\n用Node执行上面的代码`node test.js`，你会看到，打印输出是：\n\n```javascript\nnextTick was set!\nnextTick callback!\n```\n\n这说明传入`process.nextTick()`的函数不是立刻执行，而是要等到下一次事件循环。\n\nNode.js进程本身的事件就由`process`对象来处理。如果我们响应`exit`事件，就可以在程序即将退出时执行某个回调函数：\n\n```javascript\n// 程序即将退出时的回调函数:\nprocess.on('exit', function (code) {\n    console.log('about to exit with code: ' + code);\n});\n```\n\n#### 判断JavaScript执行环境\n有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\n\n```javscript\nif (typeof(window) === 'undefined') {\n    console.log('node.js');\n} else {\n    console.log('browser');\n}\n```\n\n### fs\n#### 异步读取文件\n```javascript\nvar fs = require('fs');\n\nfs.readFile('sample.txt', 'utf-8', function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n    }\n});\n```\n\n`sample.txt`文件必须在当前目录下，且文件编码为`utf-8`。异步读取时，传入的回调函数接收两个参数，当正常读取时，`err`参数为`null`，`data`参数为读取到的`String`。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。\n\n当读取二进制文件时，不传入文件编码时，回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中，`Buffer`对象就是一个包含零个或任意个字节的数组（注意和`Array`不同）。\n\n```javascript\nvar fs = require('fs');\n\nfs.readFile('sample.png', function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n        console.log(data.length + ' bytes');\n    }\n});\n```\n\n`Buffer`对象可以和`String`作转换，例如，把一个`Buffer`对象转换成`String`：\n\n```javascript\n// Buffer -> String\nvar text = data.toString('utf-8');\nconsole.log(text);\n```\n\n或者把一个`String`转换成`Buffer`：\n\n```javascript\n// String -> Buffer\nvar buf = new Buffer(text, 'utf-8');\nconsole.log(buf);\n```\n\n#### 同步读取文件\nfs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果:\n\n```javascript\nvar fs = require('fs');\n\nvar data = fs.readFileSync('sample.txt', 'utf-8');\nconsole.log(data);\n```\n\n#### 写文件\n将数据写入文件是通过`fs.writeFile()`实现的：\n\n```javascript\nvar fs = require('fs');\n\nvar data = 'Hello, Node.js';\nfs.writeFile('output.txt', data, function (err) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log('ok.');\n    }\n});\n```\n\n和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：\n\n```javascript\nvar fs = require('fs');\n\nvar data = 'Hello, Node.js';\nfs.writeFileSync('output.txt', data);\n```\n\n#### stat\n如果我们要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`Stat`对象，能告诉我们文件或目录的详细信息：\n\n```javascript\nvar fs = require('fs');\n\nfs.stat('sample.txt', function (err, stat) {\n    if (err) {\n        console.log(err);\n    } else {\n        // 是否是文件:\n        console.log('isFile: ' + stat.isFile());\n        // 是否是目录:\n        console.log('isDirectory: ' + stat.isDirectory());\n        if (stat.isFile()) {\n            // 文件大小:\n            console.log('size: ' + stat.size);\n            // 创建时间, Date对象:\n            console.log('birth time: ' + stat.birthtime);\n            // 修改时间, Date对象:\n            console.log('modified time: ' + stat.mtime);\n        }\n    }\n});\n```\n\n#### 同步还是异步\n同步方法是为了方便使用,但是一般情况下还是使用异步的方式。服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次。\n\n### stream\n在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。\n\n#### 流读取文件\n```javascript\nvar fs = require('fs');\n\n// 打开一个流:\nvar rs = fs.createReadStream('sample.txt', 'utf-8');\n\nrs.on('data', function (chunk) {\n    console.log('DATA:')\n    console.log(chunk);\n});\n\nrs.on('end', function () {\n    console.log('END');\n});\n\nrs.on('error', function (err) {\n    console.log('ERROR: ' + err);\n});\n```\n\n#### 流写入文件\n要以流的形式写入文件，只需要不断调用`write()`方法，最后以`end()`结束：\n\n```javascript\nvar fs = require('fs');\n\nvar ws1 = fs.createWriteStream('output1.txt', 'utf-8');\nws1.write('使用Stream写入文本数据...\\n');\nws1.write('END.');\nws1.end();\n\nvar ws2 = fs.createWriteStream('output2.txt');\nws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));\nws2.write(new Buffer('END.', 'utf-8'));\nws2.end();\n```\n\n#### pipe\n就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。\n\n让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：\n\n```javascript\nvar fs = require('fs');\n\nvar rs = fs.createReadStream('sample.txt');\nvar ws = fs.createWriteStream('copied.txt');\n\nrs.pipe(ws);\n```\n\n### http\n#### Http服务器\nNode.js自带的`http`模块完成了对http协议的解析。直接操作`http`模块提供的`request`和`response`对象。\n\n`request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；\n`response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。\n\n我们来实现一个最简单的Web程序`hello.js`，它对于所有请求，都返回`Hello world!`：\n\n```javascript\n// 导入http模块:\nvar http = require('http');\n\n// 创建http server，并传入回调函数:\nvar server = http.createServer(function (request, response) {\n    // 回调函数接收request和response对象,\n    // 获得HTTP请求的method和url:\n    console.log(request.method + ': ' + request.url);\n    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\n    response.writeHead(200, {'Content-Type': 'text/html'});\n    // 将HTTP响应的HTML内容写入response:\n    response.end('<h1>Hello world!</h1>');\n});\n\n// 让服务器监听8080端口:\nserver.listen(8080);\n\nconsole.log('Server is running at http://127.0.0.1:8080/');\n```\n\n可以看到以下输出：\n\n```javascript\n$ node hello.js \nServer is running at http://127.0.0.1:8080/\n```\n\n打开浏览器，输入`http://localhost:8080`即可看到输出。\n\n#### 文件服务器\n我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析`request.url`中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\n\n解析URL需要用到Node.js提供的`url`模块，它使用起来非常简单，通过`parse()`将一个字符串解析为一个`Url`对象：\n\n```javascript\nvar url = require('url');\n\nconsole.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));\n```\n\n结果如下：\n\n```javascript\nUrl {\n  protocol: 'http:',\n  slashes: true,\n  auth: 'user:pass',\n  host: 'host.com:8080',\n  port: '8080',\n  hostname: 'host.com',\n  hash: '#hash',\n  search: '?query=string',\n  query: 'query=string',\n  pathname: '/path/to/file',\n  path: '/path/to/file?query=string',\n  href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }\n```\n\n处理本地文件目录需要使用Node.js提供的`path`模块，它可以方便地构造目录：\n\n```javacript\nvar path = require('path');\n\n// 解析当前目录:\nvar workDir = path.resolve('.'); // '/Users/michael'\n\n// 组合完整的文件路径:当前目录+'pub'+'index.html':\nvar filePath = path.join(workDir, 'pub', 'index.html');\n// '/Users/michael/pub/index.html'\n```\n\n最后，我们实现一个文件服务器`file_server.js`：\n\n```javascript\nvar\n    fs = require('fs'),\n    url = require('url'),\n    path = require('path'),\n    http = require('http');\n\n// 从命令行参数获取root目录，默认是当前目录:\n//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。\nvar root = path.resolve(process.argv[2] || '.');\n\nconsole.log('Static root dir: ' + root);\n\n// 创建服务器:\nvar server = http.createServer(function (request, response) {\n    // 获得URL的path，类似 '/css/bootstrap.css':\n    var pathname = url.parse(request.url).pathname;\n    // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':\n    var filepath = path.join(root, pathname);\n    // 获取文件状态:\n    fs.stat(filepath, function (err, stats) {\n        if (!err && stats.isFile()) {\n            // 没有出错并且文件存在:\n            console.log('200 ' + request.url);\n            // 发送200响应:\n            response.writeHead(200);\n            // 将文件流导向response:\n            fs.createReadStream(filepath).pipe(response);\n        } else {\n            // 出错了或者文件不存在:\n            console.log('404 ' + request.url);\n            // 发送404响应:\n            response.writeHead(404);\n            response.end('404 Not Found');\n        }\n    });\n});\n\nserver.listen(8080);\n\nconsole.log('Server is running at http://127.0.0.1:8080/');\n```\n\n没有必要手动读取文件内容。由于`response`对象本身是一个`Writable Stream`，直接用`pipe()`方法就实现了自动读取文件内容并输出到HTTP响应。\n\n在命令行运行`node file_server.js /path/to/dir`，把`/path/to/dir`改成你本地的一个有效的目录，然后在浏览器中输入`http://localhost:8080/index.html`。只要当前目录下存在文件`index.html`，服务器就可以把文件内容发送给浏览器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Nodejs学习笔记","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dph00127hzgvs5kj8kl","content":"<p>本篇是NodeJs的学习笔记</p>\n<a id=\"more\"></a>\n<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>node 中，所有的任务都<strong>在一个线程中完成(I/O等除外)</strong>，在 node.js 执行的时候维护着一个事件队列；程序在执行时进入<strong>事件循环</strong>等待下一个事件到来，每个异步 I/O 请求完成后都会被推送到事件队列中的等待执行。</p>\n<p>优势是避免了频繁的切换线程带来的消耗，缺点是面对 cpu 密集型模型(比如 while 循环)，就会造成阻塞。</p>\n<p>所谓事件循环是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。<br>node.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。node.js的事件循环对开发者不可见，由libev库实现，libev不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。</p>\n<p><a href=\"http://blog.csdn.net/leftfist/article/details/41891407\" target=\"_blank\" rel=\"external\">Node.js机制及原理理解初步</a></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>模块化的好处不多说，下面看看Node中如何模块化.我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(s + <span class=\"string\">', '</span> + name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = greet;</div></pre></td></tr></table></figure>\n<p>上面定义了一个函数<code>greet()</code>，<code>module.exports = greet</code>的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。</p>\n<p>其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 引入hello模块:</span></div><div class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"></div><div class=\"line\">greet(s); <span class=\"comment\">// Hello, Michael!</span></div></pre></td></tr></table></figure>\n<p><code>greet</code>变量就是上面<code>module.exports = greet</code>输出的<code>greet</code>。在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。</p>\n<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>模块化保证不同模块可以使用相同的变量名，那么这是如何实现的呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 准备module对象,require就是根据id获得相应module的exports:</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</div><div class=\"line\">    id: <span class=\"string\">'hello'</span>,</div><div class=\"line\">    exports: &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 读取的hello.js代码:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello, '</span> + name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = greet;</div><div class=\"line\">    <span class=\"comment\">// hello.js代码结束</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> exported = load(<span class=\"built_in\">module</span>);</div><div class=\"line\"><span class=\"comment\">// 保存module:</span></div><div class=\"line\">save(<span class=\"built_in\">module</span>, exported);</div></pre></td></tr></table></figure>\n<p>全局变量现在变成了匿名函数内部的局部变量，所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>\n<p>变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数.</p>\n<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>\n<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取<code>module</code>时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出。</p>\n<h2 id=\"基本模块\"><a href=\"#基本模块\" class=\"headerlink\" title=\"基本模块\"></a>基本模块</h2><h3 id=\"基本模块-1\"><a href=\"#基本模块-1\" class=\"headerlink\" title=\"基本模块\"></a>基本模块</h3><h4 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h4><p>JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，叫<code>global</code>。</p>\n<h4 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h4><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; process === global.process;</div><div class=\"line\"><span class=\"literal\">true</span></div><div class=\"line\">&gt; process.version;</div><div class=\"line\"><span class=\"string\">'v4.5.0'</span></div><div class=\"line\">&gt; process.platform;</div><div class=\"line\"><span class=\"string\">'darwin'</span></div><div class=\"line\">&gt; process.arch;</div><div class=\"line\"><span class=\"string\">'x64'</span></div><div class=\"line\">&gt; process.cwd(); <span class=\"comment\">//返回当前工作目录</span></div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\">&gt; process.chdir(<span class=\"string\">'/private/tmp'</span>); <span class=\"comment\">// 切换当前工作目录</span></div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">&gt; process.cwd();</div><div class=\"line\"><span class=\"string\">'/private/tmp'</span></div></pre></td></tr></table></figure>\n<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// process.nextTick()将在下一轮事件循环中调用:</div><div class=\"line\">process.nextTick(function () &#123;</div><div class=\"line\">    console.log(&apos;nextTick callback!&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">console.log(&apos;nextTick was set!&apos;);</div></pre></td></tr></table></figure>\n<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">nextTick was set!</div><div class=\"line\">nextTick callback!</div></pre></td></tr></table></figure>\n<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>\n<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 程序即将退出时的回调函数:</span></div><div class=\"line\">process.on(<span class=\"string\">'exit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'about to exit with code: '</span> + code);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"判断JavaScript执行环境\"><a href=\"#判断JavaScript执行环境\" class=\"headerlink\" title=\"判断JavaScript执行环境\"></a>判断JavaScript执行环境</h4><p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (typeof(window) === &apos;undefined&apos;) &#123;</div><div class=\"line\">    console.log(&apos;node.js&apos;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    console.log(&apos;browser&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a>fs</h3><h4 id=\"异步读取文件\"><a href=\"#异步读取文件\" class=\"headerlink\" title=\"异步读取文件\"></a>异步读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.readFile(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的<code>String</code>。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。</p>\n<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和<code>Array</code>不同）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.readFile(<span class=\"string\">'sample.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data.length + <span class=\"string\">' bytes'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>Buffer</code>对象可以和<code>String</code>作转换，例如，把一个<code>Buffer</code>对象转换成<code>String</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Buffer -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">var</span> text = data.toString(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(text);</div></pre></td></tr></table></figure>\n<p>或者把一个<code>String</code>转换成<code>Buffer</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// String -&gt; Buffer</span></div><div class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(text, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(buf);</div></pre></td></tr></table></figure>\n<h4 id=\"同步读取文件\"><a href=\"#同步读取文件\" class=\"headerlink\" title=\"同步读取文件\"></a>同步读取文件</h4><p>fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data);</div></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">'Hello, Node.js'</span>;</div><div class=\"line\">fs.writeFile(<span class=\"string\">'output.txt'</span>, data, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ok.'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">'Hello, Node.js'</span>;</div><div class=\"line\">fs.writeFileSync(<span class=\"string\">'output.txt'</span>, data);</div></pre></td></tr></table></figure>\n<h4 id=\"stat\"><a href=\"#stat\" class=\"headerlink\" title=\"stat\"></a>stat</h4><p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.stat(<span class=\"string\">'sample.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 是否是文件:</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'isFile: '</span> + stat.isFile());</div><div class=\"line\">        <span class=\"comment\">// 是否是目录:</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'isDirectory: '</span> + stat.isDirectory());</div><div class=\"line\">        <span class=\"keyword\">if</span> (stat.isFile()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 文件大小:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'size: '</span> + stat.size);</div><div class=\"line\">            <span class=\"comment\">// 创建时间, Date对象:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'birth time: '</span> + stat.birthtime);</div><div class=\"line\">            <span class=\"comment\">// 修改时间, Date对象:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'modified time: '</span> + stat.mtime);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"同步还是异步\"><a href=\"#同步还是异步\" class=\"headerlink\" title=\"同步还是异步\"></a>同步还是异步</h4><p>同步方法是为了方便使用,但是一般情况下还是使用异步的方式。服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次。</p>\n<h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<h4 id=\"流读取文件\"><a href=\"#流读取文件\" class=\"headerlink\" title=\"流读取文件\"></a>流读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 打开一个流:</span></div><div class=\"line\"><span class=\"keyword\">var</span> rs = fs.createReadStream(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'DATA:'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(chunk);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'END'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ERROR: '</span> + err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"流写入文件\"><a href=\"#流写入文件\" class=\"headerlink\" title=\"流写入文件\"></a>流写入文件</h4><p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ws1 = fs.createWriteStream(<span class=\"string\">'output1.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">ws1.write(<span class=\"string\">'使用Stream写入文本数据...\\n'</span>);</div><div class=\"line\">ws1.write(<span class=\"string\">'END.'</span>);</div><div class=\"line\">ws1.end();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ws2 = fs.createWriteStream(<span class=\"string\">'output2.txt'</span>);</div><div class=\"line\">ws2.write(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'使用Stream写入二进制数据...\\n'</span>, <span class=\"string\">'utf-8'</span>));</div><div class=\"line\">ws2.write(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'END.'</span>, <span class=\"string\">'utf-8'</span>));</div><div class=\"line\">ws2.end();</div></pre></td></tr></table></figure>\n<h4 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a>pipe</h4><p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> rs = fs.createReadStream(<span class=\"string\">'sample.txt'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ws = fs.createWriteStream(<span class=\"string\">'copied.txt'</span>);</div><div class=\"line\"></div><div class=\"line\">rs.pipe(ws);</div></pre></td></tr></table></figure>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h3><h4 id=\"Http服务器\"><a href=\"#Http服务器\" class=\"headerlink\" title=\"Http服务器\"></a>Http服务器</h4><p>Node.js自带的<code>http</code>模块完成了对http协议的解析。直接操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>\n<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<br><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>\n<p>我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入http模块:</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建http server，并传入回调函数:</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 回调函数接收request和response对象,</span></div><div class=\"line\">    <span class=\"comment\">// 获得HTTP请求的method和url:</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(request.method + <span class=\"string\">': '</span> + request.url);</div><div class=\"line\">    <span class=\"comment\">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">// 将HTTP响应的HTML内容写入response:</span></div><div class=\"line\">    response.end(<span class=\"string\">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 让服务器监听8080端口:</span></div><div class=\"line\">server.listen(<span class=\"number\">8080</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>\n<p>可以看到以下输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node hello.js </div><div class=\"line\">Server is running at http:<span class=\"comment\">//127.0.0.1:8080/</span></div></pre></td></tr></table></figure>\n<p>打开浏览器，输入<code>http://localhost:8080</code>即可看到输出。</p>\n<h4 id=\"文件服务器\"><a href=\"#文件服务器\" class=\"headerlink\" title=\"文件服务器\"></a>文件服务器</h4><p>我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>\n<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(url.parse(<span class=\"string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span>));</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Url &#123;</div><div class=\"line\">  protocol: <span class=\"string\">'http:'</span>,</div><div class=\"line\">  slashes: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: <span class=\"string\">'user:pass'</span>,</div><div class=\"line\">  host: <span class=\"string\">'host.com:8080'</span>,</div><div class=\"line\">  port: <span class=\"string\">'8080'</span>,</div><div class=\"line\">  hostname: <span class=\"string\">'host.com'</span>,</div><div class=\"line\">  hash: <span class=\"string\">'#hash'</span>,</div><div class=\"line\">  search: <span class=\"string\">'?query=string'</span>,</div><div class=\"line\">  query: <span class=\"string\">'query=string'</span>,</div><div class=\"line\">  pathname: <span class=\"string\">'/path/to/file'</span>,</div><div class=\"line\">  path: <span class=\"string\">'/path/to/file?query=string'</span>,</div><div class=\"line\">  href: <span class=\"string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span> &#125;</div></pre></td></tr></table></figure>\n<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\"></div><div class=\"line\">// 解析当前目录:</div><div class=\"line\">var workDir = path.resolve(&apos;.&apos;); // &apos;/Users/michael&apos;</div><div class=\"line\"></div><div class=\"line\">// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:</div><div class=\"line\">var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);</div><div class=\"line\">// &apos;/Users/michael/pub/index.html&apos;</div></pre></td></tr></table></figure>\n<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span></div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</div><div class=\"line\">    url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>),</div><div class=\"line\">    path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>),</div><div class=\"line\">    http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从命令行参数获取root目录，默认是当前目录:</span></div><div class=\"line\"><span class=\"comment\">//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。</span></div><div class=\"line\"><span class=\"keyword\">var</span> root = path.resolve(process.argv[<span class=\"number\">2</span>] || <span class=\"string\">'.'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Static root dir: '</span> + root);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建服务器:</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 获得URL的path，类似 '/css/bootstrap.css':</span></div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"comment\">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></div><div class=\"line\">    <span class=\"keyword\">var</span> filepath = path.join(root, pathname);</div><div class=\"line\">    <span class=\"comment\">// 获取文件状态:</span></div><div class=\"line\">    fs.stat(filepath, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!err &amp;&amp; stats.isFile()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 没有出错并且文件存在:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'200 '</span> + request.url);</div><div class=\"line\">            <span class=\"comment\">// 发送200响应:</span></div><div class=\"line\">            response.writeHead(<span class=\"number\">200</span>);</div><div class=\"line\">            <span class=\"comment\">// 将文件流导向response:</span></div><div class=\"line\">            fs.createReadStream(filepath).pipe(response);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 出错了或者文件不存在:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'404 '</span> + request.url);</div><div class=\"line\">            <span class=\"comment\">// 发送404响应:</span></div><div class=\"line\">            response.writeHead(<span class=\"number\">404</span>);</div><div class=\"line\">            response.end(<span class=\"string\">'404 Not Found'</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">server.listen(<span class=\"number\">8080</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>\n<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>\n<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>。只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。</p>\n","excerpt":"<p>本篇是NodeJs的学习笔记</p>","more":"<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>node 中，所有的任务都<strong>在一个线程中完成(I/O等除外)</strong>，在 node.js 执行的时候维护着一个事件队列；程序在执行时进入<strong>事件循环</strong>等待下一个事件到来，每个异步 I/O 请求完成后都会被推送到事件队列中的等待执行。</p>\n<p>优势是避免了频繁的切换线程带来的消耗，缺点是面对 cpu 密集型模型(比如 while 循环)，就会造成阻塞。</p>\n<p>所谓事件循环是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。<br>node.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。node.js的事件循环对开发者不可见，由libev库实现，libev不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。</p>\n<p><a href=\"http://blog.csdn.net/leftfist/article/details/41891407\">Node.js机制及原理理解初步</a></p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>模块化的好处不多说，下面看看Node中如何模块化.我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(s + <span class=\"string\">', '</span> + name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = greet;</div></pre></td></tr></table></figure>\n<p>上面定义了一个函数<code>greet()</code>，<code>module.exports = greet</code>的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。</p>\n<p>其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 引入hello模块:</span></div><div class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"built_in\">require</span>(<span class=\"string\">'./hello'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"></div><div class=\"line\">greet(s); <span class=\"comment\">// Hello, Michael!</span></div></pre></td></tr></table></figure>\n<p><code>greet</code>变量就是上面<code>module.exports = greet</code>输出的<code>greet</code>。在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。</p>\n<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>模块化保证不同模块可以使用相同的变量名，那么这是如何实现的呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 准备module对象,require就是根据id获得相应module的exports:</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</div><div class=\"line\">    id: <span class=\"string\">'hello'</span>,</div><div class=\"line\">    exports: &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> load = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 读取的hello.js代码:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello, '</span> + name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = greet;</div><div class=\"line\">    <span class=\"comment\">// hello.js代码结束</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> exported = load(<span class=\"built_in\">module</span>);</div><div class=\"line\"><span class=\"comment\">// 保存module:</span></div><div class=\"line\">save(<span class=\"built_in\">module</span>, exported);</div></pre></td></tr></table></figure>\n<p>全局变量现在变成了匿名函数内部的局部变量，所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>\n<p>变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数.</p>\n<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>\n<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取<code>module</code>时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出。</p>\n<h2 id=\"基本模块\"><a href=\"#基本模块\" class=\"headerlink\" title=\"基本模块\"></a>基本模块</h2><h3 id=\"基本模块-1\"><a href=\"#基本模块-1\" class=\"headerlink\" title=\"基本模块\"></a>基本模块</h3><h4 id=\"global\"><a href=\"#global\" class=\"headerlink\" title=\"global\"></a>global</h4><p>JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，叫<code>global</code>。</p>\n<h4 id=\"process\"><a href=\"#process\" class=\"headerlink\" title=\"process\"></a>process</h4><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; process === global.process;</div><div class=\"line\"><span class=\"literal\">true</span></div><div class=\"line\">&gt; process.version;</div><div class=\"line\"><span class=\"string\">'v4.5.0'</span></div><div class=\"line\">&gt; process.platform;</div><div class=\"line\"><span class=\"string\">'darwin'</span></div><div class=\"line\">&gt; process.arch;</div><div class=\"line\"><span class=\"string\">'x64'</span></div><div class=\"line\">&gt; process.cwd(); <span class=\"comment\">//返回当前工作目录</span></div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\">&gt; process.chdir(<span class=\"string\">'/private/tmp'</span>); <span class=\"comment\">// 切换当前工作目录</span></div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">&gt; process.cwd();</div><div class=\"line\"><span class=\"string\">'/private/tmp'</span></div></pre></td></tr></table></figure>\n<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// process.nextTick()将在下一轮事件循环中调用:</div><div class=\"line\">process.nextTick(function () &#123;</div><div class=\"line\">    console.log(&apos;nextTick callback!&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">console.log(&apos;nextTick was set!&apos;);</div></pre></td></tr></table></figure>\n<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">nextTick was set!</div><div class=\"line\">nextTick callback!</div></pre></td></tr></table></figure>\n<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>\n<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 程序即将退出时的回调函数:</span></div><div class=\"line\">process.on(<span class=\"string\">'exit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">code</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'about to exit with code: '</span> + code);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"判断JavaScript执行环境\"><a href=\"#判断JavaScript执行环境\" class=\"headerlink\" title=\"判断JavaScript执行环境\"></a>判断JavaScript执行环境</h4><p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (typeof(window) === &apos;undefined&apos;) &#123;</div><div class=\"line\">    console.log(&apos;node.js&apos;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    console.log(&apos;browser&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"fs\"><a href=\"#fs\" class=\"headerlink\" title=\"fs\"></a>fs</h3><h4 id=\"异步读取文件\"><a href=\"#异步读取文件\" class=\"headerlink\" title=\"异步读取文件\"></a>异步读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.readFile(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的<code>String</code>。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。</p>\n<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和<code>Array</code>不同）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.readFile(<span class=\"string\">'sample.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(data.length + <span class=\"string\">' bytes'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>Buffer</code>对象可以和<code>String</code>作转换，例如，把一个<code>Buffer</code>对象转换成<code>String</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Buffer -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">var</span> text = data.toString(<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(text);</div></pre></td></tr></table></figure>\n<p>或者把一个<code>String</code>转换成<code>Buffer</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// String -&gt; Buffer</span></div><div class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(text, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(buf);</div></pre></td></tr></table></figure>\n<h4 id=\"同步读取文件\"><a href=\"#同步读取文件\" class=\"headerlink\" title=\"同步读取文件\"></a>同步读取文件</h4><p>fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data);</div></pre></td></tr></table></figure>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">'Hello, Node.js'</span>;</div><div class=\"line\">fs.writeFile(<span class=\"string\">'output.txt'</span>, data, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'ok.'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">'Hello, Node.js'</span>;</div><div class=\"line\">fs.writeFileSync(<span class=\"string\">'output.txt'</span>, data);</div></pre></td></tr></table></figure>\n<h4 id=\"stat\"><a href=\"#stat\" class=\"headerlink\" title=\"stat\"></a>stat</h4><p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.stat(<span class=\"string\">'sample.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 是否是文件:</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'isFile: '</span> + stat.isFile());</div><div class=\"line\">        <span class=\"comment\">// 是否是目录:</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'isDirectory: '</span> + stat.isDirectory());</div><div class=\"line\">        <span class=\"keyword\">if</span> (stat.isFile()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 文件大小:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'size: '</span> + stat.size);</div><div class=\"line\">            <span class=\"comment\">// 创建时间, Date对象:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'birth time: '</span> + stat.birthtime);</div><div class=\"line\">            <span class=\"comment\">// 修改时间, Date对象:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'modified time: '</span> + stat.mtime);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"同步还是异步\"><a href=\"#同步还是异步\" class=\"headerlink\" title=\"同步还是异步\"></a>同步还是异步</h4><p>同步方法是为了方便使用,但是一般情况下还是使用异步的方式。服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次。</p>\n<h3 id=\"stream\"><a href=\"#stream\" class=\"headerlink\" title=\"stream\"></a>stream</h3><p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<h4 id=\"流读取文件\"><a href=\"#流读取文件\" class=\"headerlink\" title=\"流读取文件\"></a>流读取文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 打开一个流:</span></div><div class=\"line\"><span class=\"keyword\">var</span> rs = fs.createReadStream(<span class=\"string\">'sample.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">chunk</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'DATA:'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(chunk);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'END'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">rs.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'ERROR: '</span> + err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"流写入文件\"><a href=\"#流写入文件\" class=\"headerlink\" title=\"流写入文件\"></a>流写入文件</h4><p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ws1 = fs.createWriteStream(<span class=\"string\">'output1.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">ws1.write(<span class=\"string\">'使用Stream写入文本数据...\\n'</span>);</div><div class=\"line\">ws1.write(<span class=\"string\">'END.'</span>);</div><div class=\"line\">ws1.end();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ws2 = fs.createWriteStream(<span class=\"string\">'output2.txt'</span>);</div><div class=\"line\">ws2.write(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'使用Stream写入二进制数据...\\n'</span>, <span class=\"string\">'utf-8'</span>));</div><div class=\"line\">ws2.write(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'END.'</span>, <span class=\"string\">'utf-8'</span>));</div><div class=\"line\">ws2.end();</div></pre></td></tr></table></figure>\n<h4 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a>pipe</h4><p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> rs = fs.createReadStream(<span class=\"string\">'sample.txt'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ws = fs.createWriteStream(<span class=\"string\">'copied.txt'</span>);</div><div class=\"line\"></div><div class=\"line\">rs.pipe(ws);</div></pre></td></tr></table></figure>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h3><h4 id=\"Http服务器\"><a href=\"#Http服务器\" class=\"headerlink\" title=\"Http服务器\"></a>Http服务器</h4><p>Node.js自带的<code>http</code>模块完成了对http协议的解析。直接操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>\n<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<br><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>\n<p>我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 导入http模块:</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建http server，并传入回调函数:</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 回调函数接收request和response对象,</span></div><div class=\"line\">    <span class=\"comment\">// 获得HTTP请求的method和url:</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(request.method + <span class=\"string\">': '</span> + request.url);</div><div class=\"line\">    <span class=\"comment\">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/html'</span>&#125;);</div><div class=\"line\">    <span class=\"comment\">// 将HTTP响应的HTML内容写入response:</span></div><div class=\"line\">    response.end(<span class=\"string\">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 让服务器监听8080端口:</span></div><div class=\"line\">server.listen(<span class=\"number\">8080</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>\n<p>可以看到以下输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node hello.js </div><div class=\"line\">Server is running at http:<span class=\"comment\">//127.0.0.1:8080/</span></div></pre></td></tr></table></figure>\n<p>打开浏览器，输入<code>http://localhost:8080</code>即可看到输出。</p>\n<h4 id=\"文件服务器\"><a href=\"#文件服务器\" class=\"headerlink\" title=\"文件服务器\"></a>文件服务器</h4><p>我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>\n<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(url.parse(<span class=\"string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span>));</div></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Url &#123;</div><div class=\"line\">  protocol: <span class=\"string\">'http:'</span>,</div><div class=\"line\">  slashes: <span class=\"literal\">true</span>,</div><div class=\"line\">  auth: <span class=\"string\">'user:pass'</span>,</div><div class=\"line\">  host: <span class=\"string\">'host.com:8080'</span>,</div><div class=\"line\">  port: <span class=\"string\">'8080'</span>,</div><div class=\"line\">  hostname: <span class=\"string\">'host.com'</span>,</div><div class=\"line\">  hash: <span class=\"string\">'#hash'</span>,</div><div class=\"line\">  search: <span class=\"string\">'?query=string'</span>,</div><div class=\"line\">  query: <span class=\"string\">'query=string'</span>,</div><div class=\"line\">  pathname: <span class=\"string\">'/path/to/file'</span>,</div><div class=\"line\">  path: <span class=\"string\">'/path/to/file?query=string'</span>,</div><div class=\"line\">  href: <span class=\"string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span> &#125;</div></pre></td></tr></table></figure>\n<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\"></div><div class=\"line\">// 解析当前目录:</div><div class=\"line\">var workDir = path.resolve(&apos;.&apos;); // &apos;/Users/michael&apos;</div><div class=\"line\"></div><div class=\"line\">// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:</div><div class=\"line\">var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);</div><div class=\"line\">// &apos;/Users/michael/pub/index.html&apos;</div></pre></td></tr></table></figure>\n<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span></div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</div><div class=\"line\">    url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>),</div><div class=\"line\">    path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>),</div><div class=\"line\">    http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 从命令行参数获取root目录，默认是当前目录:</span></div><div class=\"line\"><span class=\"comment\">//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。</span></div><div class=\"line\"><span class=\"keyword\">var</span> root = path.resolve(process.argv[<span class=\"number\">2</span>] || <span class=\"string\">'.'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Static root dir: '</span> + root);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建服务器:</span></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 获得URL的path，类似 '/css/bootstrap.css':</span></div><div class=\"line\">    <span class=\"keyword\">var</span> pathname = url.parse(request.url).pathname;</div><div class=\"line\">    <span class=\"comment\">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></div><div class=\"line\">    <span class=\"keyword\">var</span> filepath = path.join(root, pathname);</div><div class=\"line\">    <span class=\"comment\">// 获取文件状态:</span></div><div class=\"line\">    fs.stat(filepath, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!err &amp;&amp; stats.isFile()) &#123;</div><div class=\"line\">            <span class=\"comment\">// 没有出错并且文件存在:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'200 '</span> + request.url);</div><div class=\"line\">            <span class=\"comment\">// 发送200响应:</span></div><div class=\"line\">            response.writeHead(<span class=\"number\">200</span>);</div><div class=\"line\">            <span class=\"comment\">// 将文件流导向response:</span></div><div class=\"line\">            fs.createReadStream(filepath).pipe(response);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 出错了或者文件不存在:</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'404 '</span> + request.url);</div><div class=\"line\">            <span class=\"comment\">// 发送404响应:</span></div><div class=\"line\">            response.writeHead(<span class=\"number\">404</span>);</div><div class=\"line\">            response.end(<span class=\"string\">'404 Not Found'</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">server.listen(<span class=\"number\">8080</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>\n<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>\n<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>。只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。</p>"},{"title":"React-Native 使用方式","date":"2016-11-25T02:07:12.000Z","_content":"\n这里基于0.39的官方文档，列举了一些需要知道的点。\n\n<!--more-->\n### AppRegistry\n`index.ios.js` 作为一个组件的注册集合以及入口，在这里，将所有组件像这样注册。\n\n```javascript\nAppRegistry.registerComponent('HelloApp', () => HellodApp);\nAppRegistry.registerComponent('HelloWorldApp', () => HelloWorldApp);\n```\n\n### Props\n#### 简介\n组件在创建的时候传入 `Props` 来完成定制，例如：\n\n```javascript\n<Image source={pic} style={{width: 193, height: 110}} />\n```\n\n其中 `source`,`style` 都是传入 image 的 `Props`。其中 `pic` 表示一个js对象，类似后面的 `{width: 193, height: 110}`。\n\n`{pic}` 外面有个括号，表示括号内是一个js变量或者表达式，需要执行后取值，以此**在JSX中嵌入js语句**。\n\n#### 自定义组件的 Props\n自定义组件可以提高复用性。使用时在函数中引用 `this.props.属性名`，例如下面的 `name` 属性：\n\n```javascript \nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\nclass LotsOfGreetings extends Component {\n  render() {\n    return (\n      <View style={{alignItems: 'center'}}>\n        <Greeting name='Rexxar' />\n        <Greeting name='Jaina' />\n      </View>\n    );\n  }\n}\n```\n\n### State\n通过 `Props`,`State` 控制组件。`Props` 在父组件中指定，一经指定，不能改变。对于需要改变的组件，要使用 `state`。\n\n一般要在 `constructor` 中初始化 `state`(通过 `getInitialState` 方法为es5方法，已被淘汰)，需要修改时调用 `setState`。\n\n```javascript\nclass Blink extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { showText: true };\n\n    // 每1000毫秒对showText状态做一次取反操作\n    setInterval(() => {\n      this.setState({ showText: !this.state.showText });\n    }, 1000);\n  }\n\n  render() {\n    // 根据当前showText的值决定是否显示text内容\n    let display = this.state.showText ? this.props.text : ' ';\n    return (\n      <Text>{display}</Text>\n    );\n  }\n}\n\nclass BlinkApp extends Component {\n  render() {\n    return (\n      <View>\n        <Blink text='I love to blink' />\n        <Blink text='Yes blinking is so great' />\n      </View>\n    );\n  }\n}\n```\n\n这个例子中 text 是固定的，所以用 `Props` 在父控件创建的时候传入。在构造函数的时候创建了 `State` 和其属性 `showText`。当然，还可以再这里初始化任意多个属性，用逗号隔开，相当于创建一个 `state` 对象。使用的时候直接可以点出来：`this.state.showText`。想要修改的时候调用 `this.setState()` 方法，将要修改的属性组成对象传入。\n\n拓展：可以学习一下状态容器如：`Redux`。另外，关于 `state` 的更多原理，可以参考 `React.js`。\n\n### StyleSheet\n相当于一个样式合集：\n\n```javascript\nimport { AppRegistry, StyleSheet, Text, View } from 'react-native';\n\nconst styles = StyleSheet.create({\n  bigblue: {\n    color: 'blue',\n    fontWeight: 'bold',\n    fontSize: 30,\n  },\n});\n\n//使用：\n<View style={styles.bigblue}/>\n```\n\n### flex\n在 `style` 中通过flex可以灵活地将组件撑满整个屏幕。\n\n组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的 `width` 和 `height`，也没有设定 `flex`，则父容器的尺寸为零。其子组件如果使用了 `flex`，也是无法显示的。\n\n### flexbox布局\n#### flexDirection\n在 `style` 中指定布局的**主轴**，是 `row` 还是 `column`。默认是 `column`。\n\n#### justifyContent\n在 `style` 中指定元素沿着**主轴**的排序方式。**注意**，这个属性是定义在父控件，作用在子控件上的。\n\n包括 `flex-start`,`flex-end`,`center`,`space-between`,`space-around`。\n\n前面三个不说了，后面两个说一下：\n1. `space-between`:左右各一个子控件，剩余的子控件均匀的分布在中间。如果只有一个，那么这个居左。\n2. `space-around`:所有子控件均匀的分布，如果只有一个，那么这个居中。\n\n#### alignItems\n在 `style` 中指定布局的**次轴**的排序方式。**注意**，这个属性是定义在父控件，作用在子控件上的。\n\n包括 `flex-start`,`flex-end`,`center`,`stretch`。\n\n其中 `stretch` 表示拉伸撑满次轴，前提是不设置子控件宽度。\n\n### 布局样式\n#### 属性\n除了上面说的那些，再摘取一些有用的 `style` 中的属性：\n\n1. `border` 系列:设置边框的宽度，`borderTopWidth`,`borderLeftWidth`...上下左右都可以分别设置。\n2. `alignSelf`:类似于 `alignItems`，只不过这个属性定义在子控件中，重写父控件的 `alignItems`。因为子控件在次轴上没有必要完全按照父控件的控制，那样太死板了，`alignSelf` 的目的就是搞这个特殊。\n3. `left` 系列:定义子控件到父控件的左边距。**注意**，要先设置 `position:absolute` 否则无效。类似的还有 `right`,`top`,`bottom`。\n4. `flexWrap`:当子控件到底后自动换行。`wrap` 为自动换行，`noWrap` 为不换行。**注意**，要定义在父控件中。\n5. `margin` 系列:设置子控件到相邻子控件的间隔。\n6. `max`,`min` 系列:设置控件的最大(小)宽度(高度).\n7. `padding` 系列:在父控件内设置，设置子控件的起点。\n8. `position`:分为 `absolute` 绝对，`relative`相对。默认是相对的，如果要使用 `left` 等样式，就要使用绝对布局。**绝对布局的子控件的大小不会影响父控件的大小**\n9. `zIndex`: 控制控件的绘制层级，该属性越大，越绘在顶层。\n\n#### 使用\n一般使用方式:\n```JSX\nstyle={{height:xx,width:xx}}\n```\n\n如果有多个对象，需要用数组的方式传入：\n\n```JSX\nstyle={[{height:xx,width:xx,},{height:yy,wudth:yy,}]}\n```\n\n如果有相同的属性重复赋值，则以后一个覆盖前一个为准。\n\n### TextInput\n#### 例子\n文本输入组件，先看一个例子：\n\n```javscript\nclass UselessTextInput extends Component {\n  render() {\n    return (\n      <TextInput\n        {...this.props} // Inherit any props passed to it; e.g., multiline, numberOfLines below\n        editable = {true}\n        maxLength = {40}\n      />\n    );\n  }\n}\n\nclass UselessTextInputMultiline extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      text: 'Useless Multiline Placeholder',\n    };\n  }\n\n  render() {\n    return (\n     <View style={{\n       backgroundColor: this.state.text,\n       borderBottomColor: '#000000',\n       borderBottomWidth: 1 }}\n     >\n       <UselessTextInput\n         multiline = {true}\n         numberOfLines = {4}\n         onChangeText={(text) => this.setState({text})}\n         value={this.state.text}\n       />\n     </View>\n    );\n  }\n}\n```\n\n这里为什么要把这个例子贴出来呢？主要有**两个要点**：\n\n首先，`{...this.props}` 的语法。这里`{}` 还是表示使用JS语法的意思。`...` 是es6的语法，叫做**展开运算符**。可以看看下面这个例子：\n\n```javascript\nvar array = [1,2,3,4,5,6,7];\nconsole.log(array);\n//输出 [1, 2, 3, 4, 5, 6, 7]\nconsole.log(...array);\n//输出 1 2 3 4 5 6 7\n```\n\n`this.props` 是个对象，肯定不能放在 Component 中，但是用了**展开运算符**，里面的属性就全部被展开了，也就符合了 JSX 的语法。不只是 `this.props` **任何对象都可以用这种展开的方式将参数传入 Component**。不过不建议滥用，因为容易将很多多余参数传入，可能产生一些不易排查的问题。\n\n\n其次，`onChangeText={(text) => this.setState({text})}`。一般 `setState()` 中都是对象，为什么这里只是 `text`？这也是es6的语法，在键和值相等的时候可以省略 `{text:text}` 为 `{text}`。也就是本例的 `this.setState({text})`。\n\n#### 部分属性\n1. `autoFocus`:在 `componentDidMount` 后是否自动获得焦点。\n2. `defaultValue`:提供文本框的初始值。\n3. `editable`:文本框是否可编辑\n4. `maxLength`:文本框中最长字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。\n5. `multiline`:是否可以多行，默认 false\n6. `onFocus`,`onBlur`,`onEndEditing`,`onSubmitEditing`:输入框在各种情况下的回调函数。\n7. `onChange`:当输入框内容改变时，回调该函数\n8. `onChangeText`:当输入框内容改变时，回调该函数。改变后的文字内容将作为参数传入。\n9. `placeholder`:占位符\n10. `placeholderTextColor`:占位符颜色.(注意，貌似没有 placeholderTextSize 这个属性)\n11. `value`:输入框内显示的值 \n12. `underlineColorAndroid`:这是 android 特有的属性，非常的坑。文档里是这么说的“文本框的下划线颜色”，其实不是这个意思，这个属性设置的是整个文本框的颜色。比如在 iOS 上，直接设置 `backgroundColor='red'` 就能把文本框设成红色，但是 android 不然，在 background 之上还有一层，就是这个 `underlineColorAndroid` 需要将这个也设置成红色，才能正确显示成红色。\n13. 这里还有一个坑点，就是一定一定一定设置 TextInput 的高度。不然即使 TextInput 大小为0，任然会显示 placeholder ，这就会导致一直没有点击效果。所以**一个调试技巧：给控件设置醒目的背景颜色，这样有助于了解控件的布局情况，方便调试。**\n\n#### 方法\n1. `isFocusd()`:判断当前输入框是否获得焦点。\n2. `clear()`:清空输入框内容。\n\n\n### ScrollView\n#### 属性\n1. `contentContainerStyle`:比较重要的属性，相当于在 ScrollView 中内嵌了一个 View，这个属性就是控制这个内嵌 View 的。\n2. `horizontal`:内容水平排布，不知道和 `flexDirection` 有什么区别\n3. `keyboardDismissMode`:用户拖拽视图是否隐藏软键盘。`none`,`on-drag`\n4. `keyboardShouldPersistTaps`:控制是否在当点击文本输入框以外区域时，自动隐藏软键盘。true 不隐藏，false 隐藏。默认 false\n5. `onScroll`:滚动的时候以一定频率回调该函数。\n6. `refreshControll`:指定 RefreshController 组件，用于为 ScrollView 提供下拉刷新功能。\n7. `pagingEnabled`:滚动条停在整数倍位置。\n8. `scrollEventEnabled`:控制视图能否滚动。\n\n#### 方法\n1. `scrollTo`:滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。\n\n```javascript\nscrollTo({x: 0, y: 0, animated: true})\n```\n\n#### RefreshControl\n这一组件可以用在 ScrollView 或 ListView 内部，为其添加下拉刷新的功能。当 ScrollView 处于竖直方向上的起点位置时，此时下拉会触发一个 `onRefresh` 事件。有两个常用属性：\n\n1. `onRefresh`:在视图开始刷新时调用。\n2. `refreshing`: 视图是否应该在刷新时显示指示器。一般是从网络获取数据的时候是 true，获取完数据为 false\n\n#### 示例：用Scrollview实现带下拉刷新的Tableview\n\n```javascript\n// 每一个row的view\nconst Row = React.createClass({\n  _onClick: function() {\n    this.props.onClick(this.props.data);\n  },\n  render: function() {\n    return (\n     <TouchableWithoutFeedback onPress={this._onClick} >\n        <View style={styles.row}>\n          <Text style={styles.text}>\n            {this.props.data.text + ' (' + this.props.data.clicks + ' clicks)'}\n          </Text>\n        </View>\n      </TouchableWithoutFeedback>\n    );\n  },\n});\n\nconst RefreshControlExample = React.createClass({\n  statics: {\n    title: '<RefreshControl>',\n    description: 'Adds pull-to-refresh support to a scrollview.'\n  },\n\n  getInitialState() {\n    return {\n      isRefreshing: false,\n      loaded: 0,\n      rowData: Array.from(new Array(20)).map(\n        (val, i) => ({text: 'Initial row ' + i, clicks: 0})),\n    };\n  },\n\n  _onClick(row) {\n    row.clicks++;\n    this.setState({\n      rowData: this.state.rowData,\n    });\n  },\n\n  render() {\n    const rows = this.state.rowData.map((row, ii) => {\n      return <Row key={ii} data={row} onClick={this._onClick}/>;\n    });\n    return (\n      <ScrollView\n        style={styles.scrollview}\n        refreshControl={\n          <RefreshControl\n            refreshing={this.state.isRefreshing}\n            onRefresh={this._onRefresh}\n            tintColor=\"#ff0000\"\n            title=\"Loading...\"\n            titleColor=\"#00ff00\"\n            colors={['#ff0000', '#00ff00', '#0000ff']}\n            progressBackgroundColor=\"#ffff00\"\n          />\n        }>\n        {rows}\n      </ScrollView>\n    );\n  },\n\n  _onRefresh() {\n    this.setState({isRefreshing: true});\n    setTimeout(() => {\n      // prepend 10 items\n      const rowData = Array.from(new Array(10))\n      .map((val, i) => ({\n        text: 'Loaded row ' + (+this.state.loaded + i),\n        clicks: 0,\n      }))\n      .concat(this.state.rowData);\n\n      this.setState({\n        loaded: this.state.loaded + 10,\n        isRefreshing: false,\n        rowData: rowData,\n      });\n    }, 5000);\n  },\n});\n```\n\n省略了styleSheet。这里主要注意几点：\n1. 譬如封装一个组件 Row，其中有点击事件的处理。iOS 中一般使用代理。这里由于js的特性，可以把外部的点击方法传入组件内，再由组件的点击事件调用。\n2. 注意 `map()` 方法的使用。这也就是用 scrollview 实现 tableview 的方式。\n3. 在 `render` 里可以插入js方法，如上面的 `{row}`,只要方法返回的是JSX的 component就行。（貌似component里的属性只能用展开运算符才能插入，用js方法返回的方式一直都报错）\n4. `RefreshControl` 看起来也就是一个 component，由 scrollview 控制什么时候展示，怎么展示。\n5. 如果想要自定义上拉刷新，就得知道 `contentOffset` 可以研究一下。\n\n### ListView\nListView设计到各种优化，以及各种方法，掌握的不是很好，需要进一步学习。\n#### 属性\n1. ScrollView 全部属性\n2. `dataSource`:`ListView.DataSource实例`。\n3. `initialListSize`:指定在组件刚挂载的时候渲染多少行数据。(试了下没看出有什么效果。)\n4. `onChangeVisibleRows`:显示区域的 cell 变化时调用。（api 和实际使用有出入，需要实际使用的时候检验，不过这个东西好像没什么太大用）\n5. `onEndReachedThreshold`:调用 `onEndReached` 之前的临界值.\n6. `onEndReached`:滚动到底部时的回调，如果数据不满足一屏，会立即回调，需要手动标记过滤。\n7. `pageSize`:每次事件循环（每帧）渲染的行数。默认是1。（好像不需要自己设置，不知道设了有什么影响）\n8. `removeClippedSubviews`:说是提升性能默认开启，不知道具体有啥用。\n9. `renderHeader`,`renderFooter`:页头，页脚。\n10. `renderRow`: cell 的实现，方法为`(rowData, sectionID, rowID, highlightRow) => renderable`\n11. `renderSeparator`: `(sectionID, rowID, adjacentRowHighlighted) => renderable` 一个可渲染的组件会被渲染在每一行下面.如果被点击了，就会显示出来。没什么太大用。如果要用，要在 return 的 view 里添加 `key`，最好看一下示例。\n12. `scrollRenderAheadDistance`:距离多少开始渲染下一行。\n13. `renderScrollComponent`:不知道怎么用。\n14. `renderSectionHeader`:每个小节(section)渲染一个粘性的标题。`(sectionData, sectionID) => renderable` 其中 `sectionData` 就是section内内容的数组。\n\n#### 一些方法\n1. listview 只是提供了渲染其中 cell 的功能，默认是 cell 竖着排下来。那么如果要实现成 gridview 之类该怎么做呢？就是给 listview 附上从 scrollview 中继承来的 `contentContainerStyle` 这个 style 用来控制其中子视图的样式，只要在其中将 `flexDirection:‘row’,justifyContent: 'space-around',flexWrap: 'wrap'` 这样一设置。就能达到横排 cell，并且自动换行的效果。\n\n### 网络\n感觉没什么好写的，暂且不表\n\n### navigator\n暂时还是用原生的 navigator，感觉 navigator 不太好用，所以暂且不表。\n\n如果需要使用，可以查看这篇[教程](http://bbs.reactnative.cn/topic/20/新手理解navigator的教程)\n\n###\n\n\n\n\n\n\n","source":"_posts/RN使用方式.md","raw":"title: React-Native 使用方式\ndate: 2016/11/25 10:07:12  \ncategories: React-Native\ntags:\n\t- React-Native\n\n---\n\n这里基于0.39的官方文档，列举了一些需要知道的点。\n\n<!--more-->\n### AppRegistry\n`index.ios.js` 作为一个组件的注册集合以及入口，在这里，将所有组件像这样注册。\n\n```javascript\nAppRegistry.registerComponent('HelloApp', () => HellodApp);\nAppRegistry.registerComponent('HelloWorldApp', () => HelloWorldApp);\n```\n\n### Props\n#### 简介\n组件在创建的时候传入 `Props` 来完成定制，例如：\n\n```javascript\n<Image source={pic} style={{width: 193, height: 110}} />\n```\n\n其中 `source`,`style` 都是传入 image 的 `Props`。其中 `pic` 表示一个js对象，类似后面的 `{width: 193, height: 110}`。\n\n`{pic}` 外面有个括号，表示括号内是一个js变量或者表达式，需要执行后取值，以此**在JSX中嵌入js语句**。\n\n#### 自定义组件的 Props\n自定义组件可以提高复用性。使用时在函数中引用 `this.props.属性名`，例如下面的 `name` 属性：\n\n```javascript \nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\nclass LotsOfGreetings extends Component {\n  render() {\n    return (\n      <View style={{alignItems: 'center'}}>\n        <Greeting name='Rexxar' />\n        <Greeting name='Jaina' />\n      </View>\n    );\n  }\n}\n```\n\n### State\n通过 `Props`,`State` 控制组件。`Props` 在父组件中指定，一经指定，不能改变。对于需要改变的组件，要使用 `state`。\n\n一般要在 `constructor` 中初始化 `state`(通过 `getInitialState` 方法为es5方法，已被淘汰)，需要修改时调用 `setState`。\n\n```javascript\nclass Blink extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { showText: true };\n\n    // 每1000毫秒对showText状态做一次取反操作\n    setInterval(() => {\n      this.setState({ showText: !this.state.showText });\n    }, 1000);\n  }\n\n  render() {\n    // 根据当前showText的值决定是否显示text内容\n    let display = this.state.showText ? this.props.text : ' ';\n    return (\n      <Text>{display}</Text>\n    );\n  }\n}\n\nclass BlinkApp extends Component {\n  render() {\n    return (\n      <View>\n        <Blink text='I love to blink' />\n        <Blink text='Yes blinking is so great' />\n      </View>\n    );\n  }\n}\n```\n\n这个例子中 text 是固定的，所以用 `Props` 在父控件创建的时候传入。在构造函数的时候创建了 `State` 和其属性 `showText`。当然，还可以再这里初始化任意多个属性，用逗号隔开，相当于创建一个 `state` 对象。使用的时候直接可以点出来：`this.state.showText`。想要修改的时候调用 `this.setState()` 方法，将要修改的属性组成对象传入。\n\n拓展：可以学习一下状态容器如：`Redux`。另外，关于 `state` 的更多原理，可以参考 `React.js`。\n\n### StyleSheet\n相当于一个样式合集：\n\n```javascript\nimport { AppRegistry, StyleSheet, Text, View } from 'react-native';\n\nconst styles = StyleSheet.create({\n  bigblue: {\n    color: 'blue',\n    fontWeight: 'bold',\n    fontSize: 30,\n  },\n});\n\n//使用：\n<View style={styles.bigblue}/>\n```\n\n### flex\n在 `style` 中通过flex可以灵活地将组件撑满整个屏幕。\n\n组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的 `width` 和 `height`，也没有设定 `flex`，则父容器的尺寸为零。其子组件如果使用了 `flex`，也是无法显示的。\n\n### flexbox布局\n#### flexDirection\n在 `style` 中指定布局的**主轴**，是 `row` 还是 `column`。默认是 `column`。\n\n#### justifyContent\n在 `style` 中指定元素沿着**主轴**的排序方式。**注意**，这个属性是定义在父控件，作用在子控件上的。\n\n包括 `flex-start`,`flex-end`,`center`,`space-between`,`space-around`。\n\n前面三个不说了，后面两个说一下：\n1. `space-between`:左右各一个子控件，剩余的子控件均匀的分布在中间。如果只有一个，那么这个居左。\n2. `space-around`:所有子控件均匀的分布，如果只有一个，那么这个居中。\n\n#### alignItems\n在 `style` 中指定布局的**次轴**的排序方式。**注意**，这个属性是定义在父控件，作用在子控件上的。\n\n包括 `flex-start`,`flex-end`,`center`,`stretch`。\n\n其中 `stretch` 表示拉伸撑满次轴，前提是不设置子控件宽度。\n\n### 布局样式\n#### 属性\n除了上面说的那些，再摘取一些有用的 `style` 中的属性：\n\n1. `border` 系列:设置边框的宽度，`borderTopWidth`,`borderLeftWidth`...上下左右都可以分别设置。\n2. `alignSelf`:类似于 `alignItems`，只不过这个属性定义在子控件中，重写父控件的 `alignItems`。因为子控件在次轴上没有必要完全按照父控件的控制，那样太死板了，`alignSelf` 的目的就是搞这个特殊。\n3. `left` 系列:定义子控件到父控件的左边距。**注意**，要先设置 `position:absolute` 否则无效。类似的还有 `right`,`top`,`bottom`。\n4. `flexWrap`:当子控件到底后自动换行。`wrap` 为自动换行，`noWrap` 为不换行。**注意**，要定义在父控件中。\n5. `margin` 系列:设置子控件到相邻子控件的间隔。\n6. `max`,`min` 系列:设置控件的最大(小)宽度(高度).\n7. `padding` 系列:在父控件内设置，设置子控件的起点。\n8. `position`:分为 `absolute` 绝对，`relative`相对。默认是相对的，如果要使用 `left` 等样式，就要使用绝对布局。**绝对布局的子控件的大小不会影响父控件的大小**\n9. `zIndex`: 控制控件的绘制层级，该属性越大，越绘在顶层。\n\n#### 使用\n一般使用方式:\n```JSX\nstyle={{height:xx,width:xx}}\n```\n\n如果有多个对象，需要用数组的方式传入：\n\n```JSX\nstyle={[{height:xx,width:xx,},{height:yy,wudth:yy,}]}\n```\n\n如果有相同的属性重复赋值，则以后一个覆盖前一个为准。\n\n### TextInput\n#### 例子\n文本输入组件，先看一个例子：\n\n```javscript\nclass UselessTextInput extends Component {\n  render() {\n    return (\n      <TextInput\n        {...this.props} // Inherit any props passed to it; e.g., multiline, numberOfLines below\n        editable = {true}\n        maxLength = {40}\n      />\n    );\n  }\n}\n\nclass UselessTextInputMultiline extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      text: 'Useless Multiline Placeholder',\n    };\n  }\n\n  render() {\n    return (\n     <View style={{\n       backgroundColor: this.state.text,\n       borderBottomColor: '#000000',\n       borderBottomWidth: 1 }}\n     >\n       <UselessTextInput\n         multiline = {true}\n         numberOfLines = {4}\n         onChangeText={(text) => this.setState({text})}\n         value={this.state.text}\n       />\n     </View>\n    );\n  }\n}\n```\n\n这里为什么要把这个例子贴出来呢？主要有**两个要点**：\n\n首先，`{...this.props}` 的语法。这里`{}` 还是表示使用JS语法的意思。`...` 是es6的语法，叫做**展开运算符**。可以看看下面这个例子：\n\n```javascript\nvar array = [1,2,3,4,5,6,7];\nconsole.log(array);\n//输出 [1, 2, 3, 4, 5, 6, 7]\nconsole.log(...array);\n//输出 1 2 3 4 5 6 7\n```\n\n`this.props` 是个对象，肯定不能放在 Component 中，但是用了**展开运算符**，里面的属性就全部被展开了，也就符合了 JSX 的语法。不只是 `this.props` **任何对象都可以用这种展开的方式将参数传入 Component**。不过不建议滥用，因为容易将很多多余参数传入，可能产生一些不易排查的问题。\n\n\n其次，`onChangeText={(text) => this.setState({text})}`。一般 `setState()` 中都是对象，为什么这里只是 `text`？这也是es6的语法，在键和值相等的时候可以省略 `{text:text}` 为 `{text}`。也就是本例的 `this.setState({text})`。\n\n#### 部分属性\n1. `autoFocus`:在 `componentDidMount` 后是否自动获得焦点。\n2. `defaultValue`:提供文本框的初始值。\n3. `editable`:文本框是否可编辑\n4. `maxLength`:文本框中最长字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。\n5. `multiline`:是否可以多行，默认 false\n6. `onFocus`,`onBlur`,`onEndEditing`,`onSubmitEditing`:输入框在各种情况下的回调函数。\n7. `onChange`:当输入框内容改变时，回调该函数\n8. `onChangeText`:当输入框内容改变时，回调该函数。改变后的文字内容将作为参数传入。\n9. `placeholder`:占位符\n10. `placeholderTextColor`:占位符颜色.(注意，貌似没有 placeholderTextSize 这个属性)\n11. `value`:输入框内显示的值 \n12. `underlineColorAndroid`:这是 android 特有的属性，非常的坑。文档里是这么说的“文本框的下划线颜色”，其实不是这个意思，这个属性设置的是整个文本框的颜色。比如在 iOS 上，直接设置 `backgroundColor='red'` 就能把文本框设成红色，但是 android 不然，在 background 之上还有一层，就是这个 `underlineColorAndroid` 需要将这个也设置成红色，才能正确显示成红色。\n13. 这里还有一个坑点，就是一定一定一定设置 TextInput 的高度。不然即使 TextInput 大小为0，任然会显示 placeholder ，这就会导致一直没有点击效果。所以**一个调试技巧：给控件设置醒目的背景颜色，这样有助于了解控件的布局情况，方便调试。**\n\n#### 方法\n1. `isFocusd()`:判断当前输入框是否获得焦点。\n2. `clear()`:清空输入框内容。\n\n\n### ScrollView\n#### 属性\n1. `contentContainerStyle`:比较重要的属性，相当于在 ScrollView 中内嵌了一个 View，这个属性就是控制这个内嵌 View 的。\n2. `horizontal`:内容水平排布，不知道和 `flexDirection` 有什么区别\n3. `keyboardDismissMode`:用户拖拽视图是否隐藏软键盘。`none`,`on-drag`\n4. `keyboardShouldPersistTaps`:控制是否在当点击文本输入框以外区域时，自动隐藏软键盘。true 不隐藏，false 隐藏。默认 false\n5. `onScroll`:滚动的时候以一定频率回调该函数。\n6. `refreshControll`:指定 RefreshController 组件，用于为 ScrollView 提供下拉刷新功能。\n7. `pagingEnabled`:滚动条停在整数倍位置。\n8. `scrollEventEnabled`:控制视图能否滚动。\n\n#### 方法\n1. `scrollTo`:滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。\n\n```javascript\nscrollTo({x: 0, y: 0, animated: true})\n```\n\n#### RefreshControl\n这一组件可以用在 ScrollView 或 ListView 内部，为其添加下拉刷新的功能。当 ScrollView 处于竖直方向上的起点位置时，此时下拉会触发一个 `onRefresh` 事件。有两个常用属性：\n\n1. `onRefresh`:在视图开始刷新时调用。\n2. `refreshing`: 视图是否应该在刷新时显示指示器。一般是从网络获取数据的时候是 true，获取完数据为 false\n\n#### 示例：用Scrollview实现带下拉刷新的Tableview\n\n```javascript\n// 每一个row的view\nconst Row = React.createClass({\n  _onClick: function() {\n    this.props.onClick(this.props.data);\n  },\n  render: function() {\n    return (\n     <TouchableWithoutFeedback onPress={this._onClick} >\n        <View style={styles.row}>\n          <Text style={styles.text}>\n            {this.props.data.text + ' (' + this.props.data.clicks + ' clicks)'}\n          </Text>\n        </View>\n      </TouchableWithoutFeedback>\n    );\n  },\n});\n\nconst RefreshControlExample = React.createClass({\n  statics: {\n    title: '<RefreshControl>',\n    description: 'Adds pull-to-refresh support to a scrollview.'\n  },\n\n  getInitialState() {\n    return {\n      isRefreshing: false,\n      loaded: 0,\n      rowData: Array.from(new Array(20)).map(\n        (val, i) => ({text: 'Initial row ' + i, clicks: 0})),\n    };\n  },\n\n  _onClick(row) {\n    row.clicks++;\n    this.setState({\n      rowData: this.state.rowData,\n    });\n  },\n\n  render() {\n    const rows = this.state.rowData.map((row, ii) => {\n      return <Row key={ii} data={row} onClick={this._onClick}/>;\n    });\n    return (\n      <ScrollView\n        style={styles.scrollview}\n        refreshControl={\n          <RefreshControl\n            refreshing={this.state.isRefreshing}\n            onRefresh={this._onRefresh}\n            tintColor=\"#ff0000\"\n            title=\"Loading...\"\n            titleColor=\"#00ff00\"\n            colors={['#ff0000', '#00ff00', '#0000ff']}\n            progressBackgroundColor=\"#ffff00\"\n          />\n        }>\n        {rows}\n      </ScrollView>\n    );\n  },\n\n  _onRefresh() {\n    this.setState({isRefreshing: true});\n    setTimeout(() => {\n      // prepend 10 items\n      const rowData = Array.from(new Array(10))\n      .map((val, i) => ({\n        text: 'Loaded row ' + (+this.state.loaded + i),\n        clicks: 0,\n      }))\n      .concat(this.state.rowData);\n\n      this.setState({\n        loaded: this.state.loaded + 10,\n        isRefreshing: false,\n        rowData: rowData,\n      });\n    }, 5000);\n  },\n});\n```\n\n省略了styleSheet。这里主要注意几点：\n1. 譬如封装一个组件 Row，其中有点击事件的处理。iOS 中一般使用代理。这里由于js的特性，可以把外部的点击方法传入组件内，再由组件的点击事件调用。\n2. 注意 `map()` 方法的使用。这也就是用 scrollview 实现 tableview 的方式。\n3. 在 `render` 里可以插入js方法，如上面的 `{row}`,只要方法返回的是JSX的 component就行。（貌似component里的属性只能用展开运算符才能插入，用js方法返回的方式一直都报错）\n4. `RefreshControl` 看起来也就是一个 component，由 scrollview 控制什么时候展示，怎么展示。\n5. 如果想要自定义上拉刷新，就得知道 `contentOffset` 可以研究一下。\n\n### ListView\nListView设计到各种优化，以及各种方法，掌握的不是很好，需要进一步学习。\n#### 属性\n1. ScrollView 全部属性\n2. `dataSource`:`ListView.DataSource实例`。\n3. `initialListSize`:指定在组件刚挂载的时候渲染多少行数据。(试了下没看出有什么效果。)\n4. `onChangeVisibleRows`:显示区域的 cell 变化时调用。（api 和实际使用有出入，需要实际使用的时候检验，不过这个东西好像没什么太大用）\n5. `onEndReachedThreshold`:调用 `onEndReached` 之前的临界值.\n6. `onEndReached`:滚动到底部时的回调，如果数据不满足一屏，会立即回调，需要手动标记过滤。\n7. `pageSize`:每次事件循环（每帧）渲染的行数。默认是1。（好像不需要自己设置，不知道设了有什么影响）\n8. `removeClippedSubviews`:说是提升性能默认开启，不知道具体有啥用。\n9. `renderHeader`,`renderFooter`:页头，页脚。\n10. `renderRow`: cell 的实现，方法为`(rowData, sectionID, rowID, highlightRow) => renderable`\n11. `renderSeparator`: `(sectionID, rowID, adjacentRowHighlighted) => renderable` 一个可渲染的组件会被渲染在每一行下面.如果被点击了，就会显示出来。没什么太大用。如果要用，要在 return 的 view 里添加 `key`，最好看一下示例。\n12. `scrollRenderAheadDistance`:距离多少开始渲染下一行。\n13. `renderScrollComponent`:不知道怎么用。\n14. `renderSectionHeader`:每个小节(section)渲染一个粘性的标题。`(sectionData, sectionID) => renderable` 其中 `sectionData` 就是section内内容的数组。\n\n#### 一些方法\n1. listview 只是提供了渲染其中 cell 的功能，默认是 cell 竖着排下来。那么如果要实现成 gridview 之类该怎么做呢？就是给 listview 附上从 scrollview 中继承来的 `contentContainerStyle` 这个 style 用来控制其中子视图的样式，只要在其中将 `flexDirection:‘row’,justifyContent: 'space-around',flexWrap: 'wrap'` 这样一设置。就能达到横排 cell，并且自动换行的效果。\n\n### 网络\n感觉没什么好写的，暂且不表\n\n### navigator\n暂时还是用原生的 navigator，感觉 navigator 不太好用，所以暂且不表。\n\n如果需要使用，可以查看这篇[教程](http://bbs.reactnative.cn/topic/20/新手理解navigator的教程)\n\n###\n\n\n\n\n\n\n","slug":"RN使用方式","published":1,"updated":"2016-12-15T17:24:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpl00157hzgrhfe0clf","content":"<p>这里基于0.39的官方文档，列举了一些需要知道的点。</p>\n<a id=\"more\"></a>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p><code>index.ios.js</code> 作为一个组件的注册集合以及入口，在这里，将所有组件像这样注册。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloApp'</span>, () =&gt; HellodApp);</div><div class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloWorldApp'</span>, () =&gt; HelloWorldApp);</div></pre></td></tr></table></figure>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>组件在创建的时候传入 <code>Props</code> 来完成定制，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;pic&#125; style=&#123;&#123;width: <span class=\"number\">193</span>, height: <span class=\"number\">110</span>&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>其中 <code>source</code>,<code>style</code> 都是传入 image 的 <code>Props</code>。其中 <code>pic</code> 表示一个js对象，类似后面的 <code>{width: 193, height: 110}</code>。</p>\n<p><code>{pic}</code> 外面有个括号，表示括号内是一个js变量或者表达式，需要执行后取值，以此<strong>在JSX中嵌入js语句</strong>。</p>\n<h4 id=\"自定义组件的-Props\"><a href=\"#自定义组件的-Props\" class=\"headerlink\" title=\"自定义组件的 Props\"></a>自定义组件的 Props</h4><p>自定义组件可以提高复用性。使用时在函数中引用 <code>this.props.属性名</code>，例如下面的 <code>name</code> 属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LotsOfGreetings</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt;</div><div class=\"line\">        &lt;Greeting name='Rexxar' /&gt;</div><div class=\"line\">        &lt;Greeting name='Jaina' /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>通过 <code>Props</code>,<code>State</code> 控制组件。<code>Props</code> 在父组件中指定，一经指定，不能改变。对于需要改变的组件，要使用 <code>state</code>。</p>\n<p>一般要在 <code>constructor</code> 中初始化 <code>state</code>(通过 <code>getInitialState</code> 方法为es5方法，已被淘汰)，需要修改时调用 <code>setState</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blink</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; showText: <span class=\"literal\">true</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 每1000毫秒对showText状态做一次取反操作</span></div><div class=\"line\">    setInterval(() =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; showText: !<span class=\"keyword\">this</span>.state.showText &#125;);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 根据当前showText的值决定是否显示text内容</span></div><div class=\"line\">    <span class=\"keyword\">let</span> display = <span class=\"keyword\">this</span>.state.showText ? <span class=\"keyword\">this</span>.props.text : <span class=\"string\">' '</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlinkApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View&gt;</div><div class=\"line\">        &lt;Blink text='I love to blink' /&gt;</div><div class=\"line\">        &lt;Blink text='Yes blinking is so great' /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子中 text 是固定的，所以用 <code>Props</code> 在父控件创建的时候传入。在构造函数的时候创建了 <code>State</code> 和其属性 <code>showText</code>。当然，还可以再这里初始化任意多个属性，用逗号隔开，相当于创建一个 <code>state</code> 对象。使用的时候直接可以点出来：<code>this.state.showText</code>。想要修改的时候调用 <code>this.setState()</code> 方法，将要修改的属性组成对象传入。</p>\n<p>拓展：可以学习一下状态容器如：<code>Redux</code>。另外，关于 <code>state</code> 的更多原理，可以参考 <code>React.js</code>。</p>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>相当于一个样式合集：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, StyleSheet, Text, View &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</div><div class=\"line\">  bigblue: &#123;</div><div class=\"line\">    color: <span class=\"string\">'blue'</span>,</div><div class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</div><div class=\"line\">    fontSize: <span class=\"number\">30</span>,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用：</span></div><div class=\"line\">&lt;View style=&#123;styles.bigblue&#125;/&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p>在 <code>style</code> 中通过flex可以灵活地将组件撑满整个屏幕。</p>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的 <code>width</code> 和 <code>height</code>，也没有设定 <code>flex</code>，则父容器的尺寸为零。其子组件如果使用了 <code>flex</code>，也是无法显示的。</p>\n<h3 id=\"flexbox布局\"><a href=\"#flexbox布局\" class=\"headerlink\" title=\"flexbox布局\"></a>flexbox布局</h3><h4 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h4><p>在 <code>style</code> 中指定布局的<strong>主轴</strong>，是 <code>row</code> 还是 <code>column</code>。默认是 <code>column</code>。</p>\n<h4 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h4><p>在 <code>style</code> 中指定元素沿着<strong>主轴</strong>的排序方式。<strong>注意</strong>，这个属性是定义在父控件，作用在子控件上的。</p>\n<p>包括 <code>flex-start</code>,<code>flex-end</code>,<code>center</code>,<code>space-between</code>,<code>space-around</code>。</p>\n<p>前面三个不说了，后面两个说一下：</p>\n<ol>\n<li><code>space-between</code>:左右各一个子控件，剩余的子控件均匀的分布在中间。如果只有一个，那么这个居左。</li>\n<li><code>space-around</code>:所有子控件均匀的分布，如果只有一个，那么这个居中。</li>\n</ol>\n<h4 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h4><p>在 <code>style</code> 中指定布局的<strong>次轴</strong>的排序方式。<strong>注意</strong>，这个属性是定义在父控件，作用在子控件上的。</p>\n<p>包括 <code>flex-start</code>,<code>flex-end</code>,<code>center</code>,<code>stretch</code>。</p>\n<p>其中 <code>stretch</code> 表示拉伸撑满次轴，前提是不设置子控件宽度。</p>\n<h3 id=\"布局样式\"><a href=\"#布局样式\" class=\"headerlink\" title=\"布局样式\"></a>布局样式</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>除了上面说的那些，再摘取一些有用的 <code>style</code> 中的属性：</p>\n<ol>\n<li><code>border</code> 系列:设置边框的宽度，<code>borderTopWidth</code>,<code>borderLeftWidth</code>…上下左右都可以分别设置。</li>\n<li><code>alignSelf</code>:类似于 <code>alignItems</code>，只不过这个属性定义在子控件中，重写父控件的 <code>alignItems</code>。因为子控件在次轴上没有必要完全按照父控件的控制，那样太死板了，<code>alignSelf</code> 的目的就是搞这个特殊。</li>\n<li><code>left</code> 系列:定义子控件到父控件的左边距。<strong>注意</strong>，要先设置 <code>position:absolute</code> 否则无效。类似的还有 <code>right</code>,<code>top</code>,<code>bottom</code>。</li>\n<li><code>flexWrap</code>:当子控件到底后自动换行。<code>wrap</code> 为自动换行，<code>noWrap</code> 为不换行。<strong>注意</strong>，要定义在父控件中。</li>\n<li><code>margin</code> 系列:设置子控件到相邻子控件的间隔。</li>\n<li><code>max</code>,<code>min</code> 系列:设置控件的最大(小)宽度(高度).</li>\n<li><code>padding</code> 系列:在父控件内设置，设置子控件的起点。</li>\n<li><code>position</code>:分为 <code>absolute</code> 绝对，<code>relative</code>相对。默认是相对的，如果要使用 <code>left</code> 等样式，就要使用绝对布局。<strong>绝对布局的子控件的大小不会影响父控件的大小</strong></li>\n<li><code>zIndex</code>: 控制控件的绘制层级，该属性越大，越绘在顶层。</li>\n</ol>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>一般使用方式:<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">style=&#123;&#123;height:xx,width:xx&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个对象，需要用数组的方式传入：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">style=&#123;[&#123;height:xx,width:xx,&#125;,&#123;height:yy,wudth:yy,&#125;]&#125;</div></pre></td></tr></table></figure>\n<p>如果有相同的属性重复赋值，则以后一个覆盖前一个为准。</p>\n<h3 id=\"TextInput\"><a href=\"#TextInput\" class=\"headerlink\" title=\"TextInput\"></a>TextInput</h3><h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p>文本输入组件，先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UselessTextInput extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;TextInput</div><div class=\"line\">        &#123;...this.props&#125; // Inherit any props passed to it; e.g., multiline, numberOfLines below</div><div class=\"line\">        editable = &#123;true&#125;</div><div class=\"line\">        maxLength = &#123;40&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class UselessTextInputMultiline extends Component &#123;</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      text: &apos;Useless Multiline Placeholder&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">     &lt;View style=&#123;&#123;</div><div class=\"line\">       backgroundColor: this.state.text,</div><div class=\"line\">       borderBottomColor: &apos;#000000&apos;,</div><div class=\"line\">       borderBottomWidth: 1 &#125;&#125;</div><div class=\"line\">     &gt;</div><div class=\"line\">       &lt;UselessTextInput</div><div class=\"line\">         multiline = &#123;true&#125;</div><div class=\"line\">         numberOfLines = &#123;4&#125;</div><div class=\"line\">         onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125;</div><div class=\"line\">         value=&#123;this.state.text&#125;</div><div class=\"line\">       /&gt;</div><div class=\"line\">     &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里为什么要把这个例子贴出来呢？主要有<strong>两个要点</strong>：</p>\n<p>首先，<code>{...this.props}</code> 的语法。这里<code>{}</code> 还是表示使用JS语法的意思。<code>...</code> 是es6的语法，叫做<strong>展开运算符</strong>。可以看看下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array);</div><div class=\"line\"><span class=\"comment\">//输出 [1, 2, 3, 4, 5, 6, 7]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(...array);</div><div class=\"line\"><span class=\"comment\">//输出 1 2 3 4 5 6 7</span></div></pre></td></tr></table></figure>\n<p><code>this.props</code> 是个对象，肯定不能放在 Component 中，但是用了<strong>展开运算符</strong>，里面的属性就全部被展开了，也就符合了 JSX 的语法。不只是 <code>this.props</code> <strong>任何对象都可以用这种展开的方式将参数传入 Component</strong>。不过不建议滥用，因为容易将很多多余参数传入，可能产生一些不易排查的问题。</p>\n<p>其次，<code>onChangeText={(text) =&gt; this.setState({text})}</code>。一般 <code>setState()</code> 中都是对象，为什么这里只是 <code>text</code>？这也是es6的语法，在键和值相等的时候可以省略 <code>{text:text}</code> 为 <code>{text}</code>。也就是本例的 <code>this.setState({text})</code>。</p>\n<h4 id=\"部分属性\"><a href=\"#部分属性\" class=\"headerlink\" title=\"部分属性\"></a>部分属性</h4><ol>\n<li><code>autoFocus</code>:在 <code>componentDidMount</code> 后是否自动获得焦点。</li>\n<li><code>defaultValue</code>:提供文本框的初始值。</li>\n<li><code>editable</code>:文本框是否可编辑</li>\n<li><code>maxLength</code>:文本框中最长字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。</li>\n<li><code>multiline</code>:是否可以多行，默认 false</li>\n<li><code>onFocus</code>,<code>onBlur</code>,<code>onEndEditing</code>,<code>onSubmitEditing</code>:输入框在各种情况下的回调函数。</li>\n<li><code>onChange</code>:当输入框内容改变时，回调该函数</li>\n<li><code>onChangeText</code>:当输入框内容改变时，回调该函数。改变后的文字内容将作为参数传入。</li>\n<li><code>placeholder</code>:占位符</li>\n<li><code>placeholderTextColor</code>:占位符颜色.(注意，貌似没有 placeholderTextSize 这个属性)</li>\n<li><code>value</code>:输入框内显示的值 </li>\n<li><code>underlineColorAndroid</code>:这是 android 特有的属性，非常的坑。文档里是这么说的“文本框的下划线颜色”，其实不是这个意思，这个属性设置的是整个文本框的颜色。比如在 iOS 上，直接设置 <code>backgroundColor=&#39;red&#39;</code> 就能把文本框设成红色，但是 android 不然，在 background 之上还有一层，就是这个 <code>underlineColorAndroid</code> 需要将这个也设置成红色，才能正确显示成红色。</li>\n<li>这里还有一个坑点，就是一定一定一定设置 TextInput 的高度。不然即使 TextInput 大小为0，任然会显示 placeholder ，这就会导致一直没有点击效果。所以<strong>一个调试技巧：给控件设置醒目的背景颜色，这样有助于了解控件的布局情况，方便调试。</strong></li>\n</ol>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ol>\n<li><code>isFocusd()</code>:判断当前输入框是否获得焦点。</li>\n<li><code>clear()</code>:清空输入框内容。</li>\n</ol>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ol>\n<li><code>contentContainerStyle</code>:比较重要的属性，相当于在 ScrollView 中内嵌了一个 View，这个属性就是控制这个内嵌 View 的。</li>\n<li><code>horizontal</code>:内容水平排布，不知道和 <code>flexDirection</code> 有什么区别</li>\n<li><code>keyboardDismissMode</code>:用户拖拽视图是否隐藏软键盘。<code>none</code>,<code>on-drag</code></li>\n<li><code>keyboardShouldPersistTaps</code>:控制是否在当点击文本输入框以外区域时，自动隐藏软键盘。true 不隐藏，false 隐藏。默认 false</li>\n<li><code>onScroll</code>:滚动的时候以一定频率回调该函数。</li>\n<li><code>refreshControll</code>:指定 RefreshController 组件，用于为 ScrollView 提供下拉刷新功能。</li>\n<li><code>pagingEnabled</code>:滚动条停在整数倍位置。</li>\n<li><code>scrollEventEnabled</code>:控制视图能否滚动。</li>\n</ol>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ol>\n<li><code>scrollTo</code>:滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollTo(&#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, animated: <span class=\"literal\">true</span>&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"RefreshControl\"><a href=\"#RefreshControl\" class=\"headerlink\" title=\"RefreshControl\"></a>RefreshControl</h4><p>这一组件可以用在 ScrollView 或 ListView 内部，为其添加下拉刷新的功能。当 ScrollView 处于竖直方向上的起点位置时，此时下拉会触发一个 <code>onRefresh</code> 事件。有两个常用属性：</p>\n<ol>\n<li><code>onRefresh</code>:在视图开始刷新时调用。</li>\n<li><code>refreshing</code>: 视图是否应该在刷新时显示指示器。一般是从网络获取数据的时候是 true，获取完数据为 false</li>\n</ol>\n<h4 id=\"示例：用Scrollview实现带下拉刷新的Tableview\"><a href=\"#示例：用Scrollview实现带下拉刷新的Tableview\" class=\"headerlink\" title=\"示例：用Scrollview实现带下拉刷新的Tableview\"></a>示例：用Scrollview实现带下拉刷新的Tableview</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每一个row的view</span></div><div class=\"line\"><span class=\"keyword\">const</span> Row = React.createClass(&#123;</div><div class=\"line\">  _onClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.props.onClick(<span class=\"keyword\">this</span>.props.data);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">     &lt;TouchableWithoutFeedback onPress=&#123;this._onClick&#125; &gt;</div><div class=\"line\">        &lt;View style=&#123;styles.row&#125;&gt;</div><div class=\"line\">          &lt;Text style=&#123;styles.text&#125;&gt;</div><div class=\"line\">            &#123;this.props.data.text + ' (' + this.props.data.clicks + ' clicks)'&#125;</div><div class=\"line\">          &lt;/Text&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      &lt;/TouchableWithoutFeedback&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> RefreshControlExample = React.createClass(&#123;</div><div class=\"line\">  statics: &#123;</div><div class=\"line\">    title: <span class=\"string\">'&lt;RefreshControl&gt;'</span>,</div><div class=\"line\">    description: <span class=\"string\">'Adds pull-to-refresh support to a scrollview.'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  getInitialState() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      isRefreshing: <span class=\"literal\">false</span>,</div><div class=\"line\">      loaded: <span class=\"number\">0</span>,</div><div class=\"line\">      rowData: <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">20</span>)).map(</div><div class=\"line\">        (val, i) =&gt; (&#123;text: <span class=\"string\">'Initial row '</span> + i, clicks: <span class=\"number\">0</span>&#125;)),</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  _onClick(row) &#123;</div><div class=\"line\">    row.clicks++;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      rowData: <span class=\"keyword\">this</span>.state.rowData,</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">this</span>.state.rowData.map((row, ii) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &lt;Row key=&#123;ii&#125; data=&#123;row&#125; onClick=&#123;this._onClick&#125;/&gt;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;ScrollView</div><div class=\"line\">        style=&#123;styles.scrollview&#125;</div><div class=\"line\">        refreshControl=&#123;</div><div class=\"line\">          &lt;RefreshControl</div><div class=\"line\">            refreshing=&#123;this.state.isRefreshing&#125;</div><div class=\"line\">            onRefresh=&#123;this._onRefresh&#125;</div><div class=\"line\">            tintColor=\"#ff0000\"</div><div class=\"line\">            title=\"Loading...\"</div><div class=\"line\">            titleColor=\"#00ff00\"</div><div class=\"line\">            colors=&#123;['#ff0000', '#00ff00', '#0000ff']&#125;</div><div class=\"line\">            progressBackgroundColor=\"#ffff00\"</div><div class=\"line\">          /&gt;</div><div class=\"line\">        &#125;&gt;</div><div class=\"line\">        &#123;rows&#125;</div><div class=\"line\">      &lt;/ScrollView&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  _onRefresh() &#123;</div><div class=\"line\">    this.setState(&#123;isRefreshing: true&#125;);</div><div class=\"line\">    setTimeout(() =&gt; &#123;</div><div class=\"line\">      // prepend 10 items</div><div class=\"line\">      const rowData = Array.from(new Array(10))</div><div class=\"line\">      .map((val, i) =&gt; (&#123;</div><div class=\"line\">        text: 'Loaded row ' + (+this.state.loaded + i),</div><div class=\"line\">        clicks: 0,</div><div class=\"line\">      &#125;))</div><div class=\"line\">      .concat(this.state.rowData);</div><div class=\"line\"></div><div class=\"line\">      this.setState(&#123;</div><div class=\"line\">        loaded: this.state.loaded + 10,</div><div class=\"line\">        isRefreshing: false,</div><div class=\"line\">        rowData: rowData,</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;, 5000);</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>省略了styleSheet。这里主要注意几点：</p>\n<ol>\n<li>譬如封装一个组件 Row，其中有点击事件的处理。iOS 中一般使用代理。这里由于js的特性，可以把外部的点击方法传入组件内，再由组件的点击事件调用。</li>\n<li>注意 <code>map()</code> 方法的使用。这也就是用 scrollview 实现 tableview 的方式。</li>\n<li>在 <code>render</code> 里可以插入js方法，如上面的 <code>{row}</code>,只要方法返回的是JSX的 component就行。（貌似component里的属性只能用展开运算符才能插入，用js方法返回的方式一直都报错）</li>\n<li><code>RefreshControl</code> 看起来也就是一个 component，由 scrollview 控制什么时候展示，怎么展示。</li>\n<li>如果想要自定义上拉刷新，就得知道 <code>contentOffset</code> 可以研究一下。</li>\n</ol>\n<h3 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h3><p>ListView设计到各种优化，以及各种方法，掌握的不是很好，需要进一步学习。</p>\n<h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ol>\n<li>ScrollView 全部属性</li>\n<li><code>dataSource</code>:<code>ListView.DataSource实例</code>。</li>\n<li><code>initialListSize</code>:指定在组件刚挂载的时候渲染多少行数据。(试了下没看出有什么效果。)</li>\n<li><code>onChangeVisibleRows</code>:显示区域的 cell 变化时调用。（api 和实际使用有出入，需要实际使用的时候检验，不过这个东西好像没什么太大用）</li>\n<li><code>onEndReachedThreshold</code>:调用 <code>onEndReached</code> 之前的临界值.</li>\n<li><code>onEndReached</code>:滚动到底部时的回调，如果数据不满足一屏，会立即回调，需要手动标记过滤。</li>\n<li><code>pageSize</code>:每次事件循环（每帧）渲染的行数。默认是1。（好像不需要自己设置，不知道设了有什么影响）</li>\n<li><code>removeClippedSubviews</code>:说是提升性能默认开启，不知道具体有啥用。</li>\n<li><code>renderHeader</code>,<code>renderFooter</code>:页头，页脚。</li>\n<li><code>renderRow</code>: cell 的实现，方法为<code>(rowData, sectionID, rowID, highlightRow) =&gt; renderable</code></li>\n<li><code>renderSeparator</code>: <code>(sectionID, rowID, adjacentRowHighlighted) =&gt; renderable</code> 一个可渲染的组件会被渲染在每一行下面.如果被点击了，就会显示出来。没什么太大用。如果要用，要在 return 的 view 里添加 <code>key</code>，最好看一下示例。</li>\n<li><code>scrollRenderAheadDistance</code>:距离多少开始渲染下一行。</li>\n<li><code>renderScrollComponent</code>:不知道怎么用。</li>\n<li><code>renderSectionHeader</code>:每个小节(section)渲染一个粘性的标题。<code>(sectionData, sectionID) =&gt; renderable</code> 其中 <code>sectionData</code> 就是section内内容的数组。</li>\n</ol>\n<h4 id=\"一些方法\"><a href=\"#一些方法\" class=\"headerlink\" title=\"一些方法\"></a>一些方法</h4><ol>\n<li>listview 只是提供了渲染其中 cell 的功能，默认是 cell 竖着排下来。那么如果要实现成 gridview 之类该怎么做呢？就是给 listview 附上从 scrollview 中继承来的 <code>contentContainerStyle</code> 这个 style 用来控制其中子视图的样式，只要在其中将 <code>flexDirection:‘row’,justifyContent: &#39;space-around&#39;,flexWrap: &#39;wrap&#39;</code> 这样一设置。就能达到横排 cell，并且自动换行的效果。</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p>感觉没什么好写的，暂且不表</p>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p>暂时还是用原生的 navigator，感觉 navigator 不太好用，所以暂且不表。</p>\n<p>如果需要使用，可以查看这篇<a href=\"http://bbs.reactnative.cn/topic/20/新手理解navigator的教程\" target=\"_blank\" rel=\"external\">教程</a></p>\n<p>###</p>\n","excerpt":"<p>这里基于0.39的官方文档，列举了一些需要知道的点。</p>","more":"<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p><code>index.ios.js</code> 作为一个组件的注册集合以及入口，在这里，将所有组件像这样注册。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloApp'</span>, () =&gt; HellodApp);</div><div class=\"line\">AppRegistry.registerComponent(<span class=\"string\">'HelloWorldApp'</span>, () =&gt; HelloWorldApp);</div></pre></td></tr></table></figure>\n<h3 id=\"Props\"><a href=\"#Props\" class=\"headerlink\" title=\"Props\"></a>Props</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>组件在创建的时候传入 <code>Props</code> 来完成定制，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;pic&#125; style=&#123;&#123;width: <span class=\"number\">193</span>, height: <span class=\"number\">110</span>&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>其中 <code>source</code>,<code>style</code> 都是传入 image 的 <code>Props</code>。其中 <code>pic</code> 表示一个js对象，类似后面的 <code>{width: 193, height: 110}</code>。</p>\n<p><code>{pic}</code> 外面有个括号，表示括号内是一个js变量或者表达式，需要执行后取值，以此<strong>在JSX中嵌入js语句</strong>。</p>\n<h4 id=\"自定义组件的-Props\"><a href=\"#自定义组件的-Props\" class=\"headerlink\" title=\"自定义组件的 Props\"></a>自定义组件的 Props</h4><p>自定义组件可以提高复用性。使用时在函数中引用 <code>this.props.属性名</code>，例如下面的 <code>name</code> 属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LotsOfGreetings</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt;</div><div class=\"line\">        &lt;Greeting name='Rexxar' /&gt;</div><div class=\"line\">        &lt;Greeting name='Jaina' /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>通过 <code>Props</code>,<code>State</code> 控制组件。<code>Props</code> 在父组件中指定，一经指定，不能改变。对于需要改变的组件，要使用 <code>state</code>。</p>\n<p>一般要在 <code>constructor</code> 中初始化 <code>state</code>(通过 <code>getInitialState</code> 方法为es5方法，已被淘汰)，需要修改时调用 <code>setState</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Blink</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; showText: <span class=\"literal\">true</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 每1000毫秒对showText状态做一次取反操作</span></div><div class=\"line\">    setInterval(() =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; showText: !<span class=\"keyword\">this</span>.state.showText &#125;);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"comment\">// 根据当前showText的值决定是否显示text内容</span></div><div class=\"line\">    <span class=\"keyword\">let</span> display = <span class=\"keyword\">this</span>.state.showText ? <span class=\"keyword\">this</span>.props.text : <span class=\"string\">' '</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlinkApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      &lt;View&gt;</div><div class=\"line\">        &lt;Blink text='I love to blink' /&gt;</div><div class=\"line\">        &lt;Blink text='Yes blinking is so great' /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子中 text 是固定的，所以用 <code>Props</code> 在父控件创建的时候传入。在构造函数的时候创建了 <code>State</code> 和其属性 <code>showText</code>。当然，还可以再这里初始化任意多个属性，用逗号隔开，相当于创建一个 <code>state</code> 对象。使用的时候直接可以点出来：<code>this.state.showText</code>。想要修改的时候调用 <code>this.setState()</code> 方法，将要修改的属性组成对象传入。</p>\n<p>拓展：可以学习一下状态容器如：<code>Redux</code>。另外，关于 <code>state</code> 的更多原理，可以参考 <code>React.js</code>。</p>\n<h3 id=\"StyleSheet\"><a href=\"#StyleSheet\" class=\"headerlink\" title=\"StyleSheet\"></a>StyleSheet</h3><p>相当于一个样式合集：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; AppRegistry, StyleSheet, Text, View &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> styles = StyleSheet.create(&#123;</div><div class=\"line\">  bigblue: &#123;</div><div class=\"line\">    color: <span class=\"string\">'blue'</span>,</div><div class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</div><div class=\"line\">    fontSize: <span class=\"number\">30</span>,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使用：</span></div><div class=\"line\">&lt;View style=&#123;styles.bigblue&#125;/&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a>flex</h3><p>在 <code>style</code> 中通过flex可以灵活地将组件撑满整个屏幕。</p>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的 <code>width</code> 和 <code>height</code>，也没有设定 <code>flex</code>，则父容器的尺寸为零。其子组件如果使用了 <code>flex</code>，也是无法显示的。</p>\n<h3 id=\"flexbox布局\"><a href=\"#flexbox布局\" class=\"headerlink\" title=\"flexbox布局\"></a>flexbox布局</h3><h4 id=\"flexDirection\"><a href=\"#flexDirection\" class=\"headerlink\" title=\"flexDirection\"></a>flexDirection</h4><p>在 <code>style</code> 中指定布局的<strong>主轴</strong>，是 <code>row</code> 还是 <code>column</code>。默认是 <code>column</code>。</p>\n<h4 id=\"justifyContent\"><a href=\"#justifyContent\" class=\"headerlink\" title=\"justifyContent\"></a>justifyContent</h4><p>在 <code>style</code> 中指定元素沿着<strong>主轴</strong>的排序方式。<strong>注意</strong>，这个属性是定义在父控件，作用在子控件上的。</p>\n<p>包括 <code>flex-start</code>,<code>flex-end</code>,<code>center</code>,<code>space-between</code>,<code>space-around</code>。</p>\n<p>前面三个不说了，后面两个说一下：</p>\n<ol>\n<li><code>space-between</code>:左右各一个子控件，剩余的子控件均匀的分布在中间。如果只有一个，那么这个居左。</li>\n<li><code>space-around</code>:所有子控件均匀的分布，如果只有一个，那么这个居中。</li>\n</ol>\n<h4 id=\"alignItems\"><a href=\"#alignItems\" class=\"headerlink\" title=\"alignItems\"></a>alignItems</h4><p>在 <code>style</code> 中指定布局的<strong>次轴</strong>的排序方式。<strong>注意</strong>，这个属性是定义在父控件，作用在子控件上的。</p>\n<p>包括 <code>flex-start</code>,<code>flex-end</code>,<code>center</code>,<code>stretch</code>。</p>\n<p>其中 <code>stretch</code> 表示拉伸撑满次轴，前提是不设置子控件宽度。</p>\n<h3 id=\"布局样式\"><a href=\"#布局样式\" class=\"headerlink\" title=\"布局样式\"></a>布局样式</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>除了上面说的那些，再摘取一些有用的 <code>style</code> 中的属性：</p>\n<ol>\n<li><code>border</code> 系列:设置边框的宽度，<code>borderTopWidth</code>,<code>borderLeftWidth</code>…上下左右都可以分别设置。</li>\n<li><code>alignSelf</code>:类似于 <code>alignItems</code>，只不过这个属性定义在子控件中，重写父控件的 <code>alignItems</code>。因为子控件在次轴上没有必要完全按照父控件的控制，那样太死板了，<code>alignSelf</code> 的目的就是搞这个特殊。</li>\n<li><code>left</code> 系列:定义子控件到父控件的左边距。<strong>注意</strong>，要先设置 <code>position:absolute</code> 否则无效。类似的还有 <code>right</code>,<code>top</code>,<code>bottom</code>。</li>\n<li><code>flexWrap</code>:当子控件到底后自动换行。<code>wrap</code> 为自动换行，<code>noWrap</code> 为不换行。<strong>注意</strong>，要定义在父控件中。</li>\n<li><code>margin</code> 系列:设置子控件到相邻子控件的间隔。</li>\n<li><code>max</code>,<code>min</code> 系列:设置控件的最大(小)宽度(高度).</li>\n<li><code>padding</code> 系列:在父控件内设置，设置子控件的起点。</li>\n<li><code>position</code>:分为 <code>absolute</code> 绝对，<code>relative</code>相对。默认是相对的，如果要使用 <code>left</code> 等样式，就要使用绝对布局。<strong>绝对布局的子控件的大小不会影响父控件的大小</strong></li>\n<li><code>zIndex</code>: 控制控件的绘制层级，该属性越大，越绘在顶层。</li>\n</ol>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>一般使用方式:<br><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">style=&#123;&#123;height:xx,width:xx&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>如果有多个对象，需要用数组的方式传入：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">style=&#123;[&#123;height:xx,width:xx,&#125;,&#123;height:yy,wudth:yy,&#125;]&#125;</div></pre></td></tr></table></figure>\n<p>如果有相同的属性重复赋值，则以后一个覆盖前一个为准。</p>\n<h3 id=\"TextInput\"><a href=\"#TextInput\" class=\"headerlink\" title=\"TextInput\"></a>TextInput</h3><h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><p>文本输入组件，先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class UselessTextInput extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;TextInput</div><div class=\"line\">        &#123;...this.props&#125; // Inherit any props passed to it; e.g., multiline, numberOfLines below</div><div class=\"line\">        editable = &#123;true&#125;</div><div class=\"line\">        maxLength = &#123;40&#125;</div><div class=\"line\">      /&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class UselessTextInputMultiline extends Component &#123;</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      text: &apos;Useless Multiline Placeholder&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">     &lt;View style=&#123;&#123;</div><div class=\"line\">       backgroundColor: this.state.text,</div><div class=\"line\">       borderBottomColor: &apos;#000000&apos;,</div><div class=\"line\">       borderBottomWidth: 1 &#125;&#125;</div><div class=\"line\">     &gt;</div><div class=\"line\">       &lt;UselessTextInput</div><div class=\"line\">         multiline = &#123;true&#125;</div><div class=\"line\">         numberOfLines = &#123;4&#125;</div><div class=\"line\">         onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125;</div><div class=\"line\">         value=&#123;this.state.text&#125;</div><div class=\"line\">       /&gt;</div><div class=\"line\">     &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里为什么要把这个例子贴出来呢？主要有<strong>两个要点</strong>：</p>\n<p>首先，<code>{...this.props}</code> 的语法。这里<code>{}</code> 还是表示使用JS语法的意思。<code>...</code> 是es6的语法，叫做<strong>展开运算符</strong>。可以看看下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array);</div><div class=\"line\"><span class=\"comment\">//输出 [1, 2, 3, 4, 5, 6, 7]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(...array);</div><div class=\"line\"><span class=\"comment\">//输出 1 2 3 4 5 6 7</span></div></pre></td></tr></table></figure>\n<p><code>this.props</code> 是个对象，肯定不能放在 Component 中，但是用了<strong>展开运算符</strong>，里面的属性就全部被展开了，也就符合了 JSX 的语法。不只是 <code>this.props</code> <strong>任何对象都可以用这种展开的方式将参数传入 Component</strong>。不过不建议滥用，因为容易将很多多余参数传入，可能产生一些不易排查的问题。</p>\n<p>其次，<code>onChangeText={(text) =&gt; this.setState({text})}</code>。一般 <code>setState()</code> 中都是对象，为什么这里只是 <code>text</code>？这也是es6的语法，在键和值相等的时候可以省略 <code>{text:text}</code> 为 <code>{text}</code>。也就是本例的 <code>this.setState({text})</code>。</p>\n<h4 id=\"部分属性\"><a href=\"#部分属性\" class=\"headerlink\" title=\"部分属性\"></a>部分属性</h4><ol>\n<li><code>autoFocus</code>:在 <code>componentDidMount</code> 后是否自动获得焦点。</li>\n<li><code>defaultValue</code>:提供文本框的初始值。</li>\n<li><code>editable</code>:文本框是否可编辑</li>\n<li><code>maxLength</code>:文本框中最长字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。</li>\n<li><code>multiline</code>:是否可以多行，默认 false</li>\n<li><code>onFocus</code>,<code>onBlur</code>,<code>onEndEditing</code>,<code>onSubmitEditing</code>:输入框在各种情况下的回调函数。</li>\n<li><code>onChange</code>:当输入框内容改变时，回调该函数</li>\n<li><code>onChangeText</code>:当输入框内容改变时，回调该函数。改变后的文字内容将作为参数传入。</li>\n<li><code>placeholder</code>:占位符</li>\n<li><code>placeholderTextColor</code>:占位符颜色.(注意，貌似没有 placeholderTextSize 这个属性)</li>\n<li><code>value</code>:输入框内显示的值 </li>\n<li><code>underlineColorAndroid</code>:这是 android 特有的属性，非常的坑。文档里是这么说的“文本框的下划线颜色”，其实不是这个意思，这个属性设置的是整个文本框的颜色。比如在 iOS 上，直接设置 <code>backgroundColor=&#39;red&#39;</code> 就能把文本框设成红色，但是 android 不然，在 background 之上还有一层，就是这个 <code>underlineColorAndroid</code> 需要将这个也设置成红色，才能正确显示成红色。</li>\n<li>这里还有一个坑点，就是一定一定一定设置 TextInput 的高度。不然即使 TextInput 大小为0，任然会显示 placeholder ，这就会导致一直没有点击效果。所以<strong>一个调试技巧：给控件设置醒目的背景颜色，这样有助于了解控件的布局情况，方便调试。</strong></li>\n</ol>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ol>\n<li><code>isFocusd()</code>:判断当前输入框是否获得焦点。</li>\n<li><code>clear()</code>:清空输入框内容。</li>\n</ol>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ol>\n<li><code>contentContainerStyle</code>:比较重要的属性，相当于在 ScrollView 中内嵌了一个 View，这个属性就是控制这个内嵌 View 的。</li>\n<li><code>horizontal</code>:内容水平排布，不知道和 <code>flexDirection</code> 有什么区别</li>\n<li><code>keyboardDismissMode</code>:用户拖拽视图是否隐藏软键盘。<code>none</code>,<code>on-drag</code></li>\n<li><code>keyboardShouldPersistTaps</code>:控制是否在当点击文本输入框以外区域时，自动隐藏软键盘。true 不隐藏，false 隐藏。默认 false</li>\n<li><code>onScroll</code>:滚动的时候以一定频率回调该函数。</li>\n<li><code>refreshControll</code>:指定 RefreshController 组件，用于为 ScrollView 提供下拉刷新功能。</li>\n<li><code>pagingEnabled</code>:滚动条停在整数倍位置。</li>\n<li><code>scrollEventEnabled</code>:控制视图能否滚动。</li>\n</ol>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><ol>\n<li><code>scrollTo</code>:滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollTo(&#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, animated: <span class=\"literal\">true</span>&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"RefreshControl\"><a href=\"#RefreshControl\" class=\"headerlink\" title=\"RefreshControl\"></a>RefreshControl</h4><p>这一组件可以用在 ScrollView 或 ListView 内部，为其添加下拉刷新的功能。当 ScrollView 处于竖直方向上的起点位置时，此时下拉会触发一个 <code>onRefresh</code> 事件。有两个常用属性：</p>\n<ol>\n<li><code>onRefresh</code>:在视图开始刷新时调用。</li>\n<li><code>refreshing</code>: 视图是否应该在刷新时显示指示器。一般是从网络获取数据的时候是 true，获取完数据为 false</li>\n</ol>\n<h4 id=\"示例：用Scrollview实现带下拉刷新的Tableview\"><a href=\"#示例：用Scrollview实现带下拉刷新的Tableview\" class=\"headerlink\" title=\"示例：用Scrollview实现带下拉刷新的Tableview\"></a>示例：用Scrollview实现带下拉刷新的Tableview</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 每一个row的view</span></div><div class=\"line\"><span class=\"keyword\">const</span> Row = React.createClass(&#123;</div><div class=\"line\">  _onClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.props.onClick(<span class=\"keyword\">this</span>.props.data);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">     &lt;TouchableWithoutFeedback onPress=&#123;this._onClick&#125; &gt;</div><div class=\"line\">        &lt;View style=&#123;styles.row&#125;&gt;</div><div class=\"line\">          &lt;Text style=&#123;styles.text&#125;&gt;</div><div class=\"line\">            &#123;this.props.data.text + ' (' + this.props.data.clicks + ' clicks)'&#125;</div><div class=\"line\">          &lt;/Text&gt;</div><div class=\"line\">        &lt;/View&gt;</div><div class=\"line\">      &lt;/TouchableWithoutFeedback&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> RefreshControlExample = React.createClass(&#123;</div><div class=\"line\">  statics: &#123;</div><div class=\"line\">    title: <span class=\"string\">'&lt;RefreshControl&gt;'</span>,</div><div class=\"line\">    description: <span class=\"string\">'Adds pull-to-refresh support to a scrollview.'</span></div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  getInitialState() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      isRefreshing: <span class=\"literal\">false</span>,</div><div class=\"line\">      loaded: <span class=\"number\">0</span>,</div><div class=\"line\">      rowData: <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">20</span>)).map(</div><div class=\"line\">        (val, i) =&gt; (&#123;text: <span class=\"string\">'Initial row '</span> + i, clicks: <span class=\"number\">0</span>&#125;)),</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  _onClick(row) &#123;</div><div class=\"line\">    row.clicks++;</div><div class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</div><div class=\"line\">      rowData: <span class=\"keyword\">this</span>.state.rowData,</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> rows = <span class=\"keyword\">this</span>.state.rowData.map((row, ii) =&gt; &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &lt;Row key=&#123;ii&#125; data=&#123;row&#125; onClick=&#123;this._onClick&#125;/&gt;;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;ScrollView</div><div class=\"line\">        style=&#123;styles.scrollview&#125;</div><div class=\"line\">        refreshControl=&#123;</div><div class=\"line\">          &lt;RefreshControl</div><div class=\"line\">            refreshing=&#123;this.state.isRefreshing&#125;</div><div class=\"line\">            onRefresh=&#123;this._onRefresh&#125;</div><div class=\"line\">            tintColor=\"#ff0000\"</div><div class=\"line\">            title=\"Loading...\"</div><div class=\"line\">            titleColor=\"#00ff00\"</div><div class=\"line\">            colors=&#123;['#ff0000', '#00ff00', '#0000ff']&#125;</div><div class=\"line\">            progressBackgroundColor=\"#ffff00\"</div><div class=\"line\">          /&gt;</div><div class=\"line\">        &#125;&gt;</div><div class=\"line\">        &#123;rows&#125;</div><div class=\"line\">      &lt;/ScrollView&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  _onRefresh() &#123;</div><div class=\"line\">    this.setState(&#123;isRefreshing: true&#125;);</div><div class=\"line\">    setTimeout(() =&gt; &#123;</div><div class=\"line\">      // prepend 10 items</div><div class=\"line\">      const rowData = Array.from(new Array(10))</div><div class=\"line\">      .map((val, i) =&gt; (&#123;</div><div class=\"line\">        text: 'Loaded row ' + (+this.state.loaded + i),</div><div class=\"line\">        clicks: 0,</div><div class=\"line\">      &#125;))</div><div class=\"line\">      .concat(this.state.rowData);</div><div class=\"line\"></div><div class=\"line\">      this.setState(&#123;</div><div class=\"line\">        loaded: this.state.loaded + 10,</div><div class=\"line\">        isRefreshing: false,</div><div class=\"line\">        rowData: rowData,</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;, 5000);</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>省略了styleSheet。这里主要注意几点：</p>\n<ol>\n<li>譬如封装一个组件 Row，其中有点击事件的处理。iOS 中一般使用代理。这里由于js的特性，可以把外部的点击方法传入组件内，再由组件的点击事件调用。</li>\n<li>注意 <code>map()</code> 方法的使用。这也就是用 scrollview 实现 tableview 的方式。</li>\n<li>在 <code>render</code> 里可以插入js方法，如上面的 <code>{row}</code>,只要方法返回的是JSX的 component就行。（貌似component里的属性只能用展开运算符才能插入，用js方法返回的方式一直都报错）</li>\n<li><code>RefreshControl</code> 看起来也就是一个 component，由 scrollview 控制什么时候展示，怎么展示。</li>\n<li>如果想要自定义上拉刷新，就得知道 <code>contentOffset</code> 可以研究一下。</li>\n</ol>\n<h3 id=\"ListView\"><a href=\"#ListView\" class=\"headerlink\" title=\"ListView\"></a>ListView</h3><p>ListView设计到各种优化，以及各种方法，掌握的不是很好，需要进一步学习。</p>\n<h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ol>\n<li>ScrollView 全部属性</li>\n<li><code>dataSource</code>:<code>ListView.DataSource实例</code>。</li>\n<li><code>initialListSize</code>:指定在组件刚挂载的时候渲染多少行数据。(试了下没看出有什么效果。)</li>\n<li><code>onChangeVisibleRows</code>:显示区域的 cell 变化时调用。（api 和实际使用有出入，需要实际使用的时候检验，不过这个东西好像没什么太大用）</li>\n<li><code>onEndReachedThreshold</code>:调用 <code>onEndReached</code> 之前的临界值.</li>\n<li><code>onEndReached</code>:滚动到底部时的回调，如果数据不满足一屏，会立即回调，需要手动标记过滤。</li>\n<li><code>pageSize</code>:每次事件循环（每帧）渲染的行数。默认是1。（好像不需要自己设置，不知道设了有什么影响）</li>\n<li><code>removeClippedSubviews</code>:说是提升性能默认开启，不知道具体有啥用。</li>\n<li><code>renderHeader</code>,<code>renderFooter</code>:页头，页脚。</li>\n<li><code>renderRow</code>: cell 的实现，方法为<code>(rowData, sectionID, rowID, highlightRow) =&gt; renderable</code></li>\n<li><code>renderSeparator</code>: <code>(sectionID, rowID, adjacentRowHighlighted) =&gt; renderable</code> 一个可渲染的组件会被渲染在每一行下面.如果被点击了，就会显示出来。没什么太大用。如果要用，要在 return 的 view 里添加 <code>key</code>，最好看一下示例。</li>\n<li><code>scrollRenderAheadDistance</code>:距离多少开始渲染下一行。</li>\n<li><code>renderScrollComponent</code>:不知道怎么用。</li>\n<li><code>renderSectionHeader</code>:每个小节(section)渲染一个粘性的标题。<code>(sectionData, sectionID) =&gt; renderable</code> 其中 <code>sectionData</code> 就是section内内容的数组。</li>\n</ol>\n<h4 id=\"一些方法\"><a href=\"#一些方法\" class=\"headerlink\" title=\"一些方法\"></a>一些方法</h4><ol>\n<li>listview 只是提供了渲染其中 cell 的功能，默认是 cell 竖着排下来。那么如果要实现成 gridview 之类该怎么做呢？就是给 listview 附上从 scrollview 中继承来的 <code>contentContainerStyle</code> 这个 style 用来控制其中子视图的样式，只要在其中将 <code>flexDirection:‘row’,justifyContent: &#39;space-around&#39;,flexWrap: &#39;wrap&#39;</code> 这样一设置。就能达到横排 cell，并且自动换行的效果。</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p>感觉没什么好写的，暂且不表</p>\n<h3 id=\"navigator\"><a href=\"#navigator\" class=\"headerlink\" title=\"navigator\"></a>navigator</h3><p>暂时还是用原生的 navigator，感觉 navigator 不太好用，所以暂且不表。</p>\n<p>如果需要使用，可以查看这篇<a href=\"http://bbs.reactnative.cn/topic/20/新手理解navigator的教程\">教程</a></p>\n<p>###</p>"},{"title":"UIButton 简介","date":"2016-08-29T06:07:12.000Z","_content":"\n从最基础的控件开始一点点学习。先来总结下UIButton。\n\n<!--more-->\n\n## 基础\n### 创建\n```objc\nUIButton *btn1 = [[UIButton alloc] init];\nCGRect btn1Frame = CGRectMake(50, 50, 200, 100);\nbtn1.frame = btn1Frame;\n[self.view addSubview:btn1];\n```\n\n通过`init`和设置`frame`以及`addSubView`就可以将button添加到Voew上。\n\n### 点击事件\n#### 通过xib关联\n```objc\n- (IBAction)btn2Pressed:(id)sender{\n    NSLog(@\"点击操作\");\n}\n```\n与xib关联即可，其中`(id)sender`就表示的是这个Button\n\n#### 通过代码\n```objc\n//添加\n[btn1 addTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n//移除\n[btn1 removeTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n```\n为`btn1`添加和删除一个`btn1Pressed`的点击事件。\n\n## 设置title和image\nbutton有`imageView`和`titleLabel`两个属性，默认image在左，label在右。\n\n### 添加title和image\n```\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setTitle:@\"BTN1\" forState:UIControlStateNormal];\n```\n这里`forState`常用的有一下几种：\n- UIControlStateNormal  \t\t常态\n- UIControlStateHighlighted \t高亮\n- UIControlStateDisabled\t\t禁用\n- UIControlStateSelected\t\t选中\n\n其中需要说明的是，高亮就是点击时的状态。其实还有一种`UIControlStateSelected | UIControlStateHighlighted`这个组合是选中时候的高亮状态，也是比较有用的。\n\n### 设置button选中\nbutton选中与否是由`UIControlStateSelected`控制的。\n\n可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于*点赞*。一般情况我们实现方式是这样的：\n```objc\n- (void)buttonClick:(UIButton *)button {\n    if ([button.currentImage isEqual:[UIImage imageNamed:@\"like\"]]) {\n        [button setImage:[UIImage imageNamed:@\"like_selected\"] forState:UIControlStateNormal];\n    }\n    else {\n        [button setImage:[UIImage imageNamed:@\"like\"] forState:UIControlStateNormal];\n    }\n}\n```\n\n但是最好不要这样实现。可以使用`UIControlStateSelected`来控制：\n```objc\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected];\n\n//点击事件\n- (void)btn1Pressed:(UIButton *)button{\n    //button.enabled 设置是否可点击。\n    button.selected = !button.selected;\n}\n```\n这样，每次点击的时候切换选中状态达到效果。\n\n但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。\n\n因此，需要将normal->selected以及selected->normal之间的highlight都设置一下:\n```objc\n//normal->selected\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateHighlighted];\n//selected->normal\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected | UIControlStateHighlighted];\n```\n\n好的，这样就完成了切换状态的过程。\n\n### 设置image和title位置\nimage和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。\n\n#### image和title位置互换\n先看代码：\n```objc\n[btn1 setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn1.imageView.bounds.size.width, 0, btn1.imageView.bounds.size.width)];\n[btn1 setImageEdgeInsets:UIEdgeInsetsMake(0, btn1.titleLabel.bounds.size.width, 0, -btn1.titleLabel.bounds.size.width)];\n```\n这里需要强调的是一定要先设置`title`再设置`image`。因为`title`是依赖于`image`的，在如果先设置`image`，这个时候`title`还没有确定，于是`titleLabel.bounds.size.width`一定是`0`，即`image`没有变。\n\n这里的`UIEdgeInsetsMake`里的四个参数分别是`top`,`left`,`bottom`,`right`四个方向的`inset`,默认是`0`，也就是说，所有变化都是针对当前位置的。`-btn1.imageView.bounds.size.width`表示让`title`的左边距**减少**`image`的宽度，同理`btn1.imageView.bounds.size.width`表示让右边距**增加**`image`的宽度。\n\n#### 控制image的大小\n交换了image的位置后，我就想怎么控制image的大小。尝试改变了`UIEdgeInsetsMake`的参数，发现改变`top`和`bottom`可以将图片压缩，但是改变`left` `right`图片始终不动。\n\n经过我不断尝试后终于得出了结论：\n以横轴为例，只有当**左边距+右边距+图片宽度=button宽度**时，继续增加边距，才会导致图片的压缩。当**左边距+右边距+图片宽度<button宽度**时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。\n\n因此，为什么改变`top`和`bottom`可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时`top`和`bottom`都为0，但是由于**image高度=button高度**，此时增加`top`和`bottom`就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。\n\n而在横轴方面，开始时，**左边距+右边距+图片宽度<button宽度**。图片只会平移直到边距增加到使等式相等才会进行压缩。\n\n## UIControl\n### 概览\n`UIControl` 是控件类的基类，它是一个抽象基类，我们不能直接使用 `UIControl` 类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。\n![UIControl](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/uibutton_1.png?raw=true)\n\n### Target-Action机制\nTarget-action 是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：\n\n```objc\n[button addTarget:self action:@selector(tapButton:) forControlEvents:UIControlEventTouchUpInside];\n```\n\n也就是说，当按钮的点击事件发生时，会将消息发送到 `target`(此处即为 `self` 对象)，并由 `target` 对象的 `tapButton:` 方法来处理相应的事件。因此，Target-Action 机制由两部分组成：即目标对象和行为 `Selector`。目标对象指定最终处理事件的对象，而行为 `Selector` 则是处理事件的方法。\n\n我们先来看看 UIControl 为我们提供了哪些自定义跟踪行为的方法:\n```objc\n- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (void)cancelTrackingWithEvent:(UIEvent *)event\n```\n\n这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。跟 `UIResponse` 提供的四个事件跟踪方法是不是挺像的？我们来看看 `UIResponse` 的四个方法：\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n```\n\n上面两组方法的参数基本相同，只不过 `UIControl` 的是针对单点触摸，而 `UIResponse` 可能是多点触摸。另外，返回值也是大同小异。由于 `UIControl` 本身是视图，所以它实际上也继承了 `UIResponse` 的这四个方法。如果测试一下，我们会发现**在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。**\n\n对于一个给定的事件，`UIControl` 会调用 `sendAction:to:forEvent:` 来将行为消息转发到 `UIApplication`对象，再由 `UIApplication` 对象调用其 `sendAction:to:fromSender:forEvent:` 方法来将消息分发到指定的 `target` 上。而如果子类想监控或修改这种行为的话，则可以重写这个方法:\n\n```objc\n// ImageControl.m\n- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n  // 将事件传递到对象本身来处理\n    [super sendAction:@selector(handleAction:) to:self forEvent:event];\n}\n \n- (void)handleAction:(id)sender {\n \n    NSLog(@\"handle Action\");\n}\n \n// ViewController.m\n \n- (void)viewDidLoad {\n    [super viewDidLoad];\n \n    self.view.backgroundColor = [UIColor whiteColor];\n \n    ImageControl *control = [[ImageControl alloc] initWithFrame:(CGRect){50.0f, 100.0f, 200.0f, 300.0f} title:@\"This is a demo\" image:[UIImage imageNamed:@\"demo\"]];\n    // ...\n \n    [control addTarget:self action:@selector(tapImageControl:) forControlEvents:UIControlEventTouchUpInside];\n}\n- (void)tapImageControl:(id)sender {\n \n    NSLog(@\"sender = %@\", sender);\n}\n```\n\n由于我们重写了 `sendAction:to:forEvent:` 方法，所以最后处理事件的 `Selector` 是 `ImageControl的handleAction:` 方法，而不是 `ViewController` 的 `tapImageControl:` 方法。\n\n### Target-Action的管理\n为一个控件对象添加、删除Target-Action的操作我们都已经很熟悉了，主要使用的是以下两个方法：\n```objc\n// 添加\n- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents\n \n- (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents\n```\n\n如果想获取控件对象所有相关的 `target` 对象，则可以调用 `allTargets` 方法，该方法返回一个集合。集合中可能包含 `NSNull` 对象，表示至少有一个 `nil` 目标对象。\n\n而如果想获取某个 `target` 对象及事件相关的所有 `action`，则可以调用 `actionsForTarget:forControlEvent:` 方法。返回一个可变数组。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n就是这样~~O(∩_∩)O~~","source":"_posts/UIButton基础.md","raw":"title: UIButton 简介\ndate: 2016/8/29 14:07:12  \ncategories: iOS\ntags: \n\t- 基本控件\n\t\n---\n\n从最基础的控件开始一点点学习。先来总结下UIButton。\n\n<!--more-->\n\n## 基础\n### 创建\n```objc\nUIButton *btn1 = [[UIButton alloc] init];\nCGRect btn1Frame = CGRectMake(50, 50, 200, 100);\nbtn1.frame = btn1Frame;\n[self.view addSubview:btn1];\n```\n\n通过`init`和设置`frame`以及`addSubView`就可以将button添加到Voew上。\n\n### 点击事件\n#### 通过xib关联\n```objc\n- (IBAction)btn2Pressed:(id)sender{\n    NSLog(@\"点击操作\");\n}\n```\n与xib关联即可，其中`(id)sender`就表示的是这个Button\n\n#### 通过代码\n```objc\n//添加\n[btn1 addTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n//移除\n[btn1 removeTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n```\n为`btn1`添加和删除一个`btn1Pressed`的点击事件。\n\n## 设置title和image\nbutton有`imageView`和`titleLabel`两个属性，默认image在左，label在右。\n\n### 添加title和image\n```\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setTitle:@\"BTN1\" forState:UIControlStateNormal];\n```\n这里`forState`常用的有一下几种：\n- UIControlStateNormal  \t\t常态\n- UIControlStateHighlighted \t高亮\n- UIControlStateDisabled\t\t禁用\n- UIControlStateSelected\t\t选中\n\n其中需要说明的是，高亮就是点击时的状态。其实还有一种`UIControlStateSelected | UIControlStateHighlighted`这个组合是选中时候的高亮状态，也是比较有用的。\n\n### 设置button选中\nbutton选中与否是由`UIControlStateSelected`控制的。\n\n可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于*点赞*。一般情况我们实现方式是这样的：\n```objc\n- (void)buttonClick:(UIButton *)button {\n    if ([button.currentImage isEqual:[UIImage imageNamed:@\"like\"]]) {\n        [button setImage:[UIImage imageNamed:@\"like_selected\"] forState:UIControlStateNormal];\n    }\n    else {\n        [button setImage:[UIImage imageNamed:@\"like\"] forState:UIControlStateNormal];\n    }\n}\n```\n\n但是最好不要这样实现。可以使用`UIControlStateSelected`来控制：\n```objc\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected];\n\n//点击事件\n- (void)btn1Pressed:(UIButton *)button{\n    //button.enabled 设置是否可点击。\n    button.selected = !button.selected;\n}\n```\n这样，每次点击的时候切换选中状态达到效果。\n\n但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。\n\n因此，需要将normal->selected以及selected->normal之间的highlight都设置一下:\n```objc\n//normal->selected\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateHighlighted];\n//selected->normal\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected | UIControlStateHighlighted];\n```\n\n好的，这样就完成了切换状态的过程。\n\n### 设置image和title位置\nimage和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。\n\n#### image和title位置互换\n先看代码：\n```objc\n[btn1 setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn1.imageView.bounds.size.width, 0, btn1.imageView.bounds.size.width)];\n[btn1 setImageEdgeInsets:UIEdgeInsetsMake(0, btn1.titleLabel.bounds.size.width, 0, -btn1.titleLabel.bounds.size.width)];\n```\n这里需要强调的是一定要先设置`title`再设置`image`。因为`title`是依赖于`image`的，在如果先设置`image`，这个时候`title`还没有确定，于是`titleLabel.bounds.size.width`一定是`0`，即`image`没有变。\n\n这里的`UIEdgeInsetsMake`里的四个参数分别是`top`,`left`,`bottom`,`right`四个方向的`inset`,默认是`0`，也就是说，所有变化都是针对当前位置的。`-btn1.imageView.bounds.size.width`表示让`title`的左边距**减少**`image`的宽度，同理`btn1.imageView.bounds.size.width`表示让右边距**增加**`image`的宽度。\n\n#### 控制image的大小\n交换了image的位置后，我就想怎么控制image的大小。尝试改变了`UIEdgeInsetsMake`的参数，发现改变`top`和`bottom`可以将图片压缩，但是改变`left` `right`图片始终不动。\n\n经过我不断尝试后终于得出了结论：\n以横轴为例，只有当**左边距+右边距+图片宽度=button宽度**时，继续增加边距，才会导致图片的压缩。当**左边距+右边距+图片宽度<button宽度**时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。\n\n因此，为什么改变`top`和`bottom`可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时`top`和`bottom`都为0，但是由于**image高度=button高度**，此时增加`top`和`bottom`就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。\n\n而在横轴方面，开始时，**左边距+右边距+图片宽度<button宽度**。图片只会平移直到边距增加到使等式相等才会进行压缩。\n\n## UIControl\n### 概览\n`UIControl` 是控件类的基类，它是一个抽象基类，我们不能直接使用 `UIControl` 类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。\n![UIControl](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/uibutton_1.png?raw=true)\n\n### Target-Action机制\nTarget-action 是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：\n\n```objc\n[button addTarget:self action:@selector(tapButton:) forControlEvents:UIControlEventTouchUpInside];\n```\n\n也就是说，当按钮的点击事件发生时，会将消息发送到 `target`(此处即为 `self` 对象)，并由 `target` 对象的 `tapButton:` 方法来处理相应的事件。因此，Target-Action 机制由两部分组成：即目标对象和行为 `Selector`。目标对象指定最终处理事件的对象，而行为 `Selector` 则是处理事件的方法。\n\n我们先来看看 UIControl 为我们提供了哪些自定义跟踪行为的方法:\n```objc\n- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event\n- (void)cancelTrackingWithEvent:(UIEvent *)event\n```\n\n这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。跟 `UIResponse` 提供的四个事件跟踪方法是不是挺像的？我们来看看 `UIResponse` 的四个方法：\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n```\n\n上面两组方法的参数基本相同，只不过 `UIControl` 的是针对单点触摸，而 `UIResponse` 可能是多点触摸。另外，返回值也是大同小异。由于 `UIControl` 本身是视图，所以它实际上也继承了 `UIResponse` 的这四个方法。如果测试一下，我们会发现**在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。**\n\n对于一个给定的事件，`UIControl` 会调用 `sendAction:to:forEvent:` 来将行为消息转发到 `UIApplication`对象，再由 `UIApplication` 对象调用其 `sendAction:to:fromSender:forEvent:` 方法来将消息分发到指定的 `target` 上。而如果子类想监控或修改这种行为的话，则可以重写这个方法:\n\n```objc\n// ImageControl.m\n- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n  // 将事件传递到对象本身来处理\n    [super sendAction:@selector(handleAction:) to:self forEvent:event];\n}\n \n- (void)handleAction:(id)sender {\n \n    NSLog(@\"handle Action\");\n}\n \n// ViewController.m\n \n- (void)viewDidLoad {\n    [super viewDidLoad];\n \n    self.view.backgroundColor = [UIColor whiteColor];\n \n    ImageControl *control = [[ImageControl alloc] initWithFrame:(CGRect){50.0f, 100.0f, 200.0f, 300.0f} title:@\"This is a demo\" image:[UIImage imageNamed:@\"demo\"]];\n    // ...\n \n    [control addTarget:self action:@selector(tapImageControl:) forControlEvents:UIControlEventTouchUpInside];\n}\n- (void)tapImageControl:(id)sender {\n \n    NSLog(@\"sender = %@\", sender);\n}\n```\n\n由于我们重写了 `sendAction:to:forEvent:` 方法，所以最后处理事件的 `Selector` 是 `ImageControl的handleAction:` 方法，而不是 `ViewController` 的 `tapImageControl:` 方法。\n\n### Target-Action的管理\n为一个控件对象添加、删除Target-Action的操作我们都已经很熟悉了，主要使用的是以下两个方法：\n```objc\n// 添加\n- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents\n \n- (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents\n```\n\n如果想获取控件对象所有相关的 `target` 对象，则可以调用 `allTargets` 方法，该方法返回一个集合。集合中可能包含 `NSNull` 对象，表示至少有一个 `nil` 目标对象。\n\n而如果想获取某个 `target` 对象及事件相关的所有 `action`，则可以调用 `actionsForTarget:forControlEvent:` 方法。返回一个可变数组。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n就是这样~~O(∩_∩)O~~","slug":"UIButton基础","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpn00197hzg472fv11m","content":"<p>从最基础的控件开始一点点学习。先来总结下UIButton。</p>\n<a id=\"more\"></a>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\"><span class=\"built_in\">CGRect</span> btn1Frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>);</div><div class=\"line\">btn1.frame = btn1Frame;</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</div></pre></td></tr></table></figure>\n<p>通过<code>init</code>和设置<code>frame</code>以及<code>addSubView</code>就可以将button添加到Voew上。</p>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><h4 id=\"通过xib关联\"><a href=\"#通过xib关联\" class=\"headerlink\" title=\"通过xib关联\"></a>通过xib关联</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btn2Pressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"点击操作\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与xib关联即可，其中<code>(id)sender</code>就表示的是这个Button</p>\n<h4 id=\"通过代码\"><a href=\"#通过代码\" class=\"headerlink\" title=\"通过代码\"></a>通过代码</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加</span></div><div class=\"line\">[btn1 addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"><span class=\"comment\">//移除</span></div><div class=\"line\">[btn1 removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>为<code>btn1</code>添加和删除一个<code>btn1Pressed</code>的点击事件。</p>\n<h2 id=\"设置title和image\"><a href=\"#设置title和image\" class=\"headerlink\" title=\"设置title和image\"></a>设置title和image</h2><p>button有<code>imageView</code>和<code>titleLabel</code>两个属性，默认image在左，label在右。</p>\n<h3 id=\"添加title和image\"><a href=\"#添加title和image\" class=\"headerlink\" title=\"添加title和image\"></a>添加title和image</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];</div><div class=\"line\">[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p>这里<code>forState</code>常用的有一下几种：</p>\n<ul>\n<li>UIControlStateNormal          常态</li>\n<li>UIControlStateHighlighted     高亮</li>\n<li>UIControlStateDisabled        禁用</li>\n<li>UIControlStateSelected        选中</li>\n</ul>\n<p>其中需要说明的是，高亮就是点击时的状态。其实还有一种<code>UIControlStateSelected | UIControlStateHighlighted</code>这个组合是选中时候的高亮状态，也是比较有用的。</p>\n<h3 id=\"设置button选中\"><a href=\"#设置button选中\" class=\"headerlink\" title=\"设置button选中\"></a>设置button选中</h3><p>button选中与否是由<code>UIControlStateSelected</code>控制的。</p>\n<p>可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于<em>点赞</em>。一般情况我们实现方式是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick:(<span class=\"built_in\">UIButton</span> *)button &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([button.currentImage isEqual:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>]]) &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like_selected\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是最好不要这样实现。可以使用<code>UIControlStateSelected</code>来控制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//点击事件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)btn1Pressed:(<span class=\"built_in\">UIButton</span> *)button&#123;</div><div class=\"line\">    <span class=\"comment\">//button.enabled 设置是否可点击。</span></div><div class=\"line\">    button.selected = !button.selected;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，每次点击的时候切换选中状态达到效果。</p>\n<p>但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。</p>\n<p>因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//normal-&gt;selected</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</div><div class=\"line\"><span class=\"comment\">//selected-&gt;normal</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span> | <span class=\"built_in\">UIControlStateHighlighted</span>];</div></pre></td></tr></table></figure></p>\n<p>好的，这样就完成了切换状态的过程。</p>\n<h3 id=\"设置image和title位置\"><a href=\"#设置image和title位置\" class=\"headerlink\" title=\"设置image和title位置\"></a>设置image和title位置</h3><p>image和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。</p>\n<h4 id=\"image和title位置互换\"><a href=\"#image和title位置互换\" class=\"headerlink\" title=\"image和title位置互换\"></a>image和title位置互换</h4><p>先看代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setTitleEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, -btn1.imageView.bounds.size.width, <span class=\"number\">0</span>, btn1.imageView.bounds.size.width)];</div><div class=\"line\">[btn1 setImageEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, btn1.titleLabel.bounds.size.width, <span class=\"number\">0</span>, -btn1.titleLabel.bounds.size.width)];</div></pre></td></tr></table></figure></p>\n<p>这里需要强调的是一定要先设置<code>title</code>再设置<code>image</code>。因为<code>title</code>是依赖于<code>image</code>的，在如果先设置<code>image</code>，这个时候<code>title</code>还没有确定，于是<code>titleLabel.bounds.size.width</code>一定是<code>0</code>，即<code>image</code>没有变。</p>\n<p>这里的<code>UIEdgeInsetsMake</code>里的四个参数分别是<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>四个方向的<code>inset</code>,默认是<code>0</code>，也就是说，所有变化都是针对当前位置的。<code>-btn1.imageView.bounds.size.width</code>表示让<code>title</code>的左边距<strong>减少</strong><code>image</code>的宽度，同理<code>btn1.imageView.bounds.size.width</code>表示让右边距<strong>增加</strong><code>image</code>的宽度。</p>\n<h4 id=\"控制image的大小\"><a href=\"#控制image的大小\" class=\"headerlink\" title=\"控制image的大小\"></a>控制image的大小</h4><p>交换了image的位置后，我就想怎么控制image的大小。尝试改变了<code>UIEdgeInsetsMake</code>的参数，发现改变<code>top</code>和<code>bottom</code>可以将图片压缩，但是改变<code>left</code> <code>right</code>图片始终不动。</p>\n<p>经过我不断尝试后终于得出了结论：<br>以横轴为例，只有当<strong>左边距+右边距+图片宽度=button宽度</strong>时，继续增加边距，才会导致图片的压缩。当<strong>左边距+右边距+图片宽度&lt;button宽度</strong>时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。</p>\n<p>因此，为什么改变<code>top</code>和<code>bottom</code>可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时<code>top</code>和<code>bottom</code>都为0，但是由于<strong>image高度=button高度</strong>，此时增加<code>top</code>和<code>bottom</code>就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。</p>\n<p>而在横轴方面，开始时，<strong>左边距+右边距+图片宽度&lt;button宽度</strong>。图片只会平移直到边距增加到使等式相等才会进行压缩。</p>\n<h2 id=\"UIControl\"><a href=\"#UIControl\" class=\"headerlink\" title=\"UIControl\"></a>UIControl</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p><code>UIControl</code> 是控件类的基类，它是一个抽象基类，我们不能直接使用 <code>UIControl</code> 类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/uibutton_1.png?raw=true\" alt=\"UIControl\"></p>\n<h3 id=\"Target-Action机制\"><a href=\"#Target-Action机制\" class=\"headerlink\" title=\"Target-Action机制\"></a>Target-Action机制</h3><p>Target-action 是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[button addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(tapButton:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>也就是说，当按钮的点击事件发生时，会将消息发送到 <code>target</code>(此处即为 <code>self</code> 对象)，并由 <code>target</code> 对象的 <code>tapButton:</code> 方法来处理相应的事件。因此，Target-Action 机制由两部分组成：即目标对象和行为 <code>Selector</code>。目标对象指定最终处理事件的对象，而行为 <code>Selector</code> 则是处理事件的方法。</p>\n<p>我们先来看看 UIControl 为我们提供了哪些自定义跟踪行为的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)beginTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)continueTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)endTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancelTrackingWithEvent:(<span class=\"built_in\">UIEvent</span> *)event</div></pre></td></tr></table></figure></p>\n<p>这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。跟 <code>UIResponse</code> 提供的四个事件跟踪方法是不是挺像的？我们来看看 <code>UIResponse</code> 的四个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div></pre></td></tr></table></figure>\n<p>上面两组方法的参数基本相同，只不过 <code>UIControl</code> 的是针对单点触摸，而 <code>UIResponse</code> 可能是多点触摸。另外，返回值也是大同小异。由于 <code>UIControl</code> 本身是视图，所以它实际上也继承了 <code>UIResponse</code> 的这四个方法。如果测试一下，我们会发现<strong>在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。</strong></p>\n<p>对于一个给定的事件，<code>UIControl</code> 会调用 <code>sendAction:to:forEvent:</code> 来将行为消息转发到 <code>UIApplication</code>对象，再由 <code>UIApplication</code> 对象调用其 <code>sendAction:to:fromSender:forEvent:</code> 方法来将消息分发到指定的 <code>target</code> 上。而如果子类想监控或修改这种行为的话，则可以重写这个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ImageControl.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)sendAction:(SEL)action to:(<span class=\"keyword\">id</span>)target forEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">  <span class=\"comment\">// 将事件传递到对象本身来处理</span></div><div class=\"line\">    [<span class=\"keyword\">super</span> sendAction:<span class=\"keyword\">@selector</span>(handleAction:) to:<span class=\"keyword\">self</span> forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)handleAction:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"handle Action\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// ViewController.m</span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> whiteColor];</div><div class=\"line\"> </div><div class=\"line\">    ImageControl *control = [[ImageControl alloc] initWithFrame:(<span class=\"built_in\">CGRect</span>)&#123;<span class=\"number\">50.0</span>f, <span class=\"number\">100.0</span>f, <span class=\"number\">200.0</span>f, <span class=\"number\">300.0</span>f&#125; title:<span class=\"string\">@\"This is a demo\"</span> image:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"demo\"</span>]];</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\"> </div><div class=\"line\">    [control addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(tapImageControl:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)tapImageControl:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"sender = %@\"</span>, sender);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们重写了 <code>sendAction:to:forEvent:</code> 方法，所以最后处理事件的 <code>Selector</code> 是 <code>ImageControl的handleAction:</code> 方法，而不是 <code>ViewController</code> 的 <code>tapImageControl:</code> 方法。</p>\n<h3 id=\"Target-Action的管理\"><a href=\"#Target-Action的管理\" class=\"headerlink\" title=\"Target-Action的管理\"></a>Target-Action的管理</h3><p>为一个控件对象添加、删除Target-Action的操作我们都已经很熟悉了，主要使用的是以下两个方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 添加</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action forControlEvents:(<span class=\"built_in\">UIControlEvents</span>)controlEvents</div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action forControlEvents:(<span class=\"built_in\">UIControlEvents</span>)controlEvents</div></pre></td></tr></table></figure></p>\n<p>如果想获取控件对象所有相关的 <code>target</code> 对象，则可以调用 <code>allTargets</code> 方法，该方法返回一个集合。集合中可能包含 <code>NSNull</code> 对象，表示至少有一个 <code>nil</code> 目标对象。</p>\n<p>而如果想获取某个 <code>target</code> 对象及事件相关的所有 <code>action</code>，则可以调用 <code>actionsForTarget:forControlEvent:</code> 方法。返回一个可变数组。</p>\n<p>就是这样<del>O(∩_∩)O</del></p>\n","excerpt":"<p>从最基础的控件开始一点点学习。先来总结下UIButton。</p>","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\"><span class=\"built_in\">CGRect</span> btn1Frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>);</div><div class=\"line\">btn1.frame = btn1Frame;</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</div></pre></td></tr></table></figure>\n<p>通过<code>init</code>和设置<code>frame</code>以及<code>addSubView</code>就可以将button添加到Voew上。</p>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><h4 id=\"通过xib关联\"><a href=\"#通过xib关联\" class=\"headerlink\" title=\"通过xib关联\"></a>通过xib关联</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btn2Pressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"点击操作\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与xib关联即可，其中<code>(id)sender</code>就表示的是这个Button</p>\n<h4 id=\"通过代码\"><a href=\"#通过代码\" class=\"headerlink\" title=\"通过代码\"></a>通过代码</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加</span></div><div class=\"line\">[btn1 addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"><span class=\"comment\">//移除</span></div><div class=\"line\">[btn1 removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>为<code>btn1</code>添加和删除一个<code>btn1Pressed</code>的点击事件。</p>\n<h2 id=\"设置title和image\"><a href=\"#设置title和image\" class=\"headerlink\" title=\"设置title和image\"></a>设置title和image</h2><p>button有<code>imageView</code>和<code>titleLabel</code>两个属性，默认image在左，label在右。</p>\n<h3 id=\"添加title和image\"><a href=\"#添加title和image\" class=\"headerlink\" title=\"添加title和image\"></a>添加title和image</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];</div><div class=\"line\">[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p>这里<code>forState</code>常用的有一下几种：</p>\n<ul>\n<li>UIControlStateNormal          常态</li>\n<li>UIControlStateHighlighted     高亮</li>\n<li>UIControlStateDisabled        禁用</li>\n<li>UIControlStateSelected        选中</li>\n</ul>\n<p>其中需要说明的是，高亮就是点击时的状态。其实还有一种<code>UIControlStateSelected | UIControlStateHighlighted</code>这个组合是选中时候的高亮状态，也是比较有用的。</p>\n<h3 id=\"设置button选中\"><a href=\"#设置button选中\" class=\"headerlink\" title=\"设置button选中\"></a>设置button选中</h3><p>button选中与否是由<code>UIControlStateSelected</code>控制的。</p>\n<p>可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于<em>点赞</em>。一般情况我们实现方式是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick:(<span class=\"built_in\">UIButton</span> *)button &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([button.currentImage isEqual:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>]]) &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like_selected\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是最好不要这样实现。可以使用<code>UIControlStateSelected</code>来控制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//点击事件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)btn1Pressed:(<span class=\"built_in\">UIButton</span> *)button&#123;</div><div class=\"line\">    <span class=\"comment\">//button.enabled 设置是否可点击。</span></div><div class=\"line\">    button.selected = !button.selected;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，每次点击的时候切换选中状态达到效果。</p>\n<p>但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。</p>\n<p>因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//normal-&gt;selected</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</div><div class=\"line\"><span class=\"comment\">//selected-&gt;normal</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span> | <span class=\"built_in\">UIControlStateHighlighted</span>];</div></pre></td></tr></table></figure></p>\n<p>好的，这样就完成了切换状态的过程。</p>\n<h3 id=\"设置image和title位置\"><a href=\"#设置image和title位置\" class=\"headerlink\" title=\"设置image和title位置\"></a>设置image和title位置</h3><p>image和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。</p>\n<h4 id=\"image和title位置互换\"><a href=\"#image和title位置互换\" class=\"headerlink\" title=\"image和title位置互换\"></a>image和title位置互换</h4><p>先看代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setTitleEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, -btn1.imageView.bounds.size.width, <span class=\"number\">0</span>, btn1.imageView.bounds.size.width)];</div><div class=\"line\">[btn1 setImageEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, btn1.titleLabel.bounds.size.width, <span class=\"number\">0</span>, -btn1.titleLabel.bounds.size.width)];</div></pre></td></tr></table></figure></p>\n<p>这里需要强调的是一定要先设置<code>title</code>再设置<code>image</code>。因为<code>title</code>是依赖于<code>image</code>的，在如果先设置<code>image</code>，这个时候<code>title</code>还没有确定，于是<code>titleLabel.bounds.size.width</code>一定是<code>0</code>，即<code>image</code>没有变。</p>\n<p>这里的<code>UIEdgeInsetsMake</code>里的四个参数分别是<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>四个方向的<code>inset</code>,默认是<code>0</code>，也就是说，所有变化都是针对当前位置的。<code>-btn1.imageView.bounds.size.width</code>表示让<code>title</code>的左边距<strong>减少</strong><code>image</code>的宽度，同理<code>btn1.imageView.bounds.size.width</code>表示让右边距<strong>增加</strong><code>image</code>的宽度。</p>\n<h4 id=\"控制image的大小\"><a href=\"#控制image的大小\" class=\"headerlink\" title=\"控制image的大小\"></a>控制image的大小</h4><p>交换了image的位置后，我就想怎么控制image的大小。尝试改变了<code>UIEdgeInsetsMake</code>的参数，发现改变<code>top</code>和<code>bottom</code>可以将图片压缩，但是改变<code>left</code> <code>right</code>图片始终不动。</p>\n<p>经过我不断尝试后终于得出了结论：<br>以横轴为例，只有当<strong>左边距+右边距+图片宽度=button宽度</strong>时，继续增加边距，才会导致图片的压缩。当<strong>左边距+右边距+图片宽度&lt;button宽度</strong>时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。</p>\n<p>因此，为什么改变<code>top</code>和<code>bottom</code>可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时<code>top</code>和<code>bottom</code>都为0，但是由于<strong>image高度=button高度</strong>，此时增加<code>top</code>和<code>bottom</code>就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。</p>\n<p>而在横轴方面，开始时，<strong>左边距+右边距+图片宽度&lt;button宽度</strong>。图片只会平移直到边距增加到使等式相等才会进行压缩。</p>\n<h2 id=\"UIControl\"><a href=\"#UIControl\" class=\"headerlink\" title=\"UIControl\"></a>UIControl</h2><h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p><code>UIControl</code> 是控件类的基类，它是一个抽象基类，我们不能直接使用 <code>UIControl</code> 类来实例化控件，它只是为控件子类定义一些通用的接口，并提供一些基础实现，以在事件发生时，预处理这些消息并将它们发送到指定目标对象上。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/uibutton_1.png?raw=true\" alt=\"UIControl\"></p>\n<h3 id=\"Target-Action机制\"><a href=\"#Target-Action机制\" class=\"headerlink\" title=\"Target-Action机制\"></a>Target-Action机制</h3><p>Target-action 是一种设计模式，直译过来就是”目标-行为”。当我们通过代码为一个按钮添加一个点击事件时，通常是如下处理：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[button addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(tapButton:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>也就是说，当按钮的点击事件发生时，会将消息发送到 <code>target</code>(此处即为 <code>self</code> 对象)，并由 <code>target</code> 对象的 <code>tapButton:</code> 方法来处理相应的事件。因此，Target-Action 机制由两部分组成：即目标对象和行为 <code>Selector</code>。目标对象指定最终处理事件的对象，而行为 <code>Selector</code> 则是处理事件的方法。</p>\n<p>我们先来看看 UIControl 为我们提供了哪些自定义跟踪行为的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)beginTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)continueTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)endTrackingWithTouch:(<span class=\"built_in\">UITouch</span> *)touch withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancelTrackingWithEvent:(<span class=\"built_in\">UIEvent</span> *)event</div></pre></td></tr></table></figure></p>\n<p>这四个方法分别对应的时跟踪开始、移动、结束、取消四种状态。跟 <code>UIResponse</code> 提供的四个事件跟踪方法是不是挺像的？我们来看看 <code>UIResponse</code> 的四个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div></pre></td></tr></table></figure>\n<p>上面两组方法的参数基本相同，只不过 <code>UIControl</code> 的是针对单点触摸，而 <code>UIResponse</code> 可能是多点触摸。另外，返回值也是大同小异。由于 <code>UIControl</code> 本身是视图，所以它实际上也继承了 <code>UIResponse</code> 的这四个方法。如果测试一下，我们会发现<strong>在针对控件的触摸事件发生时，这两组方法都会被调用，而且互不干涉。</strong></p>\n<p>对于一个给定的事件，<code>UIControl</code> 会调用 <code>sendAction:to:forEvent:</code> 来将行为消息转发到 <code>UIApplication</code>对象，再由 <code>UIApplication</code> 对象调用其 <code>sendAction:to:fromSender:forEvent:</code> 方法来将消息分发到指定的 <code>target</code> 上。而如果子类想监控或修改这种行为的话，则可以重写这个方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ImageControl.m</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)sendAction:(SEL)action to:(<span class=\"keyword\">id</span>)target forEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</div><div class=\"line\">  <span class=\"comment\">// 将事件传递到对象本身来处理</span></div><div class=\"line\">    [<span class=\"keyword\">super</span> sendAction:<span class=\"keyword\">@selector</span>(handleAction:) to:<span class=\"keyword\">self</span> forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)handleAction:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"handle Action\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// ViewController.m</span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> whiteColor];</div><div class=\"line\"> </div><div class=\"line\">    ImageControl *control = [[ImageControl alloc] initWithFrame:(<span class=\"built_in\">CGRect</span>)&#123;<span class=\"number\">50.0</span>f, <span class=\"number\">100.0</span>f, <span class=\"number\">200.0</span>f, <span class=\"number\">300.0</span>f&#125; title:<span class=\"string\">@\"This is a demo\"</span> image:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"demo\"</span>]];</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\"> </div><div class=\"line\">    [control addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(tapImageControl:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)tapImageControl:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"sender = %@\"</span>, sender);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们重写了 <code>sendAction:to:forEvent:</code> 方法，所以最后处理事件的 <code>Selector</code> 是 <code>ImageControl的handleAction:</code> 方法，而不是 <code>ViewController</code> 的 <code>tapImageControl:</code> 方法。</p>\n<h3 id=\"Target-Action的管理\"><a href=\"#Target-Action的管理\" class=\"headerlink\" title=\"Target-Action的管理\"></a>Target-Action的管理</h3><p>为一个控件对象添加、删除Target-Action的操作我们都已经很熟悉了，主要使用的是以下两个方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 添加</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action forControlEvents:(<span class=\"built_in\">UIControlEvents</span>)controlEvents</div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action forControlEvents:(<span class=\"built_in\">UIControlEvents</span>)controlEvents</div></pre></td></tr></table></figure></p>\n<p>如果想获取控件对象所有相关的 <code>target</code> 对象，则可以调用 <code>allTargets</code> 方法，该方法返回一个集合。集合中可能包含 <code>NSNull</code> 对象，表示至少有一个 <code>nil</code> 目标对象。</p>\n<p>而如果想获取某个 <code>target</code> 对象及事件相关的所有 <code>action</code>，则可以调用 <code>actionsForTarget:forControlEvent:</code> 方法。返回一个可变数组。</p>\n<p>就是这样<del>O(∩_∩)O</del></p>"},{"title":"UIScrollView详细介绍","date":"2016-09-18T06:07:12.000Z","_content":"\n本次将参考[iOS 性能优化之 UIScrollView 实践经验](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)对UIScrollView的使用方式进行详细介绍\n<!--more-->\n\n## ScrollView和Auto Layout\n`UIScrollView` 在 `Auto Layout` 是一个很特殊的 `view`，对于 `UIScrollView` 的 `subview` 来说，它的 `leading/trailing/top/bottom space` 是**相对于 `UIScrollView`的 `contentSize` 而不是 `bounds` (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。**\n\n所以，一般的做法是在`UIScrollVIew`和它的`subViews`之间增加一个`content view`。这样可以方便地给 `subview` 提供 `leading/trailing/top/bottom`，方便 `subview` 的布局，并且可以 通过调整`content view` 的 `size`（调整`constraint` 的 `IBOutlet`）来调整 `contentSize`。\n\n### 添加ContentView的注意点\n`scrollview`中添加的`contentview`和添加一般的视图不同，一般的视图只要只要提供`leading/trailing/top/bottom space`就能唯一确定长宽，位置。\n而`ScrollView`的`contentView`除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。\n\n所以整个`scrollview`的`contentSize`的等式应该是：\n```\nscrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）\n```\n\n**另外一点需要强调两点：**\n1. `ScrollView`的`bounds`早就确定了下来，在设置`contentview`的宽度的时候，如果设置`contentview.width = superview.width + constant`这里的`superview.width`是指`ScrollView.bounds`而不是`contentSize`\n2. 在设置`contentview`的上下左右约束的时候，如果设置`contentview.trailing = superview.trailing + constant`,这里的`superview.trailing`指的是`contentSize.trailing`而不是`bounds`。此时就可以通过上面的公式计算`contentSize`的宽度了。\n\n> Demo参见AutoLayout\n\n## UIScrollView部分属性\n### **contentSize**、**contentInset**和**contentOffset**\n- contentSize: 就是scrollview可以滚动的区域.\n比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。\n- contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。\n比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 \n- contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。\n例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 \n\n/* 上拉刷新一般实现代码如下 */\n```objc\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{     \n    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  \n    float offset=scrollView.contentOffset.y;  \n    float contentHeight=scrollView.contentSize.height;  \n    float sub=contentHeight-offset;  \n    if ((scrollView.height-sub)>20) {//如果上拉距离超过20p，则加载更多数据  \n        //[self loadMoreData];//此处在view底部加载更多数据  \n    }  \n}\n```\n\n\n## UIScrollViewDelegate\n`UIScrollViewDelegate` 是 `UIScrollView` 的 `delegate protocol`，`UIScrollView` 有意思的功能都是通过它的 delegate 方法实现的。\n\n### - (void)scrollViewDidScroll:(UIScrollView *)scrollView\n这个方法在任何方式触发 `contentOffset` 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 `contentOffset` 的变化，并根据当前的 `contentOffset` 对其他 view 做出随动调整。\n\n### - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n用户开始拖动 scroll view 的时候被调用。\n\n### - (void)scrollViewWillEndDragging:(UIScrollView \\*)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint \\*)targetContentOffset\n在 didEndDragging 前被调用，当 willEndDragging 方法中 `velocity` 为 `CGPointZero`（结束拖动时两个方向都没有速度）时，didEndDragging 中的 `decelerate` 为 `NO`，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 `velocity` 不为 `CGPointZero` 时，scroll view 会以 `velocity` 为初速度，减速直到 `targetContentOffset`。值得注意的是，这里的 `targetContentOffset` 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。\n\n### - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n在用户结束拖动后被调用，`decelerate` 为 `YES` 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 `NO`，而是要等到减速结束之后，所以**这个 dragging 属性的实际语义更接近 scrolling**。\n\n### - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\n减速动画开始前被调用。\n\n### - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n减速动画结束时被调用。\n\n这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，**并且这时 scroll view 的 `dragging` 和 `decelerating` 属性都是 `YES`**(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。\n\n> Demo参见Delegate\n\n\n\n## 实例\n### Table View 中图片加载逻辑的优化\n**优化目的**：滑动时不加载图片，在滑动停止时加载图片\n\n**优化难点**：前面提到，刚开始拖动的时候，`dragging` 为 `YES`，`decelerating` 为 `NO`；`decelerate` 过程中，`dragging` 和 `decelerating` 都为 `YES`；decelerate 未结束时开始下一次拖动，`dragging` 和 `decelerating` 依然都为 `YES`。所以无法简单通过 table view 的 `dragging` 和 `decelerating` 判断是在用户拖动还是减速过程。\n\n所以不能仅通过`decelerating`来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看[原文](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)比较好）\n\n**优化方法**：\n1. 每次开始拖动时scrollViewWillBeginDragging，通过`NSArray *cells = [self.tableView visibleCells];`获取屏幕上所有显示的`Cell`，全部加载一遍图片（解决问题三）\n2. 利用`scrollViewWillEndDragging: withVelocity: targetContentOffset: `方法，将`targetContentOffset`即最后减速结束后在屏幕上显示的位置，转换为一个`CGRect`，在`CGRect`范围里的`Cell`才在`CellForRowAtIndex`中加载。\n\n> Demo详见LazyLoad\n\n### 分页的几种实现方法\n分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。\n\n#### pagingEnabled\n系统提供的分页方式，实现简单，只需要`_scrollView.pagingEnabled = YES`即可，但是有局限性：\n- 只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。\n- 需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）\n\nSample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：\n- 让 scroll view 的宽度为 page 宽度 + padding，并且设置 `clipsToBounds` 为 `NO`,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:\n- 这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能\n\n![UIScrollView_pagingEnabled](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true)\n\n适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。\n\n#### Snap\n核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。\n\n#### 修改targetContentOffset\n通过修改 `scrollViewWillEndDragging: withVelocity: targetContentOffset:` 方法中的 `targetContentOffset` 直接修改目标 `offset` 为整数页位置。其中核心代码：\n```objc\n- (CGPoint)nearestTargetOffsetForOffset:(CGPoint)offset\n{    CGFloat pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    NSInteger page = roundf(offset.x / pageSize);    CGFloat targetX = pageSize * page;    return CGPointMake(targetX, offset.y);\n}\n\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n{    CGPoint targetOffset = [self nearestTargetOffsetForOffset:*targetContentOffset];\n    targetContentOffset->x = targetOffset.x;\n    targetContentOffset->y = targetOffset.y;\n}\n```\n\n适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。\n\n> Demo详见Pagination\n\n### 重用\n大部分的 iOS 开发应该都清楚 `UITableView` 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，`UIScrollView` 作为 `UITableView` 的父类，在很多场景中也很适合应用重用机制。\n\n可以参照 `UITableView` 的 cell 重用机制，总结重用机制如下：\n- 维护一个重用队列\n- 当元素离开可见范围时，`removeFromSuperview` 并加入重用队列（enqueue）\n- 当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除\n- 如果队列为空，新建元素\n- 将新建元素的view通过`addSubView`添加至 `contentView`上\n- 这些一般都在 `scrollViewDidScroll:` 方法中完成\n\nDemo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo\n\n---\n这里要说明一下Demo中用到的`addChildViewController`。\n\n苹果在iOS 5 添加了一系列的方法，希望我们在使用`addSubView`时，同时调用`[self addChildViewController:child]`方法将sub view对应的viewController也加到当前ViewController的管理中。\n\n对于那些当前暂时不需要显示的subview，只通过`addChildViewController`把subViewController加进去；需要显示时再调用`transitionFromViewController`方法。将其添加进入底层的ViewController中。\n\n这样做的好处：\n1. 对页面中的逻辑更加分明了。相应的View对应相应的ViewController。\n2. 当某个子View没有显示时，将不会被Load，减少了内存的使用。\n3. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。\n4. 可以调用`transitionFromViewController`等系统方法，ios对于显示以及动画做了比较好的封装\n5. 相当于对于 ViewController 实例的保存。实例都保存在`self.childViewControllers`中，需要使用的时候从中取出即可。\n\n当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。\n\n其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候`[self.contentView addSubview:vc.view];`,不需要显示的时候`[vc.view removeFromSuperview];`，就可以达到显示和相应事件的需求了。\n\n---\n\n> Demo详见Reuse\n\n### 联动\n所谓联动，就是当 A 滚动的时候，在 **`scrollViewDidScroll:`** 里根据 A 的 `contentOffset` 动态计算 B 的 `contentOffset` 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。\n\nDemo中的核心代码:\n```objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView{\n    if (scrollView == self.titleScrollView) {\n        CGFloat contentX = self.titleScrollView.contentOffset.x / self.titleScrollView.frame.size.width * self.contentScrollView.frame.size.width;\n        self.contentScrollView.contentOffset = CGPointMake(contentX, 0.0);\n        CGFloat transX = self.titleScrollView.contentOffset.x / (self.titleScrollView.contentSize.width - self.titleScrollView.frame.size.width) * (self.backgroundImage.frame.size.width - self.view.frame.size.width);\n        transX = MAX(0.0, transX);\n        transX = MIN(self.backgroundImage.frame.size.width - self.view.frame.size.width, transX);\n        self.backgroundImage.transform = CGAffineTransformMakeTranslation(-transX, 0.0);\n    }\n}\n```\n通过`titleScrollView`计算`contentX`和`transX`来分别控制`contentScrollView`以及`backgroundImage`这两个View的位置变化。\n\n> Demo参见Parallax\n\n## 总结\nScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.\n\n> 上述所有Demo均在UIScrollViewDemo文件夹中\n\n\n\n\n\n\n","source":"_posts/Scrollview使用详解.md","raw":"title: UIScrollView详细介绍\ndate: 2016/9/18 14:07:12  \ncategories: iOS\ntags: \n\t- 基本控件\n\t\n---\n\n本次将参考[iOS 性能优化之 UIScrollView 实践经验](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)对UIScrollView的使用方式进行详细介绍\n<!--more-->\n\n## ScrollView和Auto Layout\n`UIScrollView` 在 `Auto Layout` 是一个很特殊的 `view`，对于 `UIScrollView` 的 `subview` 来说，它的 `leading/trailing/top/bottom space` 是**相对于 `UIScrollView`的 `contentSize` 而不是 `bounds` (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。**\n\n所以，一般的做法是在`UIScrollVIew`和它的`subViews`之间增加一个`content view`。这样可以方便地给 `subview` 提供 `leading/trailing/top/bottom`，方便 `subview` 的布局，并且可以 通过调整`content view` 的 `size`（调整`constraint` 的 `IBOutlet`）来调整 `contentSize`。\n\n### 添加ContentView的注意点\n`scrollview`中添加的`contentview`和添加一般的视图不同，一般的视图只要只要提供`leading/trailing/top/bottom space`就能唯一确定长宽，位置。\n而`ScrollView`的`contentView`除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。\n\n所以整个`scrollview`的`contentSize`的等式应该是：\n```\nscrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）\n```\n\n**另外一点需要强调两点：**\n1. `ScrollView`的`bounds`早就确定了下来，在设置`contentview`的宽度的时候，如果设置`contentview.width = superview.width + constant`这里的`superview.width`是指`ScrollView.bounds`而不是`contentSize`\n2. 在设置`contentview`的上下左右约束的时候，如果设置`contentview.trailing = superview.trailing + constant`,这里的`superview.trailing`指的是`contentSize.trailing`而不是`bounds`。此时就可以通过上面的公式计算`contentSize`的宽度了。\n\n> Demo参见AutoLayout\n\n## UIScrollView部分属性\n### **contentSize**、**contentInset**和**contentOffset**\n- contentSize: 就是scrollview可以滚动的区域.\n比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。\n- contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。\n比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 \n- contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。\n例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 \n\n/* 上拉刷新一般实现代码如下 */\n```objc\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{     \n    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  \n    float offset=scrollView.contentOffset.y;  \n    float contentHeight=scrollView.contentSize.height;  \n    float sub=contentHeight-offset;  \n    if ((scrollView.height-sub)>20) {//如果上拉距离超过20p，则加载更多数据  \n        //[self loadMoreData];//此处在view底部加载更多数据  \n    }  \n}\n```\n\n\n## UIScrollViewDelegate\n`UIScrollViewDelegate` 是 `UIScrollView` 的 `delegate protocol`，`UIScrollView` 有意思的功能都是通过它的 delegate 方法实现的。\n\n### - (void)scrollViewDidScroll:(UIScrollView *)scrollView\n这个方法在任何方式触发 `contentOffset` 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 `contentOffset` 的变化，并根据当前的 `contentOffset` 对其他 view 做出随动调整。\n\n### - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n用户开始拖动 scroll view 的时候被调用。\n\n### - (void)scrollViewWillEndDragging:(UIScrollView \\*)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint \\*)targetContentOffset\n在 didEndDragging 前被调用，当 willEndDragging 方法中 `velocity` 为 `CGPointZero`（结束拖动时两个方向都没有速度）时，didEndDragging 中的 `decelerate` 为 `NO`，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 `velocity` 不为 `CGPointZero` 时，scroll view 会以 `velocity` 为初速度，减速直到 `targetContentOffset`。值得注意的是，这里的 `targetContentOffset` 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。\n\n### - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n在用户结束拖动后被调用，`decelerate` 为 `YES` 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 `NO`，而是要等到减速结束之后，所以**这个 dragging 属性的实际语义更接近 scrolling**。\n\n### - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\n减速动画开始前被调用。\n\n### - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n减速动画结束时被调用。\n\n这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，**并且这时 scroll view 的 `dragging` 和 `decelerating` 属性都是 `YES`**(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。\n\n> Demo参见Delegate\n\n\n\n## 实例\n### Table View 中图片加载逻辑的优化\n**优化目的**：滑动时不加载图片，在滑动停止时加载图片\n\n**优化难点**：前面提到，刚开始拖动的时候，`dragging` 为 `YES`，`decelerating` 为 `NO`；`decelerate` 过程中，`dragging` 和 `decelerating` 都为 `YES`；decelerate 未结束时开始下一次拖动，`dragging` 和 `decelerating` 依然都为 `YES`。所以无法简单通过 table view 的 `dragging` 和 `decelerating` 判断是在用户拖动还是减速过程。\n\n所以不能仅通过`decelerating`来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看[原文](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)比较好）\n\n**优化方法**：\n1. 每次开始拖动时scrollViewWillBeginDragging，通过`NSArray *cells = [self.tableView visibleCells];`获取屏幕上所有显示的`Cell`，全部加载一遍图片（解决问题三）\n2. 利用`scrollViewWillEndDragging: withVelocity: targetContentOffset: `方法，将`targetContentOffset`即最后减速结束后在屏幕上显示的位置，转换为一个`CGRect`，在`CGRect`范围里的`Cell`才在`CellForRowAtIndex`中加载。\n\n> Demo详见LazyLoad\n\n### 分页的几种实现方法\n分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。\n\n#### pagingEnabled\n系统提供的分页方式，实现简单，只需要`_scrollView.pagingEnabled = YES`即可，但是有局限性：\n- 只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。\n- 需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）\n\nSample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：\n- 让 scroll view 的宽度为 page 宽度 + padding，并且设置 `clipsToBounds` 为 `NO`,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:\n- 这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能\n\n![UIScrollView_pagingEnabled](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true)\n\n适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。\n\n#### Snap\n核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。\n\n#### 修改targetContentOffset\n通过修改 `scrollViewWillEndDragging: withVelocity: targetContentOffset:` 方法中的 `targetContentOffset` 直接修改目标 `offset` 为整数页位置。其中核心代码：\n```objc\n- (CGPoint)nearestTargetOffsetForOffset:(CGPoint)offset\n{    CGFloat pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    NSInteger page = roundf(offset.x / pageSize);    CGFloat targetX = pageSize * page;    return CGPointMake(targetX, offset.y);\n}\n\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n{    CGPoint targetOffset = [self nearestTargetOffsetForOffset:*targetContentOffset];\n    targetContentOffset->x = targetOffset.x;\n    targetContentOffset->y = targetOffset.y;\n}\n```\n\n适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。\n\n> Demo详见Pagination\n\n### 重用\n大部分的 iOS 开发应该都清楚 `UITableView` 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，`UIScrollView` 作为 `UITableView` 的父类，在很多场景中也很适合应用重用机制。\n\n可以参照 `UITableView` 的 cell 重用机制，总结重用机制如下：\n- 维护一个重用队列\n- 当元素离开可见范围时，`removeFromSuperview` 并加入重用队列（enqueue）\n- 当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除\n- 如果队列为空，新建元素\n- 将新建元素的view通过`addSubView`添加至 `contentView`上\n- 这些一般都在 `scrollViewDidScroll:` 方法中完成\n\nDemo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo\n\n---\n这里要说明一下Demo中用到的`addChildViewController`。\n\n苹果在iOS 5 添加了一系列的方法，希望我们在使用`addSubView`时，同时调用`[self addChildViewController:child]`方法将sub view对应的viewController也加到当前ViewController的管理中。\n\n对于那些当前暂时不需要显示的subview，只通过`addChildViewController`把subViewController加进去；需要显示时再调用`transitionFromViewController`方法。将其添加进入底层的ViewController中。\n\n这样做的好处：\n1. 对页面中的逻辑更加分明了。相应的View对应相应的ViewController。\n2. 当某个子View没有显示时，将不会被Load，减少了内存的使用。\n3. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。\n4. 可以调用`transitionFromViewController`等系统方法，ios对于显示以及动画做了比较好的封装\n5. 相当于对于 ViewController 实例的保存。实例都保存在`self.childViewControllers`中，需要使用的时候从中取出即可。\n\n当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。\n\n其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候`[self.contentView addSubview:vc.view];`,不需要显示的时候`[vc.view removeFromSuperview];`，就可以达到显示和相应事件的需求了。\n\n---\n\n> Demo详见Reuse\n\n### 联动\n所谓联动，就是当 A 滚动的时候，在 **`scrollViewDidScroll:`** 里根据 A 的 `contentOffset` 动态计算 B 的 `contentOffset` 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。\n\nDemo中的核心代码:\n```objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView{\n    if (scrollView == self.titleScrollView) {\n        CGFloat contentX = self.titleScrollView.contentOffset.x / self.titleScrollView.frame.size.width * self.contentScrollView.frame.size.width;\n        self.contentScrollView.contentOffset = CGPointMake(contentX, 0.0);\n        CGFloat transX = self.titleScrollView.contentOffset.x / (self.titleScrollView.contentSize.width - self.titleScrollView.frame.size.width) * (self.backgroundImage.frame.size.width - self.view.frame.size.width);\n        transX = MAX(0.0, transX);\n        transX = MIN(self.backgroundImage.frame.size.width - self.view.frame.size.width, transX);\n        self.backgroundImage.transform = CGAffineTransformMakeTranslation(-transX, 0.0);\n    }\n}\n```\n通过`titleScrollView`计算`contentX`和`transX`来分别控制`contentScrollView`以及`backgroundImage`这两个View的位置变化。\n\n> Demo参见Parallax\n\n## 总结\nScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.\n\n> 上述所有Demo均在UIScrollViewDemo文件夹中\n\n\n\n\n\n\n","slug":"Scrollview使用详解","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpq001b7hzgqlef9l0q","content":"<p>本次将参考<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\" target=\"_blank\" rel=\"external\">iOS 性能优化之 UIScrollView 实践经验</a>对UIScrollView的使用方式进行详细介绍<br><a id=\"more\"></a></p>\n<h2 id=\"ScrollView和Auto-Layout\"><a href=\"#ScrollView和Auto-Layout\" class=\"headerlink\" title=\"ScrollView和Auto Layout\"></a>ScrollView和Auto Layout</h2><p><code>UIScrollView</code> 在 <code>Auto Layout</code> 是一个很特殊的 <code>view</code>，对于 <code>UIScrollView</code> 的 <code>subview</code> 来说，它的 <code>leading/trailing/top/bottom space</code> 是<strong>相对于 <code>UIScrollView</code>的 <code>contentSize</code> 而不是 <code>bounds</code> (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。</strong></p>\n<p>所以，一般的做法是在<code>UIScrollVIew</code>和它的<code>subViews</code>之间增加一个<code>content view</code>。这样可以方便地给 <code>subview</code> 提供 <code>leading/trailing/top/bottom</code>，方便 <code>subview</code> 的布局，并且可以 通过调整<code>content view</code> 的 <code>size</code>（调整<code>constraint</code> 的 <code>IBOutlet</code>）来调整 <code>contentSize</code>。</p>\n<h3 id=\"添加ContentView的注意点\"><a href=\"#添加ContentView的注意点\" class=\"headerlink\" title=\"添加ContentView的注意点\"></a>添加ContentView的注意点</h3><p><code>scrollview</code>中添加的<code>contentview</code>和添加一般的视图不同，一般的视图只要只要提供<code>leading/trailing/top/bottom space</code>就能唯一确定长宽，位置。<br>而<code>ScrollView</code>的<code>contentView</code>除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。</p>\n<p>所以整个<code>scrollview</code>的<code>contentSize</code>的等式应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）</div></pre></td></tr></table></figure></p>\n<p><strong>另外一点需要强调两点：</strong></p>\n<ol>\n<li><code>ScrollView</code>的<code>bounds</code>早就确定了下来，在设置<code>contentview</code>的宽度的时候，如果设置<code>contentview.width = superview.width + constant</code>这里的<code>superview.width</code>是指<code>ScrollView.bounds</code>而不是<code>contentSize</code></li>\n<li>在设置<code>contentview</code>的上下左右约束的时候，如果设置<code>contentview.trailing = superview.trailing + constant</code>,这里的<code>superview.trailing</code>指的是<code>contentSize.trailing</code>而不是<code>bounds</code>。此时就可以通过上面的公式计算<code>contentSize</code>的宽度了。</li>\n</ol>\n<blockquote>\n<p>Demo参见AutoLayout</p>\n</blockquote>\n<h2 id=\"UIScrollView部分属性\"><a href=\"#UIScrollView部分属性\" class=\"headerlink\" title=\"UIScrollView部分属性\"></a>UIScrollView部分属性</h2><h3 id=\"contentSize、contentInset和contentOffset\"><a href=\"#contentSize、contentInset和contentOffset\" class=\"headerlink\" title=\"contentSize、contentInset和contentOffset\"></a><strong>contentSize</strong>、<strong>contentInset</strong>和<strong>contentOffset</strong></h3><ul>\n<li>contentSize: 就是scrollview可以滚动的区域.<br>比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。</li>\n<li>contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。<br>比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 </li>\n<li>contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。<br>例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 </li>\n</ul>\n<p>/<em> 上拉刷新一般实现代码如下 </em>/<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView willDecelerate:(<span class=\"built_in\">BOOL</span>)decelerate&#123;     </div><div class=\"line\">    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  </div><div class=\"line\">    <span class=\"keyword\">float</span> offset=scrollView.contentOffset.y;  </div><div class=\"line\">    <span class=\"keyword\">float</span> contentHeight=scrollView.contentSize.height;  </div><div class=\"line\">    <span class=\"keyword\">float</span> sub=contentHeight-offset;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ((scrollView.height-sub)&gt;<span class=\"number\">20</span>) &#123;<span class=\"comment\">//如果上拉距离超过20p，则加载更多数据  </span></div><div class=\"line\">        <span class=\"comment\">//[self loadMoreData];//此处在view底部加载更多数据  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UIScrollViewDelegate\"><a href=\"#UIScrollViewDelegate\" class=\"headerlink\" title=\"UIScrollViewDelegate\"></a>UIScrollViewDelegate</h2><p><code>UIScrollViewDelegate</code> 是 <code>UIScrollView</code> 的 <code>delegate protocol</code>，<code>UIScrollView</code> 有意思的功能都是通过它的 delegate 方法实现的。</p>\n<h3 id=\"void-scrollViewDidScroll-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidScroll-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidScroll:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</h3><p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>\n<h3 id=\"void-scrollViewWillBeginDragging-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDragging-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</h3><p>用户开始拖动 scroll view 的时候被调用。</p>\n<h3 id=\"void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\"><a href=\"#void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\" class=\"headerlink\" title=\"- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\"></a>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset</h3><p>在 didEndDragging 前被调用，当 willEndDragging 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，didEndDragging 中的 <code>decelerate</code> 为 <code>NO</code>，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。</p>\n<h3 id=\"void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\"><a href=\"#void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\"></a>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</h3><p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 <code>NO</code>，而是要等到减速结束之后，所以<strong>这个 dragging 属性的实际语义更接近 scrolling</strong>。</p>\n<h3 id=\"void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView</h3><p>减速动画开始前被调用。</p>\n<h3 id=\"void-scrollViewDidEndDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidEndDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</h3><p>减速动画结束时被调用。</p>\n<p>这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，<strong>并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 <code>YES</code></strong>(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。</p>\n<blockquote>\n<p>Demo参见Delegate</p>\n</blockquote>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"Table-View-中图片加载逻辑的优化\"><a href=\"#Table-View-中图片加载逻辑的优化\" class=\"headerlink\" title=\"Table View 中图片加载逻辑的优化\"></a>Table View 中图片加载逻辑的优化</h3><p><strong>优化目的</strong>：滑动时不加载图片，在滑动停止时加载图片</p>\n<p><strong>优化难点</strong>：前面提到，刚开始拖动的时候，<code>dragging</code> 为 <code>YES</code>，<code>decelerating</code> 为 <code>NO</code>；<code>decelerate</code> 过程中，<code>dragging</code> 和 <code>decelerating</code> 都为 <code>YES</code>；decelerate 未结束时开始下一次拖动，<code>dragging</code> 和 <code>decelerating</code> 依然都为 <code>YES</code>。所以无法简单通过 table view 的 <code>dragging</code> 和 <code>decelerating</code> 判断是在用户拖动还是减速过程。</p>\n<p>所以不能仅通过<code>decelerating</code>来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\" target=\"_blank\" rel=\"external\">原文</a>比较好）</p>\n<p><strong>优化方法</strong>：</p>\n<ol>\n<li>每次开始拖动时scrollViewWillBeginDragging，通过<code>NSArray *cells = [self.tableView visibleCells];</code>获取屏幕上所有显示的<code>Cell</code>，全部加载一遍图片（解决问题三）</li>\n<li>利用<code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code>方法，将<code>targetContentOffset</code>即最后减速结束后在屏幕上显示的位置，转换为一个<code>CGRect</code>，在<code>CGRect</code>范围里的<code>Cell</code>才在<code>CellForRowAtIndex</code>中加载。</li>\n</ol>\n<blockquote>\n<p>Demo详见LazyLoad</p>\n</blockquote>\n<h3 id=\"分页的几种实现方法\"><a href=\"#分页的几种实现方法\" class=\"headerlink\" title=\"分页的几种实现方法\"></a>分页的几种实现方法</h3><p>分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。</p>\n<h4 id=\"pagingEnabled\"><a href=\"#pagingEnabled\" class=\"headerlink\" title=\"pagingEnabled\"></a>pagingEnabled</h4><p>系统提供的分页方式，实现简单，只需要<code>_scrollView.pagingEnabled = YES</code>即可，但是有局限性：</p>\n<ul>\n<li>只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。</li>\n<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>\n</ul>\n<p>Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>\n<ul>\n<li>让 scroll view 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 <code>NO</code>,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:</li>\n<li>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true\" alt=\"UIScrollView_pagingEnabled\"></p>\n<p>适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>\n<h4 id=\"Snap\"><a href=\"#Snap\" class=\"headerlink\" title=\"Snap\"></a>Snap</h4><p>核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。</p>\n<h4 id=\"修改targetContentOffset\"><a href=\"#修改targetContentOffset\" class=\"headerlink\" title=\"修改targetContentOffset\"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 <code>offset</code> 为整数页位置。其中核心代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)nearestTargetOffsetForOffset:(<span class=\"built_in\">CGPoint</span>)offset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    <span class=\"built_in\">NSInteger</span> page = roundf(offset.x / pageSize);    <span class=\"built_in\">CGFloat</span> targetX = pageSize * page;    <span class=\"keyword\">return</span> <span class=\"built_in\">CGPointMake</span>(targetX, offset.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGPoint</span> targetOffset = [<span class=\"keyword\">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class=\"line\">    targetContentOffset-&gt;x = targetOffset.x;</div><div class=\"line\">    targetContentOffset-&gt;y = targetOffset.y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>\n<blockquote>\n<p>Demo详见Pagination</p>\n</blockquote>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>大部分的 iOS 开发应该都清楚 <code>UITableView</code> 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，<code>UIScrollView</code> 作为 <code>UITableView</code> 的父类，在很多场景中也很适合应用重用机制。</p>\n<p>可以参照 <code>UITableView</code> 的 cell 重用机制，总结重用机制如下：</p>\n<ul>\n<li>维护一个重用队列</li>\n<li>当元素离开可见范围时，<code>removeFromSuperview</code> 并加入重用队列（enqueue）</li>\n<li>当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除</li>\n<li>如果队列为空，新建元素</li>\n<li>将新建元素的view通过<code>addSubView</code>添加至 <code>contentView</code>上</li>\n<li>这些一般都在 <code>scrollViewDidScroll:</code> 方法中完成</li>\n</ul>\n<p>Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo</p>\n<hr>\n<p>这里要说明一下Demo中用到的<code>addChildViewController</code>。</p>\n<p>苹果在iOS 5 添加了一系列的方法，希望我们在使用<code>addSubView</code>时，同时调用<code>[self addChildViewController:child]</code>方法将sub view对应的viewController也加到当前ViewController的管理中。</p>\n<p>对于那些当前暂时不需要显示的subview，只通过<code>addChildViewController</code>把subViewController加进去；需要显示时再调用<code>transitionFromViewController</code>方法。将其添加进入底层的ViewController中。</p>\n<p>这样做的好处：</p>\n<ol>\n<li>对页面中的逻辑更加分明了。相应的View对应相应的ViewController。</li>\n<li>当某个子View没有显示时，将不会被Load，减少了内存的使用。</li>\n<li>当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。</li>\n<li>可以调用<code>transitionFromViewController</code>等系统方法，ios对于显示以及动画做了比较好的封装</li>\n<li>相当于对于 ViewController 实例的保存。实例都保存在<code>self.childViewControllers</code>中，需要使用的时候从中取出即可。</li>\n</ol>\n<p>当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。</p>\n<p>其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候<code>[self.contentView addSubview:vc.view];</code>,不需要显示的时候<code>[vc.view removeFromSuperview];</code>，就可以达到显示和相应事件的需求了。</p>\n<hr>\n<blockquote>\n<p>Demo详见Reuse</p>\n</blockquote>\n<h3 id=\"联动\"><a href=\"#联动\" class=\"headerlink\" title=\"联动\"></a>联动</h3><p>所谓联动，就是当 A 滚动的时候，在 <strong><code>scrollViewDidScroll:</code></strong> 里根据 A 的 <code>contentOffset</code> 动态计算 B 的 <code>contentOffset</code> 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。</p>\n<p>Demo中的核心代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scrollView == <span class=\"keyword\">self</span>.titleScrollView) &#123;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> contentX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / <span class=\"keyword\">self</span>.titleScrollView.frame.size.width * <span class=\"keyword\">self</span>.contentScrollView.frame.size.width;</div><div class=\"line\">        <span class=\"keyword\">self</span>.contentScrollView.contentOffset = <span class=\"built_in\">CGPointMake</span>(contentX, <span class=\"number\">0.0</span>);</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> transX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / (<span class=\"keyword\">self</span>.titleScrollView.contentSize.width - <span class=\"keyword\">self</span>.titleScrollView.frame.size.width) * (<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width);</div><div class=\"line\">        transX = MAX(<span class=\"number\">0.0</span>, transX);</div><div class=\"line\">        transX = MIN(<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width, transX);</div><div class=\"line\">        <span class=\"keyword\">self</span>.backgroundImage.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(-transX, <span class=\"number\">0.0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>titleScrollView</code>计算<code>contentX</code>和<code>transX</code>来分别控制<code>contentScrollView</code>以及<code>backgroundImage</code>这两个View的位置变化。</p>\n<blockquote>\n<p>Demo参见Parallax</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.</p>\n<blockquote>\n<p>上述所有Demo均在UIScrollViewDemo文件夹中</p>\n</blockquote>\n","excerpt":"<p>本次将参考<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\">iOS 性能优化之 UIScrollView 实践经验</a>对UIScrollView的使用方式进行详细介绍<br>","more":"</p>\n<h2 id=\"ScrollView和Auto-Layout\"><a href=\"#ScrollView和Auto-Layout\" class=\"headerlink\" title=\"ScrollView和Auto Layout\"></a>ScrollView和Auto Layout</h2><p><code>UIScrollView</code> 在 <code>Auto Layout</code> 是一个很特殊的 <code>view</code>，对于 <code>UIScrollView</code> 的 <code>subview</code> 来说，它的 <code>leading/trailing/top/bottom space</code> 是<strong>相对于 <code>UIScrollView</code>的 <code>contentSize</code> 而不是 <code>bounds</code> (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。</strong></p>\n<p>所以，一般的做法是在<code>UIScrollVIew</code>和它的<code>subViews</code>之间增加一个<code>content view</code>。这样可以方便地给 <code>subview</code> 提供 <code>leading/trailing/top/bottom</code>，方便 <code>subview</code> 的布局，并且可以 通过调整<code>content view</code> 的 <code>size</code>（调整<code>constraint</code> 的 <code>IBOutlet</code>）来调整 <code>contentSize</code>。</p>\n<h3 id=\"添加ContentView的注意点\"><a href=\"#添加ContentView的注意点\" class=\"headerlink\" title=\"添加ContentView的注意点\"></a>添加ContentView的注意点</h3><p><code>scrollview</code>中添加的<code>contentview</code>和添加一般的视图不同，一般的视图只要只要提供<code>leading/trailing/top/bottom space</code>就能唯一确定长宽，位置。<br>而<code>ScrollView</code>的<code>contentView</code>除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。</p>\n<p>所以整个<code>scrollview</code>的<code>contentSize</code>的等式应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）</div></pre></td></tr></table></figure></p>\n<p><strong>另外一点需要强调两点：</strong></p>\n<ol>\n<li><code>ScrollView</code>的<code>bounds</code>早就确定了下来，在设置<code>contentview</code>的宽度的时候，如果设置<code>contentview.width = superview.width + constant</code>这里的<code>superview.width</code>是指<code>ScrollView.bounds</code>而不是<code>contentSize</code></li>\n<li>在设置<code>contentview</code>的上下左右约束的时候，如果设置<code>contentview.trailing = superview.trailing + constant</code>,这里的<code>superview.trailing</code>指的是<code>contentSize.trailing</code>而不是<code>bounds</code>。此时就可以通过上面的公式计算<code>contentSize</code>的宽度了。</li>\n</ol>\n<blockquote>\n<p>Demo参见AutoLayout</p>\n</blockquote>\n<h2 id=\"UIScrollView部分属性\"><a href=\"#UIScrollView部分属性\" class=\"headerlink\" title=\"UIScrollView部分属性\"></a>UIScrollView部分属性</h2><h3 id=\"contentSize、contentInset和contentOffset\"><a href=\"#contentSize、contentInset和contentOffset\" class=\"headerlink\" title=\"contentSize、contentInset和contentOffset\"></a><strong>contentSize</strong>、<strong>contentInset</strong>和<strong>contentOffset</strong></h3><ul>\n<li>contentSize: 就是scrollview可以滚动的区域.<br>比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。</li>\n<li>contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。<br>比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 </li>\n<li>contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。<br>例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 </li>\n</ul>\n<p>/<em> 上拉刷新一般实现代码如下 </em>/<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView willDecelerate:(<span class=\"built_in\">BOOL</span>)decelerate&#123;     </div><div class=\"line\">    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  </div><div class=\"line\">    <span class=\"keyword\">float</span> offset=scrollView.contentOffset.y;  </div><div class=\"line\">    <span class=\"keyword\">float</span> contentHeight=scrollView.contentSize.height;  </div><div class=\"line\">    <span class=\"keyword\">float</span> sub=contentHeight-offset;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ((scrollView.height-sub)&gt;<span class=\"number\">20</span>) &#123;<span class=\"comment\">//如果上拉距离超过20p，则加载更多数据  </span></div><div class=\"line\">        <span class=\"comment\">//[self loadMoreData];//此处在view底部加载更多数据  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UIScrollViewDelegate\"><a href=\"#UIScrollViewDelegate\" class=\"headerlink\" title=\"UIScrollViewDelegate\"></a>UIScrollViewDelegate</h2><p><code>UIScrollViewDelegate</code> 是 <code>UIScrollView</code> 的 <code>delegate protocol</code>，<code>UIScrollView</code> 有意思的功能都是通过它的 delegate 方法实现的。</p>\n<h3 id=\"void-scrollViewDidScroll-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidScroll-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidScroll:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</h3><p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>\n<h3 id=\"void-scrollViewWillBeginDragging-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDragging-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</h3><p>用户开始拖动 scroll view 的时候被调用。</p>\n<h3 id=\"void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\"><a href=\"#void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\" class=\"headerlink\" title=\"- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\"></a>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset</h3><p>在 didEndDragging 前被调用，当 willEndDragging 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，didEndDragging 中的 <code>decelerate</code> 为 <code>NO</code>，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。</p>\n<h3 id=\"void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\"><a href=\"#void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\"></a>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</h3><p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 <code>NO</code>，而是要等到减速结束之后，所以<strong>这个 dragging 属性的实际语义更接近 scrolling</strong>。</p>\n<h3 id=\"void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView</h3><p>减速动画开始前被调用。</p>\n<h3 id=\"void-scrollViewDidEndDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidEndDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</h3><p>减速动画结束时被调用。</p>\n<p>这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，<strong>并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 <code>YES</code></strong>(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。</p>\n<blockquote>\n<p>Demo参见Delegate</p>\n</blockquote>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"Table-View-中图片加载逻辑的优化\"><a href=\"#Table-View-中图片加载逻辑的优化\" class=\"headerlink\" title=\"Table View 中图片加载逻辑的优化\"></a>Table View 中图片加载逻辑的优化</h3><p><strong>优化目的</strong>：滑动时不加载图片，在滑动停止时加载图片</p>\n<p><strong>优化难点</strong>：前面提到，刚开始拖动的时候，<code>dragging</code> 为 <code>YES</code>，<code>decelerating</code> 为 <code>NO</code>；<code>decelerate</code> 过程中，<code>dragging</code> 和 <code>decelerating</code> 都为 <code>YES</code>；decelerate 未结束时开始下一次拖动，<code>dragging</code> 和 <code>decelerating</code> 依然都为 <code>YES</code>。所以无法简单通过 table view 的 <code>dragging</code> 和 <code>decelerating</code> 判断是在用户拖动还是减速过程。</p>\n<p>所以不能仅通过<code>decelerating</code>来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\">原文</a>比较好）</p>\n<p><strong>优化方法</strong>：</p>\n<ol>\n<li>每次开始拖动时scrollViewWillBeginDragging，通过<code>NSArray *cells = [self.tableView visibleCells];</code>获取屏幕上所有显示的<code>Cell</code>，全部加载一遍图片（解决问题三）</li>\n<li>利用<code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code>方法，将<code>targetContentOffset</code>即最后减速结束后在屏幕上显示的位置，转换为一个<code>CGRect</code>，在<code>CGRect</code>范围里的<code>Cell</code>才在<code>CellForRowAtIndex</code>中加载。</li>\n</ol>\n<blockquote>\n<p>Demo详见LazyLoad</p>\n</blockquote>\n<h3 id=\"分页的几种实现方法\"><a href=\"#分页的几种实现方法\" class=\"headerlink\" title=\"分页的几种实现方法\"></a>分页的几种实现方法</h3><p>分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。</p>\n<h4 id=\"pagingEnabled\"><a href=\"#pagingEnabled\" class=\"headerlink\" title=\"pagingEnabled\"></a>pagingEnabled</h4><p>系统提供的分页方式，实现简单，只需要<code>_scrollView.pagingEnabled = YES</code>即可，但是有局限性：</p>\n<ul>\n<li>只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。</li>\n<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>\n</ul>\n<p>Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>\n<ul>\n<li>让 scroll view 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 <code>NO</code>,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:</li>\n<li>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true\" alt=\"UIScrollView_pagingEnabled\"></p>\n<p>适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>\n<h4 id=\"Snap\"><a href=\"#Snap\" class=\"headerlink\" title=\"Snap\"></a>Snap</h4><p>核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。</p>\n<h4 id=\"修改targetContentOffset\"><a href=\"#修改targetContentOffset\" class=\"headerlink\" title=\"修改targetContentOffset\"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 <code>offset</code> 为整数页位置。其中核心代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)nearestTargetOffsetForOffset:(<span class=\"built_in\">CGPoint</span>)offset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    <span class=\"built_in\">NSInteger</span> page = roundf(offset.x / pageSize);    <span class=\"built_in\">CGFloat</span> targetX = pageSize * page;    <span class=\"keyword\">return</span> <span class=\"built_in\">CGPointMake</span>(targetX, offset.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGPoint</span> targetOffset = [<span class=\"keyword\">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class=\"line\">    targetContentOffset-&gt;x = targetOffset.x;</div><div class=\"line\">    targetContentOffset-&gt;y = targetOffset.y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>\n<blockquote>\n<p>Demo详见Pagination</p>\n</blockquote>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>大部分的 iOS 开发应该都清楚 <code>UITableView</code> 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，<code>UIScrollView</code> 作为 <code>UITableView</code> 的父类，在很多场景中也很适合应用重用机制。</p>\n<p>可以参照 <code>UITableView</code> 的 cell 重用机制，总结重用机制如下：</p>\n<ul>\n<li>维护一个重用队列</li>\n<li>当元素离开可见范围时，<code>removeFromSuperview</code> 并加入重用队列（enqueue）</li>\n<li>当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除</li>\n<li>如果队列为空，新建元素</li>\n<li>将新建元素的view通过<code>addSubView</code>添加至 <code>contentView</code>上</li>\n<li>这些一般都在 <code>scrollViewDidScroll:</code> 方法中完成</li>\n</ul>\n<p>Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo</p>\n<hr>\n<p>这里要说明一下Demo中用到的<code>addChildViewController</code>。</p>\n<p>苹果在iOS 5 添加了一系列的方法，希望我们在使用<code>addSubView</code>时，同时调用<code>[self addChildViewController:child]</code>方法将sub view对应的viewController也加到当前ViewController的管理中。</p>\n<p>对于那些当前暂时不需要显示的subview，只通过<code>addChildViewController</code>把subViewController加进去；需要显示时再调用<code>transitionFromViewController</code>方法。将其添加进入底层的ViewController中。</p>\n<p>这样做的好处：</p>\n<ol>\n<li>对页面中的逻辑更加分明了。相应的View对应相应的ViewController。</li>\n<li>当某个子View没有显示时，将不会被Load，减少了内存的使用。</li>\n<li>当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。</li>\n<li>可以调用<code>transitionFromViewController</code>等系统方法，ios对于显示以及动画做了比较好的封装</li>\n<li>相当于对于 ViewController 实例的保存。实例都保存在<code>self.childViewControllers</code>中，需要使用的时候从中取出即可。</li>\n</ol>\n<p>当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。</p>\n<p>其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候<code>[self.contentView addSubview:vc.view];</code>,不需要显示的时候<code>[vc.view removeFromSuperview];</code>，就可以达到显示和相应事件的需求了。</p>\n<hr>\n<blockquote>\n<p>Demo详见Reuse</p>\n</blockquote>\n<h3 id=\"联动\"><a href=\"#联动\" class=\"headerlink\" title=\"联动\"></a>联动</h3><p>所谓联动，就是当 A 滚动的时候，在 <strong><code>scrollViewDidScroll:</code></strong> 里根据 A 的 <code>contentOffset</code> 动态计算 B 的 <code>contentOffset</code> 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。</p>\n<p>Demo中的核心代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scrollView == <span class=\"keyword\">self</span>.titleScrollView) &#123;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> contentX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / <span class=\"keyword\">self</span>.titleScrollView.frame.size.width * <span class=\"keyword\">self</span>.contentScrollView.frame.size.width;</div><div class=\"line\">        <span class=\"keyword\">self</span>.contentScrollView.contentOffset = <span class=\"built_in\">CGPointMake</span>(contentX, <span class=\"number\">0.0</span>);</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> transX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / (<span class=\"keyword\">self</span>.titleScrollView.contentSize.width - <span class=\"keyword\">self</span>.titleScrollView.frame.size.width) * (<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width);</div><div class=\"line\">        transX = MAX(<span class=\"number\">0.0</span>, transX);</div><div class=\"line\">        transX = MIN(<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width, transX);</div><div class=\"line\">        <span class=\"keyword\">self</span>.backgroundImage.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(-transX, <span class=\"number\">0.0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>titleScrollView</code>计算<code>contentX</code>和<code>transX</code>来分别控制<code>contentScrollView</code>以及<code>backgroundImage</code>这两个View的位置变化。</p>\n<blockquote>\n<p>Demo参见Parallax</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.</p>\n<blockquote>\n<p>上述所有Demo均在UIScrollViewDemo文件夹中</p>\n</blockquote>"},{"title":"UICollectionView 使用方法总结","date":"2016-08-05T06:07:12.000Z","_content":"\nUICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。\n\n<!--more-->\n\n## 视图\nUICollectionView上面显示内容的视图有三种**Cell**视图、**Supplementary View**和**Decoration View**。\n- Cell视图\nCollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。\n- Supplementary View\n它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。\n例如flow layout当中的headers和footers就是可选的Supplementary View。\n- Decoration View\n这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。\n\n## 注册与重用\n### 注册\n在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。\n- registerClass: forCellWithReuseIdentifier:\n- registerNib: forCellWithReuseIdentifier:\n- registerClass: forSupplementaryViewOfKind: withReuseIdentifier:\n- registerNib: forSupplementaryViewOfKind: withReuseIdentifier:\n\n前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。\n\n### 重用\n注册后，调用一下方法进行重用:\n- dequeueReusableCellWithReuseIdentifier:forIndexPath:\n- dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:\n\n## 数据源方法\n### 基本方法\n数据源方法与UITableView类似，主要有：\n- numberOfSectionsInCollectionView:\n- collectionView: numberOfItemsInSection:\n- collectionView: cellForItemAtIndexPath:\n- collectionView: viewForSupplementaryElementOfKind: atIndexPath:\n\n### 添加头部和尾部视图\ncollection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。\n```objc\n-(UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{\n    if ([kind isEqual:UICollectionElementKindSectionFooter] ) {\n        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];\n        mineTicketListReusableView.delegate = self;\n        return mineTicketListReusableView;\n    }else{\n    \treturn nil;\n    }\n}\n\n```\n\n## 部分代理方法\n###  移动cell\n```objc\n//返回YES允许其item移动\n- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n//移动item时回调\n- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath {\n}\n\n//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势\nUILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handlelongGesture:)];\n    [self.collectionView addGestureRecognizer:longGesture];\n    \n//再实现手势操作\n- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture {\n    //判断手势状态\n    switch (longGesture.state) {\n        case UIGestureRecognizerStateBegan:{\n            //判断手势落点位置是否在路径上\n            NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:[longGesture locationInView:self.collectionView]];\n            if (indexPath == nil) {\n                break;\n            }\n            //在路径上则开始移动该路径上的cell\n            [self.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];\n        }\n            break;\n        case UIGestureRecognizerStateChanged:\n            //移动过程当中随时更新cell位置\n            [self.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:self.collectionView]];\n            break;\n        case UIGestureRecognizerStateEnded:\n            //移动结束后关闭cell移动\n            [self.collectionView endInteractiveMovement];\n            break;\n        default:\n            [self.collectionView cancelInteractiveMovement];\n            break;\n    }\n}\n\n```\n\n### 点击cell高亮\n```objc\n// 允许选中时，高亮\n-(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n// 高亮完成后回调  \n// 放大缩小效果\n-(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f);\n    }];\n}\n\n// 由高亮转成非高亮完成时的回调  \n-(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(1.0f, 1.0f);\n    }];\n}\n```\n\n### 点击cell选中\n```objc\n// 设置是否允许选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 设置是否允许取消选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n  \n// 取消选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n```\n\n## FlowLayout代理方法\n### 设置每个item大小\n- @property (CGSize)itemSize\n- -collectionView:ayout:sizeForItemAtIndexPath:\n\n可以设置全局属性也可以对某个cell定制尺寸。\n\n\n### item间隔\n- @property (CGSize) minimumInteritemSpacing\n- @property (CGSize) minimumLineSpacing\n- -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:\n- -collectionView:layout:minimumLineSpacingForSectionAtIndex:\n\n同itemsize，可以设置全局属性也可以定制。\n\n### 缩进（padding）\n- @property UIEdgeInsets sectionInset;\n- -collectionView:layout:insetForSectionAtIndex:\n\n同上。\n\n### 设置headerview的layout\n- @property (CGSize) headerReferenceSize\n- @property (CGSize) footerReferenceSize\n- -collectionView:layout:referenceSizeForHeaderInSection:\n- -collectionView:layout:referenceSizeForFooterInSection:\n\n同上。\n\n## UICollectionViewLayout子类\n## 基本方法\nUICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。\n\n子类需要覆盖父类以下3个方法：\n- prepareLayout\n- layoutAttributesForElementsInRect:(CGRect)rect\n- collectionViewContentSize\n\n---\n应用场景示例：\n为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。\n因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。\n\n---\n\n### -(void)prepareLayout\n初始化参数\n\n### -(CGSize)collectionViewContentSize\n布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。\n\n### -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\n实现必须返回一个包含**UICollectionViewLayoutAttributes**对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。\n\n传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。\n\n## 其他设置\n### 对齐 \n- **-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：**\n当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。\n每次移动整数个view的长度，示例代码：\n```objc\n- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity {\n    CGFloat index = roundf((self.scrollDirection == UICollectionViewScrollDirectionVertical ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);\n    if (self.scrollDirection == UICollectionViewScrollDirectionVertical) {\n        proposedContentOffset.y = _itemHeight * index;\n    } else {\n        proposedContentOffset.x = _itemHeight * index;\n    }\n    return proposedContentOffset;\n}\n```\n\n### 对item缩放翻转\n在layoutAttributesForElementsInRect:(CGRect)rect方法中设置**transform3D**的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：\n- m11主要负责x轴缩放\n- m22主要负责y轴缩放\n- m33主要负责z轴缩放\n- 其余值综合控制旋转与翻折\n\n具体使用方法以后再写。\n\n### 是否刷新布局\n```objc\n-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds\n{\n    return !CGRectEqualToRect(newBounds, self.collectionView.bounds);\n}\n```\n划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。\n\n### 删除item\n```\n-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    [self.dataArr removeObjectAtIndex:indexPath.item];\n    //TODO:  这个方法 特别注意 删除item的方法\n    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];\n}\n```\n\n\n\n\n","source":"_posts/UICollectionView.md","raw":"title: UICollectionView 使用方法总结\ndate: 2016/8/5 14:07:12  \ncategories: iOS\ntags: \n\t- 基本控件\t\n\n---\n\nUICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。\n\n<!--more-->\n\n## 视图\nUICollectionView上面显示内容的视图有三种**Cell**视图、**Supplementary View**和**Decoration View**。\n- Cell视图\nCollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。\n- Supplementary View\n它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。\n例如flow layout当中的headers和footers就是可选的Supplementary View。\n- Decoration View\n这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。\n\n## 注册与重用\n### 注册\n在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。\n- registerClass: forCellWithReuseIdentifier:\n- registerNib: forCellWithReuseIdentifier:\n- registerClass: forSupplementaryViewOfKind: withReuseIdentifier:\n- registerNib: forSupplementaryViewOfKind: withReuseIdentifier:\n\n前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。\n\n### 重用\n注册后，调用一下方法进行重用:\n- dequeueReusableCellWithReuseIdentifier:forIndexPath:\n- dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:\n\n## 数据源方法\n### 基本方法\n数据源方法与UITableView类似，主要有：\n- numberOfSectionsInCollectionView:\n- collectionView: numberOfItemsInSection:\n- collectionView: cellForItemAtIndexPath:\n- collectionView: viewForSupplementaryElementOfKind: atIndexPath:\n\n### 添加头部和尾部视图\ncollection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。\n```objc\n-(UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{\n    if ([kind isEqual:UICollectionElementKindSectionFooter] ) {\n        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];\n        mineTicketListReusableView.delegate = self;\n        return mineTicketListReusableView;\n    }else{\n    \treturn nil;\n    }\n}\n\n```\n\n## 部分代理方法\n###  移动cell\n```objc\n//返回YES允许其item移动\n- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n//移动item时回调\n- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath {\n}\n\n//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势\nUILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handlelongGesture:)];\n    [self.collectionView addGestureRecognizer:longGesture];\n    \n//再实现手势操作\n- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture {\n    //判断手势状态\n    switch (longGesture.state) {\n        case UIGestureRecognizerStateBegan:{\n            //判断手势落点位置是否在路径上\n            NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:[longGesture locationInView:self.collectionView]];\n            if (indexPath == nil) {\n                break;\n            }\n            //在路径上则开始移动该路径上的cell\n            [self.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];\n        }\n            break;\n        case UIGestureRecognizerStateChanged:\n            //移动过程当中随时更新cell位置\n            [self.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:self.collectionView]];\n            break;\n        case UIGestureRecognizerStateEnded:\n            //移动结束后关闭cell移动\n            [self.collectionView endInteractiveMovement];\n            break;\n        default:\n            [self.collectionView cancelInteractiveMovement];\n            break;\n    }\n}\n\n```\n\n### 点击cell高亮\n```objc\n// 允许选中时，高亮\n-(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n// 高亮完成后回调  \n// 放大缩小效果\n-(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f);\n    }];\n}\n\n// 由高亮转成非高亮完成时的回调  \n-(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(1.0f, 1.0f);\n    }];\n}\n```\n\n### 点击cell选中\n```objc\n// 设置是否允许选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 设置是否允许取消选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n  \n// 取消选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n```\n\n## FlowLayout代理方法\n### 设置每个item大小\n- @property (CGSize)itemSize\n- -collectionView:ayout:sizeForItemAtIndexPath:\n\n可以设置全局属性也可以对某个cell定制尺寸。\n\n\n### item间隔\n- @property (CGSize) minimumInteritemSpacing\n- @property (CGSize) minimumLineSpacing\n- -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:\n- -collectionView:layout:minimumLineSpacingForSectionAtIndex:\n\n同itemsize，可以设置全局属性也可以定制。\n\n### 缩进（padding）\n- @property UIEdgeInsets sectionInset;\n- -collectionView:layout:insetForSectionAtIndex:\n\n同上。\n\n### 设置headerview的layout\n- @property (CGSize) headerReferenceSize\n- @property (CGSize) footerReferenceSize\n- -collectionView:layout:referenceSizeForHeaderInSection:\n- -collectionView:layout:referenceSizeForFooterInSection:\n\n同上。\n\n## UICollectionViewLayout子类\n## 基本方法\nUICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。\n\n子类需要覆盖父类以下3个方法：\n- prepareLayout\n- layoutAttributesForElementsInRect:(CGRect)rect\n- collectionViewContentSize\n\n---\n应用场景示例：\n为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。\n因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。\n\n---\n\n### -(void)prepareLayout\n初始化参数\n\n### -(CGSize)collectionViewContentSize\n布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。\n\n### -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\n实现必须返回一个包含**UICollectionViewLayoutAttributes**对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。\n\n传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。\n\n## 其他设置\n### 对齐 \n- **-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：**\n当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。\n每次移动整数个view的长度，示例代码：\n```objc\n- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity {\n    CGFloat index = roundf((self.scrollDirection == UICollectionViewScrollDirectionVertical ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);\n    if (self.scrollDirection == UICollectionViewScrollDirectionVertical) {\n        proposedContentOffset.y = _itemHeight * index;\n    } else {\n        proposedContentOffset.x = _itemHeight * index;\n    }\n    return proposedContentOffset;\n}\n```\n\n### 对item缩放翻转\n在layoutAttributesForElementsInRect:(CGRect)rect方法中设置**transform3D**的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：\n- m11主要负责x轴缩放\n- m22主要负责y轴缩放\n- m33主要负责z轴缩放\n- 其余值综合控制旋转与翻折\n\n具体使用方法以后再写。\n\n### 是否刷新布局\n```objc\n-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds\n{\n    return !CGRectEqualToRect(newBounds, self.collectionView.bounds);\n}\n```\n划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。\n\n### 删除item\n```\n-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    [self.dataArr removeObjectAtIndex:indexPath.item];\n    //TODO:  这个方法 特别注意 删除item的方法\n    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];\n}\n```\n\n\n\n\n","slug":"UICollectionView","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dps001e7hzgl9u38j5s","content":"<p>UICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。</p>\n<a id=\"more\"></a>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>UICollectionView上面显示内容的视图有三种<strong>Cell</strong>视图、<strong>Supplementary View</strong>和<strong>Decoration View</strong>。</p>\n<ul>\n<li>Cell视图<br>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</li>\n<li>Supplementary View<br>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。<br>例如flow layout当中的headers和footers就是可选的Supplementary View。</li>\n<li>Decoration View<br>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</li>\n</ul>\n<h2 id=\"注册与重用\"><a href=\"#注册与重用\" class=\"headerlink\" title=\"注册与重用\"></a>注册与重用</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。</p>\n<ul>\n<li>registerClass: forCellWithReuseIdentifier:</li>\n<li>registerNib: forCellWithReuseIdentifier:</li>\n<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n</ul>\n<p>前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。</p>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>注册后，调用一下方法进行重用:</p>\n<ul>\n<li>dequeueReusableCellWithReuseIdentifier:forIndexPath:</li>\n<li>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</li>\n</ul>\n<h2 id=\"数据源方法\"><a href=\"#数据源方法\" class=\"headerlink\" title=\"数据源方法\"></a>数据源方法</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><p>数据源方法与UITableView类似，主要有：</p>\n<ul>\n<li>numberOfSectionsInCollectionView:</li>\n<li>collectionView: numberOfItemsInSection:</li>\n<li>collectionView: cellForItemAtIndexPath:</li>\n<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>\n</ul>\n<h3 id=\"添加头部和尾部视图\"><a href=\"#添加头部和尾部视图\" class=\"headerlink\" title=\"添加头部和尾部视图\"></a>添加头部和尾部视图</h3><p>collection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UICollectionReusableView</span> *)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class=\"built_in\">NSString</span> *)kind atIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([kind isEqual:<span class=\"built_in\">UICollectionElementKindSectionFooter</span>] ) &#123;</div><div class=\"line\">        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:<span class=\"built_in\">UICollectionElementKindSectionFooter</span> withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];</div><div class=\"line\">        mineTicketListReusableView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> mineTicketListReusableView;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"部分代理方法\"><a href=\"#部分代理方法\" class=\"headerlink\" title=\"部分代理方法\"></a>部分代理方法</h2><h3 id=\"移动cell\"><a href=\"#移动cell\" class=\"headerlink\" title=\"移动cell\"></a>移动cell</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回YES允许其item移动</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移动item时回调</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span>*)destinationIndexPath &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势</span></div><div class=\"line\"><span class=\"built_in\">UILongPressGestureRecognizer</span> *longGesture = [[<span class=\"built_in\">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(handlelongGesture:)];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView addGestureRecognizer:longGesture];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//再实现手势操作</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)handlelongGesture:(<span class=\"built_in\">UILongPressGestureRecognizer</span> *)longGesture &#123;</div><div class=\"line\">    <span class=\"comment\">//判断手势状态</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (longGesture.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateBegan</span>:&#123;</div><div class=\"line\">            <span class=\"comment\">//判断手势落点位置是否在路径上</span></div><div class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"keyword\">self</span>.collectionView indexPathForItemAtPoint:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">if</span> (indexPath == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//在路径上则开始移动该路径上的cell</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateChanged</span>:</div><div class=\"line\">            <span class=\"comment\">//移动过程当中随时更新cell位置</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateEnded</span>:</div><div class=\"line\">            <span class=\"comment\">//移动结束后关闭cell移动</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView endInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView cancelInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell高亮\"><a href=\"#点击cell高亮\" class=\"headerlink\" title=\"点击cell高亮\"></a>点击cell高亮</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 允许选中时，高亮</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 高亮完成后回调  </span></div><div class=\"line\"><span class=\"comment\">// 放大缩小效果</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">2.0</span>f, <span class=\"number\">2.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 由高亮转成非高亮完成时的回调  </span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell选中\"><a href=\"#点击cell选中\" class=\"headerlink\" title=\"点击cell选中\"></a>点击cell选中</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置是否允许选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 设置是否允许取消选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 取消选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"FlowLayout代理方法\"><a href=\"#FlowLayout代理方法\" class=\"headerlink\" title=\"FlowLayout代理方法\"></a>FlowLayout代理方法</h2><h3 id=\"设置每个item大小\"><a href=\"#设置每个item大小\" class=\"headerlink\" title=\"设置每个item大小\"></a>设置每个item大小</h3><ul>\n<li>@property (CGSize)itemSize</li>\n<li>-collectionView:ayout:sizeForItemAtIndexPath:</li>\n</ul>\n<p>可以设置全局属性也可以对某个cell定制尺寸。</p>\n<h3 id=\"item间隔\"><a href=\"#item间隔\" class=\"headerlink\" title=\"item间隔\"></a>item间隔</h3><ul>\n<li>@property (CGSize) minimumInteritemSpacing</li>\n<li>@property (CGSize) minimumLineSpacing</li>\n<li>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:</li>\n<li>-collectionView:layout:minimumLineSpacingForSectionAtIndex:</li>\n</ul>\n<p>同itemsize，可以设置全局属性也可以定制。</p>\n<h3 id=\"缩进（padding）\"><a href=\"#缩进（padding）\" class=\"headerlink\" title=\"缩进（padding）\"></a>缩进（padding）</h3><ul>\n<li>@property UIEdgeInsets sectionInset;</li>\n<li>-collectionView:layout:insetForSectionAtIndex:</li>\n</ul>\n<p>同上。</p>\n<h3 id=\"设置headerview的layout\"><a href=\"#设置headerview的layout\" class=\"headerlink\" title=\"设置headerview的layout\"></a>设置headerview的layout</h3><ul>\n<li>@property (CGSize) headerReferenceSize</li>\n<li>@property (CGSize) footerReferenceSize</li>\n<li>-collectionView:layout:referenceSizeForHeaderInSection:</li>\n<li>-collectionView:layout:referenceSizeForFooterInSection:</li>\n</ul>\n<p>同上。</p>\n<h2 id=\"UICollectionViewLayout子类\"><a href=\"#UICollectionViewLayout子类\" class=\"headerlink\" title=\"UICollectionViewLayout子类\"></a>UICollectionViewLayout子类</h2><h2 id=\"基本方法-1\"><a href=\"#基本方法-1\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><p>UICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。</p>\n<p>子类需要覆盖父类以下3个方法：</p>\n<ul>\n<li>prepareLayout</li>\n<li>layoutAttributesForElementsInRect:(CGRect)rect</li>\n<li>collectionViewContentSize</li>\n</ul>\n<hr>\n<p>应用场景示例：<br>为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。<br>因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。</p>\n<hr>\n<h3 id=\"void-prepareLayout\"><a href=\"#void-prepareLayout\" class=\"headerlink\" title=\"-(void)prepareLayout\"></a>-(void)prepareLayout</h3><p>初始化参数</p>\n<h3 id=\"CGSize-collectionViewContentSize\"><a href=\"#CGSize-collectionViewContentSize\" class=\"headerlink\" title=\"-(CGSize)collectionViewContentSize\"></a>-(CGSize)collectionViewContentSize</h3><p>布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。</p>\n<h3 id=\"NSArray-layoutAttributesForElementsInRect-CGRect-rect\"><a href=\"#NSArray-layoutAttributesForElementsInRect-CGRect-rect\" class=\"headerlink\" title=\"-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\"></a>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</h3><p>实现必须返回一个包含<strong>UICollectionViewLayoutAttributes</strong>对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。</p>\n<p>传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。</p>\n<h2 id=\"其他设置\"><a href=\"#其他设置\" class=\"headerlink\" title=\"其他设置\"></a>其他设置</h2><h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><ul>\n<li><strong>-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：</strong><br>当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。<br>每次移动整数个view的长度，示例代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class=\"built_in\">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class=\"built_in\">CGPoint</span>)velocity &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> index = roundf((<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span> ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span>) &#123;</div><div class=\"line\">        proposedContentOffset.y = _itemHeight * index;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        proposedContentOffset.x = _itemHeight * index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> proposedContentOffset;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"对item缩放翻转\"><a href=\"#对item缩放翻转\" class=\"headerlink\" title=\"对item缩放翻转\"></a>对item缩放翻转</h3><p>在layoutAttributesForElementsInRect:(CGRect)rect方法中设置<strong>transform3D</strong>的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：</p>\n<ul>\n<li>m11主要负责x轴缩放</li>\n<li>m22主要负责y轴缩放</li>\n<li>m33主要负责z轴缩放</li>\n<li>其余值综合控制旋转与翻折</li>\n</ul>\n<p>具体使用方法以后再写。</p>\n<h3 id=\"是否刷新布局\"><a href=\"#是否刷新布局\" class=\"headerlink\" title=\"是否刷新布局\"></a>是否刷新布局</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class=\"built_in\">CGRect</span>)newBounds</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">CGRectEqualToRect</span>(newBounds, <span class=\"keyword\">self</span>.collectionView.bounds);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。</p>\n<h3 id=\"删除item\"><a href=\"#删除item\" class=\"headerlink\" title=\"删除item\"></a>删除item</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dataArr removeObjectAtIndex:indexPath.item];</div><div class=\"line\">    //TODO:  这个方法 特别注意 删除item的方法</div><div class=\"line\">    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>UICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。</p>","more":"<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>UICollectionView上面显示内容的视图有三种<strong>Cell</strong>视图、<strong>Supplementary View</strong>和<strong>Decoration View</strong>。</p>\n<ul>\n<li>Cell视图<br>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</li>\n<li>Supplementary View<br>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。<br>例如flow layout当中的headers和footers就是可选的Supplementary View。</li>\n<li>Decoration View<br>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</li>\n</ul>\n<h2 id=\"注册与重用\"><a href=\"#注册与重用\" class=\"headerlink\" title=\"注册与重用\"></a>注册与重用</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。</p>\n<ul>\n<li>registerClass: forCellWithReuseIdentifier:</li>\n<li>registerNib: forCellWithReuseIdentifier:</li>\n<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n</ul>\n<p>前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。</p>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>注册后，调用一下方法进行重用:</p>\n<ul>\n<li>dequeueReusableCellWithReuseIdentifier:forIndexPath:</li>\n<li>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</li>\n</ul>\n<h2 id=\"数据源方法\"><a href=\"#数据源方法\" class=\"headerlink\" title=\"数据源方法\"></a>数据源方法</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><p>数据源方法与UITableView类似，主要有：</p>\n<ul>\n<li>numberOfSectionsInCollectionView:</li>\n<li>collectionView: numberOfItemsInSection:</li>\n<li>collectionView: cellForItemAtIndexPath:</li>\n<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>\n</ul>\n<h3 id=\"添加头部和尾部视图\"><a href=\"#添加头部和尾部视图\" class=\"headerlink\" title=\"添加头部和尾部视图\"></a>添加头部和尾部视图</h3><p>collection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UICollectionReusableView</span> *)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class=\"built_in\">NSString</span> *)kind atIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([kind isEqual:<span class=\"built_in\">UICollectionElementKindSectionFooter</span>] ) &#123;</div><div class=\"line\">        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:<span class=\"built_in\">UICollectionElementKindSectionFooter</span> withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];</div><div class=\"line\">        mineTicketListReusableView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> mineTicketListReusableView;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"部分代理方法\"><a href=\"#部分代理方法\" class=\"headerlink\" title=\"部分代理方法\"></a>部分代理方法</h2><h3 id=\"移动cell\"><a href=\"#移动cell\" class=\"headerlink\" title=\"移动cell\"></a>移动cell</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回YES允许其item移动</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移动item时回调</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span>*)destinationIndexPath &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势</span></div><div class=\"line\"><span class=\"built_in\">UILongPressGestureRecognizer</span> *longGesture = [[<span class=\"built_in\">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(handlelongGesture:)];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView addGestureRecognizer:longGesture];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//再实现手势操作</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)handlelongGesture:(<span class=\"built_in\">UILongPressGestureRecognizer</span> *)longGesture &#123;</div><div class=\"line\">    <span class=\"comment\">//判断手势状态</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (longGesture.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateBegan</span>:&#123;</div><div class=\"line\">            <span class=\"comment\">//判断手势落点位置是否在路径上</span></div><div class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"keyword\">self</span>.collectionView indexPathForItemAtPoint:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">if</span> (indexPath == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//在路径上则开始移动该路径上的cell</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateChanged</span>:</div><div class=\"line\">            <span class=\"comment\">//移动过程当中随时更新cell位置</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateEnded</span>:</div><div class=\"line\">            <span class=\"comment\">//移动结束后关闭cell移动</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView endInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView cancelInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell高亮\"><a href=\"#点击cell高亮\" class=\"headerlink\" title=\"点击cell高亮\"></a>点击cell高亮</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 允许选中时，高亮</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 高亮完成后回调  </span></div><div class=\"line\"><span class=\"comment\">// 放大缩小效果</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">2.0</span>f, <span class=\"number\">2.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 由高亮转成非高亮完成时的回调  </span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell选中\"><a href=\"#点击cell选中\" class=\"headerlink\" title=\"点击cell选中\"></a>点击cell选中</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置是否允许选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 设置是否允许取消选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 取消选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"FlowLayout代理方法\"><a href=\"#FlowLayout代理方法\" class=\"headerlink\" title=\"FlowLayout代理方法\"></a>FlowLayout代理方法</h2><h3 id=\"设置每个item大小\"><a href=\"#设置每个item大小\" class=\"headerlink\" title=\"设置每个item大小\"></a>设置每个item大小</h3><ul>\n<li>@property (CGSize)itemSize</li>\n<li>-collectionView:ayout:sizeForItemAtIndexPath:</li>\n</ul>\n<p>可以设置全局属性也可以对某个cell定制尺寸。</p>\n<h3 id=\"item间隔\"><a href=\"#item间隔\" class=\"headerlink\" title=\"item间隔\"></a>item间隔</h3><ul>\n<li>@property (CGSize) minimumInteritemSpacing</li>\n<li>@property (CGSize) minimumLineSpacing</li>\n<li>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:</li>\n<li>-collectionView:layout:minimumLineSpacingForSectionAtIndex:</li>\n</ul>\n<p>同itemsize，可以设置全局属性也可以定制。</p>\n<h3 id=\"缩进（padding）\"><a href=\"#缩进（padding）\" class=\"headerlink\" title=\"缩进（padding）\"></a>缩进（padding）</h3><ul>\n<li>@property UIEdgeInsets sectionInset;</li>\n<li>-collectionView:layout:insetForSectionAtIndex:</li>\n</ul>\n<p>同上。</p>\n<h3 id=\"设置headerview的layout\"><a href=\"#设置headerview的layout\" class=\"headerlink\" title=\"设置headerview的layout\"></a>设置headerview的layout</h3><ul>\n<li>@property (CGSize) headerReferenceSize</li>\n<li>@property (CGSize) footerReferenceSize</li>\n<li>-collectionView:layout:referenceSizeForHeaderInSection:</li>\n<li>-collectionView:layout:referenceSizeForFooterInSection:</li>\n</ul>\n<p>同上。</p>\n<h2 id=\"UICollectionViewLayout子类\"><a href=\"#UICollectionViewLayout子类\" class=\"headerlink\" title=\"UICollectionViewLayout子类\"></a>UICollectionViewLayout子类</h2><h2 id=\"基本方法-1\"><a href=\"#基本方法-1\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><p>UICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。</p>\n<p>子类需要覆盖父类以下3个方法：</p>\n<ul>\n<li>prepareLayout</li>\n<li>layoutAttributesForElementsInRect:(CGRect)rect</li>\n<li>collectionViewContentSize</li>\n</ul>\n<hr>\n<p>应用场景示例：<br>为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。<br>因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。</p>\n<hr>\n<h3 id=\"void-prepareLayout\"><a href=\"#void-prepareLayout\" class=\"headerlink\" title=\"-(void)prepareLayout\"></a>-(void)prepareLayout</h3><p>初始化参数</p>\n<h3 id=\"CGSize-collectionViewContentSize\"><a href=\"#CGSize-collectionViewContentSize\" class=\"headerlink\" title=\"-(CGSize)collectionViewContentSize\"></a>-(CGSize)collectionViewContentSize</h3><p>布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。</p>\n<h3 id=\"NSArray-layoutAttributesForElementsInRect-CGRect-rect\"><a href=\"#NSArray-layoutAttributesForElementsInRect-CGRect-rect\" class=\"headerlink\" title=\"-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\"></a>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</h3><p>实现必须返回一个包含<strong>UICollectionViewLayoutAttributes</strong>对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。</p>\n<p>传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。</p>\n<h2 id=\"其他设置\"><a href=\"#其他设置\" class=\"headerlink\" title=\"其他设置\"></a>其他设置</h2><h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><ul>\n<li><strong>-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：</strong><br>当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。<br>每次移动整数个view的长度，示例代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class=\"built_in\">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class=\"built_in\">CGPoint</span>)velocity &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> index = roundf((<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span> ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span>) &#123;</div><div class=\"line\">        proposedContentOffset.y = _itemHeight * index;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        proposedContentOffset.x = _itemHeight * index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> proposedContentOffset;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"对item缩放翻转\"><a href=\"#对item缩放翻转\" class=\"headerlink\" title=\"对item缩放翻转\"></a>对item缩放翻转</h3><p>在layoutAttributesForElementsInRect:(CGRect)rect方法中设置<strong>transform3D</strong>的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：</p>\n<ul>\n<li>m11主要负责x轴缩放</li>\n<li>m22主要负责y轴缩放</li>\n<li>m33主要负责z轴缩放</li>\n<li>其余值综合控制旋转与翻折</li>\n</ul>\n<p>具体使用方法以后再写。</p>\n<h3 id=\"是否刷新布局\"><a href=\"#是否刷新布局\" class=\"headerlink\" title=\"是否刷新布局\"></a>是否刷新布局</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class=\"built_in\">CGRect</span>)newBounds</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">CGRectEqualToRect</span>(newBounds, <span class=\"keyword\">self</span>.collectionView.bounds);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。</p>\n<h3 id=\"删除item\"><a href=\"#删除item\" class=\"headerlink\" title=\"删除item\"></a>删除item</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dataArr removeObjectAtIndex:indexPath.item];</div><div class=\"line\">    //TODO:  这个方法 特别注意 删除item的方法</div><div class=\"line\">    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UILabel高度控制","date":"2016-09-12T06:07:12.000Z","_content":"\n在[tableview自适应高度](https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/)一篇中学习了如何用`systemLayoutSizeFittingSize:`方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。\n\n<!--more-->\n\n## sizeThatFits的使用\n`sizeThatFits`是UIView中的方法：\n```objc\n- (CGSize)sizeThatFits:(CGSize)size;\n```\n\n官方文档的注释：\n>return 'best' size to fit given size. does not actually resize view. Default is return existing view size\n也就是说，该方法将会根据传入的`size`,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。\n\nUILabel会根据传入的`size`的`width`自动换行，得到`height`后，将这两个值作为估算出的`CGSize`返回。\n如果传入的是`CGSizeZero`相当于不设置换行宽度，一行到底。\n\n由于`SizeThatFits`只估算，不修改。在得到估算值后，需要手动设置UILabel的`frame`或者`constraint`：\n```objc\n- (void) useSizeThatFitsZeroWithLabel:(UILabel *)label{\n    //使用CGSizeZero相当于不设置换行宽度，一行到底\n    CGSize size = [label sizeThatFits:CGSizeZero];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n\n- (void) useSizeThatFitsCustomWithLabel:(UILabel *)label{\n    //使用自定义的CGSize，会根据size的宽度进行换行\n    CGSize size = [label sizeThatFits:CGSizeMake(50, 50)];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n```\n\n## SizeToFit\n`SizeToFit`的方法：\n```objc\n- (void)sizeToFit;  \n```\n\n`SizeToFit`的文档注释：\n> calls sizeThatFits: with current view bounds and changes bounds size.\n也就是说，它会调用`SizeThatFits`,并且直接设置View的`bounds`。\n\n既然要调用`sizeThatFits`那就需要传入一个`CGSize`。这个`CGSize`就是设置View的`frame`时传入的`height`,`width`。\n\n\n\n\n\n## frame与constraint\n在代码添加View时，init都会使用`initWithFrame:`方法。在AutoLayout后，`constraint`被使用，是为了适配不同屏幕的机器。\n\n- 设置好View之间的`constraint`后，一个View的约束改变，将会联动改变其他View的位置、大小。\n- 设置好View的`frame`或者`bound`后，改变View的`frame`，不会对其它View造成任何影响。\n- 在设置好`constraint`后，显示的View就以约束为准。修改`frame`，View的显示没有任何改变，虽然`frame`确实变了。\n\n```objc\nNSLog(@\"改变前%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n_label.frame = CGRectMake(0, 0, 200, 200);\nNSLog(@\"改变后%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n\n2016-09-12 15:32:44.458 Parallax[2126:578089] 66.000000,147.000000,180.000000,117.000000\n2016-09-12 15:32:44.459 Parallax[2126:578089] 改变后200.000000,200.000000,0.000000,0.000000\n```\n\n\n## 与systemLayoutSizeFittingSize的比较\n`systemLayoutSizeFittingSize`方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了`sizeThatFits`吧)，得到最适合的supview的高度。\n\n`sizetofit`和`sizethatfits`则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。\n\n> Demo 详见 UIScrollViewDemo/Parallax","source":"_posts/UILabel的高度计算.md","raw":"title: UILabel高度控制\ndate: 2016/9/12 14:07:12  \ncategories: iOS \ntags: \n\t- UI\n\t\n\n---\n\n在[tableview自适应高度](https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/)一篇中学习了如何用`systemLayoutSizeFittingSize:`方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。\n\n<!--more-->\n\n## sizeThatFits的使用\n`sizeThatFits`是UIView中的方法：\n```objc\n- (CGSize)sizeThatFits:(CGSize)size;\n```\n\n官方文档的注释：\n>return 'best' size to fit given size. does not actually resize view. Default is return existing view size\n也就是说，该方法将会根据传入的`size`,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。\n\nUILabel会根据传入的`size`的`width`自动换行，得到`height`后，将这两个值作为估算出的`CGSize`返回。\n如果传入的是`CGSizeZero`相当于不设置换行宽度，一行到底。\n\n由于`SizeThatFits`只估算，不修改。在得到估算值后，需要手动设置UILabel的`frame`或者`constraint`：\n```objc\n- (void) useSizeThatFitsZeroWithLabel:(UILabel *)label{\n    //使用CGSizeZero相当于不设置换行宽度，一行到底\n    CGSize size = [label sizeThatFits:CGSizeZero];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n\n- (void) useSizeThatFitsCustomWithLabel:(UILabel *)label{\n    //使用自定义的CGSize，会根据size的宽度进行换行\n    CGSize size = [label sizeThatFits:CGSizeMake(50, 50)];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n```\n\n## SizeToFit\n`SizeToFit`的方法：\n```objc\n- (void)sizeToFit;  \n```\n\n`SizeToFit`的文档注释：\n> calls sizeThatFits: with current view bounds and changes bounds size.\n也就是说，它会调用`SizeThatFits`,并且直接设置View的`bounds`。\n\n既然要调用`sizeThatFits`那就需要传入一个`CGSize`。这个`CGSize`就是设置View的`frame`时传入的`height`,`width`。\n\n\n\n\n\n## frame与constraint\n在代码添加View时，init都会使用`initWithFrame:`方法。在AutoLayout后，`constraint`被使用，是为了适配不同屏幕的机器。\n\n- 设置好View之间的`constraint`后，一个View的约束改变，将会联动改变其他View的位置、大小。\n- 设置好View的`frame`或者`bound`后，改变View的`frame`，不会对其它View造成任何影响。\n- 在设置好`constraint`后，显示的View就以约束为准。修改`frame`，View的显示没有任何改变，虽然`frame`确实变了。\n\n```objc\nNSLog(@\"改变前%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n_label.frame = CGRectMake(0, 0, 200, 200);\nNSLog(@\"改变后%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n\n2016-09-12 15:32:44.458 Parallax[2126:578089] 66.000000,147.000000,180.000000,117.000000\n2016-09-12 15:32:44.459 Parallax[2126:578089] 改变后200.000000,200.000000,0.000000,0.000000\n```\n\n\n## 与systemLayoutSizeFittingSize的比较\n`systemLayoutSizeFittingSize`方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了`sizeThatFits`吧)，得到最适合的supview的高度。\n\n`sizetofit`和`sizethatfits`则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。\n\n> Demo 详见 UIScrollViewDemo/Parallax","slug":"UILabel的高度计算","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpv001i7hzgme8lard2","content":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/\">tableview自适应高度</a>一篇中学习了如何用<code>systemLayoutSizeFittingSize:</code>方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。</p>\n<a id=\"more\"></a>\n<h2 id=\"sizeThatFits的使用\"><a href=\"#sizeThatFits的使用\" class=\"headerlink\" title=\"sizeThatFits的使用\"></a>sizeThatFits的使用</h2><p><code>sizeThatFits</code>是UIView中的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeThatFits:(<span class=\"built_in\">CGSize</span>)size;</div></pre></td></tr></table></figure></p>\n<p>官方文档的注释：</p>\n<blockquote>\n<p>return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size<br>也就是说，该方法将会根据传入的<code>size</code>,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。</p>\n</blockquote>\n<p>UILabel会根据传入的<code>size</code>的<code>width</code>自动换行，得到<code>height</code>后，将这两个值作为估算出的<code>CGSize</code>返回。<br>如果传入的是<code>CGSizeZero</code>相当于不设置换行宽度，一行到底。</p>\n<p>由于<code>SizeThatFits</code>只估算，不修改。在得到估算值后，需要手动设置UILabel的<code>frame</code>或者<code>constraint</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsZeroWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用CGSizeZero相当于不设置换行宽度，一行到底</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeZero</span>];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsCustomWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用自定义的CGSize，会根据size的宽度进行换行</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>)];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"SizeToFit\"><a href=\"#SizeToFit\" class=\"headerlink\" title=\"SizeToFit\"></a>SizeToFit</h2><p><code>SizeToFit</code>的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sizeToFit;</div></pre></td></tr></table></figure></p>\n<p><code>SizeToFit</code>的文档注释：</p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size.<br>也就是说，它会调用<code>SizeThatFits</code>,并且直接设置View的<code>bounds</code>。</p>\n</blockquote>\n<p>既然要调用<code>sizeThatFits</code>那就需要传入一个<code>CGSize</code>。这个<code>CGSize</code>就是设置View的<code>frame</code>时传入的<code>height</code>,<code>width</code>。</p>\n<h2 id=\"frame与constraint\"><a href=\"#frame与constraint\" class=\"headerlink\" title=\"frame与constraint\"></a>frame与constraint</h2><p>在代码添加View时，init都会使用<code>initWithFrame:</code>方法。在AutoLayout后，<code>constraint</code>被使用，是为了适配不同屏幕的机器。</p>\n<ul>\n<li>设置好View之间的<code>constraint</code>后，一个View的约束改变，将会联动改变其他View的位置、大小。</li>\n<li>设置好View的<code>frame</code>或者<code>bound</code>后，改变View的<code>frame</code>，不会对其它View造成任何影响。</li>\n<li>在设置好<code>constraint</code>后，显示的View就以约束为准。修改<code>frame</code>，View的显示没有任何改变，虽然<code>frame</code>确实变了。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变前%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\">_label.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变后%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.458</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] <span class=\"number\">66.000000</span>,<span class=\"number\">147.000000</span>,<span class=\"number\">180.000000</span>,<span class=\"number\">117.000000</span></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.459</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] 改变后<span class=\"number\">200.000000</span>,<span class=\"number\">200.000000</span>,<span class=\"number\">0.000000</span>,<span class=\"number\">0.000000</span></div></pre></td></tr></table></figure>\n<h2 id=\"与systemLayoutSizeFittingSize的比较\"><a href=\"#与systemLayoutSizeFittingSize的比较\" class=\"headerlink\" title=\"与systemLayoutSizeFittingSize的比较\"></a>与systemLayoutSizeFittingSize的比较</h2><p><code>systemLayoutSizeFittingSize</code>方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了<code>sizeThatFits</code>吧)，得到最适合的supview的高度。</p>\n<p><code>sizetofit</code>和<code>sizethatfits</code>则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。</p>\n<blockquote>\n<p>Demo 详见 UIScrollViewDemo/Parallax</p>\n</blockquote>\n","excerpt":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/\">tableview自适应高度</a>一篇中学习了如何用<code>systemLayoutSizeFittingSize:</code>方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。</p>","more":"<h2 id=\"sizeThatFits的使用\"><a href=\"#sizeThatFits的使用\" class=\"headerlink\" title=\"sizeThatFits的使用\"></a>sizeThatFits的使用</h2><p><code>sizeThatFits</code>是UIView中的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeThatFits:(<span class=\"built_in\">CGSize</span>)size;</div></pre></td></tr></table></figure></p>\n<p>官方文档的注释：</p>\n<blockquote>\n<p>return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size<br>也就是说，该方法将会根据传入的<code>size</code>,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。</p>\n</blockquote>\n<p>UILabel会根据传入的<code>size</code>的<code>width</code>自动换行，得到<code>height</code>后，将这两个值作为估算出的<code>CGSize</code>返回。<br>如果传入的是<code>CGSizeZero</code>相当于不设置换行宽度，一行到底。</p>\n<p>由于<code>SizeThatFits</code>只估算，不修改。在得到估算值后，需要手动设置UILabel的<code>frame</code>或者<code>constraint</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsZeroWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用CGSizeZero相当于不设置换行宽度，一行到底</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeZero</span>];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsCustomWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用自定义的CGSize，会根据size的宽度进行换行</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>)];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"SizeToFit\"><a href=\"#SizeToFit\" class=\"headerlink\" title=\"SizeToFit\"></a>SizeToFit</h2><p><code>SizeToFit</code>的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sizeToFit;</div></pre></td></tr></table></figure></p>\n<p><code>SizeToFit</code>的文档注释：</p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size.<br>也就是说，它会调用<code>SizeThatFits</code>,并且直接设置View的<code>bounds</code>。</p>\n</blockquote>\n<p>既然要调用<code>sizeThatFits</code>那就需要传入一个<code>CGSize</code>。这个<code>CGSize</code>就是设置View的<code>frame</code>时传入的<code>height</code>,<code>width</code>。</p>\n<h2 id=\"frame与constraint\"><a href=\"#frame与constraint\" class=\"headerlink\" title=\"frame与constraint\"></a>frame与constraint</h2><p>在代码添加View时，init都会使用<code>initWithFrame:</code>方法。在AutoLayout后，<code>constraint</code>被使用，是为了适配不同屏幕的机器。</p>\n<ul>\n<li>设置好View之间的<code>constraint</code>后，一个View的约束改变，将会联动改变其他View的位置、大小。</li>\n<li>设置好View的<code>frame</code>或者<code>bound</code>后，改变View的<code>frame</code>，不会对其它View造成任何影响。</li>\n<li>在设置好<code>constraint</code>后，显示的View就以约束为准。修改<code>frame</code>，View的显示没有任何改变，虽然<code>frame</code>确实变了。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变前%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\">_label.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变后%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.458</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] <span class=\"number\">66.000000</span>,<span class=\"number\">147.000000</span>,<span class=\"number\">180.000000</span>,<span class=\"number\">117.000000</span></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.459</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] 改变后<span class=\"number\">200.000000</span>,<span class=\"number\">200.000000</span>,<span class=\"number\">0.000000</span>,<span class=\"number\">0.000000</span></div></pre></td></tr></table></figure>\n<h2 id=\"与systemLayoutSizeFittingSize的比较\"><a href=\"#与systemLayoutSizeFittingSize的比较\" class=\"headerlink\" title=\"与systemLayoutSizeFittingSize的比较\"></a>与systemLayoutSizeFittingSize的比较</h2><p><code>systemLayoutSizeFittingSize</code>方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了<code>sizeThatFits</code>吧)，得到最适合的supview的高度。</p>\n<p><code>sizetofit</code>和<code>sizethatfits</code>则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。</p>\n<blockquote>\n<p>Demo 详见 UIScrollViewDemo/Parallax</p>\n</blockquote>"},{"title":"UITableView 基础","date":"2016-08-30T06:07:12.000Z","_content":"\nUITableView是最常用的基本控件。此处对其一般用法进行总结。\n\n<!--more-->\n\n\n## UITableView基础\n### UITableView 的样式\n1. UITableViewStylePlain\t\t将会保持在顶部直到被顶掉\n2. UITableViewStyleGrouped\t\t将会随着cell一起滚动\n\n```objc\nUITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyle];\n```\n\n其中`CGRectZero`表示`equivalent to CGRectMake(0, 0, 0, 0)`.之后代码会改UITableView的Frame，所以暂且都是0。\n\n### UITableView对象提供数据\nUITableView不包含任何数据，需要提供一个数据源.  \n我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。  \n在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议\n```objc\n@interface BNRAppDelegate: UIResponder <UIApplicationDelegate,UITableViewDataSource>\n@property (nonatomic) UITableView *taskTable;\n@property (nonatomic) NSMutable Array *tasks;\n@end\n```\n\n在.m中向UITableView发送`setDataSource`消息，将BNRAPPDelegate实例设置为数据源\n\n```objc\nself.taskTable.dataSource = self;\n```\n\nUITableViewDataSource设置了两个必须方法：\n\n1. 根据指定的表格索引给出相应表格段包含的行数（`tableView：numberOfRowsInSection：`）\n2. 根据指定表格段索引和行索引给出相应的UITableViewCell对象（`tableView：cellForRowAtIndexPath：`）\n```objc\n@implementation BNRAppDelegate\n-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{\n\t    return [self.tasks count];\n}\n-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n        UITableViewCell *c = [self.taskTable dequeueReusableCellWithIdentifier:@“cell”];\n\t    //重用cell\n\t    NSString *item = [self.tasks objectAtIndex:indexPath.row];\n\t    c.textLabel.text = item;\n\t    return c;\n}\n```\n\n刷新表格：`[self.taskTable reloadData];`\n\n### 重用UITableViewCell对象\n需要将自定义的cell类和identifier进行关联。  \n在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell\n```objc\n-(void)viewDidLoad{\n\t[super viewDidLoad];\n\t[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@“UITableViewCell”];\n}\n```\n\n这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联\n```objc\n[self.tableView registerNib:[UINib nibWithNibName:@\"MineUserInfoCell\" bundle:nil]  forCellReuseIdentifier:@\"MineUserInfoCellIdentifier\"];\n```\n\n### 使用UIViewController创建tabeView\n需要自己创建tableview属性：\n```objc\n@property (nonatomic, strong) UITableView *tableView;\n```\n这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。\n如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。\n\n### 创建多个section的tableview\n创建多个section的tableview需要实现方法`numberOfSectionsInTableView:`返回tableview中section的个数。其余使用和单个section一样。\n\n在`cellForRowAtIndexPath:`方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数`(NSIndexPath *)indexPath`。\n\n`NSIndexPath`是一个结构体，具有两个属性`row`和`section`。表示所在section和section内row。\n`NSIndexPath`中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。\n创建方式:\n```objc\nNSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:1];\n```\n\n### TableView表头视图\n表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。\n```objc\nUIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@\"HotelReviewsHeaderView\" owner:nil options:nil]lastObject];\n```\n\n**loadNibNamed:owner:options:**返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。`initWithNibName`的实现和该方法类似，其中也会用到该方法。不过`initWithNibName`用在获取Controller的xib中。\n\n---\n\n差个题外话，这里我们来介绍下`loaNibNamed`方法和`initWithNibName`方法的异同。\n\n首先明确一点：`loadNibNamed`、`initWithNibName`以及`nibWithNibName`后面跟的都是**文件名**，那么，怎么确定该xib文件下对应的是哪个view呢？\n\n先介绍下xib文件中的`File's Owner`:\n`File's Owner` 表示视图控制器。UIViewController(或其子类)在生成的时候，首先会寻找相应的`.xib`去生成，于是controller的实例(instance)就把`.xib`载入内存，并成为`FIle's Owner`（也就是说明了为什么叫做占位符）。**所以我们定义的controller是这个`.xib`的`custom class`。**并且需要把这个`FIle Owner`上的`outlet`连到某个控件上去。（Action也同样道理）换个角度，如果我们看`.xib`文件，发现它有个`File\n Owner`,其实就是我们用来设定，究竟是那个Object来读取并载入这个`.xib`文件，也就是说，谁own这个文件。\n \n那么，也就是说，对于`initWithNibName`方法而言，它加载的必须是设置了`File's Owner`为自身的xib，**设置了`File's Owner`就说明，这个xib被这个Controller承包了，别的Controller用不了。**`File's Owner`会和文件中需要加载的view关联(也就是连线，`File's Owner`的view属性会联结要显示的view)，从而从众多view中确定要显示的view是哪一个。这就说明了两点：第一，一个Controller可以有多个xib，只要xib的`File's Owner`都指向那个Controller就行。第二，不用担心一个xib中有多个并列的view导致机器不知道要加载哪个的情况，因为`File's Owner`的`view`只会联结这些view中的一个。\n\n对于自定义的view，任何Controller都能获得该view，因此，不能设置其xib文件的`File's Owner`。上面也说了，通过`loadNibNamed`方法会返回各个view的数组，需要自己手动选择要加载哪个。\n\n`loadNibNamed`方法也可以获得`initWithNibName`的view。`loadNibNamed:owner:options:`方法中有一个`owner`参数，就是用来传`File's Owner`的。\n对于自定义的view所属的xib文件，由于没有`File's Owner`，因此加载的时候`owner`传入`nil`。\n对于有`File's Owner`的Controller的xib，`owner`需要传入该xib文件相应`File's Owner`的实例，否则无法加载，返回该xib内所有view的数组。在lldb中可以验证Controller的view属性就是通过`loadNibNamed`拿到的view：\n\n```objc\n(lldb) p [[[NSBundle mainBundle]loadNibNamed:@\"xxxController\" owner:self options:nil] firstObject] == self.view\n(bool) $1 = true\n```\n\n---\n\n```objc\n- (void)viewDidLoad{\n\tUIView *header = self.headerView;\n\t[self.tableView setTableHeaderView:header];\n}\n```\n加载完headerView后，将其设置为UITableView对象的表头视图。\n也可以在 **(UIView \\*)tableView:viewForHeaderInSection:**方法中设置，当只有一个section时效果相同。\n```objc\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{\n    UIView *view = [[[NSBundle mainBundle] loadNibNamed:@\"HeaderView\" owner:nil options:nil] lastObject];\n    return view;\n}\n```\n\n### tableview的字母索引\n实现`sectionIndexTitlesForTableView`方法，返回一个字符串数组：\n```objc\n- (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView{\n    NSMutableArray *indexs = [[NSMutableArray alloc]init];\n    [indexs addObject:@\"我\"];\n    [indexs addObject:@\"是\"];\n    return indexs;\n}\n```\n这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。\n\n### 点击cell中button获取所属indexpath\nbutton点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。\n```objc\n[cell.btn addTarget:self action:@selector(cellBtnClicked:event:) forControlEvents:UIControlEventTouchUpInside];\n\n- (void)cellBtnClicked:(id)sender event:(id)event\n{\n    NSSet *touches =[event allTouches];\n    UITouch *touch =[touches anyObject];\n    CGPoint currentTouchPosition = [touch locationInView:_tableView];\n    NSIndexPath *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];\n    if (indexPath!= nil)\n    {\n        // do something\n    }\n}\n```\n\n可以通过`event`拿到在tableView中的位置`cure`，再通过`indexPathForRowAtPoint:`方法获取`NSIndexPath`。\n\n另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：\n```objc\n//cell.h中的声明\n- (IBAction)buttonPressed :(id)；\n\n//cell.m中的实现，设置代理\n- (void)buttonPressed:(id)sender{\n    [self.delegate buttonPressed:self event:event];\n}\n\n//viewcontroller中的实现\n- (void)buttonPressed:(TableViewCell1 *)cell{\n    NSIndexPath *indexPath2 = [_tableView indexPathForCell:cell];\n    NSLog(@\"所属行数：%ld\",(long)indexPath2.row+1);\n}\n```\n\n通过设置delegate，将button的点击事件交给viewController完成。\n\n## 编辑UITableView\n### 编辑模式下的UITableView\n#### 进入编辑模式\n通过调用`[_tableView setEditing:!_tableView.isEditing animated:true]`进入编辑模式,可实现添加，删除，移动操作。\n默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。\n\n#### TableView 编辑行\n使用**setEditing:animated:**方法让tableView进入编辑模式.可以使用**tableView:canEditRowAtIndexPath**方法筛选能进入编辑模式的行：\n```objc\n- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {\n    if(indexPath.row == (10 | 12 | 14)){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n如果不实现该方法，默认为YES。\n\n#### 编辑模式\n通过设置`UITableViewCellEditingStyle`可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的`commitEditingStyle:forRowAtIndexPath:`方法的入参传入。\n```objc\n-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{\n    if (condition) {\n        return UITableViewCellEditingStyleInsert;\n    }else{\n   \t\treturn UITableViewCellEditingStyleDelete;\n\t}\n}\n```\n\n#### 编辑模式下的插入和删除行\n实现`tableView:commitEditingStyle:forRowAtIndexPath:`方法。传入三个参数。  \n第一个实参是发送该消息的UITableView对象。  \n第二个实参是`UITableViewCellEditingStyle`类型的常数(删除表格行时，传入的是`UITableViewCellEditingStyleDelete`;插入表格行时，传入的是`UITableViewCellEditingStyleInsert`)。  \n第三个实参是一个NSIndexPath对象。\n```objc\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n    if (editingStyle == UITableViewCellEditingStyleDelete) {\n        [self.dataSource removeObjectAtIndex:indexPath.row];\n        [self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];\n    }else if (editingStyle == UITableViewCellEditingStyleInsert){\n    \t[self.dataSource insertObject:@\"我是新来的\" atIndex:indexPath.row];\n        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom];\n    }\n}\n```\n使用`deleteRowsAtIndexPaths`和`insertRowsAtIndexPaths`可以进行局部刷新，节省资源，并且还能添加指定动画。\ndelete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。\n\n#### cell的移动\n进入编辑模式后\n实现`tableView:moveRowAtIndexPath:`方法\n```objc\n- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{\n    if(sourceIndexPath == destinationIndexPath){\n        return ;\n    }else{\n        Comment *comment = [self.dataSource objectAtIndex:sourceIndexPath.row];\n        [self.dataSource removeObjectAtIndex:sourceIndexPath.row];\n        [self.dataSource insertObject:comment atIndex:destinationIndexPath.row];\n    }\n}\n```\n一定要对数据源进行正确操作。\n\n#### TableView 修改删除按钮\n```objc\n- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return @\"删除\";\n}\n```\n\n### 不在编辑模式下的编辑方式\n#### 刷新方式\n简单总结一些UITableView的刷新方法：\n- reloadData\t\t\t\t\t\t\t\t\t刷新整个表格\n- reloadRowsAtIndexPaths:withRowAnimation:\t\t刷新indexPath指向的cell\n- reloadSections:withRowAnimation:\t\t\t\t刷新NSIndexSet内包含的Section\n\n这三个分别刷新tableview的各个部分\n第一个没有动画效果。\n第二个可以传入一个数组\n```objc\n[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];\n```\n第三个可以传入一个NSIndexSet集合\n```objc\n[self.tableView reloadSections:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)] withRowAnimation:UITableViewRowAnimationFade];\n[_tableView reloadSections:[NSIndexSet indexSetWithIndex:indexPath.section]withRowAnimation:UITableViewRowAnimationLeft];\n```\n\n#### 插入删除\n在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。\n- deleteRowsAtIndexPaths:withRowAnimation:\n- insertRowsAtIndexPaths:withRowAnimation:\n\n就不举例了。同上面一样。\n\n## 小技巧\n### 当cell未能填满tableview时，怎么响应空白部分点击事件\n当 tableview 太大，cell 太少，以至于不能填满tableview的时候，那么空白部分的点击事件该怎么设置呢？只要给 tableview 添加一个 footerview，这个 footerview 的大小是整个 tableview 的大小，然后设置这个 footerview 的点击事件即可。\n\n为什么能这样呢？因为 cell 没有填充满的部分都用 footerview 填充了。\n\n\n\n\n\n\n\n\n","source":"_posts/UITableView基础.md","raw":"title: UITableView 基础\ndate: 2016/8/30 14:07:12  \ncategories: iOS \ntags: \n\t- 基本控件\n\n\t\n---\n\nUITableView是最常用的基本控件。此处对其一般用法进行总结。\n\n<!--more-->\n\n\n## UITableView基础\n### UITableView 的样式\n1. UITableViewStylePlain\t\t将会保持在顶部直到被顶掉\n2. UITableViewStyleGrouped\t\t将会随着cell一起滚动\n\n```objc\nUITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyle];\n```\n\n其中`CGRectZero`表示`equivalent to CGRectMake(0, 0, 0, 0)`.之后代码会改UITableView的Frame，所以暂且都是0。\n\n### UITableView对象提供数据\nUITableView不包含任何数据，需要提供一个数据源.  \n我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。  \n在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议\n```objc\n@interface BNRAppDelegate: UIResponder <UIApplicationDelegate,UITableViewDataSource>\n@property (nonatomic) UITableView *taskTable;\n@property (nonatomic) NSMutable Array *tasks;\n@end\n```\n\n在.m中向UITableView发送`setDataSource`消息，将BNRAPPDelegate实例设置为数据源\n\n```objc\nself.taskTable.dataSource = self;\n```\n\nUITableViewDataSource设置了两个必须方法：\n\n1. 根据指定的表格索引给出相应表格段包含的行数（`tableView：numberOfRowsInSection：`）\n2. 根据指定表格段索引和行索引给出相应的UITableViewCell对象（`tableView：cellForRowAtIndexPath：`）\n```objc\n@implementation BNRAppDelegate\n-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{\n\t    return [self.tasks count];\n}\n-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n        UITableViewCell *c = [self.taskTable dequeueReusableCellWithIdentifier:@“cell”];\n\t    //重用cell\n\t    NSString *item = [self.tasks objectAtIndex:indexPath.row];\n\t    c.textLabel.text = item;\n\t    return c;\n}\n```\n\n刷新表格：`[self.taskTable reloadData];`\n\n### 重用UITableViewCell对象\n需要将自定义的cell类和identifier进行关联。  \n在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell\n```objc\n-(void)viewDidLoad{\n\t[super viewDidLoad];\n\t[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@“UITableViewCell”];\n}\n```\n\n这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联\n```objc\n[self.tableView registerNib:[UINib nibWithNibName:@\"MineUserInfoCell\" bundle:nil]  forCellReuseIdentifier:@\"MineUserInfoCellIdentifier\"];\n```\n\n### 使用UIViewController创建tabeView\n需要自己创建tableview属性：\n```objc\n@property (nonatomic, strong) UITableView *tableView;\n```\n这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。\n如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。\n\n### 创建多个section的tableview\n创建多个section的tableview需要实现方法`numberOfSectionsInTableView:`返回tableview中section的个数。其余使用和单个section一样。\n\n在`cellForRowAtIndexPath:`方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数`(NSIndexPath *)indexPath`。\n\n`NSIndexPath`是一个结构体，具有两个属性`row`和`section`。表示所在section和section内row。\n`NSIndexPath`中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。\n创建方式:\n```objc\nNSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:1];\n```\n\n### TableView表头视图\n表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。\n```objc\nUIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@\"HotelReviewsHeaderView\" owner:nil options:nil]lastObject];\n```\n\n**loadNibNamed:owner:options:**返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。`initWithNibName`的实现和该方法类似，其中也会用到该方法。不过`initWithNibName`用在获取Controller的xib中。\n\n---\n\n差个题外话，这里我们来介绍下`loaNibNamed`方法和`initWithNibName`方法的异同。\n\n首先明确一点：`loadNibNamed`、`initWithNibName`以及`nibWithNibName`后面跟的都是**文件名**，那么，怎么确定该xib文件下对应的是哪个view呢？\n\n先介绍下xib文件中的`File's Owner`:\n`File's Owner` 表示视图控制器。UIViewController(或其子类)在生成的时候，首先会寻找相应的`.xib`去生成，于是controller的实例(instance)就把`.xib`载入内存，并成为`FIle's Owner`（也就是说明了为什么叫做占位符）。**所以我们定义的controller是这个`.xib`的`custom class`。**并且需要把这个`FIle Owner`上的`outlet`连到某个控件上去。（Action也同样道理）换个角度，如果我们看`.xib`文件，发现它有个`File\n Owner`,其实就是我们用来设定，究竟是那个Object来读取并载入这个`.xib`文件，也就是说，谁own这个文件。\n \n那么，也就是说，对于`initWithNibName`方法而言，它加载的必须是设置了`File's Owner`为自身的xib，**设置了`File's Owner`就说明，这个xib被这个Controller承包了，别的Controller用不了。**`File's Owner`会和文件中需要加载的view关联(也就是连线，`File's Owner`的view属性会联结要显示的view)，从而从众多view中确定要显示的view是哪一个。这就说明了两点：第一，一个Controller可以有多个xib，只要xib的`File's Owner`都指向那个Controller就行。第二，不用担心一个xib中有多个并列的view导致机器不知道要加载哪个的情况，因为`File's Owner`的`view`只会联结这些view中的一个。\n\n对于自定义的view，任何Controller都能获得该view，因此，不能设置其xib文件的`File's Owner`。上面也说了，通过`loadNibNamed`方法会返回各个view的数组，需要自己手动选择要加载哪个。\n\n`loadNibNamed`方法也可以获得`initWithNibName`的view。`loadNibNamed:owner:options:`方法中有一个`owner`参数，就是用来传`File's Owner`的。\n对于自定义的view所属的xib文件，由于没有`File's Owner`，因此加载的时候`owner`传入`nil`。\n对于有`File's Owner`的Controller的xib，`owner`需要传入该xib文件相应`File's Owner`的实例，否则无法加载，返回该xib内所有view的数组。在lldb中可以验证Controller的view属性就是通过`loadNibNamed`拿到的view：\n\n```objc\n(lldb) p [[[NSBundle mainBundle]loadNibNamed:@\"xxxController\" owner:self options:nil] firstObject] == self.view\n(bool) $1 = true\n```\n\n---\n\n```objc\n- (void)viewDidLoad{\n\tUIView *header = self.headerView;\n\t[self.tableView setTableHeaderView:header];\n}\n```\n加载完headerView后，将其设置为UITableView对象的表头视图。\n也可以在 **(UIView \\*)tableView:viewForHeaderInSection:**方法中设置，当只有一个section时效果相同。\n```objc\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{\n    UIView *view = [[[NSBundle mainBundle] loadNibNamed:@\"HeaderView\" owner:nil options:nil] lastObject];\n    return view;\n}\n```\n\n### tableview的字母索引\n实现`sectionIndexTitlesForTableView`方法，返回一个字符串数组：\n```objc\n- (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView{\n    NSMutableArray *indexs = [[NSMutableArray alloc]init];\n    [indexs addObject:@\"我\"];\n    [indexs addObject:@\"是\"];\n    return indexs;\n}\n```\n这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。\n\n### 点击cell中button获取所属indexpath\nbutton点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。\n```objc\n[cell.btn addTarget:self action:@selector(cellBtnClicked:event:) forControlEvents:UIControlEventTouchUpInside];\n\n- (void)cellBtnClicked:(id)sender event:(id)event\n{\n    NSSet *touches =[event allTouches];\n    UITouch *touch =[touches anyObject];\n    CGPoint currentTouchPosition = [touch locationInView:_tableView];\n    NSIndexPath *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];\n    if (indexPath!= nil)\n    {\n        // do something\n    }\n}\n```\n\n可以通过`event`拿到在tableView中的位置`cure`，再通过`indexPathForRowAtPoint:`方法获取`NSIndexPath`。\n\n另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：\n```objc\n//cell.h中的声明\n- (IBAction)buttonPressed :(id)；\n\n//cell.m中的实现，设置代理\n- (void)buttonPressed:(id)sender{\n    [self.delegate buttonPressed:self event:event];\n}\n\n//viewcontroller中的实现\n- (void)buttonPressed:(TableViewCell1 *)cell{\n    NSIndexPath *indexPath2 = [_tableView indexPathForCell:cell];\n    NSLog(@\"所属行数：%ld\",(long)indexPath2.row+1);\n}\n```\n\n通过设置delegate，将button的点击事件交给viewController完成。\n\n## 编辑UITableView\n### 编辑模式下的UITableView\n#### 进入编辑模式\n通过调用`[_tableView setEditing:!_tableView.isEditing animated:true]`进入编辑模式,可实现添加，删除，移动操作。\n默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。\n\n#### TableView 编辑行\n使用**setEditing:animated:**方法让tableView进入编辑模式.可以使用**tableView:canEditRowAtIndexPath**方法筛选能进入编辑模式的行：\n```objc\n- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {\n    if(indexPath.row == (10 | 12 | 14)){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n如果不实现该方法，默认为YES。\n\n#### 编辑模式\n通过设置`UITableViewCellEditingStyle`可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的`commitEditingStyle:forRowAtIndexPath:`方法的入参传入。\n```objc\n-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{\n    if (condition) {\n        return UITableViewCellEditingStyleInsert;\n    }else{\n   \t\treturn UITableViewCellEditingStyleDelete;\n\t}\n}\n```\n\n#### 编辑模式下的插入和删除行\n实现`tableView:commitEditingStyle:forRowAtIndexPath:`方法。传入三个参数。  \n第一个实参是发送该消息的UITableView对象。  \n第二个实参是`UITableViewCellEditingStyle`类型的常数(删除表格行时，传入的是`UITableViewCellEditingStyleDelete`;插入表格行时，传入的是`UITableViewCellEditingStyleInsert`)。  \n第三个实参是一个NSIndexPath对象。\n```objc\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n    if (editingStyle == UITableViewCellEditingStyleDelete) {\n        [self.dataSource removeObjectAtIndex:indexPath.row];\n        [self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];\n    }else if (editingStyle == UITableViewCellEditingStyleInsert){\n    \t[self.dataSource insertObject:@\"我是新来的\" atIndex:indexPath.row];\n        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom];\n    }\n}\n```\n使用`deleteRowsAtIndexPaths`和`insertRowsAtIndexPaths`可以进行局部刷新，节省资源，并且还能添加指定动画。\ndelete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。\n\n#### cell的移动\n进入编辑模式后\n实现`tableView:moveRowAtIndexPath:`方法\n```objc\n- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{\n    if(sourceIndexPath == destinationIndexPath){\n        return ;\n    }else{\n        Comment *comment = [self.dataSource objectAtIndex:sourceIndexPath.row];\n        [self.dataSource removeObjectAtIndex:sourceIndexPath.row];\n        [self.dataSource insertObject:comment atIndex:destinationIndexPath.row];\n    }\n}\n```\n一定要对数据源进行正确操作。\n\n#### TableView 修改删除按钮\n```objc\n- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return @\"删除\";\n}\n```\n\n### 不在编辑模式下的编辑方式\n#### 刷新方式\n简单总结一些UITableView的刷新方法：\n- reloadData\t\t\t\t\t\t\t\t\t刷新整个表格\n- reloadRowsAtIndexPaths:withRowAnimation:\t\t刷新indexPath指向的cell\n- reloadSections:withRowAnimation:\t\t\t\t刷新NSIndexSet内包含的Section\n\n这三个分别刷新tableview的各个部分\n第一个没有动画效果。\n第二个可以传入一个数组\n```objc\n[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];\n```\n第三个可以传入一个NSIndexSet集合\n```objc\n[self.tableView reloadSections:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)] withRowAnimation:UITableViewRowAnimationFade];\n[_tableView reloadSections:[NSIndexSet indexSetWithIndex:indexPath.section]withRowAnimation:UITableViewRowAnimationLeft];\n```\n\n#### 插入删除\n在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。\n- deleteRowsAtIndexPaths:withRowAnimation:\n- insertRowsAtIndexPaths:withRowAnimation:\n\n就不举例了。同上面一样。\n\n## 小技巧\n### 当cell未能填满tableview时，怎么响应空白部分点击事件\n当 tableview 太大，cell 太少，以至于不能填满tableview的时候，那么空白部分的点击事件该怎么设置呢？只要给 tableview 添加一个 footerview，这个 footerview 的大小是整个 tableview 的大小，然后设置这个 footerview 的点击事件即可。\n\n为什么能这样呢？因为 cell 没有填充满的部分都用 footerview 填充了。\n\n\n\n\n\n\n\n\n","slug":"UITableView基础","published":1,"updated":"2016-12-07T10:25:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dpy001l7hzgjhce0e0a","content":"<p>UITableView是最常用的基本控件。此处对其一般用法进行总结。</p>\n<a id=\"more\"></a>\n<h2 id=\"UITableView基础\"><a href=\"#UITableView基础\" class=\"headerlink\" title=\"UITableView基础\"></a>UITableView基础</h2><h3 id=\"UITableView-的样式\"><a href=\"#UITableView-的样式\" class=\"headerlink\" title=\"UITableView 的样式\"></a>UITableView 的样式</h3><ol>\n<li>UITableViewStylePlain        将会保持在顶部直到被顶掉</li>\n<li>UITableViewStyleGrouped        将会随着cell一起滚动</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITableView</span> *tableView = [[<span class=\"built_in\">UITableView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectZero</span> style:<span class=\"built_in\">UITableViewStyle</span>];</div></pre></td></tr></table></figure>\n<p>其中<code>CGRectZero</code>表示<code>equivalent to CGRectMake(0, 0, 0, 0)</code>.之后代码会改UITableView的Frame，所以暂且都是0。</p>\n<h3 id=\"UITableView对象提供数据\"><a href=\"#UITableView对象提供数据\" class=\"headerlink\" title=\"UITableView对象提供数据\"></a>UITableView对象提供数据</h3><p>UITableView不包含任何数据，需要提供一个数据源.<br>我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。<br>在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRAppDelegate</span>: <span class=\"title\">UIResponder</span> &lt;<span class=\"title\">UIApplicationDelegate</span>,<span class=\"title\">UITableViewDataSource</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UITableView</span> *taskTable;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSMutable</span> Array *tasks;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中向UITableView发送<code>setDataSource</code>消息，将BNRAPPDelegate实例设置为数据源</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.taskTable.dataSource = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>UITableViewDataSource设置了两个必须方法：</p>\n<ol>\n<li>根据指定的表格索引给出相应表格段包含的行数（<code>tableView：numberOfRowsInSection：</code>）</li>\n<li>根据指定表格段索引和行索引给出相应的UITableViewCell对象（<code>tableView：cellForRowAtIndexPath：</code>）<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BNRAppDelegate</span></span></div><div class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.tasks count];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">        <span class=\"built_in\">UITableViewCell</span> *c = [<span class=\"keyword\">self</span>.taskTable dequeueReusableCellWithIdentifier:@“cell”];</div><div class=\"line\">\t    <span class=\"comment\">//重用cell</span></div><div class=\"line\">\t    <span class=\"built_in\">NSString</span> *item = [<span class=\"keyword\">self</span>.tasks objectAtIndex:indexPath.row];</div><div class=\"line\">\t    c.textLabel.text = item;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> c;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>刷新表格：<code>[self.taskTable reloadData];</code></p>\n<h3 id=\"重用UITableViewCell对象\"><a href=\"#重用UITableViewCell对象\" class=\"headerlink\" title=\"重用UITableViewCell对象\"></a>重用UITableViewCell对象</h3><p>需要将自定义的cell类和identifier进行关联。<br>在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView registerClass:[<span class=\"built_in\">UITableViewCell</span> <span class=\"keyword\">class</span>] forCellReuseIdentifier:@“<span class=\"built_in\">UITableViewCell</span>”];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView registerNib:[<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"MineUserInfoCell\"</span> bundle:<span class=\"literal\">nil</span>]  forCellReuseIdentifier:<span class=\"string\">@\"MineUserInfoCellIdentifier\"</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用UIViewController创建tabeView\"><a href=\"#使用UIViewController创建tabeView\" class=\"headerlink\" title=\"使用UIViewController创建tabeView\"></a>使用UIViewController创建tabeView</h3><p>需要自己创建tableview属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITableView</span> *tableView;</div></pre></td></tr></table></figure></p>\n<p>这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。<br>如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。</p>\n<h3 id=\"创建多个section的tableview\"><a href=\"#创建多个section的tableview\" class=\"headerlink\" title=\"创建多个section的tableview\"></a>创建多个section的tableview</h3><p>创建多个section的tableview需要实现方法<code>numberOfSectionsInTableView:</code>返回tableview中section的个数。其余使用和单个section一样。</p>\n<p>在<code>cellForRowAtIndexPath:</code>方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数<code>(NSIndexPath *)indexPath</code>。</p>\n<p><code>NSIndexPath</code>是一个结构体，具有两个属性<code>row</code>和<code>section</code>。表示所在section和section内row。<br><code>NSIndexPath</code>中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。<br>创建方式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:<span class=\"number\">1</span> inSection:<span class=\"number\">1</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"TableView表头视图\"><a href=\"#TableView表头视图\" class=\"headerlink\" title=\"TableView表头视图\"></a>TableView表头视图</h3><p>表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *headerView = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HotelReviewsHeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>]lastObject];</div></pre></td></tr></table></figure></p>\n<p><strong>loadNibNamed:owner:options:</strong>返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。<code>initWithNibName</code>的实现和该方法类似，其中也会用到该方法。不过<code>initWithNibName</code>用在获取Controller的xib中。</p>\n<hr>\n<p>差个题外话，这里我们来介绍下<code>loaNibNamed</code>方法和<code>initWithNibName</code>方法的异同。</p>\n<p>首先明确一点：<code>loadNibNamed</code>、<code>initWithNibName</code>以及<code>nibWithNibName</code>后面跟的都是<strong>文件名</strong>，那么，怎么确定该xib文件下对应的是哪个view呢？</p>\n<p>先介绍下xib文件中的<code>File&#39;s Owner</code>:<br><code>File&#39;s Owner</code> 表示视图控制器。UIViewController(或其子类)在生成的时候，首先会寻找相应的<code>.xib</code>去生成，于是controller的实例(instance)就把<code>.xib</code>载入内存，并成为<code>FIle&#39;s Owner</code>（也就是说明了为什么叫做占位符）。<strong>所以我们定义的controller是这个<code>.xib</code>的<code>custom class</code>。</strong>并且需要把这个<code>FIle Owner</code>上的<code>outlet</code>连到某个控件上去。（Action也同样道理）换个角度，如果我们看<code>.xib</code>文件，发现它有个<code>File\n Owner</code>,其实就是我们用来设定，究竟是那个Object来读取并载入这个<code>.xib</code>文件，也就是说，谁own这个文件。</p>\n<p>那么，也就是说，对于<code>initWithNibName</code>方法而言，它加载的必须是设置了<code>File&#39;s Owner</code>为自身的xib，<strong>设置了<code>File&#39;s Owner</code>就说明，这个xib被这个Controller承包了，别的Controller用不了。</strong><code>File&#39;s Owner</code>会和文件中需要加载的view关联(也就是连线，<code>File&#39;s Owner</code>的view属性会联结要显示的view)，从而从众多view中确定要显示的view是哪一个。这就说明了两点：第一，一个Controller可以有多个xib，只要xib的<code>File&#39;s Owner</code>都指向那个Controller就行。第二，不用担心一个xib中有多个并列的view导致机器不知道要加载哪个的情况，因为<code>File&#39;s Owner</code>的<code>view</code>只会联结这些view中的一个。</p>\n<p>对于自定义的view，任何Controller都能获得该view，因此，不能设置其xib文件的<code>File&#39;s Owner</code>。上面也说了，通过<code>loadNibNamed</code>方法会返回各个view的数组，需要自己手动选择要加载哪个。</p>\n<p><code>loadNibNamed</code>方法也可以获得<code>initWithNibName</code>的view。<code>loadNibNamed:owner:options:</code>方法中有一个<code>owner</code>参数，就是用来传<code>File&#39;s Owner</code>的。<br>对于自定义的view所属的xib文件，由于没有<code>File&#39;s Owner</code>，因此加载的时候<code>owner</code>传入<code>nil</code>。<br>对于有<code>File&#39;s Owner</code>的Controller的xib，<code>owner</code>需要传入该xib文件相应<code>File&#39;s Owner</code>的实例，否则无法加载，返回该xib内所有view的数组。在lldb中可以验证Controller的view属性就是通过<code>loadNibNamed</code>拿到的view：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p [[[<span class=\"built_in\">NSBundle</span> mainBundle]loadNibNamed:<span class=\"string\">@\"xxxController\"</span> owner:<span class=\"keyword\">self</span> options:<span class=\"literal\">nil</span>] firstObject] == <span class=\"keyword\">self</span>.view</div><div class=\"line\">(<span class=\"keyword\">bool</span>) $<span class=\"number\">1</span> = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t<span class=\"built_in\">UIView</span> *header = <span class=\"keyword\">self</span>.headerView;</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView setTableHeaderView:header];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载完headerView后，将其设置为UITableView对象的表头视图。<br>也可以在 <strong>(UIView *)tableView:viewForHeaderInSection:</strong>方法中设置，当只有一个section时效果相同。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView viewForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>] lastObject];</div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"tableview的字母索引\"><a href=\"#tableview的字母索引\" class=\"headerlink\" title=\"tableview的字母索引\"></a>tableview的字母索引</h3><p>实现<code>sectionIndexTitlesForTableView</code>方法，返回一个字符串数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class=\"built_in\">UITableView</span> *)tableView&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *indexs = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"我\"</span>];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"是\"</span>];</div><div class=\"line\">    <span class=\"keyword\">return</span> indexs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。</p>\n<h3 id=\"点击cell中button获取所属indexpath\"><a href=\"#点击cell中button获取所属indexpath\" class=\"headerlink\" title=\"点击cell中button获取所属indexpath\"></a>点击cell中button获取所属indexpath</h3><p>button点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[cell.btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(cellBtnClicked:event:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cellBtnClicked:(<span class=\"keyword\">id</span>)sender event:(<span class=\"keyword\">id</span>)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSSet</span> *touches =[event allTouches];</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch =[touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> currentTouchPosition = [touch locationInView:_tableView];</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexPath!= <span class=\"literal\">nil</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>event</code>拿到在tableView中的位置<code>cure</code>，再通过<code>indexPathForRowAtPoint:</code>方法获取<code>NSIndexPath</code>。</p>\n<p>另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//cell.h中的声明</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)buttonPressed :(<span class=\"keyword\">id</span>)；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//cell.m中的实现，设置代理</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.delegate buttonPressed:<span class=\"keyword\">self</span> event:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewcontroller中的实现</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(TableViewCell1 *)cell&#123;</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath2 = [_tableView indexPathForCell:cell];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"所属行数：%ld\"</span>,(<span class=\"keyword\">long</span>)indexPath2.row+<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过设置delegate，将button的点击事件交给viewController完成。</p>\n<h2 id=\"编辑UITableView\"><a href=\"#编辑UITableView\" class=\"headerlink\" title=\"编辑UITableView\"></a>编辑UITableView</h2><h3 id=\"编辑模式下的UITableView\"><a href=\"#编辑模式下的UITableView\" class=\"headerlink\" title=\"编辑模式下的UITableView\"></a>编辑模式下的UITableView</h3><h4 id=\"进入编辑模式\"><a href=\"#进入编辑模式\" class=\"headerlink\" title=\"进入编辑模式\"></a>进入编辑模式</h4><p>通过调用<code>[_tableView setEditing:!_tableView.isEditing animated:true]</code>进入编辑模式,可实现添加，删除，移动操作。<br>默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。</p>\n<h4 id=\"TableView-编辑行\"><a href=\"#TableView-编辑行\" class=\"headerlink\" title=\"TableView 编辑行\"></a>TableView 编辑行</h4><p>使用<strong>setEditing:animated:</strong>方法让tableView进入编辑模式.可以使用<strong>tableView:canEditRowAtIndexPath</strong>方法筛选能进入编辑模式的行：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView canEditRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(indexPath.row == (<span class=\"number\">10</span> | <span class=\"number\">12</span> | <span class=\"number\">14</span>))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果不实现该方法，默认为YES。</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>通过设置<code>UITableViewCellEditingStyle</code>可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的<code>commitEditingStyle:forRowAtIndexPath:</code>方法的入参传入。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UITableViewCellEditingStyle</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑模式下的插入和删除行\"><a href=\"#编辑模式下的插入和删除行\" class=\"headerlink\" title=\"编辑模式下的插入和删除行\"></a>编辑模式下的插入和删除行</h4><p>实现<code>tableView:commitEditingStyle:forRowAtIndexPath:</code>方法。传入三个参数。<br>第一个实参是发送该消息的UITableView对象。<br>第二个实参是<code>UITableViewCellEditingStyle</code>类型的常数(删除表格行时，传入的是<code>UITableViewCellEditingStyleDelete</code>;插入表格行时，传入的是<code>UITableViewCellEditingStyleInsert</code>)。<br>第三个实参是一个NSIndexPath对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView commitEditingStyle:(<span class=\"built_in\">UITableViewCellEditingStyle</span>)editingStyle forRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:indexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.tableView deleteRowsAtIndexPaths:[<span class=\"built_in\">NSArray</span> arrayWithObject:indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>)&#123;</div><div class=\"line\">    \t[<span class=\"keyword\">self</span>.dataSource insertObject:<span class=\"string\">@\"我是新来的\"</span> atIndex:indexPath.row];</div><div class=\"line\">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationBottom</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<code>deleteRowsAtIndexPaths</code>和<code>insertRowsAtIndexPaths</code>可以进行局部刷新，节省资源，并且还能添加指定动画。<br>delete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。</p>\n<h4 id=\"cell的移动\"><a href=\"#cell的移动\" class=\"headerlink\" title=\"cell的移动\"></a>cell的移动</h4><p>进入编辑模式后<br>实现<code>tableView:moveRowAtIndexPath:</code>方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView moveRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)destinationIndexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(sourceIndexPath == destinationIndexPath)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        Comment *comment = [<span class=\"keyword\">self</span>.dataSource objectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource insertObject:comment atIndex:destinationIndexPath.row];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定要对数据源进行正确操作。</p>\n<h4 id=\"TableView-修改删除按钮\"><a href=\"#TableView-修改删除按钮\" class=\"headerlink\" title=\"TableView 修改删除按钮\"></a>TableView 修改删除按钮</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"删除\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"不在编辑模式下的编辑方式\"><a href=\"#不在编辑模式下的编辑方式\" class=\"headerlink\" title=\"不在编辑模式下的编辑方式\"></a>不在编辑模式下的编辑方式</h3><h4 id=\"刷新方式\"><a href=\"#刷新方式\" class=\"headerlink\" title=\"刷新方式\"></a>刷新方式</h4><p>简单总结一些UITableView的刷新方法：</p>\n<ul>\n<li>reloadData                                    刷新整个表格</li>\n<li>reloadRowsAtIndexPaths:withRowAnimation:        刷新indexPath指向的cell</li>\n<li>reloadSections:withRowAnimation:                刷新NSIndexSet内包含的Section</li>\n</ul>\n<p>这三个分别刷新tableview的各个部分<br>第一个没有动画效果。<br>第二个可以传入一个数组<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationTop</span>];</div></pre></td></tr></table></figure></p>\n<p>第三个可以传入一个NSIndexSet集合<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">[_tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndex:indexPath.section]withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationLeft</span>];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入删除\"><a href=\"#插入删除\" class=\"headerlink\" title=\"插入删除\"></a>插入删除</h4><p>在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。</p>\n<ul>\n<li>deleteRowsAtIndexPaths:withRowAnimation:</li>\n<li>insertRowsAtIndexPaths:withRowAnimation:</li>\n</ul>\n<p>就不举例了。同上面一样。</p>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><h3 id=\"当cell未能填满tableview时，怎么响应空白部分点击事件\"><a href=\"#当cell未能填满tableview时，怎么响应空白部分点击事件\" class=\"headerlink\" title=\"当cell未能填满tableview时，怎么响应空白部分点击事件\"></a>当cell未能填满tableview时，怎么响应空白部分点击事件</h3><p>当 tableview 太大，cell 太少，以至于不能填满tableview的时候，那么空白部分的点击事件该怎么设置呢？只要给 tableview 添加一个 footerview，这个 footerview 的大小是整个 tableview 的大小，然后设置这个 footerview 的点击事件即可。</p>\n<p>为什么能这样呢？因为 cell 没有填充满的部分都用 footerview 填充了。</p>\n","excerpt":"<p>UITableView是最常用的基本控件。此处对其一般用法进行总结。</p>","more":"<h2 id=\"UITableView基础\"><a href=\"#UITableView基础\" class=\"headerlink\" title=\"UITableView基础\"></a>UITableView基础</h2><h3 id=\"UITableView-的样式\"><a href=\"#UITableView-的样式\" class=\"headerlink\" title=\"UITableView 的样式\"></a>UITableView 的样式</h3><ol>\n<li>UITableViewStylePlain        将会保持在顶部直到被顶掉</li>\n<li>UITableViewStyleGrouped        将会随着cell一起滚动</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITableView</span> *tableView = [[<span class=\"built_in\">UITableView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectZero</span> style:<span class=\"built_in\">UITableViewStyle</span>];</div></pre></td></tr></table></figure>\n<p>其中<code>CGRectZero</code>表示<code>equivalent to CGRectMake(0, 0, 0, 0)</code>.之后代码会改UITableView的Frame，所以暂且都是0。</p>\n<h3 id=\"UITableView对象提供数据\"><a href=\"#UITableView对象提供数据\" class=\"headerlink\" title=\"UITableView对象提供数据\"></a>UITableView对象提供数据</h3><p>UITableView不包含任何数据，需要提供一个数据源.<br>我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。<br>在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRAppDelegate</span>: <span class=\"title\">UIResponder</span> &lt;<span class=\"title\">UIApplicationDelegate</span>,<span class=\"title\">UITableViewDataSource</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UITableView</span> *taskTable;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSMutable</span> Array *tasks;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中向UITableView发送<code>setDataSource</code>消息，将BNRAPPDelegate实例设置为数据源</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.taskTable.dataSource = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>UITableViewDataSource设置了两个必须方法：</p>\n<ol>\n<li>根据指定的表格索引给出相应表格段包含的行数（<code>tableView：numberOfRowsInSection：</code>）</li>\n<li>根据指定表格段索引和行索引给出相应的UITableViewCell对象（<code>tableView：cellForRowAtIndexPath：</code>）<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BNRAppDelegate</span></span></div><div class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.tasks count];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">        <span class=\"built_in\">UITableViewCell</span> *c = [<span class=\"keyword\">self</span>.taskTable dequeueReusableCellWithIdentifier:@“cell”];</div><div class=\"line\">\t    <span class=\"comment\">//重用cell</span></div><div class=\"line\">\t    <span class=\"built_in\">NSString</span> *item = [<span class=\"keyword\">self</span>.tasks objectAtIndex:indexPath.row];</div><div class=\"line\">\t    c.textLabel.text = item;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> c;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>刷新表格：<code>[self.taskTable reloadData];</code></p>\n<h3 id=\"重用UITableViewCell对象\"><a href=\"#重用UITableViewCell对象\" class=\"headerlink\" title=\"重用UITableViewCell对象\"></a>重用UITableViewCell对象</h3><p>需要将自定义的cell类和identifier进行关联。<br>在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView registerClass:[<span class=\"built_in\">UITableViewCell</span> <span class=\"keyword\">class</span>] forCellReuseIdentifier:@“<span class=\"built_in\">UITableViewCell</span>”];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView registerNib:[<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"MineUserInfoCell\"</span> bundle:<span class=\"literal\">nil</span>]  forCellReuseIdentifier:<span class=\"string\">@\"MineUserInfoCellIdentifier\"</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用UIViewController创建tabeView\"><a href=\"#使用UIViewController创建tabeView\" class=\"headerlink\" title=\"使用UIViewController创建tabeView\"></a>使用UIViewController创建tabeView</h3><p>需要自己创建tableview属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITableView</span> *tableView;</div></pre></td></tr></table></figure></p>\n<p>这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。<br>如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。</p>\n<h3 id=\"创建多个section的tableview\"><a href=\"#创建多个section的tableview\" class=\"headerlink\" title=\"创建多个section的tableview\"></a>创建多个section的tableview</h3><p>创建多个section的tableview需要实现方法<code>numberOfSectionsInTableView:</code>返回tableview中section的个数。其余使用和单个section一样。</p>\n<p>在<code>cellForRowAtIndexPath:</code>方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数<code>(NSIndexPath *)indexPath</code>。</p>\n<p><code>NSIndexPath</code>是一个结构体，具有两个属性<code>row</code>和<code>section</code>。表示所在section和section内row。<br><code>NSIndexPath</code>中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。<br>创建方式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:<span class=\"number\">1</span> inSection:<span class=\"number\">1</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"TableView表头视图\"><a href=\"#TableView表头视图\" class=\"headerlink\" title=\"TableView表头视图\"></a>TableView表头视图</h3><p>表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *headerView = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HotelReviewsHeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>]lastObject];</div></pre></td></tr></table></figure></p>\n<p><strong>loadNibNamed:owner:options:</strong>返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。<code>initWithNibName</code>的实现和该方法类似，其中也会用到该方法。不过<code>initWithNibName</code>用在获取Controller的xib中。</p>\n<hr>\n<p>差个题外话，这里我们来介绍下<code>loaNibNamed</code>方法和<code>initWithNibName</code>方法的异同。</p>\n<p>首先明确一点：<code>loadNibNamed</code>、<code>initWithNibName</code>以及<code>nibWithNibName</code>后面跟的都是<strong>文件名</strong>，那么，怎么确定该xib文件下对应的是哪个view呢？</p>\n<p>先介绍下xib文件中的<code>File&#39;s Owner</code>:<br><code>File&#39;s Owner</code> 表示视图控制器。UIViewController(或其子类)在生成的时候，首先会寻找相应的<code>.xib</code>去生成，于是controller的实例(instance)就把<code>.xib</code>载入内存，并成为<code>FIle&#39;s Owner</code>（也就是说明了为什么叫做占位符）。<strong>所以我们定义的controller是这个<code>.xib</code>的<code>custom class</code>。</strong>并且需要把这个<code>FIle Owner</code>上的<code>outlet</code>连到某个控件上去。（Action也同样道理）换个角度，如果我们看<code>.xib</code>文件，发现它有个<code>File\n Owner</code>,其实就是我们用来设定，究竟是那个Object来读取并载入这个<code>.xib</code>文件，也就是说，谁own这个文件。</p>\n<p>那么，也就是说，对于<code>initWithNibName</code>方法而言，它加载的必须是设置了<code>File&#39;s Owner</code>为自身的xib，<strong>设置了<code>File&#39;s Owner</code>就说明，这个xib被这个Controller承包了，别的Controller用不了。</strong><code>File&#39;s Owner</code>会和文件中需要加载的view关联(也就是连线，<code>File&#39;s Owner</code>的view属性会联结要显示的view)，从而从众多view中确定要显示的view是哪一个。这就说明了两点：第一，一个Controller可以有多个xib，只要xib的<code>File&#39;s Owner</code>都指向那个Controller就行。第二，不用担心一个xib中有多个并列的view导致机器不知道要加载哪个的情况，因为<code>File&#39;s Owner</code>的<code>view</code>只会联结这些view中的一个。</p>\n<p>对于自定义的view，任何Controller都能获得该view，因此，不能设置其xib文件的<code>File&#39;s Owner</code>。上面也说了，通过<code>loadNibNamed</code>方法会返回各个view的数组，需要自己手动选择要加载哪个。</p>\n<p><code>loadNibNamed</code>方法也可以获得<code>initWithNibName</code>的view。<code>loadNibNamed:owner:options:</code>方法中有一个<code>owner</code>参数，就是用来传<code>File&#39;s Owner</code>的。<br>对于自定义的view所属的xib文件，由于没有<code>File&#39;s Owner</code>，因此加载的时候<code>owner</code>传入<code>nil</code>。<br>对于有<code>File&#39;s Owner</code>的Controller的xib，<code>owner</code>需要传入该xib文件相应<code>File&#39;s Owner</code>的实例，否则无法加载，返回该xib内所有view的数组。在lldb中可以验证Controller的view属性就是通过<code>loadNibNamed</code>拿到的view：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p [[[<span class=\"built_in\">NSBundle</span> mainBundle]loadNibNamed:<span class=\"string\">@\"xxxController\"</span> owner:<span class=\"keyword\">self</span> options:<span class=\"literal\">nil</span>] firstObject] == <span class=\"keyword\">self</span>.view</div><div class=\"line\">(<span class=\"keyword\">bool</span>) $<span class=\"number\">1</span> = <span class=\"literal\">true</span></div></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t<span class=\"built_in\">UIView</span> *header = <span class=\"keyword\">self</span>.headerView;</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView setTableHeaderView:header];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载完headerView后，将其设置为UITableView对象的表头视图。<br>也可以在 <strong>(UIView *)tableView:viewForHeaderInSection:</strong>方法中设置，当只有一个section时效果相同。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView viewForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>] lastObject];</div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"tableview的字母索引\"><a href=\"#tableview的字母索引\" class=\"headerlink\" title=\"tableview的字母索引\"></a>tableview的字母索引</h3><p>实现<code>sectionIndexTitlesForTableView</code>方法，返回一个字符串数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class=\"built_in\">UITableView</span> *)tableView&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *indexs = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"我\"</span>];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"是\"</span>];</div><div class=\"line\">    <span class=\"keyword\">return</span> indexs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。</p>\n<h3 id=\"点击cell中button获取所属indexpath\"><a href=\"#点击cell中button获取所属indexpath\" class=\"headerlink\" title=\"点击cell中button获取所属indexpath\"></a>点击cell中button获取所属indexpath</h3><p>button点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[cell.btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(cellBtnClicked:event:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cellBtnClicked:(<span class=\"keyword\">id</span>)sender event:(<span class=\"keyword\">id</span>)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSSet</span> *touches =[event allTouches];</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch =[touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> currentTouchPosition = [touch locationInView:_tableView];</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexPath!= <span class=\"literal\">nil</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>event</code>拿到在tableView中的位置<code>cure</code>，再通过<code>indexPathForRowAtPoint:</code>方法获取<code>NSIndexPath</code>。</p>\n<p>另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//cell.h中的声明</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)buttonPressed :(<span class=\"keyword\">id</span>)；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//cell.m中的实现，设置代理</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.delegate buttonPressed:<span class=\"keyword\">self</span> event:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewcontroller中的实现</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(TableViewCell1 *)cell&#123;</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath2 = [_tableView indexPathForCell:cell];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"所属行数：%ld\"</span>,(<span class=\"keyword\">long</span>)indexPath2.row+<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过设置delegate，将button的点击事件交给viewController完成。</p>\n<h2 id=\"编辑UITableView\"><a href=\"#编辑UITableView\" class=\"headerlink\" title=\"编辑UITableView\"></a>编辑UITableView</h2><h3 id=\"编辑模式下的UITableView\"><a href=\"#编辑模式下的UITableView\" class=\"headerlink\" title=\"编辑模式下的UITableView\"></a>编辑模式下的UITableView</h3><h4 id=\"进入编辑模式\"><a href=\"#进入编辑模式\" class=\"headerlink\" title=\"进入编辑模式\"></a>进入编辑模式</h4><p>通过调用<code>[_tableView setEditing:!_tableView.isEditing animated:true]</code>进入编辑模式,可实现添加，删除，移动操作。<br>默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。</p>\n<h4 id=\"TableView-编辑行\"><a href=\"#TableView-编辑行\" class=\"headerlink\" title=\"TableView 编辑行\"></a>TableView 编辑行</h4><p>使用<strong>setEditing:animated:</strong>方法让tableView进入编辑模式.可以使用<strong>tableView:canEditRowAtIndexPath</strong>方法筛选能进入编辑模式的行：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView canEditRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(indexPath.row == (<span class=\"number\">10</span> | <span class=\"number\">12</span> | <span class=\"number\">14</span>))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果不实现该方法，默认为YES。</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>通过设置<code>UITableViewCellEditingStyle</code>可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的<code>commitEditingStyle:forRowAtIndexPath:</code>方法的入参传入。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UITableViewCellEditingStyle</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑模式下的插入和删除行\"><a href=\"#编辑模式下的插入和删除行\" class=\"headerlink\" title=\"编辑模式下的插入和删除行\"></a>编辑模式下的插入和删除行</h4><p>实现<code>tableView:commitEditingStyle:forRowAtIndexPath:</code>方法。传入三个参数。<br>第一个实参是发送该消息的UITableView对象。<br>第二个实参是<code>UITableViewCellEditingStyle</code>类型的常数(删除表格行时，传入的是<code>UITableViewCellEditingStyleDelete</code>;插入表格行时，传入的是<code>UITableViewCellEditingStyleInsert</code>)。<br>第三个实参是一个NSIndexPath对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView commitEditingStyle:(<span class=\"built_in\">UITableViewCellEditingStyle</span>)editingStyle forRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:indexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.tableView deleteRowsAtIndexPaths:[<span class=\"built_in\">NSArray</span> arrayWithObject:indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>)&#123;</div><div class=\"line\">    \t[<span class=\"keyword\">self</span>.dataSource insertObject:<span class=\"string\">@\"我是新来的\"</span> atIndex:indexPath.row];</div><div class=\"line\">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationBottom</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<code>deleteRowsAtIndexPaths</code>和<code>insertRowsAtIndexPaths</code>可以进行局部刷新，节省资源，并且还能添加指定动画。<br>delete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。</p>\n<h4 id=\"cell的移动\"><a href=\"#cell的移动\" class=\"headerlink\" title=\"cell的移动\"></a>cell的移动</h4><p>进入编辑模式后<br>实现<code>tableView:moveRowAtIndexPath:</code>方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView moveRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)destinationIndexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(sourceIndexPath == destinationIndexPath)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        Comment *comment = [<span class=\"keyword\">self</span>.dataSource objectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource insertObject:comment atIndex:destinationIndexPath.row];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定要对数据源进行正确操作。</p>\n<h4 id=\"TableView-修改删除按钮\"><a href=\"#TableView-修改删除按钮\" class=\"headerlink\" title=\"TableView 修改删除按钮\"></a>TableView 修改删除按钮</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"删除\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"不在编辑模式下的编辑方式\"><a href=\"#不在编辑模式下的编辑方式\" class=\"headerlink\" title=\"不在编辑模式下的编辑方式\"></a>不在编辑模式下的编辑方式</h3><h4 id=\"刷新方式\"><a href=\"#刷新方式\" class=\"headerlink\" title=\"刷新方式\"></a>刷新方式</h4><p>简单总结一些UITableView的刷新方法：</p>\n<ul>\n<li>reloadData                                    刷新整个表格</li>\n<li>reloadRowsAtIndexPaths:withRowAnimation:        刷新indexPath指向的cell</li>\n<li>reloadSections:withRowAnimation:                刷新NSIndexSet内包含的Section</li>\n</ul>\n<p>这三个分别刷新tableview的各个部分<br>第一个没有动画效果。<br>第二个可以传入一个数组<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationTop</span>];</div></pre></td></tr></table></figure></p>\n<p>第三个可以传入一个NSIndexSet集合<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">[_tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndex:indexPath.section]withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationLeft</span>];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入删除\"><a href=\"#插入删除\" class=\"headerlink\" title=\"插入删除\"></a>插入删除</h4><p>在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。</p>\n<ul>\n<li>deleteRowsAtIndexPaths:withRowAnimation:</li>\n<li>insertRowsAtIndexPaths:withRowAnimation:</li>\n</ul>\n<p>就不举例了。同上面一样。</p>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><h3 id=\"当cell未能填满tableview时，怎么响应空白部分点击事件\"><a href=\"#当cell未能填满tableview时，怎么响应空白部分点击事件\" class=\"headerlink\" title=\"当cell未能填满tableview时，怎么响应空白部分点击事件\"></a>当cell未能填满tableview时，怎么响应空白部分点击事件</h3><p>当 tableview 太大，cell 太少，以至于不能填满tableview的时候，那么空白部分的点击事件该怎么设置呢？只要给 tableview 添加一个 footerview，这个 footerview 的大小是整个 tableview 的大小，然后设置这个 footerview 的点击事件即可。</p>\n<p>为什么能这样呢？因为 cell 没有填充满的部分都用 footerview 填充了。</p>"},{"title":"coding 总结","date":"2016-07-31T02:07:12.000Z","_content":"\n记录一些 coding 时候的经验吧。持续更新\n\n<!--more-->\n\n- 应该是哪个类的工作，就将相关的东西放到那个类中，能让思路更清晰。\n- 类之间操作，我可以直接操作那个类，也可以等到一个触发事件后，让那个类问我如何操作。这条要灵活运用。一般来说，等那个类问我要再操作，是个比较好的方法，类似于懒加载，而且如果那种类多的话，不需要我一个个去操作，哪个类要执行了，找我就可以了。但是，这也是有限制的，一个就是必须要有触发条件，那个类能主动找我要操作方法，还有一个是，我必须把要给其他类的东西先存起来，这样才能让别的类读取。\n- 善用代理模式，可以将自身作为代理对象保存在别人delegate属性中，别人要用的时候就能调我的方法。但是要注意及时将那个delegate属性清空，以防自身不能及时被释放。\n- 代码中除了直接操作的数可以用数字，否则如index，tag之类的数**一定不要直接写数字一定不要直接写数字一定不要直接写数字**，可以写个枚举类型。否则一旦一个index变化，那么就要在整个项目里到处找修改和这个index有关的地方。\n","source":"_posts/coding总结.md","raw":"title: coding 总结\ndate: 2016/7/31 10:07:12  \ncategories: iOS\ntags:\n\t- 学习笔记\n\n---\n\n记录一些 coding 时候的经验吧。持续更新\n\n<!--more-->\n\n- 应该是哪个类的工作，就将相关的东西放到那个类中，能让思路更清晰。\n- 类之间操作，我可以直接操作那个类，也可以等到一个触发事件后，让那个类问我如何操作。这条要灵活运用。一般来说，等那个类问我要再操作，是个比较好的方法，类似于懒加载，而且如果那种类多的话，不需要我一个个去操作，哪个类要执行了，找我就可以了。但是，这也是有限制的，一个就是必须要有触发条件，那个类能主动找我要操作方法，还有一个是，我必须把要给其他类的东西先存起来，这样才能让别的类读取。\n- 善用代理模式，可以将自身作为代理对象保存在别人delegate属性中，别人要用的时候就能调我的方法。但是要注意及时将那个delegate属性清空，以防自身不能及时被释放。\n- 代码中除了直接操作的数可以用数字，否则如index，tag之类的数**一定不要直接写数字一定不要直接写数字一定不要直接写数字**，可以写个枚举类型。否则一旦一个index变化，那么就要在整个项目里到处找修改和这个index有关的地方。\n","slug":"coding总结","published":1,"updated":"2016-12-31T11:34:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dq1001p7hzg85mt16ou","content":"<p>记录一些 coding 时候的经验吧。持续更新</p>\n<a id=\"more\"></a>\n<ul>\n<li>应该是哪个类的工作，就将相关的东西放到那个类中，能让思路更清晰。</li>\n<li>类之间操作，我可以直接操作那个类，也可以等到一个触发事件后，让那个类问我如何操作。这条要灵活运用。一般来说，等那个类问我要再操作，是个比较好的方法，类似于懒加载，而且如果那种类多的话，不需要我一个个去操作，哪个类要执行了，找我就可以了。但是，这也是有限制的，一个就是必须要有触发条件，那个类能主动找我要操作方法，还有一个是，我必须把要给其他类的东西先存起来，这样才能让别的类读取。</li>\n<li>善用代理模式，可以将自身作为代理对象保存在别人delegate属性中，别人要用的时候就能调我的方法。但是要注意及时将那个delegate属性清空，以防自身不能及时被释放。</li>\n<li>代码中除了直接操作的数可以用数字，否则如index，tag之类的数<strong>一定不要直接写数字一定不要直接写数字一定不要直接写数字</strong>，可以写个枚举类型。否则一旦一个index变化，那么就要在整个项目里到处找修改和这个index有关的地方。</li>\n</ul>\n","excerpt":"<p>记录一些 coding 时候的经验吧。持续更新</p>","more":"<ul>\n<li>应该是哪个类的工作，就将相关的东西放到那个类中，能让思路更清晰。</li>\n<li>类之间操作，我可以直接操作那个类，也可以等到一个触发事件后，让那个类问我如何操作。这条要灵活运用。一般来说，等那个类问我要再操作，是个比较好的方法，类似于懒加载，而且如果那种类多的话，不需要我一个个去操作，哪个类要执行了，找我就可以了。但是，这也是有限制的，一个就是必须要有触发条件，那个类能主动找我要操作方法，还有一个是，我必须把要给其他类的东西先存起来，这样才能让别的类读取。</li>\n<li>善用代理模式，可以将自身作为代理对象保存在别人delegate属性中，别人要用的时候就能调我的方法。但是要注意及时将那个delegate属性清空，以防自身不能及时被释放。</li>\n<li>代码中除了直接操作的数可以用数字，否则如index，tag之类的数<strong>一定不要直接写数字一定不要直接写数字一定不要直接写数字</strong>，可以写个枚举类型。否则一旦一个index变化，那么就要在整个项目里到处找修改和这个index有关的地方。</li>\n</ul>"},{"title":"tableview自适应高度","date":"2016-08-26T06:07:12.000Z","_content":"\n由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。\n\n<!--more-->\n\n## 设置布局约束\n在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。\n\n记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。\n\n下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：\n\n![布局示例](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true)\n\n可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。\n\n**需要注意的是：**\n1. 如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；\n2. label要显示多行，需要将其`Lines`设置为0。\n3. 题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。\n\n## cell的自适应\n### label的ios8实现\n在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的`rowHeight`属性设置为常量`UITableViewAutomaticDimension`。然后，只需将tableView的`estimatedRowHeight`属性设置为一个非零值即可开启行高估算功能,如：\n```objc\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 设置为一个接近于行高“平均值”的数值\n```\n\n这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算`contentView`的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在`viewDidLoad`或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n### label的ios7实现\n首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作`tableView:cellForRowAtIndexPath:`方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。\n**因为要在`heightForRowAtIndexPath`中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。**\n\n然后，强制cell立即更新子视图的布局，再在cell的`contentView`上调用`systemLayoutSizeFittingSize:`方法以计算出cell所需的高度。使用`UILayoutFittingCompressedSize`参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为`tableView:heightForRowAtIndexPath:`方法的返回值返回给table view。\n\n通过`systemLayoutSizeFittingSize:`方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。\n\niOS7中，你可以（也绝对应当）使用table view的`estimatedRowHeight`属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过`tableView:heightForRowAtIndexPath:`方法），估算的行高会被替换掉。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.label.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGFloat height = textHeight.height+1>90?textHeight.height+1:90;\n    return height;\n}\n```\n\n### textView的自适应\ntextViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用`systemLayoutSizeFittingSize`方法返回的高度并不包含textview的高度，需要调用`sizeThatFits`方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.textView.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGSize textViewSize = [_cell.textView sizeThatFits:CGSizeMake(_cell.textView.frame.size.width, FLT_MAX)];\n    CGFloat h  = textHeight.height + textViewSize.height;\n    CGFloat height = h+1>90?h+1:90;\n    return height;\n}\n```\n\n## UITableView+FDTemplateLayoutCell使用简介\n这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过`systemLayoutSizeFittingSize`方法计算高度，但是该框架通过**缓存**及**预加载**将效率大幅的地提高。\n\n这里就不具体分析该框架的实现原理了。可以参考[框架学习](http://blog.qiji.tech/archives/9538?utm_source=tuicool&utm_medium=referral)跟进。\n\n这里主要列举下使用方法,其实在[forkingdog的github](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)上都有，我这里只是摘录下。\n\n### 基本使用(不带cache)\n```objc\n#import \"UITableView+FDTemplateLayoutCell.h\"\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [tableView fd_heightForCellWithIdentifier:@\"reuse identifer\" configuration:^(id cell) {\n        // Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"\n        // Like:\n        //    cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，`systemLayoutSizeFittingSize:`所必须的。\n\n### 带cache的方法\n#### 以indexPath区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n缓存下每个indexPath对应的高度。\n\n#### 以key区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    Entity *entity = self.entities[indexPath.row];\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByKey:entity.uid configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n用户将要展示的cell分类，然后将分类的key传入。\n\n### Frame layout mode\n对于`Auto layout mode `和`Frame layout mode`。框架提供了两种方式，默认是自动布局。 \n\n### 再次注意\n需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。\n\n","source":"_posts/UITableview自适应高度.md","raw":"title: tableview自适应高度\ndate: 2016/8/26 14:07:12  \ncategories: iOS \ntags: \n\t- UI\n\t\n\n---\n\n由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。\n\n<!--more-->\n\n## 设置布局约束\n在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。\n\n记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。\n\n下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：\n\n![布局示例](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true)\n\n可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。\n\n**需要注意的是：**\n1. 如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；\n2. label要显示多行，需要将其`Lines`设置为0。\n3. 题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。\n\n## cell的自适应\n### label的ios8实现\n在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的`rowHeight`属性设置为常量`UITableViewAutomaticDimension`。然后，只需将tableView的`estimatedRowHeight`属性设置为一个非零值即可开启行高估算功能,如：\n```objc\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 设置为一个接近于行高“平均值”的数值\n```\n\n这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算`contentView`的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在`viewDidLoad`或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n### label的ios7实现\n首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作`tableView:cellForRowAtIndexPath:`方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。\n**因为要在`heightForRowAtIndexPath`中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。**\n\n然后，强制cell立即更新子视图的布局，再在cell的`contentView`上调用`systemLayoutSizeFittingSize:`方法以计算出cell所需的高度。使用`UILayoutFittingCompressedSize`参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为`tableView:heightForRowAtIndexPath:`方法的返回值返回给table view。\n\n通过`systemLayoutSizeFittingSize:`方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。\n\niOS7中，你可以（也绝对应当）使用table view的`estimatedRowHeight`属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过`tableView:heightForRowAtIndexPath:`方法），估算的行高会被替换掉。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.label.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGFloat height = textHeight.height+1>90?textHeight.height+1:90;\n    return height;\n}\n```\n\n### textView的自适应\ntextViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用`systemLayoutSizeFittingSize`方法返回的高度并不包含textview的高度，需要调用`sizeThatFits`方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.textView.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGSize textViewSize = [_cell.textView sizeThatFits:CGSizeMake(_cell.textView.frame.size.width, FLT_MAX)];\n    CGFloat h  = textHeight.height + textViewSize.height;\n    CGFloat height = h+1>90?h+1:90;\n    return height;\n}\n```\n\n## UITableView+FDTemplateLayoutCell使用简介\n这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过`systemLayoutSizeFittingSize`方法计算高度，但是该框架通过**缓存**及**预加载**将效率大幅的地提高。\n\n这里就不具体分析该框架的实现原理了。可以参考[框架学习](http://blog.qiji.tech/archives/9538?utm_source=tuicool&utm_medium=referral)跟进。\n\n这里主要列举下使用方法,其实在[forkingdog的github](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)上都有，我这里只是摘录下。\n\n### 基本使用(不带cache)\n```objc\n#import \"UITableView+FDTemplateLayoutCell.h\"\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [tableView fd_heightForCellWithIdentifier:@\"reuse identifer\" configuration:^(id cell) {\n        // Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"\n        // Like:\n        //    cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，`systemLayoutSizeFittingSize:`所必须的。\n\n### 带cache的方法\n#### 以indexPath区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n缓存下每个indexPath对应的高度。\n\n#### 以key区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    Entity *entity = self.entities[indexPath.row];\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByKey:entity.uid configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n用户将要展示的cell分类，然后将分类的key传入。\n\n### Frame layout mode\n对于`Auto layout mode `和`Frame layout mode`。框架提供了两种方式，默认是自动布局。 \n\n### 再次注意\n需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。\n\n","slug":"UITableview自适应高度","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dq6001s7hzgvl5c6eey","content":"<p>由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。</p>\n<a id=\"more\"></a>\n<h2 id=\"设置布局约束\"><a href=\"#设置布局约束\" class=\"headerlink\" title=\"设置布局约束\"></a>设置布局约束</h2><p>在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。</p>\n<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>\n<p>下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true\" alt=\"布局示例\"></p>\n<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。</p>\n<p><strong>需要注意的是：</strong></p>\n<ol>\n<li>如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；</li>\n<li>label要显示多行，需要将其<code>Lines</code>设置为0。</li>\n<li>题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。</li>\n</ol>\n<h2 id=\"cell的自适应\"><a href=\"#cell的自适应\" class=\"headerlink\" title=\"cell的自适应\"></a>cell的自适应</h2><h3 id=\"label的ios8实现\"><a href=\"#label的ios8实现\" class=\"headerlink\" title=\"label的ios8实现\"></a>label的ios8实现</h3><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能,如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">44.0</span>; <span class=\"comment\">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure></p>\n<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<h3 id=\"label的ios7实现\"><a href=\"#label的ios7实现\" class=\"headerlink\" title=\"label的ios7实现\"></a>label的ios7实现</h3><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。<br><strong>因为要在<code>heightForRowAtIndexPath</code>中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。</strong></p>\n<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>\n<p>通过<code>systemLayoutSizeFittingSize:</code>方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。</p>\n<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<p>这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.label.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = textHeight.height+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?textHeight.height+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"textView的自适应\"><a href=\"#textView的自适应\" class=\"headerlink\" title=\"textView的自适应\"></a>textView的自适应</h3><p>textViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用<code>systemLayoutSizeFittingSize</code>方法返回的高度并不包含textview的高度，需要调用<code>sizeThatFits</code>方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.textView.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textViewSize = [_cell.textView sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(_cell.textView.frame.size.width, FLT_MAX)];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> h  = textHeight.height + textViewSize.height;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = h+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?h+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UITableView-FDTemplateLayoutCell使用简介\"><a href=\"#UITableView-FDTemplateLayoutCell使用简介\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell使用简介\"></a>UITableView+FDTemplateLayoutCell使用简介</h2><p>这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过<code>systemLayoutSizeFittingSize</code>方法计算高度，但是该框架通过<strong>缓存</strong>及<strong>预加载</strong>将效率大幅的地提高。</p>\n<p>这里就不具体分析该框架的实现原理了。可以参考<a href=\"http://blog.qiji.tech/archives/9538?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">框架学习</a>跟进。</p>\n<p>这里主要列举下使用方法,其实在<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"external\">forkingdog的github</a>上都有，我这里只是摘录下。</p>\n<h3 id=\"基本使用-不带cache\"><a href=\"#基本使用-不带cache\" class=\"headerlink\" title=\"基本使用(不带cache)\"></a>基本使用(不带cache)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UITableView+FDTemplateLayoutCell.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"reuse identifer\"</span> configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"</span></div><div class=\"line\">        <span class=\"comment\">// Like:</span></div><div class=\"line\">        <span class=\"comment\">//    cell.entity = self.feedEntities[indexPath.row];</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，<code>systemLayoutSizeFittingSize:</code>所必须的。</p>\n<h3 id=\"带cache的方法\"><a href=\"#带cache的方法\" class=\"headerlink\" title=\"带cache的方法\"></a>带cache的方法</h3><h4 id=\"以indexPath区分\"><a href=\"#以indexPath区分\" class=\"headerlink\" title=\"以indexPath区分\"></a>以indexPath区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>缓存下每个indexPath对应的高度。</p>\n<h4 id=\"以key区分\"><a href=\"#以key区分\" class=\"headerlink\" title=\"以key区分\"></a>以key区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    Entity *entity = <span class=\"keyword\">self</span>.entities[indexPath.row];</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByKey:entity.uid configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用户将要展示的cell分类，然后将分类的key传入。</p>\n<h3 id=\"Frame-layout-mode\"><a href=\"#Frame-layout-mode\" class=\"headerlink\" title=\"Frame layout mode\"></a>Frame layout mode</h3><p>对于<code>Auto layout mode</code>和<code>Frame layout mode</code>。框架提供了两种方式，默认是自动布局。 </p>\n<h3 id=\"再次注意\"><a href=\"#再次注意\" class=\"headerlink\" title=\"再次注意\"></a>再次注意</h3><p>需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。</p>\n","excerpt":"<p>由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。</p>","more":"<h2 id=\"设置布局约束\"><a href=\"#设置布局约束\" class=\"headerlink\" title=\"设置布局约束\"></a>设置布局约束</h2><p>在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。</p>\n<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>\n<p>下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true\" alt=\"布局示例\"></p>\n<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。</p>\n<p><strong>需要注意的是：</strong></p>\n<ol>\n<li>如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；</li>\n<li>label要显示多行，需要将其<code>Lines</code>设置为0。</li>\n<li>题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。</li>\n</ol>\n<h2 id=\"cell的自适应\"><a href=\"#cell的自适应\" class=\"headerlink\" title=\"cell的自适应\"></a>cell的自适应</h2><h3 id=\"label的ios8实现\"><a href=\"#label的ios8实现\" class=\"headerlink\" title=\"label的ios8实现\"></a>label的ios8实现</h3><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能,如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">44.0</span>; <span class=\"comment\">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure></p>\n<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<h3 id=\"label的ios7实现\"><a href=\"#label的ios7实现\" class=\"headerlink\" title=\"label的ios7实现\"></a>label的ios7实现</h3><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。<br><strong>因为要在<code>heightForRowAtIndexPath</code>中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。</strong></p>\n<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>\n<p>通过<code>systemLayoutSizeFittingSize:</code>方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。</p>\n<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<p>这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.label.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = textHeight.height+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?textHeight.height+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"textView的自适应\"><a href=\"#textView的自适应\" class=\"headerlink\" title=\"textView的自适应\"></a>textView的自适应</h3><p>textViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用<code>systemLayoutSizeFittingSize</code>方法返回的高度并不包含textview的高度，需要调用<code>sizeThatFits</code>方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.textView.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textViewSize = [_cell.textView sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(_cell.textView.frame.size.width, FLT_MAX)];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> h  = textHeight.height + textViewSize.height;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = h+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?h+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UITableView-FDTemplateLayoutCell使用简介\"><a href=\"#UITableView-FDTemplateLayoutCell使用简介\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell使用简介\"></a>UITableView+FDTemplateLayoutCell使用简介</h2><p>这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过<code>systemLayoutSizeFittingSize</code>方法计算高度，但是该框架通过<strong>缓存</strong>及<strong>预加载</strong>将效率大幅的地提高。</p>\n<p>这里就不具体分析该框架的实现原理了。可以参考<a href=\"http://blog.qiji.tech/archives/9538?utm_source=tuicool&amp;utm_medium=referral\">框架学习</a>跟进。</p>\n<p>这里主要列举下使用方法,其实在<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\">forkingdog的github</a>上都有，我这里只是摘录下。</p>\n<h3 id=\"基本使用-不带cache\"><a href=\"#基本使用-不带cache\" class=\"headerlink\" title=\"基本使用(不带cache)\"></a>基本使用(不带cache)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UITableView+FDTemplateLayoutCell.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"reuse identifer\"</span> configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"</span></div><div class=\"line\">        <span class=\"comment\">// Like:</span></div><div class=\"line\">        <span class=\"comment\">//    cell.entity = self.feedEntities[indexPath.row];</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，<code>systemLayoutSizeFittingSize:</code>所必须的。</p>\n<h3 id=\"带cache的方法\"><a href=\"#带cache的方法\" class=\"headerlink\" title=\"带cache的方法\"></a>带cache的方法</h3><h4 id=\"以indexPath区分\"><a href=\"#以indexPath区分\" class=\"headerlink\" title=\"以indexPath区分\"></a>以indexPath区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>缓存下每个indexPath对应的高度。</p>\n<h4 id=\"以key区分\"><a href=\"#以key区分\" class=\"headerlink\" title=\"以key区分\"></a>以key区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    Entity *entity = <span class=\"keyword\">self</span>.entities[indexPath.row];</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByKey:entity.uid configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用户将要展示的cell分类，然后将分类的key传入。</p>\n<h3 id=\"Frame-layout-mode\"><a href=\"#Frame-layout-mode\" class=\"headerlink\" title=\"Frame layout mode\"></a>Frame layout mode</h3><p>对于<code>Auto layout mode</code>和<code>Frame layout mode</code>。框架提供了两种方式，默认是自动布局。 </p>\n<h3 id=\"再次注意\"><a href=\"#再次注意\" class=\"headerlink\" title=\"再次注意\"></a>再次注意</h3><p>需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。</p>"},{"title":"UIGestureRecognizer","date":"2016-09-05T06:07:12.000Z","_content":"\n在iOS系统中，手势是进行用户交互的重要方式，通过`UIGestureRecognizer`类，我们可以轻松的创建出各种手势应用于app中。关于`UIGestureRecognizer`类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。\n\n<!--more-->\n\n## 手势的抽象类——UIGestureRecognizer\n`UIGestureRecognizer`将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用`UIGestureRecognizer`的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，`UIGestureRecognizer`中抽象出了哪些方法。\n\n### 初始化方法\n`UIGestureRecognizer`类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：\n```objc\n- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action;\n```\n如果我们使用`alloc-init`的方式，也是可以的，下面的方法可以为手势添加触发的`selector`：\n```objc\n- (void)addTarget:(id)target action:(SEL)action;\n```\n与之相对应的，我们也可以将一个`selector`从其手势对象上移除：\n```objc\n- (void)removeTarget:(nullable id)target action:(nullable SEL)action;\n```\n这里的`target`一般都是`self`,因为`selector`一般都是在`self`中定义。\n\n因为`addTarget`方式的存在，iOS系统允许一个手势对象可以添加多个`selector`触发方法，并且触发的时候，所有添加的`selector`都会被执行，我们以点击手势示例如下:\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];\n    [ges addTarget:self action:@selector(haha)];\n     [self.view addGestureRecognizer:ges];\n}\n-(void)click:(UIGestureRecognizer *)ges{\n    \n    NSLog(@\"第一个手势的触发方法\");\n    \n}\n-(void)haha{\n    NSLog(@\"haha\");\n}\n```\n点击屏幕后，两个方法都会触发。\n\n### 手势状态\nUIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:\n```objc\n@property(nonatomic,readonly) UIGestureRecognizerState state;\n```\n枚举值如下：\n```objc\ntypedef NS_ENUM(NSInteger, UIGestureRecognizerState) {\n    UIGestureRecognizerStatePossible,   // 默认的状态，这个时候的手势并没有具体的情形状态\n    UIGestureRecognizerStateBegan,      // 手势开始被识别的状态\n    UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态\n    UIGestureRecognizerStateEnded,      // 手势识别结束，将会执行触发的方法\n    UIGestureRecognizerStateCancelled,  // 手势识别取消\n    UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用\n    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded \n};\n```\n可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。\n\n### 常用属性和方法\n```objc\n//设置代理，具体的协议后面会说\n@property(nullable,nonatomic,weak) id <UIGestureRecognizerDelegate> delegate; \n//设置手势是否有效\n@property(nonatomic, getter=isEnabled) BOOL enabled;\n//获取手势所在的view\n@property(nullable, nonatomic,readonly) UIView *view; \n//获取触发触摸的点\n- (CGPoint)locationInView:(nullable UIView*)view; \n//设置触摸点数\n- (NSUInteger)numberOfTouches; \n//获取某一个触摸点的触摸位置\n- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view;\n```\n其中，`UITouch`也有一个方法是`locationInView:`可以获取触摸点在view中的位置。\n可以通过设置`numberOfTapsRequired`来区分单击双击：\n```objc\nUITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(DoubleTap:)];\ndoubleTap.numberOfTapsRequired = 2; //点击的次数 ＝2 双击\n[_imageView addGestureRecognizer:doubleTap];//给对象添加一个手势监测；\n```\n\n另外还有三个属性用来控制触摸事件：\n```objc\n@property(nonatomic) BOOL cancelsTouchesInView;\n@property(nonatomic) BOOL delaysTouchesBegan;\n@property(nonatomic) BOOL delaysTouchesEnded;\n```\n\n**cancelsTouchesInView**\n默认为YES,这种情况下当手势识别器识别到touch之后，会发送`touchesCancelled:withEvent:`消息,终止触摸事件的传递,以取消 `UIResponder`对touch的响应，这个时候只有手势识别器响应touch。\n当设置成NO时，手势识别器识别到touch之后不会发送`touchesCancelled:withEvent:`消息，这个时候手势识别器和`UIResponder`均响应touch。\n**注意：**发送`touchesCancelled:withEvent:`消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后`touchesCancelled:withEvent:`消息才会生效，屏蔽touch操作。\n\n**delaysTouchesBegan**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给`UIResponder`，两者各自做出响应。\n如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给`UIResponder`，即`UIResponder`不会有任何触摸事件。只有在识别失败之后才会将touch发给`UIResponder`，这种情况下`UIResponder`的响应会延迟约0.15ms。\n\n**delaysTouchesEnded**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给`touchesCancelled:withEvent:`消息给`UIResponder`，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送`touchesEnded:withEvent:`。\n如果设置为NO，则不会延迟，即会立即发送`touchesEnded:withEvent:`以结束当前触摸。\n\n### 手势间的互斥\n有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];;\n    \n    //view.backgroundColor = [UIColor redColor];\n   \n    //ges.delegate=self;\n    [self.view addGestureRecognizer:ges];\n    \n    UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];\n//    ges2.delegate=self;\n        [self.view addGestureRecognizer:ges2];\n}\n\n\n-(void)click:(UIGestureRecognizer *)ges{\n    NSLog(@\"第一个手势的触发方法\");\n}\n-(void)click1:(UIGestureRecognizer *)ges1{\n    NSLog(@\"第二个手势的触发方法\");   \n}\n```\n\n我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：\n```objc\n[ges requireGestureRecognizerToFail:ges2];\n```\n表示如果`ges2`匹配，那么不会执行`ges`。只有当`ges2`不匹配的时候，才会执行`ges`。\n\n### UIGestureRecognizerDelegate\n前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：\n```objc\n//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;\n//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;\n//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;\n//下面这个两个方法也是用来控制手势的互斥执行的\n//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n//这个方法返回YES，第一个和第二个互斥时，第二个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n```\n最下面两个方法用起来还挺麻烦的，因为你不知道哪个是`gestureRecognizer`哪个是`otherGestureRecognizer`,因此，只能笼统的设置。\n\n\n### 手势和触摸的区别\n前一篇我们学习了`UITouch`,可以通过重写`UIResponder`的几个`touch`方法来处理触摸事件。\n`UIGestureRecognizer`和触摸事件是两个独立的事,手势和`UITouch`本身关系不大。不过手势可以通过`cancelsTouchesInView`,`delaysTouchesBegan`,`delaysTouchesEnded`这三个属性来影响触摸事件。\n\n## UIGestureRecognizer的子类\n### 点击手势——UITapGestureRecognizer\n点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：\n```objc\n//设置点击次数，默认为单击\n@property (nonatomic) NSUInteger  numberOfTapsRequired; \n//设置同时点击的手指数\n@property (nonatomic) NSUInteger  numberOfTouchesRequired;\n```\n\n### 捏合手势——UIPinchGestureRecognizer\n捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：\n```objc\n//设置缩放比例\n@property (nonatomic)          CGFloat scale; \n//设置捏合速度\n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完缩放后，一定要把`recognizer.scale`设置为1\n```objc\n- (void)handlePinch:(UIPinchGestureRecognizer*)recognizer{\n    NSLog(@\"缩放操作\");//处理缩放操作\n    //对imageview缩放\n    _imageView.transform = CGAffineTransformScale(_imageView.transform, recognizer.scale, recognizer.scale);\n    recognizer.scale = 1;\n}\n```\n\n### 拖拽手势——UIPanGestureRecognzer\n当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。\n```objc\n//设置触发拖拽的最少触摸点，默认为1\n@property (nonatomic)          NSUInteger minimumNumberOfTouches; \n//设置触发拖拽的最多触摸点\n@property (nonatomic)          NSUInteger maximumNumberOfTouches;  \n//获取当前位置\n- (CGPoint)translationInView:(nullable UIView *)view;            \n//设置当前位置\n- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;\n//设置拖拽速度\n- (CGPoint)velocityInView:(nullable UIView *)view;\n```\n代码示例：\n```objc\n-(void)handlePan:(UIPanGestureRecognizer*)recognizer{\n    NSLog(@\"拖动操作\");\n    //处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右\n    CGPoint translation = [recognizer translationInView:_imageView];\n    recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x,\n                                         recognizer.view.center.y + translation.y);\n    [recognizer setTranslation:CGPointZero inView:_imageView];\n}\n```\n必须使用`setTranslation`设置为`CGPointZero`,不知道为什么\n\n### 滑动手势——UISwipeGestureRecognizer\n滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢\n```objc\n//设置触发滑动手势的触摸点数\n@property(nonatomic) NSUInteger                        numberOfTouchesRequired; \n//设置滑动方向\n@property(nonatomic) UISwipeGestureRecognizerDirection direction;  \n//枚举如下\ntypedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) {\n    UISwipeGestureRecognizerDirectionRight = 1 << 0,\n    UISwipeGestureRecognizerDirectionLeft  = 1 << 1,\n    UISwipeGestureRecognizerDirectionUp    = 1 << 2,\n    UISwipeGestureRecognizerDirectionDown  = 1 << 3\n};\n```\n\n### 旋转手势——UIRotationGestureRecognizer\n进行旋转动作时触发手势方法\n```objc\n//设置旋转角度\n@property (nonatomic)          CGFloat rotation;\n//设置旋转速度 \n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完旋转后，`recognizer.rotation`一定要清零.\n```objc\n- (void)handleRotate:(UIRotationGestureRecognizer*) recognizer{\n    NSLog(@\"旋转操作\");//处理旋转操作\n    //对imageview旋转\n    _imageView.transform = CGAffineTransformRotate(_imageView.transform, recognizer.rotation);\n    recognizer.rotation = 0;    //一定要清零\n}\n```\n\n### 长按手势——UILongPressGestureRecognizer\n进行长按的时候触发的手势方法\n```objc\n//设置触发前的点击次数\n@property (nonatomic) NSUInteger numberOfTapsRequired;    \n//设置触发的触摸点数\n@property (nonatomic) NSUInteger numberOfTouchesRequired; \n//设置最短的长按时间\n@property (nonatomic) CFTimeInterval minimumPressDuration; \n//设置在按触时时允许移动的最大距离 默认为10像素\n@property (nonatomic) CGFloat allowableMovement;\n```\n\n### 手势组合的问题\n这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：\n![手势组合](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true)\n当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。\n\n> Demo 详见UIGestureRecognizer","source":"_posts/UIGestureRecognizer.md","raw":"title: UIGestureRecognizer\ndate: 2016/9/5 14:07:12  \ncategories: iOS\ntags: \n\t- UIGesture\n\t\n---\n\n在iOS系统中，手势是进行用户交互的重要方式，通过`UIGestureRecognizer`类，我们可以轻松的创建出各种手势应用于app中。关于`UIGestureRecognizer`类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。\n\n<!--more-->\n\n## 手势的抽象类——UIGestureRecognizer\n`UIGestureRecognizer`将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用`UIGestureRecognizer`的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，`UIGestureRecognizer`中抽象出了哪些方法。\n\n### 初始化方法\n`UIGestureRecognizer`类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：\n```objc\n- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action;\n```\n如果我们使用`alloc-init`的方式，也是可以的，下面的方法可以为手势添加触发的`selector`：\n```objc\n- (void)addTarget:(id)target action:(SEL)action;\n```\n与之相对应的，我们也可以将一个`selector`从其手势对象上移除：\n```objc\n- (void)removeTarget:(nullable id)target action:(nullable SEL)action;\n```\n这里的`target`一般都是`self`,因为`selector`一般都是在`self`中定义。\n\n因为`addTarget`方式的存在，iOS系统允许一个手势对象可以添加多个`selector`触发方法，并且触发的时候，所有添加的`selector`都会被执行，我们以点击手势示例如下:\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];\n    [ges addTarget:self action:@selector(haha)];\n     [self.view addGestureRecognizer:ges];\n}\n-(void)click:(UIGestureRecognizer *)ges{\n    \n    NSLog(@\"第一个手势的触发方法\");\n    \n}\n-(void)haha{\n    NSLog(@\"haha\");\n}\n```\n点击屏幕后，两个方法都会触发。\n\n### 手势状态\nUIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:\n```objc\n@property(nonatomic,readonly) UIGestureRecognizerState state;\n```\n枚举值如下：\n```objc\ntypedef NS_ENUM(NSInteger, UIGestureRecognizerState) {\n    UIGestureRecognizerStatePossible,   // 默认的状态，这个时候的手势并没有具体的情形状态\n    UIGestureRecognizerStateBegan,      // 手势开始被识别的状态\n    UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态\n    UIGestureRecognizerStateEnded,      // 手势识别结束，将会执行触发的方法\n    UIGestureRecognizerStateCancelled,  // 手势识别取消\n    UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用\n    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded \n};\n```\n可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。\n\n### 常用属性和方法\n```objc\n//设置代理，具体的协议后面会说\n@property(nullable,nonatomic,weak) id <UIGestureRecognizerDelegate> delegate; \n//设置手势是否有效\n@property(nonatomic, getter=isEnabled) BOOL enabled;\n//获取手势所在的view\n@property(nullable, nonatomic,readonly) UIView *view; \n//获取触发触摸的点\n- (CGPoint)locationInView:(nullable UIView*)view; \n//设置触摸点数\n- (NSUInteger)numberOfTouches; \n//获取某一个触摸点的触摸位置\n- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view;\n```\n其中，`UITouch`也有一个方法是`locationInView:`可以获取触摸点在view中的位置。\n可以通过设置`numberOfTapsRequired`来区分单击双击：\n```objc\nUITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(DoubleTap:)];\ndoubleTap.numberOfTapsRequired = 2; //点击的次数 ＝2 双击\n[_imageView addGestureRecognizer:doubleTap];//给对象添加一个手势监测；\n```\n\n另外还有三个属性用来控制触摸事件：\n```objc\n@property(nonatomic) BOOL cancelsTouchesInView;\n@property(nonatomic) BOOL delaysTouchesBegan;\n@property(nonatomic) BOOL delaysTouchesEnded;\n```\n\n**cancelsTouchesInView**\n默认为YES,这种情况下当手势识别器识别到touch之后，会发送`touchesCancelled:withEvent:`消息,终止触摸事件的传递,以取消 `UIResponder`对touch的响应，这个时候只有手势识别器响应touch。\n当设置成NO时，手势识别器识别到touch之后不会发送`touchesCancelled:withEvent:`消息，这个时候手势识别器和`UIResponder`均响应touch。\n**注意：**发送`touchesCancelled:withEvent:`消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后`touchesCancelled:withEvent:`消息才会生效，屏蔽touch操作。\n\n**delaysTouchesBegan**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给`UIResponder`，两者各自做出响应。\n如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给`UIResponder`，即`UIResponder`不会有任何触摸事件。只有在识别失败之后才会将touch发给`UIResponder`，这种情况下`UIResponder`的响应会延迟约0.15ms。\n\n**delaysTouchesEnded**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给`touchesCancelled:withEvent:`消息给`UIResponder`，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送`touchesEnded:withEvent:`。\n如果设置为NO，则不会延迟，即会立即发送`touchesEnded:withEvent:`以结束当前触摸。\n\n### 手势间的互斥\n有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];;\n    \n    //view.backgroundColor = [UIColor redColor];\n   \n    //ges.delegate=self;\n    [self.view addGestureRecognizer:ges];\n    \n    UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];\n//    ges2.delegate=self;\n        [self.view addGestureRecognizer:ges2];\n}\n\n\n-(void)click:(UIGestureRecognizer *)ges{\n    NSLog(@\"第一个手势的触发方法\");\n}\n-(void)click1:(UIGestureRecognizer *)ges1{\n    NSLog(@\"第二个手势的触发方法\");   \n}\n```\n\n我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：\n```objc\n[ges requireGestureRecognizerToFail:ges2];\n```\n表示如果`ges2`匹配，那么不会执行`ges`。只有当`ges2`不匹配的时候，才会执行`ges`。\n\n### UIGestureRecognizerDelegate\n前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：\n```objc\n//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;\n//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;\n//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;\n//下面这个两个方法也是用来控制手势的互斥执行的\n//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n//这个方法返回YES，第一个和第二个互斥时，第二个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n```\n最下面两个方法用起来还挺麻烦的，因为你不知道哪个是`gestureRecognizer`哪个是`otherGestureRecognizer`,因此，只能笼统的设置。\n\n\n### 手势和触摸的区别\n前一篇我们学习了`UITouch`,可以通过重写`UIResponder`的几个`touch`方法来处理触摸事件。\n`UIGestureRecognizer`和触摸事件是两个独立的事,手势和`UITouch`本身关系不大。不过手势可以通过`cancelsTouchesInView`,`delaysTouchesBegan`,`delaysTouchesEnded`这三个属性来影响触摸事件。\n\n## UIGestureRecognizer的子类\n### 点击手势——UITapGestureRecognizer\n点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：\n```objc\n//设置点击次数，默认为单击\n@property (nonatomic) NSUInteger  numberOfTapsRequired; \n//设置同时点击的手指数\n@property (nonatomic) NSUInteger  numberOfTouchesRequired;\n```\n\n### 捏合手势——UIPinchGestureRecognizer\n捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：\n```objc\n//设置缩放比例\n@property (nonatomic)          CGFloat scale; \n//设置捏合速度\n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完缩放后，一定要把`recognizer.scale`设置为1\n```objc\n- (void)handlePinch:(UIPinchGestureRecognizer*)recognizer{\n    NSLog(@\"缩放操作\");//处理缩放操作\n    //对imageview缩放\n    _imageView.transform = CGAffineTransformScale(_imageView.transform, recognizer.scale, recognizer.scale);\n    recognizer.scale = 1;\n}\n```\n\n### 拖拽手势——UIPanGestureRecognzer\n当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。\n```objc\n//设置触发拖拽的最少触摸点，默认为1\n@property (nonatomic)          NSUInteger minimumNumberOfTouches; \n//设置触发拖拽的最多触摸点\n@property (nonatomic)          NSUInteger maximumNumberOfTouches;  \n//获取当前位置\n- (CGPoint)translationInView:(nullable UIView *)view;            \n//设置当前位置\n- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;\n//设置拖拽速度\n- (CGPoint)velocityInView:(nullable UIView *)view;\n```\n代码示例：\n```objc\n-(void)handlePan:(UIPanGestureRecognizer*)recognizer{\n    NSLog(@\"拖动操作\");\n    //处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右\n    CGPoint translation = [recognizer translationInView:_imageView];\n    recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x,\n                                         recognizer.view.center.y + translation.y);\n    [recognizer setTranslation:CGPointZero inView:_imageView];\n}\n```\n必须使用`setTranslation`设置为`CGPointZero`,不知道为什么\n\n### 滑动手势——UISwipeGestureRecognizer\n滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢\n```objc\n//设置触发滑动手势的触摸点数\n@property(nonatomic) NSUInteger                        numberOfTouchesRequired; \n//设置滑动方向\n@property(nonatomic) UISwipeGestureRecognizerDirection direction;  \n//枚举如下\ntypedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) {\n    UISwipeGestureRecognizerDirectionRight = 1 << 0,\n    UISwipeGestureRecognizerDirectionLeft  = 1 << 1,\n    UISwipeGestureRecognizerDirectionUp    = 1 << 2,\n    UISwipeGestureRecognizerDirectionDown  = 1 << 3\n};\n```\n\n### 旋转手势——UIRotationGestureRecognizer\n进行旋转动作时触发手势方法\n```objc\n//设置旋转角度\n@property (nonatomic)          CGFloat rotation;\n//设置旋转速度 \n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完旋转后，`recognizer.rotation`一定要清零.\n```objc\n- (void)handleRotate:(UIRotationGestureRecognizer*) recognizer{\n    NSLog(@\"旋转操作\");//处理旋转操作\n    //对imageview旋转\n    _imageView.transform = CGAffineTransformRotate(_imageView.transform, recognizer.rotation);\n    recognizer.rotation = 0;    //一定要清零\n}\n```\n\n### 长按手势——UILongPressGestureRecognizer\n进行长按的时候触发的手势方法\n```objc\n//设置触发前的点击次数\n@property (nonatomic) NSUInteger numberOfTapsRequired;    \n//设置触发的触摸点数\n@property (nonatomic) NSUInteger numberOfTouchesRequired; \n//设置最短的长按时间\n@property (nonatomic) CFTimeInterval minimumPressDuration; \n//设置在按触时时允许移动的最大距离 默认为10像素\n@property (nonatomic) CGFloat allowableMovement;\n```\n\n### 手势组合的问题\n这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：\n![手势组合](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true)\n当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。\n\n> Demo 详见UIGestureRecognizer","slug":"UIGestureRecognizer","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dq8001w7hzghkvdbezo","content":"<p>在iOS系统中，手势是进行用户交互的重要方式，通过<code>UIGestureRecognizer</code>类，我们可以轻松的创建出各种手势应用于app中。关于<code>UIGestureRecognizer</code>类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。</p>\n<a id=\"more\"></a>\n<h2 id=\"手势的抽象类——UIGestureRecognizer\"><a href=\"#手势的抽象类——UIGestureRecognizer\" class=\"headerlink\" title=\"手势的抽象类——UIGestureRecognizer\"></a>手势的抽象类——UIGestureRecognizer</h2><p><code>UIGestureRecognizer</code>将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用<code>UIGestureRecognizer</code>的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，<code>UIGestureRecognizer</code>中抽象出了哪些方法。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p><code>UIGestureRecognizer</code>类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>如果我们使用<code>alloc-init</code>的方式，也是可以的，下面的方法可以为手势添加触发的<code>selector</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action;</div></pre></td></tr></table></figure></p>\n<p>与之相对应的，我们也可以将一个<code>selector</code>从其手势对象上移除：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>target</code>一般都是<code>self</code>,因为<code>selector</code>一般都是在<code>self</code>中定义。</p>\n<p>因为<code>addTarget</code>方式的存在，iOS系统允许一个手势对象可以添加多个<code>selector</code>触发方法，并且触发的时候，所有添加的<code>selector</code>都会被执行，我们以点击手势示例如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];</div><div class=\"line\">    [ges addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(haha)];</div><div class=\"line\">     [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)haha&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>点击屏幕后，两个方法都会触发。</p>\n<h3 id=\"手势状态\"><a href=\"#手势状态\" class=\"headerlink\" title=\"手势状态\"></a>手势状态</h3><p>UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIGestureRecognizerState</span> state;</div></pre></td></tr></table></figure></p>\n<p>枚举值如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIGestureRecognizerState</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStatePossible</span>,   <span class=\"comment\">// 默认的状态，这个时候的手势并没有具体的情形状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateBegan</span>,      <span class=\"comment\">// 手势开始被识别的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateChanged</span>,    <span class=\"comment\">// 手势识别发生改变的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateEnded</span>,      <span class=\"comment\">// 手势识别结束，将会执行触发的方法</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateCancelled</span>,  <span class=\"comment\">// 手势识别取消</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateFailed</span>,     <span class=\"comment\">// 识别失败，方法将不会被调用</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateRecognized</span> = <span class=\"built_in\">UIGestureRecognizerStateEnded</span> </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。</p>\n<h3 id=\"常用属性和方法\"><a href=\"#常用属性和方法\" class=\"headerlink\" title=\"常用属性和方法\"></a>常用属性和方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置代理，具体的协议后面会说</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class=\"line\"><span class=\"comment\">//设置手势是否有效</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isEnabled) <span class=\"built_in\">BOOL</span> enabled;</div><div class=\"line\"><span class=\"comment\">//获取手势所在的view</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIView</span> *view; </div><div class=\"line\"><span class=\"comment\">//获取触发触摸的点</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view; </div><div class=\"line\"><span class=\"comment\">//设置触摸点数</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfTouches; </div><div class=\"line\"><span class=\"comment\">//获取某一个触摸点的触摸位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationOfTouch:(<span class=\"built_in\">NSUInteger</span>)touchIndex inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view;</div></pre></td></tr></table></figure>\n<p>其中，<code>UITouch</code>也有一个方法是<code>locationInView:</code>可以获取触摸点在view中的位置。<br>可以通过设置<code>numberOfTapsRequired</code>来区分单击双击：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITapGestureRecognizer</span> *doubleTap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(DoubleTap:)];</div><div class=\"line\">doubleTap.numberOfTapsRequired = <span class=\"number\">2</span>; <span class=\"comment\">//点击的次数 ＝2 双击</span></div><div class=\"line\">[_imageView addGestureRecognizer:doubleTap];<span class=\"comment\">//给对象添加一个手势监测；</span></div></pre></td></tr></table></figure></p>\n<p>另外还有三个属性用来控制触摸事件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> cancelsTouchesInView;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesBegan;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesEnded;</div></pre></td></tr></table></figure></p>\n<p><strong>cancelsTouchesInView</strong><br>默认为YES,这种情况下当手势识别器识别到touch之后，会发送<code>touchesCancelled:withEvent:</code>消息,终止触摸事件的传递,以取消 <code>UIResponder</code>对touch的响应，这个时候只有手势识别器响应touch。<br>当设置成NO时，手势识别器识别到touch之后不会发送<code>touchesCancelled:withEvent:</code>消息，这个时候手势识别器和<code>UIResponder</code>均响应touch。<br><strong>注意：</strong>发送<code>touchesCancelled:withEvent:</code>消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后<code>touchesCancelled:withEvent:</code>消息才会生效，屏蔽touch操作。</p>\n<p><strong>delaysTouchesBegan</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给<code>UIResponder</code>，两者各自做出响应。<br>如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给<code>UIResponder</code>，即<code>UIResponder</code>不会有任何触摸事件。只有在识别失败之后才会将touch发给<code>UIResponder</code>，这种情况下<code>UIResponder</code>的响应会延迟约0.15ms。</p>\n<p><strong>delaysTouchesEnded</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给<code>touchesCancelled:withEvent:</code>消息给<code>UIResponder</code>，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送<code>touchesEnded:withEvent:</code>。<br>如果设置为NO，则不会延迟，即会立即发送<code>touchesEnded:withEvent:</code>以结束当前触摸。</p>\n<h3 id=\"手势间的互斥\"><a href=\"#手势间的互斥\" class=\"headerlink\" title=\"手势间的互斥\"></a>手势间的互斥</h3><p>有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//view.backgroundColor = [UIColor redColor];</span></div><div class=\"line\">   </div><div class=\"line\">    <span class=\"comment\">//ges.delegate=self;</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> * ges2 = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click1:)];</div><div class=\"line\"><span class=\"comment\">//    ges2.delegate=self;</span></div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click1:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges1&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二个手势的触发方法\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ges requireGestureRecognizerToFail:ges2];</div></pre></td></tr></table></figure></p>\n<p>表示如果<code>ges2</code>匹配，那么不会执行<code>ges</code>。只有当<code>ges2</code>不匹配的时候，才会执行<code>ges</code>。</p>\n<h3 id=\"UIGestureRecognizerDelegate\"><a href=\"#UIGestureRecognizerDelegate\" class=\"headerlink\" title=\"UIGestureRecognizerDelegate\"></a>UIGestureRecognizerDelegate</h3><p>前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class=\"built_in\">UITouch</span> *)touch;</div><div class=\"line\"><span class=\"comment\">//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizerShouldBegin:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//下面这个两个方法也是用来控制手势的互斥执行的</span></div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个和第二个互斥时，第二个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div></pre></td></tr></table></figure></p>\n<p>最下面两个方法用起来还挺麻烦的，因为你不知道哪个是<code>gestureRecognizer</code>哪个是<code>otherGestureRecognizer</code>,因此，只能笼统的设置。</p>\n<h3 id=\"手势和触摸的区别\"><a href=\"#手势和触摸的区别\" class=\"headerlink\" title=\"手势和触摸的区别\"></a>手势和触摸的区别</h3><p>前一篇我们学习了<code>UITouch</code>,可以通过重写<code>UIResponder</code>的几个<code>touch</code>方法来处理触摸事件。<br><code>UIGestureRecognizer</code>和触摸事件是两个独立的事,手势和<code>UITouch</code>本身关系不大。不过手势可以通过<code>cancelsTouchesInView</code>,<code>delaysTouchesBegan</code>,<code>delaysTouchesEnded</code>这三个属性来影响触摸事件。</p>\n<h2 id=\"UIGestureRecognizer的子类\"><a href=\"#UIGestureRecognizer的子类\" class=\"headerlink\" title=\"UIGestureRecognizer的子类\"></a>UIGestureRecognizer的子类</h2><h3 id=\"点击手势——UITapGestureRecognizer\"><a href=\"#点击手势——UITapGestureRecognizer\" class=\"headerlink\" title=\"点击手势——UITapGestureRecognizer\"></a>点击手势——UITapGestureRecognizer</h3><p>点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置点击次数，默认为单击</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTapsRequired; </div><div class=\"line\"><span class=\"comment\">//设置同时点击的手指数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTouchesRequired;</div></pre></td></tr></table></figure></p>\n<h3 id=\"捏合手势——UIPinchGestureRecognizer\"><a href=\"#捏合手势——UIPinchGestureRecognizer\" class=\"headerlink\" title=\"捏合手势——UIPinchGestureRecognizer\"></a>捏合手势——UIPinchGestureRecognizer</h3><p>捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置缩放比例</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> scale; </div><div class=\"line\"><span class=\"comment\">//设置捏合速度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完缩放后，一定要把<code>recognizer.scale</code>设置为1<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handlePinch:(<span class=\"built_in\">UIPinchGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"缩放操作\"</span>);<span class=\"comment\">//处理缩放操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview缩放</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformScale</span>(_imageView.transform, recognizer.scale, recognizer.scale);</div><div class=\"line\">    recognizer.scale = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"拖拽手势——UIPanGestureRecognzer\"><a href=\"#拖拽手势——UIPanGestureRecognzer\" class=\"headerlink\" title=\"拖拽手势——UIPanGestureRecognzer\"></a>拖拽手势——UIPanGestureRecognzer</h3><p>当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最少触摸点，默认为1</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> minimumNumberOfTouches; </div><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最多触摸点</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> maximumNumberOfTouches;  </div><div class=\"line\"><span class=\"comment\">//获取当前位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)translationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;            </div><div class=\"line\"><span class=\"comment\">//设置当前位置</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setTranslation:(<span class=\"built_in\">CGPoint</span>)translation inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">//设置拖拽速度</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)velocityInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div></pre></td></tr></table></figure></p>\n<p>代码示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"拖动操作\"</span>);</div><div class=\"line\">    <span class=\"comment\">//处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右</span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> translation = [recognizer translationInView:_imageView];</div><div class=\"line\">    recognizer.view.center = <span class=\"built_in\">CGPointMake</span>(recognizer.view.center.x + translation.x,</div><div class=\"line\">                                         recognizer.view.center.y + translation.y);</div><div class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:_imageView];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>必须使用<code>setTranslation</code>设置为<code>CGPointZero</code>,不知道为什么</p>\n<h3 id=\"滑动手势——UISwipeGestureRecognizer\"><a href=\"#滑动手势——UISwipeGestureRecognizer\" class=\"headerlink\" title=\"滑动手势——UISwipeGestureRecognizer\"></a>滑动手势——UISwipeGestureRecognizer</h3><p>滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发滑动手势的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>                        numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置滑动方向</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UISwipeGestureRecognizerDirection</span> direction;  </div><div class=\"line\"><span class=\"comment\">//枚举如下</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionRight</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionLeft</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionUp</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionDown</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"旋转手势——UIRotationGestureRecognizer\"><a href=\"#旋转手势——UIRotationGestureRecognizer\" class=\"headerlink\" title=\"旋转手势——UIRotationGestureRecognizer\"></a>旋转手势——UIRotationGestureRecognizer</h3><p>进行旋转动作时触发手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置旋转角度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> rotation;</div><div class=\"line\"><span class=\"comment\">//设置旋转速度 </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完旋转后，<code>recognizer.rotation</code>一定要清零.<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handleRotate:(<span class=\"built_in\">UIRotationGestureRecognizer</span>*) recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"旋转操作\"</span>);<span class=\"comment\">//处理旋转操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview旋转</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformRotate</span>(_imageView.transform, recognizer.rotation);</div><div class=\"line\">    recognizer.rotation = <span class=\"number\">0</span>;    <span class=\"comment\">//一定要清零</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"长按手势——UILongPressGestureRecognizer\"><a href=\"#长按手势——UILongPressGestureRecognizer\" class=\"headerlink\" title=\"长按手势——UILongPressGestureRecognizer\"></a>长按手势——UILongPressGestureRecognizer</h3><p>进行长按的时候触发的手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发前的点击次数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTapsRequired;    </div><div class=\"line\"><span class=\"comment\">//设置触发的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置最短的长按时间</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CFTimeInterval</span> minimumPressDuration; </div><div class=\"line\"><span class=\"comment\">//设置在按触时时允许移动的最大距离 默认为10像素</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGFloat</span> allowableMovement;</div></pre></td></tr></table></figure></p>\n<h3 id=\"手势组合的问题\"><a href=\"#手势组合的问题\" class=\"headerlink\" title=\"手势组合的问题\"></a>手势组合的问题</h3><p>这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true\" alt=\"手势组合\"><br>当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。</p>\n<blockquote>\n<p>Demo 详见UIGestureRecognizer</p>\n</blockquote>\n","excerpt":"<p>在iOS系统中，手势是进行用户交互的重要方式，通过<code>UIGestureRecognizer</code>类，我们可以轻松的创建出各种手势应用于app中。关于<code>UIGestureRecognizer</code>类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。</p>","more":"<h2 id=\"手势的抽象类——UIGestureRecognizer\"><a href=\"#手势的抽象类——UIGestureRecognizer\" class=\"headerlink\" title=\"手势的抽象类——UIGestureRecognizer\"></a>手势的抽象类——UIGestureRecognizer</h2><p><code>UIGestureRecognizer</code>将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用<code>UIGestureRecognizer</code>的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，<code>UIGestureRecognizer</code>中抽象出了哪些方法。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p><code>UIGestureRecognizer</code>类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>如果我们使用<code>alloc-init</code>的方式，也是可以的，下面的方法可以为手势添加触发的<code>selector</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action;</div></pre></td></tr></table></figure></p>\n<p>与之相对应的，我们也可以将一个<code>selector</code>从其手势对象上移除：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>target</code>一般都是<code>self</code>,因为<code>selector</code>一般都是在<code>self</code>中定义。</p>\n<p>因为<code>addTarget</code>方式的存在，iOS系统允许一个手势对象可以添加多个<code>selector</code>触发方法，并且触发的时候，所有添加的<code>selector</code>都会被执行，我们以点击手势示例如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];</div><div class=\"line\">    [ges addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(haha)];</div><div class=\"line\">     [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)haha&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>点击屏幕后，两个方法都会触发。</p>\n<h3 id=\"手势状态\"><a href=\"#手势状态\" class=\"headerlink\" title=\"手势状态\"></a>手势状态</h3><p>UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIGestureRecognizerState</span> state;</div></pre></td></tr></table></figure></p>\n<p>枚举值如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIGestureRecognizerState</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStatePossible</span>,   <span class=\"comment\">// 默认的状态，这个时候的手势并没有具体的情形状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateBegan</span>,      <span class=\"comment\">// 手势开始被识别的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateChanged</span>,    <span class=\"comment\">// 手势识别发生改变的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateEnded</span>,      <span class=\"comment\">// 手势识别结束，将会执行触发的方法</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateCancelled</span>,  <span class=\"comment\">// 手势识别取消</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateFailed</span>,     <span class=\"comment\">// 识别失败，方法将不会被调用</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateRecognized</span> = <span class=\"built_in\">UIGestureRecognizerStateEnded</span> </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。</p>\n<h3 id=\"常用属性和方法\"><a href=\"#常用属性和方法\" class=\"headerlink\" title=\"常用属性和方法\"></a>常用属性和方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置代理，具体的协议后面会说</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class=\"line\"><span class=\"comment\">//设置手势是否有效</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isEnabled) <span class=\"built_in\">BOOL</span> enabled;</div><div class=\"line\"><span class=\"comment\">//获取手势所在的view</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIView</span> *view; </div><div class=\"line\"><span class=\"comment\">//获取触发触摸的点</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view; </div><div class=\"line\"><span class=\"comment\">//设置触摸点数</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfTouches; </div><div class=\"line\"><span class=\"comment\">//获取某一个触摸点的触摸位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationOfTouch:(<span class=\"built_in\">NSUInteger</span>)touchIndex inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view;</div></pre></td></tr></table></figure>\n<p>其中，<code>UITouch</code>也有一个方法是<code>locationInView:</code>可以获取触摸点在view中的位置。<br>可以通过设置<code>numberOfTapsRequired</code>来区分单击双击：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITapGestureRecognizer</span> *doubleTap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(DoubleTap:)];</div><div class=\"line\">doubleTap.numberOfTapsRequired = <span class=\"number\">2</span>; <span class=\"comment\">//点击的次数 ＝2 双击</span></div><div class=\"line\">[_imageView addGestureRecognizer:doubleTap];<span class=\"comment\">//给对象添加一个手势监测；</span></div></pre></td></tr></table></figure></p>\n<p>另外还有三个属性用来控制触摸事件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> cancelsTouchesInView;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesBegan;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesEnded;</div></pre></td></tr></table></figure></p>\n<p><strong>cancelsTouchesInView</strong><br>默认为YES,这种情况下当手势识别器识别到touch之后，会发送<code>touchesCancelled:withEvent:</code>消息,终止触摸事件的传递,以取消 <code>UIResponder</code>对touch的响应，这个时候只有手势识别器响应touch。<br>当设置成NO时，手势识别器识别到touch之后不会发送<code>touchesCancelled:withEvent:</code>消息，这个时候手势识别器和<code>UIResponder</code>均响应touch。<br><strong>注意：</strong>发送<code>touchesCancelled:withEvent:</code>消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后<code>touchesCancelled:withEvent:</code>消息才会生效，屏蔽touch操作。</p>\n<p><strong>delaysTouchesBegan</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给<code>UIResponder</code>，两者各自做出响应。<br>如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给<code>UIResponder</code>，即<code>UIResponder</code>不会有任何触摸事件。只有在识别失败之后才会将touch发给<code>UIResponder</code>，这种情况下<code>UIResponder</code>的响应会延迟约0.15ms。</p>\n<p><strong>delaysTouchesEnded</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给<code>touchesCancelled:withEvent:</code>消息给<code>UIResponder</code>，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送<code>touchesEnded:withEvent:</code>。<br>如果设置为NO，则不会延迟，即会立即发送<code>touchesEnded:withEvent:</code>以结束当前触摸。</p>\n<h3 id=\"手势间的互斥\"><a href=\"#手势间的互斥\" class=\"headerlink\" title=\"手势间的互斥\"></a>手势间的互斥</h3><p>有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//view.backgroundColor = [UIColor redColor];</span></div><div class=\"line\">   </div><div class=\"line\">    <span class=\"comment\">//ges.delegate=self;</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> * ges2 = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click1:)];</div><div class=\"line\"><span class=\"comment\">//    ges2.delegate=self;</span></div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click1:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges1&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二个手势的触发方法\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ges requireGestureRecognizerToFail:ges2];</div></pre></td></tr></table></figure></p>\n<p>表示如果<code>ges2</code>匹配，那么不会执行<code>ges</code>。只有当<code>ges2</code>不匹配的时候，才会执行<code>ges</code>。</p>\n<h3 id=\"UIGestureRecognizerDelegate\"><a href=\"#UIGestureRecognizerDelegate\" class=\"headerlink\" title=\"UIGestureRecognizerDelegate\"></a>UIGestureRecognizerDelegate</h3><p>前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class=\"built_in\">UITouch</span> *)touch;</div><div class=\"line\"><span class=\"comment\">//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizerShouldBegin:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//下面这个两个方法也是用来控制手势的互斥执行的</span></div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个和第二个互斥时，第二个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div></pre></td></tr></table></figure></p>\n<p>最下面两个方法用起来还挺麻烦的，因为你不知道哪个是<code>gestureRecognizer</code>哪个是<code>otherGestureRecognizer</code>,因此，只能笼统的设置。</p>\n<h3 id=\"手势和触摸的区别\"><a href=\"#手势和触摸的区别\" class=\"headerlink\" title=\"手势和触摸的区别\"></a>手势和触摸的区别</h3><p>前一篇我们学习了<code>UITouch</code>,可以通过重写<code>UIResponder</code>的几个<code>touch</code>方法来处理触摸事件。<br><code>UIGestureRecognizer</code>和触摸事件是两个独立的事,手势和<code>UITouch</code>本身关系不大。不过手势可以通过<code>cancelsTouchesInView</code>,<code>delaysTouchesBegan</code>,<code>delaysTouchesEnded</code>这三个属性来影响触摸事件。</p>\n<h2 id=\"UIGestureRecognizer的子类\"><a href=\"#UIGestureRecognizer的子类\" class=\"headerlink\" title=\"UIGestureRecognizer的子类\"></a>UIGestureRecognizer的子类</h2><h3 id=\"点击手势——UITapGestureRecognizer\"><a href=\"#点击手势——UITapGestureRecognizer\" class=\"headerlink\" title=\"点击手势——UITapGestureRecognizer\"></a>点击手势——UITapGestureRecognizer</h3><p>点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置点击次数，默认为单击</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTapsRequired; </div><div class=\"line\"><span class=\"comment\">//设置同时点击的手指数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTouchesRequired;</div></pre></td></tr></table></figure></p>\n<h3 id=\"捏合手势——UIPinchGestureRecognizer\"><a href=\"#捏合手势——UIPinchGestureRecognizer\" class=\"headerlink\" title=\"捏合手势——UIPinchGestureRecognizer\"></a>捏合手势——UIPinchGestureRecognizer</h3><p>捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置缩放比例</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> scale; </div><div class=\"line\"><span class=\"comment\">//设置捏合速度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完缩放后，一定要把<code>recognizer.scale</code>设置为1<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handlePinch:(<span class=\"built_in\">UIPinchGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"缩放操作\"</span>);<span class=\"comment\">//处理缩放操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview缩放</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformScale</span>(_imageView.transform, recognizer.scale, recognizer.scale);</div><div class=\"line\">    recognizer.scale = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"拖拽手势——UIPanGestureRecognzer\"><a href=\"#拖拽手势——UIPanGestureRecognzer\" class=\"headerlink\" title=\"拖拽手势——UIPanGestureRecognzer\"></a>拖拽手势——UIPanGestureRecognzer</h3><p>当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最少触摸点，默认为1</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> minimumNumberOfTouches; </div><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最多触摸点</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> maximumNumberOfTouches;  </div><div class=\"line\"><span class=\"comment\">//获取当前位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)translationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;            </div><div class=\"line\"><span class=\"comment\">//设置当前位置</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setTranslation:(<span class=\"built_in\">CGPoint</span>)translation inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">//设置拖拽速度</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)velocityInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div></pre></td></tr></table></figure></p>\n<p>代码示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"拖动操作\"</span>);</div><div class=\"line\">    <span class=\"comment\">//处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右</span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> translation = [recognizer translationInView:_imageView];</div><div class=\"line\">    recognizer.view.center = <span class=\"built_in\">CGPointMake</span>(recognizer.view.center.x + translation.x,</div><div class=\"line\">                                         recognizer.view.center.y + translation.y);</div><div class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:_imageView];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>必须使用<code>setTranslation</code>设置为<code>CGPointZero</code>,不知道为什么</p>\n<h3 id=\"滑动手势——UISwipeGestureRecognizer\"><a href=\"#滑动手势——UISwipeGestureRecognizer\" class=\"headerlink\" title=\"滑动手势——UISwipeGestureRecognizer\"></a>滑动手势——UISwipeGestureRecognizer</h3><p>滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发滑动手势的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>                        numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置滑动方向</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UISwipeGestureRecognizerDirection</span> direction;  </div><div class=\"line\"><span class=\"comment\">//枚举如下</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionRight</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionLeft</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionUp</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionDown</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"旋转手势——UIRotationGestureRecognizer\"><a href=\"#旋转手势——UIRotationGestureRecognizer\" class=\"headerlink\" title=\"旋转手势——UIRotationGestureRecognizer\"></a>旋转手势——UIRotationGestureRecognizer</h3><p>进行旋转动作时触发手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置旋转角度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> rotation;</div><div class=\"line\"><span class=\"comment\">//设置旋转速度 </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完旋转后，<code>recognizer.rotation</code>一定要清零.<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handleRotate:(<span class=\"built_in\">UIRotationGestureRecognizer</span>*) recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"旋转操作\"</span>);<span class=\"comment\">//处理旋转操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview旋转</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformRotate</span>(_imageView.transform, recognizer.rotation);</div><div class=\"line\">    recognizer.rotation = <span class=\"number\">0</span>;    <span class=\"comment\">//一定要清零</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"长按手势——UILongPressGestureRecognizer\"><a href=\"#长按手势——UILongPressGestureRecognizer\" class=\"headerlink\" title=\"长按手势——UILongPressGestureRecognizer\"></a>长按手势——UILongPressGestureRecognizer</h3><p>进行长按的时候触发的手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发前的点击次数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTapsRequired;    </div><div class=\"line\"><span class=\"comment\">//设置触发的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置最短的长按时间</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CFTimeInterval</span> minimumPressDuration; </div><div class=\"line\"><span class=\"comment\">//设置在按触时时允许移动的最大距离 默认为10像素</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGFloat</span> allowableMovement;</div></pre></td></tr></table></figure></p>\n<h3 id=\"手势组合的问题\"><a href=\"#手势组合的问题\" class=\"headerlink\" title=\"手势组合的问题\"></a>手势组合的问题</h3><p>这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true\" alt=\"手势组合\"><br>当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。</p>\n<blockquote>\n<p>Demo 详见UIGestureRecognizer</p>\n</blockquote>"},{"title":"iOS开发工具应用中的坑","date":"2016-09-23T02:07:12.000Z","_content":"\n这里主要总结一下开发 iOS 使用工具上遇到的一些问题。\n\n<!--more-->\n## 安装 XVim\n\n慕名下载了[Xcode](https://github.com/XVimProject/XVim)，但是安装起来有点曲折。\n\n先用SourceTree创建了本地仓库，`clone`了代码。貌似Xcode8和Xcode7安装起来有点区别。\n\nXcode8 的用户要按照他的方法设置个人证书。主要是因为在 Xcode8 中，出于安全原因，官方已经不支持第三方插件了。想要使用第三方插件，就得开个后门，回到 Xcode7 的安全配置。操作没有歧义，按照教程就可以完成。\n\nXcode7不能用最新的版本，需要使用`commit`在`809527b`之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。\n\n之后有一步在下载下来的 XVim 文件夹下编译的操作，需要 `cd XVim/`：\n\n```\n$ make\n```\n\n至于下面这个指令，其实不用太在意:\n\n```\n$ xcode-select -p\n```\n\n这个指令主要是看看 Xcode 的版本是否指定在 `/Applications/Xcode.app/Contents/Developer` 目录下，不是的话要手动指定。具体这样是为了什么，我也没认真去搞明白。\n\n重启xcode，会提示是否使用Xvim，选择`load`就OK了。\n\n### 使用\n除了Vim自身的命令外,XVim还有几个Xcode命令:\n\n![XVim_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true)\n\n附带Vim使用详解：\n![XVim_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true)\n\n## pod 的安装和使用\n### 安装 cocoapods\n安装 cocoapods 本身并没有难度。只是一点，Ruby 的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远端替换成淘宝的。不过好像最近**淘宝的镜像也不能用了**，所以再换一个镜像吧：\n\n```ruby\n//删除默认源\n$gem sources --remove https://rubygems.org/\n//添加新源\n$gem sources -a http://gems.ruby-china.org/\n//查看\n$ gem sources -l\n```\n\n这样再安装一次，就能安装成功了：\n\n```\n$ sudo gem install cocoapods\n```\n\n### pod install 卡在 Setting up CocoaPods master repo\n安装完 pod 后就可以使用 `pod install` 安装第三方库了，但是第一次 `pod install` 的时候会自动从 `https://github.com/CocoaPods/Specs` 克隆到本地的 `.cocoapods` 目录下。\n\n但是往往就会卡在这里，如果网络不畅，极有可能失败。因此，需要换手动克隆的方式。\n\n首先进入该目录，如果没有，可以手动创建：\n\n```\ncd ~/.cocoapods/repos\n```\n\n克隆一个Specs库：\n```\ngit clone https://github.com/CocoaPods/Specs\n```\n\n然后打开目录，我们可以看到这样的目录结构：\n\n```\nrepos\n\tSpecs\n\t\tCocoaPods-version.yml\n\t\tREADME.md\n\t\tSpecs\n\t\t.git\n```\n\n现在将第一个 `Specs` 文件夹修改为 `master` 即可完成 `Setting up CocoaPods master repo` 的操作。\n\n目录结构为：\n```\nrepos\n\tmaster\n\t\tCocoaPods-version.yml\n\t\tREADME.md\n\t\tSpecs\n\t\t.git\n```\n\n现在可以放心 `pod install` 了。\n\n### pod install 卡在 Analyzing dependencies\n原因在于当执行以上两个命令的时候会升级 CocoaPods 的 spec 仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：\n\n```\npod install --verbose --no-repo-update\n```\n\n其中 `--verbose` 表示显示详情。后面的 `--no-repo-update` 才是正真起作用的。\n\n### gem 与 pod 的更新\nGem 是一个管理 Ruby 库和程序的标准包，我们使用的 cocoapods 也是通过 gem 安装的。\n\n#### gem 的一些指令\n1. `gem install xxx`:安装某个包。\n2. `gem install xxx -v 1.5.4`:安装指定版本的包\n3. `gem update`:更新所有包\n4. `gem update --system`:更新 Gem 自身\n5. `gem list`:列出所有的包\n\n#### pod 更新\n有时候 pod 安装或者更新的时候会出现这种情况：\n![安装失败](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_install_error.png?raw=true)\n解决方法是\n![更新成功](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_update.png?raw=true)\n\n## Xcode报错 code signing is required for product type 'Unit Test Bundle' in SDK 'iOS 10.1'\n在网上下载别人项目后，运不起来，总是报这个错。虽然不知道这个错误最根本的解决办法是什么。但是临时性的解决方法还是有的。做法就是不要 build 项目里面的测试工程。\n\nEdit scheme -> build -> remove xxxtest\n![Xcode报错解决](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/xcode_debug.png?raw=true)\n\n## Podfile.lock\n在协同开发时，经常会遇到，Podfile.lock 不一致，导致编译失败，需要重新 `pod install` 的情况。这里将简单介绍下 Podfile.lock\n### Podfile.lock的作用\n#### Podfile.lock\nPodfile.lock 是在第一次运行 `pod install` 时候自动生成的。Podfile.lock 中会标注项目当前依赖库的准确版本，其中包括了项目在 Podfile 中直接标注使用的库，以及这些库依赖的其他库。这样的好处是当你跟小伙伴协同开发时，你的小伙伴同步了你的 Podfile.lock 文件后，他执行 `pod install` 会安装 Podfile.lock 指定版本的依赖库，这样就可以防止大家的依赖库不一致而造成问题。因此，CocoaPods 官方强烈推荐把 Podfile.lock 纳入版本控制之下。\n\n但是，Podfile.lock 并不是一成不变的，当你修改了 Podfile 文件里使用的依赖库或者运行 `pod update` 命令时，就会生成新的 Podfile.lock 文件。所以，协同开发时需要注意使用 `pod install` 和 `pod update` 的区别:\n- 使用 `pod install`，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。\n- 使用 `pod update`，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件。\n\n#### Manifest.lock\n那么是如何知道拉取的 Podfile.lock 和 Pod 内，库的版本不一致的呢？在每次生成 Podfile.lock 的时候，都会在 Pod内生成一个 Podfile.lock 的副本Manifest.lock。由于 Pod 一般不会上传版本控制，Manifest.lock 就代表了本地的 Pod 版本。如果拉取了别人的 Podfile.lock，那么 Podfile.lock 和 Manifest.lock 就会产生不一致，就会导致编译失败。\n\n#### 目的\n有了这个检查机制就能保证开发团队的各个小伙伴能在运行项目前更新他们的依赖库，并保持这些依赖库的版本一致，从而防止在依赖库的版本不统一造成程序在一些不明显的地方编译失败或运行崩溃。\n\n#### Podfile.lock 不同的可能原因\n有时可能 Podfile 是相同的，但是你们的 Podfile.lock 还会不同。下面 `Podfile.lock 的引号问题`就是其中之一。\n\n除了 gem，ruby等库的版本不同导致之外，还有可能是因为本地的 Podspec 文件不同导致的。所有的项目的 Podspec 文件都托管在 `https://github.com/CocoaPods/Specs`。第一次执行时，CocoaPods 会将这些 podspec 索引文件更新到本地的 `~/.cocoapods/` 目录下。如果长时间不更新 podspec，那么所要下载的直接依赖库或间接依赖库的最新版本可能发生了变化，就会导致安装了不一样的依赖版本，那么 Podfile.lock 的记录就不一样了。建议可以执行 `pod repo update` 更新一下 spec repo(一般情况下，执行 `pod install` 时会先自动更新 spec 的，除非向上面说的使用 `pod install --no-repo-update`，当然，现在只是记录下可能导致 Podfile.lock 不一致的原因，万一真的发生了呢？)\n\n\n\n### Podfile.lock 的引号问题\n最近在协作的时候遇到了这样的问题，我的 pod lock 总是和同事的不一致，差别在于是否有引号。这就导致了每次拉取别人的代码我都要 pod install 一遍，别人也是一样。\n![podfile.lock](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/podlock.png?raw=true) \n\n查了一些资料[Inconsistent Podfile.lock files between Ruby versions](https://github.com/CocoaPods/CocoaPods/issues/3452),[Strange quotes in Podfile.lock?!](https://github.com/CocoaPods/CocoaPods/issues/6255) 发现大致是因为 gem 的一个 YAML 解析工具 psych 版本不同导致的。所以，解决问题的关键不是更新 cocoapods 而是更新 psych (更新 psych 前，先把 ruby，gem也先更新了，以防有什么差错).\n\n![安装psych](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/安装psych.png?raw=true)","source":"_posts/Xcode的使用.md","raw":"title: iOS开发工具应用中的坑\ndate: 2016/9/23 10:07:12  \ncategories: iOS\ntags:\n\t- Xcode\n\t- Vim \n\t- Cocoapods\n\t- 爬坑\n\t\n---\n\n这里主要总结一下开发 iOS 使用工具上遇到的一些问题。\n\n<!--more-->\n## 安装 XVim\n\n慕名下载了[Xcode](https://github.com/XVimProject/XVim)，但是安装起来有点曲折。\n\n先用SourceTree创建了本地仓库，`clone`了代码。貌似Xcode8和Xcode7安装起来有点区别。\n\nXcode8 的用户要按照他的方法设置个人证书。主要是因为在 Xcode8 中，出于安全原因，官方已经不支持第三方插件了。想要使用第三方插件，就得开个后门，回到 Xcode7 的安全配置。操作没有歧义，按照教程就可以完成。\n\nXcode7不能用最新的版本，需要使用`commit`在`809527b`之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。\n\n之后有一步在下载下来的 XVim 文件夹下编译的操作，需要 `cd XVim/`：\n\n```\n$ make\n```\n\n至于下面这个指令，其实不用太在意:\n\n```\n$ xcode-select -p\n```\n\n这个指令主要是看看 Xcode 的版本是否指定在 `/Applications/Xcode.app/Contents/Developer` 目录下，不是的话要手动指定。具体这样是为了什么，我也没认真去搞明白。\n\n重启xcode，会提示是否使用Xvim，选择`load`就OK了。\n\n### 使用\n除了Vim自身的命令外,XVim还有几个Xcode命令:\n\n![XVim_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true)\n\n附带Vim使用详解：\n![XVim_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true)\n\n## pod 的安装和使用\n### 安装 cocoapods\n安装 cocoapods 本身并没有难度。只是一点，Ruby 的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远端替换成淘宝的。不过好像最近**淘宝的镜像也不能用了**，所以再换一个镜像吧：\n\n```ruby\n//删除默认源\n$gem sources --remove https://rubygems.org/\n//添加新源\n$gem sources -a http://gems.ruby-china.org/\n//查看\n$ gem sources -l\n```\n\n这样再安装一次，就能安装成功了：\n\n```\n$ sudo gem install cocoapods\n```\n\n### pod install 卡在 Setting up CocoaPods master repo\n安装完 pod 后就可以使用 `pod install` 安装第三方库了，但是第一次 `pod install` 的时候会自动从 `https://github.com/CocoaPods/Specs` 克隆到本地的 `.cocoapods` 目录下。\n\n但是往往就会卡在这里，如果网络不畅，极有可能失败。因此，需要换手动克隆的方式。\n\n首先进入该目录，如果没有，可以手动创建：\n\n```\ncd ~/.cocoapods/repos\n```\n\n克隆一个Specs库：\n```\ngit clone https://github.com/CocoaPods/Specs\n```\n\n然后打开目录，我们可以看到这样的目录结构：\n\n```\nrepos\n\tSpecs\n\t\tCocoaPods-version.yml\n\t\tREADME.md\n\t\tSpecs\n\t\t.git\n```\n\n现在将第一个 `Specs` 文件夹修改为 `master` 即可完成 `Setting up CocoaPods master repo` 的操作。\n\n目录结构为：\n```\nrepos\n\tmaster\n\t\tCocoaPods-version.yml\n\t\tREADME.md\n\t\tSpecs\n\t\t.git\n```\n\n现在可以放心 `pod install` 了。\n\n### pod install 卡在 Analyzing dependencies\n原因在于当执行以上两个命令的时候会升级 CocoaPods 的 spec 仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：\n\n```\npod install --verbose --no-repo-update\n```\n\n其中 `--verbose` 表示显示详情。后面的 `--no-repo-update` 才是正真起作用的。\n\n### gem 与 pod 的更新\nGem 是一个管理 Ruby 库和程序的标准包，我们使用的 cocoapods 也是通过 gem 安装的。\n\n#### gem 的一些指令\n1. `gem install xxx`:安装某个包。\n2. `gem install xxx -v 1.5.4`:安装指定版本的包\n3. `gem update`:更新所有包\n4. `gem update --system`:更新 Gem 自身\n5. `gem list`:列出所有的包\n\n#### pod 更新\n有时候 pod 安装或者更新的时候会出现这种情况：\n![安装失败](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_install_error.png?raw=true)\n解决方法是\n![更新成功](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_update.png?raw=true)\n\n## Xcode报错 code signing is required for product type 'Unit Test Bundle' in SDK 'iOS 10.1'\n在网上下载别人项目后，运不起来，总是报这个错。虽然不知道这个错误最根本的解决办法是什么。但是临时性的解决方法还是有的。做法就是不要 build 项目里面的测试工程。\n\nEdit scheme -> build -> remove xxxtest\n![Xcode报错解决](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/xcode_debug.png?raw=true)\n\n## Podfile.lock\n在协同开发时，经常会遇到，Podfile.lock 不一致，导致编译失败，需要重新 `pod install` 的情况。这里将简单介绍下 Podfile.lock\n### Podfile.lock的作用\n#### Podfile.lock\nPodfile.lock 是在第一次运行 `pod install` 时候自动生成的。Podfile.lock 中会标注项目当前依赖库的准确版本，其中包括了项目在 Podfile 中直接标注使用的库，以及这些库依赖的其他库。这样的好处是当你跟小伙伴协同开发时，你的小伙伴同步了你的 Podfile.lock 文件后，他执行 `pod install` 会安装 Podfile.lock 指定版本的依赖库，这样就可以防止大家的依赖库不一致而造成问题。因此，CocoaPods 官方强烈推荐把 Podfile.lock 纳入版本控制之下。\n\n但是，Podfile.lock 并不是一成不变的，当你修改了 Podfile 文件里使用的依赖库或者运行 `pod update` 命令时，就会生成新的 Podfile.lock 文件。所以，协同开发时需要注意使用 `pod install` 和 `pod update` 的区别:\n- 使用 `pod install`，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。\n- 使用 `pod update`，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件。\n\n#### Manifest.lock\n那么是如何知道拉取的 Podfile.lock 和 Pod 内，库的版本不一致的呢？在每次生成 Podfile.lock 的时候，都会在 Pod内生成一个 Podfile.lock 的副本Manifest.lock。由于 Pod 一般不会上传版本控制，Manifest.lock 就代表了本地的 Pod 版本。如果拉取了别人的 Podfile.lock，那么 Podfile.lock 和 Manifest.lock 就会产生不一致，就会导致编译失败。\n\n#### 目的\n有了这个检查机制就能保证开发团队的各个小伙伴能在运行项目前更新他们的依赖库，并保持这些依赖库的版本一致，从而防止在依赖库的版本不统一造成程序在一些不明显的地方编译失败或运行崩溃。\n\n#### Podfile.lock 不同的可能原因\n有时可能 Podfile 是相同的，但是你们的 Podfile.lock 还会不同。下面 `Podfile.lock 的引号问题`就是其中之一。\n\n除了 gem，ruby等库的版本不同导致之外，还有可能是因为本地的 Podspec 文件不同导致的。所有的项目的 Podspec 文件都托管在 `https://github.com/CocoaPods/Specs`。第一次执行时，CocoaPods 会将这些 podspec 索引文件更新到本地的 `~/.cocoapods/` 目录下。如果长时间不更新 podspec，那么所要下载的直接依赖库或间接依赖库的最新版本可能发生了变化，就会导致安装了不一样的依赖版本，那么 Podfile.lock 的记录就不一样了。建议可以执行 `pod repo update` 更新一下 spec repo(一般情况下，执行 `pod install` 时会先自动更新 spec 的，除非向上面说的使用 `pod install --no-repo-update`，当然，现在只是记录下可能导致 Podfile.lock 不一致的原因，万一真的发生了呢？)\n\n\n\n### Podfile.lock 的引号问题\n最近在协作的时候遇到了这样的问题，我的 pod lock 总是和同事的不一致，差别在于是否有引号。这就导致了每次拉取别人的代码我都要 pod install 一遍，别人也是一样。\n![podfile.lock](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/podlock.png?raw=true) \n\n查了一些资料[Inconsistent Podfile.lock files between Ruby versions](https://github.com/CocoaPods/CocoaPods/issues/3452),[Strange quotes in Podfile.lock?!](https://github.com/CocoaPods/CocoaPods/issues/6255) 发现大致是因为 gem 的一个 YAML 解析工具 psych 版本不同导致的。所以，解决问题的关键不是更新 cocoapods 而是更新 psych (更新 psych 前，先把 ruby，gem也先更新了，以防有什么差错).\n\n![安装psych](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/安装psych.png?raw=true)","slug":"Xcode的使用","published":1,"updated":"2016-12-15T17:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqb001z7hzgcooniiu2","content":"<p>这里主要总结一下开发 iOS 使用工具上遇到的一些问题。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装-XVim\"><a href=\"#安装-XVim\" class=\"headerlink\" title=\"安装 XVim\"></a>安装 XVim</h2><p>慕名下载了<a href=\"https://github.com/XVimProject/XVim\" target=\"_blank\" rel=\"external\">Xcode</a>，但是安装起来有点曲折。</p>\n<p>先用SourceTree创建了本地仓库，<code>clone</code>了代码。貌似Xcode8和Xcode7安装起来有点区别。</p>\n<p>Xcode8 的用户要按照他的方法设置个人证书。主要是因为在 Xcode8 中，出于安全原因，官方已经不支持第三方插件了。想要使用第三方插件，就得开个后门，回到 Xcode7 的安全配置。操作没有歧义，按照教程就可以完成。</p>\n<p>Xcode7不能用最新的版本，需要使用<code>commit</code>在<code>809527b</code>之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。</p>\n<p>之后有一步在下载下来的 XVim 文件夹下编译的操作，需要 <code>cd XVim/</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ make</div></pre></td></tr></table></figure>\n<p>至于下面这个指令，其实不用太在意:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcode-select -p</div></pre></td></tr></table></figure>\n<p>这个指令主要是看看 Xcode 的版本是否指定在 <code>/Applications/Xcode.app/Contents/Developer</code> 目录下，不是的话要手动指定。具体这样是为了什么，我也没认真去搞明白。</p>\n<p>重启xcode，会提示是否使用Xvim，选择<code>load</code>就OK了。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>除了Vim自身的命令外,XVim还有几个Xcode命令:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true\" alt=\"XVim_1\"></p>\n<p>附带Vim使用详解：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true\" alt=\"XVim_2\"></p>\n<h2 id=\"pod-的安装和使用\"><a href=\"#pod-的安装和使用\" class=\"headerlink\" title=\"pod 的安装和使用\"></a>pod 的安装和使用</h2><h3 id=\"安装-cocoapods\"><a href=\"#安装-cocoapods\" class=\"headerlink\" title=\"安装 cocoapods\"></a>安装 cocoapods</h3><p>安装 cocoapods 本身并没有难度。只是一点，Ruby 的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远端替换成淘宝的。不过好像最近<strong>淘宝的镜像也不能用了</strong>，所以再换一个镜像吧：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//删除默认源</div><div class=\"line\">$gem sources --remove https://rubygems.org/</div><div class=\"line\">//添加新源</div><div class=\"line\">$gem sources -a http://gems.ruby-china.org/</div><div class=\"line\">//查看</div><div class=\"line\">$ gem sources -l</div></pre></td></tr></table></figure>\n<p>这样再安装一次，就能安装成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gem install cocoapods</div></pre></td></tr></table></figure>\n<h3 id=\"pod-install-卡在-Setting-up-CocoaPods-master-repo\"><a href=\"#pod-install-卡在-Setting-up-CocoaPods-master-repo\" class=\"headerlink\" title=\"pod install 卡在 Setting up CocoaPods master repo\"></a>pod install 卡在 Setting up CocoaPods master repo</h3><p>安装完 pod 后就可以使用 <code>pod install</code> 安装第三方库了，但是第一次 <code>pod install</code> 的时候会自动从 <code>https://github.com/CocoaPods/Specs</code> 克隆到本地的 <code>.cocoapods</code> 目录下。</p>\n<p>但是往往就会卡在这里，如果网络不畅，极有可能失败。因此，需要换手动克隆的方式。</p>\n<p>首先进入该目录，如果没有，可以手动创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>\n<p>克隆一个Specs库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/CocoaPods/Specs</div></pre></td></tr></table></figure></p>\n<p>然后打开目录，我们可以看到这样的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repos</div><div class=\"line\">\tSpecs</div><div class=\"line\">\t\tCocoaPods-version.yml</div><div class=\"line\">\t\tREADME.md</div><div class=\"line\">\t\tSpecs</div><div class=\"line\">\t\t.git</div></pre></td></tr></table></figure>\n<p>现在将第一个 <code>Specs</code> 文件夹修改为 <code>master</code> 即可完成 <code>Setting up CocoaPods master repo</code> 的操作。</p>\n<p>目录结构为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repos</div><div class=\"line\">\tmaster</div><div class=\"line\">\t\tCocoaPods-version.yml</div><div class=\"line\">\t\tREADME.md</div><div class=\"line\">\t\tSpecs</div><div class=\"line\">\t\t.git</div></pre></td></tr></table></figure></p>\n<p>现在可以放心 <code>pod install</code> 了。</p>\n<h3 id=\"pod-install-卡在-Analyzing-dependencies\"><a href=\"#pod-install-卡在-Analyzing-dependencies\" class=\"headerlink\" title=\"pod install 卡在 Analyzing dependencies\"></a>pod install 卡在 Analyzing dependencies</h3><p>原因在于当执行以上两个命令的时候会升级 CocoaPods 的 spec 仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install --verbose --no-repo-update</div></pre></td></tr></table></figure>\n<p>其中 <code>--verbose</code> 表示显示详情。后面的 <code>--no-repo-update</code> 才是正真起作用的。</p>\n<h3 id=\"gem-与-pod-的更新\"><a href=\"#gem-与-pod-的更新\" class=\"headerlink\" title=\"gem 与 pod 的更新\"></a>gem 与 pod 的更新</h3><p>Gem 是一个管理 Ruby 库和程序的标准包，我们使用的 cocoapods 也是通过 gem 安装的。</p>\n<h4 id=\"gem-的一些指令\"><a href=\"#gem-的一些指令\" class=\"headerlink\" title=\"gem 的一些指令\"></a>gem 的一些指令</h4><ol>\n<li><code>gem install xxx</code>:安装某个包。</li>\n<li><code>gem install xxx -v 1.5.4</code>:安装指定版本的包</li>\n<li><code>gem update</code>:更新所有包</li>\n<li><code>gem update --system</code>:更新 Gem 自身</li>\n<li><code>gem list</code>:列出所有的包</li>\n</ol>\n<h4 id=\"pod-更新\"><a href=\"#pod-更新\" class=\"headerlink\" title=\"pod 更新\"></a>pod 更新</h4><p>有时候 pod 安装或者更新的时候会出现这种情况：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_install_error.png?raw=true\" alt=\"安装失败\"><br>解决方法是<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_update.png?raw=true\" alt=\"更新成功\"></p>\n<h2 id=\"Xcode报错-code-signing-is-required-for-product-type-‘Unit-Test-Bundle’-in-SDK-‘iOS-10-1’\"><a href=\"#Xcode报错-code-signing-is-required-for-product-type-‘Unit-Test-Bundle’-in-SDK-‘iOS-10-1’\" class=\"headerlink\" title=\"Xcode报错 code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 10.1’\"></a>Xcode报错 code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 10.1’</h2><p>在网上下载别人项目后，运不起来，总是报这个错。虽然不知道这个错误最根本的解决办法是什么。但是临时性的解决方法还是有的。做法就是不要 build 项目里面的测试工程。</p>\n<p>Edit scheme -&gt; build -&gt; remove xxxtest<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/xcode_debug.png?raw=true\" alt=\"Xcode报错解决\"></p>\n<h2 id=\"Podfile-lock\"><a href=\"#Podfile-lock\" class=\"headerlink\" title=\"Podfile.lock\"></a>Podfile.lock</h2><p>在协同开发时，经常会遇到，Podfile.lock 不一致，导致编译失败，需要重新 <code>pod install</code> 的情况。这里将简单介绍下 Podfile.lock</p>\n<h3 id=\"Podfile-lock的作用\"><a href=\"#Podfile-lock的作用\" class=\"headerlink\" title=\"Podfile.lock的作用\"></a>Podfile.lock的作用</h3><h4 id=\"Podfile-lock-1\"><a href=\"#Podfile-lock-1\" class=\"headerlink\" title=\"Podfile.lock\"></a>Podfile.lock</h4><p>Podfile.lock 是在第一次运行 <code>pod install</code> 时候自动生成的。Podfile.lock 中会标注项目当前依赖库的准确版本，其中包括了项目在 Podfile 中直接标注使用的库，以及这些库依赖的其他库。这样的好处是当你跟小伙伴协同开发时，你的小伙伴同步了你的 Podfile.lock 文件后，他执行 <code>pod install</code> 会安装 Podfile.lock 指定版本的依赖库，这样就可以防止大家的依赖库不一致而造成问题。因此，CocoaPods 官方强烈推荐把 Podfile.lock 纳入版本控制之下。</p>\n<p>但是，Podfile.lock 并不是一成不变的，当你修改了 Podfile 文件里使用的依赖库或者运行 <code>pod update</code> 命令时，就会生成新的 Podfile.lock 文件。所以，协同开发时需要注意使用 <code>pod install</code> 和 <code>pod update</code> 的区别:</p>\n<ul>\n<li>使用 <code>pod install</code>，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。</li>\n<li>使用 <code>pod update</code>，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件。</li>\n</ul>\n<h4 id=\"Manifest-lock\"><a href=\"#Manifest-lock\" class=\"headerlink\" title=\"Manifest.lock\"></a>Manifest.lock</h4><p>那么是如何知道拉取的 Podfile.lock 和 Pod 内，库的版本不一致的呢？在每次生成 Podfile.lock 的时候，都会在 Pod内生成一个 Podfile.lock 的副本Manifest.lock。由于 Pod 一般不会上传版本控制，Manifest.lock 就代表了本地的 Pod 版本。如果拉取了别人的 Podfile.lock，那么 Podfile.lock 和 Manifest.lock 就会产生不一致，就会导致编译失败。</p>\n<h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>有了这个检查机制就能保证开发团队的各个小伙伴能在运行项目前更新他们的依赖库，并保持这些依赖库的版本一致，从而防止在依赖库的版本不统一造成程序在一些不明显的地方编译失败或运行崩溃。</p>\n<h4 id=\"Podfile-lock-不同的可能原因\"><a href=\"#Podfile-lock-不同的可能原因\" class=\"headerlink\" title=\"Podfile.lock 不同的可能原因\"></a>Podfile.lock 不同的可能原因</h4><p>有时可能 Podfile 是相同的，但是你们的 Podfile.lock 还会不同。下面 <code>Podfile.lock 的引号问题</code>就是其中之一。</p>\n<p>除了 gem，ruby等库的版本不同导致之外，还有可能是因为本地的 Podspec 文件不同导致的。所有的项目的 Podspec 文件都托管在 <code>https://github.com/CocoaPods/Specs</code>。第一次执行时，CocoaPods 会将这些 podspec 索引文件更新到本地的 <code>~/.cocoapods/</code> 目录下。如果长时间不更新 podspec，那么所要下载的直接依赖库或间接依赖库的最新版本可能发生了变化，就会导致安装了不一样的依赖版本，那么 Podfile.lock 的记录就不一样了。建议可以执行 <code>pod repo update</code> 更新一下 spec repo(一般情况下，执行 <code>pod install</code> 时会先自动更新 spec 的，除非向上面说的使用 <code>pod install --no-repo-update</code>，当然，现在只是记录下可能导致 Podfile.lock 不一致的原因，万一真的发生了呢？)</p>\n<h3 id=\"Podfile-lock-的引号问题\"><a href=\"#Podfile-lock-的引号问题\" class=\"headerlink\" title=\"Podfile.lock 的引号问题\"></a>Podfile.lock 的引号问题</h3><p>最近在协作的时候遇到了这样的问题，我的 pod lock 总是和同事的不一致，差别在于是否有引号。这就导致了每次拉取别人的代码我都要 pod install 一遍，别人也是一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/podlock.png?raw=true\" alt=\"podfile.lock\"> </p>\n<p>查了一些资料<a href=\"https://github.com/CocoaPods/CocoaPods/issues/3452\" target=\"_blank\" rel=\"external\">Inconsistent Podfile.lock files between Ruby versions</a>,<a href=\"https://github.com/CocoaPods/CocoaPods/issues/6255\" target=\"_blank\" rel=\"external\">Strange quotes in Podfile.lock?!</a> 发现大致是因为 gem 的一个 YAML 解析工具 psych 版本不同导致的。所以，解决问题的关键不是更新 cocoapods 而是更新 psych (更新 psych 前，先把 ruby，gem也先更新了，以防有什么差错).</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/安装psych.png?raw=true\" alt=\"安装psych\"></p>\n","excerpt":"<p>这里主要总结一下开发 iOS 使用工具上遇到的一些问题。</p>","more":"<h2 id=\"安装-XVim\"><a href=\"#安装-XVim\" class=\"headerlink\" title=\"安装 XVim\"></a>安装 XVim</h2><p>慕名下载了<a href=\"https://github.com/XVimProject/XVim\">Xcode</a>，但是安装起来有点曲折。</p>\n<p>先用SourceTree创建了本地仓库，<code>clone</code>了代码。貌似Xcode8和Xcode7安装起来有点区别。</p>\n<p>Xcode8 的用户要按照他的方法设置个人证书。主要是因为在 Xcode8 中，出于安全原因，官方已经不支持第三方插件了。想要使用第三方插件，就得开个后门，回到 Xcode7 的安全配置。操作没有歧义，按照教程就可以完成。</p>\n<p>Xcode7不能用最新的版本，需要使用<code>commit</code>在<code>809527b</code>之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。</p>\n<p>之后有一步在下载下来的 XVim 文件夹下编译的操作，需要 <code>cd XVim/</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ make</div></pre></td></tr></table></figure>\n<p>至于下面这个指令，其实不用太在意:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcode-select -p</div></pre></td></tr></table></figure>\n<p>这个指令主要是看看 Xcode 的版本是否指定在 <code>/Applications/Xcode.app/Contents/Developer</code> 目录下，不是的话要手动指定。具体这样是为了什么，我也没认真去搞明白。</p>\n<p>重启xcode，会提示是否使用Xvim，选择<code>load</code>就OK了。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>除了Vim自身的命令外,XVim还有几个Xcode命令:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true\" alt=\"XVim_1\"></p>\n<p>附带Vim使用详解：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true\" alt=\"XVim_2\"></p>\n<h2 id=\"pod-的安装和使用\"><a href=\"#pod-的安装和使用\" class=\"headerlink\" title=\"pod 的安装和使用\"></a>pod 的安装和使用</h2><h3 id=\"安装-cocoapods\"><a href=\"#安装-cocoapods\" class=\"headerlink\" title=\"安装 cocoapods\"></a>安装 cocoapods</h3><p>安装 cocoapods 本身并没有难度。只是一点，Ruby 的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远端替换成淘宝的。不过好像最近<strong>淘宝的镜像也不能用了</strong>，所以再换一个镜像吧：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//删除默认源</div><div class=\"line\">$gem sources --remove https://rubygems.org/</div><div class=\"line\">//添加新源</div><div class=\"line\">$gem sources -a http://gems.ruby-china.org/</div><div class=\"line\">//查看</div><div class=\"line\">$ gem sources -l</div></pre></td></tr></table></figure>\n<p>这样再安装一次，就能安装成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo gem install cocoapods</div></pre></td></tr></table></figure>\n<h3 id=\"pod-install-卡在-Setting-up-CocoaPods-master-repo\"><a href=\"#pod-install-卡在-Setting-up-CocoaPods-master-repo\" class=\"headerlink\" title=\"pod install 卡在 Setting up CocoaPods master repo\"></a>pod install 卡在 Setting up CocoaPods master repo</h3><p>安装完 pod 后就可以使用 <code>pod install</code> 安装第三方库了，但是第一次 <code>pod install</code> 的时候会自动从 <code>https://github.com/CocoaPods/Specs</code> 克隆到本地的 <code>.cocoapods</code> 目录下。</p>\n<p>但是往往就会卡在这里，如果网络不畅，极有可能失败。因此，需要换手动克隆的方式。</p>\n<p>首先进入该目录，如果没有，可以手动创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>\n<p>克隆一个Specs库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/CocoaPods/Specs</div></pre></td></tr></table></figure></p>\n<p>然后打开目录，我们可以看到这样的目录结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repos</div><div class=\"line\">\tSpecs</div><div class=\"line\">\t\tCocoaPods-version.yml</div><div class=\"line\">\t\tREADME.md</div><div class=\"line\">\t\tSpecs</div><div class=\"line\">\t\t.git</div></pre></td></tr></table></figure>\n<p>现在将第一个 <code>Specs</code> 文件夹修改为 <code>master</code> 即可完成 <code>Setting up CocoaPods master repo</code> 的操作。</p>\n<p>目录结构为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">repos</div><div class=\"line\">\tmaster</div><div class=\"line\">\t\tCocoaPods-version.yml</div><div class=\"line\">\t\tREADME.md</div><div class=\"line\">\t\tSpecs</div><div class=\"line\">\t\t.git</div></pre></td></tr></table></figure></p>\n<p>现在可以放心 <code>pod install</code> 了。</p>\n<h3 id=\"pod-install-卡在-Analyzing-dependencies\"><a href=\"#pod-install-卡在-Analyzing-dependencies\" class=\"headerlink\" title=\"pod install 卡在 Analyzing dependencies\"></a>pod install 卡在 Analyzing dependencies</h3><p>原因在于当执行以上两个命令的时候会升级 CocoaPods 的 spec 仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install --verbose --no-repo-update</div></pre></td></tr></table></figure>\n<p>其中 <code>--verbose</code> 表示显示详情。后面的 <code>--no-repo-update</code> 才是正真起作用的。</p>\n<h3 id=\"gem-与-pod-的更新\"><a href=\"#gem-与-pod-的更新\" class=\"headerlink\" title=\"gem 与 pod 的更新\"></a>gem 与 pod 的更新</h3><p>Gem 是一个管理 Ruby 库和程序的标准包，我们使用的 cocoapods 也是通过 gem 安装的。</p>\n<h4 id=\"gem-的一些指令\"><a href=\"#gem-的一些指令\" class=\"headerlink\" title=\"gem 的一些指令\"></a>gem 的一些指令</h4><ol>\n<li><code>gem install xxx</code>:安装某个包。</li>\n<li><code>gem install xxx -v 1.5.4</code>:安装指定版本的包</li>\n<li><code>gem update</code>:更新所有包</li>\n<li><code>gem update --system</code>:更新 Gem 自身</li>\n<li><code>gem list</code>:列出所有的包</li>\n</ol>\n<h4 id=\"pod-更新\"><a href=\"#pod-更新\" class=\"headerlink\" title=\"pod 更新\"></a>pod 更新</h4><p>有时候 pod 安装或者更新的时候会出现这种情况：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_install_error.png?raw=true\" alt=\"安装失败\"><br>解决方法是<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pod_update.png?raw=true\" alt=\"更新成功\"></p>\n<h2 id=\"Xcode报错-code-signing-is-required-for-product-type-‘Unit-Test-Bundle’-in-SDK-‘iOS-10-1’\"><a href=\"#Xcode报错-code-signing-is-required-for-product-type-‘Unit-Test-Bundle’-in-SDK-‘iOS-10-1’\" class=\"headerlink\" title=\"Xcode报错 code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 10.1’\"></a>Xcode报错 code signing is required for product type ‘Unit Test Bundle’ in SDK ‘iOS 10.1’</h2><p>在网上下载别人项目后，运不起来，总是报这个错。虽然不知道这个错误最根本的解决办法是什么。但是临时性的解决方法还是有的。做法就是不要 build 项目里面的测试工程。</p>\n<p>Edit scheme -&gt; build -&gt; remove xxxtest<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/xcode_debug.png?raw=true\" alt=\"Xcode报错解决\"></p>\n<h2 id=\"Podfile-lock\"><a href=\"#Podfile-lock\" class=\"headerlink\" title=\"Podfile.lock\"></a>Podfile.lock</h2><p>在协同开发时，经常会遇到，Podfile.lock 不一致，导致编译失败，需要重新 <code>pod install</code> 的情况。这里将简单介绍下 Podfile.lock</p>\n<h3 id=\"Podfile-lock的作用\"><a href=\"#Podfile-lock的作用\" class=\"headerlink\" title=\"Podfile.lock的作用\"></a>Podfile.lock的作用</h3><h4 id=\"Podfile-lock-1\"><a href=\"#Podfile-lock-1\" class=\"headerlink\" title=\"Podfile.lock\"></a>Podfile.lock</h4><p>Podfile.lock 是在第一次运行 <code>pod install</code> 时候自动生成的。Podfile.lock 中会标注项目当前依赖库的准确版本，其中包括了项目在 Podfile 中直接标注使用的库，以及这些库依赖的其他库。这样的好处是当你跟小伙伴协同开发时，你的小伙伴同步了你的 Podfile.lock 文件后，他执行 <code>pod install</code> 会安装 Podfile.lock 指定版本的依赖库，这样就可以防止大家的依赖库不一致而造成问题。因此，CocoaPods 官方强烈推荐把 Podfile.lock 纳入版本控制之下。</p>\n<p>但是，Podfile.lock 并不是一成不变的，当你修改了 Podfile 文件里使用的依赖库或者运行 <code>pod update</code> 命令时，就会生成新的 Podfile.lock 文件。所以，协同开发时需要注意使用 <code>pod install</code> 和 <code>pod update</code> 的区别:</p>\n<ul>\n<li>使用 <code>pod install</code>，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。</li>\n<li>使用 <code>pod update</code>，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件。</li>\n</ul>\n<h4 id=\"Manifest-lock\"><a href=\"#Manifest-lock\" class=\"headerlink\" title=\"Manifest.lock\"></a>Manifest.lock</h4><p>那么是如何知道拉取的 Podfile.lock 和 Pod 内，库的版本不一致的呢？在每次生成 Podfile.lock 的时候，都会在 Pod内生成一个 Podfile.lock 的副本Manifest.lock。由于 Pod 一般不会上传版本控制，Manifest.lock 就代表了本地的 Pod 版本。如果拉取了别人的 Podfile.lock，那么 Podfile.lock 和 Manifest.lock 就会产生不一致，就会导致编译失败。</p>\n<h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>有了这个检查机制就能保证开发团队的各个小伙伴能在运行项目前更新他们的依赖库，并保持这些依赖库的版本一致，从而防止在依赖库的版本不统一造成程序在一些不明显的地方编译失败或运行崩溃。</p>\n<h4 id=\"Podfile-lock-不同的可能原因\"><a href=\"#Podfile-lock-不同的可能原因\" class=\"headerlink\" title=\"Podfile.lock 不同的可能原因\"></a>Podfile.lock 不同的可能原因</h4><p>有时可能 Podfile 是相同的，但是你们的 Podfile.lock 还会不同。下面 <code>Podfile.lock 的引号问题</code>就是其中之一。</p>\n<p>除了 gem，ruby等库的版本不同导致之外，还有可能是因为本地的 Podspec 文件不同导致的。所有的项目的 Podspec 文件都托管在 <code>https://github.com/CocoaPods/Specs</code>。第一次执行时，CocoaPods 会将这些 podspec 索引文件更新到本地的 <code>~/.cocoapods/</code> 目录下。如果长时间不更新 podspec，那么所要下载的直接依赖库或间接依赖库的最新版本可能发生了变化，就会导致安装了不一样的依赖版本，那么 Podfile.lock 的记录就不一样了。建议可以执行 <code>pod repo update</code> 更新一下 spec repo(一般情况下，执行 <code>pod install</code> 时会先自动更新 spec 的，除非向上面说的使用 <code>pod install --no-repo-update</code>，当然，现在只是记录下可能导致 Podfile.lock 不一致的原因，万一真的发生了呢？)</p>\n<h3 id=\"Podfile-lock-的引号问题\"><a href=\"#Podfile-lock-的引号问题\" class=\"headerlink\" title=\"Podfile.lock 的引号问题\"></a>Podfile.lock 的引号问题</h3><p>最近在协作的时候遇到了这样的问题，我的 pod lock 总是和同事的不一致，差别在于是否有引号。这就导致了每次拉取别人的代码我都要 pod install 一遍，别人也是一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/podlock.png?raw=true\" alt=\"podfile.lock\"> </p>\n<p>查了一些资料<a href=\"https://github.com/CocoaPods/CocoaPods/issues/3452\">Inconsistent Podfile.lock files between Ruby versions</a>,<a href=\"https://github.com/CocoaPods/CocoaPods/issues/6255\">Strange quotes in Podfile.lock?!</a> 发现大致是因为 gem 的一个 YAML 解析工具 psych 版本不同导致的。所以，解决问题的关键不是更新 cocoapods 而是更新 psych (更新 psych 前，先把 ruby，gem也先更新了，以防有什么差错).</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/安装psych.png?raw=true\" alt=\"安装psych\"></p>"},{"title":"Hello World","date":"2016-07-29T06:07:12.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016/7/29 14:07:12  \ncategories: 无处置放\ntags: Hexo\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqg00237hzgck4gvxnx","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"Git技巧","date":"2016-08-27T06:07:12.000Z","_content":"\n虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。\n\n<!--more-->\n\n## git rm\nios中pod的第三方库经常会被`gitignore`掉，让使用者自己下载。\n\n想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.\n\n\n\n### 使用命令行\n可以使用`git rm --cached file`\nGit 将不再跟踪此文件，尽管它仍然是在您的硬盘上.\n对于文件夹，可以使用`git rm -r --cached file`取消关联整个文件夹。\n\n### 使用sourcetree\n在sourcetree中操作要麻烦一些。在添加完`gitignore`后，将想要ignore的文件移出git目录，然后`commit`该操作，再将文件移回来。这个时候文件就被ignore了。\n\n需要注意的是，一定要先执行`commit`操作。因为，在`.git`中存在了pod的版本控制的文件关联，添加了`gitignore`后，git并不会主动将pod文件关联删掉。\n因此，需要先用`commit`将该文件关联删除，才能正确ignore该文件夹。\n\n### 总结\n这里的移除相当于执行了 `rm 文件`的操作，因而需要使用`commit`,而使用命令行的`git rm 文件`则是通过git指令，直接移除了关联。\n\n## git add\n不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有`.git`的缘故吧。\n\n因此，如果当git不能自动添加文件关联的时候，需要使用`git add 文件`的方式手动添加。\n\n使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的`.git`不会被复制，文件也就能添加进sourcetree了。\n\n## merge\nmerge可以说是很常用的一个功能，用于代码合并。\n\n不过由于之前没真正用过，用起来还比较死板。比如，学的时候留下刻板印象就是，将feature branch合并进develop用merge，但是刚刚遇到要把develop合并到feature branch的时候就忘掉merge这个功能了。**只要是关乎于不同branch的代码进行合并都可以用merge啊**。\n\n好吧。可能只是我蠢而已。稍微做个记录，证明自己曾蠢过。但愿不要一直蠢下去。\n\n\n## rebase\n变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。\n\n变基操作的一条准则是：**不要对在你的仓库外有副本的分支执行变基**。\n\n> 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。\n\n也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。\n\n如下图所示，`C5`是其他分支的合并。先将master重置到`C1`的提交，然后rebase`C5`所在分支，得到新的提交`C4'`。一般情况下，git是不允许这样的提交到remote的，但是可以使用`git push --force`强制覆盖remote的仓库。这样`C4``C6`就不复存在了。\n![git_rebase_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_1.png?raw=true)\n\n话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交`C6`到`C7`，如下图所示：\n![git_rebase_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_2.png?raw=true)\n\n由于别人的本地git并不知道`C4``C6`已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交`C4'`，于是就拉取，但是本地git一看远端提交`C4'`和本地提交`C4``C6`都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n![git_rebase_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_3.png?raw=true)\n\n这样就比较尴尬了，因为当时使用rebase就是为了删掉`C4``C6`，但是别人这么一合并一提交，`C4``C6`又全回来了。\n\n如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记**只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令**。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。","source":"_posts/git技巧.md","raw":"title: Git技巧\ndate: 2016/8/27 14:07:12  \ncategories: Git\ntags: [Git]\n\n---\n\n虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。\n\n<!--more-->\n\n## git rm\nios中pod的第三方库经常会被`gitignore`掉，让使用者自己下载。\n\n想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.\n\n\n\n### 使用命令行\n可以使用`git rm --cached file`\nGit 将不再跟踪此文件，尽管它仍然是在您的硬盘上.\n对于文件夹，可以使用`git rm -r --cached file`取消关联整个文件夹。\n\n### 使用sourcetree\n在sourcetree中操作要麻烦一些。在添加完`gitignore`后，将想要ignore的文件移出git目录，然后`commit`该操作，再将文件移回来。这个时候文件就被ignore了。\n\n需要注意的是，一定要先执行`commit`操作。因为，在`.git`中存在了pod的版本控制的文件关联，添加了`gitignore`后，git并不会主动将pod文件关联删掉。\n因此，需要先用`commit`将该文件关联删除，才能正确ignore该文件夹。\n\n### 总结\n这里的移除相当于执行了 `rm 文件`的操作，因而需要使用`commit`,而使用命令行的`git rm 文件`则是通过git指令，直接移除了关联。\n\n## git add\n不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有`.git`的缘故吧。\n\n因此，如果当git不能自动添加文件关联的时候，需要使用`git add 文件`的方式手动添加。\n\n使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的`.git`不会被复制，文件也就能添加进sourcetree了。\n\n## merge\nmerge可以说是很常用的一个功能，用于代码合并。\n\n不过由于之前没真正用过，用起来还比较死板。比如，学的时候留下刻板印象就是，将feature branch合并进develop用merge，但是刚刚遇到要把develop合并到feature branch的时候就忘掉merge这个功能了。**只要是关乎于不同branch的代码进行合并都可以用merge啊**。\n\n好吧。可能只是我蠢而已。稍微做个记录，证明自己曾蠢过。但愿不要一直蠢下去。\n\n\n## rebase\n变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。\n\n变基操作的一条准则是：**不要对在你的仓库外有副本的分支执行变基**。\n\n> 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。\n\n也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。\n\n如下图所示，`C5`是其他分支的合并。先将master重置到`C1`的提交，然后rebase`C5`所在分支，得到新的提交`C4'`。一般情况下，git是不允许这样的提交到remote的，但是可以使用`git push --force`强制覆盖remote的仓库。这样`C4``C6`就不复存在了。\n![git_rebase_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_1.png?raw=true)\n\n话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交`C6`到`C7`，如下图所示：\n![git_rebase_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_2.png?raw=true)\n\n由于别人的本地git并不知道`C4``C6`已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交`C4'`，于是就拉取，但是本地git一看远端提交`C4'`和本地提交`C4``C6`都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n![git_rebase_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_3.png?raw=true)\n\n这样就比较尴尬了，因为当时使用rebase就是为了删掉`C4``C6`，但是别人这么一合并一提交，`C4``C6`又全回来了。\n\n如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记**只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令**。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。","slug":"git技巧","published":1,"updated":"2016-12-13T15:20:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqk00267hzg2dq9p859","content":"<p>虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。</p>\n<a id=\"more\"></a>\n<h2 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h2><p>ios中pod的第三方库经常会被<code>gitignore</code>掉，让使用者自己下载。</p>\n<p>想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.</p>\n<h3 id=\"使用命令行\"><a href=\"#使用命令行\" class=\"headerlink\" title=\"使用命令行\"></a>使用命令行</h3><p>可以使用<code>git rm --cached file</code><br>Git 将不再跟踪此文件，尽管它仍然是在您的硬盘上.<br>对于文件夹，可以使用<code>git rm -r --cached file</code>取消关联整个文件夹。</p>\n<h3 id=\"使用sourcetree\"><a href=\"#使用sourcetree\" class=\"headerlink\" title=\"使用sourcetree\"></a>使用sourcetree</h3><p>在sourcetree中操作要麻烦一些。在添加完<code>gitignore</code>后，将想要ignore的文件移出git目录，然后<code>commit</code>该操作，再将文件移回来。这个时候文件就被ignore了。</p>\n<p>需要注意的是，一定要先执行<code>commit</code>操作。因为，在<code>.git</code>中存在了pod的版本控制的文件关联，添加了<code>gitignore</code>后，git并不会主动将pod文件关联删掉。<br>因此，需要先用<code>commit</code>将该文件关联删除，才能正确ignore该文件夹。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里的移除相当于执行了 <code>rm 文件</code>的操作，因而需要使用<code>commit</code>,而使用命令行的<code>git rm 文件</code>则是通过git指令，直接移除了关联。</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有<code>.git</code>的缘故吧。</p>\n<p>因此，如果当git不能自动添加文件关联的时候，需要使用<code>git add 文件</code>的方式手动添加。</p>\n<p>使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的<code>.git</code>不会被复制，文件也就能添加进sourcetree了。</p>\n<h2 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h2><p>merge可以说是很常用的一个功能，用于代码合并。</p>\n<p>不过由于之前没真正用过，用起来还比较死板。比如，学的时候留下刻板印象就是，将feature branch合并进develop用merge，但是刚刚遇到要把develop合并到feature branch的时候就忘掉merge这个功能了。<strong>只要是关乎于不同branch的代码进行合并都可以用merge啊</strong>。</p>\n<p>好吧。可能只是我蠢而已。稍微做个记录，证明自己曾蠢过。但愿不要一直蠢下去。</p>\n<h2 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h2><p>变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。</p>\n<p>变基操作的一条准则是：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>\n<blockquote>\n<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>\n</blockquote>\n<p>也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。</p>\n<p>如下图所示，<code>C5</code>是其他分支的合并。先将master重置到<code>C1</code>的提交，然后rebase<code>C5</code>所在分支，得到新的提交<code>C4&#39;</code>。一般情况下，git是不允许这样的提交到remote的，但是可以使用<code>git push --force</code>强制覆盖remote的仓库。这样<code>C4``C6</code>就不复存在了。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_1.png?raw=true\" alt=\"git_rebase_1\"></p>\n<p>话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交<code>C6</code>到<code>C7</code>，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_2.png?raw=true\" alt=\"git_rebase_2\"></p>\n<p>由于别人的本地git并不知道<code>C4``C6</code>已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交<code>C4&#39;</code>，于是就拉取，但是本地git一看远端提交<code>C4&#39;</code>和本地提交<code>C4``C6</code>都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_3.png?raw=true\" alt=\"git_rebase_3\"></p>\n<p>这样就比较尴尬了，因为当时使用rebase就是为了删掉<code>C4``C6</code>，但是别人这么一合并一提交，<code>C4``C6</code>又全回来了。</p>\n<p>如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记<strong>只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令</strong>。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。</p>\n","excerpt":"<p>虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。</p>","more":"<h2 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h2><p>ios中pod的第三方库经常会被<code>gitignore</code>掉，让使用者自己下载。</p>\n<p>想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.</p>\n<h3 id=\"使用命令行\"><a href=\"#使用命令行\" class=\"headerlink\" title=\"使用命令行\"></a>使用命令行</h3><p>可以使用<code>git rm --cached file</code><br>Git 将不再跟踪此文件，尽管它仍然是在您的硬盘上.<br>对于文件夹，可以使用<code>git rm -r --cached file</code>取消关联整个文件夹。</p>\n<h3 id=\"使用sourcetree\"><a href=\"#使用sourcetree\" class=\"headerlink\" title=\"使用sourcetree\"></a>使用sourcetree</h3><p>在sourcetree中操作要麻烦一些。在添加完<code>gitignore</code>后，将想要ignore的文件移出git目录，然后<code>commit</code>该操作，再将文件移回来。这个时候文件就被ignore了。</p>\n<p>需要注意的是，一定要先执行<code>commit</code>操作。因为，在<code>.git</code>中存在了pod的版本控制的文件关联，添加了<code>gitignore</code>后，git并不会主动将pod文件关联删掉。<br>因此，需要先用<code>commit</code>将该文件关联删除，才能正确ignore该文件夹。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里的移除相当于执行了 <code>rm 文件</code>的操作，因而需要使用<code>commit</code>,而使用命令行的<code>git rm 文件</code>则是通过git指令，直接移除了关联。</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有<code>.git</code>的缘故吧。</p>\n<p>因此，如果当git不能自动添加文件关联的时候，需要使用<code>git add 文件</code>的方式手动添加。</p>\n<p>使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的<code>.git</code>不会被复制，文件也就能添加进sourcetree了。</p>\n<h2 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h2><p>merge可以说是很常用的一个功能，用于代码合并。</p>\n<p>不过由于之前没真正用过，用起来还比较死板。比如，学的时候留下刻板印象就是，将feature branch合并进develop用merge，但是刚刚遇到要把develop合并到feature branch的时候就忘掉merge这个功能了。<strong>只要是关乎于不同branch的代码进行合并都可以用merge啊</strong>。</p>\n<p>好吧。可能只是我蠢而已。稍微做个记录，证明自己曾蠢过。但愿不要一直蠢下去。</p>\n<h2 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h2><p>变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。</p>\n<p>变基操作的一条准则是：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>\n<blockquote>\n<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>\n</blockquote>\n<p>也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。</p>\n<p>如下图所示，<code>C5</code>是其他分支的合并。先将master重置到<code>C1</code>的提交，然后rebase<code>C5</code>所在分支，得到新的提交<code>C4&#39;</code>。一般情况下，git是不允许这样的提交到remote的，但是可以使用<code>git push --force</code>强制覆盖remote的仓库。这样<code>C4``C6</code>就不复存在了。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_1.png?raw=true\" alt=\"git_rebase_1\"></p>\n<p>话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交<code>C6</code>到<code>C7</code>，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_2.png?raw=true\" alt=\"git_rebase_2\"></p>\n<p>由于别人的本地git并不知道<code>C4``C6</code>已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交<code>C4&#39;</code>，于是就拉取，但是本地git一看远端提交<code>C4&#39;</code>和本地提交<code>C4``C6</code>都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_3.png?raw=true\" alt=\"git_rebase_3\"></p>\n<p>这样就比较尴尬了，因为当时使用rebase就是为了删掉<code>C4``C6</code>，但是别人这么一合并一提交，<code>C4``C6</code>又全回来了。</p>\n<p>如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记<strong>只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令</strong>。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。</p>"},{"title":"hexo 配置遇到的一些坑","date":"2016-12-03T06:07:12.000Z","_content":"\n配置个人博客有时候是一件很蛋疼的事情，经常会出现一些奇奇怪怪的问题。这里我就将把我填上的一些坑总结一下。\n\n<!--more-->\n\n### next主题空白\n这是16年11月份的问题，突然打开自己的博客发现一片空白，但是在本地 `hexo s` 就能够显示出来。原本以为是我远端仓库出了问题，就重建了个新的，但是没有效果。很急很难受。网上搜索真的难，以为我不知道有没有人遇到过这样的问题，并且我也不知道该怎么去描述这个出现的问题。不过，几经波折，还是找到了解决的方案。\n\n因为 Github 在 11月3日的更新中忽略了 `venders` 和 `node_modules` 两个文件夹。于是就打不开 `venders` 目录下的 js 文件了。\n\n那么如何解决呢？`next` 的作者推荐我们修改 `venders` 文件夹名。比如将 `source/venders` 修改成 `source/libs`。同时，修改主题下的配置文件 `_config.yml`,将 `_internal: venders` 修改成之前修改的名字，如 `_internal: libs`。\n\n当然，如果是直接克隆的 `next` 主题，可以通过 `git pull` 直接拉取 `next` 作者的修改。\n\n### 缺少 DTraceProviderBindings 模块\n这是在换了 Mac，重新安装 hexo 后，`hexo g` 时出现的问题。会出现如下 Error 提示：\n\n```\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n\n虽然结果上来说并不影响 hexo 的执行，但是每次都提示还是很让人不爽的。于是，搜索了一下，网上确实有很多讨论这个问题的解决方法的。一般比较多的方式是使用 `npm install hexo --no-optional` 安装 hexo（一般安装还是将 hexo 安装成全局的吧，使用 `-g` 选项）。\n\n但是我用了这个方式后，并没有效果，然后又查了几种方式都不行，就很气。然后就看 hexo 的安装文档，突然灵光一闪。因为现在安装 hexo 的方式变成了 `npm install hexo-cli -g`，那么是不是说原本的  `npm install hexo` 方式已经被废弃了呢？ 于是我就尝试在终端输入 `npm install hexo-cli -g --no-optional`。果然就没有这个 Error 了。\n\n","source":"_posts/hexo爬过的坑.md","raw":"title: hexo 配置遇到的一些坑\ndate: 2016/12/3 14:07:12  \ncategories: Git\ntags: \n\t- Hexo\n\t- 爬坑\n\n---\n\n配置个人博客有时候是一件很蛋疼的事情，经常会出现一些奇奇怪怪的问题。这里我就将把我填上的一些坑总结一下。\n\n<!--more-->\n\n### next主题空白\n这是16年11月份的问题，突然打开自己的博客发现一片空白，但是在本地 `hexo s` 就能够显示出来。原本以为是我远端仓库出了问题，就重建了个新的，但是没有效果。很急很难受。网上搜索真的难，以为我不知道有没有人遇到过这样的问题，并且我也不知道该怎么去描述这个出现的问题。不过，几经波折，还是找到了解决的方案。\n\n因为 Github 在 11月3日的更新中忽略了 `venders` 和 `node_modules` 两个文件夹。于是就打不开 `venders` 目录下的 js 文件了。\n\n那么如何解决呢？`next` 的作者推荐我们修改 `venders` 文件夹名。比如将 `source/venders` 修改成 `source/libs`。同时，修改主题下的配置文件 `_config.yml`,将 `_internal: venders` 修改成之前修改的名字，如 `_internal: libs`。\n\n当然，如果是直接克隆的 `next` 主题，可以通过 `git pull` 直接拉取 `next` 作者的修改。\n\n### 缺少 DTraceProviderBindings 模块\n这是在换了 Mac，重新安装 hexo 后，`hexo g` 时出现的问题。会出现如下 Error 提示：\n\n```\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n\n虽然结果上来说并不影响 hexo 的执行，但是每次都提示还是很让人不爽的。于是，搜索了一下，网上确实有很多讨论这个问题的解决方法的。一般比较多的方式是使用 `npm install hexo --no-optional` 安装 hexo（一般安装还是将 hexo 安装成全局的吧，使用 `-g` 选项）。\n\n但是我用了这个方式后，并没有效果，然后又查了几种方式都不行，就很气。然后就看 hexo 的安装文档，突然灵光一闪。因为现在安装 hexo 的方式变成了 `npm install hexo-cli -g`，那么是不是说原本的  `npm install hexo` 方式已经被废弃了呢？ 于是我就尝试在终端输入 `npm install hexo-cli -g --no-optional`。果然就没有这个 Error 了。\n\n","slug":"hexo爬过的坑","published":1,"updated":"2016-12-10T02:23:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqn002a7hzg2i34ealz","content":"<p>配置个人博客有时候是一件很蛋疼的事情，经常会出现一些奇奇怪怪的问题。这里我就将把我填上的一些坑总结一下。</p>\n<a id=\"more\"></a>\n<h3 id=\"next主题空白\"><a href=\"#next主题空白\" class=\"headerlink\" title=\"next主题空白\"></a>next主题空白</h3><p>这是16年11月份的问题，突然打开自己的博客发现一片空白，但是在本地 <code>hexo s</code> 就能够显示出来。原本以为是我远端仓库出了问题，就重建了个新的，但是没有效果。很急很难受。网上搜索真的难，以为我不知道有没有人遇到过这样的问题，并且我也不知道该怎么去描述这个出现的问题。不过，几经波折，还是找到了解决的方案。</p>\n<p>因为 Github 在 11月3日的更新中忽略了 <code>venders</code> 和 <code>node_modules</code> 两个文件夹。于是就打不开 <code>venders</code> 目录下的 js 文件了。</p>\n<p>那么如何解决呢？<code>next</code> 的作者推荐我们修改 <code>venders</code> 文件夹名。比如将 <code>source/venders</code> 修改成 <code>source/libs</code>。同时，修改主题下的配置文件 <code>_config.yml</code>,将 <code>_internal: venders</code> 修改成之前修改的名字，如 <code>_internal: libs</code>。</p>\n<p>当然，如果是直接克隆的 <code>next</code> 主题，可以通过 <code>git pull</code> 直接拉取 <code>next</code> 作者的修改。</p>\n<h3 id=\"缺少-DTraceProviderBindings-模块\"><a href=\"#缺少-DTraceProviderBindings-模块\" class=\"headerlink\" title=\"缺少 DTraceProviderBindings 模块\"></a>缺少 DTraceProviderBindings 模块</h3><p>这是在换了 Mac，重新安装 hexo 后，<code>hexo g</code> 时出现的问题。会出现如下 Error 提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div></pre></td></tr></table></figure>\n<p>虽然结果上来说并不影响 hexo 的执行，但是每次都提示还是很让人不爽的。于是，搜索了一下，网上确实有很多讨论这个问题的解决方法的。一般比较多的方式是使用 <code>npm install hexo --no-optional</code> 安装 hexo（一般安装还是将 hexo 安装成全局的吧，使用 <code>-g</code> 选项）。</p>\n<p>但是我用了这个方式后，并没有效果，然后又查了几种方式都不行，就很气。然后就看 hexo 的安装文档，突然灵光一闪。因为现在安装 hexo 的方式变成了 <code>npm install hexo-cli -g</code>，那么是不是说原本的  <code>npm install hexo</code> 方式已经被废弃了呢？ 于是我就尝试在终端输入 <code>npm install hexo-cli -g --no-optional</code>。果然就没有这个 Error 了。</p>\n","excerpt":"<p>配置个人博客有时候是一件很蛋疼的事情，经常会出现一些奇奇怪怪的问题。这里我就将把我填上的一些坑总结一下。</p>","more":"<h3 id=\"next主题空白\"><a href=\"#next主题空白\" class=\"headerlink\" title=\"next主题空白\"></a>next主题空白</h3><p>这是16年11月份的问题，突然打开自己的博客发现一片空白，但是在本地 <code>hexo s</code> 就能够显示出来。原本以为是我远端仓库出了问题，就重建了个新的，但是没有效果。很急很难受。网上搜索真的难，以为我不知道有没有人遇到过这样的问题，并且我也不知道该怎么去描述这个出现的问题。不过，几经波折，还是找到了解决的方案。</p>\n<p>因为 Github 在 11月3日的更新中忽略了 <code>venders</code> 和 <code>node_modules</code> 两个文件夹。于是就打不开 <code>venders</code> 目录下的 js 文件了。</p>\n<p>那么如何解决呢？<code>next</code> 的作者推荐我们修改 <code>venders</code> 文件夹名。比如将 <code>source/venders</code> 修改成 <code>source/libs</code>。同时，修改主题下的配置文件 <code>_config.yml</code>,将 <code>_internal: venders</code> 修改成之前修改的名字，如 <code>_internal: libs</code>。</p>\n<p>当然，如果是直接克隆的 <code>next</code> 主题，可以通过 <code>git pull</code> 直接拉取 <code>next</code> 作者的修改。</p>\n<h3 id=\"缺少-DTraceProviderBindings-模块\"><a href=\"#缺少-DTraceProviderBindings-模块\" class=\"headerlink\" title=\"缺少 DTraceProviderBindings 模块\"></a>缺少 DTraceProviderBindings 模块</h3><p>这是在换了 Mac，重新安装 hexo 后，<code>hexo g</code> 时出现的问题。会出现如下 Error 提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div><div class=\"line\">&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;</div></pre></td></tr></table></figure>\n<p>虽然结果上来说并不影响 hexo 的执行，但是每次都提示还是很让人不爽的。于是，搜索了一下，网上确实有很多讨论这个问题的解决方法的。一般比较多的方式是使用 <code>npm install hexo --no-optional</code> 安装 hexo（一般安装还是将 hexo 安装成全局的吧，使用 <code>-g</code> 选项）。</p>\n<p>但是我用了这个方式后，并没有效果，然后又查了几种方式都不行，就很气。然后就看 hexo 的安装文档，突然灵光一闪。因为现在安装 hexo 的方式变成了 <code>npm install hexo-cli -g</code>，那么是不是说原本的  <code>npm install hexo</code> 方式已经被废弃了呢？ 于是我就尝试在终端输入 <code>npm install hexo-cli -g --no-optional</code>。果然就没有这个 Error 了。</p>"},{"title":"ios响应机制","date":"2016-09-03T02:07:12.000Z","_content":"\n从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自[史上最详细的iOS之事件的传递和响应机制\n](http://www.jianshu.com/p/2e074db792ba)\n\n<!--more-->\n\n## iOS中的事件\nios中的事件可以被分为三类：**触摸事件**，**加速计事件**，**远程控制事件**。本文讨论的是触摸事件。\n\n### 响应者对象(UIResponder)\n在iOS中不是任何对象都能处理事件，只有继承了`UIResponder`的对象才能接受并处理事件，我们称之为“响应者对象”。\n\n以下都是继承自`UIResponder`的，所以都能接收并处理事件:\n- UIApplication\n- UIViewController\n- UIView\n\n那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。\n```objc\nUIResponder内部提供了以下方法来处理事件触摸事件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n加速计事件\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n远程控制事件\n- (void)remoteControlReceivedWithEvent:(UIEvent *)event;\n```\n\n## 事件的处理\n### 触摸事件：\n下面以UIView为例来说明触摸事件的处理:\n```objc\n// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件\n// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n// 提示：touches中存放的都是UITouch对象\n```\n需要注意的是：\n- 以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：**如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。**\n- 如果两根手指同时触摸一个view，那么view只会调用一次`touchesBegan:withEvent:`方法，`touches`参数中装着2个`UITouch`对象.\n- 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次`touchesBegan:withEvent:`方法，并且每次调用时的`touches`参数中只包含一个`UITouch`对象.\n\n### UITouch\n当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。\n\n#### UITouch作用\n- 保存着跟手指相关的信息，比如触摸的位置、时间、阶段\n- 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置\n- 当手指离开屏幕时，系统会销毁相应的UITouch对象\n\n#### UITouch属性\n```objc\n触摸产生时所处的窗口\n@property(nonatomic,readonly,retain) UIWindow *window;\n\n触摸产生时所处的视图\n@property(nonatomic,readonly,retain) UIView *view\n;\n\n短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击\n@property(nonatomic,readonly) NSUInteger tapCount;\n\n记录了触摸事件产生或变化时的时间，单位是秒\n@property(nonatomic,readonly) NSTimeInterval timestamp;\n\n当前触摸事件所处的状态\n@property(nonatomic,readonly) UITouchPhase phase;\n```\n\n#### UITouch方法\n```objc\n(CGPoint)locationInView:(UIView *)view;\n// 返回值表示触摸在view上的位置\n// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）\n// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置\n\n(CGPoint)previousLocationInView:(UIView *)view;\n// 该方法记录了前一个触摸点的位置\n```\n\n#### 使用UITouch实现UIView的拖拽\n```objc\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ \n    // 想让控件随着手指移动而移动,监听手指移动 \n    // 获取UITouch对象 \n    UITouch *touch = [touches anyObject]; \n    // 获取当前点的位置 \n    CGPoint curP = [touch locationInView:self]; \n    // 获取上一个点的位置 \n    CGPoint preP = [touch previousLocationInView:self]; \n    // 获取它们x轴的偏移量,每次都是相对上一次 \n    CGFloat offsetX = curP.x - preP.x; \n    // 获取y轴的偏移量 \n    CGFloat offsetY = curP.y - preP.y; \n    // 修改控件的形变或者frame,center,就可以控制控件的位置 \n    // 形变也是相对上一次形变(平移) \n    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 \n    // make:相对于最原始的位置形变 \n    // CGAffineTransform t:相对这个t的形变的基础上再去形变 \n    // 如果相对哪个形变再次形变,就传入它的形变 \n    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);\n}\n```\n通过UITouch对象获得当前点和上一个点的位置，求得偏移量\n\n## iOS中的事件的产生和传递\n### 事件的产生过程\n1. 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。\n2. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。\n3. 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。\n\t1. 首先判断主窗口（keyWindow）自己是否能接受触摸事件。\n\t2. 判断触摸点是否在自己身上。\n\t3. 子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。\n\t4. 如果触摸点在子控件上，那么重复3\n\t5. 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。\n4. 找到最合适的view后，**将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件**。\n\n触摸事件的传递是从父控件传递到子控件,也就是UIApplication->window->寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。\n\n### UIView不能接受触摸事件的三种情况\n- 不允许交互：`userInteractionEnabled = NO`\n- 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件\n- 透明度：如果设置一个控件的透明度<0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。\n\n**注 意**:\n- 默认UIImageView不能接受触摸事件，因为不允许交互，即`userInteractionEnabled = NO`，所以如果希望UIImageView可以交互，需要`userInteractionEnabled = YES`。\n- 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！\n\n### 找到最合适控件的方法\n#### hitTest：withEvent：\n只要事件一传递给一个控件,这个控件就会调用他自己的`hitTest：withEvent：`方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)\n\n#### 拦截事件\n不管点击哪里，最合适的view都是`hitTest：withEvent：`方法中返回的那个view。因此，可以通过重写`hitTest：withEvent：`方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用`[super touchesMoved:touches withEvent:event];`\n\n#### 注意\n- **`hitTest：withEvent：`是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View**\n- 不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用`hitTest:withEvent:`方法。`hitTest`的这个`CGPoint point`表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的`locationInView:`方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。\n- `hitTest：withEvent：`找到最佳View后，会一层层返回，将这个View返回给ViewController。如`hitTest:withEvent:`方法中返回`nil`，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。\n\n#### 技巧\n想让谁成为最合适的view就重写谁自己的父控件的`hitTest:withEvent:`方法返回指定的子控件。这里又要注意，最好不要在子控件内`return self`。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。\n\n例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的`hitTest:withEvent:`方法中`return self.subViews[0]`;这种情况下在redView的`hitTest:withEvent:`方法中`return self;`是不好使的！\n\n#### hitTest:withEvent：的底层实现\n```objc\n#import \"WSWindow.h\"\n@implementation WSWindow\n// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法\n// 作用:寻找并返回最合适的view\n// UIApplication -> [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统\n// point:当前手指触摸的点\n// point:是方法调用者坐标系上的点\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    // 1.判断下窗口能否接收事件\n     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil; \n    // 2.判断下点在不在窗口上 \n    // 不在窗口上 \n    if ([self pointInside:point withEvent:event] == NO) return nil; \n    // 3.从后往前遍历子控件数组 \n    int count = (int)self.subviews.count; \n    for (int i = count - 1; i >= 0; i--) { \n    \t// 获取子控件\n    \tUIView *childView = self.subviews[i]; \n    \t// 坐标系的转换,把窗口上的点转换为子控件上的点 \n    \t// 把自己控件上的点转换成子控件上的点 \n    \tCGPoint childP = [self convertPoint:point toView:childView]; \n    \tUIView *fitView = [childView hitTest:childP withEvent:event]; \n    \tif (fitView) {\n    \t\t// 如果能找到最合适的view \n    \t\treturn fitView; \n    \t}\n    } \n    // 4.没有找到更合适的view，也就是没有比自己更合适的view \n    return self;\n}\n// 作用:判断下传入过来的点在不在方法调用者的坐标系上\n// point:是方法调用者坐标系上的点\n//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n//\t\treturn NO;\n//}\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n    NSLog(@\"%s\",__func__);\n}\n@end\n```\n\n`hit:withEvent:`方法底层会调用`pointInside:withEvent:`方法判断点在不在方法调用者的坐标系上。\n\n#### pointInside:withEvent:方法\n`pointInside:withEvent:`方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。\n\n\n## 事件的响应\n### 事件的传递与响应区别\n前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -> UIWindow -> UIView -> initial view,以上就是事件的传递，也就是寻找最合适的view的过程。\n\n在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了`touches...`方法，则这个事件将由该控件来接受，如果调用了`[super touches….]`;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的`touches….`方法。\n\ntouches默认做法是把事件顺着响应者链条向上抛：\n```objc\n#import \"WSView.h\"\n@implementation WSView \n//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件\n// 上一个响应者可能是父控件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理\n\t[super touchesBegan:touches withEvent:event]; \n\t// 注意不是调用父控件的touches方法，而是调用父类的touches方法\n\t// super是父类 superview是父控件 \n\t// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。\n}\n@end\n```\n\n事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。\n\n**注意：**ViewController中如果自定义了`touchesBegan:withEvent:`方法，任何情况都会执行。只有在UIView中定义的`touchesBegan:withEvent:`方法，才会根据`hitTest：withEvent：`的不同返回，执行返回View的`touchesBegan:withEvent:`方法。估计是因为UIViewController中没有`hitTest：withEvent：`方法的缘故。\n\n### 一个事件多个对象处理\n因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 1.自己先处理事件...\n\tNSLog(@\"do somthing...\");\n\t// 2.再调用系统的默认做法，再把事件交给上一个响应者处理\n\t[super touchesBegan:touches withEvent:event]; \n}\n```\n\n\n\n>Demo 请看UIGestureRecognizer\n\n\n\n\n\n\n\n\n","source":"_posts/ios响应事件.md","raw":"title: ios响应机制\ndate: 2016/9/3 10:07:12  \ncategories: iOS\ntags:\n\t- UIResponder\n\n---\n\n从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自[史上最详细的iOS之事件的传递和响应机制\n](http://www.jianshu.com/p/2e074db792ba)\n\n<!--more-->\n\n## iOS中的事件\nios中的事件可以被分为三类：**触摸事件**，**加速计事件**，**远程控制事件**。本文讨论的是触摸事件。\n\n### 响应者对象(UIResponder)\n在iOS中不是任何对象都能处理事件，只有继承了`UIResponder`的对象才能接受并处理事件，我们称之为“响应者对象”。\n\n以下都是继承自`UIResponder`的，所以都能接收并处理事件:\n- UIApplication\n- UIViewController\n- UIView\n\n那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。\n```objc\nUIResponder内部提供了以下方法来处理事件触摸事件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n加速计事件\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n远程控制事件\n- (void)remoteControlReceivedWithEvent:(UIEvent *)event;\n```\n\n## 事件的处理\n### 触摸事件：\n下面以UIView为例来说明触摸事件的处理:\n```objc\n// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件\n// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n// 提示：touches中存放的都是UITouch对象\n```\n需要注意的是：\n- 以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：**如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。**\n- 如果两根手指同时触摸一个view，那么view只会调用一次`touchesBegan:withEvent:`方法，`touches`参数中装着2个`UITouch`对象.\n- 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次`touchesBegan:withEvent:`方法，并且每次调用时的`touches`参数中只包含一个`UITouch`对象.\n\n### UITouch\n当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。\n\n#### UITouch作用\n- 保存着跟手指相关的信息，比如触摸的位置、时间、阶段\n- 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置\n- 当手指离开屏幕时，系统会销毁相应的UITouch对象\n\n#### UITouch属性\n```objc\n触摸产生时所处的窗口\n@property(nonatomic,readonly,retain) UIWindow *window;\n\n触摸产生时所处的视图\n@property(nonatomic,readonly,retain) UIView *view\n;\n\n短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击\n@property(nonatomic,readonly) NSUInteger tapCount;\n\n记录了触摸事件产生或变化时的时间，单位是秒\n@property(nonatomic,readonly) NSTimeInterval timestamp;\n\n当前触摸事件所处的状态\n@property(nonatomic,readonly) UITouchPhase phase;\n```\n\n#### UITouch方法\n```objc\n(CGPoint)locationInView:(UIView *)view;\n// 返回值表示触摸在view上的位置\n// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）\n// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置\n\n(CGPoint)previousLocationInView:(UIView *)view;\n// 该方法记录了前一个触摸点的位置\n```\n\n#### 使用UITouch实现UIView的拖拽\n```objc\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ \n    // 想让控件随着手指移动而移动,监听手指移动 \n    // 获取UITouch对象 \n    UITouch *touch = [touches anyObject]; \n    // 获取当前点的位置 \n    CGPoint curP = [touch locationInView:self]; \n    // 获取上一个点的位置 \n    CGPoint preP = [touch previousLocationInView:self]; \n    // 获取它们x轴的偏移量,每次都是相对上一次 \n    CGFloat offsetX = curP.x - preP.x; \n    // 获取y轴的偏移量 \n    CGFloat offsetY = curP.y - preP.y; \n    // 修改控件的形变或者frame,center,就可以控制控件的位置 \n    // 形变也是相对上一次形变(平移) \n    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 \n    // make:相对于最原始的位置形变 \n    // CGAffineTransform t:相对这个t的形变的基础上再去形变 \n    // 如果相对哪个形变再次形变,就传入它的形变 \n    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);\n}\n```\n通过UITouch对象获得当前点和上一个点的位置，求得偏移量\n\n## iOS中的事件的产生和传递\n### 事件的产生过程\n1. 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。\n2. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。\n3. 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。\n\t1. 首先判断主窗口（keyWindow）自己是否能接受触摸事件。\n\t2. 判断触摸点是否在自己身上。\n\t3. 子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。\n\t4. 如果触摸点在子控件上，那么重复3\n\t5. 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。\n4. 找到最合适的view后，**将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件**。\n\n触摸事件的传递是从父控件传递到子控件,也就是UIApplication->window->寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。\n\n### UIView不能接受触摸事件的三种情况\n- 不允许交互：`userInteractionEnabled = NO`\n- 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件\n- 透明度：如果设置一个控件的透明度<0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。\n\n**注 意**:\n- 默认UIImageView不能接受触摸事件，因为不允许交互，即`userInteractionEnabled = NO`，所以如果希望UIImageView可以交互，需要`userInteractionEnabled = YES`。\n- 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！\n\n### 找到最合适控件的方法\n#### hitTest：withEvent：\n只要事件一传递给一个控件,这个控件就会调用他自己的`hitTest：withEvent：`方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)\n\n#### 拦截事件\n不管点击哪里，最合适的view都是`hitTest：withEvent：`方法中返回的那个view。因此，可以通过重写`hitTest：withEvent：`方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用`[super touchesMoved:touches withEvent:event];`\n\n#### 注意\n- **`hitTest：withEvent：`是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View**\n- 不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用`hitTest:withEvent:`方法。`hitTest`的这个`CGPoint point`表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的`locationInView:`方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。\n- `hitTest：withEvent：`找到最佳View后，会一层层返回，将这个View返回给ViewController。如`hitTest:withEvent:`方法中返回`nil`，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。\n\n#### 技巧\n想让谁成为最合适的view就重写谁自己的父控件的`hitTest:withEvent:`方法返回指定的子控件。这里又要注意，最好不要在子控件内`return self`。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。\n\n例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的`hitTest:withEvent:`方法中`return self.subViews[0]`;这种情况下在redView的`hitTest:withEvent:`方法中`return self;`是不好使的！\n\n#### hitTest:withEvent：的底层实现\n```objc\n#import \"WSWindow.h\"\n@implementation WSWindow\n// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法\n// 作用:寻找并返回最合适的view\n// UIApplication -> [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统\n// point:当前手指触摸的点\n// point:是方法调用者坐标系上的点\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    // 1.判断下窗口能否接收事件\n     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil; \n    // 2.判断下点在不在窗口上 \n    // 不在窗口上 \n    if ([self pointInside:point withEvent:event] == NO) return nil; \n    // 3.从后往前遍历子控件数组 \n    int count = (int)self.subviews.count; \n    for (int i = count - 1; i >= 0; i--) { \n    \t// 获取子控件\n    \tUIView *childView = self.subviews[i]; \n    \t// 坐标系的转换,把窗口上的点转换为子控件上的点 \n    \t// 把自己控件上的点转换成子控件上的点 \n    \tCGPoint childP = [self convertPoint:point toView:childView]; \n    \tUIView *fitView = [childView hitTest:childP withEvent:event]; \n    \tif (fitView) {\n    \t\t// 如果能找到最合适的view \n    \t\treturn fitView; \n    \t}\n    } \n    // 4.没有找到更合适的view，也就是没有比自己更合适的view \n    return self;\n}\n// 作用:判断下传入过来的点在不在方法调用者的坐标系上\n// point:是方法调用者坐标系上的点\n//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n//\t\treturn NO;\n//}\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n    NSLog(@\"%s\",__func__);\n}\n@end\n```\n\n`hit:withEvent:`方法底层会调用`pointInside:withEvent:`方法判断点在不在方法调用者的坐标系上。\n\n#### pointInside:withEvent:方法\n`pointInside:withEvent:`方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。\n\n\n## 事件的响应\n### 事件的传递与响应区别\n前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -> UIWindow -> UIView -> initial view,以上就是事件的传递，也就是寻找最合适的view的过程。\n\n在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了`touches...`方法，则这个事件将由该控件来接受，如果调用了`[super touches….]`;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的`touches….`方法。\n\ntouches默认做法是把事件顺着响应者链条向上抛：\n```objc\n#import \"WSView.h\"\n@implementation WSView \n//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件\n// 上一个响应者可能是父控件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理\n\t[super touchesBegan:touches withEvent:event]; \n\t// 注意不是调用父控件的touches方法，而是调用父类的touches方法\n\t// super是父类 superview是父控件 \n\t// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。\n}\n@end\n```\n\n事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。\n\n**注意：**ViewController中如果自定义了`touchesBegan:withEvent:`方法，任何情况都会执行。只有在UIView中定义的`touchesBegan:withEvent:`方法，才会根据`hitTest：withEvent：`的不同返回，执行返回View的`touchesBegan:withEvent:`方法。估计是因为UIViewController中没有`hitTest：withEvent：`方法的缘故。\n\n### 一个事件多个对象处理\n因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 1.自己先处理事件...\n\tNSLog(@\"do somthing...\");\n\t// 2.再调用系统的默认做法，再把事件交给上一个响应者处理\n\t[super touchesBegan:touches withEvent:event]; \n}\n```\n\n\n\n>Demo 请看UIGestureRecognizer\n\n\n\n\n\n\n\n\n","slug":"ios响应事件","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqq002d7hzguja8exh6","content":"<p>从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自<a href=\"http://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"external\">史上最详细的iOS之事件的传递和响应机制\n</a></p>\n<a id=\"more\"></a>\n<h2 id=\"iOS中的事件\"><a href=\"#iOS中的事件\" class=\"headerlink\" title=\"iOS中的事件\"></a>iOS中的事件</h2><p>ios中的事件可以被分为三类：<strong>触摸事件</strong>，<strong>加速计事件</strong>，<strong>远程控制事件</strong>。本文讨论的是触摸事件。</p>\n<h3 id=\"响应者对象-UIResponder\"><a href=\"#响应者对象-UIResponder\" class=\"headerlink\" title=\"响应者对象(UIResponder)\"></a>响应者对象(UIResponder)</h3><p>在iOS中不是任何对象都能处理事件，只有继承了<code>UIResponder</code>的对象才能接受并处理事件，我们称之为“响应者对象”。</p>\n<p>以下都是继承自<code>UIResponder</code>的，所以都能接收并处理事件:</p>\n<ul>\n<li>UIApplication</li>\n<li>UIViewController</li>\n<li>UIView</li>\n</ul>\n<p>那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIResponder</span>内部提供了以下方法来处理事件触摸事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">加速计事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionBegan:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionEnded:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionCancelled:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">远程控制事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)remoteControlReceivedWithEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件的处理\"><a href=\"#事件的处理\" class=\"headerlink\" title=\"事件的处理\"></a>事件的处理</h2><h3 id=\"触摸事件：\"><a href=\"#触摸事件：\" class=\"headerlink\" title=\"触摸事件：\"></a>触摸事件：</h3><p>下面以UIView为例来说明触摸事件的处理:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</span></div><div class=\"line\"><span class=\"comment\">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 提示：touches中存放的都是UITouch对象</span></div></pre></td></tr></table></figure></p>\n<p>需要注意的是：</p>\n<ul>\n<li>以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：<strong>如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。</strong></li>\n<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，<code>touches</code>参数中装着2个<code>UITouch</code>对象.</li>\n<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的<code>touches</code>参数中只包含一个<code>UITouch</code>对象.</li>\n</ul>\n<h3 id=\"UITouch\"><a href=\"#UITouch\" class=\"headerlink\" title=\"UITouch\"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。</p>\n<h4 id=\"UITouch作用\"><a href=\"#UITouch作用\" class=\"headerlink\" title=\"UITouch作用\"></a>UITouch作用</h4><ul>\n<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>\n<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>\n<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>\n</ul>\n<h4 id=\"UITouch属性\"><a href=\"#UITouch属性\" class=\"headerlink\" title=\"UITouch属性\"></a>UITouch属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">触摸产生时所处的窗口</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIWindow</span> *window;</div><div class=\"line\"></div><div class=\"line\">触摸产生时所处的视图</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIView</span> *view</div><div class=\"line\">;</div><div class=\"line\"></div><div class=\"line\">短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> tapCount;</div><div class=\"line\"></div><div class=\"line\">记录了触摸事件产生或变化时的时间，单位是秒</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> timestamp;</div><div class=\"line\"></div><div class=\"line\">当前触摸事件所处的状态</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UITouchPhase</span> phase;</div></pre></td></tr></table></figure>\n<h4 id=\"UITouch方法\"><a href=\"#UITouch方法\" class=\"headerlink\" title=\"UITouch方法\"></a>UITouch方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 返回值表示触摸在view上的位置</span></div><div class=\"line\"><span class=\"comment\">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></div><div class=\"line\"><span class=\"comment\">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)previousLocationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 该方法记录了前一个触摸点的位置</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用UITouch实现UIView的拖拽\"><a href=\"#使用UITouch实现UIView的拖拽\" class=\"headerlink\" title=\"使用UITouch实现UIView的拖拽\"></a>使用UITouch实现UIView的拖拽</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"comment\">// 想让控件随着手指移动而移动,监听手指移动 </span></div><div class=\"line\">    <span class=\"comment\">// 获取UITouch对象 </span></div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject]; </div><div class=\"line\">    <span class=\"comment\">// 获取当前点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> curP = [touch locationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取上一个点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> preP = [touch previousLocationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取它们x轴的偏移量,每次都是相对上一次 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetX = curP.x - preP.x; </div><div class=\"line\">    <span class=\"comment\">// 获取y轴的偏移量 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = curP.y - preP.y; </div><div class=\"line\">    <span class=\"comment\">// 修改控件的形变或者frame,center,就可以控制控件的位置 </span></div><div class=\"line\">    <span class=\"comment\">// 形变也是相对上一次形变(平移) </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 </span></div><div class=\"line\">    <span class=\"comment\">// make:相对于最原始的位置形变 </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransform t:相对这个t的形变的基础上再去形变 </span></div><div class=\"line\">    <span class=\"comment\">// 如果相对哪个形变再次形变,就传入它的形变 </span></div><div class=\"line\">    <span class=\"keyword\">self</span>.transform = <span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"keyword\">self</span>.transform, offsetX, offsetY);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过UITouch对象获得当前点和上一个点的位置，求得偏移量</p>\n<h2 id=\"iOS中的事件的产生和传递\"><a href=\"#iOS中的事件的产生和传递\" class=\"headerlink\" title=\"iOS中的事件的产生和传递\"></a>iOS中的事件的产生和传递</h2><h3 id=\"事件的产生过程\"><a href=\"#事件的产生过程\" class=\"headerlink\" title=\"事件的产生过程\"></a>事件的产生过程</h3><ol>\n<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>\n<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>\n<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<ol>\n<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件。</li>\n<li>判断触摸点是否在自己身上。</li>\n<li>子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。</li>\n<li>如果触摸点在子控件上，那么重复3</li>\n<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li>\n</ol>\n</li>\n<li>找到最合适的view后，<strong>将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件</strong>。</li>\n</ol>\n<p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。</p>\n<h3 id=\"UIView不能接受触摸事件的三种情况\"><a href=\"#UIView不能接受触摸事件的三种情况\" class=\"headerlink\" title=\"UIView不能接受触摸事件的三种情况\"></a>UIView不能接受触摸事件的三种情况</h3><ul>\n<li>不允许交互：<code>userInteractionEnabled = NO</code></li>\n<li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>\n<li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>\n</ul>\n<p><strong>注 意</strong>:</p>\n<ul>\n<li>默认UIImageView不能接受触摸事件，因为不允许交互，即<code>userInteractionEnabled = NO</code>，所以如果希望UIImageView可以交互，需要<code>userInteractionEnabled = YES</code>。</li>\n<li>不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！</li>\n</ul>\n<h3 id=\"找到最合适控件的方法\"><a href=\"#找到最合适控件的方法\" class=\"headerlink\" title=\"找到最合适控件的方法\"></a>找到最合适控件的方法</h3><h4 id=\"hitTest：withEvent：\"><a href=\"#hitTest：withEvent：\" class=\"headerlink\" title=\"hitTest：withEvent：\"></a>hitTest：withEvent：</h4><p>只要事件一传递给一个控件,这个控件就会调用他自己的<code>hitTest：withEvent：</code>方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)</p>\n<h4 id=\"拦截事件\"><a href=\"#拦截事件\" class=\"headerlink\" title=\"拦截事件\"></a>拦截事件</h4><p>不管点击哪里，最合适的view都是<code>hitTest：withEvent：</code>方法中返回的那个view。因此，可以通过重写<code>hitTest：withEvent：</code>方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用<code>[super touchesMoved:touches withEvent:event];</code></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><strong><code>hitTest：withEvent：</code>是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View</strong></li>\n<li>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用<code>hitTest:withEvent:</code>方法。<code>hitTest</code>的这个<code>CGPoint point</code>表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的<code>locationInView:</code>方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。</li>\n<li><code>hitTest：withEvent：</code>找到最佳View后，会一层层返回，将这个View返回给ViewController。如<code>hitTest:withEvent:</code>方法中返回<code>nil</code>，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</li>\n</ul>\n<h4 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的<code>hitTest:withEvent:</code>方法返回指定的子控件。这里又要注意，最好不要在子控件内<code>return self</code>。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。</p>\n<p>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的<code>hitTest:withEvent:</code>方法中<code>return self.subViews[0]</code>;这种情况下在redView的<code>hitTest:withEvent:</code>方法中<code>return self;</code>是不好使的！</p>\n<h4 id=\"hitTest-withEvent：的底层实现\"><a href=\"#hitTest-withEvent：的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent：的底层实现\"></a>hitTest:withEvent：的底层实现</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSWindow.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSWindow</span></span></div><div class=\"line\"><span class=\"comment\">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span></div><div class=\"line\"><span class=\"comment\">// 作用:寻找并返回最合适的view</span></div><div class=\"line\"><span class=\"comment\">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span></div><div class=\"line\"><span class=\"comment\">// point:当前手指触摸的点</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.判断下窗口能否接收事件</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.userInteractionEnabled == <span class=\"literal\">NO</span> || <span class=\"keyword\">self</span>.hidden == <span class=\"literal\">YES</span> ||  <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 2.判断下点在不在窗口上 </span></div><div class=\"line\">    <span class=\"comment\">// 不在窗口上 </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> pointInside:point withEvent:event] == <span class=\"literal\">NO</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 3.从后往前遍历子控件数组 </span></div><div class=\"line\">    <span class=\"keyword\">int</span> count = (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.subviews.count; </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; </div><div class=\"line\">    \t<span class=\"comment\">// 获取子控件</span></div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *childView = <span class=\"keyword\">self</span>.subviews[i]; </div><div class=\"line\">    \t<span class=\"comment\">// 坐标系的转换,把窗口上的点转换为子控件上的点 </span></div><div class=\"line\">    \t<span class=\"comment\">// 把自己控件上的点转换成子控件上的点 </span></div><div class=\"line\">    \t<span class=\"built_in\">CGPoint</span> childP = [<span class=\"keyword\">self</span> convertPoint:point toView:childView]; </div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *fitView = [childView hitTest:childP withEvent:event]; </div><div class=\"line\">    \t<span class=\"keyword\">if</span> (fitView) &#123;</div><div class=\"line\">    \t\t<span class=\"comment\">// 如果能找到最合适的view </span></div><div class=\"line\">    \t\t<span class=\"keyword\">return</span> fitView; </div><div class=\"line\">    \t&#125;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// 4.没有找到更合适的view，也就是没有比自己更合适的view </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\"><span class=\"comment\">//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span></div><div class=\"line\"><span class=\"comment\">//\t\treturn NO;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>hit:withEvent:</code>方法底层会调用<code>pointInside:withEvent:</code>方法判断点在不在方法调用者的坐标系上。</p>\n<h4 id=\"pointInside-withEvent-方法\"><a href=\"#pointInside-withEvent-方法\" class=\"headerlink\" title=\"pointInside:withEvent:方法\"></a>pointInside:withEvent:方法</h4><p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>\n<h2 id=\"事件的响应\"><a href=\"#事件的响应\" class=\"headerlink\" title=\"事件的响应\"></a>事件的响应</h2><h3 id=\"事件的传递与响应区别\"><a href=\"#事件的传递与响应区别\" class=\"headerlink\" title=\"事件的传递与响应区别\"></a>事件的传递与响应区别</h3><p>前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>\n<p>在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了<code>touches...</code>方法，则这个事件将由该控件来接受，如果调用了<code>[super touches….]</code>;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的<code>touches….</code>方法。</p>\n<p>touches默认做法是把事件顺着响应者链条向上抛：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSView.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSView</span> </span></div><div class=\"line\"><span class=\"comment\">//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 上一个响应者可能是父控件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">\t<span class=\"comment\">// 注意不是调用父控件的touches方法，而是调用父类的touches方法</span></div><div class=\"line\">\t<span class=\"comment\">// super是父类 superview是父控件 </span></div><div class=\"line\">\t<span class=\"comment\">// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>\n<p><strong>注意：</strong>ViewController中如果自定义了<code>touchesBegan:withEvent:</code>方法，任何情况都会执行。只有在UIView中定义的<code>touchesBegan:withEvent:</code>方法，才会根据<code>hitTest：withEvent：</code>的不同返回，执行返回View的<code>touchesBegan:withEvent:</code>方法。估计是因为UIViewController中没有<code>hitTest：withEvent：</code>方法的缘故。</p>\n<h3 id=\"一个事件多个对象处理\"><a href=\"#一个事件多个对象处理\" class=\"headerlink\" title=\"一个事件多个对象处理\"></a>一个事件多个对象处理</h3><p>因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 1.自己先处理事件...</span></div><div class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"do somthing...\"</span>);</div><div class=\"line\">\t<span class=\"comment\">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo 请看UIGestureRecognizer</p>\n</blockquote>\n","excerpt":"<p>从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自<a href=\"http://www.jianshu.com/p/2e074db792ba\">史上最详细的iOS之事件的传递和响应机制\n</a></p>","more":"<h2 id=\"iOS中的事件\"><a href=\"#iOS中的事件\" class=\"headerlink\" title=\"iOS中的事件\"></a>iOS中的事件</h2><p>ios中的事件可以被分为三类：<strong>触摸事件</strong>，<strong>加速计事件</strong>，<strong>远程控制事件</strong>。本文讨论的是触摸事件。</p>\n<h3 id=\"响应者对象-UIResponder\"><a href=\"#响应者对象-UIResponder\" class=\"headerlink\" title=\"响应者对象(UIResponder)\"></a>响应者对象(UIResponder)</h3><p>在iOS中不是任何对象都能处理事件，只有继承了<code>UIResponder</code>的对象才能接受并处理事件，我们称之为“响应者对象”。</p>\n<p>以下都是继承自<code>UIResponder</code>的，所以都能接收并处理事件:</p>\n<ul>\n<li>UIApplication</li>\n<li>UIViewController</li>\n<li>UIView</li>\n</ul>\n<p>那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIResponder</span>内部提供了以下方法来处理事件触摸事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">加速计事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionBegan:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionEnded:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionCancelled:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">远程控制事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)remoteControlReceivedWithEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件的处理\"><a href=\"#事件的处理\" class=\"headerlink\" title=\"事件的处理\"></a>事件的处理</h2><h3 id=\"触摸事件：\"><a href=\"#触摸事件：\" class=\"headerlink\" title=\"触摸事件：\"></a>触摸事件：</h3><p>下面以UIView为例来说明触摸事件的处理:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</span></div><div class=\"line\"><span class=\"comment\">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 提示：touches中存放的都是UITouch对象</span></div></pre></td></tr></table></figure></p>\n<p>需要注意的是：</p>\n<ul>\n<li>以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：<strong>如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。</strong></li>\n<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，<code>touches</code>参数中装着2个<code>UITouch</code>对象.</li>\n<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的<code>touches</code>参数中只包含一个<code>UITouch</code>对象.</li>\n</ul>\n<h3 id=\"UITouch\"><a href=\"#UITouch\" class=\"headerlink\" title=\"UITouch\"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。</p>\n<h4 id=\"UITouch作用\"><a href=\"#UITouch作用\" class=\"headerlink\" title=\"UITouch作用\"></a>UITouch作用</h4><ul>\n<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>\n<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>\n<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>\n</ul>\n<h4 id=\"UITouch属性\"><a href=\"#UITouch属性\" class=\"headerlink\" title=\"UITouch属性\"></a>UITouch属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">触摸产生时所处的窗口</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIWindow</span> *window;</div><div class=\"line\"></div><div class=\"line\">触摸产生时所处的视图</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIView</span> *view</div><div class=\"line\">;</div><div class=\"line\"></div><div class=\"line\">短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> tapCount;</div><div class=\"line\"></div><div class=\"line\">记录了触摸事件产生或变化时的时间，单位是秒</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> timestamp;</div><div class=\"line\"></div><div class=\"line\">当前触摸事件所处的状态</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UITouchPhase</span> phase;</div></pre></td></tr></table></figure>\n<h4 id=\"UITouch方法\"><a href=\"#UITouch方法\" class=\"headerlink\" title=\"UITouch方法\"></a>UITouch方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 返回值表示触摸在view上的位置</span></div><div class=\"line\"><span class=\"comment\">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></div><div class=\"line\"><span class=\"comment\">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)previousLocationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 该方法记录了前一个触摸点的位置</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用UITouch实现UIView的拖拽\"><a href=\"#使用UITouch实现UIView的拖拽\" class=\"headerlink\" title=\"使用UITouch实现UIView的拖拽\"></a>使用UITouch实现UIView的拖拽</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"comment\">// 想让控件随着手指移动而移动,监听手指移动 </span></div><div class=\"line\">    <span class=\"comment\">// 获取UITouch对象 </span></div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject]; </div><div class=\"line\">    <span class=\"comment\">// 获取当前点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> curP = [touch locationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取上一个点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> preP = [touch previousLocationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取它们x轴的偏移量,每次都是相对上一次 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetX = curP.x - preP.x; </div><div class=\"line\">    <span class=\"comment\">// 获取y轴的偏移量 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = curP.y - preP.y; </div><div class=\"line\">    <span class=\"comment\">// 修改控件的形变或者frame,center,就可以控制控件的位置 </span></div><div class=\"line\">    <span class=\"comment\">// 形变也是相对上一次形变(平移) </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 </span></div><div class=\"line\">    <span class=\"comment\">// make:相对于最原始的位置形变 </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransform t:相对这个t的形变的基础上再去形变 </span></div><div class=\"line\">    <span class=\"comment\">// 如果相对哪个形变再次形变,就传入它的形变 </span></div><div class=\"line\">    <span class=\"keyword\">self</span>.transform = <span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"keyword\">self</span>.transform, offsetX, offsetY);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过UITouch对象获得当前点和上一个点的位置，求得偏移量</p>\n<h2 id=\"iOS中的事件的产生和传递\"><a href=\"#iOS中的事件的产生和传递\" class=\"headerlink\" title=\"iOS中的事件的产生和传递\"></a>iOS中的事件的产生和传递</h2><h3 id=\"事件的产生过程\"><a href=\"#事件的产生过程\" class=\"headerlink\" title=\"事件的产生过程\"></a>事件的产生过程</h3><ol>\n<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>\n<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>\n<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<ol>\n<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件。</li>\n<li>判断触摸点是否在自己身上。</li>\n<li>子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。</li>\n<li>如果触摸点在子控件上，那么重复3</li>\n<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li>\n</ol>\n</li>\n<li>找到最合适的view后，<strong>将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件</strong>。</li>\n</ol>\n<p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。</p>\n<h3 id=\"UIView不能接受触摸事件的三种情况\"><a href=\"#UIView不能接受触摸事件的三种情况\" class=\"headerlink\" title=\"UIView不能接受触摸事件的三种情况\"></a>UIView不能接受触摸事件的三种情况</h3><ul>\n<li>不允许交互：<code>userInteractionEnabled = NO</code></li>\n<li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>\n<li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>\n</ul>\n<p><strong>注 意</strong>:</p>\n<ul>\n<li>默认UIImageView不能接受触摸事件，因为不允许交互，即<code>userInteractionEnabled = NO</code>，所以如果希望UIImageView可以交互，需要<code>userInteractionEnabled = YES</code>。</li>\n<li>不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！</li>\n</ul>\n<h3 id=\"找到最合适控件的方法\"><a href=\"#找到最合适控件的方法\" class=\"headerlink\" title=\"找到最合适控件的方法\"></a>找到最合适控件的方法</h3><h4 id=\"hitTest：withEvent：\"><a href=\"#hitTest：withEvent：\" class=\"headerlink\" title=\"hitTest：withEvent：\"></a>hitTest：withEvent：</h4><p>只要事件一传递给一个控件,这个控件就会调用他自己的<code>hitTest：withEvent：</code>方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)</p>\n<h4 id=\"拦截事件\"><a href=\"#拦截事件\" class=\"headerlink\" title=\"拦截事件\"></a>拦截事件</h4><p>不管点击哪里，最合适的view都是<code>hitTest：withEvent：</code>方法中返回的那个view。因此，可以通过重写<code>hitTest：withEvent：</code>方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用<code>[super touchesMoved:touches withEvent:event];</code></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><strong><code>hitTest：withEvent：</code>是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View</strong></li>\n<li>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用<code>hitTest:withEvent:</code>方法。<code>hitTest</code>的这个<code>CGPoint point</code>表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的<code>locationInView:</code>方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。</li>\n<li><code>hitTest：withEvent：</code>找到最佳View后，会一层层返回，将这个View返回给ViewController。如<code>hitTest:withEvent:</code>方法中返回<code>nil</code>，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</li>\n</ul>\n<h4 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的<code>hitTest:withEvent:</code>方法返回指定的子控件。这里又要注意，最好不要在子控件内<code>return self</code>。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。</p>\n<p>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的<code>hitTest:withEvent:</code>方法中<code>return self.subViews[0]</code>;这种情况下在redView的<code>hitTest:withEvent:</code>方法中<code>return self;</code>是不好使的！</p>\n<h4 id=\"hitTest-withEvent：的底层实现\"><a href=\"#hitTest-withEvent：的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent：的底层实现\"></a>hitTest:withEvent：的底层实现</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSWindow.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSWindow</span></span></div><div class=\"line\"><span class=\"comment\">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span></div><div class=\"line\"><span class=\"comment\">// 作用:寻找并返回最合适的view</span></div><div class=\"line\"><span class=\"comment\">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span></div><div class=\"line\"><span class=\"comment\">// point:当前手指触摸的点</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.判断下窗口能否接收事件</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.userInteractionEnabled == <span class=\"literal\">NO</span> || <span class=\"keyword\">self</span>.hidden == <span class=\"literal\">YES</span> ||  <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 2.判断下点在不在窗口上 </span></div><div class=\"line\">    <span class=\"comment\">// 不在窗口上 </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> pointInside:point withEvent:event] == <span class=\"literal\">NO</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 3.从后往前遍历子控件数组 </span></div><div class=\"line\">    <span class=\"keyword\">int</span> count = (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.subviews.count; </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; </div><div class=\"line\">    \t<span class=\"comment\">// 获取子控件</span></div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *childView = <span class=\"keyword\">self</span>.subviews[i]; </div><div class=\"line\">    \t<span class=\"comment\">// 坐标系的转换,把窗口上的点转换为子控件上的点 </span></div><div class=\"line\">    \t<span class=\"comment\">// 把自己控件上的点转换成子控件上的点 </span></div><div class=\"line\">    \t<span class=\"built_in\">CGPoint</span> childP = [<span class=\"keyword\">self</span> convertPoint:point toView:childView]; </div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *fitView = [childView hitTest:childP withEvent:event]; </div><div class=\"line\">    \t<span class=\"keyword\">if</span> (fitView) &#123;</div><div class=\"line\">    \t\t<span class=\"comment\">// 如果能找到最合适的view </span></div><div class=\"line\">    \t\t<span class=\"keyword\">return</span> fitView; </div><div class=\"line\">    \t&#125;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// 4.没有找到更合适的view，也就是没有比自己更合适的view </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\"><span class=\"comment\">//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span></div><div class=\"line\"><span class=\"comment\">//\t\treturn NO;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>hit:withEvent:</code>方法底层会调用<code>pointInside:withEvent:</code>方法判断点在不在方法调用者的坐标系上。</p>\n<h4 id=\"pointInside-withEvent-方法\"><a href=\"#pointInside-withEvent-方法\" class=\"headerlink\" title=\"pointInside:withEvent:方法\"></a>pointInside:withEvent:方法</h4><p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>\n<h2 id=\"事件的响应\"><a href=\"#事件的响应\" class=\"headerlink\" title=\"事件的响应\"></a>事件的响应</h2><h3 id=\"事件的传递与响应区别\"><a href=\"#事件的传递与响应区别\" class=\"headerlink\" title=\"事件的传递与响应区别\"></a>事件的传递与响应区别</h3><p>前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>\n<p>在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了<code>touches...</code>方法，则这个事件将由该控件来接受，如果调用了<code>[super touches….]</code>;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的<code>touches….</code>方法。</p>\n<p>touches默认做法是把事件顺着响应者链条向上抛：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSView.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSView</span> </span></div><div class=\"line\"><span class=\"comment\">//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 上一个响应者可能是父控件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">\t<span class=\"comment\">// 注意不是调用父控件的touches方法，而是调用父类的touches方法</span></div><div class=\"line\">\t<span class=\"comment\">// super是父类 superview是父控件 </span></div><div class=\"line\">\t<span class=\"comment\">// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>\n<p><strong>注意：</strong>ViewController中如果自定义了<code>touchesBegan:withEvent:</code>方法，任何情况都会执行。只有在UIView中定义的<code>touchesBegan:withEvent:</code>方法，才会根据<code>hitTest：withEvent：</code>的不同返回，执行返回View的<code>touchesBegan:withEvent:</code>方法。估计是因为UIViewController中没有<code>hitTest：withEvent：</code>方法的缘故。</p>\n<h3 id=\"一个事件多个对象处理\"><a href=\"#一个事件多个对象处理\" class=\"headerlink\" title=\"一个事件多个对象处理\"></a>一个事件多个对象处理</h3><p>因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 1.自己先处理事件...</span></div><div class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"do somthing...\"</span>);</div><div class=\"line\">\t<span class=\"comment\">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo 请看UIGestureRecognizer</p>\n</blockquote>"},{"title":"iOS中的多线程学习笔记","date":"2016-11-01T06:07:12.000Z","_content":"\n在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。\n<!--more-->\n\n可以通过三种方式实现 iOS 的多线程：\n- NSThread\n- GCD\n- NSOperation&NSOperationQueue\n\n## NSThread\n### 创建并启动\n#### 先创建线程类，再启动\n\n```objc\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n// 启动\n[thread start];\n```\n\n其中，`run:` 是即将执行的方法，`object` 是 `run:` 方法的参数。规定 `run:` 方法最多可有一个参数，且返回类型必须是 `void`。\n\n#### 创建并自动启动\n\n```objc\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n```\n\n#### 使用 NSObject 的方法创建并自动启动\n\n```objc\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n### 其他方法\n除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。\n\n```objc\n//取消线程\n- (void)cancel;\n\n//启动线程\n- (void)start;\n\n//判断某个线程的状态的属性\n@property (readonly, getter=isExecuting) BOOL executing;\n@property (readonly, getter=isFinished) BOOL finished;\n@property (readonly, getter=isCancelled) BOOL cancelled;\n\n//设置和获取线程名字\n-(void)setName:(NSString *)n;\n-(NSString *)name;\n\n//获取当前线程信息\n+ (NSThread *)currentThread;\n\n//获取主线程信息\n+ (NSThread *)mainThread;\n\n//使当前线程暂停一段时间，或者暂停到某个时刻\n+ (void)sleepForTimeInterval:(NSTimeInterval)time;\n+ (void)sleepUntilDate:(NSDate *)date;\n```\n\n## GCD\n该部分前一篇关于 GCD 的文章已经较为详细的研究过了。\n\n## NSOperation\n暂时没有时间看，先占个坑\n\n## 其他\n### 线程同步\n#### 互斥锁\n使用 `@synchronized`:\n\n```objc\n@synchronized(self) {\n    //需要执行的代码块\n}\n```\n\n#### 同步执行\n把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。\n\n### 延迟执行\n#### perform\n\n```objc\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n```\n\n#### GCD\n\n```objc\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n    // 3秒后需要执行的任务\n});\n```\n\n#### NSTimer\n\n```objc\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n```\n\n### 从其他线程回到主线程的方法\n在其他线程操作完成后必须到主线程更新UI\n\n#### NSThread\n\n```objc\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n```\n\n#### GCD\n\n```objc\ndispatch_async(dispatch_get_main_queue(), ^{\n  ...\n});\n```\n\n\n\n\n\n","source":"_posts/iOS多线程学习.md","raw":"title: iOS中的多线程学习笔记\ndate: 2016/11/1 14:07:12  \ncategories: iOS\ntags: \n\t- 学习笔记\n\n---\n\n在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。\n<!--more-->\n\n可以通过三种方式实现 iOS 的多线程：\n- NSThread\n- GCD\n- NSOperation&NSOperationQueue\n\n## NSThread\n### 创建并启动\n#### 先创建线程类，再启动\n\n```objc\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n// 启动\n[thread start];\n```\n\n其中，`run:` 是即将执行的方法，`object` 是 `run:` 方法的参数。规定 `run:` 方法最多可有一个参数，且返回类型必须是 `void`。\n\n#### 创建并自动启动\n\n```objc\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n```\n\n#### 使用 NSObject 的方法创建并自动启动\n\n```objc\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n### 其他方法\n除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。\n\n```objc\n//取消线程\n- (void)cancel;\n\n//启动线程\n- (void)start;\n\n//判断某个线程的状态的属性\n@property (readonly, getter=isExecuting) BOOL executing;\n@property (readonly, getter=isFinished) BOOL finished;\n@property (readonly, getter=isCancelled) BOOL cancelled;\n\n//设置和获取线程名字\n-(void)setName:(NSString *)n;\n-(NSString *)name;\n\n//获取当前线程信息\n+ (NSThread *)currentThread;\n\n//获取主线程信息\n+ (NSThread *)mainThread;\n\n//使当前线程暂停一段时间，或者暂停到某个时刻\n+ (void)sleepForTimeInterval:(NSTimeInterval)time;\n+ (void)sleepUntilDate:(NSDate *)date;\n```\n\n## GCD\n该部分前一篇关于 GCD 的文章已经较为详细的研究过了。\n\n## NSOperation\n暂时没有时间看，先占个坑\n\n## 其他\n### 线程同步\n#### 互斥锁\n使用 `@synchronized`:\n\n```objc\n@synchronized(self) {\n    //需要执行的代码块\n}\n```\n\n#### 同步执行\n把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。\n\n### 延迟执行\n#### perform\n\n```objc\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n```\n\n#### GCD\n\n```objc\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n    // 3秒后需要执行的任务\n});\n```\n\n#### NSTimer\n\n```objc\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n```\n\n### 从其他线程回到主线程的方法\n在其他线程操作完成后必须到主线程更新UI\n\n#### NSThread\n\n```objc\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n```\n\n#### GCD\n\n```objc\ndispatch_async(dispatch_get_main_queue(), ^{\n  ...\n});\n```\n\n\n\n\n\n","slug":"iOS多线程学习","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqw002g7hzgunss374g","content":"<p>在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。<br><a id=\"more\"></a></p>\n<p>可以通过三种方式实现 iOS 的多线程：</p>\n<ul>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation&amp;NSOperationQueue</li>\n</ul>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><h3 id=\"创建并启动\"><a href=\"#创建并启动\" class=\"headerlink\" title=\"创建并启动\"></a>创建并启动</h3><h4 id=\"先创建线程类，再启动\"><a href=\"#先创建线程类，再启动\" class=\"headerlink\" title=\"先创建线程类，再启动\"></a>先创建线程类，再启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建</span></div><div class=\"line\"><span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"comment\">// 启动</span></div><div class=\"line\">[thread start];</div></pre></td></tr></table></figure>\n<p>其中，<code>run:</code> 是即将执行的方法，<code>object</code> 是 <code>run:</code> 方法的参数。规定 <code>run:</code> 方法最多可有一个参数，且返回类型必须是 <code>void</code>。</p>\n<h4 id=\"创建并自动启动\"><a href=\"#创建并自动启动\" class=\"headerlink\" title=\"创建并自动启动\"></a>创建并自动启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(run:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"使用-NSObject-的方法创建并自动启动\"><a href=\"#使用-NSObject-的方法创建并自动启动\" class=\"headerlink\" title=\"使用 NSObject 的方法创建并自动启动\"></a>使用 NSObject 的方法创建并自动启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//取消线程</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//启动线程</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断某个线程的状态的属性</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isExecuting) <span class=\"built_in\">BOOL</span> executing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isFinished) <span class=\"built_in\">BOOL</span> finished;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isCancelled) <span class=\"built_in\">BOOL</span> cancelled;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置和获取线程名字</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)n;</div><div class=\"line\">-(<span class=\"built_in\">NSString</span> *)name;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取当前线程信息</span></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)currentThread;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取主线程信息</span></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)mainThread;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使当前线程暂停一段时间，或者暂停到某个时刻</span></div><div class=\"line\">+ (<span class=\"keyword\">void</span>)sleepForTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)time;</div><div class=\"line\">+ (<span class=\"keyword\">void</span>)sleepUntilDate:(<span class=\"built_in\">NSDate</span> *)date;</div></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>该部分前一篇关于 GCD 的文章已经较为详细的研究过了。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>暂时没有时间看，先占个坑</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><h4 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h4><p>使用 <code>@synchronized</code>:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">//需要执行的代码块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"同步执行\"><a href=\"#同步执行\" class=\"headerlink\" title=\"同步执行\"></a>同步执行</h4><p>把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。</p>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><h4 id=\"perform\"><a href=\"#perform\" class=\"headerlink\" title=\"perform\"></a>perform</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"string\">@\"abc\"</span> afterDelay:<span class=\"number\">3</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-1\"><a href=\"#GCD-1\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></div><div class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </div><div class=\"line\"></div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * <span class=\"built_in\">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// 3秒后需要执行的任务</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) userInfo:<span class=\"string\">@\"abc\"</span> repeats:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><p>在其他线程操作完成后必须到主线程更新UI</p>\n<h4 id=\"NSThread-1\"><a href=\"#NSThread-1\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(run) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-2\"><a href=\"#GCD-2\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"<p>在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。<br>","more":"</p>\n<p>可以通过三种方式实现 iOS 的多线程：</p>\n<ul>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation&amp;NSOperationQueue</li>\n</ul>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><h3 id=\"创建并启动\"><a href=\"#创建并启动\" class=\"headerlink\" title=\"创建并启动\"></a>创建并启动</h3><h4 id=\"先创建线程类，再启动\"><a href=\"#先创建线程类，再启动\" class=\"headerlink\" title=\"先创建线程类，再启动\"></a>先创建线程类，再启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建</span></div><div class=\"line\"><span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"comment\">// 启动</span></div><div class=\"line\">[thread start];</div></pre></td></tr></table></figure>\n<p>其中，<code>run:</code> 是即将执行的方法，<code>object</code> 是 <code>run:</code> 方法的参数。规定 <code>run:</code> 方法最多可有一个参数，且返回类型必须是 <code>void</code>。</p>\n<h4 id=\"创建并自动启动\"><a href=\"#创建并自动启动\" class=\"headerlink\" title=\"创建并自动启动\"></a>创建并自动启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(run:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"使用-NSObject-的方法创建并自动启动\"><a href=\"#使用-NSObject-的方法创建并自动启动\" class=\"headerlink\" title=\"使用 NSObject 的方法创建并自动启动\"></a>使用 NSObject 的方法创建并自动启动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//取消线程</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cancel;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//启动线程</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)start;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//判断某个线程的状态的属性</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isExecuting) <span class=\"built_in\">BOOL</span> executing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isFinished) <span class=\"built_in\">BOOL</span> finished;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>, <span class=\"keyword\">getter</span>=isCancelled) <span class=\"built_in\">BOOL</span> cancelled;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置和获取线程名字</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)n;</div><div class=\"line\">-(<span class=\"built_in\">NSString</span> *)name;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取当前线程信息</span></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)currentThread;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//获取主线程信息</span></div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)mainThread;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//使当前线程暂停一段时间，或者暂停到某个时刻</span></div><div class=\"line\">+ (<span class=\"keyword\">void</span>)sleepForTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)time;</div><div class=\"line\">+ (<span class=\"keyword\">void</span>)sleepUntilDate:(<span class=\"built_in\">NSDate</span> *)date;</div></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>该部分前一篇关于 GCD 的文章已经较为详细的研究过了。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>暂时没有时间看，先占个坑</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><h4 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h4><p>使用 <code>@synchronized</code>:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">//需要执行的代码块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"同步执行\"><a href=\"#同步执行\" class=\"headerlink\" title=\"同步执行\"></a>同步执行</h4><p>把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。</p>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><h4 id=\"perform\"><a href=\"#perform\" class=\"headerlink\" title=\"perform\"></a>perform</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(run:) withObject:<span class=\"string\">@\"abc\"</span> afterDelay:<span class=\"number\">3</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-1\"><a href=\"#GCD-1\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建队列</span></div><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></div><div class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </div><div class=\"line\"></div><div class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * <span class=\"built_in\">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// 3秒后需要执行的任务</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">3.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run:) userInfo:<span class=\"string\">@\"abc\"</span> repeats:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><p>在其他线程操作完成后必须到主线程更新UI</p>\n<h4 id=\"NSThread-1\"><a href=\"#NSThread-1\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span> performSelectorOnMainThread:<span class=\"keyword\">@selector</span>(run) withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"GCD-2\"><a href=\"#GCD-2\" class=\"headerlink\" title=\"GCD\"></a>GCD</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"ios编程(第四版) 学习笔记","date":"2016-07-31T06:07:12.000Z","_content":"\n本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。\n\n<!--more-->\n## 第一个ios应用\n### 声明插座变量\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n声明了一个叫questionLabel的插座变量.  \n**IBOutlet**告诉Xcode需要使用Interface Builder关联该插座变量。\n\n### 声明动作方法\n```objc\n- (IBAction)showQuestion:(id)sender{\n\t……\n}\n```\n**IBAction**关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。\n\n### 应用图标\nImages.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。\n\n## objective-c\n### 类方法\n实例方法使用的字符是-，类方法使用字符+。  \n类方法作用通常是创建对象，获取类的某些全局属性。\n\n## 通过ARC管理内存\n### copy\n当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。  \n当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。\n\n举个例子，比如有个`@property(nonatomic,copy) NSString *name`。如果不用`copy`而用`strong`那么将一个可修改的`NSMutableString`对象赋给`name`时，那就直接将`name`指向`NSMutableString`对象。此时，`NSMutableString`修改了自身的string值，那么相当于`name`的值也改变了，这和设计原则相悖。因此，需要使用`copy`,当`NSMutableString`对象赋给`name`时，深复制一个新的不可修改的对象，让`name`指向它，如果`NSString`对象赋给`name`时，浅赋值，将`NSString`的引用计数器加一。\n\ncopy和strong的区别就是：\n- 对于不可修改对象没有区别，都是直接返回对象地址\n- 对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。\n\n\n\n## 视图与视图层次结构\n### 视图层次结构\n任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。\n层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。\n\n### 创建UIView子类\nUIView子类模板会自动生成一个方法 **initWithFrame:**，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。\n\n```objc\n@property （nonatomic） CGRect frame；\n```\n\nCGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。    \n创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；\n  \n可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。  \n每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。  \nbounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。\n\n### 图形绘制\n没看\n\n## 视图：重绘与UIScrollView\n### ScrollView\n设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。  \n在scrollview中addSubView。\n\n## 视图控制器\n### 视图控制器\n视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。\n使用UITabBarController的类在两个视图控制器间切换。  \n\nUIViewController有一个重要属性：\n\n```objc \n@property (nonatomic, strong) UIView *view;\n```\n\n这个view就是视图的根视图。\n\n### 创建视图层次结构\n1. 覆盖UIViewController的loadView方法\n```objc\n-(void)loadView{\n        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];\n        self.view = backgroundView;\n}\n```\n\n\t此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。\n2. 通过xib创建\n.m中声明各个控件(注意控件使用弱引用)\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n\n\t再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。\n\n### 设置根视图控制器\nUIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。\n```objc\nBNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];\nself.window.rootViewController = hvc;\n```\n\nsetRootViewController其实就是将ViewController的view设置为其subview。\n\n### 加载nib文件\n加载不同名的nib文件时，需要使用**initWithNibName:Bundle:**方法。该方法的两个参数，分别用于指定NIB文件文件名和其**所在的程序包**。如果是Bundle传入nil默认是[NSBundle mainBundle];\n\n### UITabBarController\nUITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   \n\n在APPDelegate中创建两个视图控制器，加入Tabbar的**viewControllers**属性中，并将tabbar设置为rootViewController\n```objc\nUITabBarController *tabBarController = [[UITabBarController alloc] init];\ntabBarController.viewControllers = @[hvc,rvc] //两个viewController 可以写在tabbarController的viewDidLoad方法里\nself.window.rootViewController = tabBarController;\n```\n\n设置标签项，使用**tabBarItem**属性：\n\n```objc\n    UIImage *orderImage = [UIImage imageNamed:@\"tab_order\"];\n    UIImage *orderImageSel = [UIImage imageNamed:@\"tab_order_active\"];\n    orderImage = [orderImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    orderImageSel = [orderImageSel imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    UITabBarItem *orderTabBarItem = [[UITabBarItem alloc] initWithTitle:@\"订单\" image:orderImage selectedImage:orderImageSel];\n    orderNav.tabBarItem = orderTabBarItem;\n```\n\n为tabbar添加subview，UITabBarController里有一个**tabBar**的view\n\n```objc\nUIView *backview = [[UIView alloc] initWithFrame:self.tabBar.bounds];\n[backview setBackgroundColor:[UIColor whiteColor]];\n[self.tabBar addSubview:backview];\n```\n\n\n### 本地通知\n本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。\n```objc\nUILocalNotification *note = [][UILocalNotification alloc] init];\nnote.alertBody = @\"xxx\";\nnote.fireDate = date;\n[[UIApplication sharedApplication] scheduleLocalNotification:note];\n```\n\n### 加载和显示视图\nviewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。  \n另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。\n  \n如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。\n\n### 与视图控制器及其视图交互\n**application:didFinishLaunchingWithOptions:**\t该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。      \n**initWithNibName：bundle：**该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。  \n**loadView：**覆盖该方法，使用代码方式设置视图控制的的view属性。  \n**viewDidLoad：**该方法会在视图控制器加载完视图后被调用。  \n**viewWillAppear：**该方法会在视图控制器的view显示在屏幕上时被调用。  \n\n## 委托与文本输入\n### 委托（代理模式）\n当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。  \n例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  \n\n类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。\n\n### 协议\n凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  \n\n协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束  \n使用@optional指令，可以将写在指令后的全部声明为可选的。  \n发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  \n\n声明示例：\n```objc\n@interface BNRHypnosisViewController()<UITextFieldDelegate>\n@end\n```\n### 设置异常断点\n当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。\n\n### 类方法与实例方法\n这里需要注意：\n1. 类方法可以调用类方法。\n2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。\n3. 类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。\n + 实例方法里面的self，是对象的首地址。\n + 类方法里面的self，是Class.\n4. 类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。\n\n## UINavigationController\n### UINavigationController对象\nUINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。\n\nUINavigationController对象有一个名为**viewControllers**的属性，指向一个负责保存视图控制器的数组。**topViewController**属性是一个指针，指向当前位于栈顶的视图控制器。\n\nUINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有**两个子视图**：一个是**UINavigationBar对象**，一个是**topViewController的视图**。\n\n初始化UINavigationController对象：\n```objc\nUINavigationController *navController = [[UINavigationController alloc]initWithRootViewController:viewController];\n```\n\n### 关联xib\n不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）\n\n在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。\n\n设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。\n\n### 将视图控制器压入栈\n使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。\n```objc\n[self.navigationController pushViewController:detailController animated:YES];\n```\n视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。\n\n### 视图控制器间传递数据\n\n### NavigationBar\nUIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。\n\nUINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。\n\n创建一个buttonItem：\n```objc\n- (void)initNavigationView{\n    UIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 26, 44)];\n    [backBtn setImage:[UIImage imageNamed:@\"systemback\"] forState:UIControlStateNormal];\n    [backBtn addTarget:self action:@selector(backButtonPressedForOrder:) forControlEvents:UIControlEventTouchUpInside];\n    UIBarButtonItem *leftItem  = [[UIBarButtonItem alloc]initWithCustomView:backBtn];\n    [self.navigationItem setLeftBarButtonItem:leftItem];\n}\n```\n","source":"_posts/ios编程（第四版.md","raw":"title: ios编程(第四版) 学习笔记\ndate: 2016/7/31 14:07:12  \ncategories: iOS\ntags: \n\t- 学习笔记\n\n---\n\n本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。\n\n<!--more-->\n## 第一个ios应用\n### 声明插座变量\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n声明了一个叫questionLabel的插座变量.  \n**IBOutlet**告诉Xcode需要使用Interface Builder关联该插座变量。\n\n### 声明动作方法\n```objc\n- (IBAction)showQuestion:(id)sender{\n\t……\n}\n```\n**IBAction**关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。\n\n### 应用图标\nImages.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。\n\n## objective-c\n### 类方法\n实例方法使用的字符是-，类方法使用字符+。  \n类方法作用通常是创建对象，获取类的某些全局属性。\n\n## 通过ARC管理内存\n### copy\n当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。  \n当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。\n\n举个例子，比如有个`@property(nonatomic,copy) NSString *name`。如果不用`copy`而用`strong`那么将一个可修改的`NSMutableString`对象赋给`name`时，那就直接将`name`指向`NSMutableString`对象。此时，`NSMutableString`修改了自身的string值，那么相当于`name`的值也改变了，这和设计原则相悖。因此，需要使用`copy`,当`NSMutableString`对象赋给`name`时，深复制一个新的不可修改的对象，让`name`指向它，如果`NSString`对象赋给`name`时，浅赋值，将`NSString`的引用计数器加一。\n\ncopy和strong的区别就是：\n- 对于不可修改对象没有区别，都是直接返回对象地址\n- 对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。\n\n\n\n## 视图与视图层次结构\n### 视图层次结构\n任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。\n层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。\n\n### 创建UIView子类\nUIView子类模板会自动生成一个方法 **initWithFrame:**，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。\n\n```objc\n@property （nonatomic） CGRect frame；\n```\n\nCGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。    \n创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；\n  \n可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。  \n每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。  \nbounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。\n\n### 图形绘制\n没看\n\n## 视图：重绘与UIScrollView\n### ScrollView\n设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。  \n在scrollview中addSubView。\n\n## 视图控制器\n### 视图控制器\n视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。\n使用UITabBarController的类在两个视图控制器间切换。  \n\nUIViewController有一个重要属性：\n\n```objc \n@property (nonatomic, strong) UIView *view;\n```\n\n这个view就是视图的根视图。\n\n### 创建视图层次结构\n1. 覆盖UIViewController的loadView方法\n```objc\n-(void)loadView{\n        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];\n        self.view = backgroundView;\n}\n```\n\n\t此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。\n2. 通过xib创建\n.m中声明各个控件(注意控件使用弱引用)\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n\n\t再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。\n\n### 设置根视图控制器\nUIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。\n```objc\nBNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];\nself.window.rootViewController = hvc;\n```\n\nsetRootViewController其实就是将ViewController的view设置为其subview。\n\n### 加载nib文件\n加载不同名的nib文件时，需要使用**initWithNibName:Bundle:**方法。该方法的两个参数，分别用于指定NIB文件文件名和其**所在的程序包**。如果是Bundle传入nil默认是[NSBundle mainBundle];\n\n### UITabBarController\nUITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   \n\n在APPDelegate中创建两个视图控制器，加入Tabbar的**viewControllers**属性中，并将tabbar设置为rootViewController\n```objc\nUITabBarController *tabBarController = [[UITabBarController alloc] init];\ntabBarController.viewControllers = @[hvc,rvc] //两个viewController 可以写在tabbarController的viewDidLoad方法里\nself.window.rootViewController = tabBarController;\n```\n\n设置标签项，使用**tabBarItem**属性：\n\n```objc\n    UIImage *orderImage = [UIImage imageNamed:@\"tab_order\"];\n    UIImage *orderImageSel = [UIImage imageNamed:@\"tab_order_active\"];\n    orderImage = [orderImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    orderImageSel = [orderImageSel imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    UITabBarItem *orderTabBarItem = [[UITabBarItem alloc] initWithTitle:@\"订单\" image:orderImage selectedImage:orderImageSel];\n    orderNav.tabBarItem = orderTabBarItem;\n```\n\n为tabbar添加subview，UITabBarController里有一个**tabBar**的view\n\n```objc\nUIView *backview = [[UIView alloc] initWithFrame:self.tabBar.bounds];\n[backview setBackgroundColor:[UIColor whiteColor]];\n[self.tabBar addSubview:backview];\n```\n\n\n### 本地通知\n本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。\n```objc\nUILocalNotification *note = [][UILocalNotification alloc] init];\nnote.alertBody = @\"xxx\";\nnote.fireDate = date;\n[[UIApplication sharedApplication] scheduleLocalNotification:note];\n```\n\n### 加载和显示视图\nviewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。  \n另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。\n  \n如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。\n\n### 与视图控制器及其视图交互\n**application:didFinishLaunchingWithOptions:**\t该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。      \n**initWithNibName：bundle：**该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。  \n**loadView：**覆盖该方法，使用代码方式设置视图控制的的view属性。  \n**viewDidLoad：**该方法会在视图控制器加载完视图后被调用。  \n**viewWillAppear：**该方法会在视图控制器的view显示在屏幕上时被调用。  \n\n## 委托与文本输入\n### 委托（代理模式）\n当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。  \n例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  \n\n类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。\n\n### 协议\n凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  \n\n协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束  \n使用@optional指令，可以将写在指令后的全部声明为可选的。  \n发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  \n\n声明示例：\n```objc\n@interface BNRHypnosisViewController()<UITextFieldDelegate>\n@end\n```\n### 设置异常断点\n当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。\n\n### 类方法与实例方法\n这里需要注意：\n1. 类方法可以调用类方法。\n2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。\n3. 类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。\n + 实例方法里面的self，是对象的首地址。\n + 类方法里面的self，是Class.\n4. 类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。\n\n## UINavigationController\n### UINavigationController对象\nUINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。\n\nUINavigationController对象有一个名为**viewControllers**的属性，指向一个负责保存视图控制器的数组。**topViewController**属性是一个指针，指向当前位于栈顶的视图控制器。\n\nUINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有**两个子视图**：一个是**UINavigationBar对象**，一个是**topViewController的视图**。\n\n初始化UINavigationController对象：\n```objc\nUINavigationController *navController = [[UINavigationController alloc]initWithRootViewController:viewController];\n```\n\n### 关联xib\n不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）\n\n在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。\n\n设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。\n\n### 将视图控制器压入栈\n使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。\n```objc\n[self.navigationController pushViewController:detailController animated:YES];\n```\n视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。\n\n### 视图控制器间传递数据\n\n### NavigationBar\nUIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。\n\nUINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。\n\n创建一个buttonItem：\n```objc\n- (void)initNavigationView{\n    UIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 26, 44)];\n    [backBtn setImage:[UIImage imageNamed:@\"systemback\"] forState:UIControlStateNormal];\n    [backBtn addTarget:self action:@selector(backButtonPressedForOrder:) forControlEvents:UIControlEventTouchUpInside];\n    UIBarButtonItem *leftItem  = [[UIBarButtonItem alloc]initWithCustomView:backBtn];\n    [self.navigationItem setLeftBarButtonItem:leftItem];\n}\n```\n","slug":"ios编程（第四版","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dqz002k7hzgoprojmwy","content":"<p>本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。</p>\n<a id=\"more\"></a>\n<h2 id=\"第一个ios应用\"><a href=\"#第一个ios应用\" class=\"headerlink\" title=\"第一个ios应用\"></a>第一个ios应用</h2><h3 id=\"声明插座变量\"><a href=\"#声明插座变量\" class=\"headerlink\" title=\"声明插座变量\"></a>声明插座变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p>声明了一个叫questionLabel的插座变量.<br><strong>IBOutlet</strong>告诉Xcode需要使用Interface Builder关联该插座变量。</p>\n<h3 id=\"声明动作方法\"><a href=\"#声明动作方法\" class=\"headerlink\" title=\"声明动作方法\"></a>声明动作方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)showQuestion:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>IBAction</strong>关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。</p>\n<h3 id=\"应用图标\"><a href=\"#应用图标\" class=\"headerlink\" title=\"应用图标\"></a>应用图标</h3><p>Images.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。</p>\n<h2 id=\"objective-c\"><a href=\"#objective-c\" class=\"headerlink\" title=\"objective-c\"></a>objective-c</h2><h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法使用的字符是-，类方法使用字符+。<br>类方法作用通常是创建对象，获取类的某些全局属性。</p>\n<h2 id=\"通过ARC管理内存\"><a href=\"#通过ARC管理内存\" class=\"headerlink\" title=\"通过ARC管理内存\"></a>通过ARC管理内存</h2><h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。<br>当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。</p>\n<p>举个例子，比如有个<code>@property(nonatomic,copy) NSString *name</code>。如果不用<code>copy</code>而用<code>strong</code>那么将一个可修改的<code>NSMutableString</code>对象赋给<code>name</code>时，那就直接将<code>name</code>指向<code>NSMutableString</code>对象。此时，<code>NSMutableString</code>修改了自身的string值，那么相当于<code>name</code>的值也改变了，这和设计原则相悖。因此，需要使用<code>copy</code>,当<code>NSMutableString</code>对象赋给<code>name</code>时，深复制一个新的不可修改的对象，让<code>name</code>指向它，如果<code>NSString</code>对象赋给<code>name</code>时，浅赋值，将<code>NSString</code>的引用计数器加一。</p>\n<p>copy和strong的区别就是：</p>\n<ul>\n<li>对于不可修改对象没有区别，都是直接返回对象地址</li>\n<li>对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。</li>\n</ul>\n<h2 id=\"视图与视图层次结构\"><a href=\"#视图与视图层次结构\" class=\"headerlink\" title=\"视图与视图层次结构\"></a>视图与视图层次结构</h2><h3 id=\"视图层次结构\"><a href=\"#视图层次结构\" class=\"headerlink\" title=\"视图层次结构\"></a>视图层次结构</h3><p>任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。<br>层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。</p>\n<h3 id=\"创建UIView子类\"><a href=\"#创建UIView子类\" class=\"headerlink\" title=\"创建UIView子类\"></a>创建UIView子类</h3><p>UIView子类模板会自动生成一个方法 <strong>initWithFrame:</strong>，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">nonatomic</span>） <span class=\"built_in\">CGRect</span> frame；</div></pre></td></tr></table></figure>\n<p>CGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。<br>创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；</p>\n<p>可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。<br>每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。<br>bounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。</p>\n<h3 id=\"图形绘制\"><a href=\"#图形绘制\" class=\"headerlink\" title=\"图形绘制\"></a>图形绘制</h3><p>没看</p>\n<h2 id=\"视图：重绘与UIScrollView\"><a href=\"#视图：重绘与UIScrollView\" class=\"headerlink\" title=\"视图：重绘与UIScrollView\"></a>视图：重绘与UIScrollView</h2><h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。<br>在scrollview中addSubView。</p>\n<h2 id=\"视图控制器\"><a href=\"#视图控制器\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h2><h3 id=\"视图控制器-1\"><a href=\"#视图控制器-1\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h3><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。<br>使用UITabBarController的类在两个视图控制器间切换。  </p>\n<p>UIViewController有一个重要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</div></pre></td></tr></table></figure>\n<p>这个view就是视图的根视图。</p>\n<h3 id=\"创建视图层次结构\"><a href=\"#创建视图层次结构\" class=\"headerlink\" title=\"创建视图层次结构\"></a>创建视图层次结构</h3><ol>\n<li><p>覆盖UIViewController的loadView方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)loadView&#123;</div><div class=\"line\">        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];</div><div class=\"line\">        <span class=\"keyword\">self</span>.view = backgroundView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。</p>\n</li>\n<li><p>通过xib创建<br>.m中声明各个控件(注意控件使用弱引用)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p> 再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。</p>\n</li>\n</ol>\n<h3 id=\"设置根视图控制器\"><a href=\"#设置根视图控制器\" class=\"headerlink\" title=\"设置根视图控制器\"></a>设置根视图控制器</h3><p>UIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">BNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = hvc;</div></pre></td></tr></table></figure></p>\n<p>setRootViewController其实就是将ViewController的view设置为其subview。</p>\n<h3 id=\"加载nib文件\"><a href=\"#加载nib文件\" class=\"headerlink\" title=\"加载nib文件\"></a>加载nib文件</h3><p>加载不同名的nib文件时，需要使用<strong>initWithNibName:Bundle:</strong>方法。该方法的两个参数，分别用于指定NIB文件文件名和其<strong>所在的程序包</strong>。如果是Bundle传入nil默认是[NSBundle mainBundle];</p>\n<h3 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h3><p>UITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   </p>\n<p>在APPDelegate中创建两个视图控制器，加入Tabbar的<strong>viewControllers</strong>属性中，并将tabbar设置为rootViewController<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = [[<span class=\"built_in\">UITabBarController</span> alloc] init];</div><div class=\"line\">tabBarController.viewControllers = @[hvc,rvc] <span class=\"comment\">//两个viewController 可以写在tabbarController的viewDidLoad方法里</span></div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = tabBarController;</div></pre></td></tr></table></figure></p>\n<p>设置标签项，使用<strong>tabBarItem</strong>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order\"</span>];</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImageSel = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order_active\"</span>];</div><div class=\"line\">orderImage = [orderImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\">orderImageSel = [orderImageSel imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\"><span class=\"built_in\">UITabBarItem</span> *orderTabBarItem = [[<span class=\"built_in\">UITabBarItem</span> alloc] initWithTitle:<span class=\"string\">@\"订单\"</span> image:orderImage selectedImage:orderImageSel];</div><div class=\"line\">orderNav.tabBarItem = orderTabBarItem;</div></pre></td></tr></table></figure>\n<p>为tabbar添加subview，UITabBarController里有一个<strong>tabBar</strong>的view</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *backview = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.tabBar.bounds];</div><div class=\"line\">[backview setBackgroundColor:[<span class=\"built_in\">UIColor</span> whiteColor]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.tabBar addSubview:backview];</div></pre></td></tr></table></figure>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UILocalNotification</span> *note = [][<span class=\"built_in\">UILocalNotification</span> alloc] init];</div><div class=\"line\">note.alertBody = <span class=\"string\">@\"xxx\"</span>;</div><div class=\"line\">note.fireDate = date;</div><div class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] scheduleLocalNotification:note];</div></pre></td></tr></table></figure></p>\n<h3 id=\"加载和显示视图\"><a href=\"#加载和显示视图\" class=\"headerlink\" title=\"加载和显示视图\"></a>加载和显示视图</h3><p>viewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。<br>另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。</p>\n<p>如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。</p>\n<h3 id=\"与视图控制器及其视图交互\"><a href=\"#与视图控制器及其视图交互\" class=\"headerlink\" title=\"与视图控制器及其视图交互\"></a>与视图控制器及其视图交互</h3><p><strong>application:didFinishLaunchingWithOptions:</strong>    该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。<br><strong>initWithNibName：bundle：</strong>该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。<br><strong>loadView：</strong>覆盖该方法，使用代码方式设置视图控制的的view属性。<br><strong>viewDidLoad：</strong>该方法会在视图控制器加载完视图后被调用。<br><strong>viewWillAppear：</strong>该方法会在视图控制器的view显示在屏幕上时被调用。  </p>\n<h2 id=\"委托与文本输入\"><a href=\"#委托与文本输入\" class=\"headerlink\" title=\"委托与文本输入\"></a>委托与文本输入</h2><h3 id=\"委托（代理模式）\"><a href=\"#委托（代理模式）\" class=\"headerlink\" title=\"委托（代理模式）\"></a>委托（代理模式）</h3><p>当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。<br>例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  </p>\n<p>类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  </p>\n<p>协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束<br>使用@optional指令，可以将写在指令后的全部声明为可选的。<br>发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  </p>\n<p>声明示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRHypnosisViewController</span>()&lt;<span class=\"title\">UITextFieldDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"设置异常断点\"><a href=\"#设置异常断点\" class=\"headerlink\" title=\"设置异常断点\"></a>设置异常断点</h3><p>当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。</p>\n<h3 id=\"类方法与实例方法\"><a href=\"#类方法与实例方法\" class=\"headerlink\" title=\"类方法与实例方法\"></a>类方法与实例方法</h3><p>这里需要注意：</p>\n<ol>\n<li>类方法可以调用类方法。</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。</li>\n<li>类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<ul>\n<li>实例方法里面的self，是对象的首地址。</li>\n<li>类方法里面的self，是Class.</li>\n</ul>\n</li>\n<li>类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</li>\n</ol>\n<h2 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h2><h3 id=\"UINavigationController对象\"><a href=\"#UINavigationController对象\" class=\"headerlink\" title=\"UINavigationController对象\"></a>UINavigationController对象</h3><p>UINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。</p>\n<p>UINavigationController对象有一个名为<strong>viewControllers</strong>的属性，指向一个负责保存视图控制器的数组。<strong>topViewController</strong>属性是一个指针，指向当前位于栈顶的视图控制器。</p>\n<p>UINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有<strong>两个子视图</strong>：一个是<strong>UINavigationBar对象</strong>，一个是<strong>topViewController的视图</strong>。</p>\n<p>初始化UINavigationController对象：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navController = [[<span class=\"built_in\">UINavigationController</span> alloc]initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>\n<h3 id=\"关联xib\"><a href=\"#关联xib\" class=\"headerlink\" title=\"关联xib\"></a>关联xib</h3><p>不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）</p>\n<p>在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。</p>\n<p>设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。</p>\n<h3 id=\"将视图控制器压入栈\"><a href=\"#将视图控制器压入栈\" class=\"headerlink\" title=\"将视图控制器压入栈\"></a>将视图控制器压入栈</h3><p>使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:detailController animated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure></p>\n<p>视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。</p>\n<h3 id=\"视图控制器间传递数据\"><a href=\"#视图控制器间传递数据\" class=\"headerlink\" title=\"视图控制器间传递数据\"></a>视图控制器间传递数据</h3><h3 id=\"NavigationBar\"><a href=\"#NavigationBar\" class=\"headerlink\" title=\"NavigationBar\"></a>NavigationBar</h3><p>UIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。</p>\n<p>UINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。</p>\n<p>创建一个buttonItem：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initNavigationView&#123;</div><div class=\"line\">    <span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">    [backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"systemback\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    [backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(backButtonPressedForOrder:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"built_in\">UIBarButtonItem</span> *leftItem  = [[<span class=\"built_in\">UIBarButtonItem</span> alloc]initWithCustomView:backBtn];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.navigationItem setLeftBarButtonItem:leftItem];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。</p>","more":"<h2 id=\"第一个ios应用\"><a href=\"#第一个ios应用\" class=\"headerlink\" title=\"第一个ios应用\"></a>第一个ios应用</h2><h3 id=\"声明插座变量\"><a href=\"#声明插座变量\" class=\"headerlink\" title=\"声明插座变量\"></a>声明插座变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p>声明了一个叫questionLabel的插座变量.<br><strong>IBOutlet</strong>告诉Xcode需要使用Interface Builder关联该插座变量。</p>\n<h3 id=\"声明动作方法\"><a href=\"#声明动作方法\" class=\"headerlink\" title=\"声明动作方法\"></a>声明动作方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)showQuestion:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>IBAction</strong>关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。</p>\n<h3 id=\"应用图标\"><a href=\"#应用图标\" class=\"headerlink\" title=\"应用图标\"></a>应用图标</h3><p>Images.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。</p>\n<h2 id=\"objective-c\"><a href=\"#objective-c\" class=\"headerlink\" title=\"objective-c\"></a>objective-c</h2><h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法使用的字符是-，类方法使用字符+。<br>类方法作用通常是创建对象，获取类的某些全局属性。</p>\n<h2 id=\"通过ARC管理内存\"><a href=\"#通过ARC管理内存\" class=\"headerlink\" title=\"通过ARC管理内存\"></a>通过ARC管理内存</h2><h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。<br>当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。</p>\n<p>举个例子，比如有个<code>@property(nonatomic,copy) NSString *name</code>。如果不用<code>copy</code>而用<code>strong</code>那么将一个可修改的<code>NSMutableString</code>对象赋给<code>name</code>时，那就直接将<code>name</code>指向<code>NSMutableString</code>对象。此时，<code>NSMutableString</code>修改了自身的string值，那么相当于<code>name</code>的值也改变了，这和设计原则相悖。因此，需要使用<code>copy</code>,当<code>NSMutableString</code>对象赋给<code>name</code>时，深复制一个新的不可修改的对象，让<code>name</code>指向它，如果<code>NSString</code>对象赋给<code>name</code>时，浅赋值，将<code>NSString</code>的引用计数器加一。</p>\n<p>copy和strong的区别就是：</p>\n<ul>\n<li>对于不可修改对象没有区别，都是直接返回对象地址</li>\n<li>对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。</li>\n</ul>\n<h2 id=\"视图与视图层次结构\"><a href=\"#视图与视图层次结构\" class=\"headerlink\" title=\"视图与视图层次结构\"></a>视图与视图层次结构</h2><h3 id=\"视图层次结构\"><a href=\"#视图层次结构\" class=\"headerlink\" title=\"视图层次结构\"></a>视图层次结构</h3><p>任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。<br>层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。</p>\n<h3 id=\"创建UIView子类\"><a href=\"#创建UIView子类\" class=\"headerlink\" title=\"创建UIView子类\"></a>创建UIView子类</h3><p>UIView子类模板会自动生成一个方法 <strong>initWithFrame:</strong>，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">nonatomic</span>） <span class=\"built_in\">CGRect</span> frame；</div></pre></td></tr></table></figure>\n<p>CGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。<br>创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；</p>\n<p>可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。<br>每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。<br>bounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。</p>\n<h3 id=\"图形绘制\"><a href=\"#图形绘制\" class=\"headerlink\" title=\"图形绘制\"></a>图形绘制</h3><p>没看</p>\n<h2 id=\"视图：重绘与UIScrollView\"><a href=\"#视图：重绘与UIScrollView\" class=\"headerlink\" title=\"视图：重绘与UIScrollView\"></a>视图：重绘与UIScrollView</h2><h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。<br>在scrollview中addSubView。</p>\n<h2 id=\"视图控制器\"><a href=\"#视图控制器\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h2><h3 id=\"视图控制器-1\"><a href=\"#视图控制器-1\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h3><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。<br>使用UITabBarController的类在两个视图控制器间切换。  </p>\n<p>UIViewController有一个重要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</div></pre></td></tr></table></figure>\n<p>这个view就是视图的根视图。</p>\n<h3 id=\"创建视图层次结构\"><a href=\"#创建视图层次结构\" class=\"headerlink\" title=\"创建视图层次结构\"></a>创建视图层次结构</h3><ol>\n<li><p>覆盖UIViewController的loadView方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)loadView&#123;</div><div class=\"line\">        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];</div><div class=\"line\">        <span class=\"keyword\">self</span>.view = backgroundView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。</p>\n</li>\n<li><p>通过xib创建<br>.m中声明各个控件(注意控件使用弱引用)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p> 再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。</p>\n</li>\n</ol>\n<h3 id=\"设置根视图控制器\"><a href=\"#设置根视图控制器\" class=\"headerlink\" title=\"设置根视图控制器\"></a>设置根视图控制器</h3><p>UIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">BNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = hvc;</div></pre></td></tr></table></figure></p>\n<p>setRootViewController其实就是将ViewController的view设置为其subview。</p>\n<h3 id=\"加载nib文件\"><a href=\"#加载nib文件\" class=\"headerlink\" title=\"加载nib文件\"></a>加载nib文件</h3><p>加载不同名的nib文件时，需要使用<strong>initWithNibName:Bundle:</strong>方法。该方法的两个参数，分别用于指定NIB文件文件名和其<strong>所在的程序包</strong>。如果是Bundle传入nil默认是[NSBundle mainBundle];</p>\n<h3 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h3><p>UITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   </p>\n<p>在APPDelegate中创建两个视图控制器，加入Tabbar的<strong>viewControllers</strong>属性中，并将tabbar设置为rootViewController<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = [[<span class=\"built_in\">UITabBarController</span> alloc] init];</div><div class=\"line\">tabBarController.viewControllers = @[hvc,rvc] <span class=\"comment\">//两个viewController 可以写在tabbarController的viewDidLoad方法里</span></div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = tabBarController;</div></pre></td></tr></table></figure></p>\n<p>设置标签项，使用<strong>tabBarItem</strong>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order\"</span>];</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImageSel = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order_active\"</span>];</div><div class=\"line\">orderImage = [orderImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\">orderImageSel = [orderImageSel imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\"><span class=\"built_in\">UITabBarItem</span> *orderTabBarItem = [[<span class=\"built_in\">UITabBarItem</span> alloc] initWithTitle:<span class=\"string\">@\"订单\"</span> image:orderImage selectedImage:orderImageSel];</div><div class=\"line\">orderNav.tabBarItem = orderTabBarItem;</div></pre></td></tr></table></figure>\n<p>为tabbar添加subview，UITabBarController里有一个<strong>tabBar</strong>的view</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *backview = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.tabBar.bounds];</div><div class=\"line\">[backview setBackgroundColor:[<span class=\"built_in\">UIColor</span> whiteColor]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.tabBar addSubview:backview];</div></pre></td></tr></table></figure>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UILocalNotification</span> *note = [][<span class=\"built_in\">UILocalNotification</span> alloc] init];</div><div class=\"line\">note.alertBody = <span class=\"string\">@\"xxx\"</span>;</div><div class=\"line\">note.fireDate = date;</div><div class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] scheduleLocalNotification:note];</div></pre></td></tr></table></figure></p>\n<h3 id=\"加载和显示视图\"><a href=\"#加载和显示视图\" class=\"headerlink\" title=\"加载和显示视图\"></a>加载和显示视图</h3><p>viewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。<br>另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。</p>\n<p>如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。</p>\n<h3 id=\"与视图控制器及其视图交互\"><a href=\"#与视图控制器及其视图交互\" class=\"headerlink\" title=\"与视图控制器及其视图交互\"></a>与视图控制器及其视图交互</h3><p><strong>application:didFinishLaunchingWithOptions:</strong>    该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。<br><strong>initWithNibName：bundle：</strong>该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。<br><strong>loadView：</strong>覆盖该方法，使用代码方式设置视图控制的的view属性。<br><strong>viewDidLoad：</strong>该方法会在视图控制器加载完视图后被调用。<br><strong>viewWillAppear：</strong>该方法会在视图控制器的view显示在屏幕上时被调用。  </p>\n<h2 id=\"委托与文本输入\"><a href=\"#委托与文本输入\" class=\"headerlink\" title=\"委托与文本输入\"></a>委托与文本输入</h2><h3 id=\"委托（代理模式）\"><a href=\"#委托（代理模式）\" class=\"headerlink\" title=\"委托（代理模式）\"></a>委托（代理模式）</h3><p>当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。<br>例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  </p>\n<p>类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  </p>\n<p>协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束<br>使用@optional指令，可以将写在指令后的全部声明为可选的。<br>发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  </p>\n<p>声明示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRHypnosisViewController</span>()&lt;<span class=\"title\">UITextFieldDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"设置异常断点\"><a href=\"#设置异常断点\" class=\"headerlink\" title=\"设置异常断点\"></a>设置异常断点</h3><p>当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。</p>\n<h3 id=\"类方法与实例方法\"><a href=\"#类方法与实例方法\" class=\"headerlink\" title=\"类方法与实例方法\"></a>类方法与实例方法</h3><p>这里需要注意：</p>\n<ol>\n<li>类方法可以调用类方法。</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。</li>\n<li>类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<ul>\n<li>实例方法里面的self，是对象的首地址。</li>\n<li>类方法里面的self，是Class.</li>\n</ul>\n</li>\n<li>类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</li>\n</ol>\n<h2 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h2><h3 id=\"UINavigationController对象\"><a href=\"#UINavigationController对象\" class=\"headerlink\" title=\"UINavigationController对象\"></a>UINavigationController对象</h3><p>UINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。</p>\n<p>UINavigationController对象有一个名为<strong>viewControllers</strong>的属性，指向一个负责保存视图控制器的数组。<strong>topViewController</strong>属性是一个指针，指向当前位于栈顶的视图控制器。</p>\n<p>UINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有<strong>两个子视图</strong>：一个是<strong>UINavigationBar对象</strong>，一个是<strong>topViewController的视图</strong>。</p>\n<p>初始化UINavigationController对象：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navController = [[<span class=\"built_in\">UINavigationController</span> alloc]initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>\n<h3 id=\"关联xib\"><a href=\"#关联xib\" class=\"headerlink\" title=\"关联xib\"></a>关联xib</h3><p>不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）</p>\n<p>在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。</p>\n<p>设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。</p>\n<h3 id=\"将视图控制器压入栈\"><a href=\"#将视图控制器压入栈\" class=\"headerlink\" title=\"将视图控制器压入栈\"></a>将视图控制器压入栈</h3><p>使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:detailController animated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure></p>\n<p>视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。</p>\n<h3 id=\"视图控制器间传递数据\"><a href=\"#视图控制器间传递数据\" class=\"headerlink\" title=\"视图控制器间传递数据\"></a>视图控制器间传递数据</h3><h3 id=\"NavigationBar\"><a href=\"#NavigationBar\" class=\"headerlink\" title=\"NavigationBar\"></a>NavigationBar</h3><p>UIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。</p>\n<p>UINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。</p>\n<p>创建一个buttonItem：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initNavigationView&#123;</div><div class=\"line\">    <span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">    [backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"systemback\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    [backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(backButtonPressedForOrder:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"built_in\">UIBarButtonItem</span> *leftItem  = [[<span class=\"built_in\">UIBarButtonItem</span> alloc]initWithCustomView:backBtn];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.navigationItem setLeftBarButtonItem:leftItem];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"ios核心动画","date":"2016-08-16T06:07:12.000Z","_content":"依旧是[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)关于核心动画的内容。作为入门\n\n**核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。**\n\n<!--more-->\n\n## 核心动画简介\nCAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。\n\nCAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation\n它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@\"position\"为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果\n\n常见属性：\n- duration：动画的持续时间\n- repeatCount：动画的重复次数\n- repeatDuration：动画的重复时间\n- removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards\n- fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后\n- beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间\n- timingFunction：速度控制函数，控制动画运行的节奏\n- delegate：动画代理\n\n## 基础动画\n### 简介\nCABasicAnimation，是CApropertyAnimation的子类\n\n属性：\n- fromValue：keyPath相应属性的初始值\n- toValue：keyPath相应属性的结束值\n\n随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue\n\n如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但**在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。**比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。\n\n### 示例\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,strong)CALayer *myLayer;\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    //创建layer\n    CALayer *myLayer=[CALayer layer];\n    //设置layer的属性\n    myLayer.bounds=CGRectMake(0, 0, 50, 80);\n    myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n    myLayer.position=CGPointMake(50, 50);\n    myLayer.anchorPoint=CGPointMake(0, 0);\n    myLayer.cornerRadius=20;\n    //添加layer\n    [self.view.layer addSublayer:myLayer];\n    self.myLayer=myLayer;\n}\n//设置 平移 动画\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    //    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:<#(NSString *)#>]\n    CABasicAnimation *anima=[CABasicAnimation animation];\n    \n    //1.1告诉系统要执行什么样的动画\n    anima.keyPath=@\"position\";\n    //设置通过动画，将layer从哪儿移动到哪儿\n    anima.fromValue=[NSValue valueWithCGPoint:CGPointMake(0, 0)];\n    anima.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 300)];\n    \n    //1.2设置动画执行完毕之后不删除动画\n    anima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    anima.fillMode=kCAFillModeForwards;\n\n    //2.添加核心动画到layer\n    [self.myLayer addAnimation:anima forKey:nil];\n\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始执行动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    //动画执行完毕，打印执行完毕后的position值\n    NSString *str=NSStringFromCGPoint(self.myLayer.position);\n    NSLog(@\"执行后：%@\",str);\n}\n\n@end\n```\n\n其中keypath的值决定产生什么动画\n1. position：执行平移动画\n2. bounds：执行缩放动画\n3. transform：执行旋转动画\n\n## 关键帧动画\n### 简介\nCAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值\n\n属性：\n- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧\n- path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略\n- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的\n\n说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation\n\n### 示例\n#### 使用value\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    NSValue *value1=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    NSValue *value2=[NSValue valueWithCGPoint:CGPointMake(200, 100)];\n    NSValue *value3=[NSValue valueWithCGPoint:CGPointMake(200, 200)];\n    NSValue *value4=[NSValue valueWithCGPoint:CGPointMake(100, 200)];\n    NSValue *value5=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    keyAnima.values=@[value1,value2,value3,value4,value5];\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=4.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:nil];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n#### 使用path\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    //创建一条路径\n    CGMutablePathRef path=CGPathCreateMutable();\n    //设置一个圆的路径\n    CGPathAddEllipseInRect(path, NULL, CGRectMake(150, 100, 100, 100));\n    keyAnima.path=path;\n    \n    //有create就一定要有release\n    CGPathRelease(path);\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=5.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:@\"wendingding\"];\n}\n\n- (IBAction)stopOnClick:(UIButton *)sender {\n    //停止self.customView.layer上名称标示为wendingding的动画\n    [self.customView.layer removeAnimationForKey:@\"wendingding\"];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n点击停止动画，程序内部会调用  `[self.customView.layer removeAnimationForKey:@\"wendingding\"];`停止`self.customView.layer`上名称标示为wendingding的动画。\n\n#### 图标抖动\n```objc\n\n#import \"YYViewController.h\"\n#define angle2Radian(angle)  ((angle)/180.0*M_PI)\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n@end\n\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    keyAnima.keyPath=@\"transform.rotation\";\n    //设置动画时间\n    keyAnima.duration=0.1;\n    //设置图标抖动弧度\n    //把度数转换为弧度  度数/180*M_PI\n    keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];\n    //设置动画的重复次数(设置为最大值)\n    keyAnima.repeatCount=MAXFLOAT;\n    \n    keyAnima.fillMode=kCAFillModeForwards;\n    keyAnima.removedOnCompletion=NO;\n    //2.添加动画\n    [self.iconView.layer addAnimation:keyAnima forKey:nil];\n}\n\n@end\n```\n\n其中，`keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];`表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。\n\n**@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象**\n\n## 转场动画和组动画\n### 介绍\nCATransition用于做转场动画\n属性：\n- type：动画过渡类型\n- subtype：动画过渡方向\n- startProgress：动画起点(在整体动画的百分比)\n- endProgress：动画终点(在整体动画的百分比)\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,assign) int index;\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n- (IBAction)preOnClick:(UIButton *)sender;\n- (IBAction)nextOnClick:(UIButton *)sender;\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.index=1;\n\n}\n\n- (IBAction)preOnClick:(UIButton *)sender {\n    self.index--;\n    if (self.index<1) {\n        self.index=7;\n    }\n    self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //创建核心动画\n    CATransition *ca=[CATransition animation];\n    //告诉要执行什么动画\n    //设置过度效果\n    ca.type=@\"cube\";\n    //设置动画的过度方向（向左）\n    ca.subtype=kCATransitionFromLeft;\n    //设置动画的时间\n    ca.duration=2.0;\n    //添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n//下一张\n- (IBAction)nextOnClick:(UIButton *)sender {\n    self.index++;\n    if (self.index>7) {\n        self.index=1;\n    }\n        self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //1.创建核心动画\n    CATransition *ca=[CATransition animation];\n    \n    //1.1告诉要执行什么动画\n    //1.2设置过度效果\n    ca.type=@\"cube\";\n    //1.3设置动画的过度方向（向右）\n    ca.subtype=kCATransitionFromRight;\n    //1.4设置动画的时间\n    ca.duration=2.0;\n    //1.5设置动画的起点\n    ca.startProgress=0.5;\n    //1.6设置动画的终点\n//    ca.endProgress=0.5;\n    \n    //2.添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n@end\n```\n\n### 组动画\n将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *iconView;\n\n@end\n\n@implementation NJViewController\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{\n    // 平移动画\n    CABasicAnimation *a1 = [CABasicAnimation animation];\n    a1.keyPath = @\"transform.translation.y\";\n    a1.toValue = @(100);\n    // 缩放动画\n    CABasicAnimation *a2 = [CABasicAnimation animation];\n    a2.keyPath = @\"transform.scale\";\n    a2.toValue = @(0.0);\n    // 旋转动画\n    CABasicAnimation *a3 = [CABasicAnimation animation];\n    a3.keyPath = @\"transform.rotation\";\n    a3.toValue = @(M_PI_2);\n    // 组动画\n    CAAnimationGroup *groupAnima = [CAAnimationGroup animation];\n    \n    groupAnima.animations = @[a1, a2, a3];\n    \n    //设置组动画的时间\n    groupAnima.duration = 2;\n    groupAnima.fillMode = kCAFillModeForwards;\n    groupAnima.removedOnCompletion = NO;\n    \n    [self.iconView.layer addAnimation:groupAnima forKey:nil];\n}\n\n@end\n```\n\n## UIView封装动画\n### UIView动画（首尾）\n#### 简介\n执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。\n常见方法：\n- **+ (void)setAnimationDelegate:(id)delegate**     设置动画代理对象，当动画开始或者结束时会发消息给代理对象\n- **+ (void)setAnimationWillStartSelector:(SEL)selector**   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDidStopSelector:(SEL)selector**  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDuration:(NSTimeInterval)duration**   动画的持续时间，秒为单位\n- **+ (void)setAnimationDelay:(NSTimeInterval)delay**  动画延迟delay秒后再开始\n- **+ (void)setAnimationStartDate:(NSDate \\*)startDate**   动画的开始时间，默认为now\n- **+ (void)setAnimationCurve:(UIViewAnimationCurve)curve**  动画的节奏控制\n- **+ (void)setAnimationRepeatCount:(float)repeatCount**  动画的重复次数\n- **+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses**  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反\n- **+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView \\*)view cache:(BOOL)cache**  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好\n\n#### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n}\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //打印动画块的位置\n    NSLog(@\"动画执行之前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n    \n    //首尾式动画\n    [UIView beginAnimations:nil context:nil];\n    //执行动画\n    //设置动画执行时间\n    [UIView setAnimationDuration:2.0];\n    //设置代理\n    [UIView setAnimationDelegate:self];\n    //设置动画执行完毕调用的事件\n    [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];\n    self.customView.center=CGPointMake(200, 300);\n    [UIView commitAnimations];\n\n}\n\n-(void)didStopAnimation\n{\n    NSLog(@\"动画执行完毕\");\n    //打印动画块的位置\n    NSLog(@\"动画执行之后的位置：%@\",NSStringFromCGPoint(self.customView.center));\n}\n\n@end\n```\n\n#### UIView封装的动画与CALayer动画的对比\n使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。\n\n**CALayer核心动画与UIView动画的区别**：\nUIView封装的动画，改变`view`或者`layer`执行完毕之后不会反弹。如果是通过**CALayer核心动画**改变`layer`的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。\n\n### block动画\n#### 方法：\n- **+(void)animateWithDuration:delay:options:animations:completion:**\n- **+(void)transitionWithView:duration:options:animations:completion:**\n- **+(void)transitionFromView:toView:duration:options:completion:**\n属性简介：\n1. duration：动画的持续时间\n2. delay：动画延迟delay秒后开始\n3. options：动画的节奏控制/转场动画的类型(重复，转场等)\n4. animations：将改变视图属性的代码放在这个block中\n5. completion：动画结束后，会自动调用这个block\n\n前两个方法用起来好像没什么区别。\n\n#### 示例：\n```objc\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //block代码块动画\n        [UIView transitionWithView:self.customView duration:3.0 options:0 animations:^{\n            //执行的动画\n            NSLog(@\"动画开始执行前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n            self.customView.center=CGPointMake(200, 300);\n        } completion:^(BOOL finished) {\n            //动画执行完毕后的首位操作\n            NSLog(@\"动画执行完毕\");\n            NSLog(@\"动画执行完毕后的位置：%@\",NSStringFromCGPoint( self.customView.center));\n        }];\n}\n```\n\n> Demo详见CALayer_Transform\n\n\n","source":"_posts/ios动画.md","raw":"title: ios核心动画\ndate: 2016/8/16 14:07:12  \ncategories: iOS\ntags: [Animation]\n\n---\n依旧是[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)关于核心动画的内容。作为入门\n\n**核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。**\n\n<!--more-->\n\n## 核心动画简介\nCAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。\n\nCAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation\n它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@\"position\"为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果\n\n常见属性：\n- duration：动画的持续时间\n- repeatCount：动画的重复次数\n- repeatDuration：动画的重复时间\n- removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards\n- fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后\n- beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间\n- timingFunction：速度控制函数，控制动画运行的节奏\n- delegate：动画代理\n\n## 基础动画\n### 简介\nCABasicAnimation，是CApropertyAnimation的子类\n\n属性：\n- fromValue：keyPath相应属性的初始值\n- toValue：keyPath相应属性的结束值\n\n随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue\n\n如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但**在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。**比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。\n\n### 示例\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,strong)CALayer *myLayer;\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    //创建layer\n    CALayer *myLayer=[CALayer layer];\n    //设置layer的属性\n    myLayer.bounds=CGRectMake(0, 0, 50, 80);\n    myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n    myLayer.position=CGPointMake(50, 50);\n    myLayer.anchorPoint=CGPointMake(0, 0);\n    myLayer.cornerRadius=20;\n    //添加layer\n    [self.view.layer addSublayer:myLayer];\n    self.myLayer=myLayer;\n}\n//设置 平移 动画\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    //    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:<#(NSString *)#>]\n    CABasicAnimation *anima=[CABasicAnimation animation];\n    \n    //1.1告诉系统要执行什么样的动画\n    anima.keyPath=@\"position\";\n    //设置通过动画，将layer从哪儿移动到哪儿\n    anima.fromValue=[NSValue valueWithCGPoint:CGPointMake(0, 0)];\n    anima.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 300)];\n    \n    //1.2设置动画执行完毕之后不删除动画\n    anima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    anima.fillMode=kCAFillModeForwards;\n\n    //2.添加核心动画到layer\n    [self.myLayer addAnimation:anima forKey:nil];\n\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始执行动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    //动画执行完毕，打印执行完毕后的position值\n    NSString *str=NSStringFromCGPoint(self.myLayer.position);\n    NSLog(@\"执行后：%@\",str);\n}\n\n@end\n```\n\n其中keypath的值决定产生什么动画\n1. position：执行平移动画\n2. bounds：执行缩放动画\n3. transform：执行旋转动画\n\n## 关键帧动画\n### 简介\nCAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值\n\n属性：\n- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧\n- path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略\n- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的\n\n说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation\n\n### 示例\n#### 使用value\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    NSValue *value1=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    NSValue *value2=[NSValue valueWithCGPoint:CGPointMake(200, 100)];\n    NSValue *value3=[NSValue valueWithCGPoint:CGPointMake(200, 200)];\n    NSValue *value4=[NSValue valueWithCGPoint:CGPointMake(100, 200)];\n    NSValue *value5=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    keyAnima.values=@[value1,value2,value3,value4,value5];\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=4.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:nil];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n#### 使用path\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    //创建一条路径\n    CGMutablePathRef path=CGPathCreateMutable();\n    //设置一个圆的路径\n    CGPathAddEllipseInRect(path, NULL, CGRectMake(150, 100, 100, 100));\n    keyAnima.path=path;\n    \n    //有create就一定要有release\n    CGPathRelease(path);\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=5.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:@\"wendingding\"];\n}\n\n- (IBAction)stopOnClick:(UIButton *)sender {\n    //停止self.customView.layer上名称标示为wendingding的动画\n    [self.customView.layer removeAnimationForKey:@\"wendingding\"];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n点击停止动画，程序内部会调用  `[self.customView.layer removeAnimationForKey:@\"wendingding\"];`停止`self.customView.layer`上名称标示为wendingding的动画。\n\n#### 图标抖动\n```objc\n\n#import \"YYViewController.h\"\n#define angle2Radian(angle)  ((angle)/180.0*M_PI)\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n@end\n\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    keyAnima.keyPath=@\"transform.rotation\";\n    //设置动画时间\n    keyAnima.duration=0.1;\n    //设置图标抖动弧度\n    //把度数转换为弧度  度数/180*M_PI\n    keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];\n    //设置动画的重复次数(设置为最大值)\n    keyAnima.repeatCount=MAXFLOAT;\n    \n    keyAnima.fillMode=kCAFillModeForwards;\n    keyAnima.removedOnCompletion=NO;\n    //2.添加动画\n    [self.iconView.layer addAnimation:keyAnima forKey:nil];\n}\n\n@end\n```\n\n其中，`keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];`表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。\n\n**@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象**\n\n## 转场动画和组动画\n### 介绍\nCATransition用于做转场动画\n属性：\n- type：动画过渡类型\n- subtype：动画过渡方向\n- startProgress：动画起点(在整体动画的百分比)\n- endProgress：动画终点(在整体动画的百分比)\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,assign) int index;\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n- (IBAction)preOnClick:(UIButton *)sender;\n- (IBAction)nextOnClick:(UIButton *)sender;\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.index=1;\n\n}\n\n- (IBAction)preOnClick:(UIButton *)sender {\n    self.index--;\n    if (self.index<1) {\n        self.index=7;\n    }\n    self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //创建核心动画\n    CATransition *ca=[CATransition animation];\n    //告诉要执行什么动画\n    //设置过度效果\n    ca.type=@\"cube\";\n    //设置动画的过度方向（向左）\n    ca.subtype=kCATransitionFromLeft;\n    //设置动画的时间\n    ca.duration=2.0;\n    //添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n//下一张\n- (IBAction)nextOnClick:(UIButton *)sender {\n    self.index++;\n    if (self.index>7) {\n        self.index=1;\n    }\n        self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //1.创建核心动画\n    CATransition *ca=[CATransition animation];\n    \n    //1.1告诉要执行什么动画\n    //1.2设置过度效果\n    ca.type=@\"cube\";\n    //1.3设置动画的过度方向（向右）\n    ca.subtype=kCATransitionFromRight;\n    //1.4设置动画的时间\n    ca.duration=2.0;\n    //1.5设置动画的起点\n    ca.startProgress=0.5;\n    //1.6设置动画的终点\n//    ca.endProgress=0.5;\n    \n    //2.添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n@end\n```\n\n### 组动画\n将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *iconView;\n\n@end\n\n@implementation NJViewController\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{\n    // 平移动画\n    CABasicAnimation *a1 = [CABasicAnimation animation];\n    a1.keyPath = @\"transform.translation.y\";\n    a1.toValue = @(100);\n    // 缩放动画\n    CABasicAnimation *a2 = [CABasicAnimation animation];\n    a2.keyPath = @\"transform.scale\";\n    a2.toValue = @(0.0);\n    // 旋转动画\n    CABasicAnimation *a3 = [CABasicAnimation animation];\n    a3.keyPath = @\"transform.rotation\";\n    a3.toValue = @(M_PI_2);\n    // 组动画\n    CAAnimationGroup *groupAnima = [CAAnimationGroup animation];\n    \n    groupAnima.animations = @[a1, a2, a3];\n    \n    //设置组动画的时间\n    groupAnima.duration = 2;\n    groupAnima.fillMode = kCAFillModeForwards;\n    groupAnima.removedOnCompletion = NO;\n    \n    [self.iconView.layer addAnimation:groupAnima forKey:nil];\n}\n\n@end\n```\n\n## UIView封装动画\n### UIView动画（首尾）\n#### 简介\n执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。\n常见方法：\n- **+ (void)setAnimationDelegate:(id)delegate**     设置动画代理对象，当动画开始或者结束时会发消息给代理对象\n- **+ (void)setAnimationWillStartSelector:(SEL)selector**   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDidStopSelector:(SEL)selector**  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDuration:(NSTimeInterval)duration**   动画的持续时间，秒为单位\n- **+ (void)setAnimationDelay:(NSTimeInterval)delay**  动画延迟delay秒后再开始\n- **+ (void)setAnimationStartDate:(NSDate \\*)startDate**   动画的开始时间，默认为now\n- **+ (void)setAnimationCurve:(UIViewAnimationCurve)curve**  动画的节奏控制\n- **+ (void)setAnimationRepeatCount:(float)repeatCount**  动画的重复次数\n- **+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses**  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反\n- **+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView \\*)view cache:(BOOL)cache**  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好\n\n#### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n}\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //打印动画块的位置\n    NSLog(@\"动画执行之前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n    \n    //首尾式动画\n    [UIView beginAnimations:nil context:nil];\n    //执行动画\n    //设置动画执行时间\n    [UIView setAnimationDuration:2.0];\n    //设置代理\n    [UIView setAnimationDelegate:self];\n    //设置动画执行完毕调用的事件\n    [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];\n    self.customView.center=CGPointMake(200, 300);\n    [UIView commitAnimations];\n\n}\n\n-(void)didStopAnimation\n{\n    NSLog(@\"动画执行完毕\");\n    //打印动画块的位置\n    NSLog(@\"动画执行之后的位置：%@\",NSStringFromCGPoint(self.customView.center));\n}\n\n@end\n```\n\n#### UIView封装的动画与CALayer动画的对比\n使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。\n\n**CALayer核心动画与UIView动画的区别**：\nUIView封装的动画，改变`view`或者`layer`执行完毕之后不会反弹。如果是通过**CALayer核心动画**改变`layer`的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。\n\n### block动画\n#### 方法：\n- **+(void)animateWithDuration:delay:options:animations:completion:**\n- **+(void)transitionWithView:duration:options:animations:completion:**\n- **+(void)transitionFromView:toView:duration:options:completion:**\n属性简介：\n1. duration：动画的持续时间\n2. delay：动画延迟delay秒后开始\n3. options：动画的节奏控制/转场动画的类型(重复，转场等)\n4. animations：将改变视图属性的代码放在这个block中\n5. completion：动画结束后，会自动调用这个block\n\n前两个方法用起来好像没什么区别。\n\n#### 示例：\n```objc\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //block代码块动画\n        [UIView transitionWithView:self.customView duration:3.0 options:0 animations:^{\n            //执行的动画\n            NSLog(@\"动画开始执行前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n            self.customView.center=CGPointMake(200, 300);\n        } completion:^(BOOL finished) {\n            //动画执行完毕后的首位操作\n            NSLog(@\"动画执行完毕\");\n            NSLog(@\"动画执行完毕后的位置：%@\",NSStringFromCGPoint( self.customView.center));\n        }];\n}\n```\n\n> Demo详见CALayer_Transform\n\n\n","slug":"ios动画","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dr2002o7hzgrck22evy","content":"<p>依旧是<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\" target=\"_blank\" rel=\"external\">文顶顶的ios开发UI篇</a>关于核心动画的内容。作为入门</p>\n<p><strong>核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"核心动画简介\"><a href=\"#核心动画简介\" class=\"headerlink\" title=\"核心动画简介\"></a>核心动画简介</h2><p>CAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。</p>\n<p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation<br>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>\n<p>常见属性：</p>\n<ul>\n<li>duration：动画的持续时间</li>\n<li>repeatCount：动画的重复次数</li>\n<li>repeatDuration：动画的重复时间</li>\n<li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li>\n<li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li>\n<li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li>\n<li>timingFunction：速度控制函数，控制动画运行的节奏</li>\n<li>delegate：动画代理</li>\n</ul>\n<h2 id=\"基础动画\"><a href=\"#基础动画\" class=\"headerlink\" title=\"基础动画\"></a>基础动画</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CABasicAnimation，是CApropertyAnimation的子类</p>\n<p>属性：</p>\n<ul>\n<li>fromValue：keyPath相应属性的初始值</li>\n<li>toValue：keyPath相应属性的结束值</li>\n</ul>\n<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>\n<p>如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但<strong>在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</strong>比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>)<span class=\"built_in\">CALayer</span> *myLayer;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">    myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">    myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"comment\">//添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设置 平移 动画</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"comment\">//    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:&lt;#(NSString *)#&gt;]</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *anima=[<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么样的动画</span></div><div class=\"line\">    anima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置通过动画，将layer从哪儿移动到哪儿</span></div><div class=\"line\">    anima.fromValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>)];</div><div class=\"line\">    anima.toValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕之后不删除动画</span></div><div class=\"line\">    anima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    anima.fillMode=kCAFillModeForwards;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画到layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.myLayer addAnimation:anima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始执行动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//动画执行完毕，打印执行完毕后的position值</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str=<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.myLayer.position);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"执行后：%@\"</span>,str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中keypath的值决定产生什么动画</p>\n<ol>\n<li>position：执行平移动画</li>\n<li>bounds：执行缩放动画</li>\n<li>transform：执行旋转动画</li>\n</ol>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>\n<p>属性：</p>\n<ul>\n<li>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>\n<li>path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</li>\n<li>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>\n</ul>\n<p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"使用value\"><a href=\"#使用value\" class=\"headerlink\" title=\"使用value\"></a>使用value</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value1=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value2=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value3=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value4=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value5=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    keyAnima.values=@[value1,value2,value3,value4,value5];</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">4.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用path\"><a href=\"#使用path\" class=\"headerlink\" title=\"使用path\"></a>使用path</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//创建一条路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path=<span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"comment\">//设置一个圆的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">150</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    keyAnima.path=path;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//有create就一定要有release</span></div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">5.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)stopOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//停止self.customView.layer上名称标示为wendingding的动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer removeAnimationForKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>点击停止动画，程序内部会调用  <code>[self.customView.layer removeAnimationForKey:@&quot;wendingding&quot;];</code>停止<code>self.customView.layer</code>上名称标示为wendingding的动画。</p>\n<h4 id=\"图标抖动\"><a href=\"#图标抖动\" class=\"headerlink\" title=\"图标抖动\"></a>图标抖动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#define angle2Radian(angle)  ((angle)/180.0*M_PI)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">0.1</span>;</div><div class=\"line\">    <span class=\"comment\">//设置图标抖动弧度</span></div><div class=\"line\">    <span class=\"comment\">//把度数转换为弧度  度数/180*M_PI</span></div><div class=\"line\">    keyAnima.values=@[@(-angle2Radian(<span class=\"number\">4</span>)),@(angle2Radian(<span class=\"number\">4</span>)),@(-angle2Radian(<span class=\"number\">4</span>))];</div><div class=\"line\">    <span class=\"comment\">//设置动画的重复次数(设置为最大值)</span></div><div class=\"line\">    keyAnima.repeatCount=MAXFLOAT;</div><div class=\"line\">    </div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中，<code>keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];</code>表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。</p>\n<p><strong>@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象</strong></p>\n<h2 id=\"转场动画和组动画\"><a href=\"#转场动画和组动画\" class=\"headerlink\" title=\"转场动画和组动画\"></a>转场动画和组动画</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CATransition用于做转场动画<br>属性：</p>\n<ul>\n<li>type：动画过渡类型</li>\n<li>subtype：动画过渡方向</li>\n<li>startProgress：动画起点(在整体动画的百分比)</li>\n<li>endProgress：动画终点(在整体动画的百分比)</li>\n</ul>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> index;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index--;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">7</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    <span class=\"comment\">//告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画的过度方向（向左）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromLeft;</div><div class=\"line\">    <span class=\"comment\">//设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下一张</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&gt;<span class=\"number\">7</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//1.2设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置动画的过度方向（向右）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromRight;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的起点</span></div><div class=\"line\">    ca.startProgress=<span class=\"number\">0.5</span>;</div><div class=\"line\">    <span class=\"comment\">//1.6设置动画的终点</span></div><div class=\"line\"><span class=\"comment\">//    ca.endProgress=0.5;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"组动画\"><a href=\"#组动画\" class=\"headerlink\" title=\"组动画\"></a>组动画</h3><p>将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.</p>\n<h3 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NJViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 平移动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a1 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a1.keyPath = <span class=\"string\">@\"transform.translation.y\"</span>;</div><div class=\"line\">    a1.toValue = @(<span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"comment\">// 缩放动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a2 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a2.keyPath = <span class=\"string\">@\"transform.scale\"</span>;</div><div class=\"line\">    a2.toValue = @(<span class=\"number\">0.0</span>);</div><div class=\"line\">    <span class=\"comment\">// 旋转动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a3 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a3.keyPath = <span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    a3.toValue = @(M_PI_2);</div><div class=\"line\">    <span class=\"comment\">// 组动画</span></div><div class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *groupAnima = [<span class=\"built_in\">CAAnimationGroup</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    groupAnima.animations = @[a1, a2, a3];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置组动画的时间</span></div><div class=\"line\">    groupAnima.duration = <span class=\"number\">2</span>;</div><div class=\"line\">    groupAnima.fillMode = kCAFillModeForwards;</div><div class=\"line\">    groupAnima.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:groupAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"UIView封装动画\"><a href=\"#UIView封装动画\" class=\"headerlink\" title=\"UIView封装动画\"></a>UIView封装动画</h2><h3 id=\"UIView动画（首尾）\"><a href=\"#UIView动画（首尾）\" class=\"headerlink\" title=\"UIView动画（首尾）\"></a>UIView动画（首尾）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。<br>常见方法：</p>\n<ul>\n<li><strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象</li>\n<li><strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位</li>\n<li><strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始</li>\n<li><strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now</li>\n<li><strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制</li>\n<li><strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数</li>\n<li><strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</li>\n<li><strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</li>\n</ul>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//首尾式动画</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"literal\">nil</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//执行动画</span></div><div class=\"line\">    <span class=\"comment\">//设置动画执行时间</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    <span class=\"comment\">//设置动画执行完毕调用的事件</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDidStopSelector:<span class=\"keyword\">@selector</span>(didStopAnimation)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> commitAnimations];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)didStopAnimation</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"UIView封装的动画与CALayer动画的对比\"><a href=\"#UIView封装的动画与CALayer动画的对比\" class=\"headerlink\" title=\"UIView封装的动画与CALayer动画的对比\"></a>UIView封装的动画与CALayer动画的对比</h4><p>使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>\n<p><strong>CALayer核心动画与UIView动画的区别</strong>：<br>UIView封装的动画，改变<code>view</code>或者<code>layer</code>执行完毕之后不会反弹。如果是通过<strong>CALayer核心动画</strong>改变<code>layer</code>的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</p>\n<h3 id=\"block动画\"><a href=\"#block动画\" class=\"headerlink\" title=\"block动画\"></a>block动画</h3><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li><strong>+(void)animateWithDuration:delay:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionWithView:duration:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionFromView:toView:duration:options:completion:</strong><br>属性简介：</li>\n</ul>\n<ol>\n<li>duration：动画的持续时间</li>\n<li>delay：动画延迟delay秒后开始</li>\n<li>options：动画的节奏控制/转场动画的类型(重复，转场等)</li>\n<li>animations：将改变视图属性的代码放在这个block中</li>\n<li>completion：动画结束后，会自动调用这个block</li>\n</ol>\n<p>前两个方法用起来好像没什么区别。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//block代码块动画</span></div><div class=\"line\">        [<span class=\"built_in\">UIView</span> transitionWithView:<span class=\"keyword\">self</span>.customView duration:<span class=\"number\">3.0</span> options:<span class=\"number\">0</span> animations:^&#123;</div><div class=\"line\">            <span class=\"comment\">//执行的动画</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画开始执行前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">            <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">            <span class=\"comment\">//动画执行完毕后的首位操作</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>( <span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">        &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>\n","excerpt":"<p>依旧是<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\">文顶顶的ios开发UI篇</a>关于核心动画的内容。作为入门</p>\n<p><strong>核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。</strong></p>","more":"<h2 id=\"核心动画简介\"><a href=\"#核心动画简介\" class=\"headerlink\" title=\"核心动画简介\"></a>核心动画简介</h2><p>CAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。</p>\n<p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation<br>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>\n<p>常见属性：</p>\n<ul>\n<li>duration：动画的持续时间</li>\n<li>repeatCount：动画的重复次数</li>\n<li>repeatDuration：动画的重复时间</li>\n<li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li>\n<li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li>\n<li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li>\n<li>timingFunction：速度控制函数，控制动画运行的节奏</li>\n<li>delegate：动画代理</li>\n</ul>\n<h2 id=\"基础动画\"><a href=\"#基础动画\" class=\"headerlink\" title=\"基础动画\"></a>基础动画</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CABasicAnimation，是CApropertyAnimation的子类</p>\n<p>属性：</p>\n<ul>\n<li>fromValue：keyPath相应属性的初始值</li>\n<li>toValue：keyPath相应属性的结束值</li>\n</ul>\n<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>\n<p>如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但<strong>在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</strong>比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>)<span class=\"built_in\">CALayer</span> *myLayer;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">    myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">    myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"comment\">//添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设置 平移 动画</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"comment\">//    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:&lt;#(NSString *)#&gt;]</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *anima=[<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么样的动画</span></div><div class=\"line\">    anima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置通过动画，将layer从哪儿移动到哪儿</span></div><div class=\"line\">    anima.fromValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>)];</div><div class=\"line\">    anima.toValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕之后不删除动画</span></div><div class=\"line\">    anima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    anima.fillMode=kCAFillModeForwards;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画到layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.myLayer addAnimation:anima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始执行动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//动画执行完毕，打印执行完毕后的position值</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str=<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.myLayer.position);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"执行后：%@\"</span>,str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中keypath的值决定产生什么动画</p>\n<ol>\n<li>position：执行平移动画</li>\n<li>bounds：执行缩放动画</li>\n<li>transform：执行旋转动画</li>\n</ol>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>\n<p>属性：</p>\n<ul>\n<li>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>\n<li>path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</li>\n<li>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>\n</ul>\n<p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"使用value\"><a href=\"#使用value\" class=\"headerlink\" title=\"使用value\"></a>使用value</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value1=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value2=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value3=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value4=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value5=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    keyAnima.values=@[value1,value2,value3,value4,value5];</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">4.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用path\"><a href=\"#使用path\" class=\"headerlink\" title=\"使用path\"></a>使用path</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//创建一条路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path=<span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"comment\">//设置一个圆的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">150</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    keyAnima.path=path;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//有create就一定要有release</span></div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">5.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)stopOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//停止self.customView.layer上名称标示为wendingding的动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer removeAnimationForKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>点击停止动画，程序内部会调用  <code>[self.customView.layer removeAnimationForKey:@&quot;wendingding&quot;];</code>停止<code>self.customView.layer</code>上名称标示为wendingding的动画。</p>\n<h4 id=\"图标抖动\"><a href=\"#图标抖动\" class=\"headerlink\" title=\"图标抖动\"></a>图标抖动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#define angle2Radian(angle)  ((angle)/180.0*M_PI)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">0.1</span>;</div><div class=\"line\">    <span class=\"comment\">//设置图标抖动弧度</span></div><div class=\"line\">    <span class=\"comment\">//把度数转换为弧度  度数/180*M_PI</span></div><div class=\"line\">    keyAnima.values=@[@(-angle2Radian(<span class=\"number\">4</span>)),@(angle2Radian(<span class=\"number\">4</span>)),@(-angle2Radian(<span class=\"number\">4</span>))];</div><div class=\"line\">    <span class=\"comment\">//设置动画的重复次数(设置为最大值)</span></div><div class=\"line\">    keyAnima.repeatCount=MAXFLOAT;</div><div class=\"line\">    </div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中，<code>keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];</code>表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。</p>\n<p><strong>@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象</strong></p>\n<h2 id=\"转场动画和组动画\"><a href=\"#转场动画和组动画\" class=\"headerlink\" title=\"转场动画和组动画\"></a>转场动画和组动画</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CATransition用于做转场动画<br>属性：</p>\n<ul>\n<li>type：动画过渡类型</li>\n<li>subtype：动画过渡方向</li>\n<li>startProgress：动画起点(在整体动画的百分比)</li>\n<li>endProgress：动画终点(在整体动画的百分比)</li>\n</ul>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> index;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index--;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">7</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    <span class=\"comment\">//告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画的过度方向（向左）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromLeft;</div><div class=\"line\">    <span class=\"comment\">//设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下一张</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&gt;<span class=\"number\">7</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//1.2设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置动画的过度方向（向右）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromRight;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的起点</span></div><div class=\"line\">    ca.startProgress=<span class=\"number\">0.5</span>;</div><div class=\"line\">    <span class=\"comment\">//1.6设置动画的终点</span></div><div class=\"line\"><span class=\"comment\">//    ca.endProgress=0.5;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"组动画\"><a href=\"#组动画\" class=\"headerlink\" title=\"组动画\"></a>组动画</h3><p>将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.</p>\n<h3 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NJViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 平移动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a1 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a1.keyPath = <span class=\"string\">@\"transform.translation.y\"</span>;</div><div class=\"line\">    a1.toValue = @(<span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"comment\">// 缩放动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a2 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a2.keyPath = <span class=\"string\">@\"transform.scale\"</span>;</div><div class=\"line\">    a2.toValue = @(<span class=\"number\">0.0</span>);</div><div class=\"line\">    <span class=\"comment\">// 旋转动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a3 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a3.keyPath = <span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    a3.toValue = @(M_PI_2);</div><div class=\"line\">    <span class=\"comment\">// 组动画</span></div><div class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *groupAnima = [<span class=\"built_in\">CAAnimationGroup</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    groupAnima.animations = @[a1, a2, a3];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置组动画的时间</span></div><div class=\"line\">    groupAnima.duration = <span class=\"number\">2</span>;</div><div class=\"line\">    groupAnima.fillMode = kCAFillModeForwards;</div><div class=\"line\">    groupAnima.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:groupAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"UIView封装动画\"><a href=\"#UIView封装动画\" class=\"headerlink\" title=\"UIView封装动画\"></a>UIView封装动画</h2><h3 id=\"UIView动画（首尾）\"><a href=\"#UIView动画（首尾）\" class=\"headerlink\" title=\"UIView动画（首尾）\"></a>UIView动画（首尾）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。<br>常见方法：</p>\n<ul>\n<li><strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象</li>\n<li><strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位</li>\n<li><strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始</li>\n<li><strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now</li>\n<li><strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制</li>\n<li><strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数</li>\n<li><strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</li>\n<li><strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</li>\n</ul>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//首尾式动画</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"literal\">nil</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//执行动画</span></div><div class=\"line\">    <span class=\"comment\">//设置动画执行时间</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    <span class=\"comment\">//设置动画执行完毕调用的事件</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDidStopSelector:<span class=\"keyword\">@selector</span>(didStopAnimation)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> commitAnimations];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)didStopAnimation</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"UIView封装的动画与CALayer动画的对比\"><a href=\"#UIView封装的动画与CALayer动画的对比\" class=\"headerlink\" title=\"UIView封装的动画与CALayer动画的对比\"></a>UIView封装的动画与CALayer动画的对比</h4><p>使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>\n<p><strong>CALayer核心动画与UIView动画的区别</strong>：<br>UIView封装的动画，改变<code>view</code>或者<code>layer</code>执行完毕之后不会反弹。如果是通过<strong>CALayer核心动画</strong>改变<code>layer</code>的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</p>\n<h3 id=\"block动画\"><a href=\"#block动画\" class=\"headerlink\" title=\"block动画\"></a>block动画</h3><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li><strong>+(void)animateWithDuration:delay:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionWithView:duration:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionFromView:toView:duration:options:completion:</strong><br>属性简介：</li>\n</ul>\n<ol>\n<li>duration：动画的持续时间</li>\n<li>delay：动画延迟delay秒后开始</li>\n<li>options：动画的节奏控制/转场动画的类型(重复，转场等)</li>\n<li>animations：将改变视图属性的代码放在这个block中</li>\n<li>completion：动画结束后，会自动调用这个block</li>\n</ol>\n<p>前两个方法用起来好像没什么区别。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//block代码块动画</span></div><div class=\"line\">        [<span class=\"built_in\">UIView</span> transitionWithView:<span class=\"keyword\">self</span>.customView duration:<span class=\"number\">3.0</span> options:<span class=\"number\">0</span> animations:^&#123;</div><div class=\"line\">            <span class=\"comment\">//执行的动画</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画开始执行前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">            <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">            <span class=\"comment\">//动画执行完毕后的首位操作</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>( <span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">        &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>"},{"title":"lldb 调试方法","date":"2016-09-21T06:07:12.000Z","_content":"\n偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章[与调试器共舞 - LLDB 的华尔兹](https://objccn.io/issue-19-2/)这篇文章帮助最大。\n\n<!--more-->\nXcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。\n\nLLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：\n1. 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态\n2. 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序\n\n不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。\n\n\n## expression\nexpression的几个命令是最常用的，能提升debug效率的命令。\n\n### print\n打印一个对象:\n![print](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true)\n可以直接缩写`p`达到同样的效果。\n\n结果中有个`$0`，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以`$`开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：\n![print2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true)\n\n### expression\n#### 使用\n如果想要改变一个值，或者执行一个方法。可以使用`expression`或者`e`：\n![expression](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true)\n\nprint其实是特殊的expression，比如`p count =18`其结果和`expression count = 18`结果一样。事实上，`print`是 `expression --` 的缩写。\n\n#### 应用\n由于`expression`可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：\n```objc\n// 改变颜色\n(lldb) expression self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression [CATransaction flush]\n```\n不只是改变颜色，frame，animation等都能改变，非常有用。\n\n如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。\n\n### po\n`print`输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：\n```objc\n(lldb) p @[ @\"foo\", @\"bar\" ]\n\n(NSArray *) $8 = 0x00007fdb9b71b3e0 @\"2 objects\" \n```\n\n这个时候可以使用`po`(print object 的缩写)，相当于调用对象的`description`方法。\n```objc\n(lldb) po $8\n<__NSArrayI 0x7fdb9b71b3e0>(\nfoo,\nbar\n)\n(lldb) po @\"lunar\"\nlunar\n```\n\n## thread\n### bt\n可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:\n![frame](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true)\n\n### thread return\n这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。\n\n它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后**立刻执行返回命令，跳出当前栈帧**。这意味这函数剩余的部分**不会被执行**。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是**在函数的开头执行这个命令**，是个非常好的隔离这个函数，伪造返回值的方式 。\n\n比如下图所示：\n![return](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true)\n正常通过`isOdd`方法，一定是`return NO`的，但是通过`(lldb) thread return YES`，跳过了`isOdd`方法里的方法块，直接`return YES`\n\n正如上面所述，必须要在断点进行到如图所示的地方才可以使用`thread return`，因为:\n1. 此时当前栈帧是`isOdd`\n2. 不会造成引用问题\n\n## breakpoint\n断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.\n\n### 流程控制\n当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:\n![debug](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true)\n意义都很明确，不多说了，列举下对应的命令：\n1. continue按钮 => `continue`,缩写`c`\n2. step over按钮 => `next`，缩写`n`\n3. step in按钮 => `step`,缩写`s`\n4. step out按钮 => `finish`\n\n### 设置断点\n在断点处右击，选择`Edit Breakpoint`弹出如下设置框：\n![breakpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true)\n\n#### 蓝色的勾\n表示enable和disable断点。\n#### Condition\n指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，**不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法**）。\n#### Ignore\n忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。\n#### Action\n它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：\n![menu](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true)\n默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：\n1. **Debugger Command**：默认的选项，可以让断点执行LLDB调试命令。\n2. **Log Message**：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用`@exp@`形式。\n\n#### Options\n一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。\n### 断点类型\n#### 异常断点\n异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true)\n\n#### 符号断点\n他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true)\n\n它比普通断点的自定义设置界面多出了两个内容\n- **Symbol**：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:\n\t```objc\n\t-[MyViewController viewDidAppear:]\n\t+[MyViewController sharedInstance]\n\t```\n- **Module**：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。\n\n需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。\n\n### watchpoint\n有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用`watchpoin`t来监视一个指针的指向。\n\n当指针指向变化时，`watchpoint`会触发:\n![watchpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true)\n#### set\n添加watchpoint的方式如上图所示\n```objc\n(lldb) watchpoint set variable xxx\n```\n这里要说明一下，watchpoint要监听的对象必须是**当前类的对象**：\n![watchpoint2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true)\n由于`self.view`是从`UIViewController`中继承过来的，因此无法监听。\n\n另外，上面的`addr = 0x1556747f0`**不是指`_myView`在栈中的索引**，而是指这个Watchpoint在堆中的地址。\n\nWatchpoint的**原理**应该是在这个地址中写入了原来`_myView`指向的地址，然后对新`_myView`指向的地址和Watchpoint指向的地址是否相同来做出判断的。\n\n#### disable/delete/enable\nwatchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：\n![watchpoint3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true)\n\n## 其他技巧\n### run\n这是我比较喜欢的方法，所以单独列出来。\n\n调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入`run`就能直接让程序重新加载了。\n\n### 通过地址操作\n比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。\n\n本来想要监控`self.view.backgroundColor`的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。\n\n因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。\n\n### 代替NSLog\n看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的`debug log`的，而是`error log`；每次`NSLog`都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。\n\n\n","source":"_posts/lldb调试方法.md","raw":"title: lldb 调试方法\ndate: 2016/9/21 14:07:12  \ncategories: iOS\ntags:\n\t- Debug\n\n---\n\n偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章[与调试器共舞 - LLDB 的华尔兹](https://objccn.io/issue-19-2/)这篇文章帮助最大。\n\n<!--more-->\nXcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。\n\nLLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：\n1. 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态\n2. 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序\n\n不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。\n\n\n## expression\nexpression的几个命令是最常用的，能提升debug效率的命令。\n\n### print\n打印一个对象:\n![print](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true)\n可以直接缩写`p`达到同样的效果。\n\n结果中有个`$0`，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以`$`开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：\n![print2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true)\n\n### expression\n#### 使用\n如果想要改变一个值，或者执行一个方法。可以使用`expression`或者`e`：\n![expression](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true)\n\nprint其实是特殊的expression，比如`p count =18`其结果和`expression count = 18`结果一样。事实上，`print`是 `expression --` 的缩写。\n\n#### 应用\n由于`expression`可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：\n```objc\n// 改变颜色\n(lldb) expression self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression [CATransaction flush]\n```\n不只是改变颜色，frame，animation等都能改变，非常有用。\n\n如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。\n\n### po\n`print`输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：\n```objc\n(lldb) p @[ @\"foo\", @\"bar\" ]\n\n(NSArray *) $8 = 0x00007fdb9b71b3e0 @\"2 objects\" \n```\n\n这个时候可以使用`po`(print object 的缩写)，相当于调用对象的`description`方法。\n```objc\n(lldb) po $8\n<__NSArrayI 0x7fdb9b71b3e0>(\nfoo,\nbar\n)\n(lldb) po @\"lunar\"\nlunar\n```\n\n## thread\n### bt\n可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:\n![frame](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true)\n\n### thread return\n这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。\n\n它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后**立刻执行返回命令，跳出当前栈帧**。这意味这函数剩余的部分**不会被执行**。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是**在函数的开头执行这个命令**，是个非常好的隔离这个函数，伪造返回值的方式 。\n\n比如下图所示：\n![return](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true)\n正常通过`isOdd`方法，一定是`return NO`的，但是通过`(lldb) thread return YES`，跳过了`isOdd`方法里的方法块，直接`return YES`\n\n正如上面所述，必须要在断点进行到如图所示的地方才可以使用`thread return`，因为:\n1. 此时当前栈帧是`isOdd`\n2. 不会造成引用问题\n\n## breakpoint\n断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.\n\n### 流程控制\n当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:\n![debug](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true)\n意义都很明确，不多说了，列举下对应的命令：\n1. continue按钮 => `continue`,缩写`c`\n2. step over按钮 => `next`，缩写`n`\n3. step in按钮 => `step`,缩写`s`\n4. step out按钮 => `finish`\n\n### 设置断点\n在断点处右击，选择`Edit Breakpoint`弹出如下设置框：\n![breakpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true)\n\n#### 蓝色的勾\n表示enable和disable断点。\n#### Condition\n指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，**不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法**）。\n#### Ignore\n忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。\n#### Action\n它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：\n![menu](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true)\n默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：\n1. **Debugger Command**：默认的选项，可以让断点执行LLDB调试命令。\n2. **Log Message**：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用`@exp@`形式。\n\n#### Options\n一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。\n### 断点类型\n#### 异常断点\n异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true)\n\n#### 符号断点\n他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true)\n\n它比普通断点的自定义设置界面多出了两个内容\n- **Symbol**：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:\n\t```objc\n\t-[MyViewController viewDidAppear:]\n\t+[MyViewController sharedInstance]\n\t```\n- **Module**：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。\n\n需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。\n\n### watchpoint\n有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用`watchpoin`t来监视一个指针的指向。\n\n当指针指向变化时，`watchpoint`会触发:\n![watchpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true)\n#### set\n添加watchpoint的方式如上图所示\n```objc\n(lldb) watchpoint set variable xxx\n```\n这里要说明一下，watchpoint要监听的对象必须是**当前类的对象**：\n![watchpoint2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true)\n由于`self.view`是从`UIViewController`中继承过来的，因此无法监听。\n\n另外，上面的`addr = 0x1556747f0`**不是指`_myView`在栈中的索引**，而是指这个Watchpoint在堆中的地址。\n\nWatchpoint的**原理**应该是在这个地址中写入了原来`_myView`指向的地址，然后对新`_myView`指向的地址和Watchpoint指向的地址是否相同来做出判断的。\n\n#### disable/delete/enable\nwatchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：\n![watchpoint3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true)\n\n## 其他技巧\n### run\n这是我比较喜欢的方法，所以单独列出来。\n\n调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入`run`就能直接让程序重新加载了。\n\n### 通过地址操作\n比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。\n\n本来想要监控`self.view.backgroundColor`的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。\n\n因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。\n\n### 代替NSLog\n看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的`debug log`的，而是`error log`；每次`NSLog`都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。\n\n\n","slug":"lldb调试方法","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dr6002s7hzgqo1x4y0y","content":"<p>偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章<a href=\"https://objccn.io/issue-19-2/\" target=\"_blank\" rel=\"external\">与调试器共舞 - LLDB 的华尔兹</a>这篇文章帮助最大。</p>\n<a id=\"more\"></a>\n<p>Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。</p>\n<p>LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：</p>\n<ol>\n<li>断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态</li>\n<li>直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序</li>\n</ol>\n<p>不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。</p>\n<h2 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"expression\"></a>expression</h2><p>expression的几个命令是最常用的，能提升debug效率的命令。</p>\n<h3 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h3><p>打印一个对象:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true\" alt=\"print\"><br>可以直接缩写<code>p</code>达到同样的效果。</p>\n<p>结果中有个<code>$0</code>，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以<code>$</code>开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true\" alt=\"print2\"></p>\n<h3 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression\"></a>expression</h3><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>如果想要改变一个值，或者执行一个方法。可以使用<code>expression</code>或者<code>e</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true\" alt=\"expression\"></p>\n<p>print其实是特殊的expression，比如<code>p count =18</code>其结果和<code>expression count = 18</code>结果一样。事实上，<code>print</code>是 <code>expression --</code> 的缩写。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>由于<code>expression</code>可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 改变颜色</span></div><div class=\"line\">(lldb) expression <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor]</div><div class=\"line\"><span class=\"comment\">// 刷新界面</span></div><div class=\"line\">(lldb) expression [<span class=\"built_in\">CATransaction</span> flush]</div></pre></td></tr></table></figure></p>\n<p>不只是改变颜色，frame，animation等都能改变，非常有用。</p>\n<p>如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。</p>\n<h3 id=\"po\"><a href=\"#po\" class=\"headerlink\" title=\"po\"></a>po</h3><p><code>print</code>输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p @[ <span class=\"string\">@\"foo\"</span>, <span class=\"string\">@\"bar\"</span> ]</div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">NSArray</span> *) $<span class=\"number\">8</span> = <span class=\"number\">0x00007fdb9b71b3e0</span> <span class=\"string\">@\"2 objects\"</span></div></pre></td></tr></table></figure></p>\n<p>这个时候可以使用<code>po</code>(print object 的缩写)，相当于调用对象的<code>description</code>方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $<span class=\"number\">8</span></div><div class=\"line\">&lt;__NSArrayI <span class=\"number\">0x7fdb9b71b3e0</span>&gt;(</div><div class=\"line\">foo,</div><div class=\"line\">bar</div><div class=\"line\">)</div><div class=\"line\">(lldb) po <span class=\"string\">@\"lunar\"</span></div><div class=\"line\">lunar</div></pre></td></tr></table></figure></p>\n<h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><h3 id=\"bt\"><a href=\"#bt\" class=\"headerlink\" title=\"bt\"></a>bt</h3><p>可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true\" alt=\"frame\"></p>\n<h3 id=\"thread-return\"><a href=\"#thread-return\" class=\"headerlink\" title=\"thread return\"></a>thread return</h3><p>这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。</p>\n<p>它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后<strong>立刻执行返回命令，跳出当前栈帧</strong>。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是<strong>在函数的开头执行这个命令</strong>，是个非常好的隔离这个函数，伪造返回值的方式 。</p>\n<p>比如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true\" alt=\"return\"><br>正常通过<code>isOdd</code>方法，一定是<code>return NO</code>的，但是通过<code>(lldb) thread return YES</code>，跳过了<code>isOdd</code>方法里的方法块，直接<code>return YES</code></p>\n<p>正如上面所述，必须要在断点进行到如图所示的地方才可以使用<code>thread return</code>，因为:</p>\n<ol>\n<li>此时当前栈帧是<code>isOdd</code></li>\n<li>不会造成引用问题</li>\n</ol>\n<h2 id=\"breakpoint\"><a href=\"#breakpoint\" class=\"headerlink\" title=\"breakpoint\"></a>breakpoint</h2><p>断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.</p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p>当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true\" alt=\"debug\"><br>意义都很明确，不多说了，列举下对应的命令：</p>\n<ol>\n<li>continue按钮 =&gt; <code>continue</code>,缩写<code>c</code></li>\n<li>step over按钮 =&gt; <code>next</code>，缩写<code>n</code></li>\n<li>step in按钮 =&gt; <code>step</code>,缩写<code>s</code></li>\n<li>step out按钮 =&gt; <code>finish</code></li>\n</ol>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><p>在断点处右击，选择<code>Edit Breakpoint</code>弹出如下设置框：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true\" alt=\"breakpoint\"></p>\n<h4 id=\"蓝色的勾\"><a href=\"#蓝色的勾\" class=\"headerlink\" title=\"蓝色的勾\"></a>蓝色的勾</h4><p>表示enable和disable断点。</p>\n<h4 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h4><p>指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，<strong>不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法</strong>）。</p>\n<h4 id=\"Ignore\"><a href=\"#Ignore\" class=\"headerlink\" title=\"Ignore\"></a>Ignore</h4><p>忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。</p>\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true\" alt=\"menu\"><br>默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：</p>\n<ol>\n<li><strong>Debugger Command</strong>：默认的选项，可以让断点执行LLDB调试命令。</li>\n<li><strong>Log Message</strong>：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用<code>@exp@</code>形式。</li>\n</ol>\n<h4 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h4><p>一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。</p>\n<h3 id=\"断点类型\"><a href=\"#断点类型\" class=\"headerlink\" title=\"断点类型\"></a>断点类型</h3><h4 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h4><p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true\" alt=\"exception\"></p>\n<h4 id=\"符号断点\"><a href=\"#符号断点\" class=\"headerlink\" title=\"符号断点\"></a>符号断点</h4><p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true\" alt=\"exception\"></p>\n<p>它比普通断点的自定义设置界面多出了两个内容</p>\n<ul>\n<li><p><strong>Symbol</strong>：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[MyViewController viewDidAppear:]</div><div class=\"line\">+[MyViewController sharedInstance]</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Module</strong>：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>\n</li>\n</ul>\n<p>需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。</p>\n<h3 id=\"watchpoint\"><a href=\"#watchpoint\" class=\"headerlink\" title=\"watchpoint\"></a>watchpoint</h3><p>有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用<code>watchpoin</code>t来监视一个指针的指向。</p>\n<p>当指针指向变化时，<code>watchpoint</code>会触发:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true\" alt=\"watchpoint\"></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>添加watchpoint的方式如上图所示<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) watchpoint set variable xxx</div></pre></td></tr></table></figure></p>\n<p>这里要说明一下，watchpoint要监听的对象必须是<strong>当前类的对象</strong>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true\" alt=\"watchpoint2\"><br>由于<code>self.view</code>是从<code>UIViewController</code>中继承过来的，因此无法监听。</p>\n<p>另外，上面的<code>addr = 0x1556747f0</code><strong>不是指<code>_myView</code>在栈中的索引</strong>，而是指这个Watchpoint在堆中的地址。</p>\n<p>Watchpoint的<strong>原理</strong>应该是在这个地址中写入了原来<code>_myView</code>指向的地址，然后对新<code>_myView</code>指向的地址和Watchpoint指向的地址是否相同来做出判断的。</p>\n<h4 id=\"disable-delete-enable\"><a href=\"#disable-delete-enable\" class=\"headerlink\" title=\"disable/delete/enable\"></a>disable/delete/enable</h4><p>watchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true\" alt=\"watchpoint3\"></p>\n<h2 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h2><h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>这是我比较喜欢的方法，所以单独列出来。</p>\n<p>调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入<code>run</code>就能直接让程序重新加载了。</p>\n<h3 id=\"通过地址操作\"><a href=\"#通过地址操作\" class=\"headerlink\" title=\"通过地址操作\"></a>通过地址操作</h3><p>比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。</p>\n<p>本来想要监控<code>self.view.backgroundColor</code>的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。</p>\n<p>因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。</p>\n<h3 id=\"代替NSLog\"><a href=\"#代替NSLog\" class=\"headerlink\" title=\"代替NSLog\"></a>代替NSLog</h3><p>看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的<code>debug log</code>的，而是<code>error log</code>；每次<code>NSLog</code>都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。</p>\n","excerpt":"<p>偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章<a href=\"https://objccn.io/issue-19-2/\">与调试器共舞 - LLDB 的华尔兹</a>这篇文章帮助最大。</p>","more":"<p>Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。</p>\n<p>LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：</p>\n<ol>\n<li>断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态</li>\n<li>直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序</li>\n</ol>\n<p>不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。</p>\n<h2 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"expression\"></a>expression</h2><p>expression的几个命令是最常用的，能提升debug效率的命令。</p>\n<h3 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h3><p>打印一个对象:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true\" alt=\"print\"><br>可以直接缩写<code>p</code>达到同样的效果。</p>\n<p>结果中有个<code>$0</code>，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以<code>$</code>开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true\" alt=\"print2\"></p>\n<h3 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression\"></a>expression</h3><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>如果想要改变一个值，或者执行一个方法。可以使用<code>expression</code>或者<code>e</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true\" alt=\"expression\"></p>\n<p>print其实是特殊的expression，比如<code>p count =18</code>其结果和<code>expression count = 18</code>结果一样。事实上，<code>print</code>是 <code>expression --</code> 的缩写。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>由于<code>expression</code>可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 改变颜色</span></div><div class=\"line\">(lldb) expression <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor]</div><div class=\"line\"><span class=\"comment\">// 刷新界面</span></div><div class=\"line\">(lldb) expression [<span class=\"built_in\">CATransaction</span> flush]</div></pre></td></tr></table></figure></p>\n<p>不只是改变颜色，frame，animation等都能改变，非常有用。</p>\n<p>如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。</p>\n<h3 id=\"po\"><a href=\"#po\" class=\"headerlink\" title=\"po\"></a>po</h3><p><code>print</code>输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p @[ <span class=\"string\">@\"foo\"</span>, <span class=\"string\">@\"bar\"</span> ]</div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">NSArray</span> *) $<span class=\"number\">8</span> = <span class=\"number\">0x00007fdb9b71b3e0</span> <span class=\"string\">@\"2 objects\"</span></div></pre></td></tr></table></figure></p>\n<p>这个时候可以使用<code>po</code>(print object 的缩写)，相当于调用对象的<code>description</code>方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $<span class=\"number\">8</span></div><div class=\"line\">&lt;__NSArrayI <span class=\"number\">0x7fdb9b71b3e0</span>&gt;(</div><div class=\"line\">foo,</div><div class=\"line\">bar</div><div class=\"line\">)</div><div class=\"line\">(lldb) po <span class=\"string\">@\"lunar\"</span></div><div class=\"line\">lunar</div></pre></td></tr></table></figure></p>\n<h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><h3 id=\"bt\"><a href=\"#bt\" class=\"headerlink\" title=\"bt\"></a>bt</h3><p>可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true\" alt=\"frame\"></p>\n<h3 id=\"thread-return\"><a href=\"#thread-return\" class=\"headerlink\" title=\"thread return\"></a>thread return</h3><p>这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。</p>\n<p>它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后<strong>立刻执行返回命令，跳出当前栈帧</strong>。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是<strong>在函数的开头执行这个命令</strong>，是个非常好的隔离这个函数，伪造返回值的方式 。</p>\n<p>比如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true\" alt=\"return\"><br>正常通过<code>isOdd</code>方法，一定是<code>return NO</code>的，但是通过<code>(lldb) thread return YES</code>，跳过了<code>isOdd</code>方法里的方法块，直接<code>return YES</code></p>\n<p>正如上面所述，必须要在断点进行到如图所示的地方才可以使用<code>thread return</code>，因为:</p>\n<ol>\n<li>此时当前栈帧是<code>isOdd</code></li>\n<li>不会造成引用问题</li>\n</ol>\n<h2 id=\"breakpoint\"><a href=\"#breakpoint\" class=\"headerlink\" title=\"breakpoint\"></a>breakpoint</h2><p>断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.</p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p>当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true\" alt=\"debug\"><br>意义都很明确，不多说了，列举下对应的命令：</p>\n<ol>\n<li>continue按钮 =&gt; <code>continue</code>,缩写<code>c</code></li>\n<li>step over按钮 =&gt; <code>next</code>，缩写<code>n</code></li>\n<li>step in按钮 =&gt; <code>step</code>,缩写<code>s</code></li>\n<li>step out按钮 =&gt; <code>finish</code></li>\n</ol>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><p>在断点处右击，选择<code>Edit Breakpoint</code>弹出如下设置框：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true\" alt=\"breakpoint\"></p>\n<h4 id=\"蓝色的勾\"><a href=\"#蓝色的勾\" class=\"headerlink\" title=\"蓝色的勾\"></a>蓝色的勾</h4><p>表示enable和disable断点。</p>\n<h4 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h4><p>指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，<strong>不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法</strong>）。</p>\n<h4 id=\"Ignore\"><a href=\"#Ignore\" class=\"headerlink\" title=\"Ignore\"></a>Ignore</h4><p>忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。</p>\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true\" alt=\"menu\"><br>默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：</p>\n<ol>\n<li><strong>Debugger Command</strong>：默认的选项，可以让断点执行LLDB调试命令。</li>\n<li><strong>Log Message</strong>：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用<code>@exp@</code>形式。</li>\n</ol>\n<h4 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h4><p>一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。</p>\n<h3 id=\"断点类型\"><a href=\"#断点类型\" class=\"headerlink\" title=\"断点类型\"></a>断点类型</h3><h4 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h4><p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true\" alt=\"exception\"></p>\n<h4 id=\"符号断点\"><a href=\"#符号断点\" class=\"headerlink\" title=\"符号断点\"></a>符号断点</h4><p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true\" alt=\"exception\"></p>\n<p>它比普通断点的自定义设置界面多出了两个内容</p>\n<ul>\n<li><p><strong>Symbol</strong>：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[MyViewController viewDidAppear:]</div><div class=\"line\">+[MyViewController sharedInstance]</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Module</strong>：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>\n</li>\n</ul>\n<p>需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。</p>\n<h3 id=\"watchpoint\"><a href=\"#watchpoint\" class=\"headerlink\" title=\"watchpoint\"></a>watchpoint</h3><p>有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用<code>watchpoin</code>t来监视一个指针的指向。</p>\n<p>当指针指向变化时，<code>watchpoint</code>会触发:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true\" alt=\"watchpoint\"></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>添加watchpoint的方式如上图所示<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) watchpoint set variable xxx</div></pre></td></tr></table></figure></p>\n<p>这里要说明一下，watchpoint要监听的对象必须是<strong>当前类的对象</strong>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true\" alt=\"watchpoint2\"><br>由于<code>self.view</code>是从<code>UIViewController</code>中继承过来的，因此无法监听。</p>\n<p>另外，上面的<code>addr = 0x1556747f0</code><strong>不是指<code>_myView</code>在栈中的索引</strong>，而是指这个Watchpoint在堆中的地址。</p>\n<p>Watchpoint的<strong>原理</strong>应该是在这个地址中写入了原来<code>_myView</code>指向的地址，然后对新<code>_myView</code>指向的地址和Watchpoint指向的地址是否相同来做出判断的。</p>\n<h4 id=\"disable-delete-enable\"><a href=\"#disable-delete-enable\" class=\"headerlink\" title=\"disable/delete/enable\"></a>disable/delete/enable</h4><p>watchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true\" alt=\"watchpoint3\"></p>\n<h2 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h2><h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>这是我比较喜欢的方法，所以单独列出来。</p>\n<p>调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入<code>run</code>就能直接让程序重新加载了。</p>\n<h3 id=\"通过地址操作\"><a href=\"#通过地址操作\" class=\"headerlink\" title=\"通过地址操作\"></a>通过地址操作</h3><p>比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。</p>\n<p>本来想要监控<code>self.view.backgroundColor</code>的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。</p>\n<p>因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。</p>\n<h3 id=\"代替NSLog\"><a href=\"#代替NSLog\" class=\"headerlink\" title=\"代替NSLog\"></a>代替NSLog</h3><p>看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的<code>debug log</code>的，而是<code>error log</code>；每次<code>NSLog</code>都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。</p>"},{"title":"objective-c 学习笔记","date":"2016-07-31T02:07:12.000Z","_content":"\n开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。\n\n<!--more-->\n\n### 函数\n函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。\n\n### 全局变量\n在函数外声明的变量，只要类被import就能使用。  \nJava中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。  \n为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。  \n**那么这和@property有什么区别？**静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。\n\n### 指针\n&表示取地址，*表示取值。  \n空指针用nil而不是null。\n\n### 结构\n使用结构保存多个相关数据。\n```objc\nstruct Person{\n\tfloat height；\n\tint age；\n}；\n```\n使用：`struct Person mikey；`  \n使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。\n```objc\ntypedef struct {\n\tfloat height；\n\tint age；\n} Person；\n```\n使用：`Person mikey；`\n\n### 获取结构中的属性：\n当结构的使用者是一个指针时，使用->表示先获取指针p指向的数据结构，然后返回该结构的成员变量。  \n当结构的使用者是一个实例时，使用.表示访问属性。\n\n### id %@\nid表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。\nInstanceType表示方法的返回类型。  \n%@表示占位符，代表指针，会向相应指针变量对象发送description消息。\n\n### NSString\n@“…”表示创建一个NSString对象。需要知道字符串完整内容。  \n也可使用stringWithFormat方法动态创建：\n```objc\nNSString *dateString = [NSString stringWithFormat:@“The date is %@”, now]\n```\n\n### NSArray\n创建：\n```objc\nNSArray *dateList = @[now, tomorrow ,yesterday];\n```\nNSArray是无法改变的，被创建后无法添加删除以及改变顺序。  \n快速遍历数组： \n```objc\nfor(NSDate *d in daeList){}\n```\n\n\n\n### NSMutableArray\n可变数组，可添加删除和修改顺序。  \ninsertObject：atIndex在指定位置插入  \nremoveObject：atIndex删除数组中对象  \n快速遍历时不能添加删除数组内数据。\n\n### 自定义一个类\n头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始\n取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。\n\n### self\nself是指针，指向运行当前方法的对象。\n\n### 属性\n属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。  \n使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。\n\n### 继承\nNSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。\n\n### @class\n一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.  \n如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB\n\n### 类拓展\n类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。\n```objc\n\t#import “BNREmployee.h”\n\t@interface BNREmployee()\t\n\t@property (nonatomic) unsigned int officeAlarmCode;\n\t@end\n```\n注意要有括号，写在implement前面。  \n头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。\n\n### 弱引用\n通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。\n\n### Collection类\nNSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。  \nNSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。  \nNSMutable是NS的子类。  \ncollection不能保存nil。如果要保存nil则要保存NSNull类的实例。\n```objc\n[hotel addObject:[NSNull null]];\n```\n\n### 常量\n可以通过两种途径定义常量，#define和全局变量。  \n1. #define A B 告诉编译器看到A用B替换\n2. extern NSString const *NSLocaleCurrencyCode；  \nconst表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义\n\n### #include和#import\nimport会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。\n\n\n\n### 协议\n协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。  \nUITableView数据源协议是UITableViewDataSource，方法声明如下：\n```objc\n@protocal UITableViewDataSource<NSObject>\n@required\n- (NSInteger)tableView:(UITableView *)tv\n\tnumberOfRowsInSection:(NSInteger) section;\n@optional\n……. \n```\n\n### 范畴\n通过范畴（category）可以为任何已有的类添加方法。  \n创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。  \n打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。\n声明示例：NSString+MD5.h\n```objc\n@interface NSString (MD5)\n+ (NSString *)md5:(NSString *)originalStr;\n@end\n```\n\n\n","source":"_posts/objectice-c.md","raw":"title: objective-c 学习笔记\ndate: 2016/7/31 10:07:12  \ncategories: iOS\ntags:\n\t- Objective-C\n\t- 学习笔记\n\n---\n\n开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。\n\n<!--more-->\n\n### 函数\n函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。\n\n### 全局变量\n在函数外声明的变量，只要类被import就能使用。  \nJava中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。  \n为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。  \n**那么这和@property有什么区别？**静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。\n\n### 指针\n&表示取地址，*表示取值。  \n空指针用nil而不是null。\n\n### 结构\n使用结构保存多个相关数据。\n```objc\nstruct Person{\n\tfloat height；\n\tint age；\n}；\n```\n使用：`struct Person mikey；`  \n使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。\n```objc\ntypedef struct {\n\tfloat height；\n\tint age；\n} Person；\n```\n使用：`Person mikey；`\n\n### 获取结构中的属性：\n当结构的使用者是一个指针时，使用->表示先获取指针p指向的数据结构，然后返回该结构的成员变量。  \n当结构的使用者是一个实例时，使用.表示访问属性。\n\n### id %@\nid表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。\nInstanceType表示方法的返回类型。  \n%@表示占位符，代表指针，会向相应指针变量对象发送description消息。\n\n### NSString\n@“…”表示创建一个NSString对象。需要知道字符串完整内容。  \n也可使用stringWithFormat方法动态创建：\n```objc\nNSString *dateString = [NSString stringWithFormat:@“The date is %@”, now]\n```\n\n### NSArray\n创建：\n```objc\nNSArray *dateList = @[now, tomorrow ,yesterday];\n```\nNSArray是无法改变的，被创建后无法添加删除以及改变顺序。  \n快速遍历数组： \n```objc\nfor(NSDate *d in daeList){}\n```\n\n\n\n### NSMutableArray\n可变数组，可添加删除和修改顺序。  \ninsertObject：atIndex在指定位置插入  \nremoveObject：atIndex删除数组中对象  \n快速遍历时不能添加删除数组内数据。\n\n### 自定义一个类\n头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始\n取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。\n\n### self\nself是指针，指向运行当前方法的对象。\n\n### 属性\n属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。  \n使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。\n\n### 继承\nNSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。\n\n### @class\n一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.  \n如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB\n\n### 类拓展\n类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。\n```objc\n\t#import “BNREmployee.h”\n\t@interface BNREmployee()\t\n\t@property (nonatomic) unsigned int officeAlarmCode;\n\t@end\n```\n注意要有括号，写在implement前面。  \n头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。\n\n### 弱引用\n通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。\n\n### Collection类\nNSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。  \nNSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。  \nNSMutable是NS的子类。  \ncollection不能保存nil。如果要保存nil则要保存NSNull类的实例。\n```objc\n[hotel addObject:[NSNull null]];\n```\n\n### 常量\n可以通过两种途径定义常量，#define和全局变量。  \n1. #define A B 告诉编译器看到A用B替换\n2. extern NSString const *NSLocaleCurrencyCode；  \nconst表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义\n\n### #include和#import\nimport会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。\n\n\n\n### 协议\n协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。  \nUITableView数据源协议是UITableViewDataSource，方法声明如下：\n```objc\n@protocal UITableViewDataSource<NSObject>\n@required\n- (NSInteger)tableView:(UITableView *)tv\n\tnumberOfRowsInSection:(NSInteger) section;\n@optional\n……. \n```\n\n### 范畴\n通过范畴（category）可以为任何已有的类添加方法。  \n创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。  \n打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。\n声明示例：NSString+MD5.h\n```objc\n@interface NSString (MD5)\n+ (NSString *)md5:(NSString *)originalStr;\n@end\n```\n\n\n","slug":"objectice-c","published":1,"updated":"2016-12-31T11:34:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dr8002v7hzg44ikbr0p","content":"<p>开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。</p>\n<a id=\"more\"></a>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数外声明的变量，只要类被import就能使用。<br>Java中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。<br>为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。<br><strong>那么这和@property有什么区别？</strong>静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;表示取地址，*表示取值。<br>空指针用nil而不是null。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>使用结构保存多个相关数据。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125;；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>struct Person mikey；</code><br>使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125; Person；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>Person mikey；</code></p>\n<h3 id=\"获取结构中的属性：\"><a href=\"#获取结构中的属性：\" class=\"headerlink\" title=\"获取结构中的属性：\"></a>获取结构中的属性：</h3><p>当结构的使用者是一个指针时，使用-&gt;表示先获取指针p指向的数据结构，然后返回该结构的成员变量。<br>当结构的使用者是一个实例时，使用.表示访问属性。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id %@\"></a>id %@</h3><p>id表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。<br>InstanceType表示方法的返回类型。<br>%@表示占位符，代表指针，会向相应指针变量对象发送description消息。</p>\n<h3 id=\"NSString\"><a href=\"#NSString\" class=\"headerlink\" title=\"NSString\"></a>NSString</h3><p>@“…”表示创建一个NSString对象。需要知道字符串完整内容。<br>也可使用stringWithFormat方法动态创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *dateString = [<span class=\"built_in\">NSString</span> stringWithFormat:@“The date is %@”, now]</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSArray\"><a href=\"#NSArray\" class=\"headerlink\" title=\"NSArray\"></a>NSArray</h3><p>创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *dateList = @[now, tomorrow ,yesterday];</div></pre></td></tr></table></figure></p>\n<p>NSArray是无法改变的，被创建后无法添加删除以及改变顺序。<br>快速遍历数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">NSDate</span> *d <span class=\"keyword\">in</span> daeList)&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSMutableArray\"><a href=\"#NSMutableArray\" class=\"headerlink\" title=\"NSMutableArray\"></a>NSMutableArray</h3><p>可变数组，可添加删除和修改顺序。<br>insertObject：atIndex在指定位置插入<br>removeObject：atIndex删除数组中对象<br>快速遍历时不能添加删除数组内数据。</p>\n<h3 id=\"自定义一个类\"><a href=\"#自定义一个类\" class=\"headerlink\" title=\"自定义一个类\"></a>自定义一个类</h3><p>头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始<br>取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。</p>\n<h3 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h3><p>self是指针，指向运行当前方法的对象。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。<br>使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>NSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"@class\"></a>@class</h3><p>一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.<br>如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB</p>\n<h3 id=\"类拓展\"><a href=\"#类拓展\" class=\"headerlink\" title=\"类拓展\"></a>类拓展</h3><p>类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import “BNREmployee.h”</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNREmployee</span>()\t</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> officeAlarmCode;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意要有括号，写在implement前面。<br>头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。</p>\n<h3 id=\"Collection类\"><a href=\"#Collection类\" class=\"headerlink\" title=\"Collection类\"></a>Collection类</h3><p>NSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。<br>NSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。<br>NSMutable是NS的子类。<br>collection不能保存nil。如果要保存nil则要保存NSNull类的实例。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[hotel addObject:[<span class=\"built_in\">NSNull</span> null]];</div></pre></td></tr></table></figure></p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>可以通过两种途径定义常量，#define和全局变量。  </p>\n<ol>\n<li>#define A B 告诉编译器看到A用B替换</li>\n<li>extern NSString const *NSLocaleCurrencyCode；<br>const表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>\n</ol>\n<h3 id=\"include和-import\"><a href=\"#include和-import\" class=\"headerlink\" title=\"#include和#import\"></a>#include和#import</h3><p>import会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。<br>UITableView数据源协议是UITableViewDataSource，方法声明如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocal <span class=\"built_in\">UITableViewDataSource</span>&lt;<span class=\"built_in\">NSObject</span>&gt;</div><div class=\"line\"><span class=\"keyword\">@required</span></div><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tv</div><div class=\"line\">\tnumberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>) section;</div><div class=\"line\"><span class=\"keyword\">@optional</span></div><div class=\"line\">…….</div></pre></td></tr></table></figure></p>\n<h3 id=\"范畴\"><a href=\"#范畴\" class=\"headerlink\" title=\"范畴\"></a>范畴</h3><p>通过范畴（category）可以为任何已有的类添加方法。<br>创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。<br>打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。<br>声明示例：NSString+MD5.h<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">MD5</span>)</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)md5:(<span class=\"built_in\">NSString</span> *)originalStr;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p>开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。</p>","more":"<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数外声明的变量，只要类被import就能使用。<br>Java中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。<br>为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。<br><strong>那么这和@property有什么区别？</strong>静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;表示取地址，*表示取值。<br>空指针用nil而不是null。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>使用结构保存多个相关数据。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125;；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>struct Person mikey；</code><br>使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125; Person；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>Person mikey；</code></p>\n<h3 id=\"获取结构中的属性：\"><a href=\"#获取结构中的属性：\" class=\"headerlink\" title=\"获取结构中的属性：\"></a>获取结构中的属性：</h3><p>当结构的使用者是一个指针时，使用-&gt;表示先获取指针p指向的数据结构，然后返回该结构的成员变量。<br>当结构的使用者是一个实例时，使用.表示访问属性。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id %@\"></a>id %@</h3><p>id表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。<br>InstanceType表示方法的返回类型。<br>%@表示占位符，代表指针，会向相应指针变量对象发送description消息。</p>\n<h3 id=\"NSString\"><a href=\"#NSString\" class=\"headerlink\" title=\"NSString\"></a>NSString</h3><p>@“…”表示创建一个NSString对象。需要知道字符串完整内容。<br>也可使用stringWithFormat方法动态创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *dateString = [<span class=\"built_in\">NSString</span> stringWithFormat:@“The date is %@”, now]</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSArray\"><a href=\"#NSArray\" class=\"headerlink\" title=\"NSArray\"></a>NSArray</h3><p>创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *dateList = @[now, tomorrow ,yesterday];</div></pre></td></tr></table></figure></p>\n<p>NSArray是无法改变的，被创建后无法添加删除以及改变顺序。<br>快速遍历数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">NSDate</span> *d <span class=\"keyword\">in</span> daeList)&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSMutableArray\"><a href=\"#NSMutableArray\" class=\"headerlink\" title=\"NSMutableArray\"></a>NSMutableArray</h3><p>可变数组，可添加删除和修改顺序。<br>insertObject：atIndex在指定位置插入<br>removeObject：atIndex删除数组中对象<br>快速遍历时不能添加删除数组内数据。</p>\n<h3 id=\"自定义一个类\"><a href=\"#自定义一个类\" class=\"headerlink\" title=\"自定义一个类\"></a>自定义一个类</h3><p>头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始<br>取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。</p>\n<h3 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h3><p>self是指针，指向运行当前方法的对象。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。<br>使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>NSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"@class\"></a>@class</h3><p>一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.<br>如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB</p>\n<h3 id=\"类拓展\"><a href=\"#类拓展\" class=\"headerlink\" title=\"类拓展\"></a>类拓展</h3><p>类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import “BNREmployee.h”</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNREmployee</span>()\t</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> officeAlarmCode;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意要有括号，写在implement前面。<br>头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。</p>\n<h3 id=\"Collection类\"><a href=\"#Collection类\" class=\"headerlink\" title=\"Collection类\"></a>Collection类</h3><p>NSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。<br>NSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。<br>NSMutable是NS的子类。<br>collection不能保存nil。如果要保存nil则要保存NSNull类的实例。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[hotel addObject:[<span class=\"built_in\">NSNull</span> null]];</div></pre></td></tr></table></figure></p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>可以通过两种途径定义常量，#define和全局变量。  </p>\n<ol>\n<li>#define A B 告诉编译器看到A用B替换</li>\n<li>extern NSString const *NSLocaleCurrencyCode；<br>const表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>\n</ol>\n<h3 id=\"include和-import\"><a href=\"#include和-import\" class=\"headerlink\" title=\"#include和#import\"></a>#include和#import</h3><p>import会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。<br>UITableView数据源协议是UITableViewDataSource，方法声明如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocal <span class=\"built_in\">UITableViewDataSource</span>&lt;<span class=\"built_in\">NSObject</span>&gt;</div><div class=\"line\"><span class=\"keyword\">@required</span></div><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tv</div><div class=\"line\">\tnumberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>) section;</div><div class=\"line\"><span class=\"keyword\">@optional</span></div><div class=\"line\">…….</div></pre></td></tr></table></figure></p>\n<h3 id=\"范畴\"><a href=\"#范畴\" class=\"headerlink\" title=\"范畴\"></a>范畴</h3><p>通过范畴（category）可以为任何已有的类添加方法。<br>创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。<br>打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。<br>声明示例：NSString+MD5.h<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">MD5</span>)</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)md5:(<span class=\"built_in\">NSString</span> *)originalStr;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>"},{"title":"移位与枚举","date":"2016-09-07T02:07:12.000Z","_content":"\noc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（<<）来定义枚举的值，其原因是什么呢？\n\n<!--more-->\n## enum的基本用法使用\n定义一组常量。\n```objc\ntypedef enum{\n\tBlenderSpeedStir=1，\n\tBlenderSpeedChop=1<<1，\n} BlenderSpeed；\n```\n\n还可以写成这样：\n```objc\ntypedef NS_ENUM(NSInteger, BlenderSpeed) {\n//以下是枚举成员\n    Test1A = 1,\n    Test1B = 1<<1,\n    Test1C = 1<<2,\n    Test1D = 1<<3\n};\n```\n使用： \n```\nBlenderSpeed speed = Test1A；\n```\n使用`BlenderSpeed`代替`NSInteger`。\n\n\n## 移位定义enum\n### 使用移位定义enum的好处\nenum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：**用移位来定义枚举能把1的位置错开，可以使用`按位或`将几个枚举值表示成一个数，而不会互相影响**。如果用数字就要使用一个数组。\n\n比如：\n```objc\n[UIView animateWithDuration:1 delay:0 options:UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat animations:^{\n\tnil\n} completion:^(BOOL finished) {\n\tnil;\n}];\n```\n\n其中`options`只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入`UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat`表示既`FlipFromRight`又`repeat`。\n\n### 取出enum值\n将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下`按位与&`操作符的特性：\n\n>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。\n所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。\n\n因此，我们可以这样取出枚举值：\n```objc\ntypedef enum{\n    a = 1 << 0,\n    b = 1 << 1,\n    c = 1 << 2,\n    d = 1 << 3\n}testEnum;\n\ntestEnum e = a | b;\n\nif (e & a) {\n    printf(\"满足条件a\");\n    //满足a要做的事\n}\nif (e & b) {\n    printf(\"满足条件b\");\n    //满足b要做的事\n}\nif (e & c) {\n    printf(\"满足条件c\");\n    //满足c要做的事\n}\n```\n将数值与各个枚举值按位与，非零即包含该枚举值。\n\n也可以通过一个for循环，再通过switch-case处理：\n```objc\ntypedef NS_ENUM(NSInteger, AnimationType) {\n    //以下是枚举成员\n    BaseAnimation = 1,\n    KeyFrameAnimation_Value = 1<<1,\n    KeyFrameAnimation_Path = 1<<2,\n    KeyFrameAnimation_shake = 1<<3,\n    Transition = 1<<4,\n    AnimationGroup = 1<<5,\n    ViewAnimation = 1<<6\n};\n\n- (void)initAnimationWithType:(NSInteger)type{\n    for (NSInteger animationType = 1; animationType<(ViewAnimation<<1); animationType = animationType<<1) {\n        if (type & animationType) {\n            [self startAnimationInitialWithType:animationType];\n        }\n    }\n}\n\n- (void)startAnimationInitialWithType:(NSInteger)type{\n    \n    switch (type) {\n        case BaseAnimation:{\n            CALayer *myLayer=[CALayer layer];\n            myLayer.bounds=CGRectMake(0, 0, 50, 80);\n            myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n            myLayer.position=CGPointMake(50, 50);\n            myLayer.anchorPoint=CGPointMake(0, 0);\n            myLayer.cornerRadius=20;\n            //添加layer\n            [self.view.layer addSublayer:myLayer];\n            self.myLayer=myLayer;\n        }\n            break;\n        case Transition:\n            _index = 1;\n            break;\n        default:\n            break;\n    }\n}\n```\n\n**需要注意的是**：`case`中如果声明了变量，必须要用`{}`包住，这是编译器强制的，不然会报错，应该是为了避免[switch case语句里面不能定义对象，有语法错误，除非加一个花括号](http://blog.csdn.net/fanjunxi1990/article/details/9162945)这个问题。\n\n### 引申\n上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。\n比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：\n```objc\n\ntypedef enum{\n    a = 0 << 0,\n    b = 1 << 0,\n    c = 2 << 0,\n    d = 3 << 0,\n\n    e = 0 << 4,\n    f = 1 << 4,\n    g = 2 << 4,\n    h = 3 << 4\n}testEnum;\n```\n\na b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和`00001111`按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与`11110000`按位与得到另外一组。\n\n>Demo详见CALayer_Transform\n","source":"_posts/oc中的枚举.md","raw":"title: 移位与枚举\ndate: 2016/9/7 10:07:12  \ncategories: iOS\ntags:\n\t- Objective-C\n\n---\n\noc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（<<）来定义枚举的值，其原因是什么呢？\n\n<!--more-->\n## enum的基本用法使用\n定义一组常量。\n```objc\ntypedef enum{\n\tBlenderSpeedStir=1，\n\tBlenderSpeedChop=1<<1，\n} BlenderSpeed；\n```\n\n还可以写成这样：\n```objc\ntypedef NS_ENUM(NSInteger, BlenderSpeed) {\n//以下是枚举成员\n    Test1A = 1,\n    Test1B = 1<<1,\n    Test1C = 1<<2,\n    Test1D = 1<<3\n};\n```\n使用： \n```\nBlenderSpeed speed = Test1A；\n```\n使用`BlenderSpeed`代替`NSInteger`。\n\n\n## 移位定义enum\n### 使用移位定义enum的好处\nenum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：**用移位来定义枚举能把1的位置错开，可以使用`按位或`将几个枚举值表示成一个数，而不会互相影响**。如果用数字就要使用一个数组。\n\n比如：\n```objc\n[UIView animateWithDuration:1 delay:0 options:UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat animations:^{\n\tnil\n} completion:^(BOOL finished) {\n\tnil;\n}];\n```\n\n其中`options`只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入`UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat`表示既`FlipFromRight`又`repeat`。\n\n### 取出enum值\n将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下`按位与&`操作符的特性：\n\n>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。\n所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。\n\n因此，我们可以这样取出枚举值：\n```objc\ntypedef enum{\n    a = 1 << 0,\n    b = 1 << 1,\n    c = 1 << 2,\n    d = 1 << 3\n}testEnum;\n\ntestEnum e = a | b;\n\nif (e & a) {\n    printf(\"满足条件a\");\n    //满足a要做的事\n}\nif (e & b) {\n    printf(\"满足条件b\");\n    //满足b要做的事\n}\nif (e & c) {\n    printf(\"满足条件c\");\n    //满足c要做的事\n}\n```\n将数值与各个枚举值按位与，非零即包含该枚举值。\n\n也可以通过一个for循环，再通过switch-case处理：\n```objc\ntypedef NS_ENUM(NSInteger, AnimationType) {\n    //以下是枚举成员\n    BaseAnimation = 1,\n    KeyFrameAnimation_Value = 1<<1,\n    KeyFrameAnimation_Path = 1<<2,\n    KeyFrameAnimation_shake = 1<<3,\n    Transition = 1<<4,\n    AnimationGroup = 1<<5,\n    ViewAnimation = 1<<6\n};\n\n- (void)initAnimationWithType:(NSInteger)type{\n    for (NSInteger animationType = 1; animationType<(ViewAnimation<<1); animationType = animationType<<1) {\n        if (type & animationType) {\n            [self startAnimationInitialWithType:animationType];\n        }\n    }\n}\n\n- (void)startAnimationInitialWithType:(NSInteger)type{\n    \n    switch (type) {\n        case BaseAnimation:{\n            CALayer *myLayer=[CALayer layer];\n            myLayer.bounds=CGRectMake(0, 0, 50, 80);\n            myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n            myLayer.position=CGPointMake(50, 50);\n            myLayer.anchorPoint=CGPointMake(0, 0);\n            myLayer.cornerRadius=20;\n            //添加layer\n            [self.view.layer addSublayer:myLayer];\n            self.myLayer=myLayer;\n        }\n            break;\n        case Transition:\n            _index = 1;\n            break;\n        default:\n            break;\n    }\n}\n```\n\n**需要注意的是**：`case`中如果声明了变量，必须要用`{}`包住，这是编译器强制的，不然会报错，应该是为了避免[switch case语句里面不能定义对象，有语法错误，除非加一个花括号](http://blog.csdn.net/fanjunxi1990/article/details/9162945)这个问题。\n\n### 引申\n上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。\n比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：\n```objc\n\ntypedef enum{\n    a = 0 << 0,\n    b = 1 << 0,\n    c = 2 << 0,\n    d = 3 << 0,\n\n    e = 0 << 4,\n    f = 1 << 4,\n    g = 2 << 4,\n    h = 3 << 4\n}testEnum;\n```\n\na b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和`00001111`按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与`11110000`按位与得到另外一组。\n\n>Demo详见CALayer_Transform\n","slug":"oc中的枚举","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41drb002z7hzguqxgmxhm","content":"<p>oc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（&lt;&lt;）来定义枚举的值，其原因是什么呢？</p>\n<a id=\"more\"></a>\n<h2 id=\"enum的基本用法使用\"><a href=\"#enum的基本用法使用\" class=\"headerlink\" title=\"enum的基本用法使用\"></a>enum的基本用法使用</h2><p>定义一组常量。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">\tBlenderSpeedStir=<span class=\"number\">1</span>，</div><div class=\"line\">\tBlenderSpeedChop=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>，</div><div class=\"line\">&#125; BlenderSpeed；</div></pre></td></tr></table></figure></p>\n<p>还可以写成这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, BlenderSpeed) &#123;</div><div class=\"line\"><span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    Test1A = <span class=\"number\">1</span>,</div><div class=\"line\">    Test1B = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    Test1C = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    Test1D = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">BlenderSpeed speed = Test1A；</div></pre></td></tr></table></figure></p>\n<p>使用<code>BlenderSpeed</code>代替<code>NSInteger</code>。</p>\n<h2 id=\"移位定义enum\"><a href=\"#移位定义enum\" class=\"headerlink\" title=\"移位定义enum\"></a>移位定义enum</h2><h3 id=\"使用移位定义enum的好处\"><a href=\"#使用移位定义enum的好处\" class=\"headerlink\" title=\"使用移位定义enum的好处\"></a>使用移位定义enum的好处</h3><p>enum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：<strong>用移位来定义枚举能把1的位置错开，可以使用<code>按位或</code>将几个枚举值表示成一个数，而不会互相影响</strong>。如果用数字就要使用一个数组。</p>\n<p>比如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1</span> delay:<span class=\"number\">0</span> options:<span class=\"built_in\">UIViewAnimationOptionTransitionFlipFromRight</span> |<span class=\"built_in\">UIViewAnimationOptionRepeat</span> animations:^&#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span></div><div class=\"line\">&#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>其中<code>options</code>只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入<code>UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat</code>表示既<code>FlipFromRight</code>又<code>repeat</code>。</p>\n<h3 id=\"取出enum值\"><a href=\"#取出enum值\" class=\"headerlink\" title=\"取出enum值\"></a>取出enum值</h3><p>将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下<code>按位与&amp;</code>操作符的特性：</p>\n<blockquote>\n<p>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。<br>所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。</p>\n</blockquote>\n<p>因此，我们可以这样取出枚举值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    c = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    d = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;testEnum;</div><div class=\"line\"></div><div class=\"line\">testEnum e = a | b;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; a) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件a\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足a要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; b) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件b\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足b要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; c) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件c\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足c要做的事</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将数值与各个枚举值按位与，非零即包含该枚举值。</p>\n<p>也可以通过一个for循环，再通过switch-case处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, AnimationType) &#123;</div><div class=\"line\">    <span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    BaseAnimation = <span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Value = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Path = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    KeyFrameAnimation_shake = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">    Transition = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>,</div><div class=\"line\">    AnimationGroup = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>,</div><div class=\"line\">    ViewAnimation = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)initAnimationWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> animationType = <span class=\"number\">1</span>; animationType&lt;(ViewAnimation&lt;&lt;<span class=\"number\">1</span>); animationType = animationType&lt;&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (type &amp; animationType) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> startAnimationInitialWithType:animationType];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startAnimationInitialWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseAnimation:&#123;</div><div class=\"line\">            <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">            myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">            myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">            myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">            myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">            myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">            <span class=\"comment\">//添加layer</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">            <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> Transition:</div><div class=\"line\">            _index = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是</strong>：<code>case</code>中如果声明了变量，必须要用<code>{}</code>包住，这是编译器强制的，不然会报错，应该是为了避免<a href=\"http://blog.csdn.net/fanjunxi1990/article/details/9162945\" target=\"_blank\" rel=\"external\">switch case语句里面不能定义对象，有语法错误，除非加一个花括号</a>这个问题。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。<br>比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    c = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    d = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\"></div><div class=\"line\">    e = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    f = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    g = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    h = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">4</span></div><div class=\"line\">&#125;testEnum;</div></pre></td></tr></table></figure></p>\n<p>a b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和<code>00001111</code>按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与<code>11110000</code>按位与得到另外一组。</p>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>\n","excerpt":"<p>oc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（&lt;&lt;）来定义枚举的值，其原因是什么呢？</p>","more":"<h2 id=\"enum的基本用法使用\"><a href=\"#enum的基本用法使用\" class=\"headerlink\" title=\"enum的基本用法使用\"></a>enum的基本用法使用</h2><p>定义一组常量。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">\tBlenderSpeedStir=<span class=\"number\">1</span>，</div><div class=\"line\">\tBlenderSpeedChop=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>，</div><div class=\"line\">&#125; BlenderSpeed；</div></pre></td></tr></table></figure></p>\n<p>还可以写成这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, BlenderSpeed) &#123;</div><div class=\"line\"><span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    Test1A = <span class=\"number\">1</span>,</div><div class=\"line\">    Test1B = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    Test1C = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    Test1D = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">BlenderSpeed speed = Test1A；</div></pre></td></tr></table></figure></p>\n<p>使用<code>BlenderSpeed</code>代替<code>NSInteger</code>。</p>\n<h2 id=\"移位定义enum\"><a href=\"#移位定义enum\" class=\"headerlink\" title=\"移位定义enum\"></a>移位定义enum</h2><h3 id=\"使用移位定义enum的好处\"><a href=\"#使用移位定义enum的好处\" class=\"headerlink\" title=\"使用移位定义enum的好处\"></a>使用移位定义enum的好处</h3><p>enum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：<strong>用移位来定义枚举能把1的位置错开，可以使用<code>按位或</code>将几个枚举值表示成一个数，而不会互相影响</strong>。如果用数字就要使用一个数组。</p>\n<p>比如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1</span> delay:<span class=\"number\">0</span> options:<span class=\"built_in\">UIViewAnimationOptionTransitionFlipFromRight</span> |<span class=\"built_in\">UIViewAnimationOptionRepeat</span> animations:^&#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span></div><div class=\"line\">&#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>其中<code>options</code>只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入<code>UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat</code>表示既<code>FlipFromRight</code>又<code>repeat</code>。</p>\n<h3 id=\"取出enum值\"><a href=\"#取出enum值\" class=\"headerlink\" title=\"取出enum值\"></a>取出enum值</h3><p>将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下<code>按位与&amp;</code>操作符的特性：</p>\n<blockquote>\n<p>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。<br>所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。</p>\n</blockquote>\n<p>因此，我们可以这样取出枚举值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    c = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    d = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;testEnum;</div><div class=\"line\"></div><div class=\"line\">testEnum e = a | b;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; a) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件a\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足a要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; b) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件b\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足b要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; c) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件c\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足c要做的事</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将数值与各个枚举值按位与，非零即包含该枚举值。</p>\n<p>也可以通过一个for循环，再通过switch-case处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, AnimationType) &#123;</div><div class=\"line\">    <span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    BaseAnimation = <span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Value = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Path = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    KeyFrameAnimation_shake = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">    Transition = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>,</div><div class=\"line\">    AnimationGroup = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>,</div><div class=\"line\">    ViewAnimation = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)initAnimationWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> animationType = <span class=\"number\">1</span>; animationType&lt;(ViewAnimation&lt;&lt;<span class=\"number\">1</span>); animationType = animationType&lt;&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (type &amp; animationType) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> startAnimationInitialWithType:animationType];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startAnimationInitialWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseAnimation:&#123;</div><div class=\"line\">            <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">            myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">            myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">            myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">            myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">            myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">            <span class=\"comment\">//添加layer</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">            <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> Transition:</div><div class=\"line\">            _index = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是</strong>：<code>case</code>中如果声明了变量，必须要用<code>{}</code>包住，这是编译器强制的，不然会报错，应该是为了避免<a href=\"http://blog.csdn.net/fanjunxi1990/article/details/9162945\">switch case语句里面不能定义对象，有语法错误，除非加一个花括号</a>这个问题。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。<br>比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    c = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    d = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\"></div><div class=\"line\">    e = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    f = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    g = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    h = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">4</span></div><div class=\"line\">&#125;testEnum;</div></pre></td></tr></table></figure></p>\n<p>a b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和<code>00001111</code>按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与<code>11110000</code>按位与得到另外一组。</p>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>"},{"title":"oc 中的泛型与nullability","date":"2016-09-28T02:07:12.000Z","_content":"\noc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合[Objective—C语言的新魅力——Nullability、泛型集合与类型延拓](https://my.oschina.net/u/2340880/blog/514804)对oc的这些新特性进行研究。\n\n<!--more-->\n\n## Nullability检测的支持\n可以使用`nullable`关键字，表明该对象可以是空值;使用`nonnull`关键字表明不可以是空对象。\n\n```objc\n@property (nullable, nonatomic, strong) ObjectType firstObject;\n@property (nullable, nonatomic, strong) ObjectType lastObject;\n```\n\n这是NSArray中的两个属性，其中`nullable`关键字说明了这里可能返回空的值。\n\n如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如：\n\n```objc\n-(void)setValue:(NSNumber * _Nonnull )number{\n\t\n}\n```\n\n如果传入了空值，编译器会警告：\n\n![oc_new_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_1.png?raw=true)\n\n## 泛型的使用\n这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。\n\n### 有类型约定的集合\n在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下：\n\n```objc\nNSMutableArray<NSString *> *array = [[NSMutableArray alloc]init];\n```\n\n声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如：\n\n![oc_new_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_2.png?raw=true)\n\n在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来:\n\n![oc_new_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_3.png?raw=true)\n\n如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告：\n\n![oc_new_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_4.png?raw=true)\n\n### 类型通配符\niOS的系统类中，大量使用了`ObjectType`关键字，如下是系统的`NSMutableArray`的头文件：\n\n```objc\n@interface NSMutableArray<ObjectType> : NSArray<ObjectType>\n- (void)addObject:(ObjectType)anObject;\n- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;\n- (void)removeLastObject;\n- (void)removeObjectAtIndex:(NSUInteger)index;\n- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;\n- (instancetype)init NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n@end\n```\n\n这个`ObjectType`就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray：\n\n```objc\n@interface MyArray<Type> : NSObject\n@property(nonatomic,strong,nonnull)NSMutableArray<Type> *array;\n-(void)addObject:(nonnull Type)obj;\n@end\n```\n\n实现如下：\n\n```objc\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _array = [[NSMutableArray alloc]init];\n    }\n    return self;\n}\n- (void)addObject:(id)obj{\n    [_array addObject:obj];\n}\n```\n\n**注意**：\n- 这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。\n- 实现时，对于定义的`Type`类型的参数，使用`id`代替。\n- 泛型`Type`不用写成`Type *`。\n- 对于多参的集合，将参数类型用“,”隔开即可，如`NSMultableDictionary<NSString * ,NSString *> *dic = [[NSMultableDictionary alloc] init];`\n\n### __kindof\n在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如`UIView`的实例`view`和`UIButton`的实例`button`,可以`view = button`，但是最好不要`button = view`。如果想要使用，又不希望产生警告怎么办？使用`__kindof`。\n```objc\nUIButton *b = [[UIButton alloc] init];\n__kindof UIView *view = [[UIButton alloc]init];\nb = view;\n```\n\n这里，由于`view`使用`__kindof`表示`UIView`的子类，不会产生警告。否则要进行强转`b = (UIButton *)view;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/oc新特性.md","raw":"title: oc 中的泛型与nullability\ndate: 2016/9/28 10:07:12  \ncategories: iOS\ntags:\n\t- Objective-C\n\n---\n\noc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合[Objective—C语言的新魅力——Nullability、泛型集合与类型延拓](https://my.oschina.net/u/2340880/blog/514804)对oc的这些新特性进行研究。\n\n<!--more-->\n\n## Nullability检测的支持\n可以使用`nullable`关键字，表明该对象可以是空值;使用`nonnull`关键字表明不可以是空对象。\n\n```objc\n@property (nullable, nonatomic, strong) ObjectType firstObject;\n@property (nullable, nonatomic, strong) ObjectType lastObject;\n```\n\n这是NSArray中的两个属性，其中`nullable`关键字说明了这里可能返回空的值。\n\n如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如：\n\n```objc\n-(void)setValue:(NSNumber * _Nonnull )number{\n\t\n}\n```\n\n如果传入了空值，编译器会警告：\n\n![oc_new_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_1.png?raw=true)\n\n## 泛型的使用\n这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。\n\n### 有类型约定的集合\n在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下：\n\n```objc\nNSMutableArray<NSString *> *array = [[NSMutableArray alloc]init];\n```\n\n声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如：\n\n![oc_new_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_2.png?raw=true)\n\n在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来:\n\n![oc_new_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_3.png?raw=true)\n\n如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告：\n\n![oc_new_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_4.png?raw=true)\n\n### 类型通配符\niOS的系统类中，大量使用了`ObjectType`关键字，如下是系统的`NSMutableArray`的头文件：\n\n```objc\n@interface NSMutableArray<ObjectType> : NSArray<ObjectType>\n- (void)addObject:(ObjectType)anObject;\n- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;\n- (void)removeLastObject;\n- (void)removeObjectAtIndex:(NSUInteger)index;\n- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;\n- (instancetype)init NS_DESIGNATED_INITIALIZER;\n- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n@end\n```\n\n这个`ObjectType`就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray：\n\n```objc\n@interface MyArray<Type> : NSObject\n@property(nonatomic,strong,nonnull)NSMutableArray<Type> *array;\n-(void)addObject:(nonnull Type)obj;\n@end\n```\n\n实现如下：\n\n```objc\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        _array = [[NSMutableArray alloc]init];\n    }\n    return self;\n}\n- (void)addObject:(id)obj{\n    [_array addObject:obj];\n}\n```\n\n**注意**：\n- 这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。\n- 实现时，对于定义的`Type`类型的参数，使用`id`代替。\n- 泛型`Type`不用写成`Type *`。\n- 对于多参的集合，将参数类型用“,”隔开即可，如`NSMultableDictionary<NSString * ,NSString *> *dic = [[NSMultableDictionary alloc] init];`\n\n### __kindof\n在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如`UIView`的实例`view`和`UIButton`的实例`button`,可以`view = button`，但是最好不要`button = view`。如果想要使用，又不希望产生警告怎么办？使用`__kindof`。\n```objc\nUIButton *b = [[UIButton alloc] init];\n__kindof UIView *view = [[UIButton alloc]init];\nb = view;\n```\n\n这里，由于`view`使用`__kindof`表示`UIView`的子类，不会产生警告。否则要进行强转`b = (UIButton *)view;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"oc新特性","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41drd00327hzg57ahlavn","content":"<p>oc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合<a href=\"https://my.oschina.net/u/2340880/blog/514804\" target=\"_blank\" rel=\"external\">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a>对oc的这些新特性进行研究。</p>\n<a id=\"more\"></a>\n<h2 id=\"Nullability检测的支持\"><a href=\"#Nullability检测的支持\" class=\"headerlink\" title=\"Nullability检测的支持\"></a>Nullability检测的支持</h2><p>可以使用<code>nullable</code>关键字，表明该对象可以是空值;使用<code>nonnull</code>关键字表明不可以是空对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) ObjectType firstObject;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) ObjectType lastObject;</div></pre></td></tr></table></figure>\n<p>这是NSArray中的两个属性，其中<code>nullable</code>关键字说明了这里可能返回空的值。</p>\n<p>如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)setValue:(<span class=\"built_in\">NSNumber</span> * _Nonnull )number&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果传入了空值，编译器会警告：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_1.png?raw=true\" alt=\"oc_new_1\"></p>\n<h2 id=\"泛型的使用\"><a href=\"#泛型的使用\" class=\"headerlink\" title=\"泛型的使用\"></a>泛型的使用</h2><p>这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。</p>\n<h3 id=\"有类型约定的集合\"><a href=\"#有类型约定的集合\" class=\"headerlink\" title=\"有类型约定的集合\"></a>有类型约定的集合</h3><p>在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSMutableArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *array = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div></pre></td></tr></table></figure>\n<p>声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_2.png?raw=true\" alt=\"oc_new_2\"></p>\n<p>在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_3.png?raw=true\" alt=\"oc_new_3\"></p>\n<p>如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_4.png?raw=true\" alt=\"oc_new_4\"></p>\n<h3 id=\"类型通配符\"><a href=\"#类型通配符\" class=\"headerlink\" title=\"类型通配符\"></a>类型通配符</h3><p>iOS的系统类中，大量使用了<code>ObjectType</code>关键字，如下是系统的<code>NSMutableArray</code>的头文件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSMutableArray</span>&lt;<span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSArray</span>&lt;<span class=\"title\">ObjectType</span>&gt;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addObject:(ObjectType)anObject;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)insertObject:(ObjectType)anObject atIndex:(<span class=\"built_in\">NSUInteger</span>)index;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeLastObject;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)replaceObjectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index withObject:(ObjectType)anObject;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithCapacity:(<span class=\"built_in\">NSUInteger</span>)numItems <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这个<code>ObjectType</code>就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyArray</span>&lt;<span class=\"title\">Type</span>&gt; : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>,<span class=\"keyword\">nonnull</span>)<span class=\"built_in\">NSMutableArray</span>&lt;Type&gt; *array;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)addObject:(<span class=\"keyword\">nonnull</span> Type)obj;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">        _array = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)addObject:(<span class=\"keyword\">id</span>)obj&#123;</div><div class=\"line\">    [_array addObject:obj];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。</li>\n<li>实现时，对于定义的<code>Type</code>类型的参数，使用<code>id</code>代替。</li>\n<li>泛型<code>Type</code>不用写成<code>Type *</code>。</li>\n<li>对于多参的集合，将参数类型用“,”隔开即可，如<code>NSMultableDictionary&lt;NSString * ,NSString *&gt; *dic = [[NSMultableDictionary alloc] init];</code></li>\n</ul>\n<h3 id=\"kindof\"><a href=\"#kindof\" class=\"headerlink\" title=\"__kindof\"></a>__kindof</h3><p>在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如<code>UIView</code>的实例<code>view</code>和<code>UIButton</code>的实例<code>button</code>,可以<code>view = button</code>，但是最好不要<code>button = view</code>。如果想要使用，又不希望产生警告怎么办？使用<code>__kindof</code>。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *b = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\">__kindof <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIButton</span> alloc]init];</div><div class=\"line\">b = view;</div></pre></td></tr></table></figure></p>\n<p>这里，由于<code>view</code>使用<code>__kindof</code>表示<code>UIView</code>的子类，不会产生警告。否则要进行强转<code>b = (UIButton *)view;</code></p>\n","excerpt":"<p>oc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合<a href=\"https://my.oschina.net/u/2340880/blog/514804\">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a>对oc的这些新特性进行研究。</p>","more":"<h2 id=\"Nullability检测的支持\"><a href=\"#Nullability检测的支持\" class=\"headerlink\" title=\"Nullability检测的支持\"></a>Nullability检测的支持</h2><p>可以使用<code>nullable</code>关键字，表明该对象可以是空值;使用<code>nonnull</code>关键字表明不可以是空对象。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) ObjectType firstObject;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) ObjectType lastObject;</div></pre></td></tr></table></figure>\n<p>这是NSArray中的两个属性，其中<code>nullable</code>关键字说明了这里可能返回空的值。</p>\n<p>如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)setValue:(<span class=\"built_in\">NSNumber</span> * _Nonnull )number&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果传入了空值，编译器会警告：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_1.png?raw=true\" alt=\"oc_new_1\"></p>\n<h2 id=\"泛型的使用\"><a href=\"#泛型的使用\" class=\"headerlink\" title=\"泛型的使用\"></a>泛型的使用</h2><p>这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。</p>\n<h3 id=\"有类型约定的集合\"><a href=\"#有类型约定的集合\" class=\"headerlink\" title=\"有类型约定的集合\"></a>有类型约定的集合</h3><p>在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSMutableArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *array = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div></pre></td></tr></table></figure>\n<p>声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_2.png?raw=true\" alt=\"oc_new_2\"></p>\n<p>在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_3.png?raw=true\" alt=\"oc_new_3\"></p>\n<p>如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_4.png?raw=true\" alt=\"oc_new_4\"></p>\n<h3 id=\"类型通配符\"><a href=\"#类型通配符\" class=\"headerlink\" title=\"类型通配符\"></a>类型通配符</h3><p>iOS的系统类中，大量使用了<code>ObjectType</code>关键字，如下是系统的<code>NSMutableArray</code>的头文件：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSMutableArray</span>&lt;<span class=\"title\">ObjectType</span>&gt; : <span class=\"title\">NSArray</span>&lt;<span class=\"title\">ObjectType</span>&gt;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)addObject:(ObjectType)anObject;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)insertObject:(ObjectType)anObject atIndex:(<span class=\"built_in\">NSUInteger</span>)index;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeLastObject;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObjectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)replaceObjectAtIndex:(<span class=\"built_in\">NSUInteger</span>)index withObject:(ObjectType)anObject;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithCapacity:(<span class=\"built_in\">NSUInteger</span>)numItems <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder <span class=\"built_in\">NS_DESIGNATED_INITIALIZER</span>;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>这个<code>ObjectType</code>就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyArray</span>&lt;<span class=\"title\">Type</span>&gt; : <span class=\"title\">NSObject</span></span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>,<span class=\"keyword\">nonnull</span>)<span class=\"built_in\">NSMutableArray</span>&lt;Type&gt; *array;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)addObject:(<span class=\"keyword\">nonnull</span> Type)obj;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>实现如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</div><div class=\"line\">        _array = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)addObject:(<span class=\"keyword\">id</span>)obj&#123;</div><div class=\"line\">    [_array addObject:obj];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。</li>\n<li>实现时，对于定义的<code>Type</code>类型的参数，使用<code>id</code>代替。</li>\n<li>泛型<code>Type</code>不用写成<code>Type *</code>。</li>\n<li>对于多参的集合，将参数类型用“,”隔开即可，如<code>NSMultableDictionary&lt;NSString * ,NSString *&gt; *dic = [[NSMultableDictionary alloc] init];</code></li>\n</ul>\n<h3 id=\"kindof\"><a href=\"#kindof\" class=\"headerlink\" title=\"__kindof\"></a>__kindof</h3><p>在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如<code>UIView</code>的实例<code>view</code>和<code>UIButton</code>的实例<code>button</code>,可以<code>view = button</code>，但是最好不要<code>button = view</code>。如果想要使用，又不希望产生警告怎么办？使用<code>__kindof</code>。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *b = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\">__kindof <span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIButton</span> alloc]init];</div><div class=\"line\">b = view;</div></pre></td></tr></table></figure></p>\n<p>这里，由于<code>view</code>使用<code>__kindof</code>表示<code>UIView</code>的子类，不会产生警告。否则要进行强转<code>b = (UIButton *)view;</code></p>"},{"title":"python 3.5 IO编程","date":"2016-08-15T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 文件读写\n#### 读文件\n使用Python内置的open()函数，传入文件名和标示符\n```python\n>>> f = open('/Users/test.txt', 'r')\n```\n标示符'r'表示读.\n\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n```python\n>>> f.read()\n'Hello, world!'\n```\n\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的\n```python\n>>> f.close()\n```\n\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n```python\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n```\n\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n```python\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n```\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```python\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n\n#### 二进制文件\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n```python\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n```\n\n#### 文件读写\n\n阅读: 100273\n读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。\n\n读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n读文件\n\n要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：\n\n>>> f = open('/Users/michael/test.txt', 'r')\n标示符'r'表示读，这样，我们就成功地打开了一个文件。\n\n如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：\n\n>>> f=open('/Users/michael/notfound.txt', 'r')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n\n>>> f.read()\n'Hello, world!'\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：\n\n>>> f.close()\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\nfile-like Object\n\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。\n\nStringIO就是在内存中创建的file-like Object，常用作临时缓冲。\n\n#### 二进制文件\n\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n字符编码\n\n#### 字符编码\n要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')\n>>> f.read()\n'测试'\n```\n\n遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')\n```\n\n#### 写文件\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：\n```python\n>>> f = open('/Users/michael/test.txt', 'w')\n>>> f.write('Hello, world!')\n>>> f.close()\n```\n\n你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：\n```python\nwith open('/Users/michael/test.txt', 'w') as f:\n    f.write('Hello, world!')\n```\n\n### StringIO和BytesIO\n读取写内容到内存中，不写了。用到再看。\n\n### 操作文件和目录\n```python\n>>> import os\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n```\n把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：\n```python\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\n```\n\n文件操作\n```python\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n```\n\n### 序列化\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n\nPython提供了pickle模块来实现序列化。\n```python\n>>> import pickle\n>>> d = dict(name='Bob', age=20, score=88)\n>>> f = open('dump.txt', 'wb')\n>>> pickle.dump(d, f)\n>>> f.close()\n```\npickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.\n当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:\n```python\n>>> f = open('dump.txt', 'rb')\n>>> d = pickle.load(f)\n>>> f.close()\n>>> d\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n### JSON\nPython内置的json模块提供了非常完善的Python对象到JSON格式的转换。\n```python\n>>> import json\n>>> d = dict(name='Bob', age=20, score=88)\n>>> json.dumps(d)\n'{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n```\ndumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。\n\n要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：\n```python\n>>> json_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n>>> json.loads(json_str)\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_IO编程.md","raw":"title: python 3.5 IO编程\ndate: 2016/8/15 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 文件读写\n#### 读文件\n使用Python内置的open()函数，传入文件名和标示符\n```python\n>>> f = open('/Users/test.txt', 'r')\n```\n标示符'r'表示读.\n\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n```python\n>>> f.read()\n'Hello, world!'\n```\n\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的\n```python\n>>> f.close()\n```\n\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n```python\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n```\n\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n```python\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n```\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```python\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n\n#### 二进制文件\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n```python\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n```\n\n#### 文件读写\n\n阅读: 100273\n读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。\n\n读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n读文件\n\n要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：\n\n>>> f = open('/Users/michael/test.txt', 'r')\n标示符'r'表示读，这样，我们就成功地打开了一个文件。\n\n如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：\n\n>>> f=open('/Users/michael/notfound.txt', 'r')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n\n>>> f.read()\n'Hello, world!'\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：\n\n>>> f.close()\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\nfile-like Object\n\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。\n\nStringIO就是在内存中创建的file-like Object，常用作临时缓冲。\n\n#### 二进制文件\n\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n字符编码\n\n#### 字符编码\n要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')\n>>> f.read()\n'测试'\n```\n\n遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')\n```\n\n#### 写文件\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：\n```python\n>>> f = open('/Users/michael/test.txt', 'w')\n>>> f.write('Hello, world!')\n>>> f.close()\n```\n\n你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：\n```python\nwith open('/Users/michael/test.txt', 'w') as f:\n    f.write('Hello, world!')\n```\n\n### StringIO和BytesIO\n读取写内容到内存中，不写了。用到再看。\n\n### 操作文件和目录\n```python\n>>> import os\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n```\n把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：\n```python\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\n```\n\n文件操作\n```python\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n```\n\n### 序列化\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n\nPython提供了pickle模块来实现序列化。\n```python\n>>> import pickle\n>>> d = dict(name='Bob', age=20, score=88)\n>>> f = open('dump.txt', 'wb')\n>>> pickle.dump(d, f)\n>>> f.close()\n```\npickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.\n当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:\n```python\n>>> f = open('dump.txt', 'rb')\n>>> d = pickle.load(f)\n>>> f.close()\n>>> d\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n### JSON\nPython内置的json模块提供了非常完善的Python对象到JSON格式的转换。\n```python\n>>> import json\n>>> d = dict(name='Bob', age=20, score=88)\n>>> json.dumps(d)\n'{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n```\ndumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。\n\n要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：\n```python\n>>> json_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n>>> json.loads(json_str)\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_IO编程","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dri00367hzgely1z2g0","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h3><h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><p>使用Python内置的open()函数，传入文件名和标示符<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/test.txt'</span>, <span class=\"string\">'r'</span>)</div></pre></td></tr></table></figure></p>\n<p>标示符’r’表示读.</p>\n<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'Hello, world!'</span></div></pre></td></tr></table></figure></p>\n<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    f = open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</div><div class=\"line\">    print(f.read())</div><div class=\"line\"><span class=\"keyword\">finally</span>:</div><div class=\"line\">    <span class=\"keyword\">if</span> f:</div><div class=\"line\">        f.close()</div></pre></td></tr></table></figure></p>\n<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    print(f.read())</div></pre></td></tr></table></figure></p>\n<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</div><div class=\"line\">    print(line.strip()) <span class=\"comment\"># 把末尾的'\\n'删掉</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"二进制文件\"><a href=\"#二进制文件\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.jpg'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">b'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...'</span> <span class=\"comment\"># 十六进制表示的字节</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"文件读写-1\"><a href=\"#文件读写-1\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h4><p>阅读: 100273<br>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>\n<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<p>读文件</p>\n<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.txt’, ‘r’)<br>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f=open(‘/Users/michael/notfound.txt’, ‘r’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>FileNotFoundError: [Errno 2] No such file or directory: ‘/Users/michael/notfound.txt’<br>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</module></stdin></p>\n<p>f.read()<br>‘Hello, world!’<br>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>\n<p>f.close()<br>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>try:<br>    f = open(‘/path/to/file’, ‘r’)<br>    print(f.read())<br>finally:<br>    if f:<br>        f.close()<br>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>\n<p>with open(‘/path/to/file’, ‘r’) as f:<br>    print(f.read())<br>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>\n<p>for line in f.readlines():<br>    print(line.strip()) # 把末尾的’\\n’删掉<br>file-like Object</p>\n<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>\n<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<h4 id=\"二进制文件-1\"><a href=\"#二进制文件-1\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.jpg’, ‘rb’)<br>f.read()<br>b’\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00…’ # 十六进制表示的字节<br>字符编码</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'测试'</span></div></pre></td></tr></table></figure></p>\n<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>, errors=<span class=\"string\">'ignore'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.write(<span class=\"string\">'Hello, world!'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(<span class=\"string\">'Hello, world!'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"StringIO和BytesIO\"><a href=\"#StringIO和BytesIO\" class=\"headerlink\" title=\"StringIO和BytesIO\"></a>StringIO和BytesIO</h3><p>读取写内容到内存中，不写了。用到再看。</p>\n<h3 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.abspath(<span class=\"string\">'.'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></div><div class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>\n<p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。<br>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.split(<span class=\"string\">'/Users/michael/testdir/file.txt'</span>)</div><div class=\"line\">(<span class=\"string\">'/Users/michael/testdir'</span>, <span class=\"string\">'file.txt'</span>)</div></pre></td></tr></table></figure></p>\n<p>文件操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 对文件重命名:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉文件:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.remove(<span class=\"string\">'test.py'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>\n<p>Python提供了pickle模块来实现序列化。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> pickle</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'wb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</div><div class=\"line\"><span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>\n<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_str = <span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h3><h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><p>使用Python内置的open()函数，传入文件名和标示符<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/test.txt'</span>, <span class=\"string\">'r'</span>)</div></pre></td></tr></table></figure></p>\n<p>标示符’r’表示读.</p>\n<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'Hello, world!'</span></div></pre></td></tr></table></figure></p>\n<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    f = open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</div><div class=\"line\">    print(f.read())</div><div class=\"line\"><span class=\"keyword\">finally</span>:</div><div class=\"line\">    <span class=\"keyword\">if</span> f:</div><div class=\"line\">        f.close()</div></pre></td></tr></table></figure></p>\n<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    print(f.read())</div></pre></td></tr></table></figure></p>\n<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</div><div class=\"line\">    print(line.strip()) <span class=\"comment\"># 把末尾的'\\n'删掉</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"二进制文件\"><a href=\"#二进制文件\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.jpg'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">b'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...'</span> <span class=\"comment\"># 十六进制表示的字节</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"文件读写-1\"><a href=\"#文件读写-1\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h4><p>阅读: 100273<br>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>\n<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<p>读文件</p>\n<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.txt’, ‘r’)<br>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f=open(‘/Users/michael/notfound.txt’, ‘r’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>FileNotFoundError: [Errno 2] No such file or directory: ‘/Users/michael/notfound.txt’<br>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</p>\n<p>f.read()<br>‘Hello, world!’<br>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>\n<p>f.close()<br>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>try:<br>    f = open(‘/path/to/file’, ‘r’)<br>    print(f.read())<br>finally:<br>    if f:<br>        f.close()<br>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>\n<p>with open(‘/path/to/file’, ‘r’) as f:<br>    print(f.read())<br>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>\n<p>for line in f.readlines():<br>    print(line.strip()) # 把末尾的’\\n’删掉<br>file-like Object</p>\n<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>\n<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<h4 id=\"二进制文件-1\"><a href=\"#二进制文件-1\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.jpg’, ‘rb’)<br>f.read()<br>b’\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00…’ # 十六进制表示的字节<br>字符编码</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'测试'</span></div></pre></td></tr></table></figure></p>\n<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>, errors=<span class=\"string\">'ignore'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.write(<span class=\"string\">'Hello, world!'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(<span class=\"string\">'Hello, world!'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"StringIO和BytesIO\"><a href=\"#StringIO和BytesIO\" class=\"headerlink\" title=\"StringIO和BytesIO\"></a>StringIO和BytesIO</h3><p>读取写内容到内存中，不写了。用到再看。</p>\n<h3 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.abspath(<span class=\"string\">'.'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></div><div class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>\n<p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。<br>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.split(<span class=\"string\">'/Users/michael/testdir/file.txt'</span>)</div><div class=\"line\">(<span class=\"string\">'/Users/michael/testdir'</span>, <span class=\"string\">'file.txt'</span>)</div></pre></td></tr></table></figure></p>\n<p>文件操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 对文件重命名:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉文件:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.remove(<span class=\"string\">'test.py'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>\n<p>Python提供了pickle模块来实现序列化。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> pickle</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'wb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</div><div class=\"line\"><span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>\n<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_str = <span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 函数","date":"2016-08-07T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n### 调用函数\n#### 数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数\n\n#### 函数名\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”\n```python\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1\n```\n\n### 定义函数\n定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n```python\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.\n\n#### 空函数\n用pass语句定义一个什么事都不做的空函数，不用pass会报错。\n```python\ndef nop():\n    pass\n# 或者    \nif age >= 18:\n    pass\n```\n\n#### 返回多个值\n```python\nimport math\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n```\n\n得到返回值\n```python\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n```\n其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n### 函数的参数\n#### 默认参数\npython不支持重载，可以使用默认参数的方式替代。\n```python\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).\n\n但是需要注意：\n1. 必选参数在前，默认参数在后，否则Python的解释器会报错。**如果不按顺序提供参数时，需要写成 参数名=xx 的形式。**\n2. 默认参数必须指向不变对象。\n例如：\n```python\ndef add_end(L=[]):\n    L.append('END')\n    return L\n    \n>>> add_end()\n['END']\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n```\n当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。\n\n如果要默认是list，可以这么写：\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 可变参数\n通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n```\n**可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list**\n**不是可变参数的话，参数需要一一对应**\n\n如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：\n```python\n>>> nums = [1, 2, 3]\n>>> print(nums)\n[1, 2, 3]\n>>> print(*nums)\n1, 2, 3\n# 调用\n>>> calc(*nums)\n14\n```\n**nums表示一个数组或者元组\n\\*nums表示取出nums这个list里的所有元素，代表多个参数**\n\n#### 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：\n```python\n# 定义函数\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n# 调用\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n# 另一种简化写法\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n**kw表示一个dict\n\\*\\*kw表示取出kw中的所有键值对元素，代表多个参数**\n\n**另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。**\n\n#### 命名关键字参数\n不知道这么脑残的语法有什么意义。\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n","source":"_posts/python_函数.md","raw":"title: python 3.5 函数\ndate: 2016/8/7 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n### 调用函数\n#### 数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数\n\n#### 函数名\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”\n```python\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1\n```\n\n### 定义函数\n定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n```python\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.\n\n#### 空函数\n用pass语句定义一个什么事都不做的空函数，不用pass会报错。\n```python\ndef nop():\n    pass\n# 或者    \nif age >= 18:\n    pass\n```\n\n#### 返回多个值\n```python\nimport math\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n```\n\n得到返回值\n```python\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n```\n其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n### 函数的参数\n#### 默认参数\npython不支持重载，可以使用默认参数的方式替代。\n```python\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).\n\n但是需要注意：\n1. 必选参数在前，默认参数在后，否则Python的解释器会报错。**如果不按顺序提供参数时，需要写成 参数名=xx 的形式。**\n2. 默认参数必须指向不变对象。\n例如：\n```python\ndef add_end(L=[]):\n    L.append('END')\n    return L\n    \n>>> add_end()\n['END']\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n```\n当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。\n\n如果要默认是list，可以这么写：\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 可变参数\n通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n```\n**可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list**\n**不是可变参数的话，参数需要一一对应**\n\n如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：\n```python\n>>> nums = [1, 2, 3]\n>>> print(nums)\n[1, 2, 3]\n>>> print(*nums)\n1, 2, 3\n# 调用\n>>> calc(*nums)\n14\n```\n**nums表示一个数组或者元组\n\\*nums表示取出nums这个list里的所有元素，代表多个参数**\n\n#### 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：\n```python\n# 定义函数\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n# 调用\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n# 另一种简化写法\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n**kw表示一个dict\n\\*\\*kw表示取出kw中的所有键值对元素，代表多个参数**\n\n**另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。**\n\n#### 命名关键字参数\n不知道这么脑残的语法有什么意义。\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n","slug":"python_函数","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41drk00397hzgkusx4bil","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><h4 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数</p>\n<h4 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = abs <span class=\"comment\"># 变量a指向abs函数</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a(<span class=\"number\">-1</span>) <span class=\"comment\"># 所以也可以通过a调用abs函数</span></div><div class=\"line\"><span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -x</div></pre></td></tr></table></figure></p>\n<p>可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.</p>\n<h4 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h4><p>用pass语句定义一个什么事都不做的空函数，不用pass会报错。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"comment\"># 或者    </span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(x, y, step, angle=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">    nx = x + step * math.cos(angle)</div><div class=\"line\">    ny = y - step * math.sin(angle)</div><div class=\"line\">    <span class=\"keyword\">return</span> nx, ny</div></pre></td></tr></table></figure>\n<p>得到返回值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x, y = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(x, y)</div><div class=\"line\"><span class=\"number\">151.96152422706632</span> <span class=\"number\">70.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(r)</div><div class=\"line\">(<span class=\"number\">151.96152422706632</span>, <span class=\"number\">70.0</span>)</div></pre></td></tr></table></figure></p>\n<p>其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>python不支持重载，可以使用默认参数的方式替代。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div></pre></td></tr></table></figure></p>\n<p>第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).</p>\n<p>但是需要注意：</p>\n<ol>\n<li>必选参数在前，默认参数在后，否则Python的解释器会报错。<strong>如果不按顺序提供参数时，需要写成 参数名=xx 的形式。</strong></li>\n<li>默认参数必须指向不变对象。<br>例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=[])</span>:</span></div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。</p>\n<p>如果要默认是list，可以这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"number\">84</span></div></pre></td></tr></table></figure></p>\n<p><strong>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list</strong><br><strong>不是可变参数的话，参数需要一一对应</strong></p>\n<p>如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(nums)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(*nums)</div><div class=\"line\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(*nums)</div><div class=\"line\"><span class=\"number\">14</span></div></pre></td></tr></table></figure></p>\n<p><strong>nums表示一个数组或者元组<br>*nums表示取出nums这个list里的所有元素，代表多个参数</strong></p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</div><div class=\"line\">name: Adam age: <span class=\"number\">45</span> other: &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"comment\"># 另一种简化写法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Jack'</span>, <span class=\"number\">24</span>, **extra)</div><div class=\"line\">name: Jack age: <span class=\"number\">24</span> other: &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>kw表示一个dict<br>**kw表示取出kw中的所有键值对元素，代表多个参数</strong></p>\n<p><strong>另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。</strong></p>\n<h4 id=\"命名关键字参数\"><a href=\"#命名关键字参数\" class=\"headerlink\" title=\"命名关键字参数\"></a>命名关键字参数</h4><p>不知道这么脑残的语法有什么意义。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><h4 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数</p>\n<h4 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = abs <span class=\"comment\"># 变量a指向abs函数</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a(<span class=\"number\">-1</span>) <span class=\"comment\"># 所以也可以通过a调用abs函数</span></div><div class=\"line\"><span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -x</div></pre></td></tr></table></figure></p>\n<p>可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.</p>\n<h4 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h4><p>用pass语句定义一个什么事都不做的空函数，不用pass会报错。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"comment\"># 或者    </span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(x, y, step, angle=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">    nx = x + step * math.cos(angle)</div><div class=\"line\">    ny = y - step * math.sin(angle)</div><div class=\"line\">    <span class=\"keyword\">return</span> nx, ny</div></pre></td></tr></table></figure>\n<p>得到返回值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x, y = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(x, y)</div><div class=\"line\"><span class=\"number\">151.96152422706632</span> <span class=\"number\">70.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(r)</div><div class=\"line\">(<span class=\"number\">151.96152422706632</span>, <span class=\"number\">70.0</span>)</div></pre></td></tr></table></figure></p>\n<p>其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>python不支持重载，可以使用默认参数的方式替代。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div></pre></td></tr></table></figure></p>\n<p>第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).</p>\n<p>但是需要注意：</p>\n<ol>\n<li>必选参数在前，默认参数在后，否则Python的解释器会报错。<strong>如果不按顺序提供参数时，需要写成 参数名=xx 的形式。</strong></li>\n<li>默认参数必须指向不变对象。<br>例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=[])</span>:</span></div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。</p>\n<p>如果要默认是list，可以这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"number\">84</span></div></pre></td></tr></table></figure></p>\n<p><strong>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list</strong><br><strong>不是可变参数的话，参数需要一一对应</strong></p>\n<p>如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(nums)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(*nums)</div><div class=\"line\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(*nums)</div><div class=\"line\"><span class=\"number\">14</span></div></pre></td></tr></table></figure></p>\n<p><strong>nums表示一个数组或者元组<br>*nums表示取出nums这个list里的所有元素，代表多个参数</strong></p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</div><div class=\"line\">name: Adam age: <span class=\"number\">45</span> other: &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"comment\"># 另一种简化写法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Jack'</span>, <span class=\"number\">24</span>, **extra)</div><div class=\"line\">name: Jack age: <span class=\"number\">24</span> other: &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>kw表示一个dict<br>**kw表示取出kw中的所有键值对元素，代表多个参数</strong></p>\n<p><strong>另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。</strong></p>\n<h4 id=\"命名关键字参数\"><a href=\"#命名关键字参数\" class=\"headerlink\" title=\"命名关键字参数\"></a>命名关键字参数</h4><p>不知道这么脑残的语法有什么意义。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 模块","date":"2016-08-08T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n### 高阶函数\n#### 变量可以指向函数\n把函数本身赋值给变量,即：变量可以指向函数。\n```python\n>>> f = abs\n>>> f(-10)\n10\n```\n说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n\n#### 传入函数\n那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数\n```python\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n\n#### map\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n```python\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数**必须接收两个参数**，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n```python\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n#### filter\nfilter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n```python\ndef is_odd(n):\n    return n % 2 == 1\nlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n# 结果: [1, 5, 9, 15]\n```\n\n#### sorted\n使用sorted()函数就可以对list进行排序。\nsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：\n```python\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36]\n```\n**key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：**\n```python\nlist = [36, 5, -12, 9, -21]\nkeys = [36, 5,  12, 9,  21]\n```\n\n### 返回函数\n高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。\n```python\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n```\n本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。\n因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n\n### 匿名函数\n```python\nlambda x: x * x\n=>\ndef f(x):\n    return x * x\n```\n\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n匿名函数有个限制，就是**只能有一个表达式**，不用写return，返回值就是该表达式的结果。\n匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\n\n### 装饰器\n#### 不带参数\n在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n    \t# 函数对象有一个__name__属性，可以拿到函数的名字\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n@log\ndef now():\n    print('2015-3-25')\n    \n>>> now()\ncall now():\n2015-3-25\n```\n\n此处把**@log**放到**now()**定义处，相当于执行了\n**now = log(now)**: **now() => wrapper()**\n将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。\n\n#### 带参数\n如果log带参数\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print('2015-3-25')\n```\n\n首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即**now()=>wrapper()**\n\n#### 带来的问题\n上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用**now.__name__**时，结果就会使wrapper，而不是now。\n因此，需要将**wrapper.__name__ = func.__name__**。可以使用python内置的方法**functools.wraps**\n\n```\nimport functools\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 或者\nimport functools\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator  \n```\n\n### 偏函数\n使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单\n\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\n```python\ndef int2(x, base=2):\n    return int(x, base)\n```\n\n我们可以使用**functools.partial**创建一个偏函数，不需要自己定义int2\n```python\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n```\n简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单\n\n创建偏函数时，实际上可以接收函数对象、\\*args和\\*\\*kw这3个参数.\n```python\nmax2 = functools.partial(max, 10)\n```\n实际上会把10作为\\*args的一部分**自动加到左边**，也就是：\n```python\nmax2(5, 6, 7)\n相当于：\nargs = (10, 5, 6, 7)\nmax(*args)\n```\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_函数式编程.md","raw":"title: python 3.5 模块\ndate: 2016/8/8 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n### 高阶函数\n#### 变量可以指向函数\n把函数本身赋值给变量,即：变量可以指向函数。\n```python\n>>> f = abs\n>>> f(-10)\n10\n```\n说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n\n#### 传入函数\n那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数\n```python\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n\n#### map\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n```python\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数**必须接收两个参数**，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n```python\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n#### filter\nfilter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n```python\ndef is_odd(n):\n    return n % 2 == 1\nlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n# 结果: [1, 5, 9, 15]\n```\n\n#### sorted\n使用sorted()函数就可以对list进行排序。\nsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：\n```python\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36]\n```\n**key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：**\n```python\nlist = [36, 5, -12, 9, -21]\nkeys = [36, 5,  12, 9,  21]\n```\n\n### 返回函数\n高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。\n```python\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n```\n本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。\n因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n\n### 匿名函数\n```python\nlambda x: x * x\n=>\ndef f(x):\n    return x * x\n```\n\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n匿名函数有个限制，就是**只能有一个表达式**，不用写return，返回值就是该表达式的结果。\n匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\n\n### 装饰器\n#### 不带参数\n在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n    \t# 函数对象有一个__name__属性，可以拿到函数的名字\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n@log\ndef now():\n    print('2015-3-25')\n    \n>>> now()\ncall now():\n2015-3-25\n```\n\n此处把**@log**放到**now()**定义处，相当于执行了\n**now = log(now)**: **now() => wrapper()**\n将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。\n\n#### 带参数\n如果log带参数\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print('2015-3-25')\n```\n\n首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即**now()=>wrapper()**\n\n#### 带来的问题\n上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用**now.__name__**时，结果就会使wrapper，而不是now。\n因此，需要将**wrapper.__name__ = func.__name__**。可以使用python内置的方法**functools.wraps**\n\n```\nimport functools\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 或者\nimport functools\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator  \n```\n\n### 偏函数\n使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单\n\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\n```python\ndef int2(x, base=2):\n    return int(x, base)\n```\n\n我们可以使用**functools.partial**创建一个偏函数，不需要自己定义int2\n```python\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n```\n简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单\n\n创建偏函数时，实际上可以接收函数对象、\\*args和\\*\\*kw这3个参数.\n```python\nmax2 = functools.partial(max, 10)\n```\n实际上会把10作为\\*args的一部分**自动加到左边**，也就是：\n```python\nmax2(5, 6, 7)\n相当于：\nargs = (10, 5, 6, 7)\nmax(*args)\n```\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_函数式编程","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dwe004m7hzgk4gbu4kg","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><h4 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h4><p>把函数本身赋值给变量,即：变量可以指向函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = abs</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">-10</span>)</div><div class=\"line\"><span class=\"number\">10</span></div></pre></td></tr></table></figure></p>\n<p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>\n<h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</div></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x * x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = map(f, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(r)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</div></pre></td></tr></table></figure></p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数<strong>必须接收两个参数</strong>，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>filter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_odd</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span></div><div class=\"line\">list(filter(is_odd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>]))</div><div class=\"line\"><span class=\"comment\"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h4><p>使用sorted()函数就可以对list进行排序。<br>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>], key=abs)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">-12</span>, <span class=\"number\">-21</span>, <span class=\"number\">36</span>]</div></pre></td></tr></table></figure></p>\n<p><strong>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>]</div><div class=\"line\">keys = [<span class=\"number\">36</span>, <span class=\"number\">5</span>,  <span class=\"number\">12</span>, <span class=\"number\">9</span>,  <span class=\"number\">21</span>]</div></pre></td></tr></table></figure></p>\n<h3 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h3><p>高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    fs = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></div><div class=\"line\">             <span class=\"keyword\">return</span> i*i</div><div class=\"line\">        fs.append(f)</div><div class=\"line\">    <span class=\"keyword\">return</span> fs</div><div class=\"line\"></div><div class=\"line\">f1, f2, f3 = count()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</div><div class=\"line\"><span class=\"number\">9</span></div></pre></td></tr></table></figure></p>\n<p>本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。<br>因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">lambda</span> x: x * x</div><div class=\"line\">=&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x * x</div></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写return，返回值就是该表达式的结果。<br>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h4 id=\"不带参数\"><a href=\"#不带参数\" class=\"headerlink\" title=\"不带参数\"></a>不带参数</h4><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">    \t<span class=\"comment\"># 函数对象有一个__name__属性，可以拿到函数的名字</span></div><div class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</div><div class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"><span class=\"meta\">@log</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</div><div class=\"line\">call now():</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-3</span><span class=\"number\">-25</span></div></pre></td></tr></table></figure></p>\n<p>此处把<strong>@log</strong>放到<strong>now()</strong>定义处，相当于执行了<br><strong>now = log(now)</strong>: <strong>now() =&gt; wrapper()</strong><br>将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。</p>\n<h4 id=\"带参数\"><a href=\"#带参数\" class=\"headerlink\" title=\"带参数\"></a>带参数</h4><p>如果log带参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</div><div class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">        <span class=\"keyword\">return</span> wrapper</div><div class=\"line\">    <span class=\"keyword\">return</span> decorator</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@log('execute')</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div></pre></td></tr></table></figure></p>\n<p>首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即<strong>now()=&gt;wrapper()</strong></p>\n<h4 id=\"带来的问题\"><a href=\"#带来的问题\" class=\"headerlink\" title=\"带来的问题\"></a>带来的问题</h4><p>上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用<strong>now.<strong>name</strong></strong>时，结果就会使wrapper，而不是now。<br>因此，需要将<strong>wrapper.<strong>name</strong> = func.<strong>name</strong></strong>。可以使用python内置的方法<strong>functools.wraps</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import functools</div><div class=\"line\">def log(func):</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def wrapper(*args, **kw):</div><div class=\"line\">        print(&apos;call %s():&apos; % func.__name__)</div><div class=\"line\">        return func(*args, **kw)</div><div class=\"line\">    return wrapper</div><div class=\"line\"># 或者</div><div class=\"line\">import functools</div><div class=\"line\">def log(text):</div><div class=\"line\">    def decorator(func):</div><div class=\"line\">        @functools.wraps(func)</div><div class=\"line\">        def wrapper(*args, **kw):</div><div class=\"line\">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class=\"line\">            return func(*args, **kw)</div><div class=\"line\">        return wrapper</div><div class=\"line\">    return decorator</div></pre></td></tr></table></figure>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>\n<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int2</span><span class=\"params\">(x, base=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> int(x, base)</div></pre></td></tr></table></figure></p>\n<p>我们可以使用<strong>functools.partial</strong>创建一个偏函数，不需要自己定义int2<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> functools</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1000000'</span>)</div><div class=\"line\"><span class=\"number\">64</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1010101'</span>)</div><div class=\"line\"><span class=\"number\">85</span></div></pre></td></tr></table></figure></p>\n<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>\n<p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2 = functools.partial(max, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p>实际上会把10作为*args的一部分<strong>自动加到左边</strong>，也就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">相当于：</div><div class=\"line\">args = (<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">max(*args)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><h4 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h4><p>把函数本身赋值给变量,即：变量可以指向函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = abs</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">-10</span>)</div><div class=\"line\"><span class=\"number\">10</span></div></pre></td></tr></table></figure></p>\n<p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>\n<h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</div></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x * x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = map(f, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(r)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</div></pre></td></tr></table></figure></p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数<strong>必须接收两个参数</strong>，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>filter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_odd</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span></div><div class=\"line\">list(filter(is_odd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>]))</div><div class=\"line\"><span class=\"comment\"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h4><p>使用sorted()函数就可以对list进行排序。<br>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>], key=abs)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">-12</span>, <span class=\"number\">-21</span>, <span class=\"number\">36</span>]</div></pre></td></tr></table></figure></p>\n<p><strong>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>]</div><div class=\"line\">keys = [<span class=\"number\">36</span>, <span class=\"number\">5</span>,  <span class=\"number\">12</span>, <span class=\"number\">9</span>,  <span class=\"number\">21</span>]</div></pre></td></tr></table></figure></p>\n<h3 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h3><p>高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    fs = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></div><div class=\"line\">             <span class=\"keyword\">return</span> i*i</div><div class=\"line\">        fs.append(f)</div><div class=\"line\">    <span class=\"keyword\">return</span> fs</div><div class=\"line\"></div><div class=\"line\">f1, f2, f3 = count()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</div><div class=\"line\"><span class=\"number\">9</span></div></pre></td></tr></table></figure></p>\n<p>本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。<br>因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">lambda</span> x: x * x</div><div class=\"line\">=&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x * x</div></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写return，返回值就是该表达式的结果。<br>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h4 id=\"不带参数\"><a href=\"#不带参数\" class=\"headerlink\" title=\"不带参数\"></a>不带参数</h4><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">    \t<span class=\"comment\"># 函数对象有一个__name__属性，可以拿到函数的名字</span></div><div class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</div><div class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"><span class=\"meta\">@log</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</div><div class=\"line\">call now():</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-3</span><span class=\"number\">-25</span></div></pre></td></tr></table></figure></p>\n<p>此处把<strong>@log</strong>放到<strong>now()</strong>定义处，相当于执行了<br><strong>now = log(now)</strong>: <strong>now() =&gt; wrapper()</strong><br>将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。</p>\n<h4 id=\"带参数\"><a href=\"#带参数\" class=\"headerlink\" title=\"带参数\"></a>带参数</h4><p>如果log带参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</div><div class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">        <span class=\"keyword\">return</span> wrapper</div><div class=\"line\">    <span class=\"keyword\">return</span> decorator</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@log('execute')</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div></pre></td></tr></table></figure></p>\n<p>首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即<strong>now()=&gt;wrapper()</strong></p>\n<h4 id=\"带来的问题\"><a href=\"#带来的问题\" class=\"headerlink\" title=\"带来的问题\"></a>带来的问题</h4><p>上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用<strong>now.<strong>name</strong></strong>时，结果就会使wrapper，而不是now。<br>因此，需要将<strong>wrapper.<strong>name</strong> = func.<strong>name</strong></strong>。可以使用python内置的方法<strong>functools.wraps</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import functools</div><div class=\"line\">def log(func):</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def wrapper(*args, **kw):</div><div class=\"line\">        print(&apos;call %s():&apos; % func.__name__)</div><div class=\"line\">        return func(*args, **kw)</div><div class=\"line\">    return wrapper</div><div class=\"line\"># 或者</div><div class=\"line\">import functools</div><div class=\"line\">def log(text):</div><div class=\"line\">    def decorator(func):</div><div class=\"line\">        @functools.wraps(func)</div><div class=\"line\">        def wrapper(*args, **kw):</div><div class=\"line\">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class=\"line\">            return func(*args, **kw)</div><div class=\"line\">        return wrapper</div><div class=\"line\">    return decorator</div></pre></td></tr></table></figure>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>\n<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int2</span><span class=\"params\">(x, base=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> int(x, base)</div></pre></td></tr></table></figure></p>\n<p>我们可以使用<strong>functools.partial</strong>创建一个偏函数，不需要自己定义int2<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> functools</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1000000'</span>)</div><div class=\"line\"><span class=\"number\">64</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1010101'</span>)</div><div class=\"line\"><span class=\"number\">85</span></div></pre></td></tr></table></figure></p>\n<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>\n<p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2 = functools.partial(max, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p>实际上会把10作为*args的一部分<strong>自动加到左边</strong>，也就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">相当于：</div><div class=\"line\">args = (<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">max(*args)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 常用內建模块","date":"2016-08-23T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### datetime\n#### 获取当前日期和时间\ndatetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n如果仅导入import datetime，则必须引用全名datetime.datetime。\n```python\n>>> from datetime import datetime\n>>> now = datetime.now() # 获取当前datetime\n>>> print(now)\n2015-05-18 16:28:07.198690\n>>> print(type(now))\n<class 'datetime.datetime'>\n```\ndatetime.now()返回当前日期和时间，其类型是datetime。\n\n#### 获取指定日期和时间\n要指定某个日期和时间，我们直接用参数构造一个datetime：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> print(dt)\n2015-04-19 12:20:00\n```\n\n#### datetime转换为timestamp\n把一个datetime类型转换为timestamp只需要简单调用**timestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> dt.timestamp() # 把datetime转换为timestamp\n1429417200.0\n```\n注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。\n某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.\n\n#### timestamp转换为datetime\n要把timestamp转换为datetime，使用datetime提供的**fromtimestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> t = 1429417200.0\n>>> print(datetime.fromtimestamp(t))\n2015-04-19 12:20:00\n```\n\n#### str转换为datetime\n转换方法是通过**datetime.strptime()**实现，需要一个日期和时间的格式化字符串：\n```python\n>>> from datetime import datetime\n>>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')\n>>> print(cday)\n2015-06-01 18:19:59\n```\n\n#### datetime转换为str\n如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的\n```python\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(now.strftime('%a, %b %d %H:%M'))\nMon, May 05 16:28\n```\n\n#### datetime加减\n对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类\n```python\n>>> from datetime import datetime, timedelta\n>>> now = datetime.now()\n>>> now\ndatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)\n>>> now + timedelta(hours=10)\ndatetime.datetime(2015, 5, 19, 2, 57, 3, 540997)\n>>> now - timedelta(days=1)\ndatetime.datetime(2015, 5, 17, 16, 57, 3, 540997)\n>>> now + timedelta(days=2, hours=12)\ndatetime.datetime(2015, 5, 21, 4, 57, 3, 540997)\n```\n使用timedelta你可以很容易地算出前几天和后几天的时刻\n\n\n### collections\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。\n#### namedtuple\n`namedtuple`是一个函数，它用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备`tuple`的不变性，又可以根据属性来引用，使用十分方便。\n```python\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> p = Point(1, 2)\n>>> p.x\n1\n>>> p.y\n2\n\n# namedtuple('名称', [属性list]):\nCircle = namedtuple('Circle', ['x', 'y', 'r'])\n\n```\n\n#### deque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。\n`deque`是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\n```python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n`deque`除了实现list的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。\n\n#### defaultdict\n使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：\n```python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n注意默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n#### OrderedDict\n使用`dict`时，Key是无序的。在对`dict`做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用`OrderedDict`：\n```python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n注意，`OrderedDict`的Key会按照插入的顺序排列，不是Key本身排序：\n\n#### Counter\n`Counter`是一个简单的计数器，例如，统计字符出现的个数：\n```python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n```\n`Counter`实际上也是`dict`的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_常用內建模块.md","raw":"title: python 3.5 常用內建模块\ndate: 2016/8/23 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### datetime\n#### 获取当前日期和时间\ndatetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n如果仅导入import datetime，则必须引用全名datetime.datetime。\n```python\n>>> from datetime import datetime\n>>> now = datetime.now() # 获取当前datetime\n>>> print(now)\n2015-05-18 16:28:07.198690\n>>> print(type(now))\n<class 'datetime.datetime'>\n```\ndatetime.now()返回当前日期和时间，其类型是datetime。\n\n#### 获取指定日期和时间\n要指定某个日期和时间，我们直接用参数构造一个datetime：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> print(dt)\n2015-04-19 12:20:00\n```\n\n#### datetime转换为timestamp\n把一个datetime类型转换为timestamp只需要简单调用**timestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> dt.timestamp() # 把datetime转换为timestamp\n1429417200.0\n```\n注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。\n某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.\n\n#### timestamp转换为datetime\n要把timestamp转换为datetime，使用datetime提供的**fromtimestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> t = 1429417200.0\n>>> print(datetime.fromtimestamp(t))\n2015-04-19 12:20:00\n```\n\n#### str转换为datetime\n转换方法是通过**datetime.strptime()**实现，需要一个日期和时间的格式化字符串：\n```python\n>>> from datetime import datetime\n>>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')\n>>> print(cday)\n2015-06-01 18:19:59\n```\n\n#### datetime转换为str\n如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的\n```python\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(now.strftime('%a, %b %d %H:%M'))\nMon, May 05 16:28\n```\n\n#### datetime加减\n对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类\n```python\n>>> from datetime import datetime, timedelta\n>>> now = datetime.now()\n>>> now\ndatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)\n>>> now + timedelta(hours=10)\ndatetime.datetime(2015, 5, 19, 2, 57, 3, 540997)\n>>> now - timedelta(days=1)\ndatetime.datetime(2015, 5, 17, 16, 57, 3, 540997)\n>>> now + timedelta(days=2, hours=12)\ndatetime.datetime(2015, 5, 21, 4, 57, 3, 540997)\n```\n使用timedelta你可以很容易地算出前几天和后几天的时刻\n\n\n### collections\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。\n#### namedtuple\n`namedtuple`是一个函数，它用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备`tuple`的不变性，又可以根据属性来引用，使用十分方便。\n```python\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> p = Point(1, 2)\n>>> p.x\n1\n>>> p.y\n2\n\n# namedtuple('名称', [属性list]):\nCircle = namedtuple('Circle', ['x', 'y', 'r'])\n\n```\n\n#### deque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。\n`deque`是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\n```python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n`deque`除了实现list的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。\n\n#### defaultdict\n使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：\n```python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n注意默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n#### OrderedDict\n使用`dict`时，Key是无序的。在对`dict`做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用`OrderedDict`：\n```python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n注意，`OrderedDict`的Key会按照插入的顺序排列，不是Key本身排序：\n\n#### Counter\n`Counter`是一个简单的计数器，例如，统计字符出现的个数：\n```python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n```\n`Counter`实际上也是`dict`的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_常用內建模块","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dwi004o7hzgrwog14z4","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"datetime\"><a href=\"#datetime\" class=\"headerlink\" title=\"datetime\"></a>datetime</h3><h4 id=\"获取当前日期和时间\"><a href=\"#获取当前日期和时间\" class=\"headerlink\" title=\"获取当前日期和时间\"></a>获取当前日期和时间</h4><p>datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now() <span class=\"comment\"># 获取当前datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-05</span><span class=\"number\">-18</span> <span class=\"number\">16</span>:<span class=\"number\">28</span>:<span class=\"number\">07.198690</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(now))</div><div class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">datetime</span>.<span class=\"title\">datetime</span>'&gt;</span></div></pre></td></tr></table></figure></p>\n<p>datetime.now()返回当前日期和时间，其类型是datetime。</p>\n<h4 id=\"获取指定日期和时间\"><a href=\"#获取指定日期和时间\" class=\"headerlink\" title=\"获取指定日期和时间\"></a>获取指定日期和时间</h4><p>要指定某个日期和时间，我们直接用参数构造一个datetime：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(dt)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为timestamp\"><a href=\"#datetime转换为timestamp\" class=\"headerlink\" title=\"datetime转换为timestamp\"></a>datetime转换为timestamp</h4><p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt.timestamp() <span class=\"comment\"># 把datetime转换为timestamp</span></div><div class=\"line\"><span class=\"number\">1429417200.0</span></div></pre></td></tr></table></figure></p>\n<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。<br>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.</p>\n<h4 id=\"timestamp转换为datetime\"><a href=\"#timestamp转换为datetime\" class=\"headerlink\" title=\"timestamp转换为datetime\"></a>timestamp转换为datetime</h4><p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = <span class=\"number\">1429417200.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"str转换为datetime\"><a href=\"#str转换为datetime\" class=\"headerlink\" title=\"str转换为datetime\"></a>str转换为datetime</h4><p>转换方法是通过<strong>datetime.strptime()</strong>实现，需要一个日期和时间的格式化字符串：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class=\"string\">'2015-6-1 18:19:59'</span>, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(cday)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-06</span><span class=\"number\">-01</span> <span class=\"number\">18</span>:<span class=\"number\">19</span>:<span class=\"number\">59</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为str\"><a href=\"#datetime转换为str\" class=\"headerlink\" title=\"datetime转换为str\"></a>datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now.strftime(<span class=\"string\">'%a, %b %d %H:%M'</span>))</div><div class=\"line\">Mon, May <span class=\"number\">05</span> <span class=\"number\">16</span>:<span class=\"number\">28</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime加减\"><a href=\"#datetime加减\" class=\"headerlink\" title=\"datetime加减\"></a>datetime加减</h4><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime, timedelta</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(hours=<span class=\"number\">10</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">2</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now - timedelta(days=<span class=\"number\">1</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">17</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(days=<span class=\"number\">2</span>, hours=<span class=\"number\">12</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">21</span>, <span class=\"number\">4</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div></pre></td></tr></table></figure></p>\n<p>使用timedelta你可以很容易地算出前几天和后几天的时刻</p>\n<h3 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h3><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>\n<h4 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h4><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.x</div><div class=\"line\"><span class=\"number\">1</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.y</div><div class=\"line\"><span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list]):</span></div><div class=\"line\">Circle = namedtuple(<span class=\"string\">'Circle'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'r'</span>])</div></pre></td></tr></table></figure></p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。<br><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</div><div class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</div></pre></td></tr></table></figure></p>\n<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>\n<h4 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h4><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></div><div class=\"line\"><span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></div><div class=\"line\"><span class=\"string\">'N/A'</span></div></pre></td></tr></table></figure></p>\n<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h4 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></div><div class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></div><div class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div></pre></td></tr></table></figure></p>\n<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</div><div class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</div><div class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"datetime\"><a href=\"#datetime\" class=\"headerlink\" title=\"datetime\"></a>datetime</h3><h4 id=\"获取当前日期和时间\"><a href=\"#获取当前日期和时间\" class=\"headerlink\" title=\"获取当前日期和时间\"></a>获取当前日期和时间</h4><p>datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now() <span class=\"comment\"># 获取当前datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-05</span><span class=\"number\">-18</span> <span class=\"number\">16</span>:<span class=\"number\">28</span>:<span class=\"number\">07.198690</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(now))</div><div class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">datetime</span>.<span class=\"title\">datetime</span>'&gt;</span></div></pre></td></tr></table></figure></p>\n<p>datetime.now()返回当前日期和时间，其类型是datetime。</p>\n<h4 id=\"获取指定日期和时间\"><a href=\"#获取指定日期和时间\" class=\"headerlink\" title=\"获取指定日期和时间\"></a>获取指定日期和时间</h4><p>要指定某个日期和时间，我们直接用参数构造一个datetime：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(dt)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为timestamp\"><a href=\"#datetime转换为timestamp\" class=\"headerlink\" title=\"datetime转换为timestamp\"></a>datetime转换为timestamp</h4><p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt.timestamp() <span class=\"comment\"># 把datetime转换为timestamp</span></div><div class=\"line\"><span class=\"number\">1429417200.0</span></div></pre></td></tr></table></figure></p>\n<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。<br>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.</p>\n<h4 id=\"timestamp转换为datetime\"><a href=\"#timestamp转换为datetime\" class=\"headerlink\" title=\"timestamp转换为datetime\"></a>timestamp转换为datetime</h4><p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = <span class=\"number\">1429417200.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"str转换为datetime\"><a href=\"#str转换为datetime\" class=\"headerlink\" title=\"str转换为datetime\"></a>str转换为datetime</h4><p>转换方法是通过<strong>datetime.strptime()</strong>实现，需要一个日期和时间的格式化字符串：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class=\"string\">'2015-6-1 18:19:59'</span>, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(cday)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-06</span><span class=\"number\">-01</span> <span class=\"number\">18</span>:<span class=\"number\">19</span>:<span class=\"number\">59</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为str\"><a href=\"#datetime转换为str\" class=\"headerlink\" title=\"datetime转换为str\"></a>datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now.strftime(<span class=\"string\">'%a, %b %d %H:%M'</span>))</div><div class=\"line\">Mon, May <span class=\"number\">05</span> <span class=\"number\">16</span>:<span class=\"number\">28</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime加减\"><a href=\"#datetime加减\" class=\"headerlink\" title=\"datetime加减\"></a>datetime加减</h4><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime, timedelta</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(hours=<span class=\"number\">10</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">2</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now - timedelta(days=<span class=\"number\">1</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">17</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(days=<span class=\"number\">2</span>, hours=<span class=\"number\">12</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">21</span>, <span class=\"number\">4</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div></pre></td></tr></table></figure></p>\n<p>使用timedelta你可以很容易地算出前几天和后几天的时刻</p>\n<h3 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h3><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>\n<h4 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h4><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.x</div><div class=\"line\"><span class=\"number\">1</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.y</div><div class=\"line\"><span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list]):</span></div><div class=\"line\">Circle = namedtuple(<span class=\"string\">'Circle'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'r'</span>])</div></pre></td></tr></table></figure></p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。<br><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</div><div class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</div></pre></td></tr></table></figure></p>\n<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>\n<h4 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h4><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></div><div class=\"line\"><span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></div><div class=\"line\"><span class=\"string\">'N/A'</span></div></pre></td></tr></table></figure></p>\n<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h4 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></div><div class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></div><div class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div></pre></td></tr></table></figure></p>\n<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</div><div class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</div><div class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 模块","date":"2016-08-09T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n\nPython又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。\n请注意，每一个包目录下面都会有一个__init\\_\\_.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init\\_\\_.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块\n\n### 使用模块\n```python\nimport sys\ndef test():\n\tpass\nif __name__=='__main__':\n\ttest()\n```\n导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\nsys模块有一个argv变量，用list存储了**命令行的所有参数**。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。\n在命令行运行该模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n作用域：\n- 正常的函数和变量名是公开的（public），可以被直接引用\n- 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途。\n- 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。\n\n### 安装第三方模块\n使用pip3 install XXX 安装第三方库\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n搜索路径存放在sys模块的path变量中\n```python\nimport sys\nprint(sys.path)\n```\n当要添加自己的搜索目录时可以\n1. 直接修改sys.path:**sys.path.append('/Users/xxx/xxx')**\n2. 设置环境变量PYTHONPATH\n\n\n最后再次感谢廖老师的辛勤劳动。\n","source":"_posts/python_模块.md","raw":"title: python 3.5 模块\ndate: 2016/8/9 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n\nPython又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。\n请注意，每一个包目录下面都会有一个__init\\_\\_.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init\\_\\_.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块\n\n### 使用模块\n```python\nimport sys\ndef test():\n\tpass\nif __name__=='__main__':\n\ttest()\n```\n导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\nsys模块有一个argv变量，用list存储了**命令行的所有参数**。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。\n在命令行运行该模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n作用域：\n- 正常的函数和变量名是公开的（public），可以被直接引用\n- 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途。\n- 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。\n\n### 安装第三方模块\n使用pip3 install XXX 安装第三方库\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n搜索路径存放在sys模块的path变量中\n```python\nimport sys\nprint(sys.path)\n```\n当要添加自己的搜索目录时可以\n1. 直接修改sys.path:**sys.path.append('/Users/xxx/xxx')**\n2. 设置环境变量PYTHONPATH\n\n\n最后再次感谢廖老师的辛勤劳动。\n","slug":"python_模块","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dwo004r7hzgnurkycv6","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。<br>请注意，每一个包目录下面都会有一个<strong>init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</strong>init__.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">\ttest()</div></pre></td></tr></table></figure>\n<p>导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。<br>sys模块有一个argv变量，用list存储了<strong>命令行的所有参数</strong>。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>在命令行运行该模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<p>作用域：</p>\n<ul>\n<li>正常的函数和变量名是公开的（public），可以被直接引用</li>\n<li>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。</li>\n<li>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</li>\n</ul>\n<h3 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h3><p>使用pip3 install XXX 安装第三方库<br>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。<br>搜索路径存放在sys模块的path变量中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">print(sys.path)</div></pre></td></tr></table></figure></p>\n<p>当要添加自己的搜索目录时可以</p>\n<ol>\n<li>直接修改sys.path:<strong>sys.path.append(‘/Users/xxx/xxx’)</strong></li>\n<li>设置环境变量PYTHONPATH</li>\n</ol>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。<br>请注意，每一个包目录下面都会有一个<strong>init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</strong>init__.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">\ttest()</div></pre></td></tr></table></figure>\n<p>导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。<br>sys模块有一个argv变量，用list存储了<strong>命令行的所有参数</strong>。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>在命令行运行该模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<p>作用域：</p>\n<ul>\n<li>正常的函数和变量名是公开的（public），可以被直接引用</li>\n<li>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。</li>\n<li>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</li>\n</ul>\n<h3 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h3><p>使用pip3 install XXX 安装第三方库<br>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。<br>搜索路径存放在sys模块的path变量中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">print(sys.path)</div></pre></td></tr></table></figure></p>\n<p>当要添加自己的搜索目录时可以</p>\n<ol>\n<li>直接修改sys.path:<strong>sys.path.append(‘/Users/xxx/xxx’)</strong></li>\n<li>设置环境变量PYTHONPATH</li>\n</ol>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 正则表达式","date":"2016-08-20T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 基本用法\n- \\d可以匹配一个数字\n- \\w可以匹配一个字母或数字\n- .可以匹配任意字符\n- *表示任意个字符（包括0个）\n- 用+表示至少一个字符\n- 用?表示0个或1个字符\n- 用{n}表示n个字符\n- 用{n,m}表示n-m个字符\n- \\s可以匹配一个空格（也包括Tab等空白符）\n- 要做更精确地匹配，可以用[]表示范围\t\n + [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n- [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n + (P|p)ython可以匹配'Python'或者'python'\n- ^表示行的开头\n- $表示行的结束\n- ^py$就变成了整行匹配,就只能匹配'py'\n\n### re模块\nPython提供re模块，包含所有正则表达式的功能。\nPython的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：\n```python\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\n```\n\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：\n```python\ntest = '用户输入的字符串'\nif re.match(r'正则表达式', test):\n    print('ok')\nelse:\n    print('failed')\n```\n\n### 切分字符串\n```python\n>>> re.split(r'[\\s\\,\\;]+', 'a,b;; c  d')\n['a', 'b', 'c', 'd']\n```\n\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：**^(\\d{3})-(\\d{3,8})$**分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\n```python\n>>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')\n>>> m\n<_sre.SRE_Match object; span=(0, 9), match='010-12345'>\n>>> m.group(0)\n'010-12345'\n>>> m.group(1)\n'010'\n>>> m.group(2)\n'12345'\n```\n注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。\n\n### 贪婪匹配\n正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：\n```python\n>>> re.match(r'^(\\d+)(0*)$', '102300').groups()\n('102300', '')\n```\n由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。\n必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：\n```python\n>>> re.match(r'^(\\d+?)(0*)$', '102300').groups()\n('1023', '00')\n```\n### 编译\n如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：\n```python\n>>> import re\n# 编译:\n>>> re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$')\n# 使用：\n>>> re_telephone.match('010-12345').groups()\n('010', '12345')\n>>> re_telephone.match('010-8086').groups()\n('010', '8086')\n```\n\n\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_正则表达式.md","raw":"title: python 3.5 正则表达式\ndate: 2016/8/20 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 基本用法\n- \\d可以匹配一个数字\n- \\w可以匹配一个字母或数字\n- .可以匹配任意字符\n- *表示任意个字符（包括0个）\n- 用+表示至少一个字符\n- 用?表示0个或1个字符\n- 用{n}表示n个字符\n- 用{n,m}表示n-m个字符\n- \\s可以匹配一个空格（也包括Tab等空白符）\n- 要做更精确地匹配，可以用[]表示范围\t\n + [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n- [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n + (P|p)ython可以匹配'Python'或者'python'\n- ^表示行的开头\n- $表示行的结束\n- ^py$就变成了整行匹配,就只能匹配'py'\n\n### re模块\nPython提供re模块，包含所有正则表达式的功能。\nPython的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：\n```python\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\n```\n\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：\n```python\ntest = '用户输入的字符串'\nif re.match(r'正则表达式', test):\n    print('ok')\nelse:\n    print('failed')\n```\n\n### 切分字符串\n```python\n>>> re.split(r'[\\s\\,\\;]+', 'a,b;; c  d')\n['a', 'b', 'c', 'd']\n```\n\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：**^(\\d{3})-(\\d{3,8})$**分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\n```python\n>>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')\n>>> m\n<_sre.SRE_Match object; span=(0, 9), match='010-12345'>\n>>> m.group(0)\n'010-12345'\n>>> m.group(1)\n'010'\n>>> m.group(2)\n'12345'\n```\n注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。\n\n### 贪婪匹配\n正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：\n```python\n>>> re.match(r'^(\\d+)(0*)$', '102300').groups()\n('102300', '')\n```\n由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。\n必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：\n```python\n>>> re.match(r'^(\\d+?)(0*)$', '102300').groups()\n('1023', '00')\n```\n### 编译\n如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：\n```python\n>>> import re\n# 编译:\n>>> re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$')\n# 使用：\n>>> re_telephone.match('010-12345').groups()\n('010', '12345')\n>>> re_telephone.match('010-8086').groups()\n('010', '8086')\n```\n\n\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_正则表达式","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dwv004v7hzgr3owxhta","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ul>\n<li>\\d可以匹配一个数字</li>\n<li>\\w可以匹配一个字母或数字</li>\n<li>.可以匹配任意字符</li>\n<li>*表示任意个字符（包括0个）</li>\n<li>用+表示至少一个字符</li>\n<li>用?表示0个或1个字符</li>\n<li>用{n}表示n个字符</li>\n<li>用{n,m}表示n-m个字符</li>\n<li>\\s可以匹配一个空格（也包括Tab等空白符）</li>\n<li>要做更精确地匹配，可以用[]表示范围    <ul>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>\n</ul>\n</li>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线<ul>\n<li>(P|p)ython可以匹配’Python’或者’python’</li>\n</ul>\n</li>\n<li>^表示行的开头</li>\n<li>$表示行的结束</li>\n<li>^py$就变成了整行匹配,就只能匹配’py’</li>\n</ul>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python提供re模块，包含所有正则表达式的功能。<br>Python的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = <span class=\"string\">r'ABC\\-001'</span> <span class=\"comment\"># Python的字符串</span></div><div class=\"line\"><span class=\"comment\"># 对应的正则表达式字符串不变：</span></div><div class=\"line\"><span class=\"comment\"># 'ABC\\-001'</span></div></pre></td></tr></table></figure></p>\n<p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"string\">'用户输入的字符串'</span></div><div class=\"line\"><span class=\"keyword\">if</span> re.match(<span class=\"string\">r'正则表达式'</span>, test):</div><div class=\"line\">    print(<span class=\"string\">'ok'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'failed'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"切分字符串\"><a href=\"#切分字符串\" class=\"headerlink\" title=\"切分字符串\"></a>切分字符串</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">r'[\\s\\,\\;]+'</span>, <span class=\"string\">'a,b;; c  d'</span>)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：<strong>^(\\d{3})-(\\d{3,8})$</strong>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = re.match(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>, <span class=\"string\">'010-12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</div><div class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">9</span>), match=<span class=\"string\">'010-12345'</span>&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"string\">'010-12345'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"string\">'010'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"string\">'12345'</span></div></pre></td></tr></table></figure></p>\n<p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p>\n<h3 id=\"贪婪匹配\"><a href=\"#贪婪匹配\" class=\"headerlink\" title=\"贪婪匹配\"></a>贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'102300'</span>, <span class=\"string\">''</span>)</div></pre></td></tr></table></figure></p>\n<p>由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+?)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'1023'</span>, <span class=\"string\">'00'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</div><div class=\"line\"><span class=\"comment\"># 编译:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>)</div><div class=\"line\"><span class=\"comment\"># 使用：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-12345'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-8086'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'8086'</span>)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ul>\n<li>\\d可以匹配一个数字</li>\n<li>\\w可以匹配一个字母或数字</li>\n<li>.可以匹配任意字符</li>\n<li>*表示任意个字符（包括0个）</li>\n<li>用+表示至少一个字符</li>\n<li>用?表示0个或1个字符</li>\n<li>用{n}表示n个字符</li>\n<li>用{n,m}表示n-m个字符</li>\n<li>\\s可以匹配一个空格（也包括Tab等空白符）</li>\n<li>要做更精确地匹配，可以用[]表示范围    <ul>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>\n</ul>\n</li>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线<ul>\n<li>(P|p)ython可以匹配’Python’或者’python’</li>\n</ul>\n</li>\n<li>^表示行的开头</li>\n<li>$表示行的结束</li>\n<li>^py$就变成了整行匹配,就只能匹配’py’</li>\n</ul>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python提供re模块，包含所有正则表达式的功能。<br>Python的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = <span class=\"string\">r'ABC\\-001'</span> <span class=\"comment\"># Python的字符串</span></div><div class=\"line\"><span class=\"comment\"># 对应的正则表达式字符串不变：</span></div><div class=\"line\"><span class=\"comment\"># 'ABC\\-001'</span></div></pre></td></tr></table></figure></p>\n<p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"string\">'用户输入的字符串'</span></div><div class=\"line\"><span class=\"keyword\">if</span> re.match(<span class=\"string\">r'正则表达式'</span>, test):</div><div class=\"line\">    print(<span class=\"string\">'ok'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'failed'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"切分字符串\"><a href=\"#切分字符串\" class=\"headerlink\" title=\"切分字符串\"></a>切分字符串</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">r'[\\s\\,\\;]+'</span>, <span class=\"string\">'a,b;; c  d'</span>)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：<strong>^(\\d{3})-(\\d{3,8})$</strong>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = re.match(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>, <span class=\"string\">'010-12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</div><div class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">9</span>), match=<span class=\"string\">'010-12345'</span>&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"string\">'010-12345'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"string\">'010'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"string\">'12345'</span></div></pre></td></tr></table></figure></p>\n<p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p>\n<h3 id=\"贪婪匹配\"><a href=\"#贪婪匹配\" class=\"headerlink\" title=\"贪婪匹配\"></a>贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'102300'</span>, <span class=\"string\">''</span>)</div></pre></td></tr></table></figure></p>\n<p>由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+?)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'1023'</span>, <span class=\"string\">'00'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</div><div class=\"line\"><span class=\"comment\"># 编译:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>)</div><div class=\"line\"><span class=\"comment\"># 使用：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-12345'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-8086'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'8086'</span>)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 面向对象高级编程","date":"2016-08-10T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 使用__slots__\n我们可以给实例绑定任何属性和方法。\n创建实例：\n```python\nclass Student(object):\n    pass\n```\n\n给实例绑定方法：\n```python\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n**注意：**\n1. 这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 \n2. MethodType()这个方法不要用在给类绑定属性上。\n\n给类绑定方法:\n```python\n>>> def set_score(self, score):\n...     self.score = score\n...\n>>> Student.set_score = set_score\n```\n**注意：**像这样给类绑定方法后，实例变量不用自己传入self了。\n\n如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用__slots__来限制属性。\n```python\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即**__slots__属性并不会被继承**\n\nslots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是__slots__的副作用。\n\n### 使用@property\n类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。\n```python\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n注意：\n1. 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.\n2. 只定义getter方法，不定义setter方法就是一个只读属性。\n\n### 多重继承\npython允许多重继承：\n```python\nclass Dog(Mammal, Runnable):\n    pass\n```\n**如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。**\n\n在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。\n```python\nclass Dog(Mammal, RunnableMixIn, CarnivorousMixIn):\n    pass\n```\n\n感觉MixIn就是个约定啊，并没有太多实质效果啊=。=\n\n### 定制类\n形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。\n\n#### __str__\n怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：\n```python\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n#### __iter__\n如果一个类想被用于**for...in**循环，类似list或tuple那样，就必须实现一个**__iter__()**方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的**__next__()**方法拿到循环的下一个值，直到遇到**StopIteration**错误时退出循环。\n```python\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration();\n        return self.a # 返回下一个值\n\n>>> for n in Fib():\n...     print(n)\n```\n\n#### __getitem__\n要表现得像list那样按照下标取出元素，需要实现__getitem__()方法。__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice:\n```python\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n#### __getattr__\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。\n```python\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\n```\n\n当调用**不存在的属性**时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值.\n\n#### __call__\n任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。\n```python\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n\n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n### 枚举类\nPython提供了Enum类来实现这个功能\n```python\nfrom enum import Enum\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\nfor name, member in Month.__members__.items():\n    print(name, '=>', member, ',', member.value)\n```\n\nvalue属性则是自动赋给成员的int常量，默认从1开始计数。\n如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：\n\n```python\nfrom enum import Enum, unique\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n### 元类\n没看\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_面向对象高级编程.md","raw":"title: python 3.5 面向对象高级编程\ndate: 2016/8/10 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 使用__slots__\n我们可以给实例绑定任何属性和方法。\n创建实例：\n```python\nclass Student(object):\n    pass\n```\n\n给实例绑定方法：\n```python\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n**注意：**\n1. 这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 \n2. MethodType()这个方法不要用在给类绑定属性上。\n\n给类绑定方法:\n```python\n>>> def set_score(self, score):\n...     self.score = score\n...\n>>> Student.set_score = set_score\n```\n**注意：**像这样给类绑定方法后，实例变量不用自己传入self了。\n\n如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用__slots__来限制属性。\n```python\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即**__slots__属性并不会被继承**\n\nslots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是__slots__的副作用。\n\n### 使用@property\n类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。\n```python\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n注意：\n1. 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.\n2. 只定义getter方法，不定义setter方法就是一个只读属性。\n\n### 多重继承\npython允许多重继承：\n```python\nclass Dog(Mammal, Runnable):\n    pass\n```\n**如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。**\n\n在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。\n```python\nclass Dog(Mammal, RunnableMixIn, CarnivorousMixIn):\n    pass\n```\n\n感觉MixIn就是个约定啊，并没有太多实质效果啊=。=\n\n### 定制类\n形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。\n\n#### __str__\n怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：\n```python\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n#### __iter__\n如果一个类想被用于**for...in**循环，类似list或tuple那样，就必须实现一个**__iter__()**方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的**__next__()**方法拿到循环的下一个值，直到遇到**StopIteration**错误时退出循环。\n```python\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration();\n        return self.a # 返回下一个值\n\n>>> for n in Fib():\n...     print(n)\n```\n\n#### __getitem__\n要表现得像list那样按照下标取出元素，需要实现__getitem__()方法。__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice:\n```python\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n#### __getattr__\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。\n```python\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\n```\n\n当调用**不存在的属性**时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值.\n\n#### __call__\n任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。\n```python\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n\n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n### 枚举类\nPython提供了Enum类来实现这个功能\n```python\nfrom enum import Enum\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\nfor name, member in Month.__members__.items():\n    print(name, '=>', member, ',', member.value)\n```\n\nvalue属性则是自动赋给成员的int常量，默认从1开始计数。\n如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：\n\n```python\nfrom enum import Enum, unique\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n### 元类\n没看\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_面向对象高级编程","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dwy004y7hzgwnxqprqs","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"使用slots\"><a href=\"#使用slots\" class=\"headerlink\" title=\"使用slots\"></a>使用<strong>slots</strong></h3><p>我们可以给实例绑定任何属性和方法。<br>创建实例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>给实例绑定方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_age</span><span class=\"params\">(self, age)</span>:</span> <span class=\"comment\"># 定义一个函数作为实例方法</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.age = age</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> types <span class=\"keyword\">import</span> MethodType</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class=\"comment\"># 给实例绑定一个方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age(<span class=\"number\">25</span>) <span class=\"comment\"># 调用实例方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.age <span class=\"comment\"># 测试结果</span></div><div class=\"line\"><span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 </li>\n<li>MethodType()这个方法不要用在给类绑定属性上。</li>\n</ol>\n<p>给类绑定方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(self, score)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.score = score</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>像这样给类绑定方法后，实例变量不用自己传入self了。</p>\n<p>如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用<strong>slots</strong>来限制属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure></p>\n<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即<strong><strong>slots</strong>属性并不会被继承</strong></p>\n<p>slots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是<strong>slots</strong>的副作用。</p>\n<h3 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用@property</h3><p>类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @property</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self._score</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @score.setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self, value)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</div><div class=\"line\">        self._score = value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.</li>\n<li>只定义getter方法，不定义setter方法就是一个只读属性。</li>\n</ol>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>python允许多重继承：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, Runnable)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p><strong>如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。</strong></p>\n<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>感觉MixIn就是个约定啊，并没有太多实质效果啊=。=</p>\n<h3 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h3><p>形如<strong>xxx</strong>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>\n<h4 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a><strong>str</strong></h4><p>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.name = name</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % self.name</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student(<span class=\"string\">'Michael'</span>))</div><div class=\"line\">Student object (name: Michael)</div></pre></td></tr></table></figure></p>\n<h4 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"iter\"></a><strong>iter</strong></h4><p>如果一个类想被用于<strong>for…in</strong>循环，类似list或tuple那样，就必须实现一个<strong><strong>iter</strong>()</strong>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong><strong>next</strong>()</strong>方法拿到循环的下一个值，直到遇到<strong>StopIteration</strong>错误时退出循环。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span> <span class=\"comment\"># 初始化两个计数器a，b</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = self.b, self.a + self.b <span class=\"comment\"># 计算下一个值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.a &gt; <span class=\"number\">100000</span>: <span class=\"comment\"># 退出循环的条件</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> StopIteration();</div><div class=\"line\">        <span class=\"keyword\">return</span> self.a <span class=\"comment\"># 返回下一个值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib():</div><div class=\"line\"><span class=\"meta\">... </span>    print(n)</div></pre></td></tr></table></figure></p>\n<h4 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"getitem\"></a><strong>getitem</strong></h4><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int): <span class=\"comment\"># n是索引</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> a</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice): <span class=\"comment\"># n是切片</span></div><div class=\"line\">            start = n.start</div><div class=\"line\">            stop = n.stop</div><div class=\"line\">            <span class=\"keyword\">if</span> start <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">                start = <span class=\"number\">0</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            L = []</div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(stop):</div><div class=\"line\">                <span class=\"keyword\">if</span> x &gt;= start:</div><div class=\"line\">                    L.append(a)</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr\"></a><strong>getattr</strong></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.name = <span class=\"string\">'Michael'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, attr)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></div></pre></td></tr></table></figure></p>\n<p>当调用<strong>不存在的属性</strong>时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a><strong>call</strong></h4><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % self.name)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"string\">'Michael'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s() <span class=\"comment\"># self参数不要传入</span></div><div class=\"line\">My name <span class=\"keyword\">is</span> Michael.</div></pre></td></tr></table></figure></p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><p>Python提供了Enum类来实现这个功能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum</div><div class=\"line\">Month = Enum(<span class=\"string\">'Month'</span>, (<span class=\"string\">'Jan'</span>, <span class=\"string\">'Feb'</span>, <span class=\"string\">'Mar'</span>, <span class=\"string\">'Apr'</span>, <span class=\"string\">'May'</span>, <span class=\"string\">'Jun'</span>, <span class=\"string\">'Jul'</span>, <span class=\"string\">'Aug'</span>, <span class=\"string\">'Sep'</span>, <span class=\"string\">'Oct'</span>, <span class=\"string\">'Nov'</span>, <span class=\"string\">'Dec'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> name, member <span class=\"keyword\">in</span> Month.__members__.items():</div><div class=\"line\">    print(name, <span class=\"string\">'=&gt;'</span>, member, <span class=\"string\">','</span>, member.value)</div></pre></td></tr></table></figure></p>\n<p>value属性则是自动赋给成员的int常量，默认从1开始计数。<br>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum, unique</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Weekday</span><span class=\"params\">(Enum)</span>:</span></div><div class=\"line\">    Sun = <span class=\"number\">0</span> <span class=\"comment\"># Sun的value被设定为0</span></div><div class=\"line\">    Mon = <span class=\"number\">1</span></div><div class=\"line\">    Tue = <span class=\"number\">2</span></div><div class=\"line\">    Wed = <span class=\"number\">3</span></div><div class=\"line\">    Thu = <span class=\"number\">4</span></div><div class=\"line\">    Fri = <span class=\"number\">5</span></div><div class=\"line\">    Sat = <span class=\"number\">6</span></div></pre></td></tr></table></figure>\n<h3 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h3><p>没看</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"使用slots\"><a href=\"#使用slots\" class=\"headerlink\" title=\"使用slots\"></a>使用<strong>slots</strong></h3><p>我们可以给实例绑定任何属性和方法。<br>创建实例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>给实例绑定方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_age</span><span class=\"params\">(self, age)</span>:</span> <span class=\"comment\"># 定义一个函数作为实例方法</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.age = age</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> types <span class=\"keyword\">import</span> MethodType</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class=\"comment\"># 给实例绑定一个方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age(<span class=\"number\">25</span>) <span class=\"comment\"># 调用实例方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.age <span class=\"comment\"># 测试结果</span></div><div class=\"line\"><span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 </li>\n<li>MethodType()这个方法不要用在给类绑定属性上。</li>\n</ol>\n<p>给类绑定方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(self, score)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.score = score</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>像这样给类绑定方法后，实例变量不用自己传入self了。</p>\n<p>如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用<strong>slots</strong>来限制属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure></p>\n<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即<strong><strong>slots</strong>属性并不会被继承</strong></p>\n<p>slots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是<strong>slots</strong>的副作用。</p>\n<h3 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用@property</h3><p>类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @property</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self._score</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @score.setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self, value)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</div><div class=\"line\">        self._score = value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.</li>\n<li>只定义getter方法，不定义setter方法就是一个只读属性。</li>\n</ol>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>python允许多重继承：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, Runnable)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p><strong>如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。</strong></p>\n<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>感觉MixIn就是个约定啊，并没有太多实质效果啊=。=</p>\n<h3 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h3><p>形如<strong>xxx</strong>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>\n<h4 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a><strong>str</strong></h4><p>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.name = name</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % self.name</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student(<span class=\"string\">'Michael'</span>))</div><div class=\"line\">Student object (name: Michael)</div></pre></td></tr></table></figure></p>\n<h4 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"iter\"></a><strong>iter</strong></h4><p>如果一个类想被用于<strong>for…in</strong>循环，类似list或tuple那样，就必须实现一个<strong><strong>iter</strong>()</strong>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong><strong>next</strong>()</strong>方法拿到循环的下一个值，直到遇到<strong>StopIteration</strong>错误时退出循环。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span> <span class=\"comment\"># 初始化两个计数器a，b</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = self.b, self.a + self.b <span class=\"comment\"># 计算下一个值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.a &gt; <span class=\"number\">100000</span>: <span class=\"comment\"># 退出循环的条件</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> StopIteration();</div><div class=\"line\">        <span class=\"keyword\">return</span> self.a <span class=\"comment\"># 返回下一个值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib():</div><div class=\"line\"><span class=\"meta\">... </span>    print(n)</div></pre></td></tr></table></figure></p>\n<h4 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"getitem\"></a><strong>getitem</strong></h4><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int): <span class=\"comment\"># n是索引</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> a</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice): <span class=\"comment\"># n是切片</span></div><div class=\"line\">            start = n.start</div><div class=\"line\">            stop = n.stop</div><div class=\"line\">            <span class=\"keyword\">if</span> start <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">                start = <span class=\"number\">0</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            L = []</div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(stop):</div><div class=\"line\">                <span class=\"keyword\">if</span> x &gt;= start:</div><div class=\"line\">                    L.append(a)</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr\"></a><strong>getattr</strong></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.name = <span class=\"string\">'Michael'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, attr)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></div></pre></td></tr></table></figure></p>\n<p>当调用<strong>不存在的属性</strong>时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a><strong>call</strong></h4><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % self.name)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"string\">'Michael'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s() <span class=\"comment\"># self参数不要传入</span></div><div class=\"line\">My name <span class=\"keyword\">is</span> Michael.</div></pre></td></tr></table></figure></p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><p>Python提供了Enum类来实现这个功能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum</div><div class=\"line\">Month = Enum(<span class=\"string\">'Month'</span>, (<span class=\"string\">'Jan'</span>, <span class=\"string\">'Feb'</span>, <span class=\"string\">'Mar'</span>, <span class=\"string\">'Apr'</span>, <span class=\"string\">'May'</span>, <span class=\"string\">'Jun'</span>, <span class=\"string\">'Jul'</span>, <span class=\"string\">'Aug'</span>, <span class=\"string\">'Sep'</span>, <span class=\"string\">'Oct'</span>, <span class=\"string\">'Nov'</span>, <span class=\"string\">'Dec'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> name, member <span class=\"keyword\">in</span> Month.__members__.items():</div><div class=\"line\">    print(name, <span class=\"string\">'=&gt;'</span>, member, <span class=\"string\">','</span>, member.value)</div></pre></td></tr></table></figure></p>\n<p>value属性则是自动赋给成员的int常量，默认从1开始计数。<br>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum, unique</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Weekday</span><span class=\"params\">(Enum)</span>:</span></div><div class=\"line\">    Sun = <span class=\"number\">0</span> <span class=\"comment\"># Sun的value被设定为0</span></div><div class=\"line\">    Mon = <span class=\"number\">1</span></div><div class=\"line\">    Tue = <span class=\"number\">2</span></div><div class=\"line\">    Wed = <span class=\"number\">3</span></div><div class=\"line\">    Thu = <span class=\"number\">4</span></div><div class=\"line\">    Fri = <span class=\"number\">5</span></div><div class=\"line\">    Sat = <span class=\"number\">6</span></div></pre></td></tr></table></figure>\n<h3 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h3><p>没看</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 进程与线程","date":"2016-08-18T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 多进程\n#### multiprocessing\nmultiprocessing模块就是跨平台版本的多进程模块。\nmultiprocessing模块提供了一个Process类来代表一个进程对象\n```python\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid()))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    print('Child process will start.')\n    p.start()\n    p.join()\n    print('Child process end.')\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n#### pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    p.join()\n    print('All subprocesses done.')\n```\n结果如下：\n```python\nParent process 669.\nWaiting for all subprocesses done...\nRun task 0 (671)...\nRun task 1 (672)...\nRun task 2 (673)...\nRun task 3 (674)...\nTask 2 runs 0.14 seconds.\nRun task 4 (673)...\nTask 1 runs 0.27 seconds.\nTask 3 runs 0.86 seconds.\nTask 0 runs 1.41 seconds.\nTask 4 runs 1.91 seconds.\nAll subprocesses done.\n```\n\n对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。\n注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：`p = ool(5)`就可以同时跑5个进程。\n\n#### 子进程&进程间通信\n到时候再看\n\n### 多线程\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```python\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while n < 5:\n        n = n + 1\n        print('thread %s >>> %s' % (threading.current_thread().name, n))\n        time.sleep(1)\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n```\n执行结果如下:\n\n```python\nthread MainThread is running...\nthread LoopThread is running...\nthread LoopThread >>> 1\nthread LoopThread >>> 2\nthread LoopThread >>> 3\nthread LoopThread >>> 4\nthread LoopThread >>> 5\nthread LoopThread ended.\nthread MainThread ended.\n```\n任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2\n\n#### Lock\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n```python\nbalance = 0\nlock = threading.Lock()\n\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n```\n创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try...finally来确保锁一定会被释放。\n\n\n### ThreadLocal\n一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。\n```python\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    print('Hello, %s (in %s)' % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n执行结果：\n\n```python\nHello, Alice (in Thread-A)\nHello, Bob (in Thread-B)\n```\n\n全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。\n\n可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。\n\nThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 分布式进程\n用到再看\n","source":"_posts/python_进程与线程.md","raw":"title: python 3.5 进程与线程\ndate: 2016/8/18 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 多进程\n#### multiprocessing\nmultiprocessing模块就是跨平台版本的多进程模块。\nmultiprocessing模块提供了一个Process类来代表一个进程对象\n```python\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid()))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    print('Child process will start.')\n    p.start()\n    p.join()\n    print('Child process end.')\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n#### pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    p.join()\n    print('All subprocesses done.')\n```\n结果如下：\n```python\nParent process 669.\nWaiting for all subprocesses done...\nRun task 0 (671)...\nRun task 1 (672)...\nRun task 2 (673)...\nRun task 3 (674)...\nTask 2 runs 0.14 seconds.\nRun task 4 (673)...\nTask 1 runs 0.27 seconds.\nTask 3 runs 0.86 seconds.\nTask 0 runs 1.41 seconds.\nTask 4 runs 1.91 seconds.\nAll subprocesses done.\n```\n\n对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。\n注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：`p = ool(5)`就可以同时跑5个进程。\n\n#### 子进程&进程间通信\n到时候再看\n\n### 多线程\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```python\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while n < 5:\n        n = n + 1\n        print('thread %s >>> %s' % (threading.current_thread().name, n))\n        time.sleep(1)\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n```\n执行结果如下:\n\n```python\nthread MainThread is running...\nthread LoopThread is running...\nthread LoopThread >>> 1\nthread LoopThread >>> 2\nthread LoopThread >>> 3\nthread LoopThread >>> 4\nthread LoopThread >>> 5\nthread LoopThread ended.\nthread MainThread ended.\n```\n任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2\n\n#### Lock\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n```python\nbalance = 0\nlock = threading.Lock()\n\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n```\n创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try...finally来确保锁一定会被释放。\n\n\n### ThreadLocal\n一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。\n```python\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    print('Hello, %s (in %s)' % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n执行结果：\n\n```python\nHello, Alice (in Thread-A)\nHello, Bob (in Thread-B)\n```\n\n全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。\n\n可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。\n\nThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 分布式进程\n用到再看\n","slug":"python_进程与线程","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dx100517hzgyzzbzl9u","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h4><p>multiprocessing模块就是跨平台版本的多进程模块。<br>multiprocessing模块提供了一个Process类来代表一个进程对象<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 子进程要执行的代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</div><div class=\"line\">    print(<span class=\"string\">'Child process will start.'</span>)</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'Child process end.'</span>)</div></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<h4 id=\"pool\"><a href=\"#pool\" class=\"headerlink\" title=\"pool\"></a>pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">import</span> os, time, random</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\">    start = time.time()</div><div class=\"line\">    time.sleep(random.random() * <span class=\"number\">3</span>)</div><div class=\"line\">    end = time.time()</div><div class=\"line\">    print(<span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Pool(<span class=\"number\">4</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</div><div class=\"line\">        p.apply_async(long_time_task, args=(i,))</div><div class=\"line\">    print(<span class=\"string\">'Waiting for all subprocesses done...'</span>)</div><div class=\"line\">    p.close()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Parent process <span class=\"number\">669.</span></div><div class=\"line\">Waiting <span class=\"keyword\">for</span> all subprocesses done...</div><div class=\"line\">Run task <span class=\"number\">0</span> (<span class=\"number\">671</span>)...</div><div class=\"line\">Run task <span class=\"number\">1</span> (<span class=\"number\">672</span>)...</div><div class=\"line\">Run task <span class=\"number\">2</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Run task <span class=\"number\">3</span> (<span class=\"number\">674</span>)...</div><div class=\"line\">Task <span class=\"number\">2</span> runs <span class=\"number\">0.14</span> seconds.</div><div class=\"line\">Run task <span class=\"number\">4</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Task <span class=\"number\">1</span> runs <span class=\"number\">0.27</span> seconds.</div><div class=\"line\">Task <span class=\"number\">3</span> runs <span class=\"number\">0.86</span> seconds.</div><div class=\"line\">Task <span class=\"number\">0</span> runs <span class=\"number\">1.41</span> seconds.</div><div class=\"line\">Task <span class=\"number\">4</span> runs <span class=\"number\">1.91</span> seconds.</div><div class=\"line\">All subprocesses done.</div></pre></td></tr></table></figure></p>\n<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = ool(5)</code>就可以同时跑5个进程。</p>\n<h4 id=\"子进程-amp-进程间通信\"><a href=\"#子进程-amp-进程间通信\" class=\"headerlink\" title=\"子进程&amp;进程间通信\"></a>子进程&amp;进程间通信</h4><p>到时候再看</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time, threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 新线程执行的代码:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">    n = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class=\"line\">        time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\">    print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">t = threading.Thread(target=loop, name=<span class=\"string\">'LoopThread'</span>)</div><div class=\"line\">t.start()</div><div class=\"line\">t.join()</div><div class=\"line\">print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure></p>\n<p>执行结果如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread MainThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">1</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">2</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">3</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">4</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">5</span></div><div class=\"line\">thread LoopThread ended.</div><div class=\"line\">thread MainThread ended.</div></pre></td></tr></table></figure>\n<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">balance = <span class=\"number\">0</span></div><div class=\"line\">lock = threading.Lock()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100000</span>):</div><div class=\"line\">        <span class=\"comment\"># 先要获取锁:</span></div><div class=\"line\">        lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># 放心地改吧:</span></div><div class=\"line\">            change_it(n)</div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># 改完了一定要释放锁:</span></div><div class=\"line\">            lock.release()</div></pre></td></tr></table></figure></p>\n<p>创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></div><div class=\"line\">local_school = threading.local()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 获取当前线程关联的student:</span></div><div class=\"line\">    std = local_school.student</div><div class=\"line\">    print(<span class=\"string\">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></div><div class=\"line\">    local_school.student = name</div><div class=\"line\">    process_student()</div><div class=\"line\"></div><div class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</div><div class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</div><div class=\"line\">t1.start()</div><div class=\"line\">t2.start()</div><div class=\"line\">t1.join()</div><div class=\"line\">t2.join()</div></pre></td></tr></table></figure></p>\n<p>执行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello, Alice (<span class=\"keyword\">in</span> Thread-A)</div><div class=\"line\">Hello, Bob (<span class=\"keyword\">in</span> Thread-B)</div></pre></td></tr></table></figure>\n<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>\n<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>\n<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>用到再看</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h4><p>multiprocessing模块就是跨平台版本的多进程模块。<br>multiprocessing模块提供了一个Process类来代表一个进程对象<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 子进程要执行的代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</div><div class=\"line\">    print(<span class=\"string\">'Child process will start.'</span>)</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'Child process end.'</span>)</div></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<h4 id=\"pool\"><a href=\"#pool\" class=\"headerlink\" title=\"pool\"></a>pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">import</span> os, time, random</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\">    start = time.time()</div><div class=\"line\">    time.sleep(random.random() * <span class=\"number\">3</span>)</div><div class=\"line\">    end = time.time()</div><div class=\"line\">    print(<span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Pool(<span class=\"number\">4</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</div><div class=\"line\">        p.apply_async(long_time_task, args=(i,))</div><div class=\"line\">    print(<span class=\"string\">'Waiting for all subprocesses done...'</span>)</div><div class=\"line\">    p.close()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Parent process <span class=\"number\">669.</span></div><div class=\"line\">Waiting <span class=\"keyword\">for</span> all subprocesses done...</div><div class=\"line\">Run task <span class=\"number\">0</span> (<span class=\"number\">671</span>)...</div><div class=\"line\">Run task <span class=\"number\">1</span> (<span class=\"number\">672</span>)...</div><div class=\"line\">Run task <span class=\"number\">2</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Run task <span class=\"number\">3</span> (<span class=\"number\">674</span>)...</div><div class=\"line\">Task <span class=\"number\">2</span> runs <span class=\"number\">0.14</span> seconds.</div><div class=\"line\">Run task <span class=\"number\">4</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Task <span class=\"number\">1</span> runs <span class=\"number\">0.27</span> seconds.</div><div class=\"line\">Task <span class=\"number\">3</span> runs <span class=\"number\">0.86</span> seconds.</div><div class=\"line\">Task <span class=\"number\">0</span> runs <span class=\"number\">1.41</span> seconds.</div><div class=\"line\">Task <span class=\"number\">4</span> runs <span class=\"number\">1.91</span> seconds.</div><div class=\"line\">All subprocesses done.</div></pre></td></tr></table></figure></p>\n<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = ool(5)</code>就可以同时跑5个进程。</p>\n<h4 id=\"子进程-amp-进程间通信\"><a href=\"#子进程-amp-进程间通信\" class=\"headerlink\" title=\"子进程&amp;进程间通信\"></a>子进程&amp;进程间通信</h4><p>到时候再看</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time, threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 新线程执行的代码:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">    n = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class=\"line\">        time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\">    print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">t = threading.Thread(target=loop, name=<span class=\"string\">'LoopThread'</span>)</div><div class=\"line\">t.start()</div><div class=\"line\">t.join()</div><div class=\"line\">print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure></p>\n<p>执行结果如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread MainThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">1</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">2</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">3</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">4</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">5</span></div><div class=\"line\">thread LoopThread ended.</div><div class=\"line\">thread MainThread ended.</div></pre></td></tr></table></figure>\n<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">balance = <span class=\"number\">0</span></div><div class=\"line\">lock = threading.Lock()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100000</span>):</div><div class=\"line\">        <span class=\"comment\"># 先要获取锁:</span></div><div class=\"line\">        lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># 放心地改吧:</span></div><div class=\"line\">            change_it(n)</div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># 改完了一定要释放锁:</span></div><div class=\"line\">            lock.release()</div></pre></td></tr></table></figure></p>\n<p>创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></div><div class=\"line\">local_school = threading.local()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 获取当前线程关联的student:</span></div><div class=\"line\">    std = local_school.student</div><div class=\"line\">    print(<span class=\"string\">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></div><div class=\"line\">    local_school.student = name</div><div class=\"line\">    process_student()</div><div class=\"line\"></div><div class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</div><div class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</div><div class=\"line\">t1.start()</div><div class=\"line\">t2.start()</div><div class=\"line\">t1.join()</div><div class=\"line\">t2.join()</div></pre></td></tr></table></figure></p>\n<p>执行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello, Alice (<span class=\"keyword\">in</span> Thread-A)</div><div class=\"line\">Hello, Bob (<span class=\"keyword\">in</span> Thread-B)</div></pre></td></tr></table></figure>\n<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>\n<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>\n<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>用到再看</p>"},{"title":"python 3.5 面向对象编程","date":"2016-08-09T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 类和实例\n定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。\n```python\nclass Student(object)\n\tpass\n```\n\n定义好类，就可以创建出实例了。\n```python\nbart = Student()\n```\n\n可以**自由地给一个实例变量绑定属性**，比如，给实例bart绑定一个name属性：\n```python\nbart.name = 'Zachary'\n```\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。\n\n创建实例的时候可以使用特殊的**__init__**方法初始化：\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n```\n注意：\n1. 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n2. 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。\n\n另外：\n1. 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n2. 如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。\n\n### 访问限制\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。\n\noc中使用.h和.m定义属性的方式区分共有私有。\nJava中通过public，private的方式区分共有私有。\npython通过__的方式区分共有私有。\n\n以_开头的变量表示：可以访问，但是最好视为私有变量。\n\n### 继承和多态\n继承和多态和其他语言没什么不同，就不重复了。\n\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了\n\n### 获取对象信息\n#### type\n使用type()函数,判断对象类型\n```python\n>>> import types\n>>> def fn():\n...     pass\n...\n>>> type(fn)==types.FunctionType\nTrue\n>>> type(abs)==types.BuiltinFunctionType\nTrue\n>>> type(lambda x: x)==types.LambdaType\nTrue\n>>> type((x for x in range(10)))==types.GeneratorType\nTrue\n```\n\n#### isinstance()\n使用isinstance()函数,判断class的继承关系\n判断基本类型：\n```python\n>>> isinstance('a', str)\nTrue\n>>> isinstance(123, int)\nTrue\n>>> isinstance(b'a', bytes)\nTrue\n```\n判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：\n```python\n>>> isinstance([1, 2, 3], (list, tuple))\nTrue\n>>> isinstance((1, 2, 3), (list, tuple))\nTrue\n```\n\n#### dir()\n如果要获得一个对象的**所有属性和方法**，可以使用dir()函数，它返回一个包含字符串的list.\n\n仅仅把属性和方法列出来是不够的，配合**getattr()**、**setattr()**以及**hasattr()**，我们可以直接**操作一个对象的状态**：\n```python\n>>> class MyObject(object):\n...     def __init__(self):\n...         self.x = 9\n...     def power(self):\n...         return self.x * self.x\n...\n>>> obj = MyObject()\n```\n紧接着，可以测试该对象的属性：\n```python\n>>> hasattr(obj, 'x') # 有属性'x'吗？\nTrue\n>>> obj.x\n9\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nFalse\n>>> setattr(obj, 'y', 19) # 设置一个属性'y'\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nTrue\n>>> getattr(obj, 'y') # 获取属性'y'\n19\n>>> obj.y # 获取属性'y'\n19\n```\n如果试图获取不存在的属性，会抛出AttributeError的错误\n可以传入一个default参数，如果属性不存在，就返回默认值：\n```python\n>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404\n404\n```\n\n也可以获得对象的方法：\n```python\n>>> hasattr(obj, 'power') # 有属性'power'吗？\nTrue\n>>> getattr(obj, 'power') # 获取属性'power'\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn\n>>> fn # fn指向obj.power\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn() # 调用fn()与调用obj.power()是一样的\n81\n```\n\n**感觉上，用set，get，has方法和直接设置没什么太大区别。**\n\n### 实例属性和类属性\npython中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：\n```python\n>>> class Student(object):\n...     name = 'Student'\n...\n>>> s = Student() # 创建实例s\n>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性\nStudent\n>>> print(Student.name) # 打印类的name属性\nStudent\n>>> s.name = 'Michael' # 给实例绑定name属性\n>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性\nMichael\n>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问\nStudent\n>>> del s.name # 如果删除实例的name属性\n>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了\nStudent\n```\n在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_面向对象编程.md","raw":"title: python 3.5 面向对象编程\ndate: 2016/8/9 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 类和实例\n定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。\n```python\nclass Student(object)\n\tpass\n```\n\n定义好类，就可以创建出实例了。\n```python\nbart = Student()\n```\n\n可以**自由地给一个实例变量绑定属性**，比如，给实例bart绑定一个name属性：\n```python\nbart.name = 'Zachary'\n```\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。\n\n创建实例的时候可以使用特殊的**__init__**方法初始化：\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n```\n注意：\n1. 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n2. 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。\n\n另外：\n1. 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n2. 如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。\n\n### 访问限制\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。\n\noc中使用.h和.m定义属性的方式区分共有私有。\nJava中通过public，private的方式区分共有私有。\npython通过__的方式区分共有私有。\n\n以_开头的变量表示：可以访问，但是最好视为私有变量。\n\n### 继承和多态\n继承和多态和其他语言没什么不同，就不重复了。\n\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了\n\n### 获取对象信息\n#### type\n使用type()函数,判断对象类型\n```python\n>>> import types\n>>> def fn():\n...     pass\n...\n>>> type(fn)==types.FunctionType\nTrue\n>>> type(abs)==types.BuiltinFunctionType\nTrue\n>>> type(lambda x: x)==types.LambdaType\nTrue\n>>> type((x for x in range(10)))==types.GeneratorType\nTrue\n```\n\n#### isinstance()\n使用isinstance()函数,判断class的继承关系\n判断基本类型：\n```python\n>>> isinstance('a', str)\nTrue\n>>> isinstance(123, int)\nTrue\n>>> isinstance(b'a', bytes)\nTrue\n```\n判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：\n```python\n>>> isinstance([1, 2, 3], (list, tuple))\nTrue\n>>> isinstance((1, 2, 3), (list, tuple))\nTrue\n```\n\n#### dir()\n如果要获得一个对象的**所有属性和方法**，可以使用dir()函数，它返回一个包含字符串的list.\n\n仅仅把属性和方法列出来是不够的，配合**getattr()**、**setattr()**以及**hasattr()**，我们可以直接**操作一个对象的状态**：\n```python\n>>> class MyObject(object):\n...     def __init__(self):\n...         self.x = 9\n...     def power(self):\n...         return self.x * self.x\n...\n>>> obj = MyObject()\n```\n紧接着，可以测试该对象的属性：\n```python\n>>> hasattr(obj, 'x') # 有属性'x'吗？\nTrue\n>>> obj.x\n9\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nFalse\n>>> setattr(obj, 'y', 19) # 设置一个属性'y'\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nTrue\n>>> getattr(obj, 'y') # 获取属性'y'\n19\n>>> obj.y # 获取属性'y'\n19\n```\n如果试图获取不存在的属性，会抛出AttributeError的错误\n可以传入一个default参数，如果属性不存在，就返回默认值：\n```python\n>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404\n404\n```\n\n也可以获得对象的方法：\n```python\n>>> hasattr(obj, 'power') # 有属性'power'吗？\nTrue\n>>> getattr(obj, 'power') # 获取属性'power'\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn\n>>> fn # fn指向obj.power\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn() # 调用fn()与调用obj.power()是一样的\n81\n```\n\n**感觉上，用set，get，has方法和直接设置没什么太大区别。**\n\n### 实例属性和类属性\npython中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：\n```python\n>>> class Student(object):\n...     name = 'Student'\n...\n>>> s = Student() # 创建实例s\n>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性\nStudent\n>>> print(Student.name) # 打印类的name属性\nStudent\n>>> s.name = 'Michael' # 给实例绑定name属性\n>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性\nMichael\n>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问\nStudent\n>>> del s.name # 如果删除实例的name属性\n>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了\nStudent\n```\n在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_面向对象编程","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dx400547hzg4o1lugvr","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h3><p>定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Student(object)</div><div class=\"line\">\tpass</div></pre></td></tr></table></figure></p>\n<p>定义好类，就可以创建出实例了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart = Student()</div></pre></td></tr></table></figure></p>\n<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart.name = <span class=\"string\">'Zachary'</span></div></pre></td></tr></table></figure></p>\n<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>\n<p>创建实例的时候可以使用特殊的<strong><strong>init</strong></strong>方法初始化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, score)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\">        self.score = score</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</li>\n<li>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</li>\n</ol>\n<p>另外：</p>\n<ol>\n<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</li>\n<li>如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。</li>\n</ol>\n<h3 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>\n<p>oc中使用.h和.m定义属性的方式区分共有私有。<br>Java中通过public，private的方式区分共有私有。<br>python通过__的方式区分共有私有。</p>\n<p>以_开头的变量表示：可以访问，但是最好视为私有变量。</p>\n<h3 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h3><p>继承和多态和其他语言没什么不同，就不重复了。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</p>\n<h3 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>使用type()函数,判断对象类型<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> types</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">()</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">pass</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(<span class=\"keyword\">lambda</span> x: x)==types.LambdaType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)))==types.GeneratorType</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h4><p>使用isinstance()函数,判断class的继承关系<br>判断基本类型：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">'a'</span>, str)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"number\">123</span>, int)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">b'a'</span>, bytes)</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<p>判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance((<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h4><p>如果要获得一个对象的<strong>所有属性和方法</strong>，可以使用dir()函数，它返回一个包含字符串的list.</p>\n<p>仅仅把属性和方法列出来是不够的，配合<strong>getattr()</strong>、<strong>setattr()</strong>以及<strong>hasattr()</strong>，我们可以直接<strong>操作一个对象的状态</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.x = <span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> self.x * self.x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure></p>\n<p>紧接着，可以测试该对象的属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'x'</span>) <span class=\"comment\"># 有属性'x'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.x</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">False</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>) <span class=\"comment\"># 设置一个属性'y'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.y <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div></pre></td></tr></table></figure></p>\n<p>如果试图获取不存在的属性，会抛出AttributeError的错误<br>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'z'</span>, <span class=\"number\">404</span>) <span class=\"comment\"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class=\"line\"><span class=\"number\">404</span></div></pre></td></tr></table></figure></p>\n<p>也可以获得对象的方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 有属性'power'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn = getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'并赋值到变量fn</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn <span class=\"comment\"># fn指向obj.power</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn() <span class=\"comment\"># 调用fn()与调用obj.power()是一样的</span></div><div class=\"line\"><span class=\"number\">81</span></div></pre></td></tr></table></figure></p>\n<p><strong>感觉上，用set，get，has方法和直接设置没什么太大区别。</strong></p>\n<h3 id=\"实例属性和类属性\"><a href=\"#实例属性和类属性\" class=\"headerlink\" title=\"实例属性和类属性\"></a>实例属性和类属性</h3><p>python中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    name = <span class=\"string\">'Student'</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student() <span class=\"comment\"># 创建实例s</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 打印类的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.name = <span class=\"string\">'Michael'</span> <span class=\"comment\"># 给实例绑定name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class=\"line\">Michael</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">del</span> s.name <span class=\"comment\"># 如果删除实例的name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class=\"line\">Student</div></pre></td></tr></table></figure></p>\n<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h3><p>定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Student(object)</div><div class=\"line\">\tpass</div></pre></td></tr></table></figure></p>\n<p>定义好类，就可以创建出实例了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart = Student()</div></pre></td></tr></table></figure></p>\n<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart.name = <span class=\"string\">'Zachary'</span></div></pre></td></tr></table></figure></p>\n<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>\n<p>创建实例的时候可以使用特殊的<strong><strong>init</strong></strong>方法初始化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, score)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\">        self.score = score</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</li>\n<li>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</li>\n</ol>\n<p>另外：</p>\n<ol>\n<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</li>\n<li>如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。</li>\n</ol>\n<h3 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>\n<p>oc中使用.h和.m定义属性的方式区分共有私有。<br>Java中通过public，private的方式区分共有私有。<br>python通过__的方式区分共有私有。</p>\n<p>以_开头的变量表示：可以访问，但是最好视为私有变量。</p>\n<h3 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h3><p>继承和多态和其他语言没什么不同，就不重复了。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</p>\n<h3 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>使用type()函数,判断对象类型<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> types</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">()</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">pass</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(<span class=\"keyword\">lambda</span> x: x)==types.LambdaType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)))==types.GeneratorType</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h4><p>使用isinstance()函数,判断class的继承关系<br>判断基本类型：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">'a'</span>, str)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"number\">123</span>, int)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">b'a'</span>, bytes)</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<p>判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance((<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h4><p>如果要获得一个对象的<strong>所有属性和方法</strong>，可以使用dir()函数，它返回一个包含字符串的list.</p>\n<p>仅仅把属性和方法列出来是不够的，配合<strong>getattr()</strong>、<strong>setattr()</strong>以及<strong>hasattr()</strong>，我们可以直接<strong>操作一个对象的状态</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.x = <span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> self.x * self.x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure></p>\n<p>紧接着，可以测试该对象的属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'x'</span>) <span class=\"comment\"># 有属性'x'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.x</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">False</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>) <span class=\"comment\"># 设置一个属性'y'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.y <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div></pre></td></tr></table></figure></p>\n<p>如果试图获取不存在的属性，会抛出AttributeError的错误<br>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'z'</span>, <span class=\"number\">404</span>) <span class=\"comment\"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class=\"line\"><span class=\"number\">404</span></div></pre></td></tr></table></figure></p>\n<p>也可以获得对象的方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 有属性'power'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn = getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'并赋值到变量fn</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn <span class=\"comment\"># fn指向obj.power</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn() <span class=\"comment\"># 调用fn()与调用obj.power()是一样的</span></div><div class=\"line\"><span class=\"number\">81</span></div></pre></td></tr></table></figure></p>\n<p><strong>感觉上，用set，get，has方法和直接设置没什么太大区别。</strong></p>\n<h3 id=\"实例属性和类属性\"><a href=\"#实例属性和类属性\" class=\"headerlink\" title=\"实例属性和类属性\"></a>实例属性和类属性</h3><p>python中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    name = <span class=\"string\">'Student'</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student() <span class=\"comment\"># 创建实例s</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 打印类的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.name = <span class=\"string\">'Michael'</span> <span class=\"comment\"># 给实例绑定name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class=\"line\">Michael</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">del</span> s.name <span class=\"comment\"># 如果删除实例的name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class=\"line\">Student</div></pre></td></tr></table></figure></p>\n<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 高级特性","date":"2016-08-08T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n### 切片\n切片（Slice）操作符用来简化经常取指定索引范围的操作\n```python\n>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n>>> L[0:3]\n['Michael', 'Sarah', 'Tracy']\n```\n从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.\n\n各种用法示例：\n```python\n# Python支持L[-1]取倒数第一个元素,同样支持倒数切片\n>>> L[-2:]\n['Bob', 'Jack']\n>>> L[-2:-1]\n['Bob']\n\n# 前10个数，每两个取一个：\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n\n# 所有数，每5个取一个：\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n# 什么都不写，只写[:]就可以原样复制一个list\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n\n# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n\n#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n### 迭代\n我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。\n\n判断一个对象是否是可迭代对象：\n```python\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n### 列表生成式\n感觉没啥用。\n\n### 生成器\n列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。\n例如实现斐波那契函数：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n    \nfor n in fib(6):\n\tprint(n)\n```\n如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n","source":"_posts/python_高级特性.md","raw":"title: python 3.5 高级特性\ndate: 2016/8/8 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n### 切片\n切片（Slice）操作符用来简化经常取指定索引范围的操作\n```python\n>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n>>> L[0:3]\n['Michael', 'Sarah', 'Tracy']\n```\n从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.\n\n各种用法示例：\n```python\n# Python支持L[-1]取倒数第一个元素,同样支持倒数切片\n>>> L[-2:]\n['Bob', 'Jack']\n>>> L[-2:-1]\n['Bob']\n\n# 前10个数，每两个取一个：\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n\n# 所有数，每5个取一个：\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n# 什么都不写，只写[:]就可以原样复制一个list\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n\n# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n\n#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n### 迭代\n我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。\n\n判断一个对象是否是可迭代对象：\n```python\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n### 列表生成式\n感觉没啥用。\n\n### 生成器\n列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。\n例如实现斐波那契函数：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n    \nfor n in fib(6):\n\tprint(n)\n```\n如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n","slug":"python_高级特性","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dx700577hzgm308y4zc","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>切片（Slice）操作符用来简化经常取指定索引范围的操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">0</span>:<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.</p>\n<p>各种用法示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Python支持L[-1]取倒数第一个元素,同样支持倒数切片</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:<span class=\"number\">-1</span>]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 前10个数，每两个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 所有数，每5个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[::<span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>, <span class=\"number\">50</span>, <span class=\"number\">55</span>, <span class=\"number\">60</span>, <span class=\"number\">65</span>, <span class=\"number\">70</span>, <span class=\"number\">75</span>, <span class=\"number\">80</span>, <span class=\"number\">85</span>, <span class=\"number\">90</span>, <span class=\"number\">95</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 什么都不写，只写[:]就可以原样复制一个list</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, ..., <span class=\"number\">99</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)[:<span class=\"number\">3</span>]</div><div class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"string\">'ABC'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"string\">'ACEG'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。</p>\n<p>判断一个对象是否是可迭代对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</div><div class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable)</div></pre></td></tr></table></figure></p>\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>感觉没啥用。</p>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。<br>例如实现斐波那契函数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></div><div class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</div><div class=\"line\">        <span class=\"keyword\">yield</span> b</div><div class=\"line\">        a, b = b, a + b</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'done'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</div><div class=\"line\">\tprint(n)</div></pre></td></tr></table></figure></p>\n<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>切片（Slice）操作符用来简化经常取指定索引范围的操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">0</span>:<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.</p>\n<p>各种用法示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Python支持L[-1]取倒数第一个元素,同样支持倒数切片</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:<span class=\"number\">-1</span>]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 前10个数，每两个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 所有数，每5个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[::<span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>, <span class=\"number\">50</span>, <span class=\"number\">55</span>, <span class=\"number\">60</span>, <span class=\"number\">65</span>, <span class=\"number\">70</span>, <span class=\"number\">75</span>, <span class=\"number\">80</span>, <span class=\"number\">85</span>, <span class=\"number\">90</span>, <span class=\"number\">95</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 什么都不写，只写[:]就可以原样复制一个list</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, ..., <span class=\"number\">99</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)[:<span class=\"number\">3</span>]</div><div class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"string\">'ABC'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"string\">'ACEG'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。</p>\n<p>判断一个对象是否是可迭代对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</div><div class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable)</div></pre></td></tr></table></figure></p>\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>感觉没啥用。</p>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。<br>例如实现斐波那契函数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></div><div class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</div><div class=\"line\">        <span class=\"keyword\">yield</span> b</div><div class=\"line\">        a, b = b, a + b</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'done'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</div><div class=\"line\">\tprint(n)</div></pre></td></tr></table></figure></p>\n<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"runtime原理笔记","date":"2016-08-22T06:07:12.000Z","_content":"\n最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。\n所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)\t\n<!--more-->\n\n## Runtime基础\n在Objective-C中，使用`[receiver message]`语法并不会马上执行`receiver`对象的`message`方法的代码，而是向`receiver`发送一条`message`消息。\n其实`[receiver message]`被编译器转化为:\n```objc\nid objc_msgSend ( id self, SEL op, ... );\n```\n现在可以看出`[receiver message]`真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送`message`这条消息，而`receive`将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的`selector`，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个`selector`对应的实现内容，要么就干脆玩完崩溃掉。\n\n### id\n`objc_msgSend`第一个参数类型为`id`,它是一个指向`objc_object`结构体指针,它包含一个`Class isa`指针(完整的定义在`objc_private.h`中)：\n```objc\ntypedef struct objc_object *id;\n\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\n### SEL\n`objc_msgSend`函数第二个参数类型为`SEL`，它是`selector`在Objc中的表示类型.`selector`是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是`SEL`:\n```objc\ntypedef struct objc_selector *SEL;\n```\n\n### Class\n之所以说`isa`是指针是因为`Class`其实是一个指向`objc_class`结构体的指针：\n```objc\ntypedef struct objc_class *Class;\n```\n\n这个结构体在`runtime.h`中有定义:\n```objc\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n其中`OBJC2_UNAVAILABLE`表示：在objc2中这些属性已经不在此定义。\n\n在objc2中，`objc_class`的完整定义在`objc-runtime-new.h`中：\n```objc\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n\nstruct objc_class : objc_object {\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n};\n```\n\n和`runtime.h`中的定义对比，少了许多属性，多出一个`bits`属性。这些属性都包含在了`class_rw_t`的`data`对象中。\n\n注意到`objc_class`中也有一个`isa`对象(继承自`objc_object`)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 **元类 (Meta Class)**的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。**类方法就定义于此处**，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。\n当你发出一个类似`[NSObject alloc]`的消息时，你事实上是把这个消息发给了一个**类对象 (Class Object)** ，这个类对象必须是一个元类的实例，而这个元类同时也是一个**根元类 (root meta class)**的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 `[NSObject alloc]`这条消息发给类对象的时候，`objc_msgSend()`会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。\n![Class isa and superclass relationship](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true)\n\n### class_rw_t\n`bits` 中包含了一个指向 `class_rw_t` 结构体的指针，它的定义如下:\n```objc\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n}\n```\n\n其中，`const class_ro_t *ro`包含了所有**成员变量**的一维数组以及**各个基础的(base)属性、方法和协议**\n`method_array_t methods`、`property_array_t properties`、`protocol_array_t protocols`则包含了所有**拓展的属性方法和协议**。**注意：这里的属性只是getset方法，不包含成员变量。**\n这也就解释了，开篇不能添加成员变量的原因。\n\n具体如何应用可看下一篇。\n\n### 部分类的声明\n这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。\n\n#### class_ro_t:\n```objc\nstruct class_ro_t {\n\t...\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    property_list_t *baseProperties;\n    ...\n};\n```\n#### method_t\n`method_list_t`和`method_array_t`内都是`method_t`类型:\n```objc\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n}\n```\n- 方法名类型为`SEL`\n- 方法类型`types`是个`char`指针，其实存储着方法的参数类型和返回值类型。\n- `imp`指向了方法的实现，本质上是一个函数指针\n\n#### ivar_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n}\n```\n\n#### property_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n#### protocol_t\n`protocol_list_t`和`protocol_array_t`内都是`protocol_t`类型:\n```objc\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n};\n```\n\n#### Ivar,Method,Category,objc_property_t\n外部可以通过一系列的方法获得类的信息，诸如：`class_copyIvarList`,`class_copyPropertyList`等方法，可以获得类的实例变量和属性，对应的类型是`Ivar`、`objc_property_t`，它们分别是`ivar_t`,`property_t`类型的指针。\n\n```objc\ntypedef struct method_t *Method;\ntypedef struct ivar_t *Ivar;\ntypedef struct category_t *Category;\ntypedef struct property_t *objc_property_t;\n```\n\n## 消息\n### objc_msgSend函数\n看起来像是`objc_msgSend`返回了数据，其实`objc_msgSend`从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：\n1. 检测这个 `selector` 是不是要忽略的。比如有了垃圾回收就不理会 `retain`, `release` 这些函数了。\n2. 检测这个 `target` 是不是 `nil` 对象。ObjC 的特性是允许对一个 `nil`对象执行任何一个方法不会 Crash，因为会被忽略掉。\n3. 如果上面两个都过了，那就开始查找这个类的 `IMP`，先从 `cache` 里面找，完了找得到就跳到对应的函数去执行。\n4. 如果 `cache` 找不到就找一下方法分发表。\n5. 如果分发表找不到就到超类的分发表去找，一直找，直到找到`NSObject`类为止。\n6. 如果还找不到就要开始进入动态方法解析了.\n\n编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`Super`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`stret`的函数。\n\n当我们调用`[super selector]` 时，Runtime 会调用 `objc_msgSendSuper `方法，`objc_msgSendSuper` 方法有两个参数，`super` 和 `op`，`Runtime` 会把 `selector` 方法选择器赋值给 `op`。而 `super` 是一个 `objc_super` 结构体指针，`objc_super` 结构体定义如下：\n```objc\nstruct objc_super { id receiver; Class class; };\n```\n需要注意的是：这里的`receiver`仍然是`self`本身。当我们想通过`[super class]`获取超类时，编译器只是将指向`self`的`id`指针和`class`的`SEL`传递给了`objc_msgSendSuper`函数，因为只有在`NSObject`类才能找到`class`方法，然后`class`方法调用`object_getClass()`，接着调用`objc_msgSend(objc_super->receiver, @selector(class))`，传入的第一个参数是指向`self`的`id`指针，与调用`[self class]`相同，所以我们得到的永远都是`self`的类型。\n\n举个栗子，问下面的代码输出什么：\n\n```objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n答案是全部输出 `Son`.\n\n当调用 `[super class]` 时，会转换成 `objc_msgSendSuper` 函数：\n1. 先构造 `objc_super` 结构体，结构体第一个成员就是 `self`。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))`.\n2. 去 `Father` 这个类里去找 `- (Class)class`，没有，然后去 `NSObject` 类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))` 去调用，此时已经和 `[self class]` 调用相同了，所以两个输出结果都是 `Son`。\n\n这里调用`class`只是举例，所有调用`super`的方法，最后都变成了`self`的调用。\n\n\n## Category 的实现原理\n### 概述\nruntime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:\n```objc\nvoid _objc_init(void)\n└──const char \\*map_2_images(...)\n    └──const char \\*map_images_nolock(...)\n        └──void _read_images(header_info **hList, uint32_t hCount)\n        \t└──static void remethodizeClass(Class cls)\n        \t\t└──static void attachCategories(Class cls, category_list *cats, bool flush_caches)\n```\n### Category 相关的数据结构\n首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：\n```objc\nstruct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\n\n### 处理 Category\n对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:\n```objc\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches) {\n    if (!cats) return;\n    bool isMeta = cls->isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)malloc(cats->count * sizeof(*mlists));\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n}\n```\n\n首先，通过 `while` 循环，我们遍历所有的 category，也就是参数 `cats` 中的 `list` 属性。对于每一个 category，得到它的方法列表 `mlist` 并存入 `mlists` 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。\n\n在 `while` 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:\n```objc\nauto rw = cls->data();\nrw->methods.attachLists(mlists, mcount);\n```\n`rw` 是一个 `class_rw_t`类型的结构体指针。根据 runtime 中的数据结构，它有一个 `methods` 结构体成员，并从父类继承了 `attachLists` 方法，用来合并 category 中的方法:\n```objc\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n    if (addedCount == 0) return;\n    uint32_t oldCount = array()->count;\n    uint32_t newCount = oldCount + addedCount;\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));\n    memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));\n}\n```\n需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。\n\n[runtime的一篇较好的参考资料](http://www.jianshu.com/p/9d649ce6d0b8)","source":"_posts/runtime原理.md","raw":"title: runtime原理笔记\ndate: 2016/8/22 14:07:12  \ncategories: iOS\ntags: [Runtime]\n\n---\n\n最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。\n所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)\t\n<!--more-->\n\n## Runtime基础\n在Objective-C中，使用`[receiver message]`语法并不会马上执行`receiver`对象的`message`方法的代码，而是向`receiver`发送一条`message`消息。\n其实`[receiver message]`被编译器转化为:\n```objc\nid objc_msgSend ( id self, SEL op, ... );\n```\n现在可以看出`[receiver message]`真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送`message`这条消息，而`receive`将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的`selector`，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个`selector`对应的实现内容，要么就干脆玩完崩溃掉。\n\n### id\n`objc_msgSend`第一个参数类型为`id`,它是一个指向`objc_object`结构体指针,它包含一个`Class isa`指针(完整的定义在`objc_private.h`中)：\n```objc\ntypedef struct objc_object *id;\n\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\n### SEL\n`objc_msgSend`函数第二个参数类型为`SEL`，它是`selector`在Objc中的表示类型.`selector`是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是`SEL`:\n```objc\ntypedef struct objc_selector *SEL;\n```\n\n### Class\n之所以说`isa`是指针是因为`Class`其实是一个指向`objc_class`结构体的指针：\n```objc\ntypedef struct objc_class *Class;\n```\n\n这个结构体在`runtime.h`中有定义:\n```objc\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n其中`OBJC2_UNAVAILABLE`表示：在objc2中这些属性已经不在此定义。\n\n在objc2中，`objc_class`的完整定义在`objc-runtime-new.h`中：\n```objc\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n\nstruct objc_class : objc_object {\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n};\n```\n\n和`runtime.h`中的定义对比，少了许多属性，多出一个`bits`属性。这些属性都包含在了`class_rw_t`的`data`对象中。\n\n注意到`objc_class`中也有一个`isa`对象(继承自`objc_object`)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 **元类 (Meta Class)**的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。**类方法就定义于此处**，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。\n当你发出一个类似`[NSObject alloc]`的消息时，你事实上是把这个消息发给了一个**类对象 (Class Object)** ，这个类对象必须是一个元类的实例，而这个元类同时也是一个**根元类 (root meta class)**的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 `[NSObject alloc]`这条消息发给类对象的时候，`objc_msgSend()`会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。\n![Class isa and superclass relationship](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true)\n\n### class_rw_t\n`bits` 中包含了一个指向 `class_rw_t` 结构体的指针，它的定义如下:\n```objc\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n}\n```\n\n其中，`const class_ro_t *ro`包含了所有**成员变量**的一维数组以及**各个基础的(base)属性、方法和协议**\n`method_array_t methods`、`property_array_t properties`、`protocol_array_t protocols`则包含了所有**拓展的属性方法和协议**。**注意：这里的属性只是getset方法，不包含成员变量。**\n这也就解释了，开篇不能添加成员变量的原因。\n\n具体如何应用可看下一篇。\n\n### 部分类的声明\n这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。\n\n#### class_ro_t:\n```objc\nstruct class_ro_t {\n\t...\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    property_list_t *baseProperties;\n    ...\n};\n```\n#### method_t\n`method_list_t`和`method_array_t`内都是`method_t`类型:\n```objc\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n}\n```\n- 方法名类型为`SEL`\n- 方法类型`types`是个`char`指针，其实存储着方法的参数类型和返回值类型。\n- `imp`指向了方法的实现，本质上是一个函数指针\n\n#### ivar_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n}\n```\n\n#### property_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n#### protocol_t\n`protocol_list_t`和`protocol_array_t`内都是`protocol_t`类型:\n```objc\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n};\n```\n\n#### Ivar,Method,Category,objc_property_t\n外部可以通过一系列的方法获得类的信息，诸如：`class_copyIvarList`,`class_copyPropertyList`等方法，可以获得类的实例变量和属性，对应的类型是`Ivar`、`objc_property_t`，它们分别是`ivar_t`,`property_t`类型的指针。\n\n```objc\ntypedef struct method_t *Method;\ntypedef struct ivar_t *Ivar;\ntypedef struct category_t *Category;\ntypedef struct property_t *objc_property_t;\n```\n\n## 消息\n### objc_msgSend函数\n看起来像是`objc_msgSend`返回了数据，其实`objc_msgSend`从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：\n1. 检测这个 `selector` 是不是要忽略的。比如有了垃圾回收就不理会 `retain`, `release` 这些函数了。\n2. 检测这个 `target` 是不是 `nil` 对象。ObjC 的特性是允许对一个 `nil`对象执行任何一个方法不会 Crash，因为会被忽略掉。\n3. 如果上面两个都过了，那就开始查找这个类的 `IMP`，先从 `cache` 里面找，完了找得到就跳到对应的函数去执行。\n4. 如果 `cache` 找不到就找一下方法分发表。\n5. 如果分发表找不到就到超类的分发表去找，一直找，直到找到`NSObject`类为止。\n6. 如果还找不到就要开始进入动态方法解析了.\n\n编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`Super`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`stret`的函数。\n\n当我们调用`[super selector]` 时，Runtime 会调用 `objc_msgSendSuper `方法，`objc_msgSendSuper` 方法有两个参数，`super` 和 `op`，`Runtime` 会把 `selector` 方法选择器赋值给 `op`。而 `super` 是一个 `objc_super` 结构体指针，`objc_super` 结构体定义如下：\n```objc\nstruct objc_super { id receiver; Class class; };\n```\n需要注意的是：这里的`receiver`仍然是`self`本身。当我们想通过`[super class]`获取超类时，编译器只是将指向`self`的`id`指针和`class`的`SEL`传递给了`objc_msgSendSuper`函数，因为只有在`NSObject`类才能找到`class`方法，然后`class`方法调用`object_getClass()`，接着调用`objc_msgSend(objc_super->receiver, @selector(class))`，传入的第一个参数是指向`self`的`id`指针，与调用`[self class]`相同，所以我们得到的永远都是`self`的类型。\n\n举个栗子，问下面的代码输出什么：\n\n```objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n答案是全部输出 `Son`.\n\n当调用 `[super class]` 时，会转换成 `objc_msgSendSuper` 函数：\n1. 先构造 `objc_super` 结构体，结构体第一个成员就是 `self`。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))`.\n2. 去 `Father` 这个类里去找 `- (Class)class`，没有，然后去 `NSObject` 类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))` 去调用，此时已经和 `[self class]` 调用相同了，所以两个输出结果都是 `Son`。\n\n这里调用`class`只是举例，所有调用`super`的方法，最后都变成了`self`的调用。\n\n\n## Category 的实现原理\n### 概述\nruntime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:\n```objc\nvoid _objc_init(void)\n└──const char \\*map_2_images(...)\n    └──const char \\*map_images_nolock(...)\n        └──void _read_images(header_info **hList, uint32_t hCount)\n        \t└──static void remethodizeClass(Class cls)\n        \t\t└──static void attachCategories(Class cls, category_list *cats, bool flush_caches)\n```\n### Category 相关的数据结构\n首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：\n```objc\nstruct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\n\n### 处理 Category\n对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:\n```objc\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches) {\n    if (!cats) return;\n    bool isMeta = cls->isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)malloc(cats->count * sizeof(*mlists));\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n}\n```\n\n首先，通过 `while` 循环，我们遍历所有的 category，也就是参数 `cats` 中的 `list` 属性。对于每一个 category，得到它的方法列表 `mlist` 并存入 `mlists` 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。\n\n在 `while` 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:\n```objc\nauto rw = cls->data();\nrw->methods.attachLists(mlists, mcount);\n```\n`rw` 是一个 `class_rw_t`类型的结构体指针。根据 runtime 中的数据结构，它有一个 `methods` 结构体成员，并从父类继承了 `attachLists` 方法，用来合并 category 中的方法:\n```objc\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n    if (addedCount == 0) return;\n    uint32_t oldCount = array()->count;\n    uint32_t newCount = oldCount + addedCount;\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));\n    memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));\n}\n```\n需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。\n\n[runtime的一篇较好的参考资料](http://www.jianshu.com/p/9d649ce6d0b8)","slug":"runtime原理","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxa005a7hzgn3jwipqu","content":"<p>最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。<br>所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C Runtime</a><br><a id=\"more\"></a></p>\n<h2 id=\"Runtime基础\"><a href=\"#Runtime基础\" class=\"headerlink\" title=\"Runtime基础\"></a>Runtime基础</h2><p>在Objective-C中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息。<br>其实<code>[receiver message]</code>被编译器转化为:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_msgSend ( <span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL op, ... );</div></pre></td></tr></table></figure></p>\n<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>,它是一个指向<code>objc_object</code>结构体指针,它包含一个<code>Class isa</code>指针(完整的定义在<code>objc_private.h</code>中)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"keyword\">id</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型.<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>\n<p>这个结构体在<code>runtime.h</code>中有定义:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>其中<code>OBJC2_UNAVAILABLE</code>表示：在objc2中这些属性已经不在此定义。</p>\n<p>在objc2中，<code>objc_class</code>的完整定义在<code>objc-runtime-new.h</code>中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></div><div class=\"line\">    class_data_bits_t bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>和<code>runtime.h</code>中的定义对比，少了许多属性，多出一个<code>bits</code>属性。这些属性都包含在了<code>class_rw_t</code>的<code>data</code>对象中。</p>\n<p>注意到<code>objc_class</code>中也有一个<code>isa</code>对象(继承自<code>objc_object</code>)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 <strong>元类 (Meta Class)</strong>的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。<strong>类方法就定义于此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。<br>当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个<strong>类对象 (Class Object)</strong> ，这个类对象必须是一个元类的实例，而这个元类同时也是一个<strong>根元类 (root meta class)</strong>的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code>这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true\" alt=\"Class isa and superclass relationship\"></p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;</div><div class=\"line\">    property_array_t properties;</div><div class=\"line\">    protocol_array_t protocols;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>const class_ro_t *ro</code>包含了所有<strong>成员变量</strong>的一维数组以及<strong>各个基础的(base)属性、方法和协议</strong><br><code>method_array_t methods</code>、<code>property_array_t properties</code>、<code>protocol_array_t protocols</code>则包含了所有<strong>拓展的属性方法和协议</strong>。<strong>注意：这里的属性只是getset方法，不包含成员变量。</strong><br>这也就解释了，开篇不能添加成员变量的原因。</p>\n<p>具体如何应用可看下一篇。</p>\n<h3 id=\"部分类的声明\"><a href=\"#部分类的声明\" class=\"headerlink\" title=\"部分类的声明\"></a>部分类的声明</h3><p>这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。</p>\n<h4 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t:\"></a>class_ro_t:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</div><div class=\"line\">\t...</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h4><p><code>method_list_t</code>和<code>method_array_t</code>内都是<code>method_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>方法名类型为<code>SEL</code></li>\n<li>方法类型<code>types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>\n<li><code>imp</code>指向了方法的实现，本质上是一个函数指针</li>\n</ul>\n<h4 id=\"ivar-t\"><a href=\"#ivar-t\" class=\"headerlink\" title=\"ivar_t\"></a>ivar_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"property-t\"><a href=\"#property-t\" class=\"headerlink\" title=\"property_t\"></a>property_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h4><p><code>protocol_list_t</code>和<code>protocol_array_t</code>内都是<code>protocol_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> protocol_t : objc_object &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    method_list_t *instanceMethods;</div><div class=\"line\">    method_list_t *classMethods;</div><div class=\"line\">    method_list_t *optionalInstanceMethods;</div><div class=\"line\">    method_list_t *optionalClassMethods;</div><div class=\"line\">    property_list_t *instanceProperties;</div><div class=\"line\">    uint32_t size;   <span class=\"comment\">// sizeof(protocol_t)</span></div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Ivar-Method-Category-objc-property-t\"><a href=\"#Ivar-Method-Category-objc-property-t\" class=\"headerlink\" title=\"Ivar,Method,Category,objc_property_t\"></a>Ivar,Method,Category,objc_property_t</h4><p>外部可以通过一系列的方法获得类的信息，诸如：<code>class_copyIvarList</code>,<code>class_copyPropertyList</code>等方法，可以获得类的实例变量和属性，对应的类型是<code>Ivar</code>、<code>objc_property_t</code>，它们分别是<code>ivar_t</code>,<code>property_t</code>类型的指针。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> method_t *Method;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ivar_t *Ivar;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> category_t *Category;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> property_t *objc_property_t;</div></pre></td></tr></table></figure>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h3 id=\"objc-msgSend函数\"><a href=\"#objc-msgSend函数\" class=\"headerlink\" title=\"objc_msgSend函数\"></a>objc_msgSend函数</h3><p>看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>\n<ol>\n<li>检测这个 <code>selector</code> 是不是要忽略的。比如有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>\n<li>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>\n<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>\n<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>\n<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>\n<li>如果还找不到就要开始进入动态方法解析了.</li>\n</ol>\n<p>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。</p>\n<p>当我们调用<code>[super selector]</code> 时，Runtime 会调用 <code>objc_msgSendSuper</code>方法，<code>objc_msgSendSuper</code> 方法有两个参数，<code>super</code> 和 <code>op</code>，<code>Runtime</code> 会把 <code>selector</code> 方法选择器赋值给 <code>op</code>。而 <code>super</code> 是一个 <code>objc_super</code> 结构体指针，<code>objc_super</code> 结构体定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123; <span class=\"keyword\">id</span> receiver; Class <span class=\"keyword\">class</span>; &#125;;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是：这里的<code>receiver</code>仍然是<code>self</code>本身。当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>\n<p>举个栗子，问下面的代码输出什么：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>答案是全部输出 <code>Son</code>.</p>\n<p>当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 函数：</p>\n<ol>\n<li>先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code>。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>.</li>\n<li>去 <code>Father</code> 这个类里去找 <code>- (Class)class</code>，没有，然后去 <code>NSObject</code> 类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code> 去调用，此时已经和 <code>[self class]</code> 调用相同了，所以两个输出结果都是 <code>Son</code>。</li>\n</ol>\n<p>这里调用<code>class</code>只是举例，所有调用<code>super</code>的方法，最后都变成了<code>self</code>的调用。</p>\n<h2 id=\"Category-的实现原理\"><a href=\"#Category-的实现原理\" class=\"headerlink\" title=\"Category 的实现原理\"></a>Category 的实现原理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> _objc_init(<span class=\"keyword\">void</span>)</div><div class=\"line\">└──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_2_images(...)</div><div class=\"line\">    └──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_images_nolock(...)</div><div class=\"line\">        └──<span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount)</div><div class=\"line\">        \t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> remethodizeClass(Class cls)</div><div class=\"line\">        \t\t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Category-相关的数据结构\"><a href=\"#Category-相关的数据结构\" class=\"headerlink\" title=\"Category 相关的数据结构\"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> category_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *instanceMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *classMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    <span class=\"keyword\">struct</span> property_list_t *instanceProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>\n<h3 id=\"处理-Category\"><a href=\"#处理-Category\" class=\"headerlink\" title=\"处理 Category\"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</div><div class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></div><div class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</div><div class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\"></div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle);</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">    free(mlists);</div><div class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，通过 <code>while</code> 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。</p>\n<p>在 <code>while</code> 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto rw = cls-&gt;data();</div><div class=\"line\">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure></p>\n<p><code>rw</code> 是一个 <code>class_rw_t</code>类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> attachLists(List* <span class=\"keyword\">const</span> * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (addedCount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">    uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">    array()-&gt;count = newCount;</div><div class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>\n<p><a href=\"http://www.jianshu.com/p/9d649ce6d0b8\" target=\"_blank\" rel=\"external\">runtime的一篇较好的参考资料</a></p>\n","excerpt":"<p>最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。<br>所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\">Objective-C Runtime</a><br>","more":"</p>\n<h2 id=\"Runtime基础\"><a href=\"#Runtime基础\" class=\"headerlink\" title=\"Runtime基础\"></a>Runtime基础</h2><p>在Objective-C中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息。<br>其实<code>[receiver message]</code>被编译器转化为:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_msgSend ( <span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL op, ... );</div></pre></td></tr></table></figure></p>\n<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>,它是一个指向<code>objc_object</code>结构体指针,它包含一个<code>Class isa</code>指针(完整的定义在<code>objc_private.h</code>中)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"keyword\">id</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型.<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>\n<p>这个结构体在<code>runtime.h</code>中有定义:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>其中<code>OBJC2_UNAVAILABLE</code>表示：在objc2中这些属性已经不在此定义。</p>\n<p>在objc2中，<code>objc_class</code>的完整定义在<code>objc-runtime-new.h</code>中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></div><div class=\"line\">    class_data_bits_t bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>和<code>runtime.h</code>中的定义对比，少了许多属性，多出一个<code>bits</code>属性。这些属性都包含在了<code>class_rw_t</code>的<code>data</code>对象中。</p>\n<p>注意到<code>objc_class</code>中也有一个<code>isa</code>对象(继承自<code>objc_object</code>)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 <strong>元类 (Meta Class)</strong>的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。<strong>类方法就定义于此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。<br>当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个<strong>类对象 (Class Object)</strong> ，这个类对象必须是一个元类的实例，而这个元类同时也是一个<strong>根元类 (root meta class)</strong>的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code>这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true\" alt=\"Class isa and superclass relationship\"></p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;</div><div class=\"line\">    property_array_t properties;</div><div class=\"line\">    protocol_array_t protocols;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>const class_ro_t *ro</code>包含了所有<strong>成员变量</strong>的一维数组以及<strong>各个基础的(base)属性、方法和协议</strong><br><code>method_array_t methods</code>、<code>property_array_t properties</code>、<code>protocol_array_t protocols</code>则包含了所有<strong>拓展的属性方法和协议</strong>。<strong>注意：这里的属性只是getset方法，不包含成员变量。</strong><br>这也就解释了，开篇不能添加成员变量的原因。</p>\n<p>具体如何应用可看下一篇。</p>\n<h3 id=\"部分类的声明\"><a href=\"#部分类的声明\" class=\"headerlink\" title=\"部分类的声明\"></a>部分类的声明</h3><p>这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。</p>\n<h4 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t:\"></a>class_ro_t:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</div><div class=\"line\">\t...</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h4><p><code>method_list_t</code>和<code>method_array_t</code>内都是<code>method_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>方法名类型为<code>SEL</code></li>\n<li>方法类型<code>types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>\n<li><code>imp</code>指向了方法的实现，本质上是一个函数指针</li>\n</ul>\n<h4 id=\"ivar-t\"><a href=\"#ivar-t\" class=\"headerlink\" title=\"ivar_t\"></a>ivar_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"property-t\"><a href=\"#property-t\" class=\"headerlink\" title=\"property_t\"></a>property_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h4><p><code>protocol_list_t</code>和<code>protocol_array_t</code>内都是<code>protocol_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> protocol_t : objc_object &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    method_list_t *instanceMethods;</div><div class=\"line\">    method_list_t *classMethods;</div><div class=\"line\">    method_list_t *optionalInstanceMethods;</div><div class=\"line\">    method_list_t *optionalClassMethods;</div><div class=\"line\">    property_list_t *instanceProperties;</div><div class=\"line\">    uint32_t size;   <span class=\"comment\">// sizeof(protocol_t)</span></div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Ivar-Method-Category-objc-property-t\"><a href=\"#Ivar-Method-Category-objc-property-t\" class=\"headerlink\" title=\"Ivar,Method,Category,objc_property_t\"></a>Ivar,Method,Category,objc_property_t</h4><p>外部可以通过一系列的方法获得类的信息，诸如：<code>class_copyIvarList</code>,<code>class_copyPropertyList</code>等方法，可以获得类的实例变量和属性，对应的类型是<code>Ivar</code>、<code>objc_property_t</code>，它们分别是<code>ivar_t</code>,<code>property_t</code>类型的指针。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> method_t *Method;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ivar_t *Ivar;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> category_t *Category;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> property_t *objc_property_t;</div></pre></td></tr></table></figure>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h3 id=\"objc-msgSend函数\"><a href=\"#objc-msgSend函数\" class=\"headerlink\" title=\"objc_msgSend函数\"></a>objc_msgSend函数</h3><p>看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>\n<ol>\n<li>检测这个 <code>selector</code> 是不是要忽略的。比如有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>\n<li>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>\n<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>\n<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>\n<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>\n<li>如果还找不到就要开始进入动态方法解析了.</li>\n</ol>\n<p>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。</p>\n<p>当我们调用<code>[super selector]</code> 时，Runtime 会调用 <code>objc_msgSendSuper</code>方法，<code>objc_msgSendSuper</code> 方法有两个参数，<code>super</code> 和 <code>op</code>，<code>Runtime</code> 会把 <code>selector</code> 方法选择器赋值给 <code>op</code>。而 <code>super</code> 是一个 <code>objc_super</code> 结构体指针，<code>objc_super</code> 结构体定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123; <span class=\"keyword\">id</span> receiver; Class <span class=\"keyword\">class</span>; &#125;;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是：这里的<code>receiver</code>仍然是<code>self</code>本身。当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>\n<p>举个栗子，问下面的代码输出什么：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>答案是全部输出 <code>Son</code>.</p>\n<p>当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 函数：</p>\n<ol>\n<li>先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code>。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>.</li>\n<li>去 <code>Father</code> 这个类里去找 <code>- (Class)class</code>，没有，然后去 <code>NSObject</code> 类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code> 去调用，此时已经和 <code>[self class]</code> 调用相同了，所以两个输出结果都是 <code>Son</code>。</li>\n</ol>\n<p>这里调用<code>class</code>只是举例，所有调用<code>super</code>的方法，最后都变成了<code>self</code>的调用。</p>\n<h2 id=\"Category-的实现原理\"><a href=\"#Category-的实现原理\" class=\"headerlink\" title=\"Category 的实现原理\"></a>Category 的实现原理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> _objc_init(<span class=\"keyword\">void</span>)</div><div class=\"line\">└──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_2_images(...)</div><div class=\"line\">    └──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_images_nolock(...)</div><div class=\"line\">        └──<span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount)</div><div class=\"line\">        \t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> remethodizeClass(Class cls)</div><div class=\"line\">        \t\t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Category-相关的数据结构\"><a href=\"#Category-相关的数据结构\" class=\"headerlink\" title=\"Category 相关的数据结构\"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> category_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *instanceMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *classMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    <span class=\"keyword\">struct</span> property_list_t *instanceProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>\n<h3 id=\"处理-Category\"><a href=\"#处理-Category\" class=\"headerlink\" title=\"处理 Category\"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</div><div class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></div><div class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</div><div class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\"></div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle);</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">    free(mlists);</div><div class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，通过 <code>while</code> 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。</p>\n<p>在 <code>while</code> 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto rw = cls-&gt;data();</div><div class=\"line\">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure></p>\n<p><code>rw</code> 是一个 <code>class_rw_t</code>类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> attachLists(List* <span class=\"keyword\">const</span> * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (addedCount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">    uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">    array()-&gt;count = newCount;</div><div class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>\n<p><a href=\"http://www.jianshu.com/p/9d649ce6d0b8\">runtime的一篇较好的参考资料</a></p>"},{"title":"runtime应用笔记","date":"2016-08-23T06:07:12.000Z","_content":"\n了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考[Runtime全方位装逼指南](http://www.jianshu.com/p/efeb33712445)，总结了以下几点应用场景。\n\n<!--more-->\n\n## 给category添加属性\n### 原理\n**对象关联**允许开发者对已经存在的类在 Category 中添加自定义的属性：\n```objc\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n- object 是源对象.\n- value 是被关联的对象.\n- key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.\n- policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：\n```objc\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：\n```objc\nobjc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n```\n\nobjc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.\n\n### 示例：\n新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n@property (nonatomic,copy) clickBlock click;\n@end\n```\n\n在.m中设置click的set，get方法(UIButton+ClickBlock.m):\n```objc\n#import \"UIButton+ClickBlock.h\"\n#import <objc/runtime.h>\n\nstatic const void *associatedKey = \"associatedKey\";\n\n@implementation UIButton (ClickBlock)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n-(clickBlock)click{\n    return objc_getAssociatedObject(self, associatedKey);\n}\n\n-(void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n```\n\n其中，在set方法中使用`addTarget:action:forControlEvents:`给button设置了点击事件。\n\n`self.click()`表示使用`self.click`获得block，再通过`block()`执行块。\n\n为什么不直接给click赋值，而是通过runtime的`objc_setAssociatedObject`方法呢？\n@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。\n\n@property在本例中只是为了在.h里声明一个getset方法。可替换成：\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n//@property (nonatomic,copy) clickBlock click;\n- (clickBlock)click;\n- (void)setClick:(clickBlock)click;\n@end\n```\n\n## 字典与模型转换\n### 原理\n字典转模型的时候：\n1. 根据字典的 key 生成 setter 方法.\n2. 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.\n\n模型转字典的时候：\n1. 调用 class_copyPropertyList 方法获取当前 Model 的所有属性.\n2. 调用 property_getName 获取属性名称.\n3. 根据属性名称生成 getter 方法.\n4. 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.\n\n### 示例\n```objc\n@interface NSObject (KeyValues)\n\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary;\n\n-(NSDictionary *)keyValuesWithObject;\n\n@end\n\n\n#import \"NSObject+KeyValues.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation NSObject (KeyValues)\n\n//字典转模型\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary{\n    id objc = [[self alloc] init];\n    for (NSString *key in aDictionary.allKeys) {\n        id value = aDictionary[key];\n        \n        /*判断当前属性是不是Model*/\n        objc_property_t property = class_getProperty(self, key.UTF8String);\n        unsigned int outCount = 0;\n        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &outCount);\n        objc_property_attribute_t attribute = attributeList[0];\n        NSString *typeString = [NSString stringWithUTF8String:attribute.value];\n        if ([typeString isEqualToString:@\"@\\\"TestModel\\\"\"]) {\n            value = [self objectWithKeyValues:value];\n        }\n        /**********************/\n        \n        //生成setter方法，并用objc_msgSend调用\n        NSString *methodName = [NSString stringWithFormat:@\"set%@%@:\",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];\n        SEL setter = sel_registerName(methodName.UTF8String);\n        if ([objc respondsToSelector:setter]) {\n            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);\n        }\n        free(attributeList);\n    }\n    return objc;\n}\n\n//模型转字典\n-(NSDictionary *)keyValuesWithObject{\n    unsigned int outCount = 0;\n    objc_property_t *propertyList = class_copyPropertyList([self class], &outCount);\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (int i = 0; i < outCount; i ++) {\n        objc_property_t property = propertyList[i];\n        \n        //生成getter方法，并用objc_msgSend调用\n        const char *propertyName = property_getName(property);\n        SEL getter = sel_registerName(propertyName);\n        if ([self respondsToSelector:getter]) {\n            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);\n            \n            /*判断当前属性是不是Model*/\n            if ([value isKindOfClass:[self class]] && value) {\n                value = [value keyValuesWithObject];\n            }\n            /**********************/\n            \n            if (value) {\n                NSString *key = [NSString stringWithUTF8String:propertyName];\n                [dict setObject:value forKey:key];\n            }\n        }\n        \n    }\n    free(propertyList);\n    return dict;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyValuesTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    NSLog(@\"name is %@\",model.name);\n    NSLog(@\"son name is %@\",model.son.name);\n    \n    NSDictionary *dict = [model keyValuesWithObject];\n    NSLog(@\"dict is %@\",dict);\n}\n```\n\n注意：\n1. 在NSObject中添加类方法，其中的`self`指的是`TestModel`这个类。\n2. `objc_property_t`具有两个属性，name和attribute。调用`property_getAttribute`将返回attribute的字符串。调用`property_copyAttributeList`则将字符串切分，返回一个`objc_property_attribute_t`类型的指针，`outCount`返回了属性的数量。\n\n---\noutCount使用了**指向指针的指针**的方式，使没有返回outCount的情况下，修改了outCount的值。\n\n例：\n```objc\n- (NSArray *)scanBeginStr:(NSString *)beginstr endStr:(NSString *)endstr inText:(NSMutableString * *)textPointer{\n    NSRange range1,range2;\n    NSUInteger location =0,length=0;\n    range1.location = 0;\n    NSMutableString *text = *textPointer;\n    NSMutableArray *rangeArray = [NSMutableArray array];\n    while (range1.location != NSNotFound) {\n        range1 = [text rangeOfString:beginstr];\n        range2 = [text rangeOfString:endstr];\n        if (range1.location != NSNotFound) {\n            location = range1.location;\n            length = range2.location - range1.location - 1;\n            if (length > 5000)break;\n            [text replaceOccurrencesOfString:beginstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];\n            [text replaceOccurrencesOfString:endstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];\n        }\n        [rangeArray addObject:@{@\"location\":@(location),@\"length\":@(length)}];\n    }\n    return rangeArray;\n}\n```\n使用：通过&取指针的地址\n```\n NSArray *rangeArray = [self scanBegin3Str:@\"<\" endStr:@\">\" inText:&mutableText];\n```\n\n---\n\n## 自动归档\n### 原理\n归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：\n```objc\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    [aCoder encodeObject:self.name forKey:@\"name\"];\n    [aCoder encodeObject:self.ID forKey:@\"ID\"];\n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        self.ID = [aDecoder decodeObjectForKey:@\"ID\"];\n        self.name = [aDecoder decodeObjectForKey:@\"name\"];\n    }\n    return self;\n}\n```\n如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：\n1. 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.\n2. 使用 ivar_getName 方法获取成员变量的名称.\n3. 通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.\n\n### 示例：\n```objc\n#import \"TestModel.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation TestModel\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    unsigned int outCount = 0;\n    Ivar *vars = class_copyIvarList([self class], &outCount);\n    for (int i = 0; i < outCount; i ++) {\n        Ivar var = vars[i];\n        const char *name = ivar_getName(var);\n        NSString *key = [NSString stringWithUTF8String:name];\n        \n        // 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法\n        // 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值\n        // 所以这里不需要再另外处理成员变量名称的“_”前缀\n        id value = [self valueForKey:key];\n        [aCoder encodeObject:value forKey:key];\n    }\n    free(vars);\n}\n\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        unsigned int outCount = 0;\n        Ivar *vars = class_copyIvarList([self class], &outCount);\n        for (int i = 0; i < outCount; i ++) {\n            Ivar var = vars[i];\n            const char *name = ivar_getName(var);\n            NSString *key = [NSString stringWithUTF8String:name];\n            id value = [aDecoder decodeObjectForKey:key];\n            [self setValue:value forKey:key];\n        }\n        free(vars);\n    }\n    return self;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyedArchiverTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    \n    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;\n    path = [path stringByAppendingPathComponent:@\"test\"];\n    [NSKeyedArchiver archiveRootObject:model toFile:path];\n    \n    TestModel *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n    NSLog(@\"m.name is %@\",m.name);\n    NSLog(@\"m.son name is %@\",m.son.name);\n}\n```\n\n## 动态方法解析与消息转发\n### 原理\n消息转发的大致过程如图：\n\n![消息转发流程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true)\n\n1. 当 Runtime 系统在`Cache`和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用`resolveInstanceMethod:`或`resolveClassMethod:`(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回`NO`，则进入下一步，若返回`YES`，则通过 `class_addMethod` 函数动态地添加方法，消息得到处理，此流程完毕.\n2. `resolveInstanceMethod:` 方法返回 `NO` 时，就会进入 `forwardingTargetForSelector:` 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 `selector`。返回`nil`，进入下一步，返回某个对象，则会调用该对象的方法.\n3. 若 `forwardingTargetForSelector:` 返回的是`nil`，则我们首先要通过 `methodSignatureForSelector:` 来指定方法签名，返回`nil`，表示不处理，若返回方法签名，则会进入下一步.\n4. 当第 `methodSignatureForSelector:` 方法返回方法签名后，就会调用 `forwardInvocation:` 方法，我们可以通过 `anInvocation` 对象做很多处理，比如修改实现方法，修改响应对象等.\n5. 如果到最后，消息还是没有得到响应，程序就会crash.\n\n### 示例：\n```objc\n#import \"Monkey.h\"\n#import \"Bird.h\"\n#import <objc/runtime.h>\n\n@implementation Monkey\n\n-(void)jump{\n    NSLog(@\"monkey can not fly, but! monkey can jump\");\n}\n\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    /*\n     如果当前对象调用了一个不存在的方法\n     Runtime会调用resolveInstanceMethod:来进行动态方法解析\n     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作\n     返回NO，则进入下一步forwardingTargetForSelector:\n     */\n    \n\tif(sel == @selector(fly)){\n    \tclass_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(\"jump\")), \"v@:\");\n    \treturn YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n    \n    /*\n     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会\n     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象\n     返回nil则进步下一步forwardInvocation:\n     */\n    \n#if 0\n    return nil;\n#else\n    return [[Bird alloc] init];\n#endif\n}\n\n-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    /*\n     获取方法签名进入下一步，进行消息转发\n     */\n    \n    return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n}\n\n-(void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    /*\n     消息转发\n     */\n    \n    return [anInvocation invokeWithTarget:[[Bird alloc] init]];\n}\n\n@end\n```\n\n其中 `\"v@:\"` 表示返回值和参数,这个符号涉及[Type Encoding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)以及[关于type encodings的理解--runtime programming guide](http://www.jianshu.com/p/f4129b5194c0)。\n\n---\n其中**v**表示返回`void`类型，**@**表示参数`id(self)`，**：**表示`SEL(_cmd)`这几个是必须要有的，后面可以接入参类型。\n\n举个例子：`\"i@:@\"`\n**i**表示返回值类型`int`\n**@：**和上面意义相同\n**@**最后一个@表示有一个入参，是`id`类型。\n\n不过，实际上，这个东西好像没什么用，因为在`class_addMethod`上试验过，随便传任何字符串都一样能正常运行。\n\n---\n一般来说可以使用`method_getTypeEncoding()`获取更详细的Type_Encoding,下面例子中也会用到。\n\n### 转发与多继承\n转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。\n![runtime_transmit](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true)\n\n这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中`Warrior`和`Diplomat`没有继承关系，但是`Warrior`将`negotiate`消息转发给了`Diplomat`后，就好似`Diplomat`是`Warrior`的超类一样。\n\n消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。\n\n## Runtime-动态创建类添加属性和方法\n```objc\n- (void)createClass\n{\n    Class MyClass = objc_allocateClassPair([NSObject class], \"myclass\", 0);\n    //添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型\n    if (class_addIvar(MyClass, \"itest\", sizeof(NSString *), 0, \"@\")) {\n        NSLog(@\"add ivar success\");\n    }\n    //myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding\n    class_addMethod(MyClass, @selector(myclasstest:), (IMP)myclasstest, \"v@:\");\n    //注册这个类到runtime系统中就可以使用他了\n    objc_registerClassPair(MyClass);\n    //生成了一个实例化对象\n    id myobj = [[MyClass alloc] init];\n    NSString *str = @\"asdb\";\n    //给刚刚添加的变量赋值\n    //    object_setInstanceVariable(myobj, \"itest\", (void *)&str);在ARC下不允许使用\n    [myobj setValue:str forKey:@\"itest\"];\n    //调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息\n    [myobj myclasstest:10];\n\n}\n//这个方法实际上没有被调用,但是必须实现否则编译都不能通过\n- (void)myclasstest:(int)a\n{\n    \n}\n//调用的是这个方法\nstatic void myclasstest(id self, SEL _cmd, int a) //self和_cmd是必须的，在之后可以随意添加其他参数\n{\n    \n    Ivar v = class_getInstanceVariable([self class], \"itest\");\n    //返回名为itest的ivar的变量的值\n    id o = object_getIvar(self, v);\n    //成功打印出结果\n    NSLog(@\"%@\", o);\n    NSLog(@\"int a is %d\", a);\n}\n```\n\n## Method Swizzling\n此部分参考自[Objective-C的方法替换](http://blog.csdn.net/horkychen/article/details/8532087)、[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)等系列文章\n### 例子\n```objc\n#import <objc/runtime.h> \n \n@implementation UIViewController (Tracking) \n \n+ (void)load { \n    static dispatch_once_t onceToken; \n    dispatch_once(&onceToken, ^{ \n        Class aClass = [self class]; \n \n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n        \n        // When swizzling a class method, use the following:\n        // Class aClass = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(aClass, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n \n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n \n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        } \n    }); \n} \n \n#pragma mark - Method Swizzling \n \n- (void)xxx_viewWillAppear:(BOOL)animated { \n    [self xxx_viewWillAppear:animated]; \n    NSLog(@\"viewWillAppear: %@\", self); \n} \n \n@end\n```\n\n### 原理\n#### 概述\n在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。\n\n每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图\n![runtime_swizzling_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true)\n\n通过Swizzling需要实现的是偷换selector的IMP，如下图所示：\n![runtime_swizzling_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true)\n\n#### 实现过程\n上面的代码通过添加一个`Tracking`类别到`UIViewController`类中，将`UIViewController`类的`viewWillAppear:`方法和`Tracking`类别中`xxx_viewWillAppear:`方法的实现相互调换。Swizzling 应该在`+load`方法中实现，因为`+load`是在一个类最开始加载时调用。`dispatch_once`是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。\n\n实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉`UIViewController`中的`viewWillAppear:`方法。这两种情况要区别对待。\n\n对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(`xxx_viewWillAppear:`)，然后将复写的方法替换为原先的实现(`viewWillAppear:`).\n\n```objc\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n```\n`class_addMethod`将本来不存在于被操作的Class里的`swizzledMethod`的实现添加在被操作的Class里,并使用`originalSelector`作为其选择子。如果发现方法已经存在，会失败返回。\n\n---\n通过上一篇[runtime原理](https://zhang759740844.github.io/2016/08/22/runtime原理/)的分析，`class_addMethod`应该是先在类的method数组里找是否有这个`SEL`,如果没有就添加一个`method_t`。\n\n---\n\n如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:\n```objc\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n```\n`addMethod`会让当前类的方法(IMP)指向新的实现(SEL)，使用`replaceMethod`再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法`SEL`来调用，就会实现新方法的`IMP`，通过新方法的`SEL`来调用，就会实现旧方法的`IMP`。\n\n如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过`method_exchangeImplementations`直接交换两个`method_t`的`IMP`:\n```objc\nelse {\n    method_exchangeImplementations(originalMethod, overrideMethod);\n}\n```\n\n所以本例中由于`viewWillAppear:`已经在UIViewController中实现过了，所以，`class_addMethod`失败，通过`method_exchangeImplementations`达到交换实现。如果要通过`class_addMethod`添加，需要自定义一个View继承UIViewController，再在这个类中替换`viewWillAppear:`。\n\n\n如果类中没有想被替换实现的原方法时，`class_replaceMethod`相当于直接调用`class_addMethod`向类中添加该方法的实现。\n\n`method_exchangeImplementations`方法做的事情与如下的原子操作等价：\n```objc\nIMP imp1 = method_getImplementation(m1);\nIMP imp2 = method_getImplementation(m2);\nmethod_setImplementation(m1, imp2);\nmethod_setImplementation(m2, imp1);\n```\n直接设置了`method`:`m1`,`m2`的`IMP`，简单暴力。\n\n对于注释了的这几行:\n```objc\n// When swizzling a class method, use the following:\n// Class aClass = object_getClass((id)self);\n// ...\n// Method originalMethod = class_getClassMethod(aClass, originalSelector);\n// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n```\n`object_getClass((id)self)` 与 `[self class]` 返回的结果类型都是 `Class`,但前者为元类,后者为其本身,因为此时 `self` 为 `Class` 而不是实例.注意 `[NSObject class]` 与 `[object实例 class]` 的区别：\n```objc\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n`object_getClass()`方法返回对象的`isa`。\n\n最后，`xxx_viewWillAppear:`方法的定义看似是递归调用引发死循环，其实不会的。因为`[self xxx_viewWillAppear:animated]`消息会动态找到`xxx_viewWillAppear:`方法的实现，而它的实现已经被我们与`viewWillAppear:`方法实现进行了互换，所以这段代码不仅不会死循环，如果你把`[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]`反而会引发死循环。\n\n> Demo 详见RuntimeLearn\n\n\n","source":"_posts/runtime应用.md","raw":"title: runtime应用笔记\ndate: 2016/8/23 14:07:12  \ncategories: iOS\ntags: [Runtime]\n\n---\n\n了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考[Runtime全方位装逼指南](http://www.jianshu.com/p/efeb33712445)，总结了以下几点应用场景。\n\n<!--more-->\n\n## 给category添加属性\n### 原理\n**对象关联**允许开发者对已经存在的类在 Category 中添加自定义的属性：\n```objc\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n- object 是源对象.\n- value 是被关联的对象.\n- key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.\n- policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：\n```objc\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：\n```objc\nobjc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n```\n\nobjc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.\n\n### 示例：\n新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n@property (nonatomic,copy) clickBlock click;\n@end\n```\n\n在.m中设置click的set，get方法(UIButton+ClickBlock.m):\n```objc\n#import \"UIButton+ClickBlock.h\"\n#import <objc/runtime.h>\n\nstatic const void *associatedKey = \"associatedKey\";\n\n@implementation UIButton (ClickBlock)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n-(clickBlock)click{\n    return objc_getAssociatedObject(self, associatedKey);\n}\n\n-(void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n```\n\n其中，在set方法中使用`addTarget:action:forControlEvents:`给button设置了点击事件。\n\n`self.click()`表示使用`self.click`获得block，再通过`block()`执行块。\n\n为什么不直接给click赋值，而是通过runtime的`objc_setAssociatedObject`方法呢？\n@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。\n\n@property在本例中只是为了在.h里声明一个getset方法。可替换成：\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n//@property (nonatomic,copy) clickBlock click;\n- (clickBlock)click;\n- (void)setClick:(clickBlock)click;\n@end\n```\n\n## 字典与模型转换\n### 原理\n字典转模型的时候：\n1. 根据字典的 key 生成 setter 方法.\n2. 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.\n\n模型转字典的时候：\n1. 调用 class_copyPropertyList 方法获取当前 Model 的所有属性.\n2. 调用 property_getName 获取属性名称.\n3. 根据属性名称生成 getter 方法.\n4. 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.\n\n### 示例\n```objc\n@interface NSObject (KeyValues)\n\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary;\n\n-(NSDictionary *)keyValuesWithObject;\n\n@end\n\n\n#import \"NSObject+KeyValues.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation NSObject (KeyValues)\n\n//字典转模型\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary{\n    id objc = [[self alloc] init];\n    for (NSString *key in aDictionary.allKeys) {\n        id value = aDictionary[key];\n        \n        /*判断当前属性是不是Model*/\n        objc_property_t property = class_getProperty(self, key.UTF8String);\n        unsigned int outCount = 0;\n        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &outCount);\n        objc_property_attribute_t attribute = attributeList[0];\n        NSString *typeString = [NSString stringWithUTF8String:attribute.value];\n        if ([typeString isEqualToString:@\"@\\\"TestModel\\\"\"]) {\n            value = [self objectWithKeyValues:value];\n        }\n        /**********************/\n        \n        //生成setter方法，并用objc_msgSend调用\n        NSString *methodName = [NSString stringWithFormat:@\"set%@%@:\",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];\n        SEL setter = sel_registerName(methodName.UTF8String);\n        if ([objc respondsToSelector:setter]) {\n            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);\n        }\n        free(attributeList);\n    }\n    return objc;\n}\n\n//模型转字典\n-(NSDictionary *)keyValuesWithObject{\n    unsigned int outCount = 0;\n    objc_property_t *propertyList = class_copyPropertyList([self class], &outCount);\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (int i = 0; i < outCount; i ++) {\n        objc_property_t property = propertyList[i];\n        \n        //生成getter方法，并用objc_msgSend调用\n        const char *propertyName = property_getName(property);\n        SEL getter = sel_registerName(propertyName);\n        if ([self respondsToSelector:getter]) {\n            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);\n            \n            /*判断当前属性是不是Model*/\n            if ([value isKindOfClass:[self class]] && value) {\n                value = [value keyValuesWithObject];\n            }\n            /**********************/\n            \n            if (value) {\n                NSString *key = [NSString stringWithUTF8String:propertyName];\n                [dict setObject:value forKey:key];\n            }\n        }\n        \n    }\n    free(propertyList);\n    return dict;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyValuesTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    NSLog(@\"name is %@\",model.name);\n    NSLog(@\"son name is %@\",model.son.name);\n    \n    NSDictionary *dict = [model keyValuesWithObject];\n    NSLog(@\"dict is %@\",dict);\n}\n```\n\n注意：\n1. 在NSObject中添加类方法，其中的`self`指的是`TestModel`这个类。\n2. `objc_property_t`具有两个属性，name和attribute。调用`property_getAttribute`将返回attribute的字符串。调用`property_copyAttributeList`则将字符串切分，返回一个`objc_property_attribute_t`类型的指针，`outCount`返回了属性的数量。\n\n---\noutCount使用了**指向指针的指针**的方式，使没有返回outCount的情况下，修改了outCount的值。\n\n例：\n```objc\n- (NSArray *)scanBeginStr:(NSString *)beginstr endStr:(NSString *)endstr inText:(NSMutableString * *)textPointer{\n    NSRange range1,range2;\n    NSUInteger location =0,length=0;\n    range1.location = 0;\n    NSMutableString *text = *textPointer;\n    NSMutableArray *rangeArray = [NSMutableArray array];\n    while (range1.location != NSNotFound) {\n        range1 = [text rangeOfString:beginstr];\n        range2 = [text rangeOfString:endstr];\n        if (range1.location != NSNotFound) {\n            location = range1.location;\n            length = range2.location - range1.location - 1;\n            if (length > 5000)break;\n            [text replaceOccurrencesOfString:beginstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];\n            [text replaceOccurrencesOfString:endstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];\n        }\n        [rangeArray addObject:@{@\"location\":@(location),@\"length\":@(length)}];\n    }\n    return rangeArray;\n}\n```\n使用：通过&取指针的地址\n```\n NSArray *rangeArray = [self scanBegin3Str:@\"<\" endStr:@\">\" inText:&mutableText];\n```\n\n---\n\n## 自动归档\n### 原理\n归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：\n```objc\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    [aCoder encodeObject:self.name forKey:@\"name\"];\n    [aCoder encodeObject:self.ID forKey:@\"ID\"];\n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        self.ID = [aDecoder decodeObjectForKey:@\"ID\"];\n        self.name = [aDecoder decodeObjectForKey:@\"name\"];\n    }\n    return self;\n}\n```\n如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：\n1. 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.\n2. 使用 ivar_getName 方法获取成员变量的名称.\n3. 通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.\n\n### 示例：\n```objc\n#import \"TestModel.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation TestModel\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    unsigned int outCount = 0;\n    Ivar *vars = class_copyIvarList([self class], &outCount);\n    for (int i = 0; i < outCount; i ++) {\n        Ivar var = vars[i];\n        const char *name = ivar_getName(var);\n        NSString *key = [NSString stringWithUTF8String:name];\n        \n        // 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法\n        // 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值\n        // 所以这里不需要再另外处理成员变量名称的“_”前缀\n        id value = [self valueForKey:key];\n        [aCoder encodeObject:value forKey:key];\n    }\n    free(vars);\n}\n\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        unsigned int outCount = 0;\n        Ivar *vars = class_copyIvarList([self class], &outCount);\n        for (int i = 0; i < outCount; i ++) {\n            Ivar var = vars[i];\n            const char *name = ivar_getName(var);\n            NSString *key = [NSString stringWithUTF8String:name];\n            id value = [aDecoder decodeObjectForKey:key];\n            [self setValue:value forKey:key];\n        }\n        free(vars);\n    }\n    return self;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyedArchiverTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    \n    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;\n    path = [path stringByAppendingPathComponent:@\"test\"];\n    [NSKeyedArchiver archiveRootObject:model toFile:path];\n    \n    TestModel *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n    NSLog(@\"m.name is %@\",m.name);\n    NSLog(@\"m.son name is %@\",m.son.name);\n}\n```\n\n## 动态方法解析与消息转发\n### 原理\n消息转发的大致过程如图：\n\n![消息转发流程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true)\n\n1. 当 Runtime 系统在`Cache`和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用`resolveInstanceMethod:`或`resolveClassMethod:`(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回`NO`，则进入下一步，若返回`YES`，则通过 `class_addMethod` 函数动态地添加方法，消息得到处理，此流程完毕.\n2. `resolveInstanceMethod:` 方法返回 `NO` 时，就会进入 `forwardingTargetForSelector:` 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 `selector`。返回`nil`，进入下一步，返回某个对象，则会调用该对象的方法.\n3. 若 `forwardingTargetForSelector:` 返回的是`nil`，则我们首先要通过 `methodSignatureForSelector:` 来指定方法签名，返回`nil`，表示不处理，若返回方法签名，则会进入下一步.\n4. 当第 `methodSignatureForSelector:` 方法返回方法签名后，就会调用 `forwardInvocation:` 方法，我们可以通过 `anInvocation` 对象做很多处理，比如修改实现方法，修改响应对象等.\n5. 如果到最后，消息还是没有得到响应，程序就会crash.\n\n### 示例：\n```objc\n#import \"Monkey.h\"\n#import \"Bird.h\"\n#import <objc/runtime.h>\n\n@implementation Monkey\n\n-(void)jump{\n    NSLog(@\"monkey can not fly, but! monkey can jump\");\n}\n\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    /*\n     如果当前对象调用了一个不存在的方法\n     Runtime会调用resolveInstanceMethod:来进行动态方法解析\n     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作\n     返回NO，则进入下一步forwardingTargetForSelector:\n     */\n    \n\tif(sel == @selector(fly)){\n    \tclass_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(\"jump\")), \"v@:\");\n    \treturn YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n    \n    /*\n     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会\n     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象\n     返回nil则进步下一步forwardInvocation:\n     */\n    \n#if 0\n    return nil;\n#else\n    return [[Bird alloc] init];\n#endif\n}\n\n-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    /*\n     获取方法签名进入下一步，进行消息转发\n     */\n    \n    return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n}\n\n-(void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    /*\n     消息转发\n     */\n    \n    return [anInvocation invokeWithTarget:[[Bird alloc] init]];\n}\n\n@end\n```\n\n其中 `\"v@:\"` 表示返回值和参数,这个符号涉及[Type Encoding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)以及[关于type encodings的理解--runtime programming guide](http://www.jianshu.com/p/f4129b5194c0)。\n\n---\n其中**v**表示返回`void`类型，**@**表示参数`id(self)`，**：**表示`SEL(_cmd)`这几个是必须要有的，后面可以接入参类型。\n\n举个例子：`\"i@:@\"`\n**i**表示返回值类型`int`\n**@：**和上面意义相同\n**@**最后一个@表示有一个入参，是`id`类型。\n\n不过，实际上，这个东西好像没什么用，因为在`class_addMethod`上试验过，随便传任何字符串都一样能正常运行。\n\n---\n一般来说可以使用`method_getTypeEncoding()`获取更详细的Type_Encoding,下面例子中也会用到。\n\n### 转发与多继承\n转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。\n![runtime_transmit](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true)\n\n这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中`Warrior`和`Diplomat`没有继承关系，但是`Warrior`将`negotiate`消息转发给了`Diplomat`后，就好似`Diplomat`是`Warrior`的超类一样。\n\n消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。\n\n## Runtime-动态创建类添加属性和方法\n```objc\n- (void)createClass\n{\n    Class MyClass = objc_allocateClassPair([NSObject class], \"myclass\", 0);\n    //添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型\n    if (class_addIvar(MyClass, \"itest\", sizeof(NSString *), 0, \"@\")) {\n        NSLog(@\"add ivar success\");\n    }\n    //myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding\n    class_addMethod(MyClass, @selector(myclasstest:), (IMP)myclasstest, \"v@:\");\n    //注册这个类到runtime系统中就可以使用他了\n    objc_registerClassPair(MyClass);\n    //生成了一个实例化对象\n    id myobj = [[MyClass alloc] init];\n    NSString *str = @\"asdb\";\n    //给刚刚添加的变量赋值\n    //    object_setInstanceVariable(myobj, \"itest\", (void *)&str);在ARC下不允许使用\n    [myobj setValue:str forKey:@\"itest\"];\n    //调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息\n    [myobj myclasstest:10];\n\n}\n//这个方法实际上没有被调用,但是必须实现否则编译都不能通过\n- (void)myclasstest:(int)a\n{\n    \n}\n//调用的是这个方法\nstatic void myclasstest(id self, SEL _cmd, int a) //self和_cmd是必须的，在之后可以随意添加其他参数\n{\n    \n    Ivar v = class_getInstanceVariable([self class], \"itest\");\n    //返回名为itest的ivar的变量的值\n    id o = object_getIvar(self, v);\n    //成功打印出结果\n    NSLog(@\"%@\", o);\n    NSLog(@\"int a is %d\", a);\n}\n```\n\n## Method Swizzling\n此部分参考自[Objective-C的方法替换](http://blog.csdn.net/horkychen/article/details/8532087)、[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)等系列文章\n### 例子\n```objc\n#import <objc/runtime.h> \n \n@implementation UIViewController (Tracking) \n \n+ (void)load { \n    static dispatch_once_t onceToken; \n    dispatch_once(&onceToken, ^{ \n        Class aClass = [self class]; \n \n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n        \n        // When swizzling a class method, use the following:\n        // Class aClass = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(aClass, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n \n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n \n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        } \n    }); \n} \n \n#pragma mark - Method Swizzling \n \n- (void)xxx_viewWillAppear:(BOOL)animated { \n    [self xxx_viewWillAppear:animated]; \n    NSLog(@\"viewWillAppear: %@\", self); \n} \n \n@end\n```\n\n### 原理\n#### 概述\n在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。\n\n每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图\n![runtime_swizzling_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true)\n\n通过Swizzling需要实现的是偷换selector的IMP，如下图所示：\n![runtime_swizzling_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true)\n\n#### 实现过程\n上面的代码通过添加一个`Tracking`类别到`UIViewController`类中，将`UIViewController`类的`viewWillAppear:`方法和`Tracking`类别中`xxx_viewWillAppear:`方法的实现相互调换。Swizzling 应该在`+load`方法中实现，因为`+load`是在一个类最开始加载时调用。`dispatch_once`是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。\n\n实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉`UIViewController`中的`viewWillAppear:`方法。这两种情况要区别对待。\n\n对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(`xxx_viewWillAppear:`)，然后将复写的方法替换为原先的实现(`viewWillAppear:`).\n\n```objc\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n```\n`class_addMethod`将本来不存在于被操作的Class里的`swizzledMethod`的实现添加在被操作的Class里,并使用`originalSelector`作为其选择子。如果发现方法已经存在，会失败返回。\n\n---\n通过上一篇[runtime原理](https://zhang759740844.github.io/2016/08/22/runtime原理/)的分析，`class_addMethod`应该是先在类的method数组里找是否有这个`SEL`,如果没有就添加一个`method_t`。\n\n---\n\n如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:\n```objc\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n```\n`addMethod`会让当前类的方法(IMP)指向新的实现(SEL)，使用`replaceMethod`再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法`SEL`来调用，就会实现新方法的`IMP`，通过新方法的`SEL`来调用，就会实现旧方法的`IMP`。\n\n如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过`method_exchangeImplementations`直接交换两个`method_t`的`IMP`:\n```objc\nelse {\n    method_exchangeImplementations(originalMethod, overrideMethod);\n}\n```\n\n所以本例中由于`viewWillAppear:`已经在UIViewController中实现过了，所以，`class_addMethod`失败，通过`method_exchangeImplementations`达到交换实现。如果要通过`class_addMethod`添加，需要自定义一个View继承UIViewController，再在这个类中替换`viewWillAppear:`。\n\n\n如果类中没有想被替换实现的原方法时，`class_replaceMethod`相当于直接调用`class_addMethod`向类中添加该方法的实现。\n\n`method_exchangeImplementations`方法做的事情与如下的原子操作等价：\n```objc\nIMP imp1 = method_getImplementation(m1);\nIMP imp2 = method_getImplementation(m2);\nmethod_setImplementation(m1, imp2);\nmethod_setImplementation(m2, imp1);\n```\n直接设置了`method`:`m1`,`m2`的`IMP`，简单暴力。\n\n对于注释了的这几行:\n```objc\n// When swizzling a class method, use the following:\n// Class aClass = object_getClass((id)self);\n// ...\n// Method originalMethod = class_getClassMethod(aClass, originalSelector);\n// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n```\n`object_getClass((id)self)` 与 `[self class]` 返回的结果类型都是 `Class`,但前者为元类,后者为其本身,因为此时 `self` 为 `Class` 而不是实例.注意 `[NSObject class]` 与 `[object实例 class]` 的区别：\n```objc\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n`object_getClass()`方法返回对象的`isa`。\n\n最后，`xxx_viewWillAppear:`方法的定义看似是递归调用引发死循环，其实不会的。因为`[self xxx_viewWillAppear:animated]`消息会动态找到`xxx_viewWillAppear:`方法的实现，而它的实现已经被我们与`viewWillAppear:`方法实现进行了互换，所以这段代码不仅不会死循环，如果你把`[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]`反而会引发死循环。\n\n> Demo 详见RuntimeLearn\n\n\n","slug":"runtime应用","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxd005d7hzgmyzt8eij","content":"<p>了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考<a href=\"http://www.jianshu.com/p/efeb33712445\" target=\"_blank\" rel=\"external\">Runtime全方位装逼指南</a>，总结了以下几点应用场景。</p>\n<a id=\"more\"></a>\n<h2 id=\"给category添加属性\"><a href=\"#给category添加属性\" class=\"headerlink\" title=\"给category添加属性\"></a>给category添加属性</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>对象关联</strong>允许开发者对已经存在的类在 Category 中添加自定义的属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>object 是源对象.</li>\n<li>value 是被关联的对象.</li>\n<li>key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.</li>\n<li>policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </span></div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </span></div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</span></div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</span></div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>\n<p>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</p>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><p>新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中设置click的set，get方法(UIButton+ClickBlock.m):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+ClickBlock.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *associatedKey = <span class=\"string\">\"associatedKey\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(clickBlock)click&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)buttonClick&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.click();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>其中，在set方法中使用<code>addTarget:action:forControlEvents:</code>给button设置了点击事件。</p>\n<p><code>self.click()</code>表示使用<code>self.click</code>获得block，再通过<code>block()</code>执行块。</p>\n<p>为什么不直接给click赋值，而是通过runtime的<code>objc_setAssociatedObject</code>方法呢？<br>@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。</p>\n<p>@property在本例中只是为了在.h里声明一个getset方法。可替换成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"comment\">//@property (nonatomic,copy) clickBlock click;</span></div><div class=\"line\">- (clickBlock)click;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setClick:(clickBlock)click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"字典与模型转换\"><a href=\"#字典与模型转换\" class=\"headerlink\" title=\"字典与模型转换\"></a>字典与模型转换</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>字典转模型的时候：</p>\n<ol>\n<li>根据字典的 key 生成 setter 方法.</li>\n<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>\n</ol>\n<p>模型转字典的时候：</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSObject+KeyValues.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典转模型</span></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> aDictionary.allKeys) &#123;</div><div class=\"line\">        <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">        objc_property_t property = class_getProperty(<span class=\"keyword\">self</span>, key.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class=\"line\">        objc_property_attribute_t attribute = attributeList[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *typeString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:attribute.value];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([typeString isEqualToString:<span class=\"string\">@\"@\\\"TestModel\\\"\"</span>]) &#123;</div><div class=\"line\">            value = [<span class=\"keyword\">self</span> objectWithKeyValues:value];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**********************/</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成setter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"set%@%@:\"</span>,[key substringToIndex:<span class=\"number\">1</span>].uppercaseString,[key substringFromIndex:<span class=\"number\">1</span>]];</div><div class=\"line\">        SEL <span class=\"keyword\">setter</span> = sel_registerName(methodName.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([objc respondsToSelector:<span class=\"keyword\">setter</span>]) &#123;</div><div class=\"line\">            ((<span class=\"keyword\">void</span> (*) (<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">id</span>)) objc_msgSend) (objc,<span class=\"keyword\">setter</span>,value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(attributeList);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//模型转字典</span></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    objc_property_t *propertyList = class_copyPropertyList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        objc_property_t property = propertyList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成getter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(property);</div><div class=\"line\">        SEL <span class=\"keyword\">getter</span> = sel_registerName(propertyName);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">getter</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">id</span> value = ((<span class=\"keyword\">id</span> (*) (<span class=\"keyword\">id</span>,SEL)) objc_msgSend) (<span class=\"keyword\">self</span>,<span class=\"keyword\">getter</span>);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]] &amp;&amp; value) &#123;</div><div class=\"line\">                value = [value keyValuesWithObject];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**********************/</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (value) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName];</div><div class=\"line\">                [dict setObject:value forKey:key];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    free(propertyList);</div><div class=\"line\">    <span class=\"keyword\">return</span> dict;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyValuesTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name is %@\"</span>,model.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"son name is %@\"</span>,model.son.name);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *dict = [model keyValuesWithObject];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"dict is %@\"</span>,dict);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在NSObject中添加类方法，其中的<code>self</code>指的是<code>TestModel</code>这个类。</li>\n<li><code>objc_property_t</code>具有两个属性，name和attribute。调用<code>property_getAttribute</code>将返回attribute的字符串。调用<code>property_copyAttributeList</code>则将字符串切分，返回一个<code>objc_property_attribute_t</code>类型的指针，<code>outCount</code>返回了属性的数量。</li>\n</ol>\n<hr>\n<p>outCount使用了<strong>指向指针的指针</strong>的方式，使没有返回outCount的情况下，修改了outCount的值。</p>\n<p>例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)scanBeginStr:(<span class=\"built_in\">NSString</span> *)beginstr endStr:(<span class=\"built_in\">NSString</span> *)endstr inText:(<span class=\"built_in\">NSMutableString</span> * *)textPointer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> range1,range2;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> location =<span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">    range1.location = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *text = *textPointer;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *rangeArray = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">    <span class=\"keyword\">while</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">        range1 = [text rangeOfString:beginstr];</div><div class=\"line\">        range2 = [text rangeOfString:endstr];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            location = range1.location;</div><div class=\"line\">            length = range2.location - range1.location - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">5000</span>)<span class=\"keyword\">break</span>;</div><div class=\"line\">            [text replaceOccurrencesOfString:beginstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range1.location + range1.length)];</div><div class=\"line\">            [text replaceOccurrencesOfString:endstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range2.location + range2.length - <span class=\"number\">1</span>)];</div><div class=\"line\">        &#125;</div><div class=\"line\">        [rangeArray addObject:@&#123;<span class=\"string\">@\"location\"</span>:@(location),<span class=\"string\">@\"length\"</span>:@(length)&#125;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rangeArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用：通过&amp;取指针的地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText];</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"自动归档\"><a href=\"#自动归档\" class=\"headerlink\" title=\"自动归档\"></a>自动归档</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.ID forKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.ID = [aDecoder decodeObjectForKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：</p>\n<ol>\n<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>\n<li>使用 ivar_getName 方法获取成员变量的名称.</li>\n<li>通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</li>\n</ol>\n<h3 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TestModel.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestModel</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        Ivar var = vars[i];</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></div><div class=\"line\">        <span class=\"comment\">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></div><div class=\"line\">        <span class=\"comment\">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = [<span class=\"keyword\">self</span> valueForKey:key];</div><div class=\"line\">        [aCoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">            Ivar var = vars[i];</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">            <span class=\"keyword\">id</span> value = [aDecoder decodeObjectForKey:key];</div><div class=\"line\">            [<span class=\"keyword\">self</span> setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(vars);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyedArchiverTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).lastObject;</div><div class=\"line\">    path = [path stringByAppendingPathComponent:<span class=\"string\">@\"test\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:model toFile:path];</div><div class=\"line\">    </div><div class=\"line\">    TestModel *m = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.name is %@\"</span>,m.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.son name is %@\"</span>,m.son.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"动态方法解析与消息转发\"><a href=\"#动态方法解析与消息转发\" class=\"headerlink\" title=\"动态方法解析与消息转发\"></a>动态方法解析与消息转发</h2><h3 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>消息转发的大致过程如图：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true\" alt=\"消息转发流程\"></p>\n<ol>\n<li>当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回<code>NO</code>，则进入下一步，若返回<code>YES</code>，则通过 <code>class_addMethod</code> 函数动态地添加方法，消息得到处理，此流程完毕.</li>\n<li><code>resolveInstanceMethod:</code> 方法返回 <code>NO</code> 时，就会进入 <code>forwardingTargetForSelector:</code> 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 <code>selector</code>。返回<code>nil</code>，进入下一步，返回某个对象，则会调用该对象的方法.</li>\n<li>若 <code>forwardingTargetForSelector:</code> 返回的是<code>nil</code>，则我们首先要通过 <code>methodSignatureForSelector:</code> 来指定方法签名，返回<code>nil</code>，表示不处理，若返回方法签名，则会进入下一步.</li>\n<li>当第 <code>methodSignatureForSelector:</code> 方法返回方法签名后，就会调用 <code>forwardInvocation:</code> 方法，我们可以通过 <code>anInvocation</code> 对象做很多处理，比如修改实现方法，修改响应对象等.</li>\n<li>如果到最后，消息还是没有得到响应，程序就会crash.</li>\n</ol>\n<h3 id=\"示例：-2\"><a href=\"#示例：-2\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Monkey.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Bird.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Monkey</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)jump&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"monkey can not fly, but! monkey can jump\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     如果当前对象调用了一个不存在的方法</div><div class=\"line\">     Runtime会调用resolveInstanceMethod:来进行动态方法解析</div><div class=\"line\">     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作</div><div class=\"line\">     返回NO，则进入下一步forwardingTargetForSelector:</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"keyword\">if</span>(sel == <span class=\"keyword\">@selector</span>(fly))&#123;</div><div class=\"line\">    \tclass_addMethod(<span class=\"keyword\">self</span>, sel, class_getMethodImplementation(<span class=\"keyword\">self</span>, sel_registerName(<span class=\"string\">\"jump\"</span>)), <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会</div><div class=\"line\">     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象</div><div class=\"line\">     返回nil则进步下一步forwardInvocation:</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">#if 0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\">    <span class=\"keyword\">return</span> [[Bird alloc] init];</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     获取方法签名进入下一步，进行消息转发</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     消息转发</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [anInvocation invokeWithTarget:[[Bird alloc] init]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中 <code>&quot;v@:&quot;</code> 表示返回值和参数,这个符号涉及<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\" target=\"_blank\" rel=\"external\">Type Encoding</a>以及<a href=\"http://www.jianshu.com/p/f4129b5194c0\" target=\"_blank\" rel=\"external\">关于type encodings的理解–runtime programming guide</a>。</p>\n<hr>\n<p>其中<strong>v</strong>表示返回<code>void</code>类型，<strong>@</strong>表示参数<code>id(self)</code>，<strong>：</strong>表示<code>SEL(_cmd)</code>这几个是必须要有的，后面可以接入参类型。</p>\n<p>举个例子：<code>&quot;i@:@&quot;</code><br><strong>i</strong>表示返回值类型<code>int</code><br><strong>@：</strong>和上面意义相同<br><strong>@</strong>最后一个@表示有一个入参，是<code>id</code>类型。</p>\n<p>不过，实际上，这个东西好像没什么用，因为在<code>class_addMethod</code>上试验过，随便传任何字符串都一样能正常运行。</p>\n<hr>\n<p>一般来说可以使用<code>method_getTypeEncoding()</code>获取更详细的Type_Encoding,下面例子中也会用到。</p>\n<h3 id=\"转发与多继承\"><a href=\"#转发与多继承\" class=\"headerlink\" title=\"转发与多继承\"></a>转发与多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true\" alt=\"runtime_transmit\"></p>\n<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>\n<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>\n<h2 id=\"Runtime-动态创建类添加属性和方法\"><a href=\"#Runtime-动态创建类添加属性和方法\" class=\"headerlink\" title=\"Runtime-动态创建类添加属性和方法\"></a>Runtime-动态创建类添加属性和方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)createClass</div><div class=\"line\">&#123;</div><div class=\"line\">    Class MyClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"myclass\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (class_addIvar(MyClass, <span class=\"string\">\"itest\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">NSString</span> *), <span class=\"number\">0</span>, <span class=\"string\">\"@\"</span>)) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"add ivar success\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding</span></div><div class=\"line\">    class_addMethod(MyClass, <span class=\"keyword\">@selector</span>(myclasstest:), (IMP)myclasstest, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    <span class=\"comment\">//注册这个类到runtime系统中就可以使用他了</span></div><div class=\"line\">    objc_registerClassPair(MyClass);</div><div class=\"line\">    <span class=\"comment\">//生成了一个实例化对象</span></div><div class=\"line\">    <span class=\"keyword\">id</span> myobj = [[MyClass alloc] init];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"asdb\"</span>;</div><div class=\"line\">    <span class=\"comment\">//给刚刚添加的变量赋值</span></div><div class=\"line\">    <span class=\"comment\">//    object_setInstanceVariable(myobj, \"itest\", (void *)&amp;str);在ARC下不允许使用</span></div><div class=\"line\">    [myobj setValue:str forKey:<span class=\"string\">@\"itest\"</span>];</div><div class=\"line\">    <span class=\"comment\">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></div><div class=\"line\">    [myobj myclasstest:<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这个方法实际上没有被调用,但是必须实现否则编译都不能通过</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myclasstest:(<span class=\"keyword\">int</span>)a</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//调用的是这个方法</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> myclasstest(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">int</span> a) <span class=\"comment\">//self和_cmd是必须的，在之后可以随意添加其他参数</span></div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    Ivar v = class_getInstanceVariable([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"itest\"</span>);</div><div class=\"line\">    <span class=\"comment\">//返回名为itest的ivar的变量的值</span></div><div class=\"line\">    <span class=\"keyword\">id</span> o = object_getIvar(<span class=\"keyword\">self</span>, v);</div><div class=\"line\">    <span class=\"comment\">//成功打印出结果</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, o);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int a is %d\"</span>, a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h2><p>此部分参考自<a href=\"http://blog.csdn.net/horkychen/article/details/8532087\" target=\"_blank\" rel=\"external\">Objective-C的方法替换</a>、<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C Runtime</a>等系列文章</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span> </span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>) </span></div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123; </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken; </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class=\"line\">        Class aClass = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; </div><div class=\"line\"> </div><div class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:); </div><div class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:); </div><div class=\"line\"> </div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\">        <span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">            class_addMethod(aClass, </div><div class=\"line\">                originalSelector, </div><div class=\"line\">                method_getImplementation(swizzledMethod), </div><div class=\"line\">                method_getTypeEncoding(swizzledMethod)); </div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">            class_replaceMethod(aClass, </div><div class=\"line\">                swizzledSelector, </div><div class=\"line\">                method_getImplementation(originalMethod), </div><div class=\"line\">                method_getTypeEncoding(originalMethod)); </div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling </span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123; </div><div class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated]; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>\n<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true\" alt=\"runtime_swizzling_1\"></p>\n<p>通过Swizzling需要实现的是偷换selector的IMP，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true\" alt=\"runtime_swizzling_2\"></p>\n<h4 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h4><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>\n<p>实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉<code>UIViewController</code>中的<code>viewWillAppear:</code>方法。这两种情况要区别对待。</p>\n<p>对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(<code>xxx_viewWillAppear:</code>)，然后将复写的方法替换为原先的实现(<code>viewWillAppear:</code>).</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">    class_addMethod(aClass, </div><div class=\"line\">        originalSelector, </div><div class=\"line\">        method_getImplementation(swizzledMethod), </div><div class=\"line\">        method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure>\n<p><code>class_addMethod</code>将本来不存在于被操作的Class里的<code>swizzledMethod</code>的实现添加在被操作的Class里,并使用<code>originalSelector</code>作为其选择子。如果发现方法已经存在，会失败返回。</p>\n<hr>\n<p>通过上一篇<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime原理</a>的分析，<code>class_addMethod</code>应该是先在类的method数组里找是否有这个<code>SEL</code>,如果没有就添加一个<code>method_t</code>。</p>\n<hr>\n<p>如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">    class_replaceMethod(aClass, </div><div class=\"line\">        swizzledSelector, </div><div class=\"line\">        method_getImplementation(originalMethod), </div><div class=\"line\">        method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>\n<p><code>addMethod</code>会让当前类的方法(IMP)指向新的实现(SEL)，使用<code>replaceMethod</code>再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法<code>SEL</code>来调用，就会实现新方法的<code>IMP</code>，通过新方法的<code>SEL</code>来调用，就会实现旧方法的<code>IMP</code>。</p>\n<p>如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过<code>method_exchangeImplementations</code>直接交换两个<code>method_t</code>的<code>IMP</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    method_exchangeImplementations(originalMethod, overrideMethod);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以本例中由于<code>viewWillAppear:</code>已经在UIViewController中实现过了，所以，<code>class_addMethod</code>失败，通过<code>method_exchangeImplementations</code>达到交换实现。如果要通过<code>class_addMethod</code>添加，需要自定义一个View继承UIViewController，再在这个类中替换<code>viewWillAppear:</code>。</p>\n<p>如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现。</p>\n<p><code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">method_setImplementation(m1, imp2);</div><div class=\"line\">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>\n<p>直接设置了<code>method</code>:<code>m1</code>,<code>m2</code>的<code>IMP</code>，简单暴力。</p>\n<p>对于注释了的这几行:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\"><span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"><span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\"><span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure></p>\n<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object实例 class]</code> 的区别：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>object_getClass()</code>方法返回对象的<code>isa</code>。</p>\n<p>最后，<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]</code>反而会引发死循环。</p>\n<blockquote>\n<p>Demo 详见RuntimeLearn</p>\n</blockquote>\n","excerpt":"<p>了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考<a href=\"http://www.jianshu.com/p/efeb33712445\">Runtime全方位装逼指南</a>，总结了以下几点应用场景。</p>","more":"<h2 id=\"给category添加属性\"><a href=\"#给category添加属性\" class=\"headerlink\" title=\"给category添加属性\"></a>给category添加属性</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>对象关联</strong>允许开发者对已经存在的类在 Category 中添加自定义的属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>object 是源对象.</li>\n<li>value 是被关联的对象.</li>\n<li>key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.</li>\n<li>policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </div><div class=\"line\">                                            *   The association is not made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </div><div class=\"line\">                                            *   The association is not made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</div><div class=\"line\">                                            *   The association is made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</div><div class=\"line\">                                            *   The association is made atomically. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>\n<p>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</p>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><p>新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中设置click的set，get方法(UIButton+ClickBlock.m):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+ClickBlock.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *associatedKey = <span class=\"string\">\"associatedKey\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(clickBlock)click&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)buttonClick&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.click();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>其中，在set方法中使用<code>addTarget:action:forControlEvents:</code>给button设置了点击事件。</p>\n<p><code>self.click()</code>表示使用<code>self.click</code>获得block，再通过<code>block()</code>执行块。</p>\n<p>为什么不直接给click赋值，而是通过runtime的<code>objc_setAssociatedObject</code>方法呢？<br>@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。</p>\n<p>@property在本例中只是为了在.h里声明一个getset方法。可替换成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"comment\">//@property (nonatomic,copy) clickBlock click;</span></div><div class=\"line\">- (clickBlock)click;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setClick:(clickBlock)click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"字典与模型转换\"><a href=\"#字典与模型转换\" class=\"headerlink\" title=\"字典与模型转换\"></a>字典与模型转换</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>字典转模型的时候：</p>\n<ol>\n<li>根据字典的 key 生成 setter 方法.</li>\n<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>\n</ol>\n<p>模型转字典的时候：</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSObject+KeyValues.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典转模型</span></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> aDictionary.allKeys) &#123;</div><div class=\"line\">        <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">        objc_property_t property = class_getProperty(<span class=\"keyword\">self</span>, key.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class=\"line\">        objc_property_attribute_t attribute = attributeList[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *typeString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:attribute.value];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([typeString isEqualToString:<span class=\"string\">@\"@\\\"TestModel\\\"\"</span>]) &#123;</div><div class=\"line\">            value = [<span class=\"keyword\">self</span> objectWithKeyValues:value];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**********************/</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成setter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"set%@%@:\"</span>,[key substringToIndex:<span class=\"number\">1</span>].uppercaseString,[key substringFromIndex:<span class=\"number\">1</span>]];</div><div class=\"line\">        SEL <span class=\"keyword\">setter</span> = sel_registerName(methodName.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([objc respondsToSelector:<span class=\"keyword\">setter</span>]) &#123;</div><div class=\"line\">            ((<span class=\"keyword\">void</span> (*) (<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">id</span>)) objc_msgSend) (objc,<span class=\"keyword\">setter</span>,value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(attributeList);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//模型转字典</span></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    objc_property_t *propertyList = class_copyPropertyList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        objc_property_t property = propertyList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成getter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(property);</div><div class=\"line\">        SEL <span class=\"keyword\">getter</span> = sel_registerName(propertyName);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">getter</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">id</span> value = ((<span class=\"keyword\">id</span> (*) (<span class=\"keyword\">id</span>,SEL)) objc_msgSend) (<span class=\"keyword\">self</span>,<span class=\"keyword\">getter</span>);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]] &amp;&amp; value) &#123;</div><div class=\"line\">                value = [value keyValuesWithObject];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**********************/</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (value) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName];</div><div class=\"line\">                [dict setObject:value forKey:key];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    free(propertyList);</div><div class=\"line\">    <span class=\"keyword\">return</span> dict;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyValuesTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name is %@\"</span>,model.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"son name is %@\"</span>,model.son.name);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *dict = [model keyValuesWithObject];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"dict is %@\"</span>,dict);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在NSObject中添加类方法，其中的<code>self</code>指的是<code>TestModel</code>这个类。</li>\n<li><code>objc_property_t</code>具有两个属性，name和attribute。调用<code>property_getAttribute</code>将返回attribute的字符串。调用<code>property_copyAttributeList</code>则将字符串切分，返回一个<code>objc_property_attribute_t</code>类型的指针，<code>outCount</code>返回了属性的数量。</li>\n</ol>\n<hr>\n<p>outCount使用了<strong>指向指针的指针</strong>的方式，使没有返回outCount的情况下，修改了outCount的值。</p>\n<p>例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)scanBeginStr:(<span class=\"built_in\">NSString</span> *)beginstr endStr:(<span class=\"built_in\">NSString</span> *)endstr inText:(<span class=\"built_in\">NSMutableString</span> * *)textPointer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> range1,range2;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> location =<span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">    range1.location = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *text = *textPointer;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *rangeArray = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">    <span class=\"keyword\">while</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">        range1 = [text rangeOfString:beginstr];</div><div class=\"line\">        range2 = [text rangeOfString:endstr];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            location = range1.location;</div><div class=\"line\">            length = range2.location - range1.location - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">5000</span>)<span class=\"keyword\">break</span>;</div><div class=\"line\">            [text replaceOccurrencesOfString:beginstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range1.location + range1.length)];</div><div class=\"line\">            [text replaceOccurrencesOfString:endstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range2.location + range2.length - <span class=\"number\">1</span>)];</div><div class=\"line\">        &#125;</div><div class=\"line\">        [rangeArray addObject:@&#123;<span class=\"string\">@\"location\"</span>:@(location),<span class=\"string\">@\"length\"</span>:@(length)&#125;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rangeArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用：通过&amp;取指针的地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText];</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"自动归档\"><a href=\"#自动归档\" class=\"headerlink\" title=\"自动归档\"></a>自动归档</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.ID forKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.ID = [aDecoder decodeObjectForKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：</p>\n<ol>\n<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>\n<li>使用 ivar_getName 方法获取成员变量的名称.</li>\n<li>通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</li>\n</ol>\n<h3 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TestModel.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestModel</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        Ivar var = vars[i];</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></div><div class=\"line\">        <span class=\"comment\">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></div><div class=\"line\">        <span class=\"comment\">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = [<span class=\"keyword\">self</span> valueForKey:key];</div><div class=\"line\">        [aCoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">            Ivar var = vars[i];</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">            <span class=\"keyword\">id</span> value = [aDecoder decodeObjectForKey:key];</div><div class=\"line\">            [<span class=\"keyword\">self</span> setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(vars);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyedArchiverTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).lastObject;</div><div class=\"line\">    path = [path stringByAppendingPathComponent:<span class=\"string\">@\"test\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:model toFile:path];</div><div class=\"line\">    </div><div class=\"line\">    TestModel *m = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.name is %@\"</span>,m.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.son name is %@\"</span>,m.son.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"动态方法解析与消息转发\"><a href=\"#动态方法解析与消息转发\" class=\"headerlink\" title=\"动态方法解析与消息转发\"></a>动态方法解析与消息转发</h2><h3 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>消息转发的大致过程如图：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true\" alt=\"消息转发流程\"></p>\n<ol>\n<li>当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回<code>NO</code>，则进入下一步，若返回<code>YES</code>，则通过 <code>class_addMethod</code> 函数动态地添加方法，消息得到处理，此流程完毕.</li>\n<li><code>resolveInstanceMethod:</code> 方法返回 <code>NO</code> 时，就会进入 <code>forwardingTargetForSelector:</code> 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 <code>selector</code>。返回<code>nil</code>，进入下一步，返回某个对象，则会调用该对象的方法.</li>\n<li>若 <code>forwardingTargetForSelector:</code> 返回的是<code>nil</code>，则我们首先要通过 <code>methodSignatureForSelector:</code> 来指定方法签名，返回<code>nil</code>，表示不处理，若返回方法签名，则会进入下一步.</li>\n<li>当第 <code>methodSignatureForSelector:</code> 方法返回方法签名后，就会调用 <code>forwardInvocation:</code> 方法，我们可以通过 <code>anInvocation</code> 对象做很多处理，比如修改实现方法，修改响应对象等.</li>\n<li>如果到最后，消息还是没有得到响应，程序就会crash.</li>\n</ol>\n<h3 id=\"示例：-2\"><a href=\"#示例：-2\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Monkey.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Bird.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Monkey</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)jump&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"monkey can not fly, but! monkey can jump\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     如果当前对象调用了一个不存在的方法</div><div class=\"line\">     Runtime会调用resolveInstanceMethod:来进行动态方法解析</div><div class=\"line\">     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作</div><div class=\"line\">     返回NO，则进入下一步forwardingTargetForSelector:</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"keyword\">if</span>(sel == <span class=\"keyword\">@selector</span>(fly))&#123;</div><div class=\"line\">    \tclass_addMethod(<span class=\"keyword\">self</span>, sel, class_getMethodImplementation(<span class=\"keyword\">self</span>, sel_registerName(<span class=\"string\">\"jump\"</span>)), <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会</div><div class=\"line\">     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象</div><div class=\"line\">     返回nil则进步下一步forwardInvocation:</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">#if 0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\">    <span class=\"keyword\">return</span> [[Bird alloc] init];</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     获取方法签名进入下一步，进行消息转发</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     消息转发</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [anInvocation invokeWithTarget:[[Bird alloc] init]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中 <code>&quot;v@:&quot;</code> 表示返回值和参数,这个符号涉及<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\">Type Encoding</a>以及<a href=\"http://www.jianshu.com/p/f4129b5194c0\">关于type encodings的理解–runtime programming guide</a>。</p>\n<hr>\n<p>其中<strong>v</strong>表示返回<code>void</code>类型，<strong>@</strong>表示参数<code>id(self)</code>，<strong>：</strong>表示<code>SEL(_cmd)</code>这几个是必须要有的，后面可以接入参类型。</p>\n<p>举个例子：<code>&quot;i@:@&quot;</code><br><strong>i</strong>表示返回值类型<code>int</code><br><strong>@：</strong>和上面意义相同<br><strong>@</strong>最后一个@表示有一个入参，是<code>id</code>类型。</p>\n<p>不过，实际上，这个东西好像没什么用，因为在<code>class_addMethod</code>上试验过，随便传任何字符串都一样能正常运行。</p>\n<hr>\n<p>一般来说可以使用<code>method_getTypeEncoding()</code>获取更详细的Type_Encoding,下面例子中也会用到。</p>\n<h3 id=\"转发与多继承\"><a href=\"#转发与多继承\" class=\"headerlink\" title=\"转发与多继承\"></a>转发与多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true\" alt=\"runtime_transmit\"></p>\n<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>\n<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>\n<h2 id=\"Runtime-动态创建类添加属性和方法\"><a href=\"#Runtime-动态创建类添加属性和方法\" class=\"headerlink\" title=\"Runtime-动态创建类添加属性和方法\"></a>Runtime-动态创建类添加属性和方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)createClass</div><div class=\"line\">&#123;</div><div class=\"line\">    Class MyClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"myclass\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (class_addIvar(MyClass, <span class=\"string\">\"itest\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">NSString</span> *), <span class=\"number\">0</span>, <span class=\"string\">\"@\"</span>)) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"add ivar success\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding</span></div><div class=\"line\">    class_addMethod(MyClass, <span class=\"keyword\">@selector</span>(myclasstest:), (IMP)myclasstest, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    <span class=\"comment\">//注册这个类到runtime系统中就可以使用他了</span></div><div class=\"line\">    objc_registerClassPair(MyClass);</div><div class=\"line\">    <span class=\"comment\">//生成了一个实例化对象</span></div><div class=\"line\">    <span class=\"keyword\">id</span> myobj = [[MyClass alloc] init];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"asdb\"</span>;</div><div class=\"line\">    <span class=\"comment\">//给刚刚添加的变量赋值</span></div><div class=\"line\">    <span class=\"comment\">//    object_setInstanceVariable(myobj, \"itest\", (void *)&amp;str);在ARC下不允许使用</span></div><div class=\"line\">    [myobj setValue:str forKey:<span class=\"string\">@\"itest\"</span>];</div><div class=\"line\">    <span class=\"comment\">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></div><div class=\"line\">    [myobj myclasstest:<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这个方法实际上没有被调用,但是必须实现否则编译都不能通过</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myclasstest:(<span class=\"keyword\">int</span>)a</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//调用的是这个方法</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> myclasstest(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">int</span> a) <span class=\"comment\">//self和_cmd是必须的，在之后可以随意添加其他参数</span></div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    Ivar v = class_getInstanceVariable([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"itest\"</span>);</div><div class=\"line\">    <span class=\"comment\">//返回名为itest的ivar的变量的值</span></div><div class=\"line\">    <span class=\"keyword\">id</span> o = object_getIvar(<span class=\"keyword\">self</span>, v);</div><div class=\"line\">    <span class=\"comment\">//成功打印出结果</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, o);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int a is %d\"</span>, a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h2><p>此部分参考自<a href=\"http://blog.csdn.net/horkychen/article/details/8532087\">Objective-C的方法替换</a>、<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\">Objective-C Runtime</a>等系列文章</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span> </span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>) </span></div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123; </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken; </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class=\"line\">        Class aClass = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; </div><div class=\"line\"> </div><div class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:); </div><div class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:); </div><div class=\"line\"> </div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\">        <span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">            class_addMethod(aClass, </div><div class=\"line\">                originalSelector, </div><div class=\"line\">                method_getImplementation(swizzledMethod), </div><div class=\"line\">                method_getTypeEncoding(swizzledMethod)); </div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">            class_replaceMethod(aClass, </div><div class=\"line\">                swizzledSelector, </div><div class=\"line\">                method_getImplementation(originalMethod), </div><div class=\"line\">                method_getTypeEncoding(originalMethod)); </div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling </span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123; </div><div class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated]; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>\n<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true\" alt=\"runtime_swizzling_1\"></p>\n<p>通过Swizzling需要实现的是偷换selector的IMP，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true\" alt=\"runtime_swizzling_2\"></p>\n<h4 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h4><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>\n<p>实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉<code>UIViewController</code>中的<code>viewWillAppear:</code>方法。这两种情况要区别对待。</p>\n<p>对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(<code>xxx_viewWillAppear:</code>)，然后将复写的方法替换为原先的实现(<code>viewWillAppear:</code>).</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">    class_addMethod(aClass, </div><div class=\"line\">        originalSelector, </div><div class=\"line\">        method_getImplementation(swizzledMethod), </div><div class=\"line\">        method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure>\n<p><code>class_addMethod</code>将本来不存在于被操作的Class里的<code>swizzledMethod</code>的实现添加在被操作的Class里,并使用<code>originalSelector</code>作为其选择子。如果发现方法已经存在，会失败返回。</p>\n<hr>\n<p>通过上一篇<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime原理</a>的分析，<code>class_addMethod</code>应该是先在类的method数组里找是否有这个<code>SEL</code>,如果没有就添加一个<code>method_t</code>。</p>\n<hr>\n<p>如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">    class_replaceMethod(aClass, </div><div class=\"line\">        swizzledSelector, </div><div class=\"line\">        method_getImplementation(originalMethod), </div><div class=\"line\">        method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>\n<p><code>addMethod</code>会让当前类的方法(IMP)指向新的实现(SEL)，使用<code>replaceMethod</code>再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法<code>SEL</code>来调用，就会实现新方法的<code>IMP</code>，通过新方法的<code>SEL</code>来调用，就会实现旧方法的<code>IMP</code>。</p>\n<p>如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过<code>method_exchangeImplementations</code>直接交换两个<code>method_t</code>的<code>IMP</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    method_exchangeImplementations(originalMethod, overrideMethod);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以本例中由于<code>viewWillAppear:</code>已经在UIViewController中实现过了，所以，<code>class_addMethod</code>失败，通过<code>method_exchangeImplementations</code>达到交换实现。如果要通过<code>class_addMethod</code>添加，需要自定义一个View继承UIViewController，再在这个类中替换<code>viewWillAppear:</code>。</p>\n<p>如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现。</p>\n<p><code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">method_setImplementation(m1, imp2);</div><div class=\"line\">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>\n<p>直接设置了<code>method</code>:<code>m1</code>,<code>m2</code>的<code>IMP</code>，简单暴力。</p>\n<p>对于注释了的这几行:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\"><span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"><span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\"><span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure></p>\n<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object实例 class]</code> 的区别：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>object_getClass()</code>方法返回对象的<code>isa</code>。</p>\n<p>最后，<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]</code>反而会引发死循环。</p>\n<blockquote>\n<p>Demo 详见RuntimeLearn</p>\n</blockquote>"},{"title":"python 3.5 基础语法","date":"2016-08-07T02:07:12.000Z","_content":"\npython还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n  \n\nPython采用缩进方式,写出来的代码就像下面的样子：\n```python\n# print absolute value of an integer:\na = 100\nif a >= 0:\n    print(a)\nelse:\n    print(-a)\n```\n以#开头的语句是注释\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.\n\n### 数据类型和变量\n#### 字符串\n字符串是以单引号'或双引号\"括起来的任意文本.如果字符串内部既包含'又包含\",可以用转义字符\\来标识。\n要计算str包含多少个字符，可以用len()函数。\n%运算符就是用来格式化字符串，如：\n```python\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n```\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.\n\n#### 布尔值\n一个布尔值只有True、False两种值\n布尔值可以用and、or和not运算。\n\n#### 空值\n空值是Python里一个特殊的值，用None表示。\n\n#### 变量\n等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量\n\n### 数组和元组\n#### list\nlist是一种**可变的**有序的集合，用len()函数可以获得list元素的个数\n```python\nclassmates = ['Michael', 'Bob', 'Tracy']\n```\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置\nlist里面的元素的数据类型也可以不同\n列表可以看成一个多维数组 s[2][1]拿到元素。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0\n\n#### tuple\n另一种有序列表叫元组，但是tuple一旦初始化就不能修改\n```python\nclassmates = ('Michael', 'Bob', 'Tracy')\n```\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.\n\n如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下\n```python\nt = (1,)\n```\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义\n\n### 条件判断\nif-else语句实现：\n```python\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n```\n注意不要少写了冒号:\n完全可以用elif做更细致的判断,elif是else if的缩写\n\n### 循环\n#### for...in\n依次把list或tuple中的每个元素迭代出来\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\nPython提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for...in中可以简写成range()\n```python\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n#### while\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n### 容器\n#### dict\n```python\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n```\n**要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key**\n\n#### set\nset和dict类似，**也是一组key的集合**，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，需要**提供一个list作为输入集合**：\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n重复元素在set中自动被过滤\n```python\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n\n\n\n\n\n","source":"_posts/python语法.md","raw":"title: python 3.5 基础语法\ndate: 2016/8/7 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\npython还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n  \n\nPython采用缩进方式,写出来的代码就像下面的样子：\n```python\n# print absolute value of an integer:\na = 100\nif a >= 0:\n    print(a)\nelse:\n    print(-a)\n```\n以#开头的语句是注释\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.\n\n### 数据类型和变量\n#### 字符串\n字符串是以单引号'或双引号\"括起来的任意文本.如果字符串内部既包含'又包含\",可以用转义字符\\来标识。\n要计算str包含多少个字符，可以用len()函数。\n%运算符就是用来格式化字符串，如：\n```python\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n```\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.\n\n#### 布尔值\n一个布尔值只有True、False两种值\n布尔值可以用and、or和not运算。\n\n#### 空值\n空值是Python里一个特殊的值，用None表示。\n\n#### 变量\n等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量\n\n### 数组和元组\n#### list\nlist是一种**可变的**有序的集合，用len()函数可以获得list元素的个数\n```python\nclassmates = ['Michael', 'Bob', 'Tracy']\n```\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置\nlist里面的元素的数据类型也可以不同\n列表可以看成一个多维数组 s[2][1]拿到元素。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0\n\n#### tuple\n另一种有序列表叫元组，但是tuple一旦初始化就不能修改\n```python\nclassmates = ('Michael', 'Bob', 'Tracy')\n```\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.\n\n如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下\n```python\nt = (1,)\n```\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义\n\n### 条件判断\nif-else语句实现：\n```python\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n```\n注意不要少写了冒号:\n完全可以用elif做更细致的判断,elif是else if的缩写\n\n### 循环\n#### for...in\n依次把list或tuple中的每个元素迭代出来\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\nPython提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for...in中可以简写成range()\n```python\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n#### while\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n### 容器\n#### dict\n```python\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n```\n**要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key**\n\n#### set\nset和dict类似，**也是一组key的集合**，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，需要**提供一个list作为输入集合**：\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n重复元素在set中自动被过滤\n```python\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n\n\n\n\n\n","slug":"python语法","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxh005g7hzgvxvmxtgc","content":"<p>python还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。<br>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>Python采用缩进方式,写出来的代码就像下面的样子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print absolute value of an integer:</span></div><div class=\"line\">a = <span class=\"number\">100</span></div><div class=\"line\"><span class=\"keyword\">if</span> a &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">    print(a)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(-a)</div></pre></td></tr></table></figure></p>\n<p>以#开头的语句是注释<br>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.</p>\n<h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本.如果字符串内部既包含’又包含”,可以用转义字符\\来标识。<br>要计算str包含多少个字符，可以用len()函数。<br>%运算符就是用来格式化字符串，如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hello, %s'</span> % <span class=\"string\">'world'</span></div><div class=\"line\"><span class=\"string\">'Hello, world'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hi, %s, you have $%d.'</span> % (<span class=\"string\">'Michael'</span>, <span class=\"number\">1000000</span>)</div><div class=\"line\"><span class=\"string\">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>\n<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.</p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>一个布尔值只有True、False两种值<br>布尔值可以用and、or和not运算。</p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h4><p>空值是Python里一个特殊的值，用None表示。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>\n<h3 id=\"数组和元组\"><a href=\"#数组和元组\" class=\"headerlink\" title=\"数组和元组\"></a>数组和元组</h3><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>list是一种<strong>可变的</strong>有序的集合，用len()函数可以获得list元素的个数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>列表可以看成一个多维数组 s[2][1]拿到元素。<br>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>另一种有序列表叫元组，但是tuple一旦初始化就不能修改<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = (<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>)</div></pre></td></tr></table></figure></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.</p>\n<p>如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">t = (<span class=\"number\">1</span>,)</div></pre></td></tr></table></figure></p>\n<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义</p>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>if-else语句实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'adult'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'teenager'</span>)</div></pre></td></tr></table></figure></p>\n<p>注意不要少写了冒号:<br>完全可以用elif做更细致的判断,elif是else if的缩写</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>依次把list或tuple中的每个元素迭代出来<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">names = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names:</div><div class=\"line\">    print(name)</div></pre></td></tr></table></figure></p>\n<p>Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for…in中可以简写成range()<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</div><div class=\"line\">    sum = sum + x</div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\">n = <span class=\"number\">99</span></div><div class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">    sum = sum + n</div><div class=\"line\">    n = n - <span class=\"number\">2</span></div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">d = &#123;<span class=\"string\">'Michael'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Bob'</span>: <span class=\"number\">75</span>, <span class=\"string\">'Tracy'</span>: <span class=\"number\">85</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>set和dict类似，<strong>也是一组key的集合</strong>，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要<strong>提供一个list作为输入集合</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复元素在set中自动被过滤<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>python还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。<br>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>Python采用缩进方式,写出来的代码就像下面的样子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print absolute value of an integer:</span></div><div class=\"line\">a = <span class=\"number\">100</span></div><div class=\"line\"><span class=\"keyword\">if</span> a &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">    print(a)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(-a)</div></pre></td></tr></table></figure></p>\n<p>以#开头的语句是注释<br>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.</p>\n<h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本.如果字符串内部既包含’又包含”,可以用转义字符\\来标识。<br>要计算str包含多少个字符，可以用len()函数。<br>%运算符就是用来格式化字符串，如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hello, %s'</span> % <span class=\"string\">'world'</span></div><div class=\"line\"><span class=\"string\">'Hello, world'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hi, %s, you have $%d.'</span> % (<span class=\"string\">'Michael'</span>, <span class=\"number\">1000000</span>)</div><div class=\"line\"><span class=\"string\">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>\n<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.</p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>一个布尔值只有True、False两种值<br>布尔值可以用and、or和not运算。</p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h4><p>空值是Python里一个特殊的值，用None表示。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>\n<h3 id=\"数组和元组\"><a href=\"#数组和元组\" class=\"headerlink\" title=\"数组和元组\"></a>数组和元组</h3><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>list是一种<strong>可变的</strong>有序的集合，用len()函数可以获得list元素的个数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>列表可以看成一个多维数组 s[2][1]拿到元素。<br>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>另一种有序列表叫元组，但是tuple一旦初始化就不能修改<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = (<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>)</div></pre></td></tr></table></figure></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.</p>\n<p>如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">t = (<span class=\"number\">1</span>,)</div></pre></td></tr></table></figure></p>\n<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义</p>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>if-else语句实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'adult'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'teenager'</span>)</div></pre></td></tr></table></figure></p>\n<p>注意不要少写了冒号:<br>完全可以用elif做更细致的判断,elif是else if的缩写</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>依次把list或tuple中的每个元素迭代出来<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">names = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names:</div><div class=\"line\">    print(name)</div></pre></td></tr></table></figure></p>\n<p>Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for…in中可以简写成range()<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</div><div class=\"line\">    sum = sum + x</div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\">n = <span class=\"number\">99</span></div><div class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">    sum = sum + n</div><div class=\"line\">    n = n - <span class=\"number\">2</span></div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">d = &#123;<span class=\"string\">'Michael'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Bob'</span>: <span class=\"number\">75</span>, <span class=\"string\">'Tracy'</span>: <span class=\"number\">85</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>set和dict类似，<strong>也是一组key的集合</strong>，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要<strong>提供一个list作为输入集合</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复元素在set中自动被过滤<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"使用xib设置view的border的宽度和颜色","date":"2016-08-10T06:07:12.000Z","_content":"\n使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。\n\n<!--more-->\n\n写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。\n可以使用User Defined Runtime Attributes在xib中进行设置。\n\n对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：\n```objc\nlayer.cornerRadius\t\t\t\tNumber\nlayer.borderWidth\t\t\t\tNumber\nlayer.borderColor\t\t\t\tColor\n```\n\n但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。\n\n需要使用category定义一个CALayer的方法\n```objc\n#import \"CALayer+Additions.h\"\n#import <UIKit/UIKit.h>\n@implementation CALayer (Additions)\n- (void)setBorderColorFromUIColor:(UIColor *)color{\n    self.borderColor = color.CGColor;\n}\n@end\n```\n通过这个方法可以把Color设置为borderColor。\nxib中的key需要改成此方法名\n**layer.borderColorFromUIColor**\n\n在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。\n\n设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。\n","source":"_posts/xib设置border.md","raw":"title: 使用xib设置view的border的宽度和颜色\ndate: 2016/8/10 14:07:12  \ncategories: iOS\ntags: \n\t- Runtime\n\t- UI\n\t\n---\n\n使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。\n\n<!--more-->\n\n写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。\n可以使用User Defined Runtime Attributes在xib中进行设置。\n\n对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：\n```objc\nlayer.cornerRadius\t\t\t\tNumber\nlayer.borderWidth\t\t\t\tNumber\nlayer.borderColor\t\t\t\tColor\n```\n\n但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。\n\n需要使用category定义一个CALayer的方法\n```objc\n#import \"CALayer+Additions.h\"\n#import <UIKit/UIKit.h>\n@implementation CALayer (Additions)\n- (void)setBorderColorFromUIColor:(UIColor *)color{\n    self.borderColor = color.CGColor;\n}\n@end\n```\n通过这个方法可以把Color设置为borderColor。\nxib中的key需要改成此方法名\n**layer.borderColorFromUIColor**\n\n在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。\n\n设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。\n","slug":"xib设置border","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxj005i7hzg98rydvgf","content":"<p>使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。</p>\n<a id=\"more\"></a>\n<p>写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。<br>可以使用User Defined Runtime Attributes在xib中进行设置。</p>\n<p>对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layer.cornerRadius\t\t\t\tNumber</div><div class=\"line\">layer.borderWidth\t\t\t\tNumber</div><div class=\"line\">layer.borderColor\t\t\t\tColor</div></pre></td></tr></table></figure></p>\n<p>但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。</p>\n<p>需要使用category定义一个CALayer的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CALayer+Additions.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CALayer</span> (<span class=\"title\">Additions</span>)</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setBorderColorFromUIColor:(<span class=\"built_in\">UIColor</span> *)color&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.borderColor = color.CGColor;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>通过这个方法可以把Color设置为borderColor。<br>xib中的key需要改成此方法名<br><strong>layer.borderColorFromUIColor</strong></p>\n<p>在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。</p>\n<p>设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。</p>\n","excerpt":"<p>使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。</p>","more":"<p>写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。<br>可以使用User Defined Runtime Attributes在xib中进行设置。</p>\n<p>对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layer.cornerRadius\t\t\t\tNumber</div><div class=\"line\">layer.borderWidth\t\t\t\tNumber</div><div class=\"line\">layer.borderColor\t\t\t\tColor</div></pre></td></tr></table></figure></p>\n<p>但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。</p>\n<p>需要使用category定义一个CALayer的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CALayer+Additions.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CALayer</span> (<span class=\"title\">Additions</span>)</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setBorderColorFromUIColor:(<span class=\"built_in\">UIColor</span> *)color&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.borderColor = color.CGColor;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>通过这个方法可以把Color设置为borderColor。<br>xib中的key需要改成此方法名<br><strong>layer.borderColorFromUIColor</strong></p>\n<p>在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。</p>\n<p>设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。</p>"},{"title":"Storyboard 使用方法","date":"2016-10-13T06:07:12.000Z","_content":"\nStoryboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。\n\n<!--more-->\n\n先来看一下思维导图\n![storyboard_28](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_28.png?raw=true)\n\n## storyboard基础\n### storyboard优势\nstoryboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点：\n\n- storyboard能将nib汇总统一管理\n- storyboard可以描述各种场景之间的过渡，这种过渡被称作`segue`，storyboard 把 view controller叫做：`scene`，可以通过拖拽实现过度，减少代码\n- 支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量\n\n### storyboard的基本使用\n#### 启动storyboard\n加载storyboard肯定是需要一个主入口的，这个主入口在`info.plist`中：\n![storyboard_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_1.png?raw=true)\n\n#### 初始化ViewController\n确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选`Is Initial View Controller`\n![storyboard_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_2.png?raw=true)\n此时，对应ViewController前出现一个箭头\n![storyboard_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_3.png?raw=true)\n\n#### 创建relationship segue\n对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。\n\n如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：\n![storyboard_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_4.png?raw=true)\n连接后的图标如下图，表示relationship segue\n![storyboard_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_5.png?raw=true)\n\n#### 命名tabbar controller的tabbar\n并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：\n![storyboard_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_6.png?raw=true)\nnavigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。\n\n#### 设置ViewController对应的类\n选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。\n![storyboard_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_7.png?raw=true)\n\n#### 获取视图控制器\n就是通过`UITableViewController`和`UINavigationController`中的`viewControllers`获取：\n\n```objc\nUITabBarController *tabBarController = (UITabBarController *)self.window.rootViewController;\nUINavigationController *navigationController = [tabBarController viewControllers][0];\nPlayersViewController *playersViewController = [navigationController viewControllers][0];\n```\n\n#### Prototype cells\n选中tableview，设置tableview的 cotent 为 Dynamic Propotype\n![storyboard_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_8.png?raw=true)\n一般在`tableView: cellForRowAtIndexPath:`方法中都像下面：\n\n```objc\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n    static NSString *CellIdentifier = @\"Cell\";\n\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n                                      reuseIdentifier:CellIdentifier];\n    }\n\n    // Configure the cell...\n    return cell;\n}\n```\n\n但是，由于在storyboard中已经创建了cell，那么就可以直接使用了：\n\n```objc\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"PlayerCell\"];\n\n    // Configure the cell...\n\n    return cell;\n}\n```\n\n当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：\n![storyboard_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_9.png?raw=true)\n设置不同的 identifier 来标识不同的cell。\n\n除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。\n\n#### Static cells\n使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：\n![storyboard_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_10.png?raw=true)\n因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。\n\n那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：\n![storyboard_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_11.png?raw=true)\n此时右边栏出现如图所示 Table View Section\n![storyboard_12](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_12.png?raw=true)\n可以设置数量，表头表尾的title\n\n和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。\n也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。\n\n所以，方便起见，static cell 直接在viewController中连线设置就可以了。\n\n\n\n\n\n## 使用segue\n### 简介\n#### 什么是Segue\nStoryboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）\n\n#### Segue的属性\n每一个Segue对象，都有3个属性\n\n```objc\n// 唯一标识\n@property (nonatomic, readonly) NSString *identifier;\n// 来源控制器\n@property (nonatomic, readonly) id sourceViewController;\n// 目标控制器\n@property (nonatomic, readonly) id destinationViewController;\n```\n\n#### Segue的类型\n根据Segue的执行（跳转）时刻，Segue可以分为2大类型:\n- 自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。\n- 手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。\n\n#### segue执行过程\n手动调用`performSegueWithIdentifier:sender:`方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。\n\n1. 根据`identifier`去storyboard中找到对应的线，新建UIStoryboardSegue对象\n\n```objc\n- (instancetype)initWithIdentifier:(NSString *)identifier source:(UIViewController *)source destination:(UIViewController *)destination; // Designated initializer\n```\n\n其实就是执行了UIStoryboardSegue中`initWithIdentifier:source:destination:`方法,并且`identifier`就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾\n\n2. 调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender;\n```\n\n所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。\n\n3. 调用Segue对象的`perform`方法开始执行界面跳转操作。\n\n### 页面跳转\nsegue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。\n\n#### 跳进\n##### 使用storyboard\nAction segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。\nManual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。\n\n首先，先对两个viewController进行连线：\n![storyboard_14](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_14.png?raw=true)\n之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：\n![storyboard_15](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_15.png?raw=true)\n其中参数 `identifier` 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。\n\n接下来就可以调用方法，在合适的时机加载了\n\n```objc\n//根据 segue Identifier跳转界面\n[self performSegueWithIdentifier:@\"GotoTwo\" sender:self];\n```\n\n其中的`identifer`自然不用多说，那么`sender`是什么呢？`sender`是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置`sender`区分了。引申开来，在设置button点击事件时的`-(IBAction)click:(id)sender;`方法中的`sender`和这里的`sender`是一个作用。\n\n\n##### 使用纯代码\n上面的方法实现效果和平时用的下面两个方法相同：\n\n```objc\n//以modal 方式跳转\n[self presentViewController:ViewController animated:YES completion:nil];\n//压进一个viewcontroller\n[self.navigationController pushViewController:ViewController animated:YES completion:nil];\n```\n\n不过，既然用了storyboard了，那么实例化viewController时就不能用`initWithNibName`了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：\n![storyboard_19](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_19.png?raw=true)\n那个`use storyboardId`的勾不打也行，不知道干什么用的，\n\n现在就可以在代码中找到特定storyboard的viewcontroller了：\n\n```objc\n- (IBAction)tapButton:(id)sender {\n    //获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard,\n    UIStoryboard *story = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil];\n    //由storyboard根据myView的storyBoardID来获取我们要切换的视图\n    UIViewController *myView = [story instantiateViewControllerWithIdentifier:@\"myView\"];\n    //显示ViewController\n    [self presentViewController:myView animated:YES completion:nil];\n}\n```\n\n#### 跳出\n能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。\n\n##### exit segue \n跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1：\n\n先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是`IBAction`，参数类型**一定**是`UIStoryboardSegue`，名称随便（这个方法一定要加，返回时调用的）\n\n```objc\n//其他界面返回到此界面调用的方法\n- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue {\n}\n```\n\n右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择`manual`，这里连接自己表示要在当前viewcontroller中用代码的方式回退。\n![storyboard_17](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_17.png?raw=true)\n\n给2视图的unwind segue取一个名字叫`from2to1`的identifier如下图:\n![storyboard_18](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_18.png?raw=true)\n\n现在就可以在界面2中的任意时候调用方法回退了：\n\n```objc\n- (IBAction)back:(id)sender {\n　　//执行segue跳页的方法\n    [self performSegueWithIdentifier:@\"from2to1\" sender:nil];\n}\n```\n\n使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法：\n\n```objc\n//其他界面返回到此界面调用的方法\n- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue {\n    if ([unwindSegue.identifier isEqualToString:@\"from2to1\"]) {\n        _lbShowMessage.text = @\"从2退到1\";\n    } else if ([unwindSegue.identifier isEqualToString:@\"from3to1\"]) {\n        _lbShowMessage.text = @\"从3退到1\";\n    }\n}\n```\n\n这里就看出上面为什么说类型一定是`UIStoryboardSegue`了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。\n\n使用 exit segue 的**好处**是可以跳转到任意打开过的界面比如从3->1，而不是只能返回上级界面从2->1。\n\n\n##### 一般跳出方法\n也可以使用代码根据是model类型还是push类型选择：\n\n```objc\n//弹出一个viewcontroller  相当与返回上一个界面\n[self.navigationController popViewControllerAnimated:YES];   \n// 以 modal跳转的返回方法\n[self dismissViewControllerAnimated:YES];\n```\n\n### 跳转的方式\n在进行跳转连线后会出现如下窗口： \n![storyboard_13](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_13.png?raw=true)\n共有三种跳转方式，也就是上面右边栏的`Kind`属性\n\n#### push\nPush类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。\n\n#### model\n最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的`Presentation`选择需要展示的动画效果。\n\n#### custom\n自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。\n![storyboard_16](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_16.png?raw=true)\n这段代码的作用是创建从中心渐变充满屏幕的动画:\n\n```objc\n-(void)perform{\n    UIViewController * svc = self.sourceViewController;\n    UIViewController * dvc = self.destinationViewController;\n    [svc.view addSubview:dvc.view];\n    [dvc.view setFrame:svc.view.frame];\n    [dvc.view setTransform:CGAffineTransformMakeScale(0.5, 0.5)];\n    [dvc.view setAlpha:0.0];\n    [UIView animateWithDuration:1.0\n                     animations:^{\n                         [dvc.view setTransform:CGAffineTransformMakeScale(1.0, 1.0)];\n                         [dvc.view setAlpha:1.0];\n                     }\n                     completion:^(BOOL finished) {\n                         [svc presentViewController:dvc animated:NO completion:nil];\n                     }];\n}\n```\n\n其实实质还是`presentViewController`，但是不用系统带的`animation`，而是先将`destinationViewController`的页面用动画加载后，直接`present`。\n\n### 跳转传值\n前面说到，`- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender `方法会在跳转时自动触发。跳转传值就在这个方法内完成。\n\n我们可以对Segue的标识进行判断，一般有以下两种方法：\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    if ([segue.identifier  isEqual: @\"login2index\"]) {\n        // 需要执行的代码\n    }\n}\n```\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    if ([segue.destinationViewController isKindOfClass:[IndexTableViewController class]]) {\n        //  执行代码\n    }\n}\n```\n\n第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。\n\n接下来就可以对`destination`进行赋值了：\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    \n    NSLog(@\"触发该场景切换的sender对象的类型是:%@\",[sender class]);\n    \n    //方法一,使用KVC给B 也就是目标场景传值\n    UIViewController *destinationController=[segue destinationViewController];\n    [destinationController setValue:@\"119\" forKey:@\"number\"];\n    \n    //方法2,使用属性传值,需导入相关的类.h\n    //BViewController *bController=[segue destinationViewController];\n    //bController.number=@188;\n}\n```\n\n跳转传值不仅可以用`prepareForSegue:sender:`实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见[使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/mad1989/article/details/7919504#comments)\n\n\n### 多分支NavigationController\n主要应用在下面这种情况：\n![storyboard_20](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_20.png?raw=true)\nnavigationController要分情况跳转到界面A或者界面B，但是navigationController只能有一个`rootViewController`啊。所以，通过一个空的`ParentViewController`在`viewWillAppear:`方法中加载任意一个`ChildViewController`。如下图：\n![storyboard_22](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_22.png?raw=true)\n\n注意，上图红框中的分支，其实**表现的只是一个页面的两种形态**，本质上还是一个页面。所以加载`childViewController`的segue都要用不带任何动画的`custome`类型。因为如果`ChildViewController`有动画，那么就会暴露出`ParentViewController`中的空白部分，就表现为两个页面了。\n\n可以看出，这个方法的优点是可以通过`parent`，从`C1`直接跳到`C2`，如果不用这种父子ViewController的方式，那么不可避免的就得先从`C1`跳回前一级页面，然后再从前一级页面跳到`C2`。不过缺点就是`C1`到`C2`的跳转没有任何跳转动画。\n\n不过，思考了一段时间后，觉得多分支NavigationController本身并不是一个问题，用父子ViewController的方式虽然能解决，但是把问题复杂化了。比如应用在登录跳转上，我完全可以不用在加载NavigationController后再判断是否要登录，而是把这一过程放到加载NavigationController之前。至于可以直接跳转的这一好处，一般情况下，产品也不会这么设计，而且它的弊端也是很明显的。\n\n具体实现的过程参见[基于Storyboard的创建多分支NavigationController的方法](http://www.cnblogs.com/shanpow/p/4149462.html)。记得如果使用这种方法的话，一定要清除`Parent`中上次显示的`ChildViewController`，文中在`prepareForSegue:sender:`方法中清除，是个很好的时机。 \n\n## storyboard reference\niOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。\n\n### 简化现有storyboard\n如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。\n\n![storyboard_23](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_23.png?raw=true)\n\n做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor->Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。\n![storyboard_24](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_24.png?raw=true)\n\n![storyboard_25](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_25.png?raw=true)\n\n### 加载storyboard中一个特定viewController\n和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上：\n![storyboard_26](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_26.png?raw=true)\n\n然后设置storyboard：\n![storyboard_27](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_27.png?raw=true)\n这里面`storyboard`填的是目标storboard的文件名；`Reference ID`是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的`Storyboard ID`，具体在哪设，上面也说过。\n\n这样，一个简洁的storyboard就能创建出来了。\n\n\n## 参考链接\n[【Storyboard】Storyboard介绍及使用](http://www.jianshu.com/p/2ec2c19f183e)\n\n[UIStoryboardSegue讲解](http://birdmichael.com/?p=180);\n\n[iOS-prepareForSegue场景切换,KVC传值](http://blog.csdn.net/yangbingbinga/article/details/43704269);\n\n[(4.4.1)使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/mad1989/article/details/7919504#comments);\n\n[【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/xuqiang918/article/details/17023737)\n\n[iOS9 Day-by-Day :: Day 3 :: Storyboard References](https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references);\n\n[基于Storyboard的创建多分支NavigationController的方法](http://www.cnblogs.com/shanpow/p/4149462.html);\n\n[iOS 9 Storyboard 教程(一下)](http://blog.csdn.net/yangmeng13930719363/article/details/49886901);\n\n[10 Practical Tips for iOS Developers Using Storyboards](http://www.xmcgraw.com/10-practical-tips-for-ios-developers-using-storyboards/);\n\n还有一些看完随手就关了，没有记录。\n\n水平有限，如有错误，多多指正~","source":"_posts/storyboard基础.md","raw":"title: Storyboard 使用方法\t\ndate: 2016/10/13 14:07:12  \ncategories: iOS \ntags: \n\t- Xcode\n\n\t\n---\n\nStoryboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。\n\n<!--more-->\n\n先来看一下思维导图\n![storyboard_28](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_28.png?raw=true)\n\n## storyboard基础\n### storyboard优势\nstoryboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点：\n\n- storyboard能将nib汇总统一管理\n- storyboard可以描述各种场景之间的过渡，这种过渡被称作`segue`，storyboard 把 view controller叫做：`scene`，可以通过拖拽实现过度，减少代码\n- 支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量\n\n### storyboard的基本使用\n#### 启动storyboard\n加载storyboard肯定是需要一个主入口的，这个主入口在`info.plist`中：\n![storyboard_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_1.png?raw=true)\n\n#### 初始化ViewController\n确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选`Is Initial View Controller`\n![storyboard_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_2.png?raw=true)\n此时，对应ViewController前出现一个箭头\n![storyboard_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_3.png?raw=true)\n\n#### 创建relationship segue\n对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。\n\n如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：\n![storyboard_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_4.png?raw=true)\n连接后的图标如下图，表示relationship segue\n![storyboard_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_5.png?raw=true)\n\n#### 命名tabbar controller的tabbar\n并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：\n![storyboard_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_6.png?raw=true)\nnavigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。\n\n#### 设置ViewController对应的类\n选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。\n![storyboard_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_7.png?raw=true)\n\n#### 获取视图控制器\n就是通过`UITableViewController`和`UINavigationController`中的`viewControllers`获取：\n\n```objc\nUITabBarController *tabBarController = (UITabBarController *)self.window.rootViewController;\nUINavigationController *navigationController = [tabBarController viewControllers][0];\nPlayersViewController *playersViewController = [navigationController viewControllers][0];\n```\n\n#### Prototype cells\n选中tableview，设置tableview的 cotent 为 Dynamic Propotype\n![storyboard_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_8.png?raw=true)\n一般在`tableView: cellForRowAtIndexPath:`方法中都像下面：\n\n```objc\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n    static NSString *CellIdentifier = @\"Cell\";\n\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n                                      reuseIdentifier:CellIdentifier];\n    }\n\n    // Configure the cell...\n    return cell;\n}\n```\n\n但是，由于在storyboard中已经创建了cell，那么就可以直接使用了：\n\n```objc\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"PlayerCell\"];\n\n    // Configure the cell...\n\n    return cell;\n}\n```\n\n当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：\n![storyboard_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_9.png?raw=true)\n设置不同的 identifier 来标识不同的cell。\n\n除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。\n\n#### Static cells\n使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：\n![storyboard_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_10.png?raw=true)\n因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。\n\n那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：\n![storyboard_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_11.png?raw=true)\n此时右边栏出现如图所示 Table View Section\n![storyboard_12](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_12.png?raw=true)\n可以设置数量，表头表尾的title\n\n和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。\n也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。\n\n所以，方便起见，static cell 直接在viewController中连线设置就可以了。\n\n\n\n\n\n## 使用segue\n### 简介\n#### 什么是Segue\nStoryboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）\n\n#### Segue的属性\n每一个Segue对象，都有3个属性\n\n```objc\n// 唯一标识\n@property (nonatomic, readonly) NSString *identifier;\n// 来源控制器\n@property (nonatomic, readonly) id sourceViewController;\n// 目标控制器\n@property (nonatomic, readonly) id destinationViewController;\n```\n\n#### Segue的类型\n根据Segue的执行（跳转）时刻，Segue可以分为2大类型:\n- 自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。\n- 手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。\n\n#### segue执行过程\n手动调用`performSegueWithIdentifier:sender:`方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。\n\n1. 根据`identifier`去storyboard中找到对应的线，新建UIStoryboardSegue对象\n\n```objc\n- (instancetype)initWithIdentifier:(NSString *)identifier source:(UIViewController *)source destination:(UIViewController *)destination; // Designated initializer\n```\n\n其实就是执行了UIStoryboardSegue中`initWithIdentifier:source:destination:`方法,并且`identifier`就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾\n\n2. 调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender;\n```\n\n所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。\n\n3. 调用Segue对象的`perform`方法开始执行界面跳转操作。\n\n### 页面跳转\nsegue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。\n\n#### 跳进\n##### 使用storyboard\nAction segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。\nManual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。\n\n首先，先对两个viewController进行连线：\n![storyboard_14](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_14.png?raw=true)\n之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：\n![storyboard_15](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_15.png?raw=true)\n其中参数 `identifier` 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。\n\n接下来就可以调用方法，在合适的时机加载了\n\n```objc\n//根据 segue Identifier跳转界面\n[self performSegueWithIdentifier:@\"GotoTwo\" sender:self];\n```\n\n其中的`identifer`自然不用多说，那么`sender`是什么呢？`sender`是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置`sender`区分了。引申开来，在设置button点击事件时的`-(IBAction)click:(id)sender;`方法中的`sender`和这里的`sender`是一个作用。\n\n\n##### 使用纯代码\n上面的方法实现效果和平时用的下面两个方法相同：\n\n```objc\n//以modal 方式跳转\n[self presentViewController:ViewController animated:YES completion:nil];\n//压进一个viewcontroller\n[self.navigationController pushViewController:ViewController animated:YES completion:nil];\n```\n\n不过，既然用了storyboard了，那么实例化viewController时就不能用`initWithNibName`了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：\n![storyboard_19](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_19.png?raw=true)\n那个`use storyboardId`的勾不打也行，不知道干什么用的，\n\n现在就可以在代码中找到特定storyboard的viewcontroller了：\n\n```objc\n- (IBAction)tapButton:(id)sender {\n    //获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard,\n    UIStoryboard *story = [UIStoryboard storyboardWithName:@\"Main\" bundle:nil];\n    //由storyboard根据myView的storyBoardID来获取我们要切换的视图\n    UIViewController *myView = [story instantiateViewControllerWithIdentifier:@\"myView\"];\n    //显示ViewController\n    [self presentViewController:myView animated:YES completion:nil];\n}\n```\n\n#### 跳出\n能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。\n\n##### exit segue \n跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1：\n\n先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是`IBAction`，参数类型**一定**是`UIStoryboardSegue`，名称随便（这个方法一定要加，返回时调用的）\n\n```objc\n//其他界面返回到此界面调用的方法\n- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue {\n}\n```\n\n右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择`manual`，这里连接自己表示要在当前viewcontroller中用代码的方式回退。\n![storyboard_17](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_17.png?raw=true)\n\n给2视图的unwind segue取一个名字叫`from2to1`的identifier如下图:\n![storyboard_18](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_18.png?raw=true)\n\n现在就可以在界面2中的任意时候调用方法回退了：\n\n```objc\n- (IBAction)back:(id)sender {\n　　//执行segue跳页的方法\n    [self performSegueWithIdentifier:@\"from2to1\" sender:nil];\n}\n```\n\n使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法：\n\n```objc\n//其他界面返回到此界面调用的方法\n- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue {\n    if ([unwindSegue.identifier isEqualToString:@\"from2to1\"]) {\n        _lbShowMessage.text = @\"从2退到1\";\n    } else if ([unwindSegue.identifier isEqualToString:@\"from3to1\"]) {\n        _lbShowMessage.text = @\"从3退到1\";\n    }\n}\n```\n\n这里就看出上面为什么说类型一定是`UIStoryboardSegue`了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。\n\n使用 exit segue 的**好处**是可以跳转到任意打开过的界面比如从3->1，而不是只能返回上级界面从2->1。\n\n\n##### 一般跳出方法\n也可以使用代码根据是model类型还是push类型选择：\n\n```objc\n//弹出一个viewcontroller  相当与返回上一个界面\n[self.navigationController popViewControllerAnimated:YES];   \n// 以 modal跳转的返回方法\n[self dismissViewControllerAnimated:YES];\n```\n\n### 跳转的方式\n在进行跳转连线后会出现如下窗口： \n![storyboard_13](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_13.png?raw=true)\n共有三种跳转方式，也就是上面右边栏的`Kind`属性\n\n#### push\nPush类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。\n\n#### model\n最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的`Presentation`选择需要展示的动画效果。\n\n#### custom\n自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。\n![storyboard_16](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_16.png?raw=true)\n这段代码的作用是创建从中心渐变充满屏幕的动画:\n\n```objc\n-(void)perform{\n    UIViewController * svc = self.sourceViewController;\n    UIViewController * dvc = self.destinationViewController;\n    [svc.view addSubview:dvc.view];\n    [dvc.view setFrame:svc.view.frame];\n    [dvc.view setTransform:CGAffineTransformMakeScale(0.5, 0.5)];\n    [dvc.view setAlpha:0.0];\n    [UIView animateWithDuration:1.0\n                     animations:^{\n                         [dvc.view setTransform:CGAffineTransformMakeScale(1.0, 1.0)];\n                         [dvc.view setAlpha:1.0];\n                     }\n                     completion:^(BOOL finished) {\n                         [svc presentViewController:dvc animated:NO completion:nil];\n                     }];\n}\n```\n\n其实实质还是`presentViewController`，但是不用系统带的`animation`，而是先将`destinationViewController`的页面用动画加载后，直接`present`。\n\n### 跳转传值\n前面说到，`- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender `方法会在跳转时自动触发。跳转传值就在这个方法内完成。\n\n我们可以对Segue的标识进行判断，一般有以下两种方法：\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    if ([segue.identifier  isEqual: @\"login2index\"]) {\n        // 需要执行的代码\n    }\n}\n```\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    if ([segue.destinationViewController isKindOfClass:[IndexTableViewController class]]) {\n        //  执行代码\n    }\n}\n```\n\n第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。\n\n接下来就可以对`destination`进行赋值了：\n\n```objc\n- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\n    \n    NSLog(@\"触发该场景切换的sender对象的类型是:%@\",[sender class]);\n    \n    //方法一,使用KVC给B 也就是目标场景传值\n    UIViewController *destinationController=[segue destinationViewController];\n    [destinationController setValue:@\"119\" forKey:@\"number\"];\n    \n    //方法2,使用属性传值,需导入相关的类.h\n    //BViewController *bController=[segue destinationViewController];\n    //bController.number=@188;\n}\n```\n\n跳转传值不仅可以用`prepareForSegue:sender:`实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见[使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/mad1989/article/details/7919504#comments)\n\n\n### 多分支NavigationController\n主要应用在下面这种情况：\n![storyboard_20](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_20.png?raw=true)\nnavigationController要分情况跳转到界面A或者界面B，但是navigationController只能有一个`rootViewController`啊。所以，通过一个空的`ParentViewController`在`viewWillAppear:`方法中加载任意一个`ChildViewController`。如下图：\n![storyboard_22](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_22.png?raw=true)\n\n注意，上图红框中的分支，其实**表现的只是一个页面的两种形态**，本质上还是一个页面。所以加载`childViewController`的segue都要用不带任何动画的`custome`类型。因为如果`ChildViewController`有动画，那么就会暴露出`ParentViewController`中的空白部分，就表现为两个页面了。\n\n可以看出，这个方法的优点是可以通过`parent`，从`C1`直接跳到`C2`，如果不用这种父子ViewController的方式，那么不可避免的就得先从`C1`跳回前一级页面，然后再从前一级页面跳到`C2`。不过缺点就是`C1`到`C2`的跳转没有任何跳转动画。\n\n不过，思考了一段时间后，觉得多分支NavigationController本身并不是一个问题，用父子ViewController的方式虽然能解决，但是把问题复杂化了。比如应用在登录跳转上，我完全可以不用在加载NavigationController后再判断是否要登录，而是把这一过程放到加载NavigationController之前。至于可以直接跳转的这一好处，一般情况下，产品也不会这么设计，而且它的弊端也是很明显的。\n\n具体实现的过程参见[基于Storyboard的创建多分支NavigationController的方法](http://www.cnblogs.com/shanpow/p/4149462.html)。记得如果使用这种方法的话，一定要清除`Parent`中上次显示的`ChildViewController`，文中在`prepareForSegue:sender:`方法中清除，是个很好的时机。 \n\n## storyboard reference\niOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。\n\n### 简化现有storyboard\n如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。\n\n![storyboard_23](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_23.png?raw=true)\n\n做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor->Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。\n![storyboard_24](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_24.png?raw=true)\n\n![storyboard_25](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_25.png?raw=true)\n\n### 加载storyboard中一个特定viewController\n和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上：\n![storyboard_26](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_26.png?raw=true)\n\n然后设置storyboard：\n![storyboard_27](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_27.png?raw=true)\n这里面`storyboard`填的是目标storboard的文件名；`Reference ID`是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的`Storyboard ID`，具体在哪设，上面也说过。\n\n这样，一个简洁的storyboard就能创建出来了。\n\n\n## 参考链接\n[【Storyboard】Storyboard介绍及使用](http://www.jianshu.com/p/2ec2c19f183e)\n\n[UIStoryboardSegue讲解](http://birdmichael.com/?p=180);\n\n[iOS-prepareForSegue场景切换,KVC传值](http://blog.csdn.net/yangbingbinga/article/details/43704269);\n\n[(4.4.1)使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/mad1989/article/details/7919504#comments);\n\n[【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递](http://blog.csdn.net/xuqiang918/article/details/17023737)\n\n[iOS9 Day-by-Day :: Day 3 :: Storyboard References](https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references);\n\n[基于Storyboard的创建多分支NavigationController的方法](http://www.cnblogs.com/shanpow/p/4149462.html);\n\n[iOS 9 Storyboard 教程(一下)](http://blog.csdn.net/yangmeng13930719363/article/details/49886901);\n\n[10 Practical Tips for iOS Developers Using Storyboards](http://www.xmcgraw.com/10-practical-tips-for-ios-developers-using-storyboards/);\n\n还有一些看完随手就关了，没有记录。\n\n水平有限，如有错误，多多指正~","slug":"storyboard基础","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxm005m7hzg2ajnlwud","content":"<p>Storyboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。</p>\n<a id=\"more\"></a>\n<p>先来看一下思维导图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_28.png?raw=true\" alt=\"storyboard_28\"></p>\n<h2 id=\"storyboard基础\"><a href=\"#storyboard基础\" class=\"headerlink\" title=\"storyboard基础\"></a>storyboard基础</h2><h3 id=\"storyboard优势\"><a href=\"#storyboard优势\" class=\"headerlink\" title=\"storyboard优势\"></a>storyboard优势</h3><p>storyboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点：</p>\n<ul>\n<li>storyboard能将nib汇总统一管理</li>\n<li>storyboard可以描述各种场景之间的过渡，这种过渡被称作<code>segue</code>，storyboard 把 view controller叫做：<code>scene</code>，可以通过拖拽实现过度，减少代码</li>\n<li>支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量</li>\n</ul>\n<h3 id=\"storyboard的基本使用\"><a href=\"#storyboard的基本使用\" class=\"headerlink\" title=\"storyboard的基本使用\"></a>storyboard的基本使用</h3><h4 id=\"启动storyboard\"><a href=\"#启动storyboard\" class=\"headerlink\" title=\"启动storyboard\"></a>启动storyboard</h4><p>加载storyboard肯定是需要一个主入口的，这个主入口在<code>info.plist</code>中：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_1.png?raw=true\" alt=\"storyboard_1\"></p>\n<h4 id=\"初始化ViewController\"><a href=\"#初始化ViewController\" class=\"headerlink\" title=\"初始化ViewController\"></a>初始化ViewController</h4><p>确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选<code>Is Initial View Controller</code><br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_2.png?raw=true\" alt=\"storyboard_2\"><br>此时，对应ViewController前出现一个箭头<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_3.png?raw=true\" alt=\"storyboard_3\"></p>\n<h4 id=\"创建relationship-segue\"><a href=\"#创建relationship-segue\" class=\"headerlink\" title=\"创建relationship segue\"></a>创建relationship segue</h4><p>对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。</p>\n<p>如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_4.png?raw=true\" alt=\"storyboard_4\"><br>连接后的图标如下图，表示relationship segue<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_5.png?raw=true\" alt=\"storyboard_5\"></p>\n<h4 id=\"命名tabbar-controller的tabbar\"><a href=\"#命名tabbar-controller的tabbar\" class=\"headerlink\" title=\"命名tabbar controller的tabbar\"></a>命名tabbar controller的tabbar</h4><p>并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_6.png?raw=true\" alt=\"storyboard_6\"><br>navigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。</p>\n<h4 id=\"设置ViewController对应的类\"><a href=\"#设置ViewController对应的类\" class=\"headerlink\" title=\"设置ViewController对应的类\"></a>设置ViewController对应的类</h4><p>选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_7.png?raw=true\" alt=\"storyboard_7\"></p>\n<h4 id=\"获取视图控制器\"><a href=\"#获取视图控制器\" class=\"headerlink\" title=\"获取视图控制器\"></a>获取视图控制器</h4><p>就是通过<code>UITableViewController</code>和<code>UINavigationController</code>中的<code>viewControllers</code>获取：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = (<span class=\"built_in\">UITabBarController</span> *)<span class=\"keyword\">self</span>.window.rootViewController;</div><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navigationController = [tabBarController viewControllers][<span class=\"number\">0</span>];</div><div class=\"line\">PlayersViewController *playersViewController = [navigationController viewControllers][<span class=\"number\">0</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"Prototype-cells\"><a href=\"#Prototype-cells\" class=\"headerlink\" title=\"Prototype cells\"></a>Prototype cells</h4><p>选中tableview，设置tableview的 cotent 为 Dynamic Propotype<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_8.png?raw=true\" alt=\"storyboard_8\"><br>一般在<code>tableView: cellForRowAtIndexPath:</code>方法中都像下面：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *CellIdentifier = <span class=\"string\">@\"Cell\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</div><div class=\"line\">    <span class=\"keyword\">if</span> (cell == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        cell = [[<span class=\"built_in\">UITableViewCell</span> alloc] initWithStyle:<span class=\"built_in\">UITableViewCellStyleDefault</span></div><div class=\"line\">                                      reuseIdentifier:CellIdentifier];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Configure the cell...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，由于在storyboard中已经创建了cell，那么就可以直接使用了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class=\"string\">@\"PlayerCell\"</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Configure the cell...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_9.png?raw=true\" alt=\"storyboard_9\"><br>设置不同的 identifier 来标识不同的cell。</p>\n<p>除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。</p>\n<h4 id=\"Static-cells\"><a href=\"#Static-cells\" class=\"headerlink\" title=\"Static cells\"></a>Static cells</h4><p>使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_10.png?raw=true\" alt=\"storyboard_10\"><br>因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。</p>\n<p>那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_11.png?raw=true\" alt=\"storyboard_11\"><br>此时右边栏出现如图所示 Table View Section<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_12.png?raw=true\" alt=\"storyboard_12\"><br>可以设置数量，表头表尾的title</p>\n<p>和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。<br>也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。</p>\n<p>所以，方便起见，static cell 直接在viewController中连线设置就可以了。</p>\n<h2 id=\"使用segue\"><a href=\"#使用segue\" class=\"headerlink\" title=\"使用segue\"></a>使用segue</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"什么是Segue\"><a href=\"#什么是Segue\" class=\"headerlink\" title=\"什么是Segue\"></a>什么是Segue</h4><p>Storyboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）</p>\n<h4 id=\"Segue的属性\"><a href=\"#Segue的属性\" class=\"headerlink\" title=\"Segue的属性\"></a>Segue的属性</h4><p>每一个Segue对象，都有3个属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一标识</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *identifier;</div><div class=\"line\"><span class=\"comment\">// 来源控制器</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"keyword\">id</span> sourceViewController;</div><div class=\"line\"><span class=\"comment\">// 目标控制器</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"keyword\">id</span> destinationViewController;</div></pre></td></tr></table></figure>\n<h4 id=\"Segue的类型\"><a href=\"#Segue的类型\" class=\"headerlink\" title=\"Segue的类型\"></a>Segue的类型</h4><p>根据Segue的执行（跳转）时刻，Segue可以分为2大类型:</p>\n<ul>\n<li>自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。</li>\n<li>手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。</li>\n</ul>\n<h4 id=\"segue执行过程\"><a href=\"#segue执行过程\" class=\"headerlink\" title=\"segue执行过程\"></a>segue执行过程</h4><p>手动调用<code>performSegueWithIdentifier:sender:</code>方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。</p>\n<ol>\n<li>根据<code>identifier</code>去storyboard中找到对应的线，新建UIStoryboardSegue对象</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier source:(<span class=\"built_in\">UIViewController</span> *)source destination:(<span class=\"built_in\">UIViewController</span> *)destination; <span class=\"comment\">// Designated initializer</span></div></pre></td></tr></table></figure>\n<p>其实就是执行了UIStoryboardSegue中<code>initWithIdentifier:source:destination:</code>方法,并且<code>identifier</code>就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾</p>\n<ol>\n<li>调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender;</div></pre></td></tr></table></figure>\n<p>所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。</p>\n<ol>\n<li>调用Segue对象的<code>perform</code>方法开始执行界面跳转操作。</li>\n</ol>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p>segue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。</p>\n<h4 id=\"跳进\"><a href=\"#跳进\" class=\"headerlink\" title=\"跳进\"></a>跳进</h4><h5 id=\"使用storyboard\"><a href=\"#使用storyboard\" class=\"headerlink\" title=\"使用storyboard\"></a>使用storyboard</h5><p>Action segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。<br>Manual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。</p>\n<p>首先，先对两个viewController进行连线：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_14.png?raw=true\" alt=\"storyboard_14\"><br>之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_15.png?raw=true\" alt=\"storyboard_15\"><br>其中参数 <code>identifier</code> 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。</p>\n<p>接下来就可以调用方法，在合适的时机加载了</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//根据 segue Identifier跳转界面</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSegueWithIdentifier:<span class=\"string\">@\"GotoTwo\"</span> sender:<span class=\"keyword\">self</span>];</div></pre></td></tr></table></figure>\n<p>其中的<code>identifer</code>自然不用多说，那么<code>sender</code>是什么呢？<code>sender</code>是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置<code>sender</code>区分了。引申开来，在设置button点击事件时的<code>-(IBAction)click:(id)sender;</code>方法中的<code>sender</code>和这里的<code>sender</code>是一个作用。</p>\n<h5 id=\"使用纯代码\"><a href=\"#使用纯代码\" class=\"headerlink\" title=\"使用纯代码\"></a>使用纯代码</h5><p>上面的方法实现效果和平时用的下面两个方法相同：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//以modal 方式跳转</span></div><div class=\"line\">[<span class=\"keyword\">self</span> presentViewController:ViewController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"comment\">//压进一个viewcontroller</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:ViewController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>不过，既然用了storyboard了，那么实例化viewController时就不能用<code>initWithNibName</code>了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_19.png?raw=true\" alt=\"storyboard_19\"><br>那个<code>use storyboardId</code>的勾不打也行，不知道干什么用的，</p>\n<p>现在就可以在代码中找到特定storyboard的viewcontroller了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)tapButton:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard,</span></div><div class=\"line\">    <span class=\"built_in\">UIStoryboard</span> *story = [<span class=\"built_in\">UIStoryboard</span> storyboardWithName:<span class=\"string\">@\"Main\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//由storyboard根据myView的storyBoardID来获取我们要切换的视图</span></div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> *myView = [story instantiateViewControllerWithIdentifier:<span class=\"string\">@\"myView\"</span>];</div><div class=\"line\">    <span class=\"comment\">//显示ViewController</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:myView animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"跳出\"><a href=\"#跳出\" class=\"headerlink\" title=\"跳出\"></a>跳出</h4><p>能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。</p>\n<h5 id=\"exit-segue\"><a href=\"#exit-segue\" class=\"headerlink\" title=\"exit segue\"></a>exit segue</h5><p>跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1：</p>\n<p>先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是<code>IBAction</code>，参数类型<strong>一定</strong>是<code>UIStoryboardSegue</code>，名称随便（这个方法一定要加，返回时调用的）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//其他界面返回到此界面调用的方法</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)ViewController1UnwindSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择<code>manual</code>，这里连接自己表示要在当前viewcontroller中用代码的方式回退。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_17.png?raw=true\" alt=\"storyboard_17\"></p>\n<p>给2视图的unwind segue取一个名字叫<code>from2to1</code>的identifier如下图:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_18.png?raw=true\" alt=\"storyboard_18\"></p>\n<p>现在就可以在界面2中的任意时候调用方法回退了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)back:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\">　　<span class=\"comment\">//执行segue跳页的方法</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> performSegueWithIdentifier:<span class=\"string\">@\"from2to1\"</span> sender:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//其他界面返回到此界面调用的方法</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)ViewController1UnwindSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([unwindSegue.identifier isEqualToString:<span class=\"string\">@\"from2to1\"</span>]) &#123;</div><div class=\"line\">        _lbShowMessage.text = <span class=\"string\">@\"从2退到1\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([unwindSegue.identifier isEqualToString:<span class=\"string\">@\"from3to1\"</span>]) &#123;</div><div class=\"line\">        _lbShowMessage.text = <span class=\"string\">@\"从3退到1\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里就看出上面为什么说类型一定是<code>UIStoryboardSegue</code>了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。</p>\n<p>使用 exit segue 的<strong>好处</strong>是可以跳转到任意打开过的界面比如从3-&gt;1，而不是只能返回上级界面从2-&gt;1。</p>\n<h5 id=\"一般跳出方法\"><a href=\"#一般跳出方法\" class=\"headerlink\" title=\"一般跳出方法\"></a>一般跳出方法</h5><p>也可以使用代码根据是model类型还是push类型选择：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//弹出一个viewcontroller  相当与返回上一个界面</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController popViewControllerAnimated:<span class=\"literal\">YES</span>];   </div><div class=\"line\"><span class=\"comment\">// 以 modal跳转的返回方法</span></div><div class=\"line\">[<span class=\"keyword\">self</span> dismissViewControllerAnimated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"跳转的方式\"><a href=\"#跳转的方式\" class=\"headerlink\" title=\"跳转的方式\"></a>跳转的方式</h3><p>在进行跳转连线后会出现如下窗口：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_13.png?raw=true\" alt=\"storyboard_13\"><br>共有三种跳转方式，也就是上面右边栏的<code>Kind</code>属性</p>\n<h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>Push类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。</p>\n<h4 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h4><p>最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的<code>Presentation</code>选择需要展示的动画效果。</p>\n<h4 id=\"custom\"><a href=\"#custom\" class=\"headerlink\" title=\"custom\"></a>custom</h4><p>自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_16.png?raw=true\" alt=\"storyboard_16\"><br>这段代码的作用是创建从中心渐变充满屏幕的动画:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)perform&#123;</div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> * svc = <span class=\"keyword\">self</span>.sourceViewController;</div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> * dvc = <span class=\"keyword\">self</span>.destinationViewController;</div><div class=\"line\">    [svc.view addSubview:dvc.view];</div><div class=\"line\">    [dvc.view setFrame:svc.view.frame];</div><div class=\"line\">    [dvc.view setTransform:<span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>)];</div><div class=\"line\">    [dvc.view setAlpha:<span class=\"number\">0.0</span>];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1.0</span></div><div class=\"line\">                     animations:^&#123;</div><div class=\"line\">                         [dvc.view setTransform:<span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>)];</div><div class=\"line\">                         [dvc.view setAlpha:<span class=\"number\">1.0</span>];</div><div class=\"line\">                     &#125;</div><div class=\"line\">                     completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">                         [svc presentViewController:dvc animated:<span class=\"literal\">NO</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\">                     &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实实质还是<code>presentViewController</code>，但是不用系统带的<code>animation</code>，而是先将<code>destinationViewController</code>的页面用动画加载后，直接<code>present</code>。</p>\n<h3 id=\"跳转传值\"><a href=\"#跳转传值\" class=\"headerlink\" title=\"跳转传值\"></a>跳转传值</h3><p>前面说到，<code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</code>方法会在跳转时自动触发。跳转传值就在这个方法内完成。</p>\n<p>我们可以对Segue的标识进行判断，一般有以下两种方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([segue.identifier  isEqual: <span class=\"string\">@\"login2index\"</span>]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 需要执行的代码</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([segue.destinationViewController isKindOfClass:[IndexTableViewController <span class=\"keyword\">class</span>]]) &#123;</div><div class=\"line\">        <span class=\"comment\">//  执行代码</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。</p>\n<p>接下来就可以对<code>destination</code>进行赋值了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"触发该场景切换的sender对象的类型是:%@\"</span>,[sender <span class=\"keyword\">class</span>]);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//方法一,使用KVC给B 也就是目标场景传值</span></div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> *destinationController=[segue destinationViewController];</div><div class=\"line\">    [destinationController setValue:<span class=\"string\">@\"119\"</span> forKey:<span class=\"string\">@\"number\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//方法2,使用属性传值,需导入相关的类.h</span></div><div class=\"line\">    <span class=\"comment\">//BViewController *bController=[segue destinationViewController];</span></div><div class=\"line\">    <span class=\"comment\">//bController.number=@188;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>跳转传值不仅可以用<code>prepareForSegue:sender:</code>实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见<a href=\"http://blog.csdn.net/mad1989/article/details/7919504#comments\" target=\"_blank\" rel=\"external\">使用storyboard实现页面跳转，简单的数据传递</a></p>\n<h3 id=\"多分支NavigationController\"><a href=\"#多分支NavigationController\" class=\"headerlink\" title=\"多分支NavigationController\"></a>多分支NavigationController</h3><p>主要应用在下面这种情况：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_20.png?raw=true\" alt=\"storyboard_20\"><br>navigationController要分情况跳转到界面A或者界面B，但是navigationController只能有一个<code>rootViewController</code>啊。所以，通过一个空的<code>ParentViewController</code>在<code>viewWillAppear:</code>方法中加载任意一个<code>ChildViewController</code>。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_22.png?raw=true\" alt=\"storyboard_22\"></p>\n<p>注意，上图红框中的分支，其实<strong>表现的只是一个页面的两种形态</strong>，本质上还是一个页面。所以加载<code>childViewController</code>的segue都要用不带任何动画的<code>custome</code>类型。因为如果<code>ChildViewController</code>有动画，那么就会暴露出<code>ParentViewController</code>中的空白部分，就表现为两个页面了。</p>\n<p>可以看出，这个方法的优点是可以通过<code>parent</code>，从<code>C1</code>直接跳到<code>C2</code>，如果不用这种父子ViewController的方式，那么不可避免的就得先从<code>C1</code>跳回前一级页面，然后再从前一级页面跳到<code>C2</code>。不过缺点就是<code>C1</code>到<code>C2</code>的跳转没有任何跳转动画。</p>\n<p>不过，思考了一段时间后，觉得多分支NavigationController本身并不是一个问题，用父子ViewController的方式虽然能解决，但是把问题复杂化了。比如应用在登录跳转上，我完全可以不用在加载NavigationController后再判断是否要登录，而是把这一过程放到加载NavigationController之前。至于可以直接跳转的这一好处，一般情况下，产品也不会这么设计，而且它的弊端也是很明显的。</p>\n<p>具体实现的过程参见<a href=\"http://www.cnblogs.com/shanpow/p/4149462.html\" target=\"_blank\" rel=\"external\">基于Storyboard的创建多分支NavigationController的方法</a>。记得如果使用这种方法的话，一定要清除<code>Parent</code>中上次显示的<code>ChildViewController</code>，文中在<code>prepareForSegue:sender:</code>方法中清除，是个很好的时机。 </p>\n<h2 id=\"storyboard-reference\"><a href=\"#storyboard-reference\" class=\"headerlink\" title=\"storyboard reference\"></a>storyboard reference</h2><p>iOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。</p>\n<h3 id=\"简化现有storyboard\"><a href=\"#简化现有storyboard\" class=\"headerlink\" title=\"简化现有storyboard\"></a>简化现有storyboard</h3><p>如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_23.png?raw=true\" alt=\"storyboard_23\"></p>\n<p>做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor-&gt;Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_24.png?raw=true\" alt=\"storyboard_24\"></p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_25.png?raw=true\" alt=\"storyboard_25\"></p>\n<h3 id=\"加载storyboard中一个特定viewController\"><a href=\"#加载storyboard中一个特定viewController\" class=\"headerlink\" title=\"加载storyboard中一个特定viewController\"></a>加载storyboard中一个特定viewController</h3><p>和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_26.png?raw=true\" alt=\"storyboard_26\"></p>\n<p>然后设置storyboard：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_27.png?raw=true\" alt=\"storyboard_27\"><br>这里面<code>storyboard</code>填的是目标storboard的文件名；<code>Reference ID</code>是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的<code>Storyboard ID</code>，具体在哪设，上面也说过。</p>\n<p>这样，一个简洁的storyboard就能创建出来了。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://www.jianshu.com/p/2ec2c19f183e\" target=\"_blank\" rel=\"external\">【Storyboard】Storyboard介绍及使用</a></p>\n<p><a href=\"http://birdmichael.com/?p=180\" target=\"_blank\" rel=\"external\">UIStoryboardSegue讲解</a>;</p>\n<p><a href=\"http://blog.csdn.net/yangbingbinga/article/details/43704269\" target=\"_blank\" rel=\"external\">iOS-prepareForSegue场景切换,KVC传值</a>;</p>\n<p><a href=\"http://blog.csdn.net/mad1989/article/details/7919504#comments\" target=\"_blank\" rel=\"external\">(4.4.1)使用storyboard实现页面跳转，简单的数据传递</a>;</p>\n<p><a href=\"http://blog.csdn.net/xuqiang918/article/details/17023737\" target=\"_blank\" rel=\"external\">【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递</a></p>\n<p><a href=\"https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references\" target=\"_blank\" rel=\"external\">iOS9 Day-by-Day :: Day 3 :: Storyboard References</a>;</p>\n<p><a href=\"http://www.cnblogs.com/shanpow/p/4149462.html\" target=\"_blank\" rel=\"external\">基于Storyboard的创建多分支NavigationController的方法</a>;</p>\n<p><a href=\"http://blog.csdn.net/yangmeng13930719363/article/details/49886901\" target=\"_blank\" rel=\"external\">iOS 9 Storyboard 教程(一下)</a>;</p>\n<p><a href=\"http://www.xmcgraw.com/10-practical-tips-for-ios-developers-using-storyboards/\" target=\"_blank\" rel=\"external\">10 Practical Tips for iOS Developers Using Storyboards</a>;</p>\n<p>还有一些看完随手就关了，没有记录。</p>\n<p>水平有限，如有错误，多多指正~</p>\n","excerpt":"<p>Storyboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。</p>","more":"<p>先来看一下思维导图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_28.png?raw=true\" alt=\"storyboard_28\"></p>\n<h2 id=\"storyboard基础\"><a href=\"#storyboard基础\" class=\"headerlink\" title=\"storyboard基础\"></a>storyboard基础</h2><h3 id=\"storyboard优势\"><a href=\"#storyboard优势\" class=\"headerlink\" title=\"storyboard优势\"></a>storyboard优势</h3><p>storyboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点：</p>\n<ul>\n<li>storyboard能将nib汇总统一管理</li>\n<li>storyboard可以描述各种场景之间的过渡，这种过渡被称作<code>segue</code>，storyboard 把 view controller叫做：<code>scene</code>，可以通过拖拽实现过度，减少代码</li>\n<li>支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量</li>\n</ul>\n<h3 id=\"storyboard的基本使用\"><a href=\"#storyboard的基本使用\" class=\"headerlink\" title=\"storyboard的基本使用\"></a>storyboard的基本使用</h3><h4 id=\"启动storyboard\"><a href=\"#启动storyboard\" class=\"headerlink\" title=\"启动storyboard\"></a>启动storyboard</h4><p>加载storyboard肯定是需要一个主入口的，这个主入口在<code>info.plist</code>中：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_1.png?raw=true\" alt=\"storyboard_1\"></p>\n<h4 id=\"初始化ViewController\"><a href=\"#初始化ViewController\" class=\"headerlink\" title=\"初始化ViewController\"></a>初始化ViewController</h4><p>确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选<code>Is Initial View Controller</code><br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_2.png?raw=true\" alt=\"storyboard_2\"><br>此时，对应ViewController前出现一个箭头<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_3.png?raw=true\" alt=\"storyboard_3\"></p>\n<h4 id=\"创建relationship-segue\"><a href=\"#创建relationship-segue\" class=\"headerlink\" title=\"创建relationship segue\"></a>创建relationship segue</h4><p>对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。</p>\n<p>如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_4.png?raw=true\" alt=\"storyboard_4\"><br>连接后的图标如下图，表示relationship segue<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_5.png?raw=true\" alt=\"storyboard_5\"></p>\n<h4 id=\"命名tabbar-controller的tabbar\"><a href=\"#命名tabbar-controller的tabbar\" class=\"headerlink\" title=\"命名tabbar controller的tabbar\"></a>命名tabbar controller的tabbar</h4><p>并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_6.png?raw=true\" alt=\"storyboard_6\"><br>navigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。</p>\n<h4 id=\"设置ViewController对应的类\"><a href=\"#设置ViewController对应的类\" class=\"headerlink\" title=\"设置ViewController对应的类\"></a>设置ViewController对应的类</h4><p>选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_7.png?raw=true\" alt=\"storyboard_7\"></p>\n<h4 id=\"获取视图控制器\"><a href=\"#获取视图控制器\" class=\"headerlink\" title=\"获取视图控制器\"></a>获取视图控制器</h4><p>就是通过<code>UITableViewController</code>和<code>UINavigationController</code>中的<code>viewControllers</code>获取：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = (<span class=\"built_in\">UITabBarController</span> *)<span class=\"keyword\">self</span>.window.rootViewController;</div><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navigationController = [tabBarController viewControllers][<span class=\"number\">0</span>];</div><div class=\"line\">PlayersViewController *playersViewController = [navigationController viewControllers][<span class=\"number\">0</span>];</div></pre></td></tr></table></figure>\n<h4 id=\"Prototype-cells\"><a href=\"#Prototype-cells\" class=\"headerlink\" title=\"Prototype cells\"></a>Prototype cells</h4><p>选中tableview，设置tableview的 cotent 为 Dynamic Propotype<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_8.png?raw=true\" alt=\"storyboard_8\"><br>一般在<code>tableView: cellForRowAtIndexPath:</code>方法中都像下面：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *CellIdentifier = <span class=\"string\">@\"Cell\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</div><div class=\"line\">    <span class=\"keyword\">if</span> (cell == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        cell = [[<span class=\"built_in\">UITableViewCell</span> alloc] initWithStyle:<span class=\"built_in\">UITableViewCellStyleDefault</span></div><div class=\"line\">                                      reuseIdentifier:CellIdentifier];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Configure the cell...</span></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，由于在storyboard中已经创建了cell，那么就可以直接使用了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class=\"string\">@\"PlayerCell\"</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Configure the cell...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> cell;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_9.png?raw=true\" alt=\"storyboard_9\"><br>设置不同的 identifier 来标识不同的cell。</p>\n<p>除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。</p>\n<h4 id=\"Static-cells\"><a href=\"#Static-cells\" class=\"headerlink\" title=\"Static cells\"></a>Static cells</h4><p>使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_10.png?raw=true\" alt=\"storyboard_10\"><br>因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。</p>\n<p>那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_11.png?raw=true\" alt=\"storyboard_11\"><br>此时右边栏出现如图所示 Table View Section<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_12.png?raw=true\" alt=\"storyboard_12\"><br>可以设置数量，表头表尾的title</p>\n<p>和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。<br>也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。</p>\n<p>所以，方便起见，static cell 直接在viewController中连线设置就可以了。</p>\n<h2 id=\"使用segue\"><a href=\"#使用segue\" class=\"headerlink\" title=\"使用segue\"></a>使用segue</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"什么是Segue\"><a href=\"#什么是Segue\" class=\"headerlink\" title=\"什么是Segue\"></a>什么是Segue</h4><p>Storyboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）</p>\n<h4 id=\"Segue的属性\"><a href=\"#Segue的属性\" class=\"headerlink\" title=\"Segue的属性\"></a>Segue的属性</h4><p>每一个Segue对象，都有3个属性</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一标识</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSString</span> *identifier;</div><div class=\"line\"><span class=\"comment\">// 来源控制器</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"keyword\">id</span> sourceViewController;</div><div class=\"line\"><span class=\"comment\">// 目标控制器</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"keyword\">id</span> destinationViewController;</div></pre></td></tr></table></figure>\n<h4 id=\"Segue的类型\"><a href=\"#Segue的类型\" class=\"headerlink\" title=\"Segue的类型\"></a>Segue的类型</h4><p>根据Segue的执行（跳转）时刻，Segue可以分为2大类型:</p>\n<ul>\n<li>自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。</li>\n<li>手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。</li>\n</ul>\n<h4 id=\"segue执行过程\"><a href=\"#segue执行过程\" class=\"headerlink\" title=\"segue执行过程\"></a>segue执行过程</h4><p>手动调用<code>performSegueWithIdentifier:sender:</code>方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。</p>\n<ol>\n<li>根据<code>identifier</code>去storyboard中找到对应的线，新建UIStoryboardSegue对象</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier source:(<span class=\"built_in\">UIViewController</span> *)source destination:(<span class=\"built_in\">UIViewController</span> *)destination; <span class=\"comment\">// Designated initializer</span></div></pre></td></tr></table></figure>\n<p>其实就是执行了UIStoryboardSegue中<code>initWithIdentifier:source:destination:</code>方法,并且<code>identifier</code>就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾</p>\n<ol>\n<li>调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender;</div></pre></td></tr></table></figure>\n<p>所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。</p>\n<ol>\n<li>调用Segue对象的<code>perform</code>方法开始执行界面跳转操作。</li>\n</ol>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p>segue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。</p>\n<h4 id=\"跳进\"><a href=\"#跳进\" class=\"headerlink\" title=\"跳进\"></a>跳进</h4><h5 id=\"使用storyboard\"><a href=\"#使用storyboard\" class=\"headerlink\" title=\"使用storyboard\"></a>使用storyboard</h5><p>Action segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。<br>Manual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。</p>\n<p>首先，先对两个viewController进行连线：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_14.png?raw=true\" alt=\"storyboard_14\"><br>之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_15.png?raw=true\" alt=\"storyboard_15\"><br>其中参数 <code>identifier</code> 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。</p>\n<p>接下来就可以调用方法，在合适的时机加载了</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//根据 segue Identifier跳转界面</span></div><div class=\"line\">[<span class=\"keyword\">self</span> performSegueWithIdentifier:<span class=\"string\">@\"GotoTwo\"</span> sender:<span class=\"keyword\">self</span>];</div></pre></td></tr></table></figure>\n<p>其中的<code>identifer</code>自然不用多说，那么<code>sender</code>是什么呢？<code>sender</code>是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置<code>sender</code>区分了。引申开来，在设置button点击事件时的<code>-(IBAction)click:(id)sender;</code>方法中的<code>sender</code>和这里的<code>sender</code>是一个作用。</p>\n<h5 id=\"使用纯代码\"><a href=\"#使用纯代码\" class=\"headerlink\" title=\"使用纯代码\"></a>使用纯代码</h5><p>上面的方法实现效果和平时用的下面两个方法相同：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//以modal 方式跳转</span></div><div class=\"line\">[<span class=\"keyword\">self</span> presentViewController:ViewController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\"><span class=\"comment\">//压进一个viewcontroller</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:ViewController animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>不过，既然用了storyboard了，那么实例化viewController时就不能用<code>initWithNibName</code>了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_19.png?raw=true\" alt=\"storyboard_19\"><br>那个<code>use storyboardId</code>的勾不打也行，不知道干什么用的，</p>\n<p>现在就可以在代码中找到特定storyboard的viewcontroller了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)tapButton:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard,</span></div><div class=\"line\">    <span class=\"built_in\">UIStoryboard</span> *story = [<span class=\"built_in\">UIStoryboard</span> storyboardWithName:<span class=\"string\">@\"Main\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//由storyboard根据myView的storyBoardID来获取我们要切换的视图</span></div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> *myView = [story instantiateViewControllerWithIdentifier:<span class=\"string\">@\"myView\"</span>];</div><div class=\"line\">    <span class=\"comment\">//显示ViewController</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> presentViewController:myView animated:<span class=\"literal\">YES</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"跳出\"><a href=\"#跳出\" class=\"headerlink\" title=\"跳出\"></a>跳出</h4><p>能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。</p>\n<h5 id=\"exit-segue\"><a href=\"#exit-segue\" class=\"headerlink\" title=\"exit segue\"></a>exit segue</h5><p>跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1：</p>\n<p>先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是<code>IBAction</code>，参数类型<strong>一定</strong>是<code>UIStoryboardSegue</code>，名称随便（这个方法一定要加，返回时调用的）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//其他界面返回到此界面调用的方法</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)ViewController1UnwindSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择<code>manual</code>，这里连接自己表示要在当前viewcontroller中用代码的方式回退。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_17.png?raw=true\" alt=\"storyboard_17\"></p>\n<p>给2视图的unwind segue取一个名字叫<code>from2to1</code>的identifier如下图:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_18.png?raw=true\" alt=\"storyboard_18\"></p>\n<p>现在就可以在界面2中的任意时候调用方法回退了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)back:(<span class=\"keyword\">id</span>)sender &#123;</div><div class=\"line\">　　<span class=\"comment\">//执行segue跳页的方法</span></div><div class=\"line\">    [<span class=\"keyword\">self</span> performSegueWithIdentifier:<span class=\"string\">@\"from2to1\"</span> sender:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//其他界面返回到此界面调用的方法</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)ViewController1UnwindSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([unwindSegue.identifier isEqualToString:<span class=\"string\">@\"from2to1\"</span>]) &#123;</div><div class=\"line\">        _lbShowMessage.text = <span class=\"string\">@\"从2退到1\"</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([unwindSegue.identifier isEqualToString:<span class=\"string\">@\"from3to1\"</span>]) &#123;</div><div class=\"line\">        _lbShowMessage.text = <span class=\"string\">@\"从3退到1\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里就看出上面为什么说类型一定是<code>UIStoryboardSegue</code>了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。</p>\n<p>使用 exit segue 的<strong>好处</strong>是可以跳转到任意打开过的界面比如从3-&gt;1，而不是只能返回上级界面从2-&gt;1。</p>\n<h5 id=\"一般跳出方法\"><a href=\"#一般跳出方法\" class=\"headerlink\" title=\"一般跳出方法\"></a>一般跳出方法</h5><p>也可以使用代码根据是model类型还是push类型选择：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//弹出一个viewcontroller  相当与返回上一个界面</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController popViewControllerAnimated:<span class=\"literal\">YES</span>];   </div><div class=\"line\"><span class=\"comment\">// 以 modal跳转的返回方法</span></div><div class=\"line\">[<span class=\"keyword\">self</span> dismissViewControllerAnimated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure>\n<h3 id=\"跳转的方式\"><a href=\"#跳转的方式\" class=\"headerlink\" title=\"跳转的方式\"></a>跳转的方式</h3><p>在进行跳转连线后会出现如下窗口：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_13.png?raw=true\" alt=\"storyboard_13\"><br>共有三种跳转方式，也就是上面右边栏的<code>Kind</code>属性</p>\n<h4 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h4><p>Push类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。</p>\n<h4 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h4><p>最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的<code>Presentation</code>选择需要展示的动画效果。</p>\n<h4 id=\"custom\"><a href=\"#custom\" class=\"headerlink\" title=\"custom\"></a>custom</h4><p>自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_16.png?raw=true\" alt=\"storyboard_16\"><br>这段代码的作用是创建从中心渐变充满屏幕的动画:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)perform&#123;</div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> * svc = <span class=\"keyword\">self</span>.sourceViewController;</div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> * dvc = <span class=\"keyword\">self</span>.destinationViewController;</div><div class=\"line\">    [svc.view addSubview:dvc.view];</div><div class=\"line\">    [dvc.view setFrame:svc.view.frame];</div><div class=\"line\">    [dvc.view setTransform:<span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>)];</div><div class=\"line\">    [dvc.view setAlpha:<span class=\"number\">0.0</span>];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1.0</span></div><div class=\"line\">                     animations:^&#123;</div><div class=\"line\">                         [dvc.view setTransform:<span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>)];</div><div class=\"line\">                         [dvc.view setAlpha:<span class=\"number\">1.0</span>];</div><div class=\"line\">                     &#125;</div><div class=\"line\">                     completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">                         [svc presentViewController:dvc animated:<span class=\"literal\">NO</span> completion:<span class=\"literal\">nil</span>];</div><div class=\"line\">                     &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其实实质还是<code>presentViewController</code>，但是不用系统带的<code>animation</code>，而是先将<code>destinationViewController</code>的页面用动画加载后，直接<code>present</code>。</p>\n<h3 id=\"跳转传值\"><a href=\"#跳转传值\" class=\"headerlink\" title=\"跳转传值\"></a>跳转传值</h3><p>前面说到，<code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</code>方法会在跳转时自动触发。跳转传值就在这个方法内完成。</p>\n<p>我们可以对Segue的标识进行判断，一般有以下两种方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([segue.identifier  isEqual: <span class=\"string\">@\"login2index\"</span>]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 需要执行的代码</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([segue.destinationViewController isKindOfClass:[IndexTableViewController <span class=\"keyword\">class</span>]]) &#123;</div><div class=\"line\">        <span class=\"comment\">//  执行代码</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。</p>\n<p>接下来就可以对<code>destination</code>进行赋值了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)prepareForSegue:(<span class=\"built_in\">UIStoryboardSegue</span> *)segue sender:(<span class=\"keyword\">id</span>)sender</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"触发该场景切换的sender对象的类型是:%@\"</span>,[sender <span class=\"keyword\">class</span>]);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//方法一,使用KVC给B 也就是目标场景传值</span></div><div class=\"line\">    <span class=\"built_in\">UIViewController</span> *destinationController=[segue destinationViewController];</div><div class=\"line\">    [destinationController setValue:<span class=\"string\">@\"119\"</span> forKey:<span class=\"string\">@\"number\"</span>];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//方法2,使用属性传值,需导入相关的类.h</span></div><div class=\"line\">    <span class=\"comment\">//BViewController *bController=[segue destinationViewController];</span></div><div class=\"line\">    <span class=\"comment\">//bController.number=@188;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>跳转传值不仅可以用<code>prepareForSegue:sender:</code>实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见<a href=\"http://blog.csdn.net/mad1989/article/details/7919504#comments\">使用storyboard实现页面跳转，简单的数据传递</a></p>\n<h3 id=\"多分支NavigationController\"><a href=\"#多分支NavigationController\" class=\"headerlink\" title=\"多分支NavigationController\"></a>多分支NavigationController</h3><p>主要应用在下面这种情况：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_20.png?raw=true\" alt=\"storyboard_20\"><br>navigationController要分情况跳转到界面A或者界面B，但是navigationController只能有一个<code>rootViewController</code>啊。所以，通过一个空的<code>ParentViewController</code>在<code>viewWillAppear:</code>方法中加载任意一个<code>ChildViewController</code>。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_22.png?raw=true\" alt=\"storyboard_22\"></p>\n<p>注意，上图红框中的分支，其实<strong>表现的只是一个页面的两种形态</strong>，本质上还是一个页面。所以加载<code>childViewController</code>的segue都要用不带任何动画的<code>custome</code>类型。因为如果<code>ChildViewController</code>有动画，那么就会暴露出<code>ParentViewController</code>中的空白部分，就表现为两个页面了。</p>\n<p>可以看出，这个方法的优点是可以通过<code>parent</code>，从<code>C1</code>直接跳到<code>C2</code>，如果不用这种父子ViewController的方式，那么不可避免的就得先从<code>C1</code>跳回前一级页面，然后再从前一级页面跳到<code>C2</code>。不过缺点就是<code>C1</code>到<code>C2</code>的跳转没有任何跳转动画。</p>\n<p>不过，思考了一段时间后，觉得多分支NavigationController本身并不是一个问题，用父子ViewController的方式虽然能解决，但是把问题复杂化了。比如应用在登录跳转上，我完全可以不用在加载NavigationController后再判断是否要登录，而是把这一过程放到加载NavigationController之前。至于可以直接跳转的这一好处，一般情况下，产品也不会这么设计，而且它的弊端也是很明显的。</p>\n<p>具体实现的过程参见<a href=\"http://www.cnblogs.com/shanpow/p/4149462.html\">基于Storyboard的创建多分支NavigationController的方法</a>。记得如果使用这种方法的话，一定要清除<code>Parent</code>中上次显示的<code>ChildViewController</code>，文中在<code>prepareForSegue:sender:</code>方法中清除，是个很好的时机。 </p>\n<h2 id=\"storyboard-reference\"><a href=\"#storyboard-reference\" class=\"headerlink\" title=\"storyboard reference\"></a>storyboard reference</h2><p>iOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。</p>\n<h3 id=\"简化现有storyboard\"><a href=\"#简化现有storyboard\" class=\"headerlink\" title=\"简化现有storyboard\"></a>简化现有storyboard</h3><p>如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_23.png?raw=true\" alt=\"storyboard_23\"></p>\n<p>做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor-&gt;Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_24.png?raw=true\" alt=\"storyboard_24\"></p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_25.png?raw=true\" alt=\"storyboard_25\"></p>\n<h3 id=\"加载storyboard中一个特定viewController\"><a href=\"#加载storyboard中一个特定viewController\" class=\"headerlink\" title=\"加载storyboard中一个特定viewController\"></a>加载storyboard中一个特定viewController</h3><p>和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_26.png?raw=true\" alt=\"storyboard_26\"></p>\n<p>然后设置storyboard：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_27.png?raw=true\" alt=\"storyboard_27\"><br>这里面<code>storyboard</code>填的是目标storboard的文件名；<code>Reference ID</code>是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的<code>Storyboard ID</code>，具体在哪设，上面也说过。</p>\n<p>这样，一个简洁的storyboard就能创建出来了。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://www.jianshu.com/p/2ec2c19f183e\">【Storyboard】Storyboard介绍及使用</a></p>\n<p><a href=\"http://birdmichael.com/?p=180\">UIStoryboardSegue讲解</a>;</p>\n<p><a href=\"http://blog.csdn.net/yangbingbinga/article/details/43704269\">iOS-prepareForSegue场景切换,KVC传值</a>;</p>\n<p><a href=\"http://blog.csdn.net/mad1989/article/details/7919504#comments\">(4.4.1)使用storyboard实现页面跳转，简单的数据传递</a>;</p>\n<p><a href=\"http://blog.csdn.net/xuqiang918/article/details/17023737\">【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递</a></p>\n<p><a href=\"https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references\">iOS9 Day-by-Day :: Day 3 :: Storyboard References</a>;</p>\n<p><a href=\"http://www.cnblogs.com/shanpow/p/4149462.html\">基于Storyboard的创建多分支NavigationController的方法</a>;</p>\n<p><a href=\"http://blog.csdn.net/yangmeng13930719363/article/details/49886901\">iOS 9 Storyboard 教程(一下)</a>;</p>\n<p><a href=\"http://www.xmcgraw.com/10-practical-tips-for-ios-developers-using-storyboards/\">10 Practical Tips for iOS Developers Using Storyboards</a>;</p>\n<p>还有一些看完随手就关了，没有记录。</p>\n<p>水平有限，如有错误，多多指正~</p>"},{"title":"runLoop学习笔记","date":"2016-11-01T06:07:12.000Z","_content":"\nrunLoop 虽然平时用不到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。\n\n<!--more-->\n\n## 概念\n### 什么是RunLoop\n以下是一个 iOS 程序的 main 函数：\n\n```objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\nmain 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。\n\n上面代码中 `UIApplicationMain()` 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示：\n\n![runloop_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_1.png?raw=true)\n\n在 OS X/iOS 系统中，提供了两个这样的对象：\n- **CFRunLoopRef**：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。\n- **NSRunLoop**：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。\n\n先来一张 RunLoop 机制关系图总览：\n\n![runloop_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_2.png?raw=true)\n\n### RunLoop与线程的关系\n苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 `CFRunLoopGetMain()`， `CFRunLoopGetCurrent()`。NSRunLoop 的获取方法是 `currentRunLoop`,`mainRunLoop`。NSRunLoop 对象可以通过 `getCFRunLoop` 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下：\n\n```objc\n/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n \n/// 获取一个 pthread 对应的 Run Loop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n    \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n    \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n    \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n    \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个`1`的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop对外接口\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n- CFRunLoopRef\n- CFRunLoopModeRef\n- CFRunLoopSourceRef\n- CFRunLoopTimerRef\n- CFRunLoopObserverRef\n\n其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n![runloop_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_3.png?raw=true)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n### 接口类型\n#### RunLoop的Source\nRunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）：\n- Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：`performSelector:onThread:`\n- Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：`[NSTimer scheduledTimerWithTimeInterval:target:selector:]`\n\n下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源\n![runloop_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_4.png?raw=true)\n\n##### Input Source\nInput Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)：\n- Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 `CFRunLoopSourceSignal(source)`，将这个 Source 标记为待处理，然后手动调用 `CFRunLoopWakeUp(runloop)` 来唤醒 RunLoop，让其处理这个事件。\n- Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\n##### Time Source\n基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。\n\nFoundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 `scheduledTimerWithTimeInterval` 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（`scheduledTimerWithTimeInterval` 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。）\n\n#### RunLoop的Mode\nRunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。\n\n系统默认定了一下几个 mode：\n- kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的\n- UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\n- UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）\n- GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到\n- kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。\n\nMode 暴露的管理 mode item 的接口有下面几个：\n\n```objc\nCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\nCFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\n```\n\n#### RunLoop的Observers\n对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件：\n- 进入 RunLoop 的时候\n- RunLoop 将要处理一个 Timer source 的时候\n- RunLoop 将要处理一个 Input source 的时候\n- RunLoop 将要休眠的时候\n- RunLoop 被唤醒，并准备处理唤醒它的事件的时候\n- RunLoop 将要退出的时候\n\n### 使用方式\n#### Input Source \n#### Timer Source\n#### Observers\n\n这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。\n[RunLoop深度探究（五）](http://yangchao0033.github.io/blog/2016/01/18/runloop-5/)\n[RunLoop](http://blog.imemo8.com/2016/04/17/RunLoop/)\n[走进Run Loop的世界 (一)：什么是Run Loop？](http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/)\n[iOS多线程编程指南（三）Run Loop](https://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html)\n相关使用 Demo 也放到 github 上了。\n\n## 实现\n### 处理过程\n![runloop_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_5.png?raw=true)\n\n```objc\n/// 用DefaultMode启动\nvoid CFRunLoopRun(void) {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n}\n \n/// 用指定的Mode启动，允许设置RunLoop超时时间\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);\n}\n \n/// RunLoop的实现\nint CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {\n    \n    /// 首先根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n    \n    /// 1. 通知 Observers: RunLoop 即将进入 loop。\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n    \n    /// 内部函数，进入loop\n    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {\n        \n        Boolean sourceHandledThisLoop = NO;\n        int retVal = 0;\n        do {\n \n            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n            \n            /// 4. RunLoop 触发 Source0 (非port) 回调。\n            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n \n            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n            if (__Source0DidDispatchPortLastTime) {\n                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)\n                if (hasMsg) goto handle_msg;\n            }\n            \n            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n            if (!sourceHandledThisLoop) {\n                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            }\n            \n            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n            /// • 一个基于 port 的Source 的事件。\n            /// • 一个 Timer 到时间了\n            /// • RunLoop 自身的超时时间到了\n            /// • 被其他什么调用者手动唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {\n                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n            }\n \n            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n            \n            /// 收到消息，处理消息。\n            handle_msg:\n \n            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\n            if (msg_is_timer) {\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } \n \n            /// 9.2 如果有dispatch到main_queue的block，执行block。\n            else if (msg_is_dispatch) {\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } \n \n            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件\n            else {\n                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);\n                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n                if (sourceHandledThisLoop) {\n                    mach_msg(reply, MACH_SEND_MSG, reply);\n                }\n            }\n            \n            /// 执行加入到Loop的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n            \n \n            if (sourceHandledThisLoop && stopAfterHandle) {\n                /// 进入loop时参数说处理完事件就返回。\n                retVal = kCFRunLoopRunHandledSource;\n            } else if (timeout) {\n                /// 超出传入参数标记的超时时间了\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) {\n                /// 被外部调用者强制停止了\n                retVal = kCFRunLoopRunStopped;\n            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {\n                /// source/timer/observer一个都没有了\n                retVal = kCFRunLoopRunFinished;\n            }\n            \n            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n        } while (retVal == 0);\n    }\n    \n    /// 10. 通知 Observers: RunLoop 即将退出。\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n}\n```\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n### RunLoop 的底层实现\n从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 `mach_msg()`。为了实现消息的发送和接收，`mach_msg()` 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 `mach_msg_trap()`，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 `mach_msg_trap()` 时会触发陷阱机制，切换到内核态；内核态中内核实现的 `mach_msg()` 函数会完成实际的工作，如下图：\n![runloop_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_6.png?raw=true)\n\n**RunLoop 的核心就是一个 `mach_msg()`，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 `mach_msg_trap()` 这个地方。**\n\n关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。\n\n## 应用\n苹果使用 RunLoop 实现了诸多功能\n\n### AutoreleasePool\nAutorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池 Push 和 Pop。\n\n#### 一个例子\n\n```objc\n__weak id reference = nil;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    // str是一个autorelease对象，设置一个weak的引用来观察它\n    reference = str;\n}\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    NSLog(@\"%@\", reference); // Console: sunnyxx\n}\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    NSLog(@\"%@\", reference); // Console: (null)\n}\n```\n\n可以看到，在 `viewDidLoad` 方法后，一直到 `viewWillAppear` 字符串 reference 都没有被销毁，直到 `viewDidAppear` 方法后，才置为 `null`(这里创建字符串用的是 `stringWithFormat`，是在堆中创建一个对象，而不是在常量区)。由于这个 vc 在 `loadView` 之后便 add 到了 window 层级上，所以 `viewDidLoad` 和 `viewWillAppear` 是在同一个 `runloop` 调用的，因此在 `viewWillAppear` 中，这个 autorelease 的变量依然有值。\n\n当然，我们也可以手动干预Autorelease对象的释放时机：\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    @autoreleasepool {\n        NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    }\n    NSLog(@\"%@\", str); // Console: (null)\n}\n```\n\n#### AutoreleasePool 原理\nARC下，我们使用 `@autoreleasepool{}` 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：\n\n```objc\nvoid *context = objc_autoreleasePoolPush();\n// {}中的代码\nobjc_autoreleasePoolPop(context);\n```\n\n而这两个函数都是对 `AutoreleasePoolPage` 的简单封装，所以自动释放机制的核心就在于这个类。\n\n`AutoreleasePoolPage` 是一个 C++ 实现的类\n![runloop_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_7.png?raw=true)\n\n- AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）\n- AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）\n- AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址\n- 上面的 `id *next` 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置\n- 一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入\n\n所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图：\n![runloop_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_8.png?raw=true)\n\n图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 `autorelease` 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。\n\n每当进行一次 `objc_autoreleasePoolPush` 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子：\n![runloop_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_9.png?raw=true)\n\n`objc_autoreleasePoolPush` 的返回值正是这个哨兵对象的地址，被 `objc_autoreleasePoolPop` (哨兵对象)作为入参，于是：\n1. 根据传入的哨兵对象地址找到哨兵对象所处的 page\n2. 在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 `- release` 消息，并向回移动 next 指针到正确位置\n3. 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page\n\n刚才的 `objc_autoreleasePoolPop` 执行后，最终变成了下面的样子：\n![runloop_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_10.png?raw=true)\n\n\n### 事件响应\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 `__IOHIDEventSystemClientQueueCallback()`。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 `_UIApplicationHandleEventQueue()` 进行应用内部的分发。\n\n`_UIApplicationHandleEventQueue()` 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n当上面的 `_UIApplicationHandleEventQueue()` 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 `_UIGestureRecognizerUpdateObserver()`，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的  `setNeedsLayout/setNeedsDisplay` 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n`_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()` 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```objc\nZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n定时器使用方式：\n\n```objc\nself.timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n这里如果不是用的 `NSRunLoopCommonModes` 而是 `NSDefaultRunLoopMode` 那么当界面滑动时，无法执行 `showTime` 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。\n\n### PerformSelector\n当调用 NSObject 的 `performSelector:afterDelay:` 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。\n\n当调用 `performSelector:onThread:` 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。\n\n所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 `[[NSRunLoop currentRunLoop] run];`\n\n### 关于 GCD\nGCD 提供的某些接口也用到了 Run Loop， 例如 `dispatch_async()`。\n\n当调用 `dispatch_async(dispatch_get_main_queue(), block)` 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n### 关于网络请求\n\niOS 中，关于网络请求的接口自下至上有如下几层:\n- CFSocket\n- CFNetwork       ->ASIHttpRequest\n- NSURLConnection ->AFNetworking\n- NSURLSession    ->AFNetworking2, Alamofire\n\n![runloop_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_11.png?raw=true)\n\nNSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。\n\n\n### AFNetworking\nAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：\n\n```objc\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n \n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n\nRunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 `[runLoop run]` 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 `NSMachPort (mach_port)` 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。\n\n```objc\n- (void)start {\n    [self.lock lock];\n    if ([self isCancelled]) {\n        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    } else if ([self isReady]) {\n        self.state = AFOperationExecutingState;\n        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    }\n    [self.lock unlock];\n}\n```\n\n当需要这个后台线程执行任务时，AFNetworking 通过调用 `[NSObject performSelector:onThread:..]` 将这个任务扔到了后台线程的 RunLoop 中。\n\n\n## 参考\n[黑幕背后的Autorelease](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n[初识 Run Loop](http://itangqi.me/2016/04/14/the-first-meet-with-runloop/?utm_source=tuicool&utm_medium=referral)\n[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/)\n\n","source":"_posts/runloop.md","raw":"title: runLoop学习笔记\ndate: 2016/11/1 14:07:12  \ncategories: iOS\ntags: \n\t- 学习笔记\n\n---\n\nrunLoop 虽然平时用不到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。\n\n<!--more-->\n\n## 概念\n### 什么是RunLoop\n以下是一个 iOS 程序的 main 函数：\n\n```objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\nmain 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。\n\n上面代码中 `UIApplicationMain()` 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示：\n\n![runloop_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_1.png?raw=true)\n\n在 OS X/iOS 系统中，提供了两个这样的对象：\n- **CFRunLoopRef**：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。\n- **NSRunLoop**：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。\n\n先来一张 RunLoop 机制关系图总览：\n\n![runloop_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_2.png?raw=true)\n\n### RunLoop与线程的关系\n苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 `CFRunLoopGetMain()`， `CFRunLoopGetCurrent()`。NSRunLoop 的获取方法是 `currentRunLoop`,`mainRunLoop`。NSRunLoop 对象可以通过 `getCFRunLoop` 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下：\n\n```objc\n/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n \n/// 获取一个 pthread 对应的 Run Loop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n    \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n    \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n    \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n    \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个`1`的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop对外接口\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n- CFRunLoopRef\n- CFRunLoopModeRef\n- CFRunLoopSourceRef\n- CFRunLoopTimerRef\n- CFRunLoopObserverRef\n\n其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n![runloop_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_3.png?raw=true)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n### 接口类型\n#### RunLoop的Source\nRunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）：\n- Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：`performSelector:onThread:`\n- Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：`[NSTimer scheduledTimerWithTimeInterval:target:selector:]`\n\n下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源\n![runloop_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_4.png?raw=true)\n\n##### Input Source\nInput Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)：\n- Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 `CFRunLoopSourceSignal(source)`，将这个 Source 标记为待处理，然后手动调用 `CFRunLoopWakeUp(runloop)` 来唤醒 RunLoop，让其处理这个事件。\n- Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。\n\n##### Time Source\n基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。\n\nFoundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 `scheduledTimerWithTimeInterval` 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（`scheduledTimerWithTimeInterval` 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。）\n\n#### RunLoop的Mode\nRunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。\n\n系统默认定了一下几个 mode：\n- kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的\n- UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\n- UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）\n- GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到\n- kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。\n\nMode 暴露的管理 mode item 的接口有下面几个：\n\n```objc\nCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\nCFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);\nCFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);\nCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);\n```\n\n#### RunLoop的Observers\n对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件：\n- 进入 RunLoop 的时候\n- RunLoop 将要处理一个 Timer source 的时候\n- RunLoop 将要处理一个 Input source 的时候\n- RunLoop 将要休眠的时候\n- RunLoop 被唤醒，并准备处理唤醒它的事件的时候\n- RunLoop 将要退出的时候\n\n### 使用方式\n#### Input Source \n#### Timer Source\n#### Observers\n\n这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。\n[RunLoop深度探究（五）](http://yangchao0033.github.io/blog/2016/01/18/runloop-5/)\n[RunLoop](http://blog.imemo8.com/2016/04/17/RunLoop/)\n[走进Run Loop的世界 (一)：什么是Run Loop？](http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/)\n[iOS多线程编程指南（三）Run Loop](https://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html)\n相关使用 Demo 也放到 github 上了。\n\n## 实现\n### 处理过程\n![runloop_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_5.png?raw=true)\n\n```objc\n/// 用DefaultMode启动\nvoid CFRunLoopRun(void) {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n}\n \n/// 用指定的Mode启动，允许设置RunLoop超时时间\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);\n}\n \n/// RunLoop的实现\nint CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {\n    \n    /// 首先根据modeName找到对应mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);\n    /// 如果mode里没有source/timer/observer, 直接返回。\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n    \n    /// 1. 通知 Observers: RunLoop 即将进入 loop。\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n    \n    /// 内部函数，进入loop\n    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {\n        \n        Boolean sourceHandledThisLoop = NO;\n        int retVal = 0;\n        do {\n \n            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n            \n            /// 4. RunLoop 触发 Source0 (非port) 回调。\n            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);\n            /// 执行被加入的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n \n            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。\n            if (__Source0DidDispatchPortLastTime) {\n                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &msg)\n                if (hasMsg) goto handle_msg;\n            }\n            \n            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。\n            if (!sourceHandledThisLoop) {\n                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            }\n            \n            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。\n            /// • 一个基于 port 的Source 的事件。\n            /// • 一个 Timer 到时间了\n            /// • RunLoop 自身的超时时间到了\n            /// • 被其他什么调用者手动唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort) {\n                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg\n            }\n \n            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n            \n            /// 收到消息，处理消息。\n            handle_msg:\n \n            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。\n            if (msg_is_timer) {\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } \n \n            /// 9.2 如果有dispatch到main_queue的block，执行block。\n            else if (msg_is_dispatch) {\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } \n \n            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件\n            else {\n                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);\n                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n                if (sourceHandledThisLoop) {\n                    mach_msg(reply, MACH_SEND_MSG, reply);\n                }\n            }\n            \n            /// 执行加入到Loop的block\n            __CFRunLoopDoBlocks(runloop, currentMode);\n            \n \n            if (sourceHandledThisLoop && stopAfterHandle) {\n                /// 进入loop时参数说处理完事件就返回。\n                retVal = kCFRunLoopRunHandledSource;\n            } else if (timeout) {\n                /// 超出传入参数标记的超时时间了\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) {\n                /// 被外部调用者强制停止了\n                retVal = kCFRunLoopRunStopped;\n            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {\n                /// source/timer/observer一个都没有了\n                retVal = kCFRunLoopRunFinished;\n            }\n            \n            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。\n        } while (retVal == 0);\n    }\n    \n    /// 10. 通知 Observers: RunLoop 即将退出。\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n}\n```\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n### RunLoop 的底层实现\n从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 `mach_msg()`。为了实现消息的发送和接收，`mach_msg()` 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 `mach_msg_trap()`，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 `mach_msg_trap()` 时会触发陷阱机制，切换到内核态；内核态中内核实现的 `mach_msg()` 函数会完成实际的工作，如下图：\n![runloop_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_6.png?raw=true)\n\n**RunLoop 的核心就是一个 `mach_msg()`，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 `mach_msg_trap()` 这个地方。**\n\n关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。\n\n## 应用\n苹果使用 RunLoop 实现了诸多功能\n\n### AutoreleasePool\nAutorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池 Push 和 Pop。\n\n#### 一个例子\n\n```objc\n__weak id reference = nil;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    // str是一个autorelease对象，设置一个weak的引用来观察它\n    reference = str;\n}\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    NSLog(@\"%@\", reference); // Console: sunnyxx\n}\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    NSLog(@\"%@\", reference); // Console: (null)\n}\n```\n\n可以看到，在 `viewDidLoad` 方法后，一直到 `viewWillAppear` 字符串 reference 都没有被销毁，直到 `viewDidAppear` 方法后，才置为 `null`(这里创建字符串用的是 `stringWithFormat`，是在堆中创建一个对象，而不是在常量区)。由于这个 vc 在 `loadView` 之后便 add 到了 window 层级上，所以 `viewDidLoad` 和 `viewWillAppear` 是在同一个 `runloop` 调用的，因此在 `viewWillAppear` 中，这个 autorelease 的变量依然有值。\n\n当然，我们也可以手动干预Autorelease对象的释放时机：\n\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    @autoreleasepool {\n        NSString *str = [NSString stringWithFormat:@\"sunnyxx\"];\n    }\n    NSLog(@\"%@\", str); // Console: (null)\n}\n```\n\n#### AutoreleasePool 原理\nARC下，我们使用 `@autoreleasepool{}` 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：\n\n```objc\nvoid *context = objc_autoreleasePoolPush();\n// {}中的代码\nobjc_autoreleasePoolPop(context);\n```\n\n而这两个函数都是对 `AutoreleasePoolPage` 的简单封装，所以自动释放机制的核心就在于这个类。\n\n`AutoreleasePoolPage` 是一个 C++ 实现的类\n![runloop_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_7.png?raw=true)\n\n- AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）\n- AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）\n- AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址\n- 上面的 `id *next` 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置\n- 一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入\n\n所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图：\n![runloop_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_8.png?raw=true)\n\n图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 `autorelease` 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。\n\n每当进行一次 `objc_autoreleasePoolPush` 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子：\n![runloop_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_9.png?raw=true)\n\n`objc_autoreleasePoolPush` 的返回值正是这个哨兵对象的地址，被 `objc_autoreleasePoolPop` (哨兵对象)作为入参，于是：\n1. 根据传入的哨兵对象地址找到哨兵对象所处的 page\n2. 在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 `- release` 消息，并向回移动 next 指针到正确位置\n3. 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page\n\n刚才的 `objc_autoreleasePoolPop` 执行后，最终变成了下面的样子：\n![runloop_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_10.png?raw=true)\n\n\n### 事件响应\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 `__IOHIDEventSystemClientQueueCallback()`。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 `_UIApplicationHandleEventQueue()` 进行应用内部的分发。\n\n`_UIApplicationHandleEventQueue()` 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n当上面的 `_UIApplicationHandleEventQueue()` 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 `_UIGestureRecognizerUpdateObserver()`，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的  `setNeedsLayout/setNeedsDisplay` 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n`_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()` 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```objc\nZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n定时器使用方式：\n\n```objc\nself.timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n这里如果不是用的 `NSRunLoopCommonModes` 而是 `NSDefaultRunLoopMode` 那么当界面滑动时，无法执行 `showTime` 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。\n\n### PerformSelector\n当调用 NSObject 的 `performSelector:afterDelay:` 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。\n\n当调用 `performSelector:onThread:` 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。\n\n所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 `[[NSRunLoop currentRunLoop] run];`\n\n### 关于 GCD\nGCD 提供的某些接口也用到了 Run Loop， 例如 `dispatch_async()`。\n\n当调用 `dispatch_async(dispatch_get_main_queue(), block)` 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n### 关于网络请求\n\niOS 中，关于网络请求的接口自下至上有如下几层:\n- CFSocket\n- CFNetwork       ->ASIHttpRequest\n- NSURLConnection ->AFNetworking\n- NSURLSession    ->AFNetworking2, Alamofire\n\n![runloop_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_11.png?raw=true)\n\nNSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。\n\n\n### AFNetworking\nAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：\n\n```objc\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n \n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n\nRunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 `[runLoop run]` 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 `NSMachPort (mach_port)` 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。\n\n```objc\n- (void)start {\n    [self.lock lock];\n    if ([self isCancelled]) {\n        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    } else if ([self isReady]) {\n        self.state = AFOperationExecutingState;\n        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n    }\n    [self.lock unlock];\n}\n```\n\n当需要这个后台线程执行任务时，AFNetworking 通过调用 `[NSObject performSelector:onThread:..]` 将这个任务扔到了后台线程的 RunLoop 中。\n\n\n## 参考\n[黑幕背后的Autorelease](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)\n[初识 Run Loop](http://itangqi.me/2016/04/14/the-first-meet-with-runloop/?utm_source=tuicool&utm_medium=referral)\n[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/)\n\n","slug":"runloop","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxp005p7hzgco9478a8","content":"<p>runLoop 虽然平时用不到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。</p>\n<a id=\"more\"></a>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"什么是RunLoop\"><a href=\"#什么是RunLoop\" class=\"headerlink\" title=\"什么是RunLoop\"></a>什么是RunLoop</h3><p>以下是一个 iOS 程序的 main 函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([AppDelegate <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>\n<p>上面代码中 <code>UIApplicationMain()</code> 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_1.png?raw=true\" alt=\"runloop_1\"></p>\n<p>在 OS X/iOS 系统中，提供了两个这样的对象：</p>\n<ul>\n<li><strong>CFRunLoopRef</strong>：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</li>\n<li><strong>NSRunLoop</strong>：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</li>\n</ul>\n<p>先来一张 RunLoop 机制关系图总览：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_2.png?raw=true\" alt=\"runloop_2\"></p>\n<h3 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h3><p>苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 <code>CFRunLoopGetMain()</code>， <code>CFRunLoopGetCurrent()</code>。NSRunLoop 的获取方法是 <code>currentRunLoop</code>,<code>mainRunLoop</code>。NSRunLoop 对象可以通过 <code>getCFRunLoop</code> 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</div><div class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 Run Loop。</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</div><div class=\"line\">    OSSpinLockLock(&amp;loopsLock);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</div><div class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。</span></div><div class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</div><div class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</div><div class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></div><div class=\"line\">        loop = _CFRunLoopCreate();</div><div class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</div><div class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。</span></div><div class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</div><div class=\"line\">    <span class=\"keyword\">return</span> loop;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个<code>1</code>的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop对外接口\"><a href=\"#RunLoop对外接口\" class=\"headerlink\" title=\"RunLoop对外接口\"></a>RunLoop对外接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_3.png?raw=true\" alt=\"runloop_3\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><h4 id=\"RunLoop的Source\"><a href=\"#RunLoop的Source\" class=\"headerlink\" title=\"RunLoop的Source\"></a>RunLoop的Source</h4><p>RunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）：</p>\n<ul>\n<li>Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：<code>performSelector:onThread:</code></li>\n<li>Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：<code>[NSTimer scheduledTimerWithTimeInterval:target:selector:]</code></li>\n</ul>\n<p>下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_4.png?raw=true\" alt=\"runloop_4\"></p>\n<h5 id=\"Input-Source\"><a href=\"#Input-Source\" class=\"headerlink\" title=\"Input Source\"></a>Input Source</h5><p>Input Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)：</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>\n</ul>\n<h5 id=\"Time-Source\"><a href=\"#Time-Source\" class=\"headerlink\" title=\"Time Source\"></a>Time Source</h5><p>基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。</p>\n<p>Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 <code>scheduledTimerWithTimeInterval</code> 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（<code>scheduledTimerWithTimeInterval</code> 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。）</p>\n<h4 id=\"RunLoop的Mode\"><a href=\"#RunLoop的Mode\" class=\"headerlink\" title=\"RunLoop的Mode\"></a>RunLoop的Mode</h4><p>RunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。</p>\n<p>系统默认定了一下几个 mode：</p>\n<ul>\n<li>kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的</li>\n<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>\n<li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）</li>\n<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>\n<li>kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode</li>\n</ul>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。</p>\n<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CFRunLoopAddSource</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopSourceRef</span> source, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddTimer</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopTimerRef</span> timer, <span class=\"built_in\">CFStringRef</span> mode);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveSource</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopSourceRef</span> source, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveObserver</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveTimer</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopTimerRef</span> timer, <span class=\"built_in\">CFStringRef</span> mode);</div></pre></td></tr></table></figure>\n<h4 id=\"RunLoop的Observers\"><a href=\"#RunLoop的Observers\" class=\"headerlink\" title=\"RunLoop的Observers\"></a>RunLoop的Observers</h4><p>对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件：</p>\n<ul>\n<li>进入 RunLoop 的时候</li>\n<li>RunLoop 将要处理一个 Timer source 的时候</li>\n<li>RunLoop 将要处理一个 Input source 的时候</li>\n<li>RunLoop 将要休眠的时候</li>\n<li>RunLoop 被唤醒，并准备处理唤醒它的事件的时候</li>\n<li>RunLoop 将要退出的时候</li>\n</ul>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><h4 id=\"Input-Source-1\"><a href=\"#Input-Source-1\" class=\"headerlink\" title=\"Input Source\"></a>Input Source</h4><h4 id=\"Timer-Source\"><a href=\"#Timer-Source\" class=\"headerlink\" title=\"Timer Source\"></a>Timer Source</h4><h4 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h4><p>这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。<br><a href=\"http://yangchao0033.github.io/blog/2016/01/18/runloop-5/\" target=\"_blank\" rel=\"external\">RunLoop深度探究（五）</a><br><a href=\"http://blog.imemo8.com/2016/04/17/RunLoop/\" target=\"_blank\" rel=\"external\">RunLoop</a><br><a href=\"http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/\" target=\"_blank\" rel=\"external\">走进Run Loop的世界 (一)：什么是Run Loop？</a><br><a href=\"https://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html\" target=\"_blank\" rel=\"external\">iOS多线程编程指南（三）Run Loop</a><br>相关使用 Demo 也放到 github 上了。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"处理过程\"><a href=\"#处理过程\" class=\"headerlink\" title=\"处理过程\"></a>处理过程</h3><p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_5.png?raw=true\" alt=\"runloop_5\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 用DefaultMode启动</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CFRunLoopRun</span>(<span class=\"keyword\">void</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">CFRunLoopRunInMode</span>(<span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// RunLoop的实现</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 首先根据modeName找到对应mode</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class=\"literal\">false</span>);</div><div class=\"line\">    <span class=\"comment\">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class=\"keyword\">return</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 内部函数，进入loop</span></div><div class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class=\"line\">        </div><div class=\"line\">        Boolean sourceHandledThisLoop = <span class=\"literal\">NO</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> retVal = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class=\"line\">            <span class=\"comment\">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class=\"line\">            <span class=\"comment\">/// 执行被加入的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class=\"line\">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class=\"line\">            <span class=\"comment\">/// 执行被加入的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class=\"line\">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class=\"line\">                <span class=\"keyword\">if</span> (hasMsg) <span class=\"keyword\">goto</span> handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!sourceHandledThisLoop) &#123;</div><div class=\"line\">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class=\"line\">            <span class=\"comment\">/// • 一个基于 port 的Source 的事件。</span></div><div class=\"line\">            <span class=\"comment\">/// • 一个 Timer 到时间了</span></div><div class=\"line\">            <span class=\"comment\">/// • RunLoop 自身的超时时间到了</span></div><div class=\"line\">            <span class=\"comment\">/// • 被其他什么调用者手动唤醒</span></div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port); <span class=\"comment\">// thread wait for receive msg</span></div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 收到消息，处理消息。</span></div><div class=\"line\">            handle_msg:</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg_is_timer) &#123;</div><div class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (msg_is_dispatch) &#123;</div><div class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class=\"line\">                <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</div><div class=\"line\">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 执行加入到Loop的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\">            </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 进入loop时参数说处理完事件就返回。</span></div><div class=\"line\">                retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 超出传入参数标记的超时时间了</span></div><div class=\"line\">                retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 被外部调用者强制停止了</span></div><div class=\"line\">                retVal = kCFRunLoopRunStopped;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class=\"line\">                <span class=\"comment\">/// source/timer/observer一个都没有了</span></div><div class=\"line\">                retVal = kCFRunLoopRunFinished;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (retVal == <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h3 id=\"RunLoop-的底层实现\"><a href=\"#RunLoop-的底层实现\" class=\"headerlink\" title=\"RunLoop 的底层实现\"></a>RunLoop 的底层实现</h3><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 <code>mach_msg_trap()</code>，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 <code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_6.png?raw=true\" alt=\"runloop_6\"></p>\n<p><strong>RunLoop 的核心就是一个 <code>mach_msg()</code>，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</strong></p>\n<p>关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>苹果使用 RunLoop 实现了诸多功能</p>\n<h3 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h3><p>Autorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池 Push 和 Pop。</p>\n<h4 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> reference = <span class=\"literal\">nil</span>;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</div><div class=\"line\">    <span class=\"comment\">// str是一个autorelease对象，设置一个weak的引用来观察它</span></div><div class=\"line\">    reference = str;</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: sunnyxx</span></div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: (null)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，在 <code>viewDidLoad</code> 方法后，一直到 <code>viewWillAppear</code> 字符串 reference 都没有被销毁，直到 <code>viewDidAppear</code> 方法后，才置为 <code>null</code>(这里创建字符串用的是 <code>stringWithFormat</code>，是在堆中创建一个对象，而不是在常量区)。由于这个 vc 在 <code>loadView</code> 之后便 add 到了 window 层级上，所以 <code>viewDidLoad</code> 和 <code>viewWillAppear</code> 是在同一个 <code>runloop</code> 调用的，因此在 <code>viewWillAppear</code> 中，这个 autorelease 的变量依然有值。</p>\n<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str); <span class=\"comment\">// Console: (null)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"AutoreleasePool-原理\"><a href=\"#AutoreleasePool-原理\" class=\"headerlink\" title=\"AutoreleasePool 原理\"></a>AutoreleasePool 原理</h4><p>ARC下，我们使用 <code>@autoreleasepool{}</code> 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> *context = objc_autoreleasePoolPush();</div><div class=\"line\"><span class=\"comment\">// &#123;&#125;中的代码</span></div><div class=\"line\">objc_autoreleasePoolPop(context);</div></pre></td></tr></table></figure>\n<p>而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类。</p>\n<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_7.png?raw=true\" alt=\"runloop_7\"></p>\n<ul>\n<li>AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）</li>\n<li>AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）</li>\n<li>AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址</li>\n<li>上面的 <code>id *next</code> 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置</li>\n<li>一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入</li>\n</ul>\n<p>所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_8.png?raw=true\" alt=\"runloop_8\"></p>\n<p>图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 <code>autorelease</code> 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。</p>\n<p>每当进行一次 <code>objc_autoreleasePoolPush</code> 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_9.png?raw=true\" alt=\"runloop_9\"></p>\n<p><code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code> (哨兵对象)作为入参，于是：</p>\n<ol>\n<li>根据传入的哨兵对象地址找到哨兵对象所处的 page</li>\n<li>在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 <code>- release</code> 消息，并向回移动 next 指针到正确位置</li>\n<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page</li>\n</ol>\n<p>刚才的 <code>objc_autoreleasePoolPop</code> 执行后，最终变成了下面的样子：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_10.png?raw=true\" alt=\"runloop_10\"></p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>\n<p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的  <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class=\"line\">    QuartzCore:CA::Transaction::observer_callback:</div><div class=\"line\">        CA::Transaction::commit();</div><div class=\"line\">            CA::Context::commit_transaction();</div><div class=\"line\">                CA::Layer::layout_and_display_if_needed();</div><div class=\"line\">                    CA::Layer::layout_if_needed();</div><div class=\"line\">                        [<span class=\"built_in\">CALayer</span> layoutSublayers];</div><div class=\"line\">                            [<span class=\"built_in\">UIView</span> layoutSubviews];</div><div class=\"line\">                    CA::Layer::display_if_needed();</div><div class=\"line\">                        [<span class=\"built_in\">CALayer</span> display];</div><div class=\"line\">                            [<span class=\"built_in\">UIView</span> drawRect];</div></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>定时器使用方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">5</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:<span class=\"keyword\">self</span>.timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>\n<p>这里如果不是用的 <code>NSRunLoopCommonModes</code> 而是 <code>NSDefaultRunLoopMode</code> 那么当界面滑动时，无法执行 <code>showTime</code> 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。</p>\n<h3 id=\"PerformSelector\"><a href=\"#PerformSelector\" class=\"headerlink\" title=\"PerformSelector\"></a>PerformSelector</h3><p>当调用 NSObject 的 <code>performSelector:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>\n<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>\n<p>所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 <code>[[NSRunLoop currentRunLoop] run];</code></p>\n<h3 id=\"关于-GCD\"><a href=\"#关于-GCD\" class=\"headerlink\" title=\"关于 GCD\"></a>关于 GCD</h3><p>GCD 提供的某些接口也用到了 Run Loop， 例如 <code>dispatch_async()</code>。</p>\n<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h3 id=\"关于网络请求\"><a href=\"#关于网络请求\" class=\"headerlink\" title=\"关于网络请求\"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>\n<ul>\n<li>CFSocket</li>\n<li>CFNetwork       -&gt;ASIHttpRequest</li>\n<li>NSURLConnection -&gt;AFNetworking</li>\n<li>NSURLSession    -&gt;AFNetworking2, Alamofire</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_11.png?raw=true\" alt=\"runloop_11\"></p>\n<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>\n<h3 id=\"AFNetworking\"><a href=\"#AFNetworking\" class=\"headerlink\" title=\"AFNetworking\"></a>AFNetworking</h3><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 <code>[runLoop run]</code> 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 <code>NSMachPort (mach_port)</code> 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.state = AFOperationExecutingState;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidStart) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 <code>[NSObject performSelector:onThread:..]</code> 将这个任务扔到了后台线程的 RunLoop 中。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\" target=\"_blank\" rel=\"external\">黑幕背后的Autorelease</a><br><a href=\"http://itangqi.me/2016/04/14/the-first-meet-with-runloop/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">初识 Run Loop</a><br><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop</a></p>\n","excerpt":"<p>runLoop 虽然平时用不到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。</p>","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"什么是RunLoop\"><a href=\"#什么是RunLoop\" class=\"headerlink\" title=\"什么是RunLoop\"></a>什么是RunLoop</h3><p>以下是一个 iOS 程序的 main 函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([AppDelegate <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>main 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>\n<p>上面代码中 <code>UIApplicationMain()</code> 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_1.png?raw=true\" alt=\"runloop_1\"></p>\n<p>在 OS X/iOS 系统中，提供了两个这样的对象：</p>\n<ul>\n<li><strong>CFRunLoopRef</strong>：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</li>\n<li><strong>NSRunLoop</strong>：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</li>\n</ul>\n<p>先来一张 RunLoop 机制关系图总览：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_2.png?raw=true\" alt=\"runloop_2\"></p>\n<h3 id=\"RunLoop与线程的关系\"><a href=\"#RunLoop与线程的关系\" class=\"headerlink\" title=\"RunLoop与线程的关系\"></a>RunLoop与线程的关系</h3><p>苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 <code>CFRunLoopGetMain()</code>， <code>CFRunLoopGetCurrent()</code>。NSRunLoop 的获取方法是 <code>currentRunLoop</code>,<code>mainRunLoop</code>。NSRunLoop 对象可以通过 <code>getCFRunLoop</code> 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</div><div class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 Run Loop。</span></div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</div><div class=\"line\">    OSSpinLockLock(&amp;loopsLock);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</div><div class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。</span></div><div class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</div><div class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</div><div class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</div><div class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></div><div class=\"line\">        loop = _CFRunLoopCreate();</div><div class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</div><div class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。</span></div><div class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</div><div class=\"line\">    <span class=\"keyword\">return</span> loop;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个<code>1</code>的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop对外接口\"><a href=\"#RunLoop对外接口\" class=\"headerlink\" title=\"RunLoop对外接口\"></a>RunLoop对外接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_3.png?raw=true\" alt=\"runloop_3\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><h4 id=\"RunLoop的Source\"><a href=\"#RunLoop的Source\" class=\"headerlink\" title=\"RunLoop的Source\"></a>RunLoop的Source</h4><p>RunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）：</p>\n<ul>\n<li>Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：<code>performSelector:onThread:</code></li>\n<li>Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：<code>[NSTimer scheduledTimerWithTimeInterval:target:selector:]</code></li>\n</ul>\n<p>下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_4.png?raw=true\" alt=\"runloop_4\"></p>\n<h5 id=\"Input-Source\"><a href=\"#Input-Source\" class=\"headerlink\" title=\"Input Source\"></a>Input Source</h5><p>Input Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)：</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>\n</ul>\n<h5 id=\"Time-Source\"><a href=\"#Time-Source\" class=\"headerlink\" title=\"Time Source\"></a>Time Source</h5><p>基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。</p>\n<p>Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 <code>scheduledTimerWithTimeInterval</code> 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（<code>scheduledTimerWithTimeInterval</code> 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。）</p>\n<h4 id=\"RunLoop的Mode\"><a href=\"#RunLoop的Mode\" class=\"headerlink\" title=\"RunLoop的Mode\"></a>RunLoop的Mode</h4><p>RunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。</p>\n<p>系统默认定了一下几个 mode：</p>\n<ul>\n<li>kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的</li>\n<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>\n<li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）</li>\n<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>\n<li>kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode</li>\n</ul>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。</p>\n<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CFRunLoopAddSource</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopSourceRef</span> source, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopAddTimer</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopTimerRef</span> timer, <span class=\"built_in\">CFStringRef</span> mode);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveSource</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopSourceRef</span> source, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveObserver</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFStringRef</span> modeName);</div><div class=\"line\"><span class=\"built_in\">CFRunLoopRemoveTimer</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopTimerRef</span> timer, <span class=\"built_in\">CFStringRef</span> mode);</div></pre></td></tr></table></figure>\n<h4 id=\"RunLoop的Observers\"><a href=\"#RunLoop的Observers\" class=\"headerlink\" title=\"RunLoop的Observers\"></a>RunLoop的Observers</h4><p>对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件：</p>\n<ul>\n<li>进入 RunLoop 的时候</li>\n<li>RunLoop 将要处理一个 Timer source 的时候</li>\n<li>RunLoop 将要处理一个 Input source 的时候</li>\n<li>RunLoop 将要休眠的时候</li>\n<li>RunLoop 被唤醒，并准备处理唤醒它的事件的时候</li>\n<li>RunLoop 将要退出的时候</li>\n</ul>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><h4 id=\"Input-Source-1\"><a href=\"#Input-Source-1\" class=\"headerlink\" title=\"Input Source\"></a>Input Source</h4><h4 id=\"Timer-Source\"><a href=\"#Timer-Source\" class=\"headerlink\" title=\"Timer Source\"></a>Timer Source</h4><h4 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h4><p>这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。<br><a href=\"http://yangchao0033.github.io/blog/2016/01/18/runloop-5/\">RunLoop深度探究（五）</a><br><a href=\"http://blog.imemo8.com/2016/04/17/RunLoop/\">RunLoop</a><br><a href=\"http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/\">走进Run Loop的世界 (一)：什么是Run Loop？</a><br><a href=\"https://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html\">iOS多线程编程指南（三）Run Loop</a><br>相关使用 Demo 也放到 github 上了。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"处理过程\"><a href=\"#处理过程\" class=\"headerlink\" title=\"处理过程\"></a>处理过程</h3><p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_5.png?raw=true\" alt=\"runloop_5\"></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 用DefaultMode启动</span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CFRunLoopRun</span>(<span class=\"keyword\">void</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">CFRunLoopRunInMode</span>(<span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/// RunLoop的实现</span></div><div class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 首先根据modeName找到对应mode</span></div><div class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class=\"literal\">false</span>);</div><div class=\"line\">    <span class=\"comment\">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class=\"keyword\">return</span>;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 内部函数，进入loop</span></div><div class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class=\"line\">        </div><div class=\"line\">        Boolean sourceHandledThisLoop = <span class=\"literal\">NO</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> retVal = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">do</span> &#123;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class=\"line\">            <span class=\"comment\">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class=\"line\">            <span class=\"comment\">/// 执行被加入的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class=\"line\">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class=\"line\">            <span class=\"comment\">/// 执行被加入的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class=\"line\">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class=\"line\">                <span class=\"keyword\">if</span> (hasMsg) <span class=\"keyword\">goto</span> handle_msg;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!sourceHandledThisLoop) &#123;</div><div class=\"line\">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class=\"line\">            <span class=\"comment\">/// • 一个基于 port 的Source 的事件。</span></div><div class=\"line\">            <span class=\"comment\">/// • 一个 Timer 到时间了</span></div><div class=\"line\">            <span class=\"comment\">/// • RunLoop 自身的超时时间到了</span></div><div class=\"line\">            <span class=\"comment\">/// • 被其他什么调用者手动唤醒</span></div><div class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port); <span class=\"comment\">// thread wait for receive msg</span></div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 收到消息，处理消息。</span></div><div class=\"line\">            handle_msg:</div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (msg_is_timer) &#123;</div><div class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (msg_is_dispatch) &#123;</div><div class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class=\"line\">            &#125; </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"comment\">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"built_in\">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class=\"line\">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class=\"line\">                <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</div><div class=\"line\">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 执行加入到Loop的block</span></div><div class=\"line\">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class=\"line\">            </div><div class=\"line\"> </div><div class=\"line\">            <span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 进入loop时参数说处理完事件就返回。</span></div><div class=\"line\">                retVal = kCFRunLoopRunHandledSource;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 超出传入参数标记的超时时间了</span></div><div class=\"line\">                retVal = kCFRunLoopRunTimedOut;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class=\"line\">                <span class=\"comment\">/// 被外部调用者强制停止了</span></div><div class=\"line\">                retVal = kCFRunLoopRunStopped;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class=\"line\">                <span class=\"comment\">/// source/timer/observer一个都没有了</span></div><div class=\"line\">                retVal = kCFRunLoopRunFinished;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class=\"line\">        &#125; <span class=\"keyword\">while</span> (retVal == <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h3 id=\"RunLoop-的底层实现\"><a href=\"#RunLoop-的底层实现\" class=\"headerlink\" title=\"RunLoop 的底层实现\"></a>RunLoop 的底层实现</h3><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 <code>mach_msg_trap()</code>，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 <code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_6.png?raw=true\" alt=\"runloop_6\"></p>\n<p><strong>RunLoop 的核心就是一个 <code>mach_msg()</code>，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</strong></p>\n<p>关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>苹果使用 RunLoop 实现了诸多功能</p>\n<h3 id=\"AutoreleasePool\"><a href=\"#AutoreleasePool\" class=\"headerlink\" title=\"AutoreleasePool\"></a>AutoreleasePool</h3><p>Autorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池 Push 和 Pop。</p>\n<h4 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">id</span> reference = <span class=\"literal\">nil</span>;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</div><div class=\"line\">    <span class=\"comment\">// str是一个autorelease对象，设置一个weak的引用来观察它</span></div><div class=\"line\">    reference = str;</div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewWillAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: sunnyxx</span></div><div class=\"line\">&#125;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidAppear:(<span class=\"built_in\">BOOL</span>)animated &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidAppear:animated];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, reference); <span class=\"comment\">// Console: (null)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到，在 <code>viewDidLoad</code> 方法后，一直到 <code>viewWillAppear</code> 字符串 reference 都没有被销毁，直到 <code>viewDidAppear</code> 方法后，才置为 <code>null</code>(这里创建字符串用的是 <code>stringWithFormat</code>，是在堆中创建一个对象，而不是在常量区)。由于这个 vc 在 <code>loadView</code> 之后便 add 到了 window 层级上，所以 <code>viewDidLoad</code> 和 <code>viewWillAppear</code> 是在同一个 <code>runloop</code> 调用的，因此在 <code>viewWillAppear</code> 中，这个 autorelease 的变量依然有值。</p>\n<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"sunnyxx\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, str); <span class=\"comment\">// Console: (null)</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"AutoreleasePool-原理\"><a href=\"#AutoreleasePool-原理\" class=\"headerlink\" title=\"AutoreleasePool 原理\"></a>AutoreleasePool 原理</h4><p>ARC下，我们使用 <code>@autoreleasepool{}</code> 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> *context = objc_autoreleasePoolPush();</div><div class=\"line\"><span class=\"comment\">// &#123;&#125;中的代码</span></div><div class=\"line\">objc_autoreleasePoolPop(context);</div></pre></td></tr></table></figure>\n<p>而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类。</p>\n<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_7.png?raw=true\" alt=\"runloop_7\"></p>\n<ul>\n<li>AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）</li>\n<li>AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）</li>\n<li>AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址</li>\n<li>上面的 <code>id *next</code> 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置</li>\n<li>一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入</li>\n</ul>\n<p>所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_8.png?raw=true\" alt=\"runloop_8\"></p>\n<p>图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 <code>autorelease</code> 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。</p>\n<p>每当进行一次 <code>objc_autoreleasePoolPush</code> 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_9.png?raw=true\" alt=\"runloop_9\"></p>\n<p><code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code> (哨兵对象)作为入参，于是：</p>\n<ol>\n<li>根据传入的哨兵对象地址找到哨兵对象所处的 page</li>\n<li>在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 <code>- release</code> 消息，并向回移动 next 指针到正确位置</li>\n<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page</li>\n</ol>\n<p>刚才的 <code>objc_autoreleasePoolPop</code> 执行后，最终变成了下面的样子：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_10.png?raw=true\" alt=\"runloop_10\"></p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>\n<p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的  <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class=\"line\">    QuartzCore:CA::Transaction::observer_callback:</div><div class=\"line\">        CA::Transaction::commit();</div><div class=\"line\">            CA::Context::commit_transaction();</div><div class=\"line\">                CA::Layer::layout_and_display_if_needed();</div><div class=\"line\">                    CA::Layer::layout_if_needed();</div><div class=\"line\">                        [<span class=\"built_in\">CALayer</span> layoutSublayers];</div><div class=\"line\">                            [<span class=\"built_in\">UIView</span> layoutSubviews];</div><div class=\"line\">                    CA::Layer::display_if_needed();</div><div class=\"line\">                        [<span class=\"built_in\">CALayer</span> display];</div><div class=\"line\">                            [<span class=\"built_in\">UIView</span> drawRect];</div></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>定时器使用方式：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">5</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</div><div class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:<span class=\"keyword\">self</span>.timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>\n<p>这里如果不是用的 <code>NSRunLoopCommonModes</code> 而是 <code>NSDefaultRunLoopMode</code> 那么当界面滑动时，无法执行 <code>showTime</code> 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。</p>\n<h3 id=\"PerformSelector\"><a href=\"#PerformSelector\" class=\"headerlink\" title=\"PerformSelector\"></a>PerformSelector</h3><p>当调用 NSObject 的 <code>performSelector:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>\n<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>\n<p>所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 <code>[[NSRunLoop currentRunLoop] run];</code></p>\n<h3 id=\"关于-GCD\"><a href=\"#关于-GCD\" class=\"headerlink\" title=\"关于 GCD\"></a>关于 GCD</h3><p>GCD 提供的某些接口也用到了 Run Loop， 例如 <code>dispatch_async()</code>。</p>\n<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h3 id=\"关于网络请求\"><a href=\"#关于网络请求\" class=\"headerlink\" title=\"关于网络请求\"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>\n<ul>\n<li>CFSocket</li>\n<li>CFNetwork       -&gt;ASIHttpRequest</li>\n<li>NSURLConnection -&gt;AFNetworking</li>\n<li>NSURLSession    -&gt;AFNetworking2, Alamofire</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_11.png?raw=true\" alt=\"runloop_11\"></p>\n<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>\n<h3 id=\"AFNetworking\"><a href=\"#AFNetworking\" class=\"headerlink\" title=\"AFNetworking\"></a>AFNetworking</h3><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">void</span>)networkRequestThreadEntryPoint:(<span class=\"keyword\">id</span>)__unused object &#123;</div><div class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</div><div class=\"line\">        [[<span class=\"built_in\">NSThread</span> currentThread] setName:<span class=\"string\">@\"AFNetworking\"</span>];</div><div class=\"line\">        <span class=\"built_in\">NSRunLoop</span> *runLoop = [<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</div><div class=\"line\">        [runLoop addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</div><div class=\"line\">        [runLoop run];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"built_in\">NSThread</span> *)networkRequestThread &#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">NSThread</span> *_networkRequestThread = <span class=\"literal\">nil</span>;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> oncePredicate;</div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(networkRequestThreadEntryPoint:) object:<span class=\"literal\">nil</span>];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 <code>[runLoop run]</code> 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 <code>NSMachPort (mach_port)</code> 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)start &#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock lock];</div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isCancelled]) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(cancelConnection) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> isReady]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.state = AFOperationExecutingState;</div><div class=\"line\">        [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(operationDidStart) onThread:[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] networkRequestThread] withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span> modes:[<span class=\"keyword\">self</span>.runLoopModes allObjects]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 <code>[NSObject performSelector:onThread:..]</code> 将这个任务扔到了后台线程的 RunLoop 中。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.sunnyxx.com/2014/10/15/behind-autorelease/\">黑幕背后的Autorelease</a><br><a href=\"http://itangqi.me/2016/04/14/the-first-meet-with-runloop/?utm_source=tuicool&amp;utm_medium=referral\">初识 Run Loop</a><br><a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">深入理解RunLoop</a></p>"},{"title":"初识Provisioning Profile","date":"2016-08-26T06:07:12.000Z","_content":"\n真机调试的时候遇到了*provisioning profile即将过期*的警告，于是搜索并对provisioning profile作了一定了解。结合[关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系](http://www.cnblogs.com/cywin888/p/3263027.html)进行梳理。\n\n<!--more-->\n\n## 基本概念\n### Certificate\n证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。\n\n众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 \n\n![证书的私钥和公钥](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true)\n\n证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）\n\n### APP ID\nApp ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：\n- Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。\n- Wildcard App ID：通配符App ID，用于标识一组应用程序。例如\\*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。\n\n每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。\n\n### Device\nDevice最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。\n\n每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。\n\n### Provisioning Profile\n一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。\n\n试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。\n\n例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。\n\n![Provisioning Profile组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true)\n\n如上所述，在一台设备上运行应用程序的过程如下：\n\n![Provisioning Profile验证](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true)\n\n与证书一样，Provisioning Profile也分为Development和Distribution两种\n\n## Xcode 7+ 免证书真机调试\n在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app\n\n### 使用方法\n1. 打开自己已有的工程或者打开Xcode新建一个简单工程\n2. 菜单栏选择Xcode,下拉菜单中选择Preferences...(快捷键 command + , )\n\t![1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true)\n3. 在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。\n\t![2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true)\n4. 将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。\n\t![3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true)\n5. Xcode报错如下图所示，直接点击Fix Issue。\n\t![4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true)\n6. 警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。\n\t![5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true)\n\n\n\n","source":"_posts/初识Provisioning_Profile.md","raw":"title: 初识Provisioning Profile\ndate: 2016/8/26 14:07:12  \ncategories: iOS\ntags: [Xcode]\n\n---\n\n真机调试的时候遇到了*provisioning profile即将过期*的警告，于是搜索并对provisioning profile作了一定了解。结合[关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系](http://www.cnblogs.com/cywin888/p/3263027.html)进行梳理。\n\n<!--more-->\n\n## 基本概念\n### Certificate\n证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。\n\n众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 \n\n![证书的私钥和公钥](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true)\n\n证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）\n\n### APP ID\nApp ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：\n- Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。\n- Wildcard App ID：通配符App ID，用于标识一组应用程序。例如\\*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。\n\n每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。\n\n### Device\nDevice最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。\n\n每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。\n\n### Provisioning Profile\n一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。\n\n试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。\n\n例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。\n\n![Provisioning Profile组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true)\n\n如上所述，在一台设备上运行应用程序的过程如下：\n\n![Provisioning Profile验证](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true)\n\n与证书一样，Provisioning Profile也分为Development和Distribution两种\n\n## Xcode 7+ 免证书真机调试\n在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app\n\n### 使用方法\n1. 打开自己已有的工程或者打开Xcode新建一个简单工程\n2. 菜单栏选择Xcode,下拉菜单中选择Preferences...(快捷键 command + , )\n\t![1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true)\n3. 在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。\n\t![2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true)\n4. 将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。\n\t![3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true)\n5. Xcode报错如下图所示，直接点击Fix Issue。\n\t![4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true)\n6. 警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。\n\t![5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true)\n\n\n\n","slug":"初识Provisioning_Profile","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxr005s7hzgzavubun9","content":"<p>真机调试的时候遇到了<em>provisioning profile即将过期</em>的警告，于是搜索并对provisioning profile作了一定了解。结合<a href=\"http://www.cnblogs.com/cywin888/p/3263027.html\" target=\"_blank\" rel=\"external\">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a>进行梳理。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Certificate\"><a href=\"#Certificate\" class=\"headerlink\" title=\"Certificate\"></a>Certificate</h3><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。</p>\n<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true\" alt=\"证书的私钥和公钥\"></p>\n<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）</p>\n<h3 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>\n<ul>\n<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>\n<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>\n</ul>\n<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。</p>\n<h3 id=\"Device\"><a href=\"#Device\" class=\"headerlink\" title=\"Device\"></a>Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>\n<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>\n<h3 id=\"Provisioning-Profile\"><a href=\"#Provisioning-Profile\" class=\"headerlink\" title=\"Provisioning Profile\"></a>Provisioning Profile</h3><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>\n<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>\n<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true\" alt=\"Provisioning Profile组成\"></p>\n<p>如上所述，在一台设备上运行应用程序的过程如下：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true\" alt=\"Provisioning Profile验证\"></p>\n<p>与证书一样，Provisioning Profile也分为Development和Distribution两种</p>\n<h2 id=\"Xcode-7-免证书真机调试\"><a href=\"#Xcode-7-免证书真机调试\" class=\"headerlink\" title=\"Xcode 7+ 免证书真机调试\"></a>Xcode 7+ 免证书真机调试</h2><p>在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ol>\n<li>打开自己已有的工程或者打开Xcode新建一个简单工程</li>\n<li>菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , )<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true\" alt=\"1\"></li>\n<li>在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true\" alt=\"2\"></li>\n<li>将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true\" alt=\"3\"></li>\n<li>Xcode报错如下图所示，直接点击Fix Issue。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true\" alt=\"4\"></li>\n<li>警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true\" alt=\"5\"></li>\n</ol>\n","excerpt":"<p>真机调试的时候遇到了<em>provisioning profile即将过期</em>的警告，于是搜索并对provisioning profile作了一定了解。结合<a href=\"http://www.cnblogs.com/cywin888/p/3263027.html\">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a>进行梳理。</p>","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Certificate\"><a href=\"#Certificate\" class=\"headerlink\" title=\"Certificate\"></a>Certificate</h3><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。</p>\n<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true\" alt=\"证书的私钥和公钥\"></p>\n<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）</p>\n<h3 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>\n<ul>\n<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>\n<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>\n</ul>\n<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。</p>\n<h3 id=\"Device\"><a href=\"#Device\" class=\"headerlink\" title=\"Device\"></a>Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>\n<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>\n<h3 id=\"Provisioning-Profile\"><a href=\"#Provisioning-Profile\" class=\"headerlink\" title=\"Provisioning Profile\"></a>Provisioning Profile</h3><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>\n<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>\n<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true\" alt=\"Provisioning Profile组成\"></p>\n<p>如上所述，在一台设备上运行应用程序的过程如下：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true\" alt=\"Provisioning Profile验证\"></p>\n<p>与证书一样，Provisioning Profile也分为Development和Distribution两种</p>\n<h2 id=\"Xcode-7-免证书真机调试\"><a href=\"#Xcode-7-免证书真机调试\" class=\"headerlink\" title=\"Xcode 7+ 免证书真机调试\"></a>Xcode 7+ 免证书真机调试</h2><p>在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ol>\n<li>打开自己已有的工程或者打开Xcode新建一个简单工程</li>\n<li>菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , )<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true\" alt=\"1\"></li>\n<li>在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true\" alt=\"2\"></li>\n<li>将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true\" alt=\"3\"></li>\n<li>Xcode报错如下图所示，直接点击Fix Issue。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true\" alt=\"4\"></li>\n<li>警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true\" alt=\"5\"></li>\n</ol>"},{"title":"重新开始","date":"2016-07-30T06:07:12.000Z","_content":"时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。\n\n<!--more-->\n\n不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。\n\n今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！\n\n\n\n![fighting](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true)","source":"_posts/重新开始.md","raw":"---\ntitle: 重新开始\ndate: 2016/7/30 14:07:12  \ncategories: 无处置放\ntags: 杂谈\n\n---\n时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。\n\n<!--more-->\n\n不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。\n\n今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！\n\n\n\n![fighting](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true)","slug":"重新开始","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxt005v7hzg1dpqkr61","content":"<p>时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。</p>\n<a id=\"more\"></a>\n<p>不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。</p>\n<p>今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true\" alt=\"fighting\"></p>\n","excerpt":"<p>时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。</p>","more":"<p>不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。</p>\n<p>今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true\" alt=\"fighting\"></p>"},{"title":"删除Storyboard","date":"2016-08-11T06:07:12.000Z","_content":"\nxcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。\n<!--more-->\n\nstoryboard的入口在**targets->General->Deployment Info->Main Interface**，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。\n\n删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。\n- 点击placeholders下的File's Owner将Custom Class的Class设置为viewcController的名字。\n- 将File's Owner的view和xib的View进行关联。\n\n使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\tViewController *uv = [[ViewController alloc] initWithNibName:@\"ViewController\" bundle:nil];\n\t[self.window setRootViewController:uv];\n\t[self.window makeKeyAndVisible];\n\treturn YES;\n}\n```\n注意：这里的`ViewController`是你自定义的ViewController。\n\n如果要使用NavigationController需要写成这样:\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n   \tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    ViewController *vc = [[ViewController alloc]initWithNibName:@\"ViewController\" bundle:nil];\n    vc.title = @\"AutoHeightTableView\";\n    UINavigationController *uv = [[UINavigationController alloc] initWithRootViewController:vc];\n    [self.window setRootViewController:uv];\n    [self.window makeKeyAndVisible];\n    return YES;\n}\n```\n\n至此，app就可以显示新建的xib文件的布局了\n","source":"_posts/删除storyboard.md","raw":"title: 删除Storyboard\ndate: 2016/8/11 14:07:12  \ncategories: iOS \ntags: \n\t- UI\n\t- Xcode\n\t\n\n---\n\nxcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。\n<!--more-->\n\nstoryboard的入口在**targets->General->Deployment Info->Main Interface**，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。\n\n删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。\n- 点击placeholders下的File's Owner将Custom Class的Class设置为viewcController的名字。\n- 将File's Owner的view和xib的View进行关联。\n\n使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\tViewController *uv = [[ViewController alloc] initWithNibName:@\"ViewController\" bundle:nil];\n\t[self.window setRootViewController:uv];\n\t[self.window makeKeyAndVisible];\n\treturn YES;\n}\n```\n注意：这里的`ViewController`是你自定义的ViewController。\n\n如果要使用NavigationController需要写成这样:\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n   \tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    ViewController *vc = [[ViewController alloc]initWithNibName:@\"ViewController\" bundle:nil];\n    vc.title = @\"AutoHeightTableView\";\n    UINavigationController *uv = [[UINavigationController alloc] initWithRootViewController:vc];\n    [self.window setRootViewController:uv];\n    [self.window makeKeyAndVisible];\n    return YES;\n}\n```\n\n至此，app就可以显示新建的xib文件的布局了\n","slug":"删除storyboard","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dxw005y7hzg2h34dalo","content":"<p>xcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。<br><a id=\"more\"></a></p>\n<p>storyboard的入口在<strong>targets-&gt;General-&gt;Deployment Info-&gt;Main Interface</strong>，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。</p>\n<p>删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。</p>\n<ul>\n<li>点击placeholders下的File’s Owner将Custom Class的Class设置为viewcController的名字。</li>\n<li>将File’s Owner的view和xib的View进行关联。</li>\n</ul>\n<p>使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">\t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">\tViewController *uv = [[ViewController alloc] initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：这里的<code>ViewController</code>是你自定义的ViewController。</p>\n<p>如果要使用NavigationController需要写成这样:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></div><div class=\"line\">   \t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">    ViewController *vc = [[ViewController alloc]initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    vc.title = <span class=\"string\">@\"AutoHeightTableView\"</span>;</div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *uv = [[<span class=\"built_in\">UINavigationController</span> alloc] initWithRootViewController:vc];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，app就可以显示新建的xib文件的布局了</p>\n","excerpt":"<p>xcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。<br>","more":"</p>\n<p>storyboard的入口在<strong>targets-&gt;General-&gt;Deployment Info-&gt;Main Interface</strong>，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。</p>\n<p>删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。</p>\n<ul>\n<li>点击placeholders下的File’s Owner将Custom Class的Class设置为viewcController的名字。</li>\n<li>将File’s Owner的view和xib的View进行关联。</li>\n</ul>\n<p>使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">\t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">\tViewController *uv = [[ViewController alloc] initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：这里的<code>ViewController</code>是你自定义的ViewController。</p>\n<p>如果要使用NavigationController需要写成这样:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></div><div class=\"line\">   \t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">    ViewController *vc = [[ViewController alloc]initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    vc.title = <span class=\"string\">@\"AutoHeightTableView\"</span>;</div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *uv = [[<span class=\"built_in\">UINavigationController</span> alloc] initWithRootViewController:vc];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，app就可以显示新建的xib文件的布局了</p>"},{"title":"ios中库的介绍与使用","date":"2016-10-17T02:07:12.000Z","_content":"\n最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。\n\n<!--more-->\n\n先来看一张思维导图：\n![库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/库.png?raw=true)\n\n## 概念\n### 什么是库\n库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。\n\n### 库的分类\n#### 静态库\n存在 `.a` 和 `.framework` 两种形式。 `.a` 是一个纯二进制文件，`.framework` 中除了有二进制文件之外还有资源文件。 `.a` ，要有 `.h` 文件以及资源文件配合， `.framework` 文件可以直接使用。总的来说，`.a + .h + sourceFile = .framework`。所以创建静态库最好还是用`.framework`的形式。\n\n对于静态库而言，类似于一个编译好的 `.o` 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图：\n![静态库的链接过程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_1.jpg?raw=true)\n\n#### 动态库\n存在`.framework`和`.tbd`两种形式。\n\n在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 **App Extension** 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。\n\n动态链接是使用了 **Procedure Linkage Table (PLT)**。首先这个 **PLT** 列出了程序中每一个函数的调用，**当程序开始运行**，如果动态库被加载到内存中，**PLT** 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 **PLT** 直接跳转了。\n\n### 优劣\n静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。\n好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。\n\n动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。\n系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。\n\n\n## 库的创建\n### .a静态库的创建\n创建一个 `.a` 静态库项目，如下图所示：\n![lib_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_2.png?raw=true)\n静态库的文件列表如下，在 **products** 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。\n![lib_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_3.png?raw=true)\n现在新建自己的类`PrintString.h`，声明和实现一个第三方库的方法。\n![lib_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_4.png?raw=true)\n![lib_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_5.png?raw=true)\n现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：\n![lib_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_6.png?raw=true)\n打包生成了静态库在 **products** 文件夹内：\n![lib_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_7.png?raw=true)\n打开 **products** 文件夹， 但是此时暴露出来的头文件并没有`PrintString.h`。需要对暴露的头文件进行设置。\n![lib_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_8.png?raw=true)\n如下图，在 **Build Phase** ，的 **Copy Files** 目录下加入想要公开的头文件：\n![lib_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_9.png?raw=true)\n现在再 run 一次，就得到了正确的静态库。\n![lib_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_10.png?raw=true)\n现在，可以测试一下这个静态库。可以再创建一个工程，把库拖进去。不过更推荐如下图所示，新建一个 **target** ：\n![lib_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_11.png?raw=true)\n先要在工程和库间建立关联。如下图所示，在 **Link Binary With Libraries** 中添加库：\n![lib_12](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_12.png?raw=true)\n在 `ViewController.m` 中调用库的方法：\n![lib_13](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_13.png?raw=true)\n现在可以运行了，不过运行前要选择对 **target** ：\n![lib_14](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_14.png?raw=true)\n可以在控制台看到库中的方法被调用了：\n![lib_15](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_15.png?raw=true)\n\n\n### .framework的创建\n#### 动态framework\n创建一个framework：\n![frame_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_1.png?raw=true)\n创建后的文件列表如下，可以看到只有一个 `framework.h` 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合：\n![frame_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_2.png?raw=true)\n将前面创建的 `PrintString.h` 和 `PrintString.m` 导入，并且 import 到 `framework.h` 中去： \n![frame_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_3.png?raw=true)\n设置需要暴露的头文件，头文件默认在 **project header** 中，将需要暴露出来的拖到 **public header** 中去。\n![frame_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_4.png?raw=true)\n我们可以看到此处有三种头文件，分别是 **project header** ， **public header** ， **private header** 。区别如下：\n> Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.\n\n> Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they're not supposed to use them.\n\n> Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.\n\n\n生成的 framework 文件目录如下：\n![frame_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_5.png?raw=true)\n\n将生成的 framework 放入工程中测试，编译通过，运行时出现如下错误：\n![frame_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_6.png?raw=true)\n\n需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 **Embedded Binary** 一项中加入相应动态库：\n![frame_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_7.png?raw=true)\n\n现在就可以正确运行了\n\n#### 静态framework\n静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 **Mach-O Type** 为 `Static Library` ：\n![frame_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_8.png?raw=true)\n\n### 静态库与动态库的引用\n一个库的开发经常会需要用到其他的库(如 `AFNetWorking` )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库是我比较困惑的点。\n\n*网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。*\n\n#### 动态库引用静态库\n创建一个动态库 `DynamicWithStatic`。\n\n使用 **cocoapods** 的方式为动态库引入静态库。在工程目录下新建 `podfile`,写入:\n\n```ruby\ntarget 'DynamicWithStatic' do\npod 'SVProgressHUD'\nend\n```\n\n这里引入`SVProgressHUD`，因为调试起来比较简单。\n\n在执行完 `pod install` 后，打开 `Frameworks.xcworkspace` ,在其中添加`SVProgress`类。现在的工程目录如下：\n![动静库引用](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_1.png?raw=true)\n\n---\n\n**关于 `pod install` 慢的方法**\n这里插一下，`pod` 的时候经常会卡在一个包上，会让人以为没有下载速度了。可以通过添加选项 `pod install --verbose` 的方式，看到安装详情，可以看到速度已经估计时间，这样心里就有数了。\n\n---\n\n在`SVProgress.h`中添加代码：\n\n```objc\ntypedef void(^SVProgresshud)();\n\n#import <Foundation/Foundation.h>\n\n@interface SVProgress : NSObject\n\n+ (SVProgresshud)getBlock;\n@end\n```\n\n在`SVProgress.m`中添加代码：\n\n```objc\n#import \"SVProgress.h\"\n#import \"SVProgressHUD.h\"\n\n@implementation SVProgress\n+(SVProgresshud)getBlock{\n    return ^(){\n        [SVProgressHUD showSuccessWithStatus:@\"成功！\"];\n    };\n}\n@end\n```\n\n`SVProgress`类的目的是提供一个 block 以供调用。将 `SVProgress.h` 头文件暴露出来后， run 生成动态库。\n\n动态库内引用静态库相当于直接把代码写入动态库中，非常的简单。现在思考一个问题，如果工程中引用了这个动态库，并且工程本身也用到了 `SVProgressHUD` 库，那么会发生什么？尝试一下，在 Pod 中为 `FrameworkTest` 添加 `SVProgressHUD` ,会产生如下的警告：\n![重复实现](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_2.png?raw=true)\n\n`SVProgressHUD` 库中的各个类在工程和库中都进行了实现，但是没有指明使用哪一个实现。不过这个警告，并不影响运行，非强迫症可以选择无视，那么对于强迫症患者，如何消除掉这些警告呢？修改库中 `SVProgressHUD` 中各个类的命名。有两种方式：手动和自动，将在下面介绍。\n\n#### 动态库引用动态库\n这次被引用的动态库还是 `SVProgressHUD` 库。先用 pod 下载 `SVProgressHUD` 的源码，然后打包成动态库，这里就不多做说明了。\n\n将动态库 `SVProgressHUD` 拖入工程中，新建 `DynamicWithDynamic` 动态库。将上面的 `SVProgress.h` 和 `SVProgress.m` 拖入 `DynamicWithDynamic` 中，设置暴露出 `SVProgress.h`。\n\n记得注意一定要在 `DynamicWithDynamic` 中引入 `SVProgressHUD ` ,如下图所示：\n![引入SVProgressHUD](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_3.png?raw=true)\n\n现在 run 一下，就可以成功生成了。\n\n下面在 `FrameworkTest` 中测试，使其 embed `DynamicWithDynamic` 。微调一下 `ViewController.m` 使其引入目标库，运行。\n\n在运行中出现如下错误：\n![错误原因](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_4.png?raw=true)\n\n这个错误上面也提到过了，是因为必要的动态库没有 embed 进工程中。但是明明已经将 `DynamicWithDynamic` embed 了啊。好吧，由于 `SVProgressHUD` 现在是动态库了，还需要将 `SVProgressHUD` 库 embed 进 `FrameworkTest` 中。\n\n动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是 embed 嵌入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 `SVProgressHUD` 动态库时，那么仅需导入一份，就不会产生重复代码了。\n\n\n\n#### 静态库引用静态库\n新建一个 `target` 命名为 `StaticWithStatic` ，使用 cocoapods 管理 `SVProgressHUD` 。基本方法和上面一样，唯一需要改变的地方是 **Mach-O** 需要改为 **Static Library** ，运行。 \n\n然而运行失败，报错如下：\n![错误原因](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_5.png?raw=true)\n\n大概意思是在对 `ViewController.h` 进行链接的时候没有找到 `SVProgressHUD.m` 。这就很奇怪了，明明已经在 `StaticWithStatic` 中通过 cocoapods 管理了，怎么会没有 `SVProgressHUD.m` 呢？我想可能是因为cocoapods只是起到 Link 作用，并没有把第三方库也打进去，那么为什么动态库引入静态库的时候是可行的呢？这就不太清楚了。虽然不知道原因，但是解决方法是有的。需要在工程里，即 `FrameworkTest` 的 cocoapods 中添加 `SVProgressHUD`：\n\n```ruby\ntarget 'DynamicWithStatic' do\npod 'SVProgressHUD'\nend\n\ntarget 'StaticWithStatic' do\npod 'SVProgressHUD'\nend\n\ntarget 'FrameworksTest' do\n    pod 'SVProgressHUD'\nend\n\ntarget 'DynamicWithDynamic' do\nend\n```\n\n再次 build ，错误消除，可以使用。\n\n#### 静态库引用动态库 \n静态库貌似不能引用动态库。如果尝试一下，会发现，即使将动态库 **Link Binary With Libraries** 入静态库，也是找不到 `SVProgressHUD.h` 头文件的。\n\n## 一些需要知道的点\n### debug与release\n库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。\n- **debug** :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。\n- **release** : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。\n\ndebug 与 release 的设置方式如下图：\n![debug与release设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_1.png?raw=true)\n\n对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。\n\n### 多架构编译\n库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。\n\n框架分类：\n- 模拟器架构: \n\t+ i386   : 32位架构  4S ~ 5\n\t+ x86_64 : 64位架构  5S ~ 现在的机型\n- 真机架构:\n\t+ arm7: 在最老的支持iOS7的设备上使用\n\t+ arm7s: 在iPhone5和5C上使用 \n\t+ arm64: 运行于iPhone5S的64位 ARM 处理器 上\n\n修改框架的方式如下图：\n![修改框架设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_2.png?raw=true)\n\ndebug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内：\n![库所在目录](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_3.png?raw=true)\n\n### lipo\nlipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。\n\n#### -info\n查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：\n![查看库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_4.png?raw=true)\n可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。\n\n#### -create\n上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式：\n\n```ruby\nlipo -create 库1 库2 -output 新库  \n```\n\n使用结果如下图：\n![合并](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_5.png?raw=true)\n\n#### -thin\n如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式：\n\n```ruby\nlipo 旧库 -thin 需拆分框架 -output 新库\n```\n\n使用结果如下图：\n![拆分](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_6.png?raw=true)\n\n### bundle\n在 framework 中使用 storyboard/xib 创建的页面，可以直接访问 framework 中图片资源。但是 framework 中通过`imageNamed：`方式加载的照片都会丢失。这是因为 `imageNamed:`的方法默认是从 `mainBundle` 中查找资源的，而 framework 中的照片是从 framework 内部加载的，这是的 bundle 并不是 `mainBundle` ，而是存在于主程序的 docment 文件中的 framework 包，图片加载的路径发生了变化，自然找不到图片资源，所以需要修改加载图片的方法！\n\n一般的方法是创建一个 bundle ：\n![创建bundle](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_7.png?raw=true)\n\nbundle 一般和库命名相同。需要注意的是， bundle 并不会被打包进库中的，而是添加要单独添加到工程中，和 framework 相独立的两部分。向 bundle 中直接添加图片：\n![添加图片](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_9.png?raw=true)\n\n先在主工程的 **Copy Bundle Resources** 中添加 bundle ，如下图所示：\n![添加bundle](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_8.png?raw=true)\n\n现在就可以通过`[NSBundle mainBundle]`获取图片，一下两种方式皆可：\n\n```objc\n[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@\"Frameworks\" ofType:@\"bundle\"] stringByAppendingString:@\"/Images/author.png\"]]\n\n[UIImage imageNamed:@\"Frameworks.bundle/Images/author.png\"]\n```\n\n## cocoapods打包库\n好了，终于到最后一部分了。前面已经介绍了手动创建库的方式，那么如何自动创建一个库？另外一点，前面提到过，在动态库内引入静态库，会和项目本身由 cocoapods 引入的库同名冲突，如何消除这一冲突？以上问题都可以通过 cocoapods 打包库实现\n\n### 创建工程\n只需要输入 pod 的 `lib` 命令即可完成初始项目的搭建:\n\n```ruby\npod lib create StaticWithCocoapods\n```\n\n输出指令后，会提示确认五个问题，按需求回答即可：\n\n![创建库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_1.png?raw=true)\n\n稍等片刻，就会自动生成一个工程。\n\n### 配置信息\n在项目目录下有一个 `xxx.podspec` 配置文件，需要进行修改，摘录如下：\n\n```\nPod::Spec.new do |s|\n  s.name             = 'StaticWithCocoapods'\n  s.version          = '0.1.0'\n  s.summary          = 'A short description of StaticWithCocoapods.'\n\n# This description is used to generate tags and improve search results.\n#   * Think: What does it do? Why did you write it? What is the focus?\n#   * Try to keep it short, snappy and to the point.\n#   * Write the description between the DESC delimiters below.\n#   * Finally, don't worry about the indent, CocoaPods strips it!\n\n  s.description      = <<-DESC\nTODO: Add long description of the pod here.\n                       DESC\n\n  s.homepage         = 'https://github.com/zhang759740844'\n  s.license          = { :type => 'MIT', :file => 'LICENSE' }\n  s.author           = { 'Zachary' => '759740844@qq.com' }\n  s.source           = { :git => '/Users/zachary/Desktop/StaticWithCocoapods', :tag => s.version.to_s }\n\n  s.ios.deployment_target = '8.0'\n\n  s.source_files = 'StaticWithCocoapods/Classes/**/*'\n  \n  s.resource_bundles = {\n    'StaticWithCocoapods' => ['StaticWithCocoapods/Assets/*.png']\n  }\n\n  s.public_header_files = 'StaticWithCocoapods/Classes/**/*.h'\n  s.frameworks = 'UIKit', 'MapKit'\n  s.dependency 'AFNetworking', '~> 2.3'\n  s.denpendency 'SVProgressHUD'\nend\n```\n\n- s.version 表示的是当前类库的版本号\n- s.source 表示当前类库源\n- s.sources_files 表示类库的源文件存放目录\n- s.resource_bundles 表示资源文件存放目录\n- s.frameworks 表示类库依赖的framework\n- s.dependency 表示依赖的第三方类库\n\n其中要说明的是： \n1. source 可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。\n2. 依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。\n3. source_file 路径中出现的通配符 `*` 表示匹配任意字符， `**` 表示匹配所有当前文件夹和子文件夹。\n4. source_bundles 中花括号内的 `'StaticWithCocoapods'` 就表示一个 `StaticWithCocoapods` bundle。\n\n### 添加文件\n向 **sources_files** 和 **public_header_files** 以及 **resource_bundle** 中添加图片和类文件。在 demo 的文件夹下执行 `pod install`。现在打开 demo 工程，可以看到创建的 `StaticWithCocoapods` 库的文件结构如下图：\n![文件结构](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_2.png?raw=true)\n\n到这里一切正常，也可以使用 `SVProgressHUD` ，但是当我想用 `[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@\"StaticWithCocoapods\" ofType:@\"bundle\"] stringByAppendingString:@\"/author.png\"]]` 加载图片资源文件时，一直返回 `nil` 。\n\n好吧。虽然网上cocoapods打包教程不少，但是真正试过添加图片的人应该不多，最后在 Stackoverflow 的一个评论里总算找到了解决方法[[Cocoapods]:Resource Bundle not accessbile](http://stackoverflow.com/questions/25402782/cocoapodsresource-bundle-not-accessbile)\n\n原先 demo 中 profile 的内容如下：\n\n```ruby\nuse_frameworks!\n\ntarget 'StaticWithCocoapods_Example' do\n  pod 'StaticW', :path => '../'\n\n  target 'StaticWithCocoapods_Tests' do\n    inherit! :search_paths\n\n    pod 'FBSnapshotTestCase'\n  end\nend\n```\n\n现在要删除 `use_frameworks!` 以及其相关内容，变成这样：\n\n```ruby\ntarget 'StaticWithCocoapods_Example' do\n  pod 'StaticWithCocoapods', :path => ‘../‘\nend\n```\n\n再次尝试加载图片，可以得到正确结果. ^_^\n\n### 提交代码\n1. 使用 sourcetree 添加本地仓库\n2. 提交上面的所有改动\n3. 为改动添加 tag 为 `0.1.0`\n\n设置好后如图：\n![提交代码](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_3.png?raw=true)\n\n这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。\n\n### 验证类库\n开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 `--allow-warnings` 忽略警告：\n![验证类库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_4.png?raw=true)\n\n### 打包库\n打包库需要一个 cocoapods 的插件 **cocoapods-packager**来完成类库的打包。\n\n在终端执行以下命令，安装插件：\n\n```ruby\nsudo gem install cocoapods-packager\n```\n\n在目标文件夹内执行以下命令，完成打包：\n\n```ruby\npod package StaticWithCocoapods.podspec --force\n```\n\n打包成 `.framework` ，也可以用 `--library` 打包成 `.a` 。不过 cocoapods 之前有过打包成 `.a` 但是没有暴露出头文件的bug，懒得试有没有修复了，所以还是都打成 `.framework` 吧。\n\n![打包过程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_5.png?raw=true)\n\n\n现在在目标文件夹下就会多出一个 `StaticWithCocoapods-0.2.0` 目录，里面是打包好的 framework 。\n\n\n至于如何将打包好的库添加到 cocoapods 的官方库内，这个就没有研究了，因为，在很长的一段时间内我都不会用到。有兴趣的可以看看 cocoapods 的官方文档，自行研究下。\n\n\n## 参考链接\n[WWDC2014之iOS使用动态库](http://foggry.com/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/)\n[手把手教你使用CocoaPods打包静态库](http://blog.csdn.net/lijuan3203/article/details/52105911)\n[iOS 静态库开发](http://www.jianshu.com/p/8f5b9855efb8)\n[使用CocoaPods开发并打包静态库](http://www.cnblogs.com/brycezhang/p/4117180.html)\n[使用Cocoapods创建私有podspec](http://www.cocoachina.com/ios/20150228/11206.html)\n[iOS静态库 【.a 和framework】【超详细】](https://my.oschina.net/kaqijiang/blog/649632)\n[创建一个 iOS Framework 项目](http://www.samirchen.com/create-a-framework/)\n[iOS开发——创建你自己的Framework](http://blog.csdn.net/u013604612/article/details/43197465)\n[iOS中workspace与静态库](http://chenhuaizhe.com/jekyll/update/2015/12/13/iOS中的workspace与静态库.html)\n[Cocoapods 应用第一部分 - Xcode 创建 .framework 相关](http://www.cocoachina.com/ios/20150906/13323.html)\n[ios打包--打包静态库(五)](http://www.lhjzzu.com/2016/05/06/static-lib/)\n\n呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才总结完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库~~~~~\n\n[我的demo地址，欢迎参考](https://github.com/zhang759740844/MyOCDemo/tree/develop/Framework)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/打包静态库.md","raw":"title: ios中库的介绍与使用\ndate: 2016/10/17 10:07:12  \ncategories: iOS\ntags:\n\t- Xcode\n\n---\n\n最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。\n\n<!--more-->\n\n先来看一张思维导图：\n![库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/库.png?raw=true)\n\n## 概念\n### 什么是库\n库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。\n\n### 库的分类\n#### 静态库\n存在 `.a` 和 `.framework` 两种形式。 `.a` 是一个纯二进制文件，`.framework` 中除了有二进制文件之外还有资源文件。 `.a` ，要有 `.h` 文件以及资源文件配合， `.framework` 文件可以直接使用。总的来说，`.a + .h + sourceFile = .framework`。所以创建静态库最好还是用`.framework`的形式。\n\n对于静态库而言，类似于一个编译好的 `.o` 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图：\n![静态库的链接过程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_1.jpg?raw=true)\n\n#### 动态库\n存在`.framework`和`.tbd`两种形式。\n\n在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 **App Extension** 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。\n\n动态链接是使用了 **Procedure Linkage Table (PLT)**。首先这个 **PLT** 列出了程序中每一个函数的调用，**当程序开始运行**，如果动态库被加载到内存中，**PLT** 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 **PLT** 直接跳转了。\n\n### 优劣\n静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。\n好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。\n\n动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。\n系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。\n\n\n## 库的创建\n### .a静态库的创建\n创建一个 `.a` 静态库项目，如下图所示：\n![lib_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_2.png?raw=true)\n静态库的文件列表如下，在 **products** 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。\n![lib_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_3.png?raw=true)\n现在新建自己的类`PrintString.h`，声明和实现一个第三方库的方法。\n![lib_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_4.png?raw=true)\n![lib_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_5.png?raw=true)\n现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：\n![lib_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_6.png?raw=true)\n打包生成了静态库在 **products** 文件夹内：\n![lib_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_7.png?raw=true)\n打开 **products** 文件夹， 但是此时暴露出来的头文件并没有`PrintString.h`。需要对暴露的头文件进行设置。\n![lib_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_8.png?raw=true)\n如下图，在 **Build Phase** ，的 **Copy Files** 目录下加入想要公开的头文件：\n![lib_9](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_9.png?raw=true)\n现在再 run 一次，就得到了正确的静态库。\n![lib_10](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_10.png?raw=true)\n现在，可以测试一下这个静态库。可以再创建一个工程，把库拖进去。不过更推荐如下图所示，新建一个 **target** ：\n![lib_11](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_11.png?raw=true)\n先要在工程和库间建立关联。如下图所示，在 **Link Binary With Libraries** 中添加库：\n![lib_12](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_12.png?raw=true)\n在 `ViewController.m` 中调用库的方法：\n![lib_13](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_13.png?raw=true)\n现在可以运行了，不过运行前要选择对 **target** ：\n![lib_14](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_14.png?raw=true)\n可以在控制台看到库中的方法被调用了：\n![lib_15](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_15.png?raw=true)\n\n\n### .framework的创建\n#### 动态framework\n创建一个framework：\n![frame_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_1.png?raw=true)\n创建后的文件列表如下，可以看到只有一个 `framework.h` 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合：\n![frame_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_2.png?raw=true)\n将前面创建的 `PrintString.h` 和 `PrintString.m` 导入，并且 import 到 `framework.h` 中去： \n![frame_3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_3.png?raw=true)\n设置需要暴露的头文件，头文件默认在 **project header** 中，将需要暴露出来的拖到 **public header** 中去。\n![frame_4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_4.png?raw=true)\n我们可以看到此处有三种头文件，分别是 **project header** ， **public header** ， **private header** 。区别如下：\n> Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.\n\n> Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they're not supposed to use them.\n\n> Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.\n\n\n生成的 framework 文件目录如下：\n![frame_5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_5.png?raw=true)\n\n将生成的 framework 放入工程中测试，编译通过，运行时出现如下错误：\n![frame_6](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_6.png?raw=true)\n\n需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 **Embedded Binary** 一项中加入相应动态库：\n![frame_7](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_7.png?raw=true)\n\n现在就可以正确运行了\n\n#### 静态framework\n静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 **Mach-O Type** 为 `Static Library` ：\n![frame_8](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_8.png?raw=true)\n\n### 静态库与动态库的引用\n一个库的开发经常会需要用到其他的库(如 `AFNetWorking` )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库是我比较困惑的点。\n\n*网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。*\n\n#### 动态库引用静态库\n创建一个动态库 `DynamicWithStatic`。\n\n使用 **cocoapods** 的方式为动态库引入静态库。在工程目录下新建 `podfile`,写入:\n\n```ruby\ntarget 'DynamicWithStatic' do\npod 'SVProgressHUD'\nend\n```\n\n这里引入`SVProgressHUD`，因为调试起来比较简单。\n\n在执行完 `pod install` 后，打开 `Frameworks.xcworkspace` ,在其中添加`SVProgress`类。现在的工程目录如下：\n![动静库引用](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_1.png?raw=true)\n\n---\n\n**关于 `pod install` 慢的方法**\n这里插一下，`pod` 的时候经常会卡在一个包上，会让人以为没有下载速度了。可以通过添加选项 `pod install --verbose` 的方式，看到安装详情，可以看到速度已经估计时间，这样心里就有数了。\n\n---\n\n在`SVProgress.h`中添加代码：\n\n```objc\ntypedef void(^SVProgresshud)();\n\n#import <Foundation/Foundation.h>\n\n@interface SVProgress : NSObject\n\n+ (SVProgresshud)getBlock;\n@end\n```\n\n在`SVProgress.m`中添加代码：\n\n```objc\n#import \"SVProgress.h\"\n#import \"SVProgressHUD.h\"\n\n@implementation SVProgress\n+(SVProgresshud)getBlock{\n    return ^(){\n        [SVProgressHUD showSuccessWithStatus:@\"成功！\"];\n    };\n}\n@end\n```\n\n`SVProgress`类的目的是提供一个 block 以供调用。将 `SVProgress.h` 头文件暴露出来后， run 生成动态库。\n\n动态库内引用静态库相当于直接把代码写入动态库中，非常的简单。现在思考一个问题，如果工程中引用了这个动态库，并且工程本身也用到了 `SVProgressHUD` 库，那么会发生什么？尝试一下，在 Pod 中为 `FrameworkTest` 添加 `SVProgressHUD` ,会产生如下的警告：\n![重复实现](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_2.png?raw=true)\n\n`SVProgressHUD` 库中的各个类在工程和库中都进行了实现，但是没有指明使用哪一个实现。不过这个警告，并不影响运行，非强迫症可以选择无视，那么对于强迫症患者，如何消除掉这些警告呢？修改库中 `SVProgressHUD` 中各个类的命名。有两种方式：手动和自动，将在下面介绍。\n\n#### 动态库引用动态库\n这次被引用的动态库还是 `SVProgressHUD` 库。先用 pod 下载 `SVProgressHUD` 的源码，然后打包成动态库，这里就不多做说明了。\n\n将动态库 `SVProgressHUD` 拖入工程中，新建 `DynamicWithDynamic` 动态库。将上面的 `SVProgress.h` 和 `SVProgress.m` 拖入 `DynamicWithDynamic` 中，设置暴露出 `SVProgress.h`。\n\n记得注意一定要在 `DynamicWithDynamic` 中引入 `SVProgressHUD ` ,如下图所示：\n![引入SVProgressHUD](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_3.png?raw=true)\n\n现在 run 一下，就可以成功生成了。\n\n下面在 `FrameworkTest` 中测试，使其 embed `DynamicWithDynamic` 。微调一下 `ViewController.m` 使其引入目标库，运行。\n\n在运行中出现如下错误：\n![错误原因](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_4.png?raw=true)\n\n这个错误上面也提到过了，是因为必要的动态库没有 embed 进工程中。但是明明已经将 `DynamicWithDynamic` embed 了啊。好吧，由于 `SVProgressHUD` 现在是动态库了，还需要将 `SVProgressHUD` 库 embed 进 `FrameworkTest` 中。\n\n动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是 embed 嵌入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 `SVProgressHUD` 动态库时，那么仅需导入一份，就不会产生重复代码了。\n\n\n\n#### 静态库引用静态库\n新建一个 `target` 命名为 `StaticWithStatic` ，使用 cocoapods 管理 `SVProgressHUD` 。基本方法和上面一样，唯一需要改变的地方是 **Mach-O** 需要改为 **Static Library** ，运行。 \n\n然而运行失败，报错如下：\n![错误原因](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_5.png?raw=true)\n\n大概意思是在对 `ViewController.h` 进行链接的时候没有找到 `SVProgressHUD.m` 。这就很奇怪了，明明已经在 `StaticWithStatic` 中通过 cocoapods 管理了，怎么会没有 `SVProgressHUD.m` 呢？我想可能是因为cocoapods只是起到 Link 作用，并没有把第三方库也打进去，那么为什么动态库引入静态库的时候是可行的呢？这就不太清楚了。虽然不知道原因，但是解决方法是有的。需要在工程里，即 `FrameworkTest` 的 cocoapods 中添加 `SVProgressHUD`：\n\n```ruby\ntarget 'DynamicWithStatic' do\npod 'SVProgressHUD'\nend\n\ntarget 'StaticWithStatic' do\npod 'SVProgressHUD'\nend\n\ntarget 'FrameworksTest' do\n    pod 'SVProgressHUD'\nend\n\ntarget 'DynamicWithDynamic' do\nend\n```\n\n再次 build ，错误消除，可以使用。\n\n#### 静态库引用动态库 \n静态库貌似不能引用动态库。如果尝试一下，会发现，即使将动态库 **Link Binary With Libraries** 入静态库，也是找不到 `SVProgressHUD.h` 头文件的。\n\n## 一些需要知道的点\n### debug与release\n库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。\n- **debug** :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。\n- **release** : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。\n\ndebug 与 release 的设置方式如下图：\n![debug与release设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_1.png?raw=true)\n\n对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。\n\n### 多架构编译\n库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。\n\n框架分类：\n- 模拟器架构: \n\t+ i386   : 32位架构  4S ~ 5\n\t+ x86_64 : 64位架构  5S ~ 现在的机型\n- 真机架构:\n\t+ arm7: 在最老的支持iOS7的设备上使用\n\t+ arm7s: 在iPhone5和5C上使用 \n\t+ arm64: 运行于iPhone5S的64位 ARM 处理器 上\n\n修改框架的方式如下图：\n![修改框架设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_2.png?raw=true)\n\ndebug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内：\n![库所在目录](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_3.png?raw=true)\n\n### lipo\nlipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。\n\n#### -info\n查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：\n![查看库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_4.png?raw=true)\n可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。\n\n#### -create\n上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式：\n\n```ruby\nlipo -create 库1 库2 -output 新库  \n```\n\n使用结果如下图：\n![合并](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_5.png?raw=true)\n\n#### -thin\n如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式：\n\n```ruby\nlipo 旧库 -thin 需拆分框架 -output 新库\n```\n\n使用结果如下图：\n![拆分](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_6.png?raw=true)\n\n### bundle\n在 framework 中使用 storyboard/xib 创建的页面，可以直接访问 framework 中图片资源。但是 framework 中通过`imageNamed：`方式加载的照片都会丢失。这是因为 `imageNamed:`的方法默认是从 `mainBundle` 中查找资源的，而 framework 中的照片是从 framework 内部加载的，这是的 bundle 并不是 `mainBundle` ，而是存在于主程序的 docment 文件中的 framework 包，图片加载的路径发生了变化，自然找不到图片资源，所以需要修改加载图片的方法！\n\n一般的方法是创建一个 bundle ：\n![创建bundle](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_7.png?raw=true)\n\nbundle 一般和库命名相同。需要注意的是， bundle 并不会被打包进库中的，而是添加要单独添加到工程中，和 framework 相独立的两部分。向 bundle 中直接添加图片：\n![添加图片](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_9.png?raw=true)\n\n先在主工程的 **Copy Bundle Resources** 中添加 bundle ，如下图所示：\n![添加bundle](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_8.png?raw=true)\n\n现在就可以通过`[NSBundle mainBundle]`获取图片，一下两种方式皆可：\n\n```objc\n[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@\"Frameworks\" ofType:@\"bundle\"] stringByAppendingString:@\"/Images/author.png\"]]\n\n[UIImage imageNamed:@\"Frameworks.bundle/Images/author.png\"]\n```\n\n## cocoapods打包库\n好了，终于到最后一部分了。前面已经介绍了手动创建库的方式，那么如何自动创建一个库？另外一点，前面提到过，在动态库内引入静态库，会和项目本身由 cocoapods 引入的库同名冲突，如何消除这一冲突？以上问题都可以通过 cocoapods 打包库实现\n\n### 创建工程\n只需要输入 pod 的 `lib` 命令即可完成初始项目的搭建:\n\n```ruby\npod lib create StaticWithCocoapods\n```\n\n输出指令后，会提示确认五个问题，按需求回答即可：\n\n![创建库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_1.png?raw=true)\n\n稍等片刻，就会自动生成一个工程。\n\n### 配置信息\n在项目目录下有一个 `xxx.podspec` 配置文件，需要进行修改，摘录如下：\n\n```\nPod::Spec.new do |s|\n  s.name             = 'StaticWithCocoapods'\n  s.version          = '0.1.0'\n  s.summary          = 'A short description of StaticWithCocoapods.'\n\n# This description is used to generate tags and improve search results.\n#   * Think: What does it do? Why did you write it? What is the focus?\n#   * Try to keep it short, snappy and to the point.\n#   * Write the description between the DESC delimiters below.\n#   * Finally, don't worry about the indent, CocoaPods strips it!\n\n  s.description      = <<-DESC\nTODO: Add long description of the pod here.\n                       DESC\n\n  s.homepage         = 'https://github.com/zhang759740844'\n  s.license          = { :type => 'MIT', :file => 'LICENSE' }\n  s.author           = { 'Zachary' => '759740844@qq.com' }\n  s.source           = { :git => '/Users/zachary/Desktop/StaticWithCocoapods', :tag => s.version.to_s }\n\n  s.ios.deployment_target = '8.0'\n\n  s.source_files = 'StaticWithCocoapods/Classes/**/*'\n  \n  s.resource_bundles = {\n    'StaticWithCocoapods' => ['StaticWithCocoapods/Assets/*.png']\n  }\n\n  s.public_header_files = 'StaticWithCocoapods/Classes/**/*.h'\n  s.frameworks = 'UIKit', 'MapKit'\n  s.dependency 'AFNetworking', '~> 2.3'\n  s.denpendency 'SVProgressHUD'\nend\n```\n\n- s.version 表示的是当前类库的版本号\n- s.source 表示当前类库源\n- s.sources_files 表示类库的源文件存放目录\n- s.resource_bundles 表示资源文件存放目录\n- s.frameworks 表示类库依赖的framework\n- s.dependency 表示依赖的第三方类库\n\n其中要说明的是： \n1. source 可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。\n2. 依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。\n3. source_file 路径中出现的通配符 `*` 表示匹配任意字符， `**` 表示匹配所有当前文件夹和子文件夹。\n4. source_bundles 中花括号内的 `'StaticWithCocoapods'` 就表示一个 `StaticWithCocoapods` bundle。\n\n### 添加文件\n向 **sources_files** 和 **public_header_files** 以及 **resource_bundle** 中添加图片和类文件。在 demo 的文件夹下执行 `pod install`。现在打开 demo 工程，可以看到创建的 `StaticWithCocoapods` 库的文件结构如下图：\n![文件结构](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_2.png?raw=true)\n\n到这里一切正常，也可以使用 `SVProgressHUD` ，但是当我想用 `[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@\"StaticWithCocoapods\" ofType:@\"bundle\"] stringByAppendingString:@\"/author.png\"]]` 加载图片资源文件时，一直返回 `nil` 。\n\n好吧。虽然网上cocoapods打包教程不少，但是真正试过添加图片的人应该不多，最后在 Stackoverflow 的一个评论里总算找到了解决方法[[Cocoapods]:Resource Bundle not accessbile](http://stackoverflow.com/questions/25402782/cocoapodsresource-bundle-not-accessbile)\n\n原先 demo 中 profile 的内容如下：\n\n```ruby\nuse_frameworks!\n\ntarget 'StaticWithCocoapods_Example' do\n  pod 'StaticW', :path => '../'\n\n  target 'StaticWithCocoapods_Tests' do\n    inherit! :search_paths\n\n    pod 'FBSnapshotTestCase'\n  end\nend\n```\n\n现在要删除 `use_frameworks!` 以及其相关内容，变成这样：\n\n```ruby\ntarget 'StaticWithCocoapods_Example' do\n  pod 'StaticWithCocoapods', :path => ‘../‘\nend\n```\n\n再次尝试加载图片，可以得到正确结果. ^_^\n\n### 提交代码\n1. 使用 sourcetree 添加本地仓库\n2. 提交上面的所有改动\n3. 为改动添加 tag 为 `0.1.0`\n\n设置好后如图：\n![提交代码](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_3.png?raw=true)\n\n这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。\n\n### 验证类库\n开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 `--allow-warnings` 忽略警告：\n![验证类库](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_4.png?raw=true)\n\n### 打包库\n打包库需要一个 cocoapods 的插件 **cocoapods-packager**来完成类库的打包。\n\n在终端执行以下命令，安装插件：\n\n```ruby\nsudo gem install cocoapods-packager\n```\n\n在目标文件夹内执行以下命令，完成打包：\n\n```ruby\npod package StaticWithCocoapods.podspec --force\n```\n\n打包成 `.framework` ，也可以用 `--library` 打包成 `.a` 。不过 cocoapods 之前有过打包成 `.a` 但是没有暴露出头文件的bug，懒得试有没有修复了，所以还是都打成 `.framework` 吧。\n\n![打包过程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_5.png?raw=true)\n\n\n现在在目标文件夹下就会多出一个 `StaticWithCocoapods-0.2.0` 目录，里面是打包好的 framework 。\n\n\n至于如何将打包好的库添加到 cocoapods 的官方库内，这个就没有研究了，因为，在很长的一段时间内我都不会用到。有兴趣的可以看看 cocoapods 的官方文档，自行研究下。\n\n\n## 参考链接\n[WWDC2014之iOS使用动态库](http://foggry.com/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/)\n[手把手教你使用CocoaPods打包静态库](http://blog.csdn.net/lijuan3203/article/details/52105911)\n[iOS 静态库开发](http://www.jianshu.com/p/8f5b9855efb8)\n[使用CocoaPods开发并打包静态库](http://www.cnblogs.com/brycezhang/p/4117180.html)\n[使用Cocoapods创建私有podspec](http://www.cocoachina.com/ios/20150228/11206.html)\n[iOS静态库 【.a 和framework】【超详细】](https://my.oschina.net/kaqijiang/blog/649632)\n[创建一个 iOS Framework 项目](http://www.samirchen.com/create-a-framework/)\n[iOS开发——创建你自己的Framework](http://blog.csdn.net/u013604612/article/details/43197465)\n[iOS中workspace与静态库](http://chenhuaizhe.com/jekyll/update/2015/12/13/iOS中的workspace与静态库.html)\n[Cocoapods 应用第一部分 - Xcode 创建 .framework 相关](http://www.cocoachina.com/ios/20150906/13323.html)\n[ios打包--打包静态库(五)](http://www.lhjzzu.com/2016/05/06/static-lib/)\n\n呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才总结完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库~~~~~\n\n[我的demo地址，欢迎参考](https://github.com/zhang759740844/MyOCDemo/tree/develop/Framework)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"打包静态库","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dy000627hzgkmujhr51","content":"<p>最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。</p>\n<a id=\"more\"></a>\n<p>先来看一张思维导图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/库.png?raw=true\" alt=\"库\"></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"什么是库\"><a href=\"#什么是库\" class=\"headerlink\" title=\"什么是库\"></a>什么是库</h3><p>库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。</p>\n<h3 id=\"库的分类\"><a href=\"#库的分类\" class=\"headerlink\" title=\"库的分类\"></a>库的分类</h3><h4 id=\"静态库\"><a href=\"#静态库\" class=\"headerlink\" title=\"静态库\"></a>静态库</h4><p>存在 <code>.a</code> 和 <code>.framework</code> 两种形式。 <code>.a</code> 是一个纯二进制文件，<code>.framework</code> 中除了有二进制文件之外还有资源文件。 <code>.a</code> ，要有 <code>.h</code> 文件以及资源文件配合， <code>.framework</code> 文件可以直接使用。总的来说，<code>.a + .h + sourceFile = .framework</code>。所以创建静态库最好还是用<code>.framework</code>的形式。</p>\n<p>对于静态库而言，类似于一个编译好的 <code>.o</code> 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_1.jpg?raw=true\" alt=\"静态库的链接过程\"></p>\n<h4 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h4><p>存在<code>.framework</code>和<code>.tbd</code>两种形式。</p>\n<p>在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 <strong>App Extension</strong> 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p>\n<p>动态链接是使用了 <strong>Procedure Linkage Table (PLT)</strong>。首先这个 <strong>PLT</strong> 列出了程序中每一个函数的调用，<strong>当程序开始运行</strong>，如果动态库被加载到内存中，<strong>PLT</strong> 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 <strong>PLT</strong> 直接跳转了。</p>\n<h3 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h3><p>静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。<br>好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>\n<p>动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。<br>系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。</p>\n<h2 id=\"库的创建\"><a href=\"#库的创建\" class=\"headerlink\" title=\"库的创建\"></a>库的创建</h2><h3 id=\"a静态库的创建\"><a href=\"#a静态库的创建\" class=\"headerlink\" title=\".a静态库的创建\"></a>.a静态库的创建</h3><p>创建一个 <code>.a</code> 静态库项目，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_2.png?raw=true\" alt=\"lib_2\"><br>静态库的文件列表如下，在 <strong>products</strong> 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_3.png?raw=true\" alt=\"lib_3\"><br>现在新建自己的类<code>PrintString.h</code>，声明和实现一个第三方库的方法。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_4.png?raw=true\" alt=\"lib_4\"><br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_5.png?raw=true\" alt=\"lib_5\"><br>现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_6.png?raw=true\" alt=\"lib_6\"><br>打包生成了静态库在 <strong>products</strong> 文件夹内：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_7.png?raw=true\" alt=\"lib_7\"><br>打开 <strong>products</strong> 文件夹， 但是此时暴露出来的头文件并没有<code>PrintString.h</code>。需要对暴露的头文件进行设置。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_8.png?raw=true\" alt=\"lib_8\"><br>如下图，在 <strong>Build Phase</strong> ，的 <strong>Copy Files</strong> 目录下加入想要公开的头文件：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_9.png?raw=true\" alt=\"lib_9\"><br>现在再 run 一次，就得到了正确的静态库。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_10.png?raw=true\" alt=\"lib_10\"><br>现在，可以测试一下这个静态库。可以再创建一个工程，把库拖进去。不过更推荐如下图所示，新建一个 <strong>target</strong> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_11.png?raw=true\" alt=\"lib_11\"><br>先要在工程和库间建立关联。如下图所示，在 <strong>Link Binary With Libraries</strong> 中添加库：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_12.png?raw=true\" alt=\"lib_12\"><br>在 <code>ViewController.m</code> 中调用库的方法：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_13.png?raw=true\" alt=\"lib_13\"><br>现在可以运行了，不过运行前要选择对 <strong>target</strong> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_14.png?raw=true\" alt=\"lib_14\"><br>可以在控制台看到库中的方法被调用了：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_15.png?raw=true\" alt=\"lib_15\"></p>\n<h3 id=\"framework的创建\"><a href=\"#framework的创建\" class=\"headerlink\" title=\".framework的创建\"></a>.framework的创建</h3><h4 id=\"动态framework\"><a href=\"#动态framework\" class=\"headerlink\" title=\"动态framework\"></a>动态framework</h4><p>创建一个framework：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_1.png?raw=true\" alt=\"frame_1\"><br>创建后的文件列表如下，可以看到只有一个 <code>framework.h</code> 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_2.png?raw=true\" alt=\"frame_2\"><br>将前面创建的 <code>PrintString.h</code> 和 <code>PrintString.m</code> 导入，并且 import 到 <code>framework.h</code> 中去：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_3.png?raw=true\" alt=\"frame_3\"><br>设置需要暴露的头文件，头文件默认在 <strong>project header</strong> 中，将需要暴露出来的拖到 <strong>public header</strong> 中去。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_4.png?raw=true\" alt=\"frame_4\"><br>我们可以看到此处有三种头文件，分别是 <strong>project header</strong> ， <strong>public header</strong> ， <strong>private header</strong> 。区别如下：</p>\n<blockquote>\n<p>Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.</p>\n<p>Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they’re not supposed to use them.</p>\n<p>Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.</p>\n</blockquote>\n<p>生成的 framework 文件目录如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_5.png?raw=true\" alt=\"frame_5\"></p>\n<p>将生成的 framework 放入工程中测试，编译通过，运行时出现如下错误：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_6.png?raw=true\" alt=\"frame_6\"></p>\n<p>需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 <strong>Embedded Binary</strong> 一项中加入相应动态库：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_7.png?raw=true\" alt=\"frame_7\"></p>\n<p>现在就可以正确运行了</p>\n<h4 id=\"静态framework\"><a href=\"#静态framework\" class=\"headerlink\" title=\"静态framework\"></a>静态framework</h4><p>静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 <strong>Mach-O Type</strong> 为 <code>Static Library</code> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_8.png?raw=true\" alt=\"frame_8\"></p>\n<h3 id=\"静态库与动态库的引用\"><a href=\"#静态库与动态库的引用\" class=\"headerlink\" title=\"静态库与动态库的引用\"></a>静态库与动态库的引用</h3><p>一个库的开发经常会需要用到其他的库(如 <code>AFNetWorking</code> )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库是我比较困惑的点。</p>\n<p><em>网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。</em></p>\n<h4 id=\"动态库引用静态库\"><a href=\"#动态库引用静态库\" class=\"headerlink\" title=\"动态库引用静态库\"></a>动态库引用静态库</h4><p>创建一个动态库 <code>DynamicWithStatic</code>。</p>\n<p>使用 <strong>cocoapods</strong> 的方式为动态库引入静态库。在工程目录下新建 <code>podfile</code>,写入:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'DynamicWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>这里引入<code>SVProgressHUD</code>，因为调试起来比较简单。</p>\n<p>在执行完 <code>pod install</code> 后，打开 <code>Frameworks.xcworkspace</code> ,在其中添加<code>SVProgress</code>类。现在的工程目录如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_1.png?raw=true\" alt=\"动静库引用\"></p>\n<hr>\n<p><strong>关于 <code>pod install</code> 慢的方法</strong><br>这里插一下，<code>pod</code> 的时候经常会卡在一个包上，会让人以为没有下载速度了。可以通过添加选项 <code>pod install --verbose</code> 的方式，看到安装详情，可以看到速度已经估计时间，这样心里就有数了。</p>\n<hr>\n<p>在<code>SVProgress.h</code>中添加代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^SVProgresshud)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SVProgress</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">+ (SVProgresshud)getBlock;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>在<code>SVProgress.m</code>中添加代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SVProgress.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SVProgressHUD.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SVProgress</span></span></div><div class=\"line\">+(SVProgresshud)getBlock&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ^()&#123;</div><div class=\"line\">        [SVProgressHUD showSuccessWithStatus:<span class=\"string\">@\"成功！\"</span>];</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>SVProgress</code>类的目的是提供一个 block 以供调用。将 <code>SVProgress.h</code> 头文件暴露出来后， run 生成动态库。</p>\n<p>动态库内引用静态库相当于直接把代码写入动态库中，非常的简单。现在思考一个问题，如果工程中引用了这个动态库，并且工程本身也用到了 <code>SVProgressHUD</code> 库，那么会发生什么？尝试一下，在 Pod 中为 <code>FrameworkTest</code> 添加 <code>SVProgressHUD</code> ,会产生如下的警告：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_2.png?raw=true\" alt=\"重复实现\"></p>\n<p><code>SVProgressHUD</code> 库中的各个类在工程和库中都进行了实现，但是没有指明使用哪一个实现。不过这个警告，并不影响运行，非强迫症可以选择无视，那么对于强迫症患者，如何消除掉这些警告呢？修改库中 <code>SVProgressHUD</code> 中各个类的命名。有两种方式：手动和自动，将在下面介绍。</p>\n<h4 id=\"动态库引用动态库\"><a href=\"#动态库引用动态库\" class=\"headerlink\" title=\"动态库引用动态库\"></a>动态库引用动态库</h4><p>这次被引用的动态库还是 <code>SVProgressHUD</code> 库。先用 pod 下载 <code>SVProgressHUD</code> 的源码，然后打包成动态库，这里就不多做说明了。</p>\n<p>将动态库 <code>SVProgressHUD</code> 拖入工程中，新建 <code>DynamicWithDynamic</code> 动态库。将上面的 <code>SVProgress.h</code> 和 <code>SVProgress.m</code> 拖入 <code>DynamicWithDynamic</code> 中，设置暴露出 <code>SVProgress.h</code>。</p>\n<p>记得注意一定要在 <code>DynamicWithDynamic</code> 中引入 <code>SVProgressHUD</code> ,如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_3.png?raw=true\" alt=\"引入SVProgressHUD\"></p>\n<p>现在 run 一下，就可以成功生成了。</p>\n<p>下面在 <code>FrameworkTest</code> 中测试，使其 embed <code>DynamicWithDynamic</code> 。微调一下 <code>ViewController.m</code> 使其引入目标库，运行。</p>\n<p>在运行中出现如下错误：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_4.png?raw=true\" alt=\"错误原因\"></p>\n<p>这个错误上面也提到过了，是因为必要的动态库没有 embed 进工程中。但是明明已经将 <code>DynamicWithDynamic</code> embed 了啊。好吧，由于 <code>SVProgressHUD</code> 现在是动态库了，还需要将 <code>SVProgressHUD</code> 库 embed 进 <code>FrameworkTest</code> 中。</p>\n<p>动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是 embed 嵌入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 <code>SVProgressHUD</code> 动态库时，那么仅需导入一份，就不会产生重复代码了。</p>\n<h4 id=\"静态库引用静态库\"><a href=\"#静态库引用静态库\" class=\"headerlink\" title=\"静态库引用静态库\"></a>静态库引用静态库</h4><p>新建一个 <code>target</code> 命名为 <code>StaticWithStatic</code> ，使用 cocoapods 管理 <code>SVProgressHUD</code> 。基本方法和上面一样，唯一需要改变的地方是 <strong>Mach-O</strong> 需要改为 <strong>Static Library</strong> ，运行。 </p>\n<p>然而运行失败，报错如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_5.png?raw=true\" alt=\"错误原因\"></p>\n<p>大概意思是在对 <code>ViewController.h</code> 进行链接的时候没有找到 <code>SVProgressHUD.m</code> 。这就很奇怪了，明明已经在 <code>StaticWithStatic</code> 中通过 cocoapods 管理了，怎么会没有 <code>SVProgressHUD.m</code> 呢？我想可能是因为cocoapods只是起到 Link 作用，并没有把第三方库也打进去，那么为什么动态库引入静态库的时候是可行的呢？这就不太清楚了。虽然不知道原因，但是解决方法是有的。需要在工程里，即 <code>FrameworkTest</code> 的 cocoapods 中添加 <code>SVProgressHUD</code>：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'DynamicWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'StaticWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'FrameworksTest'</span> <span class=\"keyword\">do</span></div><div class=\"line\">    pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'DynamicWithDynamic'</span> <span class=\"keyword\">do</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>再次 build ，错误消除，可以使用。</p>\n<h4 id=\"静态库引用动态库\"><a href=\"#静态库引用动态库\" class=\"headerlink\" title=\"静态库引用动态库\"></a>静态库引用动态库</h4><p>静态库貌似不能引用动态库。如果尝试一下，会发现，即使将动态库 <strong>Link Binary With Libraries</strong> 入静态库，也是找不到 <code>SVProgressHUD.h</code> 头文件的。</p>\n<h2 id=\"一些需要知道的点\"><a href=\"#一些需要知道的点\" class=\"headerlink\" title=\"一些需要知道的点\"></a>一些需要知道的点</h2><h3 id=\"debug与release\"><a href=\"#debug与release\" class=\"headerlink\" title=\"debug与release\"></a>debug与release</h3><p>库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。</p>\n<ul>\n<li><strong>debug</strong> :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。</li>\n<li><strong>release</strong> : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。</li>\n</ul>\n<p>debug 与 release 的设置方式如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_1.png?raw=true\" alt=\"debug与release设置\"></p>\n<p>对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。</p>\n<h3 id=\"多架构编译\"><a href=\"#多架构编译\" class=\"headerlink\" title=\"多架构编译\"></a>多架构编译</h3><p>库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。</p>\n<p>框架分类：</p>\n<ul>\n<li>模拟器架构: <ul>\n<li>i386   : 32位架构  4S ~ 5</li>\n<li>x86_64 : 64位架构  5S ~ 现在的机型</li>\n</ul>\n</li>\n<li>真机架构:<ul>\n<li>arm7: 在最老的支持iOS7的设备上使用</li>\n<li>arm7s: 在iPhone5和5C上使用 </li>\n<li>arm64: 运行于iPhone5S的64位 ARM 处理器 上</li>\n</ul>\n</li>\n</ul>\n<p>修改框架的方式如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_2.png?raw=true\" alt=\"修改框架设置\"></p>\n<p>debug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_3.png?raw=true\" alt=\"库所在目录\"></p>\n<h3 id=\"lipo\"><a href=\"#lipo\" class=\"headerlink\" title=\"lipo\"></a>lipo</h3><p>lipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。</p>\n<h4 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"-info\"></a>-info</h4><p>查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_4.png?raw=true\" alt=\"查看库\"><br>可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"-create\"></a>-create</h4><p>上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -create 库<span class=\"number\">1</span> 库<span class=\"number\">2</span> -output 新库</div></pre></td></tr></table></figure>\n<p>使用结果如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_5.png?raw=true\" alt=\"合并\"></p>\n<h4 id=\"thin\"><a href=\"#thin\" class=\"headerlink\" title=\"-thin\"></a>-thin</h4><p>如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo 旧库 -thin 需拆分框架 -output 新库</div></pre></td></tr></table></figure>\n<p>使用结果如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_6.png?raw=true\" alt=\"拆分\"></p>\n<h3 id=\"bundle\"><a href=\"#bundle\" class=\"headerlink\" title=\"bundle\"></a>bundle</h3><p>在 framework 中使用 storyboard/xib 创建的页面，可以直接访问 framework 中图片资源。但是 framework 中通过<code>imageNamed：</code>方式加载的照片都会丢失。这是因为 <code>imageNamed:</code>的方法默认是从 <code>mainBundle</code> 中查找资源的，而 framework 中的照片是从 framework 内部加载的，这是的 bundle 并不是 <code>mainBundle</code> ，而是存在于主程序的 docment 文件中的 framework 包，图片加载的路径发生了变化，自然找不到图片资源，所以需要修改加载图片的方法！</p>\n<p>一般的方法是创建一个 bundle ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_7.png?raw=true\" alt=\"创建bundle\"></p>\n<p>bundle 一般和库命名相同。需要注意的是， bundle 并不会被打包进库中的，而是添加要单独添加到工程中，和 framework 相独立的两部分。向 bundle 中直接添加图片：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_9.png?raw=true\" alt=\"添加图片\"></p>\n<p>先在主工程的 <strong>Copy Bundle Resources</strong> 中添加 bundle ，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_8.png?raw=true\" alt=\"添加bundle\"></p>\n<p>现在就可以通过<code>[NSBundle mainBundle]</code>获取图片，一下两种方式皆可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:[[[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"Frameworks\"</span> ofType:<span class=\"string\">@\"bundle\"</span>] stringByAppendingString:<span class=\"string\">@\"/Images/author.png\"</span>]]</div><div class=\"line\"></div><div class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Frameworks.bundle/Images/author.png\"</span>]</div></pre></td></tr></table></figure>\n<h2 id=\"cocoapods打包库\"><a href=\"#cocoapods打包库\" class=\"headerlink\" title=\"cocoapods打包库\"></a>cocoapods打包库</h2><p>好了，终于到最后一部分了。前面已经介绍了手动创建库的方式，那么如何自动创建一个库？另外一点，前面提到过，在动态库内引入静态库，会和项目本身由 cocoapods 引入的库同名冲突，如何消除这一冲突？以上问题都可以通过 cocoapods 打包库实现</p>\n<h3 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h3><p>只需要输入 pod 的 <code>lib</code> 命令即可完成初始项目的搭建:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib create StaticWithCocoapods</div></pre></td></tr></table></figure>\n<p>输出指令后，会提示确认五个问题，按需求回答即可：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_1.png?raw=true\" alt=\"创建库\"></p>\n<p>稍等片刻，就会自动生成一个工程。</p>\n<h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><p>在项目目录下有一个 <code>xxx.podspec</code> 配置文件，需要进行修改，摘录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">  s.name             = &apos;StaticWithCocoapods&apos;</div><div class=\"line\">  s.version          = &apos;0.1.0&apos;</div><div class=\"line\">  s.summary          = &apos;A short description of StaticWithCocoapods.&apos;</div><div class=\"line\"></div><div class=\"line\"># This description is used to generate tags and improve search results.</div><div class=\"line\">#   * Think: What does it do? Why did you write it? What is the focus?</div><div class=\"line\">#   * Try to keep it short, snappy and to the point.</div><div class=\"line\">#   * Write the description between the DESC delimiters below.</div><div class=\"line\">#   * Finally, don&apos;t worry about the indent, CocoaPods strips it!</div><div class=\"line\"></div><div class=\"line\">  s.description      = &lt;&lt;-DESC</div><div class=\"line\">TODO: Add long description of the pod here.</div><div class=\"line\">                       DESC</div><div class=\"line\"></div><div class=\"line\">  s.homepage         = &apos;https://github.com/zhang759740844&apos;</div><div class=\"line\">  s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;</div><div class=\"line\">  s.author           = &#123; &apos;Zachary&apos; =&gt; &apos;759740844@qq.com&apos; &#125;</div><div class=\"line\">  s.source           = &#123; :git =&gt; &apos;/Users/zachary/Desktop/StaticWithCocoapods&apos;, :tag =&gt; s.version.to_s &#125;</div><div class=\"line\"></div><div class=\"line\">  s.ios.deployment_target = &apos;8.0&apos;</div><div class=\"line\"></div><div class=\"line\">  s.source_files = &apos;StaticWithCocoapods/Classes/**/*&apos;</div><div class=\"line\">  </div><div class=\"line\">  s.resource_bundles = &#123;</div><div class=\"line\">    &apos;StaticWithCocoapods&apos; =&gt; [&apos;StaticWithCocoapods/Assets/*.png&apos;]</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  s.public_header_files = &apos;StaticWithCocoapods/Classes/**/*.h&apos;</div><div class=\"line\">  s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;</div><div class=\"line\">  s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class=\"line\">  s.denpendency &apos;SVProgressHUD&apos;</div><div class=\"line\">end</div></pre></td></tr></table></figure>\n<ul>\n<li>s.version 表示的是当前类库的版本号</li>\n<li>s.source 表示当前类库源</li>\n<li>s.sources_files 表示类库的源文件存放目录</li>\n<li>s.resource_bundles 表示资源文件存放目录</li>\n<li>s.frameworks 表示类库依赖的framework</li>\n<li>s.dependency 表示依赖的第三方类库</li>\n</ul>\n<p>其中要说明的是： </p>\n<ol>\n<li>source 可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。</li>\n<li>依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。</li>\n<li>source_file 路径中出现的通配符 <code>*</code> 表示匹配任意字符， <code>**</code> 表示匹配所有当前文件夹和子文件夹。</li>\n<li>source_bundles 中花括号内的 <code>&#39;StaticWithCocoapods&#39;</code> 就表示一个 <code>StaticWithCocoapods</code> bundle。</li>\n</ol>\n<h3 id=\"添加文件\"><a href=\"#添加文件\" class=\"headerlink\" title=\"添加文件\"></a>添加文件</h3><p>向 <strong>sources_files</strong> 和 <strong>public_header_files</strong> 以及 <strong>resource_bundle</strong> 中添加图片和类文件。在 demo 的文件夹下执行 <code>pod install</code>。现在打开 demo 工程，可以看到创建的 <code>StaticWithCocoapods</code> 库的文件结构如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_2.png?raw=true\" alt=\"文件结构\"></p>\n<p>到这里一切正常，也可以使用 <code>SVProgressHUD</code> ，但是当我想用 <code>[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@&quot;StaticWithCocoapods&quot; ofType:@&quot;bundle&quot;] stringByAppendingString:@&quot;/author.png&quot;]]</code> 加载图片资源文件时，一直返回 <code>nil</code> 。</p>\n<p>好吧。虽然网上cocoapods打包教程不少，但是真正试过添加图片的人应该不多，最后在 Stackoverflow 的一个评论里总算找到了解决方法<a href=\"http://stackoverflow.com/questions/25402782/cocoapodsresource-bundle-not-accessbile\" target=\"_blank\" rel=\"external\">[Cocoapods]:Resource Bundle not accessbile</a></p>\n<p>原先 demo 中 profile 的内容如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">use_frameworks!</div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'StaticWithCocoapods_Example'</span> <span class=\"keyword\">do</span></div><div class=\"line\">  pod <span class=\"string\">'StaticW'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'../'</span></div><div class=\"line\"></div><div class=\"line\">  target <span class=\"string\">'StaticWithCocoapods_Tests'</span> <span class=\"keyword\">do</span></div><div class=\"line\">    inherit! <span class=\"symbol\">:search_paths</span></div><div class=\"line\"></div><div class=\"line\">    pod <span class=\"string\">'FBSnapshotTestCase'</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>现在要删除 <code>use_frameworks!</code> 以及其相关内容，变成这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'StaticWithCocoapods_Example'</span> <span class=\"keyword\">do</span></div><div class=\"line\">  pod <span class=\"string\">'StaticWithCocoapods'</span>, <span class=\"symbol\">:path</span> =&gt; ‘../‘</div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>再次尝试加载图片，可以得到正确结果. ^_^</p>\n<h3 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h3><ol>\n<li>使用 sourcetree 添加本地仓库</li>\n<li>提交上面的所有改动</li>\n<li>为改动添加 tag 为 <code>0.1.0</code></li>\n</ol>\n<p>设置好后如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_3.png?raw=true\" alt=\"提交代码\"></p>\n<p>这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。</p>\n<h3 id=\"验证类库\"><a href=\"#验证类库\" class=\"headerlink\" title=\"验证类库\"></a>验证类库</h3><p>开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 <code>--allow-warnings</code> 忽略警告：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_4.png?raw=true\" alt=\"验证类库\"></p>\n<h3 id=\"打包库\"><a href=\"#打包库\" class=\"headerlink\" title=\"打包库\"></a>打包库</h3><p>打包库需要一个 cocoapods 的插件 <strong>cocoapods-packager</strong>来完成类库的打包。</p>\n<p>在终端执行以下命令，安装插件：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo gem install cocoapods-packager</div></pre></td></tr></table></figure>\n<p>在目标文件夹内执行以下命令，完成打包：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod package StaticWithCocoapods.podspec --force</div></pre></td></tr></table></figure>\n<p>打包成 <code>.framework</code> ，也可以用 <code>--library</code> 打包成 <code>.a</code> 。不过 cocoapods 之前有过打包成 <code>.a</code> 但是没有暴露出头文件的bug，懒得试有没有修复了，所以还是都打成 <code>.framework</code> 吧。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_5.png?raw=true\" alt=\"打包过程\"></p>\n<p>现在在目标文件夹下就会多出一个 <code>StaticWithCocoapods-0.2.0</code> 目录，里面是打包好的 framework 。</p>\n<p>至于如何将打包好的库添加到 cocoapods 的官方库内，这个就没有研究了，因为，在很长的一段时间内我都不会用到。有兴趣的可以看看 cocoapods 的官方文档，自行研究下。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://foggry.com/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/\" target=\"_blank\" rel=\"external\">WWDC2014之iOS使用动态库</a><br><a href=\"http://blog.csdn.net/lijuan3203/article/details/52105911\" target=\"_blank\" rel=\"external\">手把手教你使用CocoaPods打包静态库</a><br><a href=\"http://www.jianshu.com/p/8f5b9855efb8\" target=\"_blank\" rel=\"external\">iOS 静态库开发</a><br><a href=\"http://www.cnblogs.com/brycezhang/p/4117180.html\" target=\"_blank\" rel=\"external\">使用CocoaPods开发并打包静态库</a><br><a href=\"http://www.cocoachina.com/ios/20150228/11206.html\" target=\"_blank\" rel=\"external\">使用Cocoapods创建私有podspec</a><br><a href=\"https://my.oschina.net/kaqijiang/blog/649632\" target=\"_blank\" rel=\"external\">iOS静态库 【.a 和framework】【超详细】</a><br><a href=\"http://www.samirchen.com/create-a-framework/\" target=\"_blank\" rel=\"external\">创建一个 iOS Framework 项目</a><br><a href=\"http://blog.csdn.net/u013604612/article/details/43197465\" target=\"_blank\" rel=\"external\">iOS开发——创建你自己的Framework</a><br><a href=\"http://chenhuaizhe.com/jekyll/update/2015/12/13/iOS中的workspace与静态库.html\" target=\"_blank\" rel=\"external\">iOS中workspace与静态库</a><br><a href=\"http://www.cocoachina.com/ios/20150906/13323.html\" target=\"_blank\" rel=\"external\">Cocoapods 应用第一部分 - Xcode 创建 .framework 相关</a><br><a href=\"http://www.lhjzzu.com/2016/05/06/static-lib/\" target=\"_blank\" rel=\"external\">ios打包–打包静态库(五)</a></p>\n<p>呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才总结完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库<del>~</del></p>\n<p><a href=\"https://github.com/zhang759740844/MyOCDemo/tree/develop/Framework\" target=\"_blank\" rel=\"external\">我的demo地址，欢迎参考</a></p>\n","excerpt":"<p>最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。</p>","more":"<p>先来看一张思维导图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/库.png?raw=true\" alt=\"库\"></p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"什么是库\"><a href=\"#什么是库\" class=\"headerlink\" title=\"什么是库\"></a>什么是库</h3><p>库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。</p>\n<h3 id=\"库的分类\"><a href=\"#库的分类\" class=\"headerlink\" title=\"库的分类\"></a>库的分类</h3><h4 id=\"静态库\"><a href=\"#静态库\" class=\"headerlink\" title=\"静态库\"></a>静态库</h4><p>存在 <code>.a</code> 和 <code>.framework</code> 两种形式。 <code>.a</code> 是一个纯二进制文件，<code>.framework</code> 中除了有二进制文件之外还有资源文件。 <code>.a</code> ，要有 <code>.h</code> 文件以及资源文件配合， <code>.framework</code> 文件可以直接使用。总的来说，<code>.a + .h + sourceFile = .framework</code>。所以创建静态库最好还是用<code>.framework</code>的形式。</p>\n<p>对于静态库而言，类似于一个编译好的 <code>.o</code> 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_1.jpg?raw=true\" alt=\"静态库的链接过程\"></p>\n<h4 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h4><p>存在<code>.framework</code>和<code>.tbd</code>两种形式。</p>\n<p>在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 <strong>App Extension</strong> 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p>\n<p>动态链接是使用了 <strong>Procedure Linkage Table (PLT)</strong>。首先这个 <strong>PLT</strong> 列出了程序中每一个函数的调用，<strong>当程序开始运行</strong>，如果动态库被加载到内存中，<strong>PLT</strong> 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 <strong>PLT</strong> 直接跳转了。</p>\n<h3 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h3><p>静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。<br>好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>\n<p>动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。<br>系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。</p>\n<h2 id=\"库的创建\"><a href=\"#库的创建\" class=\"headerlink\" title=\"库的创建\"></a>库的创建</h2><h3 id=\"a静态库的创建\"><a href=\"#a静态库的创建\" class=\"headerlink\" title=\".a静态库的创建\"></a>.a静态库的创建</h3><p>创建一个 <code>.a</code> 静态库项目，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_2.png?raw=true\" alt=\"lib_2\"><br>静态库的文件列表如下，在 <strong>products</strong> 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_3.png?raw=true\" alt=\"lib_3\"><br>现在新建自己的类<code>PrintString.h</code>，声明和实现一个第三方库的方法。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_4.png?raw=true\" alt=\"lib_4\"><br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_5.png?raw=true\" alt=\"lib_5\"><br>现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_6.png?raw=true\" alt=\"lib_6\"><br>打包生成了静态库在 <strong>products</strong> 文件夹内：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_7.png?raw=true\" alt=\"lib_7\"><br>打开 <strong>products</strong> 文件夹， 但是此时暴露出来的头文件并没有<code>PrintString.h</code>。需要对暴露的头文件进行设置。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_8.png?raw=true\" alt=\"lib_8\"><br>如下图，在 <strong>Build Phase</strong> ，的 <strong>Copy Files</strong> 目录下加入想要公开的头文件：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_9.png?raw=true\" alt=\"lib_9\"><br>现在再 run 一次，就得到了正确的静态库。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_10.png?raw=true\" alt=\"lib_10\"><br>现在，可以测试一下这个静态库。可以再创建一个工程，把库拖进去。不过更推荐如下图所示，新建一个 <strong>target</strong> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_11.png?raw=true\" alt=\"lib_11\"><br>先要在工程和库间建立关联。如下图所示，在 <strong>Link Binary With Libraries</strong> 中添加库：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_12.png?raw=true\" alt=\"lib_12\"><br>在 <code>ViewController.m</code> 中调用库的方法：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_13.png?raw=true\" alt=\"lib_13\"><br>现在可以运行了，不过运行前要选择对 <strong>target</strong> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_14.png?raw=true\" alt=\"lib_14\"><br>可以在控制台看到库中的方法被调用了：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_15.png?raw=true\" alt=\"lib_15\"></p>\n<h3 id=\"framework的创建\"><a href=\"#framework的创建\" class=\"headerlink\" title=\".framework的创建\"></a>.framework的创建</h3><h4 id=\"动态framework\"><a href=\"#动态framework\" class=\"headerlink\" title=\"动态framework\"></a>动态framework</h4><p>创建一个framework：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_1.png?raw=true\" alt=\"frame_1\"><br>创建后的文件列表如下，可以看到只有一个 <code>framework.h</code> 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_2.png?raw=true\" alt=\"frame_2\"><br>将前面创建的 <code>PrintString.h</code> 和 <code>PrintString.m</code> 导入，并且 import 到 <code>framework.h</code> 中去：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_3.png?raw=true\" alt=\"frame_3\"><br>设置需要暴露的头文件，头文件默认在 <strong>project header</strong> 中，将需要暴露出来的拖到 <strong>public header</strong> 中去。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_4.png?raw=true\" alt=\"frame_4\"><br>我们可以看到此处有三种头文件，分别是 <strong>project header</strong> ， <strong>public header</strong> ， <strong>private header</strong> 。区别如下：</p>\n<blockquote>\n<p>Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.</p>\n<p>Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they’re not supposed to use them.</p>\n<p>Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.</p>\n</blockquote>\n<p>生成的 framework 文件目录如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_5.png?raw=true\" alt=\"frame_5\"></p>\n<p>将生成的 framework 放入工程中测试，编译通过，运行时出现如下错误：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_6.png?raw=true\" alt=\"frame_6\"></p>\n<p>需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 <strong>Embedded Binary</strong> 一项中加入相应动态库：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_7.png?raw=true\" alt=\"frame_7\"></p>\n<p>现在就可以正确运行了</p>\n<h4 id=\"静态framework\"><a href=\"#静态framework\" class=\"headerlink\" title=\"静态framework\"></a>静态framework</h4><p>静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 <strong>Mach-O Type</strong> 为 <code>Static Library</code> ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_8.png?raw=true\" alt=\"frame_8\"></p>\n<h3 id=\"静态库与动态库的引用\"><a href=\"#静态库与动态库的引用\" class=\"headerlink\" title=\"静态库与动态库的引用\"></a>静态库与动态库的引用</h3><p>一个库的开发经常会需要用到其他的库(如 <code>AFNetWorking</code> )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库是我比较困惑的点。</p>\n<p><em>网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。</em></p>\n<h4 id=\"动态库引用静态库\"><a href=\"#动态库引用静态库\" class=\"headerlink\" title=\"动态库引用静态库\"></a>动态库引用静态库</h4><p>创建一个动态库 <code>DynamicWithStatic</code>。</p>\n<p>使用 <strong>cocoapods</strong> 的方式为动态库引入静态库。在工程目录下新建 <code>podfile</code>,写入:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'DynamicWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>这里引入<code>SVProgressHUD</code>，因为调试起来比较简单。</p>\n<p>在执行完 <code>pod install</code> 后，打开 <code>Frameworks.xcworkspace</code> ,在其中添加<code>SVProgress</code>类。现在的工程目录如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_1.png?raw=true\" alt=\"动静库引用\"></p>\n<hr>\n<p><strong>关于 <code>pod install</code> 慢的方法</strong><br>这里插一下，<code>pod</code> 的时候经常会卡在一个包上，会让人以为没有下载速度了。可以通过添加选项 <code>pod install --verbose</code> 的方式，看到安装详情，可以看到速度已经估计时间，这样心里就有数了。</p>\n<hr>\n<p>在<code>SVProgress.h</code>中添加代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^SVProgresshud)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SVProgress</span> : <span class=\"title\">NSObject</span></span></div><div class=\"line\"></div><div class=\"line\">+ (SVProgresshud)getBlock;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>在<code>SVProgress.m</code>中添加代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SVProgress.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"SVProgressHUD.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">SVProgress</span></span></div><div class=\"line\">+(SVProgresshud)getBlock&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ^()&#123;</div><div class=\"line\">        [SVProgressHUD showSuccessWithStatus:<span class=\"string\">@\"成功！\"</span>];</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>SVProgress</code>类的目的是提供一个 block 以供调用。将 <code>SVProgress.h</code> 头文件暴露出来后， run 生成动态库。</p>\n<p>动态库内引用静态库相当于直接把代码写入动态库中，非常的简单。现在思考一个问题，如果工程中引用了这个动态库，并且工程本身也用到了 <code>SVProgressHUD</code> 库，那么会发生什么？尝试一下，在 Pod 中为 <code>FrameworkTest</code> 添加 <code>SVProgressHUD</code> ,会产生如下的警告：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_2.png?raw=true\" alt=\"重复实现\"></p>\n<p><code>SVProgressHUD</code> 库中的各个类在工程和库中都进行了实现，但是没有指明使用哪一个实现。不过这个警告，并不影响运行，非强迫症可以选择无视，那么对于强迫症患者，如何消除掉这些警告呢？修改库中 <code>SVProgressHUD</code> 中各个类的命名。有两种方式：手动和自动，将在下面介绍。</p>\n<h4 id=\"动态库引用动态库\"><a href=\"#动态库引用动态库\" class=\"headerlink\" title=\"动态库引用动态库\"></a>动态库引用动态库</h4><p>这次被引用的动态库还是 <code>SVProgressHUD</code> 库。先用 pod 下载 <code>SVProgressHUD</code> 的源码，然后打包成动态库，这里就不多做说明了。</p>\n<p>将动态库 <code>SVProgressHUD</code> 拖入工程中，新建 <code>DynamicWithDynamic</code> 动态库。将上面的 <code>SVProgress.h</code> 和 <code>SVProgress.m</code> 拖入 <code>DynamicWithDynamic</code> 中，设置暴露出 <code>SVProgress.h</code>。</p>\n<p>记得注意一定要在 <code>DynamicWithDynamic</code> 中引入 <code>SVProgressHUD</code> ,如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_3.png?raw=true\" alt=\"引入SVProgressHUD\"></p>\n<p>现在 run 一下，就可以成功生成了。</p>\n<p>下面在 <code>FrameworkTest</code> 中测试，使其 embed <code>DynamicWithDynamic</code> 。微调一下 <code>ViewController.m</code> 使其引入目标库，运行。</p>\n<p>在运行中出现如下错误：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_4.png?raw=true\" alt=\"错误原因\"></p>\n<p>这个错误上面也提到过了，是因为必要的动态库没有 embed 进工程中。但是明明已经将 <code>DynamicWithDynamic</code> embed 了啊。好吧，由于 <code>SVProgressHUD</code> 现在是动态库了，还需要将 <code>SVProgressHUD</code> 库 embed 进 <code>FrameworkTest</code> 中。</p>\n<p>动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是 embed 嵌入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 <code>SVProgressHUD</code> 动态库时，那么仅需导入一份，就不会产生重复代码了。</p>\n<h4 id=\"静态库引用静态库\"><a href=\"#静态库引用静态库\" class=\"headerlink\" title=\"静态库引用静态库\"></a>静态库引用静态库</h4><p>新建一个 <code>target</code> 命名为 <code>StaticWithStatic</code> ，使用 cocoapods 管理 <code>SVProgressHUD</code> 。基本方法和上面一样，唯一需要改变的地方是 <strong>Mach-O</strong> 需要改为 <strong>Static Library</strong> ，运行。 </p>\n<p>然而运行失败，报错如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_5.png?raw=true\" alt=\"错误原因\"></p>\n<p>大概意思是在对 <code>ViewController.h</code> 进行链接的时候没有找到 <code>SVProgressHUD.m</code> 。这就很奇怪了，明明已经在 <code>StaticWithStatic</code> 中通过 cocoapods 管理了，怎么会没有 <code>SVProgressHUD.m</code> 呢？我想可能是因为cocoapods只是起到 Link 作用，并没有把第三方库也打进去，那么为什么动态库引入静态库的时候是可行的呢？这就不太清楚了。虽然不知道原因，但是解决方法是有的。需要在工程里，即 <code>FrameworkTest</code> 的 cocoapods 中添加 <code>SVProgressHUD</code>：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'DynamicWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'StaticWithStatic'</span> <span class=\"keyword\">do</span></div><div class=\"line\">pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'FrameworksTest'</span> <span class=\"keyword\">do</span></div><div class=\"line\">    pod <span class=\"string\">'SVProgressHUD'</span></div><div class=\"line\"><span class=\"keyword\">end</span></div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'DynamicWithDynamic'</span> <span class=\"keyword\">do</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>再次 build ，错误消除，可以使用。</p>\n<h4 id=\"静态库引用动态库\"><a href=\"#静态库引用动态库\" class=\"headerlink\" title=\"静态库引用动态库\"></a>静态库引用动态库</h4><p>静态库貌似不能引用动态库。如果尝试一下，会发现，即使将动态库 <strong>Link Binary With Libraries</strong> 入静态库，也是找不到 <code>SVProgressHUD.h</code> 头文件的。</p>\n<h2 id=\"一些需要知道的点\"><a href=\"#一些需要知道的点\" class=\"headerlink\" title=\"一些需要知道的点\"></a>一些需要知道的点</h2><h3 id=\"debug与release\"><a href=\"#debug与release\" class=\"headerlink\" title=\"debug与release\"></a>debug与release</h3><p>库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。</p>\n<ul>\n<li><strong>debug</strong> :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。</li>\n<li><strong>release</strong> : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。</li>\n</ul>\n<p>debug 与 release 的设置方式如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_1.png?raw=true\" alt=\"debug与release设置\"></p>\n<p>对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。</p>\n<h3 id=\"多架构编译\"><a href=\"#多架构编译\" class=\"headerlink\" title=\"多架构编译\"></a>多架构编译</h3><p>库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。</p>\n<p>框架分类：</p>\n<ul>\n<li>模拟器架构: <ul>\n<li>i386   : 32位架构  4S ~ 5</li>\n<li>x86_64 : 64位架构  5S ~ 现在的机型</li>\n</ul>\n</li>\n<li>真机架构:<ul>\n<li>arm7: 在最老的支持iOS7的设备上使用</li>\n<li>arm7s: 在iPhone5和5C上使用 </li>\n<li>arm64: 运行于iPhone5S的64位 ARM 处理器 上</li>\n</ul>\n</li>\n</ul>\n<p>修改框架的方式如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_2.png?raw=true\" alt=\"修改框架设置\"></p>\n<p>debug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_3.png?raw=true\" alt=\"库所在目录\"></p>\n<h3 id=\"lipo\"><a href=\"#lipo\" class=\"headerlink\" title=\"lipo\"></a>lipo</h3><p>lipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。</p>\n<h4 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"-info\"></a>-info</h4><p>查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_4.png?raw=true\" alt=\"查看库\"><br>可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。</p>\n<h4 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"-create\"></a>-create</h4><p>上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo -create 库<span class=\"number\">1</span> 库<span class=\"number\">2</span> -output 新库</div></pre></td></tr></table></figure>\n<p>使用结果如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_5.png?raw=true\" alt=\"合并\"></p>\n<h4 id=\"thin\"><a href=\"#thin\" class=\"headerlink\" title=\"-thin\"></a>-thin</h4><p>如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">lipo 旧库 -thin 需拆分框架 -output 新库</div></pre></td></tr></table></figure>\n<p>使用结果如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_6.png?raw=true\" alt=\"拆分\"></p>\n<h3 id=\"bundle\"><a href=\"#bundle\" class=\"headerlink\" title=\"bundle\"></a>bundle</h3><p>在 framework 中使用 storyboard/xib 创建的页面，可以直接访问 framework 中图片资源。但是 framework 中通过<code>imageNamed：</code>方式加载的照片都会丢失。这是因为 <code>imageNamed:</code>的方法默认是从 <code>mainBundle</code> 中查找资源的，而 framework 中的照片是从 framework 内部加载的，这是的 bundle 并不是 <code>mainBundle</code> ，而是存在于主程序的 docment 文件中的 framework 包，图片加载的路径发生了变化，自然找不到图片资源，所以需要修改加载图片的方法！</p>\n<p>一般的方法是创建一个 bundle ：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_7.png?raw=true\" alt=\"创建bundle\"></p>\n<p>bundle 一般和库命名相同。需要注意的是， bundle 并不会被打包进库中的，而是添加要单独添加到工程中，和 framework 相独立的两部分。向 bundle 中直接添加图片：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_9.png?raw=true\" alt=\"添加图片\"></p>\n<p>先在主工程的 <strong>Copy Bundle Resources</strong> 中添加 bundle ，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_8.png?raw=true\" alt=\"添加bundle\"></p>\n<p>现在就可以通过<code>[NSBundle mainBundle]</code>获取图片，一下两种方式皆可：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:[[[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"Frameworks\"</span> ofType:<span class=\"string\">@\"bundle\"</span>] stringByAppendingString:<span class=\"string\">@\"/Images/author.png\"</span>]]</div><div class=\"line\"></div><div class=\"line\">[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Frameworks.bundle/Images/author.png\"</span>]</div></pre></td></tr></table></figure>\n<h2 id=\"cocoapods打包库\"><a href=\"#cocoapods打包库\" class=\"headerlink\" title=\"cocoapods打包库\"></a>cocoapods打包库</h2><p>好了，终于到最后一部分了。前面已经介绍了手动创建库的方式，那么如何自动创建一个库？另外一点，前面提到过，在动态库内引入静态库，会和项目本身由 cocoapods 引入的库同名冲突，如何消除这一冲突？以上问题都可以通过 cocoapods 打包库实现</p>\n<h3 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h3><p>只需要输入 pod 的 <code>lib</code> 命令即可完成初始项目的搭建:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib create StaticWithCocoapods</div></pre></td></tr></table></figure>\n<p>输出指令后，会提示确认五个问题，按需求回答即可：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_1.png?raw=true\" alt=\"创建库\"></p>\n<p>稍等片刻，就会自动生成一个工程。</p>\n<h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><p>在项目目录下有一个 <code>xxx.podspec</code> 配置文件，需要进行修改，摘录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">Pod::Spec.new do |s|</div><div class=\"line\">  s.name             = &apos;StaticWithCocoapods&apos;</div><div class=\"line\">  s.version          = &apos;0.1.0&apos;</div><div class=\"line\">  s.summary          = &apos;A short description of StaticWithCocoapods.&apos;</div><div class=\"line\"></div><div class=\"line\"># This description is used to generate tags and improve search results.</div><div class=\"line\">#   * Think: What does it do? Why did you write it? What is the focus?</div><div class=\"line\">#   * Try to keep it short, snappy and to the point.</div><div class=\"line\">#   * Write the description between the DESC delimiters below.</div><div class=\"line\">#   * Finally, don&apos;t worry about the indent, CocoaPods strips it!</div><div class=\"line\"></div><div class=\"line\">  s.description      = &lt;&lt;-DESC</div><div class=\"line\">TODO: Add long description of the pod here.</div><div class=\"line\">                       DESC</div><div class=\"line\"></div><div class=\"line\">  s.homepage         = &apos;https://github.com/zhang759740844&apos;</div><div class=\"line\">  s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;</div><div class=\"line\">  s.author           = &#123; &apos;Zachary&apos; =&gt; &apos;759740844@qq.com&apos; &#125;</div><div class=\"line\">  s.source           = &#123; :git =&gt; &apos;/Users/zachary/Desktop/StaticWithCocoapods&apos;, :tag =&gt; s.version.to_s &#125;</div><div class=\"line\"></div><div class=\"line\">  s.ios.deployment_target = &apos;8.0&apos;</div><div class=\"line\"></div><div class=\"line\">  s.source_files = &apos;StaticWithCocoapods/Classes/**/*&apos;</div><div class=\"line\">  </div><div class=\"line\">  s.resource_bundles = &#123;</div><div class=\"line\">    &apos;StaticWithCocoapods&apos; =&gt; [&apos;StaticWithCocoapods/Assets/*.png&apos;]</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  s.public_header_files = &apos;StaticWithCocoapods/Classes/**/*.h&apos;</div><div class=\"line\">  s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;</div><div class=\"line\">  s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class=\"line\">  s.denpendency &apos;SVProgressHUD&apos;</div><div class=\"line\">end</div></pre></td></tr></table></figure>\n<ul>\n<li>s.version 表示的是当前类库的版本号</li>\n<li>s.source 表示当前类库源</li>\n<li>s.sources_files 表示类库的源文件存放目录</li>\n<li>s.resource_bundles 表示资源文件存放目录</li>\n<li>s.frameworks 表示类库依赖的framework</li>\n<li>s.dependency 表示依赖的第三方类库</li>\n</ul>\n<p>其中要说明的是： </p>\n<ol>\n<li>source 可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。</li>\n<li>依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。</li>\n<li>source_file 路径中出现的通配符 <code>*</code> 表示匹配任意字符， <code>**</code> 表示匹配所有当前文件夹和子文件夹。</li>\n<li>source_bundles 中花括号内的 <code>&#39;StaticWithCocoapods&#39;</code> 就表示一个 <code>StaticWithCocoapods</code> bundle。</li>\n</ol>\n<h3 id=\"添加文件\"><a href=\"#添加文件\" class=\"headerlink\" title=\"添加文件\"></a>添加文件</h3><p>向 <strong>sources_files</strong> 和 <strong>public_header_files</strong> 以及 <strong>resource_bundle</strong> 中添加图片和类文件。在 demo 的文件夹下执行 <code>pod install</code>。现在打开 demo 工程，可以看到创建的 <code>StaticWithCocoapods</code> 库的文件结构如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_2.png?raw=true\" alt=\"文件结构\"></p>\n<p>到这里一切正常，也可以使用 <code>SVProgressHUD</code> ，但是当我想用 <code>[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@&quot;StaticWithCocoapods&quot; ofType:@&quot;bundle&quot;] stringByAppendingString:@&quot;/author.png&quot;]]</code> 加载图片资源文件时，一直返回 <code>nil</code> 。</p>\n<p>好吧。虽然网上cocoapods打包教程不少，但是真正试过添加图片的人应该不多，最后在 Stackoverflow 的一个评论里总算找到了解决方法<a href=\"http://stackoverflow.com/questions/25402782/cocoapodsresource-bundle-not-accessbile\">[Cocoapods]:Resource Bundle not accessbile</a></p>\n<p>原先 demo 中 profile 的内容如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">use_frameworks!</div><div class=\"line\"></div><div class=\"line\">target <span class=\"string\">'StaticWithCocoapods_Example'</span> <span class=\"keyword\">do</span></div><div class=\"line\">  pod <span class=\"string\">'StaticW'</span>, <span class=\"symbol\">:path</span> =&gt; <span class=\"string\">'../'</span></div><div class=\"line\"></div><div class=\"line\">  target <span class=\"string\">'StaticWithCocoapods_Tests'</span> <span class=\"keyword\">do</span></div><div class=\"line\">    inherit! <span class=\"symbol\">:search_paths</span></div><div class=\"line\"></div><div class=\"line\">    pod <span class=\"string\">'FBSnapshotTestCase'</span></div><div class=\"line\">  <span class=\"keyword\">end</span></div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>现在要删除 <code>use_frameworks!</code> 以及其相关内容，变成这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target <span class=\"string\">'StaticWithCocoapods_Example'</span> <span class=\"keyword\">do</span></div><div class=\"line\">  pod <span class=\"string\">'StaticWithCocoapods'</span>, <span class=\"symbol\">:path</span> =&gt; ‘../‘</div><div class=\"line\"><span class=\"keyword\">end</span></div></pre></td></tr></table></figure>\n<p>再次尝试加载图片，可以得到正确结果. ^_^</p>\n<h3 id=\"提交代码\"><a href=\"#提交代码\" class=\"headerlink\" title=\"提交代码\"></a>提交代码</h3><ol>\n<li>使用 sourcetree 添加本地仓库</li>\n<li>提交上面的所有改动</li>\n<li>为改动添加 tag 为 <code>0.1.0</code></li>\n</ol>\n<p>设置好后如图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_3.png?raw=true\" alt=\"提交代码\"></p>\n<p>这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。</p>\n<h3 id=\"验证类库\"><a href=\"#验证类库\" class=\"headerlink\" title=\"验证类库\"></a>验证类库</h3><p>开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 <code>--allow-warnings</code> 忽略警告：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_4.png?raw=true\" alt=\"验证类库\"></p>\n<h3 id=\"打包库\"><a href=\"#打包库\" class=\"headerlink\" title=\"打包库\"></a>打包库</h3><p>打包库需要一个 cocoapods 的插件 <strong>cocoapods-packager</strong>来完成类库的打包。</p>\n<p>在终端执行以下命令，安装插件：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo gem install cocoapods-packager</div></pre></td></tr></table></figure>\n<p>在目标文件夹内执行以下命令，完成打包：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod package StaticWithCocoapods.podspec --force</div></pre></td></tr></table></figure>\n<p>打包成 <code>.framework</code> ，也可以用 <code>--library</code> 打包成 <code>.a</code> 。不过 cocoapods 之前有过打包成 <code>.a</code> 但是没有暴露出头文件的bug，懒得试有没有修复了，所以还是都打成 <code>.framework</code> 吧。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_5.png?raw=true\" alt=\"打包过程\"></p>\n<p>现在在目标文件夹下就会多出一个 <code>StaticWithCocoapods-0.2.0</code> 目录，里面是打包好的 framework 。</p>\n<p>至于如何将打包好的库添加到 cocoapods 的官方库内，这个就没有研究了，因为，在很长的一段时间内我都不会用到。有兴趣的可以看看 cocoapods 的官方文档，自行研究下。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://foggry.com/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/\">WWDC2014之iOS使用动态库</a><br><a href=\"http://blog.csdn.net/lijuan3203/article/details/52105911\">手把手教你使用CocoaPods打包静态库</a><br><a href=\"http://www.jianshu.com/p/8f5b9855efb8\">iOS 静态库开发</a><br><a href=\"http://www.cnblogs.com/brycezhang/p/4117180.html\">使用CocoaPods开发并打包静态库</a><br><a href=\"http://www.cocoachina.com/ios/20150228/11206.html\">使用Cocoapods创建私有podspec</a><br><a href=\"https://my.oschina.net/kaqijiang/blog/649632\">iOS静态库 【.a 和framework】【超详细】</a><br><a href=\"http://www.samirchen.com/create-a-framework/\">创建一个 iOS Framework 项目</a><br><a href=\"http://blog.csdn.net/u013604612/article/details/43197465\">iOS开发——创建你自己的Framework</a><br><a href=\"http://chenhuaizhe.com/jekyll/update/2015/12/13/iOS中的workspace与静态库.html\">iOS中workspace与静态库</a><br><a href=\"http://www.cocoachina.com/ios/20150906/13323.html\">Cocoapods 应用第一部分 - Xcode 创建 .framework 相关</a><br><a href=\"http://www.lhjzzu.com/2016/05/06/static-lib/\">ios打包–打包静态库(五)</a></p>\n<p>呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才总结完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库<del>~</del></p>\n<p><a href=\"https://github.com/zhang759740844/MyOCDemo/tree/develop/Framework\">我的demo地址，欢迎参考</a></p>"},{"title":"图解TCP-IP学习笔记","date":"2016-07-31T08:07:12.000Z","_content":"\n本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙\n<!--more-->\n## 网络基础知识\n### 协议分层\nISO制定了国际标准OSI，对通信系统进行了标准化。\n- **应用层**：针对特定应用的协议。\n- **表示层**：设备固有数据格式和网络标准设局格式的转换。\n- **会话层**：通信管理，负责建立和断开通信连接。\n- **传输层**：管理两个节点之间的数据传输。\n- **网络层**：地址管理和路由选择。\n- **数据链路层**：互联设备间传送和识别数据帧。\n- **物理层**：01代表高低平的互换\n\n### 电路交换与分组交换\n- **电路交换**：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。\n- **分组交换**：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。\n\n### 地址\n- **MAC地址**：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。\n- **IP地址**：IP地址由网络号和主机号两部分组成。具有层次性。\n\nMAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。\n\n### 网络的构成元素\n- **网卡**：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。\n- **中继器**：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。\n- **网桥**：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。\n- **路由器/3层交换机**：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。\n- **4-7层交换机**：负责处理OSI模型中从传输层到应用层的数据。\n- **网关**：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。\n\n## TCP/IP基础知识\n### TCP/IP模型\n- **硬件(物理层)**\n- **网络接口层(数据链路层)**\n- **互联网层(网络层)**\n + IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。\n + ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的\n + ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。\n- **传输层**\n + TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。\n + UDP：面向无连接的传输层协议。\n- **应用层(会话层以上的分层)**\n + WWW\n + 电子邮件(E-Mail)\n + 文件传输(FTP)\n + 远程登录(TELNET,SSH)\n + 网络管理(SNMP)\n \n## 数据链路\n### 数据链路的作用\n数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。\n\n数据链路的**段**是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。\n\n网络的连接和构成形态成为**网络拓扑**。\n\n### 数据链路相关技术\n**共享介质型网络**：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。\n\n**非共享介质网络**：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。\n\n以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。\n\n### 以太网\n众多数据链路中最著名，使用最广发的是以太网。\n\n## IP协议\n### IP即网络协议\n网络层的下一层——数据链路层主要作用是在互连**同一种数据链路节点**之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。\n\n配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。\n\n**网络层与数据链路层关系**：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。\n\n### IP基础知识\nIP大致分为三大模块，IP寻址，路由，IP分包和组包。\n\n为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。\n\n路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。\n\nIP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。\n\n### IP地址的基础知识\nIP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n\nIP地址的分类：\n1. A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识\n2. B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识\n3. C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识\n4. D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。\n\n**广播地址**用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。\n\n**多播**用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。\n\n网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做\"**子网掩码**\"的识别码通过子网网络地址细分出比ABC更小粒度的网络。  \n子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.\n\n由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于**私有IP**，在此之外的IP称为**全局IP**。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。\n\n对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。\n\n### 路由控制\n仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是**路由控制表**。\n\n路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。\n\n## IP协议相关\n### DNS\nDNS将主机名字符串转换为具体的IP地址。\n\n### ARP\n只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。\n\nARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。\n\n从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过**ARP**从IP地址获得MAC地址，实现链路内的IP通信。\n\n根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/图解TCP_IP.md","raw":"\ntitle: 图解TCP-IP学习笔记\ndate: 2016/7/31 16:07:12  \ncategories: 计算机\ntags:\n\t- 学习笔记\n\n---\n\n本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙\n<!--more-->\n## 网络基础知识\n### 协议分层\nISO制定了国际标准OSI，对通信系统进行了标准化。\n- **应用层**：针对特定应用的协议。\n- **表示层**：设备固有数据格式和网络标准设局格式的转换。\n- **会话层**：通信管理，负责建立和断开通信连接。\n- **传输层**：管理两个节点之间的数据传输。\n- **网络层**：地址管理和路由选择。\n- **数据链路层**：互联设备间传送和识别数据帧。\n- **物理层**：01代表高低平的互换\n\n### 电路交换与分组交换\n- **电路交换**：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。\n- **分组交换**：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。\n\n### 地址\n- **MAC地址**：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。\n- **IP地址**：IP地址由网络号和主机号两部分组成。具有层次性。\n\nMAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。\n\n### 网络的构成元素\n- **网卡**：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。\n- **中继器**：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。\n- **网桥**：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。\n- **路由器/3层交换机**：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。\n- **4-7层交换机**：负责处理OSI模型中从传输层到应用层的数据。\n- **网关**：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。\n\n## TCP/IP基础知识\n### TCP/IP模型\n- **硬件(物理层)**\n- **网络接口层(数据链路层)**\n- **互联网层(网络层)**\n + IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。\n + ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的\n + ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。\n- **传输层**\n + TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。\n + UDP：面向无连接的传输层协议。\n- **应用层(会话层以上的分层)**\n + WWW\n + 电子邮件(E-Mail)\n + 文件传输(FTP)\n + 远程登录(TELNET,SSH)\n + 网络管理(SNMP)\n \n## 数据链路\n### 数据链路的作用\n数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。\n\n数据链路的**段**是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。\n\n网络的连接和构成形态成为**网络拓扑**。\n\n### 数据链路相关技术\n**共享介质型网络**：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。\n\n**非共享介质网络**：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。\n\n以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。\n\n### 以太网\n众多数据链路中最著名，使用最广发的是以太网。\n\n## IP协议\n### IP即网络协议\n网络层的下一层——数据链路层主要作用是在互连**同一种数据链路节点**之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。\n\n配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。\n\n**网络层与数据链路层关系**：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。\n\n### IP基础知识\nIP大致分为三大模块，IP寻址，路由，IP分包和组包。\n\n为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。\n\n路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。\n\nIP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。\n\n### IP地址的基础知识\nIP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n\nIP地址的分类：\n1. A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识\n2. B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识\n3. C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识\n4. D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。\n\n**广播地址**用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。\n\n**多播**用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。\n\n网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做\"**子网掩码**\"的识别码通过子网网络地址细分出比ABC更小粒度的网络。  \n子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.\n\n由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于**私有IP**，在此之外的IP称为**全局IP**。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。\n\n对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。\n\n### 路由控制\n仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是**路由控制表**。\n\n路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。\n\n## IP协议相关\n### DNS\nDNS将主机名字符串转换为具体的IP地址。\n\n### ARP\n只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。\n\nARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。\n\n从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过**ARP**从IP地址获得MAC地址，实现链路内的IP通信。\n\n根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。\n\n\n\n\n\n\n\n\n\n\n","slug":"图解TCP_IP","published":1,"updated":"2016-12-03T08:44:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixh41dy200657hzgcln9yerd","content":"<p>本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙<br><a id=\"more\"></a></p>\n<h2 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h2><h3 id=\"协议分层\"><a href=\"#协议分层\" class=\"headerlink\" title=\"协议分层\"></a>协议分层</h3><p>ISO制定了国际标准OSI，对通信系统进行了标准化。</p>\n<ul>\n<li><strong>应用层</strong>：针对特定应用的协议。</li>\n<li><strong>表示层</strong>：设备固有数据格式和网络标准设局格式的转换。</li>\n<li><strong>会话层</strong>：通信管理，负责建立和断开通信连接。</li>\n<li><strong>传输层</strong>：管理两个节点之间的数据传输。</li>\n<li><strong>网络层</strong>：地址管理和路由选择。</li>\n<li><strong>数据链路层</strong>：互联设备间传送和识别数据帧。</li>\n<li><strong>物理层</strong>：01代表高低平的互换</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><strong>电路交换</strong>：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。</li>\n<li><strong>分组交换</strong>：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。</li>\n</ul>\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><ul>\n<li><strong>MAC地址</strong>：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。</li>\n<li><strong>IP地址</strong>：IP地址由网络号和主机号两部分组成。具有层次性。</li>\n</ul>\n<p>MAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。</p>\n<h3 id=\"网络的构成元素\"><a href=\"#网络的构成元素\" class=\"headerlink\" title=\"网络的构成元素\"></a>网络的构成元素</h3><ul>\n<li><strong>网卡</strong>：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。</li>\n<li><strong>中继器</strong>：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。</li>\n<li><strong>网桥</strong>：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。</li>\n<li><strong>路由器/3层交换机</strong>：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。</li>\n<li><strong>4-7层交换机</strong>：负责处理OSI模型中从传输层到应用层的数据。</li>\n<li><strong>网关</strong>：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。</li>\n</ul>\n<h2 id=\"TCP-IP基础知识\"><a href=\"#TCP-IP基础知识\" class=\"headerlink\" title=\"TCP/IP基础知识\"></a>TCP/IP基础知识</h2><h3 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP/IP模型\"></a>TCP/IP模型</h3><ul>\n<li><strong>硬件(物理层)</strong></li>\n<li><strong>网络接口层(数据链路层)</strong></li>\n<li><strong>互联网层(网络层)</strong><ul>\n<li>IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。</li>\n<li>ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的</li>\n<li>ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。</li>\n</ul>\n</li>\n<li><strong>传输层</strong><ul>\n<li>TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。</li>\n<li>UDP：面向无连接的传输层协议。</li>\n</ul>\n</li>\n<li><strong>应用层(会话层以上的分层)</strong><ul>\n<li>WWW</li>\n<li>电子邮件(E-Mail)</li>\n<li>文件传输(FTP)</li>\n<li>远程登录(TELNET,SSH)</li>\n<li>网络管理(SNMP)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据链路\"><a href=\"#数据链路\" class=\"headerlink\" title=\"数据链路\"></a>数据链路</h2><h3 id=\"数据链路的作用\"><a href=\"#数据链路的作用\" class=\"headerlink\" title=\"数据链路的作用\"></a>数据链路的作用</h3><p>数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。</p>\n<p>数据链路的<strong>段</strong>是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。</p>\n<p>网络的连接和构成形态成为<strong>网络拓扑</strong>。</p>\n<h3 id=\"数据链路相关技术\"><a href=\"#数据链路相关技术\" class=\"headerlink\" title=\"数据链路相关技术\"></a>数据链路相关技术</h3><p><strong>共享介质型网络</strong>：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。</p>\n<p><strong>非共享介质网络</strong>：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。</p>\n<p>以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。</p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>众多数据链路中最著名，使用最广发的是以太网。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><h3 id=\"IP即网络协议\"><a href=\"#IP即网络协议\" class=\"headerlink\" title=\"IP即网络协议\"></a>IP即网络协议</h3><p>网络层的下一层——数据链路层主要作用是在互连<strong>同一种数据链路节点</strong>之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。</p>\n<p>配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。</p>\n<p><strong>网络层与数据链路层关系</strong>：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。</p>\n<h3 id=\"IP基础知识\"><a href=\"#IP基础知识\" class=\"headerlink\" title=\"IP基础知识\"></a>IP基础知识</h3><p>IP大致分为三大模块，IP寻址，路由，IP分包和组包。</p>\n<p>为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。</p>\n<p>路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。</p>\n<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。</p>\n<h3 id=\"IP地址的基础知识\"><a href=\"#IP地址的基础知识\" class=\"headerlink\" title=\"IP地址的基础知识\"></a>IP地址的基础知识</h3><p>IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p>\n<p>IP地址的分类：</p>\n<ol>\n<li>A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识</li>\n<li>B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识</li>\n<li>C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识</li>\n<li>D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。</li>\n</ol>\n<p><strong>广播地址</strong>用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。</p>\n<p><strong>多播</strong>用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。</p>\n<p>网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”<strong>子网掩码</strong>“的识别码通过子网网络地址细分出比ABC更小粒度的网络。<br>子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.</p>\n<p>由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于<strong>私有IP</strong>，在此之外的IP称为<strong>全局IP</strong>。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。</p>\n<p>对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。</p>\n<h3 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h3><p>仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。</p>\n<p>路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p>\n<h2 id=\"IP协议相关\"><a href=\"#IP协议相关\" class=\"headerlink\" title=\"IP协议相关\"></a>IP协议相关</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS将主机名字符串转换为具体的IP地址。</p>\n<h3 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h3><p>只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。</p>\n<p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p>\n<p>从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过<strong>ARP</strong>从IP地址获得MAC地址，实现链路内的IP通信。</p>\n<p>根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>\n","excerpt":"<p>本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙<br>","more":"</p>\n<h2 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h2><h3 id=\"协议分层\"><a href=\"#协议分层\" class=\"headerlink\" title=\"协议分层\"></a>协议分层</h3><p>ISO制定了国际标准OSI，对通信系统进行了标准化。</p>\n<ul>\n<li><strong>应用层</strong>：针对特定应用的协议。</li>\n<li><strong>表示层</strong>：设备固有数据格式和网络标准设局格式的转换。</li>\n<li><strong>会话层</strong>：通信管理，负责建立和断开通信连接。</li>\n<li><strong>传输层</strong>：管理两个节点之间的数据传输。</li>\n<li><strong>网络层</strong>：地址管理和路由选择。</li>\n<li><strong>数据链路层</strong>：互联设备间传送和识别数据帧。</li>\n<li><strong>物理层</strong>：01代表高低平的互换</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><strong>电路交换</strong>：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。</li>\n<li><strong>分组交换</strong>：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。</li>\n</ul>\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><ul>\n<li><strong>MAC地址</strong>：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。</li>\n<li><strong>IP地址</strong>：IP地址由网络号和主机号两部分组成。具有层次性。</li>\n</ul>\n<p>MAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。</p>\n<h3 id=\"网络的构成元素\"><a href=\"#网络的构成元素\" class=\"headerlink\" title=\"网络的构成元素\"></a>网络的构成元素</h3><ul>\n<li><strong>网卡</strong>：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。</li>\n<li><strong>中继器</strong>：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。</li>\n<li><strong>网桥</strong>：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。</li>\n<li><strong>路由器/3层交换机</strong>：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。</li>\n<li><strong>4-7层交换机</strong>：负责处理OSI模型中从传输层到应用层的数据。</li>\n<li><strong>网关</strong>：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。</li>\n</ul>\n<h2 id=\"TCP-IP基础知识\"><a href=\"#TCP-IP基础知识\" class=\"headerlink\" title=\"TCP/IP基础知识\"></a>TCP/IP基础知识</h2><h3 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP/IP模型\"></a>TCP/IP模型</h3><ul>\n<li><strong>硬件(物理层)</strong></li>\n<li><strong>网络接口层(数据链路层)</strong></li>\n<li><strong>互联网层(网络层)</strong><ul>\n<li>IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。</li>\n<li>ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的</li>\n<li>ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。</li>\n</ul>\n</li>\n<li><strong>传输层</strong><ul>\n<li>TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。</li>\n<li>UDP：面向无连接的传输层协议。</li>\n</ul>\n</li>\n<li><strong>应用层(会话层以上的分层)</strong><ul>\n<li>WWW</li>\n<li>电子邮件(E-Mail)</li>\n<li>文件传输(FTP)</li>\n<li>远程登录(TELNET,SSH)</li>\n<li>网络管理(SNMP)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据链路\"><a href=\"#数据链路\" class=\"headerlink\" title=\"数据链路\"></a>数据链路</h2><h3 id=\"数据链路的作用\"><a href=\"#数据链路的作用\" class=\"headerlink\" title=\"数据链路的作用\"></a>数据链路的作用</h3><p>数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。</p>\n<p>数据链路的<strong>段</strong>是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。</p>\n<p>网络的连接和构成形态成为<strong>网络拓扑</strong>。</p>\n<h3 id=\"数据链路相关技术\"><a href=\"#数据链路相关技术\" class=\"headerlink\" title=\"数据链路相关技术\"></a>数据链路相关技术</h3><p><strong>共享介质型网络</strong>：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。</p>\n<p><strong>非共享介质网络</strong>：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。</p>\n<p>以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。</p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>众多数据链路中最著名，使用最广发的是以太网。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><h3 id=\"IP即网络协议\"><a href=\"#IP即网络协议\" class=\"headerlink\" title=\"IP即网络协议\"></a>IP即网络协议</h3><p>网络层的下一层——数据链路层主要作用是在互连<strong>同一种数据链路节点</strong>之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。</p>\n<p>配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。</p>\n<p><strong>网络层与数据链路层关系</strong>：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。</p>\n<h3 id=\"IP基础知识\"><a href=\"#IP基础知识\" class=\"headerlink\" title=\"IP基础知识\"></a>IP基础知识</h3><p>IP大致分为三大模块，IP寻址，路由，IP分包和组包。</p>\n<p>为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。</p>\n<p>路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。</p>\n<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。</p>\n<h3 id=\"IP地址的基础知识\"><a href=\"#IP地址的基础知识\" class=\"headerlink\" title=\"IP地址的基础知识\"></a>IP地址的基础知识</h3><p>IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p>\n<p>IP地址的分类：</p>\n<ol>\n<li>A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识</li>\n<li>B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识</li>\n<li>C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识</li>\n<li>D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。</li>\n</ol>\n<p><strong>广播地址</strong>用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。</p>\n<p><strong>多播</strong>用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。</p>\n<p>网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”<strong>子网掩码</strong>“的识别码通过子网网络地址细分出比ABC更小粒度的网络。<br>子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.</p>\n<p>由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于<strong>私有IP</strong>，在此之外的IP称为<strong>全局IP</strong>。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。</p>\n<p>对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。</p>\n<h3 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h3><p>仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。</p>\n<p>路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p>\n<h2 id=\"IP协议相关\"><a href=\"#IP协议相关\" class=\"headerlink\" title=\"IP协议相关\"></a>IP协议相关</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS将主机名字符串转换为具体的IP地址。</p>\n<h3 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h3><p>只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。</p>\n<p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p>\n<p>从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过<strong>ARP</strong>从IP地址获得MAC地址，实现链路内的IP通信。</p>\n<p>根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cixh41dnu00017hzglj3547t2","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dom000c7hzgwd2gjjko"},{"post_id":"cixh41doe00087hzgeme71w6j","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41doo000g7hzg66ex8m4c"},{"post_id":"cixh41doh000b7hzgh6zdb7qt","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dor000i7hzgzbw2mklo"},{"post_id":"cixh41dny00027hzgydal7nxu","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dot000m7hzgoz6zjr78"},{"post_id":"cixh41dom000d7hzgbmur3srv","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dov000p7hzgonfrv81q"},{"post_id":"cixh41do400057hzgrwfaok2a","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41doz000u7hzg64d7r9e0"},{"post_id":"cixh41dou000n7hzg6pkpoxi6","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dpb000x7hzgmk932dgr"},{"post_id":"cixh41do800067hzg9t6jhewu","category_id":"cixh41dot000k7hzgmzmtxw9l","_id":"cixh41dph00107hzgkwevla3x"},{"post_id":"cixh41dow000q7hzgs2s68odb","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dpl00147hzgwypnhceo"},{"post_id":"cixh41doz000v7hzgy9g90leg","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dpn00177hzg40qtsbqy"},{"post_id":"cixh41dop000h7hzgeyvnz4sz","category_id":"cixh41doy000s7hzgm623ugqg","_id":"cixh41dpp001a7hzg8dema2c6"},{"post_id":"cixh41dph00127hzgvs5kj8kl","category_id":"cixh41dph000z7hzgyqpdx899","_id":"cixh41dpr001c7hzgvjt6cwzl"},{"post_id":"cixh41dor000j7hzg260489x7","category_id":"cixh41dph000z7hzgyqpdx899","_id":"cixh41dpu001h7hzgvwvgckg1"},{"post_id":"cixh41dpn00197hzg472fv11m","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dpx001k7hzgk7sc30kf"},{"post_id":"cixh41dpq001b7hzgqlef9l0q","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dq1001o7hzg4el4ej5o"},{"post_id":"cixh41dpc000y7hzgy5a2ryt3","category_id":"cixh41dpm00167hzg6m72rvqo","_id":"cixh41dq5001r7hzgkwk8o4fu"},{"post_id":"cixh41dps001e7hzgl9u38j5s","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dq8001v7hzg2bz07bk7"},{"post_id":"cixh41dpv001i7hzgme8lard2","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqa001y7hzg0f88y7x2"},{"post_id":"cixh41dpl00157hzgrhfe0clf","category_id":"cixh41dpm00167hzg6m72rvqo","_id":"cixh41dqf00227hzgi9wcobiq"},{"post_id":"cixh41dpy001l7hzgjhce0e0a","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqk00257hzgwm6j9jy9"},{"post_id":"cixh41dq1001p7hzg85mt16ou","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqm00297hzgukwnvwne"},{"post_id":"cixh41dq6001s7hzgvl5c6eey","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqq002c7hzgupl6z47l"},{"post_id":"cixh41dq8001w7hzghkvdbezo","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqw002e7hzglyuq9yn8"},{"post_id":"cixh41dqb001z7hzgcooniiu2","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dqz002j7hzgguyhx2r1"},{"post_id":"cixh41dqq002d7hzguja8exh6","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dr2002m7hzgbh25cph7"},{"post_id":"cixh41dqg00237hzgck4gvxnx","category_id":"cixh41dqm00287hzgbsf5nlz4","_id":"cixh41dr5002r7hzguvn9asrn"},{"post_id":"cixh41dqw002g7hzgunss374g","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dr8002u7hzgolruqw0r"},{"post_id":"cixh41dqz002k7hzgoprojmwy","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dra002y7hzgkiq12plu"},{"post_id":"cixh41dqk00267hzg2dq9p859","category_id":"cixh41dqy002h7hzgomxrz4av","_id":"cixh41drd00317hzgsgn7vv57"},{"post_id":"cixh41dr2002o7hzgrck22evy","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41drh00357hzgb946yo8m"},{"post_id":"cixh41dr6002s7hzgqo1x4y0y","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41drk00387hzgwfcr8sl2"},{"post_id":"cixh41dqn002a7hzg2i34ealz","category_id":"cixh41dqy002h7hzgomxrz4av","_id":"cixh41drn003d7hzgmqkh4nyj"},{"post_id":"cixh41dr8002v7hzg44ikbr0p","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41drn003f7hzg4o3vj33w"},{"post_id":"cixh41drb002z7hzguqxgmxhm","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dro003h7hzg3w0cmipz"},{"post_id":"cixh41drd00327hzg57ahlavn","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dro003l7hzgpnv9v9gf"},{"post_id":"cixh41dri00367hzgely1z2g0","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41drq003n7hzgbaksd48o"},{"post_id":"cixh41drk00397hzgkusx4bil","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41drs003r7hzgmliamzxs"},{"post_id":"cixh41dwe004m7hzgk4gbu4kg","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dwv004u7hzgde3kxvd7"},{"post_id":"cixh41dwi004o7hzgrwog14z4","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dwx004x7hzgaeovssg0"},{"post_id":"cixh41dwo004r7hzgnurkycv6","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dx100507hzgfetjwpdx"},{"post_id":"cixh41dwv004v7hzgr3owxhta","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dx400537hzgfa0eoc5k"},{"post_id":"cixh41dwy004y7hzgwnxqprqs","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dx700567hzgn0ju1ham"},{"post_id":"cixh41dx100517hzgyzzbzl9u","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dxa00597hzgb3rrm23r"},{"post_id":"cixh41dx400547hzg4o1lugvr","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dxd005c7hzg055kks48"},{"post_id":"cixh41dx700577hzgm308y4zc","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dxg005f7hzg3zgz62l9"},{"post_id":"cixh41dxa005a7hzgn3jwipqu","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxj005h7hzghekb16fi"},{"post_id":"cixh41dxd005d7hzgmyzt8eij","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxm005l7hzgx0efzxp2"},{"post_id":"cixh41dxh005g7hzgvxvmxtgc","category_id":"cixh41drm003c7hzgk6p1xad3","_id":"cixh41dxp005o7hzgik4n01qx"},{"post_id":"cixh41dxj005i7hzg98rydvgf","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxr005r7hzgl4f607jr"},{"post_id":"cixh41dxm005m7hzg2ajnlwud","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxt005u7hzghnjzrhnc"},{"post_id":"cixh41dxp005p7hzgco9478a8","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxv005x7hzgzj3mwbdk"},{"post_id":"cixh41dxr005s7hzgzavubun9","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dxz00617hzga0zj4u7e"},{"post_id":"cixh41dxt005v7hzg1dpqkr61","category_id":"cixh41dqm00287hzgbsf5nlz4","_id":"cixh41dy200647hzg69dj98wl"},{"post_id":"cixh41dxw005y7hzg2h34dalo","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dy400677hzgmz4gu07h"},{"post_id":"cixh41dy000627hzgkmujhr51","category_id":"cixh41do400047hzg9ejqyy6e","_id":"cixh41dy500697hzgsdjuunbo"},{"post_id":"cixh41dy200657hzgcln9yerd","category_id":"cixh41dot000k7hzgmzmtxw9l","_id":"cixh41dy5006b7hzge1jj5vtl"}],"PostTag":[{"post_id":"cixh41dnu00017hzglj3547t2","tag_id":"cixh41do100037hzgyemzy3ia","_id":"cixh41dog000a7hzgu9vvns9k"},{"post_id":"cixh41dny00027hzgydal7nxu","tag_id":"cixh41dod00077hzgiy0422fl","_id":"cixh41dov000o7hzgwwy150gg"},{"post_id":"cixh41dny00027hzgydal7nxu","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41doy000r7hzgo5z2yuew"},{"post_id":"cixh41do400057hzgrwfaok2a","tag_id":"cixh41dot000l7hzghc203daz","_id":"cixh41dpb000w7hzgxqrgtta7"},{"post_id":"cixh41do800067hzg9t6jhewu","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dpk00137hzg2ukr68wq"},{"post_id":"cixh41doe00087hzgeme71w6j","tag_id":"cixh41dod00077hzgiy0422fl","_id":"cixh41dpu001g7hzg490grq9l"},{"post_id":"cixh41doe00087hzgeme71w6j","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41dpx001j7hzg54ygysws"},{"post_id":"cixh41dpv001i7hzgme8lard2","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41dq0001n7hzgtloiwjpu"},{"post_id":"cixh41doh000b7hzgh6zdb7qt","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dq5001q7hzgrgbih9pv"},{"post_id":"cixh41dq1001p7hzg85mt16ou","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dq8001u7hzgduk77z6b"},{"post_id":"cixh41dom000d7hzgbmur3srv","tag_id":"cixh41dq0001m7hzgxikeniv2","_id":"cixh41dqa001x7hzgleanek2i"},{"post_id":"cixh41dq6001s7hzgvl5c6eey","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41dqe00217hzg7sxjfdvn"},{"post_id":"cixh41dop000h7hzgeyvnz4sz","tag_id":"cixh41dq7001t7hzgm8bazpr5","_id":"cixh41dqj00247hzg8k7qxcm8"},{"post_id":"cixh41dor000j7hzg260489x7","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dqq002b7hzg34i78s76"},{"post_id":"cixh41dou000n7hzg6pkpoxi6","tag_id":"cixh41dqm00277hzg62olfazh","_id":"cixh41dqz002i7hzg6dvj7sgc"},{"post_id":"cixh41dqw002g7hzgunss374g","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dr1002l7hzgrc3x0r9j"},{"post_id":"cixh41dqz002k7hzgoprojmwy","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dr5002q7hzg1pnfqz3g"},{"post_id":"cixh41dow000q7hzgs2s68odb","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dr7002t7hzgspvi3man"},{"post_id":"cixh41dr2002o7hzgrck22evy","tag_id":"cixh41dod00077hzgiy0422fl","_id":"cixh41dra002x7hzggd8lfhmc"},{"post_id":"cixh41doz000v7hzgy9g90leg","tag_id":"cixh41dr2002n7hzgcfkiis32","_id":"cixh41drd00307hzgeff13gk1"},{"post_id":"cixh41dr8002v7hzg44ikbr0p","tag_id":"cixh41dq0001m7hzgxikeniv2","_id":"cixh41drh00347hzgbvd7rtb4"},{"post_id":"cixh41dr8002v7hzg44ikbr0p","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41drk00377hzg8mtwjgtp"},{"post_id":"cixh41drb002z7hzguqxgmxhm","tag_id":"cixh41dq0001m7hzgxikeniv2","_id":"cixh41drm003b7hzg0m9pv68y"},{"post_id":"cixh41drd00327hzg57ahlavn","tag_id":"cixh41dq0001m7hzgxikeniv2","_id":"cixh41drn003e7hzgqeuu5te6"},{"post_id":"cixh41dri00367hzgely1z2g0","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dro003g7hzgxu68af26"},{"post_id":"cixh41dpc000y7hzgy5a2ryt3","tag_id":"cixh41dra002w7hzg1c6d9sw5","_id":"cixh41dro003k7hzgvzxq034p"},{"post_id":"cixh41dpc000y7hzgy5a2ryt3","tag_id":"cixh41drh00337hzgrfbxvlgc","_id":"cixh41drp003m7hzgbjw7xeab"},{"post_id":"cixh41drk00397hzgkusx4bil","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41drr003p7hzgdcy4xiq5"},{"post_id":"cixh41dph00127hzgvs5kj8kl","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41drs003q7hzgybqbpaot"},{"post_id":"cixh41dph00127hzgvs5kj8kl","tag_id":"cixh41drm003a7hzgo623b60v","_id":"cixh41drs003t7hzgxegbiqog"},{"post_id":"cixh41dpl00157hzgrhfe0clf","tag_id":"cixh41dra002w7hzg1c6d9sw5","_id":"cixh41drt003u7hzgdx5j4r5a"},{"post_id":"cixh41dpn00197hzg472fv11m","tag_id":"cixh41drq003o7hzgusv2ehxx","_id":"cixh41dru003w7hzgkfer1rdl"},{"post_id":"cixh41dpq001b7hzgqlef9l0q","tag_id":"cixh41drq003o7hzgusv2ehxx","_id":"cixh41dru003x7hzgmlh9wpqo"},{"post_id":"cixh41dps001e7hzgl9u38j5s","tag_id":"cixh41drq003o7hzgusv2ehxx","_id":"cixh41drv003z7hzgn2j5hzap"},{"post_id":"cixh41dpy001l7hzgjhce0e0a","tag_id":"cixh41drq003o7hzgusv2ehxx","_id":"cixh41drw00417hzgrsni0qwl"},{"post_id":"cixh41dq8001w7hzghkvdbezo","tag_id":"cixh41drv00407hzg9solk00e","_id":"cixh41drw00437hzgr594jhuu"},{"post_id":"cixh41dqb001z7hzgcooniiu2","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dry00477hzg16qxj4qn"},{"post_id":"cixh41dqb001z7hzgcooniiu2","tag_id":"cixh41drw00427hzgdbpkhrv5","_id":"cixh41dry00487hzgqxd0s3qp"},{"post_id":"cixh41dqb001z7hzgcooniiu2","tag_id":"cixh41drx00447hzgcjb2kjbt","_id":"cixh41dry004a7hzgd9ydjqy8"},{"post_id":"cixh41dqb001z7hzgcooniiu2","tag_id":"cixh41drh00337hzgrfbxvlgc","_id":"cixh41dry004b7hzgsn33f7b6"},{"post_id":"cixh41dqg00237hzgck4gvxnx","tag_id":"cixh41drx00467hzgmiao0rgd","_id":"cixh41dry004d7hzgl8j55gg6"},{"post_id":"cixh41dqk00267hzg2dq9p859","tag_id":"cixh41dry00497hzgew7zzfjq","_id":"cixh41drz004e7hzg5wyjhnm9"},{"post_id":"cixh41dqn002a7hzg2i34ealz","tag_id":"cixh41drx00467hzgmiao0rgd","_id":"cixh41ds0004h7hzggklhpwny"},{"post_id":"cixh41dqn002a7hzg2i34ealz","tag_id":"cixh41drh00337hzgrfbxvlgc","_id":"cixh41ds0004i7hzg591e14u7"},{"post_id":"cixh41dqq002d7hzguja8exh6","tag_id":"cixh41drz004g7hzgjr732rnz","_id":"cixh41ds0004k7hzg4977gfkn"},{"post_id":"cixh41dr6002s7hzgqo1x4y0y","tag_id":"cixh41ds0004j7hzg5kdlhesu","_id":"cixh41ds0004l7hzgunmhisxp"},{"post_id":"cixh41dwe004m7hzgk4gbu4kg","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dwm004q7hzgb7bp5ozc"},{"post_id":"cixh41dwi004o7hzgrwog14z4","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dwv004t7hzgw97blfpv"},{"post_id":"cixh41dwo004r7hzgnurkycv6","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dwx004w7hzgeijhn84r"},{"post_id":"cixh41dwv004v7hzgr3owxhta","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dx0004z7hzg1fyixcv9"},{"post_id":"cixh41dwy004y7hzgwnxqprqs","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dx400527hzgb0nljqa9"},{"post_id":"cixh41dx100517hzgyzzbzl9u","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dx700557hzgw5brueka"},{"post_id":"cixh41dx400547hzg4o1lugvr","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dxa00587hzgstrhirty"},{"post_id":"cixh41dx700577hzgm308y4zc","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dxc005b7hzg3opg65tx"},{"post_id":"cixh41dxh005g7hzgvxvmxtgc","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dxm005j7hzgedr1x0mt"},{"post_id":"cixh41dxj005i7hzg98rydvgf","tag_id":"cixh41dxg005e7hzgmhd6qh21","_id":"cixh41dxo005n7hzge5w0r9sd"},{"post_id":"cixh41dxj005i7hzg98rydvgf","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41dxq005q7hzg68h0w9zn"},{"post_id":"cixh41dxa005a7hzgn3jwipqu","tag_id":"cixh41dxg005e7hzgmhd6qh21","_id":"cixh41dxs005t7hzgmdnkbcbj"},{"post_id":"cixh41dxm005m7hzg2ajnlwud","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dxv005w7hzgfwuifxwf"},{"post_id":"cixh41dxp005p7hzgco9478a8","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dxz00607hzg38hilxca"},{"post_id":"cixh41dxd005d7hzgmyzt8eij","tag_id":"cixh41dxg005e7hzgmhd6qh21","_id":"cixh41dy100637hzgmpa04mci"},{"post_id":"cixh41dxr005s7hzgzavubun9","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dy400667hzgmvp8e5lz"},{"post_id":"cixh41dxw005y7hzg2h34dalo","tag_id":"cixh41doo000f7hzg2mdb1b64","_id":"cixh41dy500687hzgu27aobef"},{"post_id":"cixh41dxw005y7hzg2h34dalo","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dy5006a7hzghizicxqv"},{"post_id":"cixh41dy000627hzgkmujhr51","tag_id":"cixh41dpr001d7hzg1jiwckm9","_id":"cixh41dy5006c7hzgvha745we"},{"post_id":"cixh41dy200657hzgcln9yerd","tag_id":"cixh41doy000t7hzgtq91ibko","_id":"cixh41dy5006d7hzgmb0ke2fz"},{"post_id":"cixh41dxt005v7hzg1dpqkr61","tag_id":"cixh41dxz005z7hzg3m55n15h","_id":"cixh41dy6006e7hzgm5d823p2"}],"Tag":[{"name":"Block","_id":"cixh41do100037hzgyemzy3ia"},{"name":"Animation","_id":"cixh41dod00077hzgiy0422fl"},{"name":"UI","_id":"cixh41doo000f7hzg2mdb1b64"},{"name":"GCD","_id":"cixh41dot000l7hzghc203daz"},{"name":"学习笔记","_id":"cixh41doy000t7hzgtq91ibko"},{"name":"Xcode","_id":"cixh41dpr001d7hzg1jiwckm9"},{"name":"Objective-C","_id":"cixh41dq0001m7hzgxikeniv2"},{"name":"Principle","_id":"cixh41dq7001t7hzgm8bazpr5"},{"name":"AutoLayout","_id":"cixh41dqm00277hzg62olfazh"},{"name":"NSNotification","_id":"cixh41dr2002n7hzgcfkiis32"},{"name":"React-Native","_id":"cixh41dra002w7hzg1c6d9sw5"},{"name":"爬坑","_id":"cixh41drh00337hzgrfbxvlgc"},{"name":"NodeJs","_id":"cixh41drm003a7hzgo623b60v"},{"name":"基本控件","_id":"cixh41drq003o7hzgusv2ehxx"},{"name":"UIGesture","_id":"cixh41drv00407hzg9solk00e"},{"name":"Vim","_id":"cixh41drw00427hzgdbpkhrv5"},{"name":"Cocoapods","_id":"cixh41drx00447hzgcjb2kjbt"},{"name":"Hexo","_id":"cixh41drx00467hzgmiao0rgd"},{"name":"Git","_id":"cixh41dry00497hzgew7zzfjq"},{"name":"UIResponder","_id":"cixh41drz004g7hzgjr732rnz"},{"name":"Debug","_id":"cixh41ds0004j7hzg5kdlhesu"},{"name":"Runtime","_id":"cixh41dxg005e7hzgmhd6qh21"},{"name":"杂谈","_id":"cixh41dxz005z7hzg3m55n15h"}]}}