{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1472176314000},{"_id":"themes/landscape/.DS_Store","hash":"b593dd68a540e9c29a02f187860f22d53dfda656","modified":1472190791000},{"_id":"themes/landscape/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1472176314000},{"_id":"themes/landscape/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1472176314000},{"_id":"themes/landscape/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1472176314000},{"_id":"themes/landscape/_config.yml","hash":"b2020e092410ea67950c6b1a159141eb88451e04","modified":1474609056000},{"_id":"source/.DS_Store","hash":"69cfd8dd5509ad8d580514c031d2a1dad728a727","modified":1474609929000},{"_id":"themes/landscape/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1472176314000},{"_id":"source/_posts/CALayer学习小结.md","hash":"d26a12f2049f74c51a8709021e8bf439d3ba4447","modified":1474609443000},{"_id":"source/_posts/.DS_Store","hash":"6d9f830c554f7333915f55f916b07bdaa5999a13","modified":1474610047000},{"_id":"source/_posts/CALayer的transform属性.md","hash":"a86fa1c1fe375724f02920a4c756c32fc9a3c08d","modified":1474609571000},{"_id":"source/_posts/Block基础.md","hash":"259fd703c64727577c1311632431c772d1916c13","modified":1473040519000},{"_id":"source/_posts/IPhone6全屏黑边处理.md","hash":"f265d6296a31271140f3e6f6c042ef69230e0486","modified":1473067453000},{"_id":"source/_posts/JavaScript基本语法.md","hash":"77275169ac26d35c9ea33f0a2e3f4a7b75083b82","modified":1474163036000},{"_id":"source/_posts/NSLayoutConstraint.md","hash":"2cfd1710542e3c5746c68c12be91274142ed7374","modified":1473386736000},{"_id":"source/_posts/Nodejs学习笔记.md","hash":"a398e52b377995208b028ec6175a4ce331393202","modified":1474545444000},{"_id":"source/_posts/NSNotification基本使用.md","hash":"8c4c78cfd3e92416e588a64cba5cbb1c4884eddb","modified":1473824534000},{"_id":"source/_posts/UIButton基础.md","hash":"cdf37e203c457d5f37627df87295f760018544a0","modified":1474609562000},{"_id":"source/_posts/GCD队列.md","hash":"73cc87cd658da63e8f85338133c798075418fa60","modified":1474609457000},{"_id":"source/_posts/Scrollview使用详解.md","hash":"58b05556e31b697fa673b347a6a6e30824671fb8","modified":1474609631000},{"_id":"source/_posts/UIGestureRecognizer.md","hash":"e0f545fa25a5f816a55aa3eb45fa3781600257cc","modified":1474609498000},{"_id":"source/_posts/UITableView基础.md","hash":"63c4160d4951def7d69a35f5a4e4ba53ab8c5ad0","modified":1474609487000},{"_id":"source/_posts/UILabel的高度计算.md","hash":"a6df5c80888fc356c0132fec0ef254de1f4148a7","modified":1473666258000},{"_id":"source/_posts/XVim安装.md","hash":"c4e5233e96fb61dfca9647f75c66b16dc95c1af0","modified":1474613118000},{"_id":"source/_posts/UICollectionView.md","hash":"1e755fafef52acbcb6467c83a88f6f946cbbefc7","modified":1474609464000},{"_id":"source/_posts/hello-world.md","hash":"db9406da75d11f33966a5062fb12e51bb169796f","modified":1474609472000},{"_id":"themes/landscape/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1472176314000},{"_id":"source/_posts/ios响应事件.md","hash":"7dcd86cce081fd6274de0102c3cbd771e8206a7f","modified":1474609585000},{"_id":"source/_posts/UITableview自适应高度.md","hash":"aaef47c471850467469656d51624589a3d43cd07","modified":1474609554000},{"_id":"source/_posts/lldb调试方法.md","hash":"8193ba709a2e117398a48236d5804c0436247718","modified":1474609531000},{"_id":"source/_posts/objectice-c.md","hash":"6521494957fda126593b30f85a4d8a9334eb7186","modified":1474609947000},{"_id":"source/_posts/oc中的枚举.md","hash":"bb34509d43e86f740a91c7ee4509b17ba9b6f869","modified":1474609604000},{"_id":"source/_posts/python_IO编程.md","hash":"15da4be02bcef3f90d853117ad32bf03a3da6c9e","modified":1474610013000},{"_id":"source/_posts/python_函数.md","hash":"084198f2cb3626bc9a3ef50db7760337524077cd","modified":1474609981000},{"_id":"source/_posts/python_函数式编程.md","hash":"22304a78a1b470030c1012e20ab734ae9fc4bed5","modified":1474609985000},{"_id":"source/_posts/python_常用內建模块.md","hash":"7e801b0e8bd8c12ddaf2cb5776953547ca6d8964","modified":1474609961000},{"_id":"source/_posts/python_模块.md","hash":"7f8cf8d9bc7920b9c8312b7f990e03262cd39f51","modified":1474610003000},{"_id":"source/_posts/python_正则表达式.md","hash":"39f4251fb405473c5503dc7ce261ef776d88d480","modified":1474610008000},{"_id":"source/_posts/python_进程与线程.md","hash":"5a381198303b993cfea4082d72a7faecdbeae0e3","modified":1474609989000},{"_id":"source/_posts/python_面向对象编程.md","hash":"b86af2a2356d378b6b676ef0f3afeddb7b1e7012","modified":1474609996000},{"_id":"source/_posts/python_面向对象高级编程.md","hash":"dce673aa2e6b47d3edd7ac9b5853a73deb46032a","modified":1474610000000},{"_id":"source/_posts/python_高级特性.md","hash":"c60b5961314b3af6c4ba0b2afd0db0f3ab988179","modified":1474609974000},{"_id":"source/_posts/python语法.md","hash":"cb240a83635f406f9b06de98ff5c3a43b05cf087","modified":1474610016000},{"_id":"source/_posts/runtime原理.md","hash":"aeef1f4f64aa4ddd05df3f53f843abb8666287ef","modified":1474609518000},{"_id":"source/_posts/runtime应用.md","hash":"99cb5513c4979bb68d15bdf9ea55ab8bd85dfe00","modified":1474609513000},{"_id":"source/_posts/ios编程（第四版.md","hash":"e0bb387b2827c7b67100458fdf1669ce045455cf","modified":1474610030000},{"_id":"source/_posts/初识Provisioning_Profile.md","hash":"4d3490c53d22ee55f4c6105166cda7c530d68da8","modified":1474609524000},{"_id":"source/_posts/ios动画.md","hash":"aa30a87d09bca9e940a34e3b1292f000a20e3417","modified":1474609576000},{"_id":"source/_posts/xib设置border.md","hash":"aa96c5a1959d5f6aa79b2c93f17da191200f0b56","modified":1474609430000},{"_id":"source/_posts/图解TCP_IP.md","hash":"50d1304151fa80af5120b588cbddbb258ae57674","modified":1474610037000},{"_id":"source/_posts/删除storyboard.md","hash":"8e3ab139bd8f6f48c0fe9301befd4e3f0c0f75ce","modified":1474609645000},{"_id":"source/_posts/git技巧.md","hash":"011729fee3d90d6077ad03522f67522e40485eeb","modified":1474609539000},{"_id":"source/_posts/重新开始.md","hash":"f15af7b5856cb41faaa7f77546581c8f3424639b","modified":1472176314000},{"_id":"source/about/index.md","hash":"0d3d216cb610b10447e97566fe3789d313cbbad4","modified":1472176314000},{"_id":"source/tags/index.md","hash":"5a034eac201382d18d2e8f7b53e7868e6bd948e2","modified":1472176314000},{"_id":"source/categories/index.md","hash":"ca9ce2d6c165e3826b6fe70c4d6f21af059b99a2","modified":1472176314000},{"_id":"themes/landscape/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1472176314000},{"_id":"source/categories/.DS_Store","hash":"4b1737e2d95536850ac239b97c1d4b1deae9a602","modified":1474608187000},{"_id":"source/tags/.DS_Store","hash":"4b1737e2d95536850ac239b97c1d4b1deae9a602","modified":1474608179000},{"_id":"themes/landscape/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1472176314000},{"_id":"themes/landscape/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1472176314000},{"_id":"themes/landscape/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1472176314000},{"_id":"themes/landscape/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1472176314000},{"_id":"themes/landscape/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1472176314000},{"_id":"themes/landscape/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1472176314000},{"_id":"themes/landscape/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1472176314000},{"_id":"themes/landscape/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1472176314000},{"_id":"themes/landscape/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1472176314000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1472176314000},{"_id":"themes/landscape/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1472176314000},{"_id":"themes/landscape/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1472176314000},{"_id":"themes/landscape/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1472176314000},{"_id":"themes/landscape/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1472176314000},{"_id":"themes/landscape/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1472176314000},{"_id":"themes/landscape/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1472176314000},{"_id":"themes/landscape/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1472176314000},{"_id":"themes/landscape/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1472176314000},{"_id":"themes/landscape/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1472176314000},{"_id":"themes/landscape/images/author.png","hash":"5b9e9293ad03091a3094ee299ce2e36231b961dd","modified":1472176314000},{"_id":"themes/landscape/images/logo.png","hash":"44201457192532a1ecadb7aacf85d987a67903e2","modified":1472176314000},{"_id":"themes/landscape/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1472176314000},{"_id":"themes/landscape/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1472176314000},{"_id":"themes/landscape/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1472176314000},{"_id":"themes/landscape/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1472176314000},{"_id":"themes/landscape/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1472176314000},{"_id":"themes/landscape/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1472176314000},{"_id":"themes/landscape/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1472176314000},{"_id":"themes/landscape/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1472176314000},{"_id":"themes/landscape/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1472176314000},{"_id":"themes/landscape/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1472176314000},{"_id":"themes/landscape/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1472176314000},{"_id":"themes/landscape/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1472176314000},{"_id":"themes/landscape/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1472176314000},{"_id":"themes/landscape/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1472176314000},{"_id":"themes/landscape/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1472176314000},{"_id":"themes/landscape/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1472176314000},{"_id":"themes/landscape/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1472176314000},{"_id":"themes/landscape/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1472176314000},{"_id":"themes/landscape/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1472176314000},{"_id":"themes/landscape/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1472176314000},{"_id":"themes/landscape/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1472176314000},{"_id":"themes/landscape/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1472176314000},{"_id":"themes/landscape/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1472176314000},{"_id":"themes/landscape/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1472176314000},{"_id":"themes/landscape/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1472176314000},{"_id":"themes/landscape/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1472176314000},{"_id":"themes/landscape/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1472176314000},{"_id":"themes/landscape/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1472176314000},{"_id":"themes/landscape/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1472176314000},{"_id":"themes/landscape/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1472176314000},{"_id":"themes/landscape/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1472176314000},{"_id":"themes/landscape/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1472176314000},{"_id":"themes/landscape/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1472176314000},{"_id":"themes/landscape/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1472176314000},{"_id":"themes/landscape/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1472176314000},{"_id":"themes/landscape/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1472176314000},{"_id":"themes/landscape/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1472176314000},{"_id":"themes/landscape/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1472176314000},{"_id":"themes/landscape/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1472176314000},{"_id":"themes/landscape/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1472176314000},{"_id":"themes/landscape/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1472176314000},{"_id":"themes/landscape/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1472176314000},{"_id":"themes/landscape/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1472176314000},{"_id":"public/search.xml","hash":"193df49882802e693befbcccbca78dcfd1be48e2","modified":1474613273257},{"_id":"public/about/index.html","hash":"f682a220c5a674f11623d6d2f6f17c85d5ac2fc5","modified":1474613273330},{"_id":"public/categories/index.html","hash":"1e1c054a6a890cd2be10014a3bff01c98fc276e8","modified":1474613273330},{"_id":"public/categories/JavaScript/index.html","hash":"4395cf91156df98c5b9bc06a6d6f202d56aa0b08","modified":1474613273330},{"_id":"public/categories/无处置放/index.html","hash":"eb2b3337f6cdebd049b930379ed47839c5b88d7b","modified":1474613273330},{"_id":"public/categories/python/page/2/index.html","hash":"05a8f2c24ff6fe7a1f68d8f7df1ce8e01c0f4488","modified":1474613273330},{"_id":"public/categories/计算机/index.html","hash":"19d7046f3e77c2464a882942fdb25b82a8e5c9e7","modified":1474613273330},{"_id":"public/categories/Git/index.html","hash":"c77472a01663cc93b03a6cd671fe6bdc17698fe1","modified":1474613273331},{"_id":"public/tag/Block/index.html","hash":"cf0aa009eeb898788ae2099eeadb129a1fd98ad4","modified":1474613273331},{"_id":"public/tag/AutoLayout/index.html","hash":"2395965342c1ebd05d5f2b952ec1e7447d2339a4","modified":1474613273331},{"_id":"public/tag/NSNotification/index.html","hash":"0d85605b19c274bf86ce5862fbc9dcefe2f464b4","modified":1474613273331},{"_id":"public/tag/GCD/index.html","hash":"612f0d72ec1c3ab3659bec507b66c0027eff0f6d","modified":1474613273331},{"_id":"public/tag/UIGesture/index.html","hash":"1ef774a33d6dcf251b5b3d6a370a2a67452a5f50","modified":1474613273331},{"_id":"public/tag/Hexo/index.html","hash":"360d89125f4a8fbf1932cbd6d03860c2b90d406b","modified":1474613273331},{"_id":"public/tag/UIResponder/index.html","hash":"d9a1b32d7e96b659a427044087d945aabf2601ed","modified":1474613273331},{"_id":"public/tag/Debug/index.html","hash":"29442dd7b1e755e6c44209756065bad516cef9be","modified":1474613273331},{"_id":"public/tag/Objective-C/index.html","hash":"7cbc206498e540ad946c6a59d582b95dcb5a5b76","modified":1474613273331},{"_id":"public/tag/Git/index.html","hash":"81bb515663391b24cb470fc182f744006381cfcb","modified":1474613273331},{"_id":"public/tag/杂谈/index.html","hash":"48dab28713f851c5e97546a5cd55335f348da474","modified":1474613273331},{"_id":"public/tags/index.html","hash":"d3679698724d3025deb8fe9c44873047e30b29ef","modified":1474613273331},{"_id":"public/2016/09/22/Nodejs学习笔记/index.html","hash":"c817d6ab2092d08ad951ad9e5f8ac1c0f576409e","modified":1474613273331},{"_id":"public/2016/09/21/lldb调试方法/index.html","hash":"5d2afdebf1239f09996c8e23d468de407a8af1da","modified":1474613273331},{"_id":"public/2016/09/18/Scrollview使用详解/index.html","hash":"ddc72ac99fbdd8b6246321ea91aabc0034936c78","modified":1474613273331},{"_id":"public/2016/09/13/NSNotification基本使用/index.html","hash":"82f5fe79027fad3441e527bdcb3e9e21e260d4cc","modified":1474613273331},{"_id":"public/2016/09/12/UILabel的高度计算/index.html","hash":"00c416817f9d2b1298de3df3b542c15155221763","modified":1474613273331},{"_id":"public/2016/09/09/JavaScript基本语法/index.html","hash":"cbb2932dbff29ea46cbc770eef2c44e7dd516284","modified":1474613273331},{"_id":"public/2016/09/08/NSLayoutConstraint/index.html","hash":"0aa5a4aaf4c3df1b83288a5d3dd7f470c05c8acf","modified":1474613273332},{"_id":"public/2016/09/07/oc中的枚举/index.html","hash":"627a01199e44d7ce1f7b136e12e49aaf936c1ca8","modified":1474613273332},{"_id":"public/2016/09/05/UIGestureRecognizer/index.html","hash":"7c42c7599aa0f246c601b85437cee386e388f7e1","modified":1474613273332},{"_id":"public/2016/09/05/IPhone6全屏黑边处理/index.html","hash":"794624dd69975e2613b37521c6db6cd836b797bc","modified":1474613273332},{"_id":"public/2016/09/03/ios响应事件/index.html","hash":"85f001425c50ff057b7c5ce6435d4d81ed78f2af","modified":1474613273332},{"_id":"public/2016/09/02/CALayer的transform属性/index.html","hash":"b840bdab4cf5ecd1d57deba6a4d737667d2e923d","modified":1474613273332},{"_id":"public/2016/09/01/Block基础/index.html","hash":"13008457648d427f2e6a937b3cfbcbbb76bfe30b","modified":1474613273332},{"_id":"public/2016/08/30/UITableView基础/index.html","hash":"3ea641fc496442b7664218857c05621da0cb1eb6","modified":1474613273332},{"_id":"public/2016/08/29/UIButton基础/index.html","hash":"a02e64319f8c4213ea8c03aa51d319c39e034406","modified":1474613273332},{"_id":"public/2016/08/27/git技巧/index.html","hash":"2a1d370df5a5e89959978387fdc81f867c70e1ee","modified":1474613273332},{"_id":"public/2016/08/26/初识Provisioning_Profile/index.html","hash":"c058f3b7413df910a0f673731a65e3573f4a5c9f","modified":1474613273332},{"_id":"public/2016/08/26/UITableview自适应高度/index.html","hash":"e44aa7592bdac39b709512f7af62aaf55fc5dee9","modified":1474613273332},{"_id":"public/2016/08/23/runtime应用/index.html","hash":"52683f2b405988ffb4d5b0f793a421745464d24b","modified":1474613273332},{"_id":"public/2016/08/23/python_常用內建模块/index.html","hash":"d53c1e013ffbfbb1186a171f14d48fdb6c999d03","modified":1474613273332},{"_id":"public/2016/08/22/runtime原理/index.html","hash":"4949ddf388ec6446f67e848ea14c2560aa6391d6","modified":1474613273333},{"_id":"public/2016/08/20/python_正则表达式/index.html","hash":"d1dca069ec601ced5396479dd545480972751c7c","modified":1474613273333},{"_id":"public/2016/08/18/python_进程与线程/index.html","hash":"19976b924ddb74831a8cab00a16b29fb186b1161","modified":1474613273333},{"_id":"public/2016/08/16/ios动画/index.html","hash":"f4b5b53e1bda8789359160ff768a4935d7ef90ea","modified":1474613273333},{"_id":"public/2016/08/15/python_IO编程/index.html","hash":"b23dea25de22a7aeaaacea7eb661747e9b5f8b87","modified":1474613273333},{"_id":"public/2016/08/12/CALayer学习小结/index.html","hash":"1075d99dc0698e41306bc56dc1d35824a4dd8bc1","modified":1474613273333},{"_id":"public/2016/08/11/删除storyboard/index.html","hash":"d458058d0165105453afc76a0fb7353e5af40c95","modified":1474613273333},{"_id":"public/2016/08/10/xib设置border/index.html","hash":"312bebfee3841c2a7bd395182ccaf15d5fa65aef","modified":1474613273333},{"_id":"public/2016/08/10/python_面向对象高级编程/index.html","hash":"8d03f14bdeb5acc6829f29b829f880c50af9ccee","modified":1474613273333},{"_id":"public/2016/08/09/python_模块/index.html","hash":"ca76b707772b3fc03741d5620cf7f53a5c1da641","modified":1474613273333},{"_id":"public/2016/08/09/python_面向对象编程/index.html","hash":"e7ecd2af08534929620388e25deb4db23e5bc735","modified":1474613273333},{"_id":"public/2016/08/08/python_高级特性/index.html","hash":"f29eacc6214216bb59c134260777540a76719aba","modified":1474613273333},{"_id":"public/2016/08/08/python_函数式编程/index.html","hash":"85ab3e1d9bd294b13d982cdbc423fef648c4cd6d","modified":1474613273333},{"_id":"public/2016/08/07/python语法/index.html","hash":"0d5231dfad66c24d2e9f4c9c7e112fa33ee91e61","modified":1474613273333},{"_id":"public/2016/08/07/python_函数/index.html","hash":"380c2a4111e9dfc4fcb7293b4f9ac15d47e59bc8","modified":1474613273333},{"_id":"public/2016/08/05/UICollectionView/index.html","hash":"cd2349fea621361ab9caa286d43e37bc5eb30410","modified":1474613273333},{"_id":"public/2016/08/02/GCD队列/index.html","hash":"0ca29bf99202d2107bc8b821155f89aa3f01e15b","modified":1474613273333},{"_id":"public/2016/07/31/图解TCP_IP/index.html","hash":"5ee53f91b7e487592ff2157caf68c440d26e7027","modified":1474613273333},{"_id":"public/2016/07/31/ios编程（第四版/index.html","hash":"8590ccffee973f0e9bec6d19442a2e2726eaaca9","modified":1474613273333},{"_id":"public/2016/07/31/objectice-c/index.html","hash":"62368d56884b87ee7e6fe193278eed644ef88b3e","modified":1474613273333},{"_id":"public/2016/07/30/重新开始/index.html","hash":"c0d796ba4718cdc9fdb93c12913cc231c5c6d47f","modified":1474613273334},{"_id":"public/2016/07/29/hello-world/index.html","hash":"0b7513479c30c49122d961ca39f41fbafab92718","modified":1474613273334},{"_id":"public/archives/index.html","hash":"14483dedf691c40a74981c468a83ed1675c0ee81","modified":1474613273334},{"_id":"public/archives/page/2/index.html","hash":"32be818bc2db4f8919703ed7229ec15e3c76eead","modified":1474613273334},{"_id":"public/archives/page/3/index.html","hash":"e39728fafa0cb13a1fbc3e40d6b0b23a36486a82","modified":1474613273334},{"_id":"public/archives/page/4/index.html","hash":"408729fe81fb4154da8b1366bd5cb808c3c4cc97","modified":1474613273334},{"_id":"public/archives/page/5/index.html","hash":"6bbab13a8181efc8e2298b6a5b796cf981839bd4","modified":1474613273334},{"_id":"public/archives/2016/index.html","hash":"0ee7688a8fe2ab702f633e55119ba3db8b24aeef","modified":1474613273334},{"_id":"public/archives/2016/page/2/index.html","hash":"f12d0e87a4e60952ab232568d7b1d0ab591f3f2b","modified":1474613273334},{"_id":"public/archives/2016/page/3/index.html","hash":"6da7ac8427b0f238ffd7c17db70a2fb049e69ca6","modified":1474613273334},{"_id":"public/archives/2016/page/4/index.html","hash":"e00f4ada5d172751919f34c9b2fce8492eb8db9b","modified":1474613273334},{"_id":"public/archives/2016/page/5/index.html","hash":"826d654ee5bf6482f58c1bb7e95e5009459f5c99","modified":1474613273334},{"_id":"public/archives/2016/08/index.html","hash":"83f87c2c726aa80c677fc5e336bfea2aeeae5637","modified":1474613273334},{"_id":"public/archives/2016/07/index.html","hash":"bd48788ab9e5ae6de04798b683c6231e73e5cf72","modified":1474613273334},{"_id":"public/archives/2016/08/page/2/index.html","hash":"80870e4c466efffd56a57689656fde08d52a4dcc","modified":1474613273334},{"_id":"public/archives/2016/08/page/3/index.html","hash":"39d3921b91fcf79eb1ff216ceab4063c8c785c1f","modified":1474613273334},{"_id":"public/archives/2016/09/index.html","hash":"184a7b528c52a1587fc38d9543cbeab99a32de08","modified":1474613273334},{"_id":"public/archives/2016/09/page/2/index.html","hash":"5bfe3b82371cf4167bd4b6ce29aa691deb20695b","modified":1474613273334},{"_id":"public/categories/IOS/index.html","hash":"d28af7672985f99df5a9bef744ecd678f19f80b4","modified":1474613273334},{"_id":"public/categories/IOS/page/2/index.html","hash":"c81d430ab3923903bc0da805bef61dbe1126e01e","modified":1474613273334},{"_id":"public/categories/IOS/page/3/index.html","hash":"99181ec08934475731f87ff8d2e2df2a524bb3e6","modified":1474613273334},{"_id":"public/categories/python/index.html","hash":"1c3a7804550bbbe689260449d7be5713e575e38b","modified":1474613273334},{"_id":"public/index.html","hash":"8836855e96c31c167305d0a449d1d6d2084849dd","modified":1474613273334},{"_id":"public/page/2/index.html","hash":"e8cbb46b347eb16d49694f1af1aabfb9beafbe17","modified":1474613273335},{"_id":"public/page/3/index.html","hash":"8fba5aaa47e00f86dbb6a2f4d35668a0d66c4227","modified":1474613273335},{"_id":"public/page/4/index.html","hash":"e1f924cd377b46a10aee9e9ec6da354f0cd058d4","modified":1474613273335},{"_id":"public/page/5/index.html","hash":"f25d15ac883bf14d99723812c6985064b7e74bdd","modified":1474613273335},{"_id":"public/tag/Animation/index.html","hash":"a344b284a81288ef5e504aec2d6cc8e276ec87d2","modified":1474613273335},{"_id":"public/tag/UI/index.html","hash":"cc8376a7162b6c69335dedc764b94ab3e52b9b1d","modified":1474613273335},{"_id":"public/tag/Xcode/index.html","hash":"4b3ea33b333f1438f3d36b1ad293f484d3522b62","modified":1474613273335},{"_id":"public/tag/学习笔记/index.html","hash":"991ff70ec3aa9981b3c8efd16da44defcb76cf19","modified":1474613273335},{"_id":"public/tag/学习笔记/page/2/index.html","hash":"4827073ca042e0f8707740de296b2654064cefb4","modified":1474613273335},{"_id":"public/tag/基本控件/index.html","hash":"aad1e0f9e4001c2650f2ac6cd014999dab909ea7","modified":1474613273335},{"_id":"public/tag/Runtime/index.html","hash":"29d44893f5103fff64a7f46f8f310ee4ecde431d","modified":1474613273335},{"_id":"public/2016/09/23/XVim安装/index.html","hash":"528e8636f27171e7eca23bc676758667031b6c88","modified":1474613273342},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1474613273347},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1474613273347},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1474613273347},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1474613273347},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1474613273347},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1474613273347},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1474613273347},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1474613273347},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1474613273347},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1474613273347},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1474613273347},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1474613273347},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1474613273347},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1474613273348},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1474613273348},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1474613273348},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1474613273348},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1474613273348},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1474613273348},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1474613273348},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1474613273349},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1474613273349},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1474613273349},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1474613273349},{"_id":"public/css/main.css","hash":"aa607053ddf6a2706a63c2ccb478784090382959","modified":1474613274540},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1474613274541},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1474613274543},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1474613274543},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1474613274550},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1474613274550},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1474613274550},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1474613274550},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1474613274551},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1474613274551},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1474613274551},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1474613274551},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1474613274551},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1474613274551},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1474613274553},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1474613274553},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1474613274553},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1474613274553},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1474613274553},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1474613274553},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1474613274553},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1474613274553},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1474613274553},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1474613274553},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1474613274553},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1474613274553},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1474613274553},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1474613274553},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1474613274553},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1474613274555},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1474613274555},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1474613274555},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1474613274555},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1474613274555},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1474613274555},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1474613274555},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1474613274555},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1474613274555},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1474613274555},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1474613274555},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1474613274555},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1474613274561}],"Category":[{"name":"IOS","_id":"citfenzuz0003rgruhtbt7ui7"},{"name":"JavaScript","_id":"citfenzvk000krgrusg8a6l27"},{"name":"无处置放","_id":"citfenzx90022rgru0thg519q"},{"name":"python","_id":"citfenzxn002jrgruun2s47e8"},{"name":"计算机","_id":"citfenzyz0043rgruy8d8sgsi"},{"name":"Git","_id":"citfenzz3004drgruelzyopd9"}],"Data":[],"Page":[{"title":"about","date":"2016-07-29T15:19:36.000Z","type":"about","_content":"\n欢迎来到我的空间。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-07-29 23:19:36\ntype: \"about\"\n\n---\n\n欢迎来到我的空间。","updated":"2016-08-26T01:51:54.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"citfenzwo001irgrubkro82wl","content":"<p>欢迎来到我的空间。</p>\n","excerpt":"","more":"<p>欢迎来到我的空间。</p>\n"},{"title":"tags","date":"2016-07-29T10:08:03.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-29 18:08:03\ntype: \"tags\"\n\n\n---\n\n","updated":"2016-08-26T01:51:54.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"citfenzws001krgru0a0331k1","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-07-29T15:21:33.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-29 23:21:33\ntype: \"categories\"\n\n---\n","updated":"2016-08-26T01:51:54.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"citfenzwv001nrgrubob7blgw","content":"","excerpt":"","more":""}],"Post":[{"title":"CALayer学习小结","date":"2016-08-12T06:07:12.000Z","_content":"\n这两天想大致学习下animation的使用方法。看了[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)专题，写的很好，学习了很多。再摘录部分，以作备忘。\n\n<!--more-->\n\n## CALayer简介\n### 简介\nUIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\nUIView本身不具备显示的功能，拥有显示功能的是它内部的图层。\n\n### 使用\n通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。\n```objc\n//设置边框的宽度为20\nself.customView.layer.borderWidth=20;\n//设置边框的颜色(borderColor是CGColor类型)\nself.customView.layer.borderColor=[UIColor greenColor].CGColor;\n\n//设置layer的圆角\nself.customView.layer.cornerRadius=20;\n//设置超过子图层的部分裁减掉\nself.iconView.layer.masksToBounds=YES;\n\n//在view的图层上添加一个image，contents表示接受内容\nself.customView.layer.contents=(id)[UIImage imageNamed:@\"cat\"].CGImage;\n\n//设置阴影的颜色\nself.customView.layer.shadowColor=[UIColor blackColor].CGColor;\n//设置阴影的偏移量，如果为正数，则代表为往右边偏移\nself.customView.layer.shadowOffset=CGSizeMake(15, 5);\n//设置阴影的透明度(0~1之间，0表示完全透明)\nself.customView.layer.shadowOpacity=0.6;\n\n//通过uiview设置（2D效果）\nself.customView.transform=CGAffineTransformMakeTranslation(0, -100);\n//通过layer来设置（3D效果,x，y，z三个方向）\nself.iconView.layer.transform=CATransform3DMakeTranslation(100, 20, 0);\n//旋转\nself.iconView.layer.transform=CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);\n```\n\n## 创建图层\n### 基本方法\n```objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //创建一个layer\n    CALayer *Mylayer=[CALayer layer];\n    //设置layer的属性\n    Mylayer.bounds=CGRectMake(100, 100, 100, 100);\n    Mylayer.position=CGPointMake(100, 100);\n    \n    //设置需要显示的图片\n    Mylayer.contents=(id)[UIImage imageNamed:@\"me\"].CGImage;\n    //设置圆角半径为10\n    Mylayer.cornerRadius=10;\n    //如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果\n    Mylayer.masksToBounds=YES;\n    //设置边框\n    Mylayer.borderWidth=3;\n    Mylayer.borderColor=[UIColor brownColor].CGColor;\n    \n    //把layer添加到界面上\n    [self.view.layer addSublayer:Mylayer];\n}\n```\n\n### 总结\n对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。\n如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以\n\n## CAlayer属性\n### position和anchorPoint\n- position:设置CALayer在父层中的位置，这个位置要和锚点重合。\n- anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，**默认值为（0.5, 0.5）**\n\n### 隐式动画\n每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。\n\n常见的动画属性：\n- bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画\n- backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画\n- position：用于设置CALayer的位置。修改这个属性会产生平移动画\n\n## 自定义layer\n### 第一种方式：新建layer类\n想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。\n\n如果在layer上画东西，与上面的过程类似。\n```objc\n#import \"YYMylayer.h\"\n@implementation YYMylayer\n//重写该方法，在该方法内绘制图形\n-(void)drawInContext:(CGContextRef)ctx\n{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n//    [[UIColor yellowColor]set];\t不能这样设置\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n     //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类\n2. 在自定义layer中`drawInContext:`方法不会自己调用，只能自己通过`setNeedDisplay`方法调用，在view中画东西`DrawRect:`方法在view第一次显示的时候会自动调用。\n\n在view中绘图：\n```objc\n#import \"YYVIEW.h\"\n@implementation YYVIEW\n- (void)drawRect:(CGRect)rect\n{\n    //1.获取上下文\n    CGContextRef ctx=UIGraphicsGetCurrentContext();\n    //2.绘制图形\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    //3.渲染\n    CGContextFillPath(ctx);\n    //在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法\n    //[self.layer drawInContext:ctx];\n}\n```\n\n### 第二种方式：实现delegate方法\n设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n```objc\n@implementation YYViewController\n- (void)viewDidLoad{\n    [super viewDidLoad];\n    //1.创建自定义的layer\n    CALayer *layer=[CALayer layer];\n    //2.设置layer的属性\n\t...\n    //设置代理\n    layer.delegate=self;\n    [layer setNeedsDisplay];\n    //3.添加layer\n    [self.view.layer addSublayer:layer];\n}\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);   \n    //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。\n2. 不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。\n\n### 补充\n1. 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n2. **当UIView需要显示时**，它内部的层会准备好一个CGContextRef(图形上下文)，然后**调用delegate(这里就是UIView)**的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。\n\n>Demo 详见 CALayer-transform\n","source":"_posts/CALayer学习小结.md","raw":"title: CALayer学习小结\ndate: 2016/8/12 14:07:12  \ncategories: IOS\ntags: \n\t- Animation\n\t- UI\n\t\n---\n\n这两天想大致学习下animation的使用方法。看了[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)专题，写的很好，学习了很多。再摘录部分，以作备忘。\n\n<!--more-->\n\n## CALayer简介\n### 简介\nUIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\nUIView本身不具备显示的功能，拥有显示功能的是它内部的图层。\n\n### 使用\n通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。\n```objc\n//设置边框的宽度为20\nself.customView.layer.borderWidth=20;\n//设置边框的颜色(borderColor是CGColor类型)\nself.customView.layer.borderColor=[UIColor greenColor].CGColor;\n\n//设置layer的圆角\nself.customView.layer.cornerRadius=20;\n//设置超过子图层的部分裁减掉\nself.iconView.layer.masksToBounds=YES;\n\n//在view的图层上添加一个image，contents表示接受内容\nself.customView.layer.contents=(id)[UIImage imageNamed:@\"cat\"].CGImage;\n\n//设置阴影的颜色\nself.customView.layer.shadowColor=[UIColor blackColor].CGColor;\n//设置阴影的偏移量，如果为正数，则代表为往右边偏移\nself.customView.layer.shadowOffset=CGSizeMake(15, 5);\n//设置阴影的透明度(0~1之间，0表示完全透明)\nself.customView.layer.shadowOpacity=0.6;\n\n//通过uiview设置（2D效果）\nself.customView.transform=CGAffineTransformMakeTranslation(0, -100);\n//通过layer来设置（3D效果,x，y，z三个方向）\nself.iconView.layer.transform=CATransform3DMakeTranslation(100, 20, 0);\n//旋转\nself.iconView.layer.transform=CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);\n```\n\n## 创建图层\n### 基本方法\n```objc\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    //创建一个layer\n    CALayer *Mylayer=[CALayer layer];\n    //设置layer的属性\n    Mylayer.bounds=CGRectMake(100, 100, 100, 100);\n    Mylayer.position=CGPointMake(100, 100);\n    \n    //设置需要显示的图片\n    Mylayer.contents=(id)[UIImage imageNamed:@\"me\"].CGImage;\n    //设置圆角半径为10\n    Mylayer.cornerRadius=10;\n    //如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果\n    Mylayer.masksToBounds=YES;\n    //设置边框\n    Mylayer.borderWidth=3;\n    Mylayer.borderColor=[UIColor brownColor].CGColor;\n    \n    //把layer添加到界面上\n    [self.view.layer addSublayer:Mylayer];\n}\n```\n\n### 总结\n对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。\n如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以\n\n## CAlayer属性\n### position和anchorPoint\n- position:设置CALayer在父层中的位置，这个位置要和锚点重合。\n- anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，**默认值为（0.5, 0.5）**\n\n### 隐式动画\n每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。\n\n常见的动画属性：\n- bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画\n- backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画\n- position：用于设置CALayer的位置。修改这个属性会产生平移动画\n\n## 自定义layer\n### 第一种方式：新建layer类\n想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。\n\n如果在layer上画东西，与上面的过程类似。\n```objc\n#import \"YYMylayer.h\"\n@implementation YYMylayer\n//重写该方法，在该方法内绘制图形\n-(void)drawInContext:(CGContextRef)ctx\n{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n//    [[UIColor yellowColor]set];\t不能这样设置\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n     //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类\n2. 在自定义layer中`drawInContext:`方法不会自己调用，只能自己通过`setNeedDisplay`方法调用，在view中画东西`DrawRect:`方法在view第一次显示的时候会自动调用。\n\n在view中绘图：\n```objc\n#import \"YYVIEW.h\"\n@implementation YYVIEW\n- (void)drawRect:(CGRect)rect\n{\n    //1.获取上下文\n    CGContextRef ctx=UIGraphicsGetCurrentContext();\n    //2.绘制图形\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    //3.渲染\n    CGContextFillPath(ctx);\n    //在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法\n    //[self.layer drawInContext:ctx];\n}\n```\n\n### 第二种方式：实现delegate方法\n设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n```objc\n@implementation YYViewController\n- (void)viewDidLoad{\n    [super viewDidLoad];\n    //1.创建自定义的layer\n    CALayer *layer=[CALayer layer];\n    //2.设置layer的属性\n\t...\n    //设置代理\n    layer.delegate=self;\n    [layer setNeedsDisplay];\n    //3.添加layer\n    [self.view.layer addSublayer:layer];\n}\n-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{\n    //1.绘制图形\n    //画一个圆\n    CGContextAddEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));\n    //设置属性（颜色）\n    //    [[UIColor yellowColor]set];\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);   \n    //2.渲染\n    CGContextFillPath(ctx);\n}\n@end\n```\n注意：\n1. 在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。\n2. 不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。\n\n### 补充\n1. 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n2. **当UIView需要显示时**，它内部的层会准备好一个CGContextRef(图形上下文)，然后**调用delegate(这里就是UIView)**的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。\n\n>Demo 详见 CALayer-transform\n","slug":"CALayer学习小结","published":1,"updated":"2016-09-23T05:44:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzum0000rgru250mhege","content":"<p>这两天想大致学习下animation的使用方法。看了<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\" target=\"_blank\" rel=\"external\">文顶顶的ios开发UI篇</a>专题，写的很好，学习了很多。再摘录部分，以作备忘。</p>\n<a id=\"more\"></a>\n<h2 id=\"CALayer简介\"><a href=\"#CALayer简介\" class=\"headerlink\" title=\"CALayer简介\"></a>CALayer简介</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。<br>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。<br>UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置边框的宽度为20</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderWidth=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置边框的颜色(borderColor是CGColor类型)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderColor=[<span class=\"built_in\">UIColor</span> greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置layer的圆角</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置超过子图层的部分裁减掉</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在view的图层上添加一个image，contents表示接受内容</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"cat\"</span>].CGImage;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置阴影的颜色</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowColor=[<span class=\"built_in\">UIColor</span> blackColor].CGColor;</div><div class=\"line\"><span class=\"comment\">//设置阴影的偏移量，如果为正数，则代表为往右边偏移</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOffset=<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">15</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//设置阴影的透明度(0~1之间，0表示完全透明)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOpacity=<span class=\"number\">0.6</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过uiview设置（2D效果）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.transform=<span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-100</span>);</div><div class=\"line\"><span class=\"comment\">//通过layer来设置（3D效果,x，y，z三个方向）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">100</span>, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">//旋转</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeRotation</span>(M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"创建图层\"><a href=\"#创建图层\" class=\"headerlink\" title=\"创建图层\"></a>创建图层</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//创建一个layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *Mylayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    Mylayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    Mylayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置需要显示的图片</span></div><div class=\"line\">    Mylayer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"me\"</span>].CGImage;</div><div class=\"line\">    <span class=\"comment\">//设置圆角半径为10</span></div><div class=\"line\">    Mylayer.cornerRadius=<span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"comment\">//如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果</span></div><div class=\"line\">    Mylayer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"comment\">//设置边框</span></div><div class=\"line\">    Mylayer.borderWidth=<span class=\"number\">3</span>;</div><div class=\"line\">    Mylayer.borderColor=[<span class=\"built_in\">UIColor</span> brownColor].CGColor;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//把layer添加到界面上</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:Mylayer];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。<br>如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>\n<h2 id=\"CAlayer属性\"><a href=\"#CAlayer属性\" class=\"headerlink\" title=\"CAlayer属性\"></a>CAlayer属性</h2><h3 id=\"position和anchorPoint\"><a href=\"#position和anchorPoint\" class=\"headerlink\" title=\"position和anchorPoint\"></a>position和anchorPoint</h3><ul>\n<li>position:设置CALayer在父层中的位置，这个位置要和锚点重合。</li>\n<li>anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，<strong>默认值为（0.5, 0.5）</strong></li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。</p>\n<p>常见的动画属性：</p>\n<ul>\n<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>\n<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>\n<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>\n</ul>\n<h2 id=\"自定义layer\"><a href=\"#自定义layer\" class=\"headerlink\" title=\"自定义layer\"></a>自定义layer</h2><h3 id=\"第一种方式：新建layer类\"><a href=\"#第一种方式：新建layer类\" class=\"headerlink\" title=\"第一种方式：新建layer类\"></a>第一种方式：新建layer类</h3><p>想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。</p>\n<p>如果在layer上画东西，与上面的过程类似。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYMylayer.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMylayer</span></span></div><div class=\"line\"><span class=\"comment\">//重写该方法，在该方法内绘制图形</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawInContext:(<span class=\"built_in\">CGContextRef</span>)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\"><span class=\"comment\">//    [[UIColor yellowColor]set];\t不能这样设置</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">     <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类</li>\n<li>在自定义layer中<code>drawInContext:</code>方法不会自己调用，只能自己通过<code>setNeedDisplay</code>方法调用，在view中画东西<code>DrawRect:</code>方法在view第一次显示的时候会自动调用。</li>\n</ol>\n<p>在view中绘图：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYVIEW.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYVIEW</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.获取上下文</span></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> ctx=<span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\">    <span class=\"comment\">//2.绘制图形</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//3.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">//在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法</span></div><div class=\"line\">    <span class=\"comment\">//[self.layer drawInContext:ctx];</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：实现delegate方法\"><a href=\"#第二种方式：实现delegate方法\" class=\"headerlink\" title=\"第二种方式：实现delegate方法\"></a>第二种方式：实现delegate方法</h3><p>设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//1.创建自定义的layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//2.设置layer的属性</span></div><div class=\"line\">\t...</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    layer.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    [layer setNeedsDisplay];</div><div class=\"line\">    <span class=\"comment\">//3.添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);   </div><div class=\"line\">    <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。</li>\n<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。</li>\n</ol>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n<li><strong>当UIView需要显示时</strong>，它内部的层会准备好一个CGContextRef(图形上下文)，然后<strong>调用delegate(这里就是UIView)</strong>的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。</li>\n</ol>\n<blockquote>\n<p>Demo 详见 CALayer-transform</p>\n</blockquote>\n","excerpt":"<p>这两天想大致学习下animation的使用方法。看了<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\">文顶顶的ios开发UI篇</a>专题，写的很好，学习了很多。再摘录部分，以作备忘。</p>","more":"<h2 id=\"CALayer简介\"><a href=\"#CALayer简介\" class=\"headerlink\" title=\"CALayer简介\"></a>CALayer简介</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。<br>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。<br>UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置边框的宽度为20</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderWidth=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置边框的颜色(borderColor是CGColor类型)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.borderColor=[<span class=\"built_in\">UIColor</span> greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置layer的圆角</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">//设置超过子图层的部分裁减掉</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在view的图层上添加一个image，contents表示接受内容</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"cat\"</span>].CGImage;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//设置阴影的颜色</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowColor=[<span class=\"built_in\">UIColor</span> blackColor].CGColor;</div><div class=\"line\"><span class=\"comment\">//设置阴影的偏移量，如果为正数，则代表为往右边偏移</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOffset=<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">15</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//设置阴影的透明度(0~1之间，0表示完全透明)</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.layer.shadowOpacity=<span class=\"number\">0.6</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过uiview设置（2D效果）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.customView.transform=<span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"number\">0</span>, <span class=\"number\">-100</span>);</div><div class=\"line\"><span class=\"comment\">//通过layer来设置（3D效果,x，y，z三个方向）</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeTranslation</span>(<span class=\"number\">100</span>, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"comment\">//旋转</span></div><div class=\"line\"><span class=\"keyword\">self</span>.iconView.layer.transform=<span class=\"built_in\">CATransform3DMakeRotation</span>(M_PI_4, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0.5</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"创建图层\"><a href=\"#创建图层\" class=\"headerlink\" title=\"创建图层\"></a>创建图层</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//创建一个layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *Mylayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    Mylayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    Mylayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置需要显示的图片</span></div><div class=\"line\">    Mylayer.contents=(<span class=\"keyword\">id</span>)[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"me\"</span>].CGImage;</div><div class=\"line\">    <span class=\"comment\">//设置圆角半径为10</span></div><div class=\"line\">    Mylayer.cornerRadius=<span class=\"number\">10</span>;</div><div class=\"line\">    <span class=\"comment\">//如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果</span></div><div class=\"line\">    Mylayer.masksToBounds=<span class=\"literal\">YES</span>;</div><div class=\"line\">    <span class=\"comment\">//设置边框</span></div><div class=\"line\">    Mylayer.borderWidth=<span class=\"number\">3</span>;</div><div class=\"line\">    Mylayer.borderColor=[<span class=\"built_in\">UIColor</span> brownColor].CGColor;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//把layer添加到界面上</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:Mylayer];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。<br>如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>\n<h2 id=\"CAlayer属性\"><a href=\"#CAlayer属性\" class=\"headerlink\" title=\"CAlayer属性\"></a>CAlayer属性</h2><h3 id=\"position和anchorPoint\"><a href=\"#position和anchorPoint\" class=\"headerlink\" title=\"position和anchorPoint\"></a>position和anchorPoint</h3><ul>\n<li>position:设置CALayer在父层中的位置，这个位置要和锚点重合。</li>\n<li>anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，<strong>默认值为（0.5, 0.5）</strong></li>\n</ul>\n<h3 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h3><p>每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。</p>\n<p>常见的动画属性：</p>\n<ul>\n<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>\n<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>\n<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>\n</ul>\n<h2 id=\"自定义layer\"><a href=\"#自定义layer\" class=\"headerlink\" title=\"自定义layer\"></a>自定义layer</h2><h3 id=\"第一种方式：新建layer类\"><a href=\"#第一种方式：新建layer类\" class=\"headerlink\" title=\"第一种方式：新建layer类\"></a>第一种方式：新建layer类</h3><p>想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。</p>\n<p>如果在layer上画东西，与上面的过程类似。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYMylayer.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYMylayer</span></span></div><div class=\"line\"><span class=\"comment\">//重写该方法，在该方法内绘制图形</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawInContext:(<span class=\"built_in\">CGContextRef</span>)ctx</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\"><span class=\"comment\">//    [[UIColor yellowColor]set];\t不能这样设置</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">     <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类</li>\n<li>在自定义layer中<code>drawInContext:</code>方法不会自己调用，只能自己通过<code>setNeedDisplay</code>方法调用，在view中画东西<code>DrawRect:</code>方法在view第一次显示的时候会自动调用。</li>\n</ol>\n<p>在view中绘图：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYVIEW.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYVIEW</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)drawRect:(<span class=\"built_in\">CGRect</span>)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.获取上下文</span></div><div class=\"line\">    <span class=\"built_in\">CGContextRef</span> ctx=<span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</div><div class=\"line\">    <span class=\"comment\">//2.绘制图形</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"comment\">//3.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">    <span class=\"comment\">//在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法</span></div><div class=\"line\">    <span class=\"comment\">//[self.layer drawInContext:ctx];</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"第二种方式：实现delegate方法\"><a href=\"#第二种方式：实现delegate方法\" class=\"headerlink\" title=\"第二种方式：实现delegate方法\"></a>第二种方式：实现delegate方法</h3><p>设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">//1.创建自定义的layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *layer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//2.设置layer的属性</span></div><div class=\"line\">\t...</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    layer.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    [layer setNeedsDisplay];</div><div class=\"line\">    <span class=\"comment\">//3.添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)drawLayer:(<span class=\"built_in\">CALayer</span> *)layer inContext:(<span class=\"built_in\">CGContextRef</span>)ctx&#123;</div><div class=\"line\">    <span class=\"comment\">//1.绘制图形</span></div><div class=\"line\">    <span class=\"comment\">//画一个圆</span></div><div class=\"line\">    <span class=\"built_in\">CGContextAddEllipseInRect</span>(ctx, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    <span class=\"comment\">//设置属性（颜色）</span></div><div class=\"line\">    <span class=\"comment\">//    [[UIColor yellowColor]set];</span></div><div class=\"line\">    <span class=\"built_in\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);   </div><div class=\"line\">    <span class=\"comment\">//2.渲染</span></div><div class=\"line\">    <span class=\"built_in\">CGContextFillPath</span>(ctx);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。</li>\n<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。</li>\n</ol>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n<li><strong>当UIView需要显示时</strong>，它内部的层会准备好一个CGContextRef(图形上下文)，然后<strong>调用delegate(这里就是UIView)</strong>的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。</li>\n</ol>\n<blockquote>\n<p>Demo 详见 CALayer-transform</p>\n</blockquote>"},{"title":"CALayer的transform","date":"2016-09-02T06:07:12.000Z","_content":"\n在[CollectionView的使用](https://zhang759740844.github.io/2016/08/05/UICollectionView/)中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。\n\n\n<!--more-->\n\n## UIView的transform属性\ntransform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是`CGAffineTransform`类型的。\n\n### transform结构\ntransform是一个`CGAffineTransform`类型，结构如下：\n```objc\nstruct CGAffineTransform {\n  CGFloat a, b, c, d;\n  CGFloat tx, ty;\n};\n```\n\nCGAffineTransform实际上是一个矩阵\n```objc\n| a,  b,  0 |\n| c,  d,  0 |\n| tx, ty, 1 |\n```\n由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。\n\n坐标变换过程：\n```objc\n                    | a,  b,  0 |\n{x',y',1}={x,y,1} x | c,  d,  0 |\n                    | tx, ty, 1 |\n                    \n==>\n\nxn=ax+cy+tx;\nyn=bx+dy+ty;\n\n```\n\n这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。\n\n### transform方法\n在`CGAffineTransform`的生成函数中，大多是两两对应的，一个带\nmake字样，一个不带。带make字样的是直接生成一个新的`CGAffineTransform`，不带make字样的则是在一个`CGAffineTransform`的基础上生成新的。函数返回值均是`CGAffineTransform`类型。\n\n多个`CGAffineTransform`对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。\n\n\n#### scale\n实现的是放大和缩小:\n```objc\nCGAffineTransformScale(CGAffineTransform t,\n  CGFloat sx, CGFloat sy)；\nCGAffineTransformMakeScale(CGFloat sx, CGFloat sy)；\n```\n生成新的transform相当于将`t' = [sx ，0 ，0，sy ，0， 0]`这六个参数代入矩阵中,即改变a和d。\n\n#### rotate\n实现的是旋转：\n```objc\nCGAffineTransformRotate(CGAffineTransform t,\n  CGFloat angle)\nCGAffineTransformMakeRotation(CGFloat angle)；\n```\nangle为角度，angle=π则旋转180度。矩阵的六个参数为`t' =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；`\n\n#### translate\n实现的是平移：\n```objc\nCGAffineTransformTranslate(CGAffineTransform t,\n  CGFloat tx, CGFloat ty)；\nCGAffineTransformMakeTranslation(CGFloat tx,\n  CGFloat ty)；\n```\n矩阵的六个参数为`t' = [1，0，0，1，tx，ty] ；`代入公式，`xn=x+tx,yn=y+ty`\n\n#### 复原\n```objc\nview.transform＝CGAffineTransformIdentity;\n```\n上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。`CGAffineTransformIdentity`将view从当前状态复原回view最初始的状态。\n\n## CALayer的transform属性\n### transform结构\nCALayer的transform是一个`CATransform3D`结构：\n```objc\nstruct CATransform3D\n{\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n};\n```\n有别于`CGAffineTransform`,`CATransform3D`是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。\n\n### transform方法\nCALayer的transform方法和View的transform基本一致。举几点不同：\n\n- CALayer由于有z轴，因此对不同图层使用`CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)`方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。\n\n- 由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变`m34`(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。`m34`的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。\n\n- 如果想要直接改变矩阵里的值，可以先使用`CATransform3DIdentity`的方式，初始化一个`CATransform3D`实例，然后再赋值。\n\n\n\n","source":"_posts/CALayer的transform属性.md","raw":"title: CALayer的transform\ndate: 2016/9/2 14:07:12  \ncategories: IOS\ntags: \n\t- Animation\n\t- UI\n\n---\n\n在[CollectionView的使用](https://zhang759740844.github.io/2016/08/05/UICollectionView/)中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。\n\n\n<!--more-->\n\n## UIView的transform属性\ntransform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是`CGAffineTransform`类型的。\n\n### transform结构\ntransform是一个`CGAffineTransform`类型，结构如下：\n```objc\nstruct CGAffineTransform {\n  CGFloat a, b, c, d;\n  CGFloat tx, ty;\n};\n```\n\nCGAffineTransform实际上是一个矩阵\n```objc\n| a,  b,  0 |\n| c,  d,  0 |\n| tx, ty, 1 |\n```\n由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。\n\n坐标变换过程：\n```objc\n                    | a,  b,  0 |\n{x',y',1}={x,y,1} x | c,  d,  0 |\n                    | tx, ty, 1 |\n                    \n==>\n\nxn=ax+cy+tx;\nyn=bx+dy+ty;\n\n```\n\n这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。\n\n### transform方法\n在`CGAffineTransform`的生成函数中，大多是两两对应的，一个带\nmake字样，一个不带。带make字样的是直接生成一个新的`CGAffineTransform`，不带make字样的则是在一个`CGAffineTransform`的基础上生成新的。函数返回值均是`CGAffineTransform`类型。\n\n多个`CGAffineTransform`对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。\n\n\n#### scale\n实现的是放大和缩小:\n```objc\nCGAffineTransformScale(CGAffineTransform t,\n  CGFloat sx, CGFloat sy)；\nCGAffineTransformMakeScale(CGFloat sx, CGFloat sy)；\n```\n生成新的transform相当于将`t' = [sx ，0 ，0，sy ，0， 0]`这六个参数代入矩阵中,即改变a和d。\n\n#### rotate\n实现的是旋转：\n```objc\nCGAffineTransformRotate(CGAffineTransform t,\n  CGFloat angle)\nCGAffineTransformMakeRotation(CGFloat angle)；\n```\nangle为角度，angle=π则旋转180度。矩阵的六个参数为`t' =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；`\n\n#### translate\n实现的是平移：\n```objc\nCGAffineTransformTranslate(CGAffineTransform t,\n  CGFloat tx, CGFloat ty)；\nCGAffineTransformMakeTranslation(CGFloat tx,\n  CGFloat ty)；\n```\n矩阵的六个参数为`t' = [1，0，0，1，tx，ty] ；`代入公式，`xn=x+tx,yn=y+ty`\n\n#### 复原\n```objc\nview.transform＝CGAffineTransformIdentity;\n```\n上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。`CGAffineTransformIdentity`将view从当前状态复原回view最初始的状态。\n\n## CALayer的transform属性\n### transform结构\nCALayer的transform是一个`CATransform3D`结构：\n```objc\nstruct CATransform3D\n{\n  CGFloat m11, m12, m13, m14;\n  CGFloat m21, m22, m23, m24;\n  CGFloat m31, m32, m33, m34;\n  CGFloat m41, m42, m43, m44;\n};\n```\n有别于`CGAffineTransform`,`CATransform3D`是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。\n\n### transform方法\nCALayer的transform方法和View的transform基本一致。举几点不同：\n\n- CALayer由于有z轴，因此对不同图层使用`CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)`方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。\n\n- 由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变`m34`(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。`m34`的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。\n\n- 如果想要直接改变矩阵里的值，可以先使用`CATransform3DIdentity`的方式，初始化一个`CATransform3D`实例，然后再赋值。\n\n\n\n","slug":"CALayer的transform属性","published":1,"updated":"2016-09-23T05:46:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzur0001rgru51dm7z39","content":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/05/UICollectionView/\">CollectionView的使用</a>中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。</p>\n<a id=\"more\"></a>\n<h2 id=\"UIView的transform属性\"><a href=\"#UIView的transform属性\" class=\"headerlink\" title=\"UIView的transform属性\"></a>UIView的transform属性</h2><p>transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是<code>CGAffineTransform</code>类型的。</p>\n<h3 id=\"transform结构\"><a href=\"#transform结构\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>transform是一个<code>CGAffineTransform</code>类型，结构如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CGAffineTransform</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> a, b, c, d;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, ty;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>CGAffineTransform实际上是一个矩阵<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">| a,  b,  <span class=\"number\">0</span> |</div><div class=\"line\">| c,  d,  <span class=\"number\">0</span> |</div><div class=\"line\">| tx, ty, <span class=\"number\">1</span> |</div></pre></td></tr></table></figure></p>\n<p>由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。</p>\n<p>坐标变换过程：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">                    | a,  b,  0 |</div><div class=\"line\">&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c,  d,  0 |</div><div class=\"line\">                    | tx, ty, 1 |</div><div class=\"line\">                    </div><div class=\"line\">==&gt;</div><div class=\"line\"></div><div class=\"line\">xn=ax+cy+tx;</div><div class=\"line\">yn=bx+dy+ty;</div></pre></td></tr></table></figure></p>\n<p>这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。</p>\n<h3 id=\"transform方法\"><a href=\"#transform方法\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>在<code>CGAffineTransform</code>的生成函数中，大多是两两对应的，一个带<br>make字样，一个不带。带make字样的是直接生成一个新的<code>CGAffineTransform</code>，不带make字样的则是在一个<code>CGAffineTransform</code>的基础上生成新的。函数返回值均是<code>CGAffineTransform</code>类型。</p>\n<p>多个<code>CGAffineTransform</code>对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。</p>\n<h4 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h4><p>实现的是放大和缩小:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div></pre></td></tr></table></figure></p>\n<p>生成新的transform相当于将<code>t&#39; = [sx ，0 ，0，sy ，0， 0]</code>这六个参数代入矩阵中,即改变a和d。</p>\n<h4 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h4><p>实现的是旋转：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> angle)</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"built_in\">CGFloat</span> angle)；</div></pre></td></tr></table></figure></p>\n<p>angle为角度，angle=π则旋转180度。矩阵的六个参数为<code>t&#39; =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；</code></p>\n<h4 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a>translate</h4><p>实现的是平移：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, <span class=\"built_in\">CGFloat</span> ty)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"built_in\">CGFloat</span> tx,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> ty)；</div></pre></td></tr></table></figure></p>\n<p>矩阵的六个参数为<code>t&#39; = [1，0，0，1，tx，ty] ；</code>代入公式，<code>xn=x+tx,yn=y+ty</code></p>\n<h4 id=\"复原\"><a href=\"#复原\" class=\"headerlink\" title=\"复原\"></a>复原</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.transform＝<span class=\"built_in\">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure>\n<p>上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。<code>CGAffineTransformIdentity</code>将view从当前状态复原回view最初始的状态。</p>\n<h2 id=\"CALayer的transform属性\"><a href=\"#CALayer的transform属性\" class=\"headerlink\" title=\"CALayer的transform属性\"></a>CALayer的transform属性</h2><h3 id=\"transform结构-1\"><a href=\"#transform结构-1\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>CALayer的transform是一个<code>CATransform3D</code>结构：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m11, m12, m13, m14;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m21, m22, m23, m24;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m31, m32, m33, m34;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m41, m42, m43, m44;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>有别于<code>CGAffineTransform</code>,<code>CATransform3D</code>是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。</p>\n<h3 id=\"transform方法-1\"><a href=\"#transform方法-1\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>CALayer的transform方法和View的transform基本一致。举几点不同：</p>\n<ul>\n<li><p>CALayer由于有z轴，因此对不同图层使用<code>CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</code>方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。</p>\n</li>\n<li><p>由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变<code>m34</code>(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。<code>m34</code>的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。</p>\n</li>\n<li><p>如果想要直接改变矩阵里的值，可以先使用<code>CATransform3DIdentity</code>的方式，初始化一个<code>CATransform3D</code>实例，然后再赋值。</p>\n</li>\n</ul>\n","excerpt":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/05/UICollectionView/\">CollectionView的使用</a>中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。</p>","more":"<h2 id=\"UIView的transform属性\"><a href=\"#UIView的transform属性\" class=\"headerlink\" title=\"UIView的transform属性\"></a>UIView的transform属性</h2><p>transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是<code>CGAffineTransform</code>类型的。</p>\n<h3 id=\"transform结构\"><a href=\"#transform结构\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>transform是一个<code>CGAffineTransform</code>类型，结构如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CGAffineTransform</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> a, b, c, d;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, ty;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>CGAffineTransform实际上是一个矩阵<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">| a,  b,  <span class=\"number\">0</span> |</div><div class=\"line\">| c,  d,  <span class=\"number\">0</span> |</div><div class=\"line\">| tx, ty, <span class=\"number\">1</span> |</div></pre></td></tr></table></figure></p>\n<p>由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。</p>\n<p>坐标变换过程：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">                    | a,  b,  0 |</div><div class=\"line\">&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c,  d,  0 |</div><div class=\"line\">                    | tx, ty, 1 |</div><div class=\"line\">                    </div><div class=\"line\">==&gt;</div><div class=\"line\"></div><div class=\"line\">xn=ax+cy+tx;</div><div class=\"line\">yn=bx+dy+ty;</div></pre></td></tr></table></figure></p>\n<p>这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。</p>\n<h3 id=\"transform方法\"><a href=\"#transform方法\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>在<code>CGAffineTransform</code>的生成函数中，大多是两两对应的，一个带<br>make字样，一个不带。带make字样的是直接生成一个新的<code>CGAffineTransform</code>，不带make字样的则是在一个<code>CGAffineTransform</code>的基础上生成新的。函数返回值均是<code>CGAffineTransform</code>类型。</p>\n<p>多个<code>CGAffineTransform</code>对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。</p>\n<h4 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h4><p>实现的是放大和缩小:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformScale</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"built_in\">CGFloat</span> sx, <span class=\"built_in\">CGFloat</span> sy)；</div></pre></td></tr></table></figure></p>\n<p>生成新的transform相当于将<code>t&#39; = [sx ，0 ，0，sy ，0， 0]</code>这六个参数代入矩阵中,即改变a和d。</p>\n<h4 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h4><p>实现的是旋转：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformRotate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> angle)</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"built_in\">CGFloat</span> angle)；</div></pre></td></tr></table></figure></p>\n<p>angle为角度，angle=π则旋转180度。矩阵的六个参数为<code>t&#39; =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；</code></p>\n<h4 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a>translate</h4><p>实现的是平移：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"built_in\">CGAffineTransform</span> t,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> tx, <span class=\"built_in\">CGFloat</span> ty)；</div><div class=\"line\"><span class=\"built_in\">CGAffineTransformMakeTranslation</span>(<span class=\"built_in\">CGFloat</span> tx,</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> ty)；</div></pre></td></tr></table></figure></p>\n<p>矩阵的六个参数为<code>t&#39; = [1，0，0，1，tx，ty] ；</code>代入公式，<code>xn=x+tx,yn=y+ty</code></p>\n<h4 id=\"复原\"><a href=\"#复原\" class=\"headerlink\" title=\"复原\"></a>复原</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.transform＝<span class=\"built_in\">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure>\n<p>上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。<code>CGAffineTransformIdentity</code>将view从当前状态复原回view最初始的状态。</p>\n<h2 id=\"CALayer的transform属性\"><a href=\"#CALayer的transform属性\" class=\"headerlink\" title=\"CALayer的transform属性\"></a>CALayer的transform属性</h2><h3 id=\"transform结构-1\"><a href=\"#transform结构-1\" class=\"headerlink\" title=\"transform结构\"></a>transform结构</h3><p>CALayer的transform是一个<code>CATransform3D</code>结构：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> <span class=\"built_in\">CATransform3D</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m11, m12, m13, m14;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m21, m22, m23, m24;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m31, m32, m33, m34;</div><div class=\"line\">  <span class=\"built_in\">CGFloat</span> m41, m42, m43, m44;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>有别于<code>CGAffineTransform</code>,<code>CATransform3D</code>是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。</p>\n<h3 id=\"transform方法-1\"><a href=\"#transform方法-1\" class=\"headerlink\" title=\"transform方法\"></a>transform方法</h3><p>CALayer的transform方法和View的transform基本一致。举几点不同：</p>\n<ul>\n<li><p>CALayer由于有z轴，因此对不同图层使用<code>CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</code>方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。</p>\n</li>\n<li><p>由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变<code>m34</code>(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。<code>m34</code>的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。</p>\n</li>\n<li><p>如果想要直接改变矩阵里的值，可以先使用<code>CATransform3DIdentity</code>的方式，初始化一个<code>CATransform3D</code>实例，然后再赋值。</p>\n</li>\n</ul>"},{"title":"Block 的使用","date":"2016-09-01T02:07:12.000Z","_content":"\n类似于匿名函数，oc中提供`block`,可以将一段代码块像对象一样作为参数传递、执行。\n\n<!--more-->\n\n## Block的使用\n### Block实例\n```objc\n^(double dividend){\n\tdouble quotient = dividend / divisor;\n\treturn quotient;\n}\n```\nBlock对象可以被当做一个实参来传递给可以接收block的方法。\n\n### 声明block变量:\n```objc \nvoid (^devowelizer)(id, NSUInteger, BOOL*);\n```\n`void` 表示返回类型  \n`^` 表示是一个block对象  \n`devowelizer` 表示block变量的名称  \n后面的是实参类型  \n方法的调用参数类型为`^(id  string, NSUInteger i, BOOL *stop)block`\n\n### 编写Block对象\n```objc\ndevowelizer = ^(id string,NSUInteger i, BOOL *stop){\n\t……\n};\n```\n\n### 调用block变量\n```objc\ndevowelizer(string,i,stop);\n```\n### typedef\n不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。\n```objc\ntypedef void(^ArrayEnumerationBlock)(id,NSUInteger,BOOL *);\n```\n需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。\n```objc\nArrayEnumerationBlock devowelizer；\n```\n\n### 外部变量\n在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。\n\n**当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。**\n\n### 修改外部变量\n如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。\n\n**__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。**\n\n### 在Block中使用self\n如果要写一个使用self的Block对象，需要避免强引用循环。  \n在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。\n```objc\n_weak BNREmployee *weakSelf = self;\t//弱引用指针\n\tmyBlock = ^{\n\t\tNSLog(@“Employee:%@”,weakSelf);\n\t};\n```\n\n\n## block的实现\nblock的实现主要参考[唐巧谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#)\n\n### block的结构\nblock的结构如下:\n```objc\nstruct Block_descriptor {\n    unsigned long int reserved;\n    unsigned long int size;\n    void (*copy)(void *dst, void *src);\n    void (*dispose)(void *);\n};\n\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\n\n结构图如下：\n![block结构图](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true)\n\n通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：\n1. `isa` 指针，所有对象都有该指针，用于实现对象相关的功能。\n2. `flags`，用于按 bit 位表示一些 block 的附加信息。\n3. `reserved`，保留变量。\n4. `invoke`，函数指针，指向具体的 block 实现的函数调用地址。\n5. `descriptor`， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。\n6. 各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。\n\n### block种类\nblock的isa是以下三个的一种：\n1. `_NSConcreteGlobalBlock` 全局的静态 block，不会访问任何外部变量。\n2. `_NSConcreteStackBlock` 保存在栈中的 block，当函数返回时会被销毁。\n3. `_NSConcreteMallocBlock` 保存在堆中的 block，当引用计数为 0 时会被销毁。\n\n在 ARC 开启的情况下，将只会有 `NSConcreteGlobalBlock` 和 `NSConcreteMallocBlock`类型的 block。原本的 `NSConcreteStackBlock` 的 block 会被 `NSConcreteMallocBlock` 类型的 block 替代。\n\n### 研究工具：clang\nclang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是\n```objc\nclang -rewrite-objc xxxx\n```\n","source":"_posts/Block基础.md","raw":"title: Block 的使用\ndate: 2016/9/1 10:07:12  \ncategories: IOS\ntags:\n\t- Block\n\n---\n\n类似于匿名函数，oc中提供`block`,可以将一段代码块像对象一样作为参数传递、执行。\n\n<!--more-->\n\n## Block的使用\n### Block实例\n```objc\n^(double dividend){\n\tdouble quotient = dividend / divisor;\n\treturn quotient;\n}\n```\nBlock对象可以被当做一个实参来传递给可以接收block的方法。\n\n### 声明block变量:\n```objc \nvoid (^devowelizer)(id, NSUInteger, BOOL*);\n```\n`void` 表示返回类型  \n`^` 表示是一个block对象  \n`devowelizer` 表示block变量的名称  \n后面的是实参类型  \n方法的调用参数类型为`^(id  string, NSUInteger i, BOOL *stop)block`\n\n### 编写Block对象\n```objc\ndevowelizer = ^(id string,NSUInteger i, BOOL *stop){\n\t……\n};\n```\n\n### 调用block变量\n```objc\ndevowelizer(string,i,stop);\n```\n### typedef\n不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。\n```objc\ntypedef void(^ArrayEnumerationBlock)(id,NSUInteger,BOOL *);\n```\n需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。\n```objc\nArrayEnumerationBlock devowelizer；\n```\n\n### 外部变量\n在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。\n\n**当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。**\n\n### 修改外部变量\n如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。\n\n**__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。**\n\n### 在Block中使用self\n如果要写一个使用self的Block对象，需要避免强引用循环。  \n在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。\n```objc\n_weak BNREmployee *weakSelf = self;\t//弱引用指针\n\tmyBlock = ^{\n\t\tNSLog(@“Employee:%@”,weakSelf);\n\t};\n```\n\n\n## block的实现\nblock的实现主要参考[唐巧谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#)\n\n### block的结构\nblock的结构如下:\n```objc\nstruct Block_descriptor {\n    unsigned long int reserved;\n    unsigned long int size;\n    void (*copy)(void *dst, void *src);\n    void (*dispose)(void *);\n};\n\nstruct Block_layout {\n    void *isa;\n    int flags;\n    int reserved;\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n```\n\n结构图如下：\n![block结构图](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true)\n\n通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：\n1. `isa` 指针，所有对象都有该指针，用于实现对象相关的功能。\n2. `flags`，用于按 bit 位表示一些 block 的附加信息。\n3. `reserved`，保留变量。\n4. `invoke`，函数指针，指向具体的 block 实现的函数调用地址。\n5. `descriptor`， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。\n6. 各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。\n\n### block种类\nblock的isa是以下三个的一种：\n1. `_NSConcreteGlobalBlock` 全局的静态 block，不会访问任何外部变量。\n2. `_NSConcreteStackBlock` 保存在栈中的 block，当函数返回时会被销毁。\n3. `_NSConcreteMallocBlock` 保存在堆中的 block，当引用计数为 0 时会被销毁。\n\n在 ARC 开启的情况下，将只会有 `NSConcreteGlobalBlock` 和 `NSConcreteMallocBlock`类型的 block。原本的 `NSConcreteStackBlock` 的 block 会被 `NSConcreteMallocBlock` 类型的 block 替代。\n\n### 研究工具：clang\nclang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是\n```objc\nclang -rewrite-objc xxxx\n```\n","slug":"Block基础","published":1,"updated":"2016-09-05T01:55:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzuz0004rgru61dd4ujo","content":"<p>类似于匿名函数，oc中提供<code>block</code>,可以将一段代码块像对象一样作为参数传递、执行。</p>\n<a id=\"more\"></a>\n<h2 id=\"Block的使用\"><a href=\"#Block的使用\" class=\"headerlink\" title=\"Block的使用\"></a>Block的使用</h2><h3 id=\"Block实例\"><a href=\"#Block实例\" class=\"headerlink\" title=\"Block实例\"></a>Block实例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">^(<span class=\"keyword\">double</span> dividend)&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span> quotient = dividend / divisor;</div><div class=\"line\">\t<span class=\"keyword\">return</span> quotient;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Block对象可以被当做一个实参来传递给可以接收block的方法。</p>\n<h3 id=\"声明block变量\"><a href=\"#声明block变量\" class=\"headerlink\" title=\"声明block变量:\"></a>声明block变量:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^devowelizer)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">BOOL</span>*);</div></pre></td></tr></table></figure>\n<p><code>void</code> 表示返回类型<br><code>^</code> 表示是一个block对象<br><code>devowelizer</code> 表示block变量的名称<br>后面的是实参类型<br>方法的调用参数类型为<code>^(id  string, NSUInteger i, BOOL *stop)block</code></p>\n<h3 id=\"编写Block对象\"><a href=\"#编写Block对象\" class=\"headerlink\" title=\"编写Block对象\"></a>编写Block对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer = ^(<span class=\"keyword\">id</span> string,<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">BOOL</span> *stop)&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"调用block变量\"><a href=\"#调用block变量\" class=\"headerlink\" title=\"调用block变量\"></a>调用block变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer(string,i,stop);</div></pre></td></tr></table></figure>\n<h3 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h3><p>不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ArrayEnumerationBlock)(<span class=\"keyword\">id</span>,<span class=\"built_in\">NSUInteger</span>,<span class=\"built_in\">BOOL</span> *);</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ArrayEnumerationBlock devowelizer；</div></pre></td></tr></table></figure></p>\n<h3 id=\"外部变量\"><a href=\"#外部变量\" class=\"headerlink\" title=\"外部变量\"></a>外部变量</h3><p>在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。</p>\n<p><strong>当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。</strong></p>\n<h3 id=\"修改外部变量\"><a href=\"#修改外部变量\" class=\"headerlink\" title=\"修改外部变量\"></a>修改外部变量</h3><p>如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。</p>\n<p><strong>__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。</strong></p>\n<h3 id=\"在Block中使用self\"><a href=\"#在Block中使用self\" class=\"headerlink\" title=\"在Block中使用self\"></a>在Block中使用self</h3><p>如果要写一个使用self的Block对象，需要避免强引用循环。<br>在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_<span class=\"keyword\">weak</span> BNREmployee *weakSelf = <span class=\"keyword\">self</span>;\t<span class=\"comment\">//弱引用指针</span></div><div class=\"line\">\tmyBlock = ^&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“Employee:%@”,weakSelf);</div><div class=\"line\">\t&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"block的实现\"><a href=\"#block的实现\" class=\"headerlink\" title=\"block的实现\"></a>block的实现</h2><p>block的实现主要参考<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#\" target=\"_blank\" rel=\"external\">唐巧谈Objective-C block的实现</a></p>\n<h3 id=\"block的结构\"><a href=\"#block的结构\" class=\"headerlink\" title=\"block的结构\"></a>block的结构</h3><p>block的结构如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_descriptor &#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"keyword\">copy</span>)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(<span class=\"keyword\">void</span> *);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> Block_layout &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa;</div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor *descriptor;</div><div class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>结构图如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true\" alt=\"block结构图\"></p>\n<p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p>\n<ol>\n<li><code>isa</code> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>\n<li><code>flags</code>，用于按 bit 位表示一些 block 的附加信息。</li>\n<li><code>reserved</code>，保留变量。</li>\n<li><code>invoke</code>，函数指针，指向具体的 block 实现的函数调用地址。</li>\n<li><code>descriptor</code>， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>\n<li>各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>\n</ol>\n<h3 id=\"block种类\"><a href=\"#block种类\" class=\"headerlink\" title=\"block种类\"></a>block种类</h3><p>block的isa是以下三个的一种：</p>\n<ol>\n<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量。</li>\n<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁。</li>\n<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>\n</ol>\n<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和 <code>NSConcreteMallocBlock</code>类型的 block。原本的 <code>NSConcreteStackBlock</code> 的 block 会被 <code>NSConcreteMallocBlock</code> 类型的 block 替代。</p>\n<h3 id=\"研究工具：clang\"><a href=\"#研究工具：clang\" class=\"headerlink\" title=\"研究工具：clang\"></a>研究工具：clang</h3><p>clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc xxxx</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>类似于匿名函数，oc中提供<code>block</code>,可以将一段代码块像对象一样作为参数传递、执行。</p>","more":"<h2 id=\"Block的使用\"><a href=\"#Block的使用\" class=\"headerlink\" title=\"Block的使用\"></a>Block的使用</h2><h3 id=\"Block实例\"><a href=\"#Block实例\" class=\"headerlink\" title=\"Block实例\"></a>Block实例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">^(<span class=\"keyword\">double</span> dividend)&#123;</div><div class=\"line\">\t<span class=\"keyword\">double</span> quotient = dividend / divisor;</div><div class=\"line\">\t<span class=\"keyword\">return</span> quotient;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Block对象可以被当做一个实参来传递给可以接收block的方法。</p>\n<h3 id=\"声明block变量\"><a href=\"#声明block变量\" class=\"headerlink\" title=\"声明block变量:\"></a>声明block变量:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> (^devowelizer)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">BOOL</span>*);</div></pre></td></tr></table></figure>\n<p><code>void</code> 表示返回类型<br><code>^</code> 表示是一个block对象<br><code>devowelizer</code> 表示block变量的名称<br>后面的是实参类型<br>方法的调用参数类型为<code>^(id  string, NSUInteger i, BOOL *stop)block</code></p>\n<h3 id=\"编写Block对象\"><a href=\"#编写Block对象\" class=\"headerlink\" title=\"编写Block对象\"></a>编写Block对象</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer = ^(<span class=\"keyword\">id</span> string,<span class=\"built_in\">NSUInteger</span> i, <span class=\"built_in\">BOOL</span> *stop)&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"调用block变量\"><a href=\"#调用block变量\" class=\"headerlink\" title=\"调用block变量\"></a>调用block变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">devowelizer(string,i,stop);</div></pre></td></tr></table></figure>\n<h3 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h3><p>不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^ArrayEnumerationBlock)(<span class=\"keyword\">id</span>,<span class=\"built_in\">NSUInteger</span>,<span class=\"built_in\">BOOL</span> *);</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ArrayEnumerationBlock devowelizer；</div></pre></td></tr></table></figure></p>\n<h3 id=\"外部变量\"><a href=\"#外部变量\" class=\"headerlink\" title=\"外部变量\"></a>外部变量</h3><p>在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。</p>\n<p><strong>当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。</strong></p>\n<h3 id=\"修改外部变量\"><a href=\"#修改外部变量\" class=\"headerlink\" title=\"修改外部变量\"></a>修改外部变量</h3><p>如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。</p>\n<p><strong>__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。</strong></p>\n<h3 id=\"在Block中使用self\"><a href=\"#在Block中使用self\" class=\"headerlink\" title=\"在Block中使用self\"></a>在Block中使用self</h3><p>如果要写一个使用self的Block对象，需要避免强引用循环。<br>在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_<span class=\"keyword\">weak</span> BNREmployee *weakSelf = <span class=\"keyword\">self</span>;\t<span class=\"comment\">//弱引用指针</span></div><div class=\"line\">\tmyBlock = ^&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“Employee:%@”,weakSelf);</div><div class=\"line\">\t&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"block的实现\"><a href=\"#block的实现\" class=\"headerlink\" title=\"block的实现\"></a>block的实现</h2><p>block的实现主要参考<a href=\"http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#\">唐巧谈Objective-C block的实现</a></p>\n<h3 id=\"block的结构\"><a href=\"#block的结构\" class=\"headerlink\" title=\"block的结构\"></a>block的结构</h3><p>block的结构如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Block_descriptor &#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"keyword\">copy</span>)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</div><div class=\"line\">    <span class=\"keyword\">void</span> (*dispose)(<span class=\"keyword\">void</span> *);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> Block_layout &#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> *isa;</div><div class=\"line\">    <span class=\"keyword\">int</span> flags;</div><div class=\"line\">    <span class=\"keyword\">int</span> reserved;</div><div class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</div><div class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor *descriptor;</div><div class=\"line\">    <span class=\"comment\">/* Imported variables. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>结构图如下：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true\" alt=\"block结构图\"></p>\n<p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p>\n<ol>\n<li><code>isa</code> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>\n<li><code>flags</code>，用于按 bit 位表示一些 block 的附加信息。</li>\n<li><code>reserved</code>，保留变量。</li>\n<li><code>invoke</code>，函数指针，指向具体的 block 实现的函数调用地址。</li>\n<li><code>descriptor</code>， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>\n<li>各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>\n</ol>\n<h3 id=\"block种类\"><a href=\"#block种类\" class=\"headerlink\" title=\"block种类\"></a>block种类</h3><p>block的isa是以下三个的一种：</p>\n<ol>\n<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量。</li>\n<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁。</li>\n<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>\n</ol>\n<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和 <code>NSConcreteMallocBlock</code>类型的 block。原本的 <code>NSConcreteStackBlock</code> 的 block 会被 <code>NSConcreteMallocBlock</code> 类型的 block 替代。</p>\n<h3 id=\"研究工具：clang\"><a href=\"#研究工具：clang\" class=\"headerlink\" title=\"研究工具：clang\"></a>研究工具：clang</h3><p>clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">clang -rewrite-objc xxxx</div></pre></td></tr></table></figure></p>"},{"title":"IPhone6全屏黑边处理","date":"2016-09-05T06:07:12.000Z","_content":"\n写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。\n\n<!--more-->\n\n检查了许久，代码里都是直接设置的`UIScreen`的`bounds`。因此，不可能是代码的问题。那么需要在设置中找原因。\n\n通过和正确的demo进行对比，发现了差异所在。\n\n这是有黑边情况下的设置：\n\n![错误设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true)\n\n这是没有黑边情况下的设置：\n![正确设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true)\n\n通过比较可以发现：\n出现黑边的原因是在设置里设置了`Launch Images Source`为`LaunchImage`,但是在Images.xcassets中并没有`LaunchImage`资源。所以，需要给`LaunchImage`设置图片资源。\n也可以像上面的那样设置`Launch Images Source`为`Use Asset Catalog`,并且将`Launch Screen File`设置为`LaunchImage`即可解决。","source":"_posts/IPhone6全屏黑边处理.md","raw":"title: IPhone6全屏黑边处理\ndate: 2016/9/5 14:07:12  \ncategories: IOS\ntags: \n\t- Xcode\n\t\n---\n\n写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。\n\n<!--more-->\n\n检查了许久，代码里都是直接设置的`UIScreen`的`bounds`。因此，不可能是代码的问题。那么需要在设置中找原因。\n\n通过和正确的demo进行对比，发现了差异所在。\n\n这是有黑边情况下的设置：\n\n![错误设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true)\n\n这是没有黑边情况下的设置：\n![正确设置](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true)\n\n通过比较可以发现：\n出现黑边的原因是在设置里设置了`Launch Images Source`为`LaunchImage`,但是在Images.xcassets中并没有`LaunchImage`资源。所以，需要给`LaunchImage`设置图片资源。\n也可以像上面的那样设置`Launch Images Source`为`Use Asset Catalog`,并且将`Launch Screen File`设置为`LaunchImage`即可解决。","slug":"IPhone6全屏黑边处理","published":1,"updated":"2016-09-05T09:24:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzv10005rgru7woulu19","content":"<p>写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。</p>\n<a id=\"more\"></a>\n<p>检查了许久，代码里都是直接设置的<code>UIScreen</code>的<code>bounds</code>。因此，不可能是代码的问题。那么需要在设置中找原因。</p>\n<p>通过和正确的demo进行对比，发现了差异所在。</p>\n<p>这是有黑边情况下的设置：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true\" alt=\"错误设置\"></p>\n<p>这是没有黑边情况下的设置：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true\" alt=\"正确设置\"></p>\n<p>通过比较可以发现：<br>出现黑边的原因是在设置里设置了<code>Launch Images Source</code>为<code>LaunchImage</code>,但是在Images.xcassets中并没有<code>LaunchImage</code>资源。所以，需要给<code>LaunchImage</code>设置图片资源。<br>也可以像上面的那样设置<code>Launch Images Source</code>为<code>Use Asset Catalog</code>,并且将<code>Launch Screen File</code>设置为<code>LaunchImage</code>即可解决。</p>\n","excerpt":"<p>写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。</p>","more":"<p>检查了许久，代码里都是直接设置的<code>UIScreen</code>的<code>bounds</code>。因此，不可能是代码的问题。那么需要在设置中找原因。</p>\n<p>通过和正确的demo进行对比，发现了差异所在。</p>\n<p>这是有黑边情况下的设置：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true\" alt=\"错误设置\"></p>\n<p>这是没有黑边情况下的设置：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true\" alt=\"正确设置\"></p>\n<p>通过比较可以发现：<br>出现黑边的原因是在设置里设置了<code>Launch Images Source</code>为<code>LaunchImage</code>,但是在Images.xcassets中并没有<code>LaunchImage</code>资源。所以，需要给<code>LaunchImage</code>设置图片资源。<br>也可以像上面的那样设置<code>Launch Images Source</code>为<code>Use Asset Catalog</code>,并且将<code>Launch Screen File</code>设置为<code>LaunchImage</code>即可解决。</p>"},{"title":"JavaScript基本语法","date":"2016-09-09T02:07:12.000Z","_content":"\n参考自[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n\n<!--more-->\n\n## 基础语法\n### 数据类型和变量\n#### Number\nJS不区分整数浮点数，统一用`Number`表示：\n```javascript\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n`Number`可以直接运算：\n```javascript\n(1 + 2) * 5 / 2; // 7.5\n2 / 0; // Infinity\n0 / 0; // NaN\n10 % 3; // 1 (取余)\n10.5 % 3; // 1.5\n```\n\n#### 字符串\n以单引号`'`或双引号`\"`括起来的任意文本.如`'abc'` \n\n#### 布尔值\n用`true`和`false`表示。\n\n#### 比较运算符\nJavaScript在设计时，有两种比较运算符：\n第一种是`==`比较，它会自动转换数据类型再比较.\n第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n`NaN`这个特殊的`Number`与所有其他值都不相等，包括它自己：\n```javascript\nNaN == NaN; // false\nNaN === NaN; // false\n```\n唯一能判断`NaN`的方法是通过`isNaN()`函数：\n```javascript\nisNaN(NaN); // true\n```\n\n浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n\n#### 数组\nJavaScript的数组可以包括任意数据类型。例如：\n```javascript\n[1, 2, 3.14, 'Hello', null, true];\n```\n\n另一种创建数组的方法是通过Array()函数实现：\n```javascript\nnew Array(1, 2, 3); // 创建了数组[1, 2, 3]\n```\n然而，出于代码的可读性考虑，强烈建议直接使用`[]`。\n\n数组的元素可以通过索引来访问。请注意，索引的起始值为0：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr[0]; // 返回索引为0的元素，即1\narr[5]; // 返回索引为5的元素，即true\narr[6]; // 索引超出了范围，返回undefined\n```\n\n#### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\nJavaScript对象的键都是**字符串类型**，值可以是任意数据类型。\n\n要获取一个对象的属性，我们用对象变量.属性名的方式：\n```javascript\nperson.name; // 'Bob'\nperson.zipcode; // null\n```\n\n#### 变量\n申明一个变量用var语句，比如：\n```javascript\nvar a; // 申明了变量a，此时a的值为undefined\nvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1\nvar s_007 = '007'; // s_007是一个字符串\nvar Answer = true; // Answer是一个布尔值true\nvar t = null; // t的值是null\n```\n注意只能用var申明一次。\n\n#### strict模式\n为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。\n\n启用strict模式的方法是在JavaScript代码的第一行写上：\n```javascript\n'use strict';\n```\n不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。\n\n### 字符串\n#### 模板字符串\n要把多个字符串连接起来，可以用`+`号连接：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = '你好, ' + name + ', 你今年' + age + '岁了!';\nalert(message);\n```\n\n如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nalert(message);\n```\n\n#### 操作字符串\n字符串常见的操作如下：\n```javascript\nvar s = 'Hello, world!';\ns.length; // 13\n```\n\n要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：\n```javascript\nvar s = 'Hello, world!';\n\ns[0]; // 'H'\ns[6]; // ' '\ns[7]; // 'w'\ns[12]; // '!'\ns[13]; // undefined 超出范围的索引不会报错，但一律返回undefined\n```\n需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.\n\n#### toUpperCase\n`toUpperCase()`返回一个全大写的字符串\n\n#### toLowerCase\n`toLowerCase()`f返回一个全小写的字符串\n\n#### indexOf\n`indexOf()`会搜索指定字符串出现的位置:\n```javascript\nvar s = 'hello, world';\ns.indexOf('world'); // 返回7\ns.indexOf('World'); // 没有找到指定的子串，返回-1\n```\n\n#### substring\n`substring()`返回指定索引区间的子串：\n```javascript\nvar s = 'hello, world'\ns.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'\ns.substring(7); // 从索引7开始到结束，返回'world'\n```\n\n### 数组\n要取得`Array`的长度，直接访问`length`属性：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr.length; // 6\n```\n\n**请注意**，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr.length; // 3\narr.length = 6;\narr; // arr变为[1, 2, 3, undefined, undefined, undefined]\narr.length = 2;\narr; // arr变为[1, 2]\n```\n\n**请注意**，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr[5] = 'x';\narr; // arr变为[1, 2, 3, undefined, undefined, 'x']\n```\n\n**大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。**\n\n#### indexOf\n与`String`类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：\n```javascript\nvar arr = [10, 20, '30', 'xyz'];\narr.indexOf(10); // 元素10的索引为0\narr.indexOf(20); // 元素20的索引为1\narr.indexOf(30); // 元素30没有找到，返回-1\narr.indexOf('30'); // 元素'30'的索引为2\n```\n\n#### slice\n`slice()`就是对应`String`的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\narr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']\narr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']\n```\n\n如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`\n\n#### push和pop\n`push()`向`Array`的末尾添加**若干**元素，`pop()`则把`Array`的最后一个元素删除掉：\n```javascript\nvar arr = [1, 2];\narr.push('A', 'B'); // 返回Array新的长度: 4\narr; // [1, 2, 'A', 'B']\narr.pop(); // pop()返回'B'\narr; // [1, 2, 'A']\narr.pop(); arr.pop(); arr.pop(); // 连续pop 3次\narr; // []\narr.pop(); // 空数组继续pop不会报错，而是返回undefined\narr; // []\n```\n\n#### unshift和shift\n如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：\n```javascript\nvar arr = [1, 2];\narr.unshift('A', 'B'); // 返回Array新的长度: 4\narr; // ['A', 'B', 1, 2]\narr.shift(); // 'A'\narr; // ['B', 1, 2]\narr.shift(); arr.shift(); arr.shift(); // 连续shift 3次\narr; // []\narr.shift(); // 空数组继续shift不会报错，而是返回undefined\narr; // []\n```\n\n#### sort\n`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：\n\n#### reverse\nreverse()把整个Array的元素给掉个个，也就是反转.\n\n#### splice\n`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\n````javascript\nvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n// 从索引2开始删除3个元素,然后再添加两个元素:\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n// 只删除,不添加:\narr.splice(2, 2); // ['Google', 'Facebook']\narr; // ['Microsoft', 'Apple', 'Oracle']\n// 只添加,不删除:\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n```\n\n#### concat\n`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C'];\nvar added = arr.concat([1, 2, 3]);\nadded; // ['A', 'B', 'C', 1, 2, 3]\narr; // ['A', 'B', 'C']\n```\n请注意，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。\n实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：\n```javascript\nvar arr = ['A', 'B', 'C'];\narr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]\n```\n\n#### join\n`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：\n```javascript\nvar arr = ['A', 'B', 'C', 1, 2, 3];\narr.join('-'); // 'A-B-C-1-2-3'\n```\n如果`Array`的元素不是字符串，将自动转换为字符串后再连接。\n\n### 对象\n```javascript\nvar xiaohong = {\n    name: '小红',\n    'middle-school': 'No.1 Middle School'\n};\n```\n`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：\n```javascript\nxiaohong['middle-school']; // 'No.1 Middle School'\nxiaohong['name']; // '小红'\nxiaohong.name; // '小红'\n```\n\n如果属性名是其他对象，那么需要用`[]`将其括起来，表示对外部对象执行`toString()`操作：\n```javascript\nvar weight = function () {\n    return \"1weight\"\n};\n\nvar xiaoming = {\n    name :  \"小明\",\n    [weight()] :\"属性名是返回值1weight\",\n    [weight]:\"属性名是整个function\"\n};\n\nconsole.log(xiaoming)\n返回：\n{ name: '小明',\n  '1weight': '属性名是返回值1weight',\n  'function () {\\n    return \"1weight\"\\n}': '属性名是整个function' }\n```\n\n由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.age; // undefined\nxiaoming.age = 18; // 新增一个age属性\nxiaoming.age; // 18\ndelete xiaoming.age; // 删除age属性\nxiaoming.age; // undefined\ndelete xiaoming['name']; // 删除name属性\nxiaoming.name; // undefined\ndelete xiaoming.school; // 删除一个不存在的school属性也不会报错\n```\n\n如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符,不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：\n```javascript\n'name' in xiaoming; // true\n'toString' in xiaoming; // true\n```\n要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.hasOwnProperty('name'); // true\nxiaoming.hasOwnProperty('toString'); // false\n```\n\n### Map和Set\nJS中默认对象表达方式`{}`可以视为其他语言中的`Map`或`Dictionary`的数据结构，即一组键值对。\n但是JavaScript的对象有个小问题，就是**键必须是字符串**。但实际上Number或者其他数据类型作为键也是非常合理的。\n为了解决这个问题，最新的ES6规范引入了新的数据类型`Map`。\n\n#### Map\n```javascript\nvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Michael'); // 95\nm.set('Zachary', 100);\n```\n\n#### Set\n重复元素在Set中自动被过滤：\n```javascript\nvar s = new Set([1, 2, 3, 3, '3']);\ns; // Set {1, 2, 3, \"3\"}\n```\n注意数字`3`和字符串`'3'`是不同的元素。\n\n通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果：\n```javascript\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n通过delete(key)方法可以删除元素：\n```javascript\nvar s = new Set([1, 2, 3]);\ns; // Set {1, 2, 3}\ns.delete(3);\ns; // Set {1, 2}\n```\n\n### iterable\nES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。\n具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。\n\n用`for ... of`循环遍历集合，用法如下：\n```javascript\nvar a = ['A', 'B', 'C'];\nvar s = new Set(['A', 'B', 'C']);\nvar m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + '=' + x[1]);\n}\n```\n\n**`for ... of`循环和`for ... in`循环有何区别？**\n`for ... in`实际上是**对象的属性名称(注意，是键，不是值)**。不要用在`Array`,`Set`,`Map`上，会出现奇怪的问题。\n`for ... of`循环则完全修复了这些问题，它**只循环得到集合内该出现的元素(注意，是值，不是键)**，例如：\n```javascript\nvar a = ['A', 'B', 'C'];\na.name = 'Hello';\na['4'] = 'D';\nconsole.log(a);\nfor (var num of a){\n    console.log(num)\n}\n输出：\n[ 'A', 'B', 'C', , 'D', name: 'Hello' ]\nA\nB\nC\nundefined\nD\n```\n`name`由于不是正常`Array`该有的，所以在`for ... of`循环时，其对应的值不会被输出。\n\n然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：\n```javascript\nvar a = ['A', 'B', 'C'];\na.forEach(function (element, index, array) {\n    // element: 指向当前元素的值\n    // index: 指向当前索引\n    // array: 指向Array对象本身\n    alert(element);\n});\n```\n对于`Set`来说，由于没有索引，`index`也是指当前元素。\n对于`Map`来说，`element`和`index`分别对应`Value`和`Key`.\n\n## 函数\n### 函数定义和调用\n#### 定义函数\n方式一：\n```javascript\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。\n\n方式二：\n```javascript\nvar abs = function (x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n};\n```\n在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。\n\n上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个`;`，表示赋值语句结束。\n\n#### 调用函数\n由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：\n```javascript\nabs(10, 'blablabla'); // 返回10\nabs(-9, 'haha', 'hehe', null); // 返回9\n```\n\n传入的参数比定义的少也没有问题：\n```javascript\nabs(); // 返回NaN\n```\n此时`abs(x)`函数的参数`x`将收到`undefined`，计算结果为`NaN`。\n\n要避免收到undefined，可以对参数进行检查：\n```javascript\nfunction abs(x) {\n    if ((typeof x) !== 'number') {\n        throw 'Not a number';\n    }\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n\n#### arguments\nJavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`：\n```javascript\nfunction foo(x) {\n    alert(x); // 10\n    for (var i=0; i<arguments.length; i++) {\n        alert(arguments[i]); // 10, 20, 30\n    }\n}\nfoo(10, 20, 30);\n```\n利用`arguments`，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。\n\n#### rest参数\n由于JavaScript函数允许接收任意个参数，于是我们就不得不用`arguments`来获取所有参数.\nES6标准引入了`rest`参数，可以将剩余的参数放在`rest`中：\n```javascript\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]\n\nfoo(1);\n// 结果:\n// a = 1\n// b = undefined\n// Array []\n```\n\n`rest`参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`，所以，不再需要`arguments`我们就获取了全部参数。\n如果传入的参数连正常定义的参数都没填满，也不要紧，`rest`参数会接收一个空数组（注意不是`undefined`）。\n\n\n### 变量作用域\n在JavaScript中，用var申明的变量实际上是有作用域的。\n- 如果一个变量在函数体内部申明，则该变量的作用域为整个**函数体**(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。\n- 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量\n- 如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\n\n#### 变量提升\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：\n```javascript\n'use strict';\n\nfunction foo() {\n    var x = 'Hello, ' + y;\n    alert(x);\n    var y = 'Bob';\n}\n\nfoo();\n```\n\n虽然是`strict`模式，但语句`var x = 'Hello, ' + y;`并不报错，原因是变量`y`在稍后申明了。但是`alert`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。\n\n#### 全局作用域\n不在任何函数内定义的变量就具有全局作用域。\n\n#### 名字空间\n不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n```javascript\n// 唯一的全局变量MYAPP:\nvar MYAPP = {};\n\n// 其他变量:\nMYAPP.name = 'myapp';\nMYAPP.version = 1.0;\n\n// 其他函数:\nMYAPP.foo = function () {\n    return 'foo';\n};\n```\n\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\n\n#### 局部作用域\n由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：\n```javascript\n'use strict';\n\nfunction foo() {\n    for (var i=0; i<100; i++) {\n        //\n    }\n    i += 100; // 仍然可以引用变量i\n}\n```\n\n为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：\n```javascript\n'use strict';\n\nfunction foo() {\n    var sum = 0;\n    for (let i=0; i<100; i++) {\n        sum += i;\n    }\n    i += 1; // SyntaxError\n}\n```\n\n#### 常量\n由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.\n\nES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：\n```javascript\n'use strict';\n\nconst PI = 3.14;\nPI = 3; // 某些浏览器不报错，但是无效果！\nPI; // 3.14\n```\n\n注意，一定要加上`use strict`,否则会报错。\n\n### 方法\n绑定到对象上的函数称为方法:\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var y = new Date().getFullYear();\n        return y - this.birth;\n    }\n};\n\nxiaoming.age; // function xiaoming.age()\nxiaoming.age(); // 今年调用是25,明年调用就变成26了\n```\n\n和普通函数也没啥区别，但是它在内部使用了一个`this`关键字.\n在一个方法内部，`this`是一个特殊变量，**它始终指向当前对象**，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。\n\n让我们拆开写：\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25, 正常结果\ngetAge(); // NaN\n```\n\n单独调用函数`getAge()`怎么返回了`NaN`？请注意，我们已经进入到了JavaScript的一个大坑里。\nJavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？\n答案是，视情况而定！\n如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。\n如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向**全局对象**.\n\n更坑爹的是，如果这么写：\n```javascript\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数\nfn(); // NaN\n```\n也是不行的！要保证`this`指向正确，必须要给出明确的上下文，必须用`obj.xxx()`的形式调用！谁调用，`this`就是指谁。上面仅仅相当于将`age`方法赋给`fn`.\n\n如果是这种情况：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - this.birth;\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); \n```\n\n又不对了。原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！需要这样修改：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var that = this; // 在方法内部一开始就捕获this\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - that.birth; // 用that而不是this\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); // 25\n```\n\n用`var that = this`;将`age`中的`this`捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\n\n#### apply\n我们还是可以控制`this`的指向的！\n\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\n\n用`apply`修复`getAge()`调用:\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25\ngetAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\n```\n\n另一个与`apply()`类似的方法是`call()`，唯一区别是：\n- `apply()`把参数打包成`Array`再传入；\n- `call()`把参数按顺序传入。 \n\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\n```javascript\nMath.max.apply(null, [3, 5, 4]); // 5\nMath.max.call(null, 3, 5, 4); // 5\n```\n对普通函数调用，我们通常把this绑定为null。\n\n#### 装饰器\n利用`apply()`，我们还可以动态改变函数的行为。\n\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以**重新指向新的函数**。\n\n现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：\n```javascript\nvar count = 0;\nvar oldParseInt = parseInt; // 保存原函数\n\nwindow.parseInt = function () {\n    count += 1;\n    return oldParseInt.apply(null, arguments); // 调用原函数\n};\n\n// 测试:\nparseInt('10');\nparseInt('20');\nparseInt('30');\ncount; // 3\n```\n\n### 高阶函数\n一个可以接收另一个函数作为参的函数，称为高阶函数。\n#### map\n`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：\n```javascript\nfunction pow(x) {\n    return x * x;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n`map()`将传入的函数一一作用在数组的每一个元素上。\n\n#### reduce\n`Array`的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n```javascipt\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n```\n\n比如对`Array`求和：\n```javascript\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n}); // 25\n```\n\n#### filter\n用于把`Array`的某些元素过滤掉，然后返回剩下的元素\n`Array`的`filter()`接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：\n```javascript\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\nvar r = arr.filter(function (x) {\n    return x % 2 !== 0;\n});\nr; // [1, 5, 9, 15]\n```\n\n#### sort\n可以接收一个比较函数来实现自定义的排序\n要按数字大小排序，我们可以这么写：\n```javascript\nvar arr = [10, 20, 1, 2];\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n}); // [1, 2, 10, 20]\n```\n\n**注意**：`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`\n\n### 闭包\n#### 函数作为返回值\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n比如返回一个求和的函数：\n```javascript\nfunction lazy_sum(arr) {\n    var sum = function () {\n        return arr.reduce(function (x, y) {\n            return x + y;\n        });\n    }\n    return sum;\n}\n```\n当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：\n```javascript\nvar f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n```\n调用函数f时，才真正计算求和的结果：\n```javascript\nf(); // 15\n```\n当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中`this`不遵循闭包)\n\n#### 闭包\n需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push(function () {\n            return i * i;\n        });\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n```\n\n上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，**或者说返回了三个闭包**.\n调用的结果全是`16`,因为返回函数都引用了变量`i`，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了`4`。\n\n**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function (n) {\n            return function () {\n                return n * n;\n            }\n        })(i));\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n\nf1(); // 1\nf2(); // 4\nf3(); // 9\n```\n\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\n```\n(function (x) {\n    return x * x;\n})(3); // 9\n``` \n\n**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            var n =i\n            return function () {\n                return n*n;\n            }\n        })());\n    }\n    return arr;\n}\n```\n相反的，如果内存函数还是用的`i`，那么结果就会全是`16`.\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            // var n =i\n            return function () {\n                return i*i;\n            }\n        })());\n    }\n    return arr;\n}\n```\n\n### 箭头函数\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\n```javascript\nx => x*x\n```\n相当于一个输入为`x`输出为`x*x`的匿名函数\n```\nfunction (x) {\n    return x * x;\n}\n```\n如果参数不是一个，就需要用括号()括起来：\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n语法糖，类似于python中的lambda函数\n\n当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。\n试做比较：\n```\n//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = function () {\n            return new Date().getFullYear() - this.birth; // this指向window或undefined\n        };\n        return fn();\n    }\n};\n//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25\n```\n如果使用箭头函数,以前`var that = this;`这种写法就不需要了。\n\n\n### generator\ngenerator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。\n\n定义如下：\n```javascript\nfunction* foo(x) {\n    yield x + 1;\n    yield x + 2;\n    return x + 3;\n}\n```\ngenerator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。好处就是**函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。**(其实这东西很像调试函数时候的断点！)\n\n执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：\n```javascript\nvar f = fib(5);\nf.next(); // {value: 0, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 1, done: true}\n```\n`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。\n\n第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：\n```javascript\nfor (var x of fib(5)) {\n    console.log(x); // 依次输出0, 1, 1\n}\n```\n\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。**看起来蛮有用的**\n\n举个例子，要生成一个自增的ID，可以编写一个next_id()函数：\n```javascript\nvar current_id = 0;\n\nfunction next_id() {\n    current_id ++;\n    return current_id;\n}\n```\n\n由于函数无法保存状态，故需要一个全局变量`current_id`来保存数字。现在改用generator：\n```javascript\nfunction* next_id() {\n\tvar i = 0;\n\twhile (true){\n    \tyield ++i;\n   \t}\n}\n```\n\n## 标准对象\n一些原则：\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\n- 判断`Array`要使用`Array.isArray(arr)`；\n- 判断`null`请使用`myVar === null`；\n- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；\n\n### Date\n在JavaScript中，`Date`对象用来表示日期和时间。\n\n要获取系统当前时间，用：\n```javascript\nvar now = new Date();\nnow; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\nnow.getFullYear(); // 2015, 年份\nnow.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月\nnow.getDate(); // 24, 表示24号\nnow.getDay(); // 3, 表示星期三\nnow.getHours(); // 19, 24小时制\nnow.getMinutes(); // 49, 分钟\nnow.getSeconds(); // 22, 秒\nnow.getMilliseconds(); // 875, 毫秒数\nnow.getTime(); // 1435146562875, 以number形式表示的时间戳\n```\n\n如果要创建一个指定日期和时间的Date对象，可以用：\n```javascript\nvar d = new Date(2015, 5, 19, 20, 15, 30, 123);\nd; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)\n```\n\n一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是`0~11`，`0`表示一月，`1`表示二月……，所以要表示`6`月，我们传入的是`5`！\n\n第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：\n```javascript\nvar d = Date.parse('2015-06-24T19:49:22.875+08:00');\nd; // 1435146562875\n```\n但它返回的不是`Date`对象，而是一个**时间戳**。不过有时间戳就可以很容易地把它转换为一个`Date`：\n```javascript\nvar d = new Date(1435146562875);\nd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\n```\n\n时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。\n\n要获取当前时间戳，可以用：\n```javascript\nif (Date.now) {\n    alert(Date.now()); // 老版本IE没有now()方法\n} else {\n    alert(new Date().getTime());\n}\n```\n\n### Json\nJSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：\n- number：和JavaScript的`number`完全一致；\n- boolean：就是JavaScript的`true`或`false`；\n- string：就是JavaScript的`string`；\n- null：就是JavaScript的`null`；\n- array：就是JavaScript的`Array`表示方式——`[]`；\n- object：就是JavaScript的`{ ... }`表示方式。\n\n#### 序列化\n先把小明这个对象序列化成JSON格式的字符串：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\n};\n\nJSON.stringify(xiaoming); // '{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]}'\n```\n\n要输出得好看一些，可以加上参数，按缩进输出：\n```javascript\nJSON.stringify(xiaoming, null, '  ');\n```\n结果：\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：\n```javacript\nJSON.stringify(xiaoming, ['name', 'skills'], '  ');\n```\n结果:\n```javascript\n{\n  \"name\": \"小明\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n还可以传入一个函数，这样对象的每个键值对都会被函数先处理：\n```javascript\nfunction convert(key, value) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value;\n}\n\nJSON.stringify(xiaoming, convert, '  ');\n```\n上面的代码把所有属性值都变成大写：\n\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\n  \"skills\": [\n    \"JAVASCRIPT\",\n    \"JAVA\",\n    \"PYTHON\",\n    \"LISP\"\n  ]\n}\n```\n如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],\n    toJSON: function () {\n        return { // 只输出name和age，并且改变了key：\n            'Name': this.name,\n            'Age': this.age\n        };\n    }\n};\n\nJSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}'\n```\n\n#### 反序列化\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：\n```javascript\nJSON.parse('[1,2,3,true]'); // [1, 2, 3, true]\nJSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}\nJSON.parse('true'); // true\nJSON.parse('123.45'); // 123.45\n```\n`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：\n```javascript\nJSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) {\n    // 把number * 2:\n    if (key === 'name') {\n        return value + '同学';\n    }\n    return value;\n}); // Object {name: '小明同学', age: 14}\n```\n\n## 面向对象编程\nJavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\n\nprototype有点类似于继承，`A`的原型是`B`，意味着，`A`拥有`B`的全部属性。\n```javascript\n// 原型对象:\nvar Student = {\n    name: 'Robot',\n    height: 1.2,\n    run: function () {\n        console.log(this.name + ' is running...');\n    }\n};\n\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 创建对象\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\n\n例如，创建一个`Array`对象：\n```javascript\nvar arr = [1, 2, 3];\n```\n其原型链是：\n```javascript\narr ----> Array.prototype ----> Object.prototype ----> null\n```\n`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。\n\n当我们创建一个函数时：\n```javascript\nfunction foo() {\n    return 0;\n}\n```\n函数也是一个对象，它的原型链是：\n```javascript\nfoo ----> Function.prototype ----> Object.prototype ----> null\n```\n由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。\n\n#### 构造函数\n除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\n```\n注意，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\n\n用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\n\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\n\nxiaoming instanceof Student; // true\n```\n他们之间的关系就是:\n![constructor](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true)\n\n红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。\n\n另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\n\n不过还有一个小问题，注意观察：\n```javascript\nxiaoming.name; // '小明'\nxiaohong.name; // '小红'\nxiaoming.hello; // function: Student.hello()\nxiaohong.hello; // function: Student.hello()\nxiaoming.hello === xiaohong.hello; // false\n```\n`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！\n\n如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。\n要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：\n![constructor2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true)\n修改代码如下：\n```javascript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n### class继承\n新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n我们先回顾用函数实现`Student`的方法：\n```javscript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n\n如果用新的`class`关键字来编写`Student`，可以这样写：\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，`class`的定义包含了**构造函数**`constructor`和定义在原型对象上的函数`hello()`（注意没有`function`关键字），这样就避免了`Student.prototype.hello = function () {...}`这样分散的代码。\n\n最后，创建一个Student对象代码和前面章节完全一样：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.hello();\n```\n\n#### class继承\n用`class`定义对象的另一个巨大的好处是继承更方便了,直接通过`extends`来实现：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n通过`super(name)`来调用父类的构造函数。`PrimaryStudent`已经自动获得了父类`Student`的`hello`方法，我们又在子类中定义了新的`myGrade`方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaScript基本语法.md","raw":"title: JavaScript基本语法\ndate: 2016/9/9 10:07:12  \ncategories: JavaScript\ntags:\n\t- 学习笔记\n\n---\n\n参考自[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n\n<!--more-->\n\n## 基础语法\n### 数据类型和变量\n#### Number\nJS不区分整数浮点数，统一用`Number`表示：\n```javascript\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n`Number`可以直接运算：\n```javascript\n(1 + 2) * 5 / 2; // 7.5\n2 / 0; // Infinity\n0 / 0; // NaN\n10 % 3; // 1 (取余)\n10.5 % 3; // 1.5\n```\n\n#### 字符串\n以单引号`'`或双引号`\"`括起来的任意文本.如`'abc'` \n\n#### 布尔值\n用`true`和`false`表示。\n\n#### 比较运算符\nJavaScript在设计时，有两种比较运算符：\n第一种是`==`比较，它会自动转换数据类型再比较.\n第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n`NaN`这个特殊的`Number`与所有其他值都不相等，包括它自己：\n```javascript\nNaN == NaN; // false\nNaN === NaN; // false\n```\n唯一能判断`NaN`的方法是通过`isNaN()`函数：\n```javascript\nisNaN(NaN); // true\n```\n\n浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n\n#### 数组\nJavaScript的数组可以包括任意数据类型。例如：\n```javascript\n[1, 2, 3.14, 'Hello', null, true];\n```\n\n另一种创建数组的方法是通过Array()函数实现：\n```javascript\nnew Array(1, 2, 3); // 创建了数组[1, 2, 3]\n```\n然而，出于代码的可读性考虑，强烈建议直接使用`[]`。\n\n数组的元素可以通过索引来访问。请注意，索引的起始值为0：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr[0]; // 返回索引为0的元素，即1\narr[5]; // 返回索引为5的元素，即true\narr[6]; // 索引超出了范围，返回undefined\n```\n\n#### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\nJavaScript对象的键都是**字符串类型**，值可以是任意数据类型。\n\n要获取一个对象的属性，我们用对象变量.属性名的方式：\n```javascript\nperson.name; // 'Bob'\nperson.zipcode; // null\n```\n\n#### 变量\n申明一个变量用var语句，比如：\n```javascript\nvar a; // 申明了变量a，此时a的值为undefined\nvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1\nvar s_007 = '007'; // s_007是一个字符串\nvar Answer = true; // Answer是一个布尔值true\nvar t = null; // t的值是null\n```\n注意只能用var申明一次。\n\n#### strict模式\n为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。\n\n启用strict模式的方法是在JavaScript代码的第一行写上：\n```javascript\n'use strict';\n```\n不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。\n\n### 字符串\n#### 模板字符串\n要把多个字符串连接起来，可以用`+`号连接：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = '你好, ' + name + ', 你今年' + age + '岁了!';\nalert(message);\n```\n\n如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nalert(message);\n```\n\n#### 操作字符串\n字符串常见的操作如下：\n```javascript\nvar s = 'Hello, world!';\ns.length; // 13\n```\n\n要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：\n```javascript\nvar s = 'Hello, world!';\n\ns[0]; // 'H'\ns[6]; // ' '\ns[7]; // 'w'\ns[12]; // '!'\ns[13]; // undefined 超出范围的索引不会报错，但一律返回undefined\n```\n需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.\n\n#### toUpperCase\n`toUpperCase()`返回一个全大写的字符串\n\n#### toLowerCase\n`toLowerCase()`f返回一个全小写的字符串\n\n#### indexOf\n`indexOf()`会搜索指定字符串出现的位置:\n```javascript\nvar s = 'hello, world';\ns.indexOf('world'); // 返回7\ns.indexOf('World'); // 没有找到指定的子串，返回-1\n```\n\n#### substring\n`substring()`返回指定索引区间的子串：\n```javascript\nvar s = 'hello, world'\ns.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'\ns.substring(7); // 从索引7开始到结束，返回'world'\n```\n\n### 数组\n要取得`Array`的长度，直接访问`length`属性：\n```javascript\nvar arr = [1, 2, 3.14, 'Hello', null, true];\narr.length; // 6\n```\n\n**请注意**，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr.length; // 3\narr.length = 6;\narr; // arr变为[1, 2, 3, undefined, undefined, undefined]\narr.length = 2;\narr; // arr变为[1, 2]\n```\n\n**请注意**，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：\n```javascript\nvar arr = [1, 2, 3];\narr[5] = 'x';\narr; // arr变为[1, 2, 3, undefined, undefined, 'x']\n```\n\n**大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。**\n\n#### indexOf\n与`String`类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：\n```javascript\nvar arr = [10, 20, '30', 'xyz'];\narr.indexOf(10); // 元素10的索引为0\narr.indexOf(20); // 元素20的索引为1\narr.indexOf(30); // 元素30没有找到，返回-1\narr.indexOf('30'); // 元素'30'的索引为2\n```\n\n#### slice\n`slice()`就是对应`String`的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\narr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']\narr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']\n```\n\n如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`\n\n#### push和pop\n`push()`向`Array`的末尾添加**若干**元素，`pop()`则把`Array`的最后一个元素删除掉：\n```javascript\nvar arr = [1, 2];\narr.push('A', 'B'); // 返回Array新的长度: 4\narr; // [1, 2, 'A', 'B']\narr.pop(); // pop()返回'B'\narr; // [1, 2, 'A']\narr.pop(); arr.pop(); arr.pop(); // 连续pop 3次\narr; // []\narr.pop(); // 空数组继续pop不会报错，而是返回undefined\narr; // []\n```\n\n#### unshift和shift\n如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：\n```javascript\nvar arr = [1, 2];\narr.unshift('A', 'B'); // 返回Array新的长度: 4\narr; // ['A', 'B', 1, 2]\narr.shift(); // 'A'\narr; // ['B', 1, 2]\narr.shift(); arr.shift(); arr.shift(); // 连续shift 3次\narr; // []\narr.shift(); // 空数组继续shift不会报错，而是返回undefined\narr; // []\n```\n\n#### sort\n`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：\n\n#### reverse\nreverse()把整个Array的元素给掉个个，也就是反转.\n\n#### splice\n`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\n````javascript\nvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n// 从索引2开始删除3个元素,然后再添加两个元素:\narr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n// 只删除,不添加:\narr.splice(2, 2); // ['Google', 'Facebook']\narr; // ['Microsoft', 'Apple', 'Oracle']\n// 只添加,不删除:\narr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\narr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n```\n\n#### concat\n`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：\n```javascript\nvar arr = ['A', 'B', 'C'];\nvar added = arr.concat([1, 2, 3]);\nadded; // ['A', 'B', 'C', 1, 2, 3]\narr; // ['A', 'B', 'C']\n```\n请注意，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。\n实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：\n```javascript\nvar arr = ['A', 'B', 'C'];\narr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]\n```\n\n#### join\n`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：\n```javascript\nvar arr = ['A', 'B', 'C', 1, 2, 3];\narr.join('-'); // 'A-B-C-1-2-3'\n```\n如果`Array`的元素不是字符串，将自动转换为字符串后再连接。\n\n### 对象\n```javascript\nvar xiaohong = {\n    name: '小红',\n    'middle-school': 'No.1 Middle School'\n};\n```\n`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：\n```javascript\nxiaohong['middle-school']; // 'No.1 Middle School'\nxiaohong['name']; // '小红'\nxiaohong.name; // '小红'\n```\n\n如果属性名是其他对象，那么需要用`[]`将其括起来，表示对外部对象执行`toString()`操作：\n```javascript\nvar weight = function () {\n    return \"1weight\"\n};\n\nvar xiaoming = {\n    name :  \"小明\",\n    [weight()] :\"属性名是返回值1weight\",\n    [weight]:\"属性名是整个function\"\n};\n\nconsole.log(xiaoming)\n返回：\n{ name: '小明',\n  '1weight': '属性名是返回值1weight',\n  'function () {\\n    return \"1weight\"\\n}': '属性名是整个function' }\n```\n\n由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.age; // undefined\nxiaoming.age = 18; // 新增一个age属性\nxiaoming.age; // 18\ndelete xiaoming.age; // 删除age属性\nxiaoming.age; // undefined\ndelete xiaoming['name']; // 删除name属性\nxiaoming.name; // undefined\ndelete xiaoming.school; // 删除一个不存在的school属性也不会报错\n```\n\n如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符,不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：\n```javascript\n'name' in xiaoming; // true\n'toString' in xiaoming; // true\n```\n要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：\n```javascript\nvar xiaoming = {\n    name: '小明'\n};\nxiaoming.hasOwnProperty('name'); // true\nxiaoming.hasOwnProperty('toString'); // false\n```\n\n### Map和Set\nJS中默认对象表达方式`{}`可以视为其他语言中的`Map`或`Dictionary`的数据结构，即一组键值对。\n但是JavaScript的对象有个小问题，就是**键必须是字符串**。但实际上Number或者其他数据类型作为键也是非常合理的。\n为了解决这个问题，最新的ES6规范引入了新的数据类型`Map`。\n\n#### Map\n```javascript\nvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Michael'); // 95\nm.set('Zachary', 100);\n```\n\n#### Set\n重复元素在Set中自动被过滤：\n```javascript\nvar s = new Set([1, 2, 3, 3, '3']);\ns; // Set {1, 2, 3, \"3\"}\n```\n注意数字`3`和字符串`'3'`是不同的元素。\n\n通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果：\n```javascript\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n>>> s.add(4)\n>>> s\n{1, 2, 3, 4}\n```\n通过delete(key)方法可以删除元素：\n```javascript\nvar s = new Set([1, 2, 3]);\ns; // Set {1, 2, 3}\ns.delete(3);\ns; // Set {1, 2}\n```\n\n### iterable\nES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。\n具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。\n\n用`for ... of`循环遍历集合，用法如下：\n```javascript\nvar a = ['A', 'B', 'C'];\nvar s = new Set(['A', 'B', 'C']);\nvar m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);\nfor (var x of a) { // 遍历Array\n    alert(x);\n}\nfor (var x of s) { // 遍历Set\n    alert(x);\n}\nfor (var x of m) { // 遍历Map\n    alert(x[0] + '=' + x[1]);\n}\n```\n\n**`for ... of`循环和`for ... in`循环有何区别？**\n`for ... in`实际上是**对象的属性名称(注意，是键，不是值)**。不要用在`Array`,`Set`,`Map`上，会出现奇怪的问题。\n`for ... of`循环则完全修复了这些问题，它**只循环得到集合内该出现的元素(注意，是值，不是键)**，例如：\n```javascript\nvar a = ['A', 'B', 'C'];\na.name = 'Hello';\na['4'] = 'D';\nconsole.log(a);\nfor (var num of a){\n    console.log(num)\n}\n输出：\n[ 'A', 'B', 'C', , 'D', name: 'Hello' ]\nA\nB\nC\nundefined\nD\n```\n`name`由于不是正常`Array`该有的，所以在`for ... of`循环时，其对应的值不会被输出。\n\n然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：\n```javascript\nvar a = ['A', 'B', 'C'];\na.forEach(function (element, index, array) {\n    // element: 指向当前元素的值\n    // index: 指向当前索引\n    // array: 指向Array对象本身\n    alert(element);\n});\n```\n对于`Set`来说，由于没有索引，`index`也是指当前元素。\n对于`Map`来说，`element`和`index`分别对应`Value`和`Key`.\n\n## 函数\n### 函数定义和调用\n#### 定义函数\n方式一：\n```javascript\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。\n\n方式二：\n```javascript\nvar abs = function (x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n};\n```\n在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。\n\n上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个`;`，表示赋值语句结束。\n\n#### 调用函数\n由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：\n```javascript\nabs(10, 'blablabla'); // 返回10\nabs(-9, 'haha', 'hehe', null); // 返回9\n```\n\n传入的参数比定义的少也没有问题：\n```javascript\nabs(); // 返回NaN\n```\n此时`abs(x)`函数的参数`x`将收到`undefined`，计算结果为`NaN`。\n\n要避免收到undefined，可以对参数进行检查：\n```javascript\nfunction abs(x) {\n    if ((typeof x) !== 'number') {\n        throw 'Not a number';\n    }\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n```\n\n#### arguments\nJavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`：\n```javascript\nfunction foo(x) {\n    alert(x); // 10\n    for (var i=0; i<arguments.length; i++) {\n        alert(arguments[i]); // 10, 20, 30\n    }\n}\nfoo(10, 20, 30);\n```\n利用`arguments`，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。\n\n#### rest参数\n由于JavaScript函数允许接收任意个参数，于是我们就不得不用`arguments`来获取所有参数.\nES6标准引入了`rest`参数，可以将剩余的参数放在`rest`中：\n```javascript\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n\nfoo(1, 2, 3, 4, 5);\n// 结果:\n// a = 1\n// b = 2\n// Array [ 3, 4, 5 ]\n\nfoo(1);\n// 结果:\n// a = 1\n// b = undefined\n// Array []\n```\n\n`rest`参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`，所以，不再需要`arguments`我们就获取了全部参数。\n如果传入的参数连正常定义的参数都没填满，也不要紧，`rest`参数会接收一个空数组（注意不是`undefined`）。\n\n\n### 变量作用域\n在JavaScript中，用var申明的变量实际上是有作用域的。\n- 如果一个变量在函数体内部申明，则该变量的作用域为整个**函数体**(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。\n- 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量\n- 如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\n\n#### 变量提升\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：\n```javascript\n'use strict';\n\nfunction foo() {\n    var x = 'Hello, ' + y;\n    alert(x);\n    var y = 'Bob';\n}\n\nfoo();\n```\n\n虽然是`strict`模式，但语句`var x = 'Hello, ' + y;`并不报错，原因是变量`y`在稍后申明了。但是`alert`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。\n\n#### 全局作用域\n不在任何函数内定义的变量就具有全局作用域。\n\n#### 名字空间\n不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n```javascript\n// 唯一的全局变量MYAPP:\nvar MYAPP = {};\n\n// 其他变量:\nMYAPP.name = 'myapp';\nMYAPP.version = 1.0;\n\n// 其他函数:\nMYAPP.foo = function () {\n    return 'foo';\n};\n```\n\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\n\n#### 局部作用域\n由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：\n```javascript\n'use strict';\n\nfunction foo() {\n    for (var i=0; i<100; i++) {\n        //\n    }\n    i += 100; // 仍然可以引用变量i\n}\n```\n\n为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：\n```javascript\n'use strict';\n\nfunction foo() {\n    var sum = 0;\n    for (let i=0; i<100; i++) {\n        sum += i;\n    }\n    i += 1; // SyntaxError\n}\n```\n\n#### 常量\n由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.\n\nES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：\n```javascript\n'use strict';\n\nconst PI = 3.14;\nPI = 3; // 某些浏览器不报错，但是无效果！\nPI; // 3.14\n```\n\n注意，一定要加上`use strict`,否则会报错。\n\n### 方法\n绑定到对象上的函数称为方法:\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var y = new Date().getFullYear();\n        return y - this.birth;\n    }\n};\n\nxiaoming.age; // function xiaoming.age()\nxiaoming.age(); // 今年调用是25,明年调用就变成26了\n```\n\n和普通函数也没啥区别，但是它在内部使用了一个`this`关键字.\n在一个方法内部，`this`是一个特殊变量，**它始终指向当前对象**，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。\n\n让我们拆开写：\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25, 正常结果\ngetAge(); // NaN\n```\n\n单独调用函数`getAge()`怎么返回了`NaN`？请注意，我们已经进入到了JavaScript的一个大坑里。\nJavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？\n答案是，视情况而定！\n如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。\n如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向**全局对象**.\n\n更坑爹的是，如果这么写：\n```javascript\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数\nfn(); // NaN\n```\n也是不行的！要保证`this`指向正确，必须要给出明确的上下文，必须用`obj.xxx()`的形式调用！谁调用，`this`就是指谁。上面仅仅相当于将`age`方法赋给`fn`.\n\n如果是这种情况：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - this.birth;\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); \n```\n\n又不对了。原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！需要这样修改：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: function () {\n        var that = this; // 在方法内部一开始就捕获this\n        function getAgeFromBirth() {\n            var y = new Date().getFullYear();\n            return y - that.birth; // 用that而不是this\n        }\n        return getAgeFromBirth();\n    }\n};\n\nxiaoming.age(); // 25\n```\n\n用`var that = this`;将`age`中的`this`捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\n\n#### apply\n我们还是可以控制`this`的指向的！\n\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\n\n用`apply`修复`getAge()`调用:\n```javascript\nfunction getAge() {\n    var y = new Date().getFullYear();\n    return y - this.birth;\n}\n\nvar xiaoming = {\n    name: '小明',\n    birth: 1990,\n    age: getAge\n};\n\nxiaoming.age(); // 25\ngetAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\n```\n\n另一个与`apply()`类似的方法是`call()`，唯一区别是：\n- `apply()`把参数打包成`Array`再传入；\n- `call()`把参数按顺序传入。 \n\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\n```javascript\nMath.max.apply(null, [3, 5, 4]); // 5\nMath.max.call(null, 3, 5, 4); // 5\n```\n对普通函数调用，我们通常把this绑定为null。\n\n#### 装饰器\n利用`apply()`，我们还可以动态改变函数的行为。\n\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以**重新指向新的函数**。\n\n现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：\n```javascript\nvar count = 0;\nvar oldParseInt = parseInt; // 保存原函数\n\nwindow.parseInt = function () {\n    count += 1;\n    return oldParseInt.apply(null, arguments); // 调用原函数\n};\n\n// 测试:\nparseInt('10');\nparseInt('20');\nparseInt('30');\ncount; // 3\n```\n\n### 高阶函数\n一个可以接收另一个函数作为参的函数，称为高阶函数。\n#### map\n`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：\n```javascript\nfunction pow(x) {\n    return x * x;\n}\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\narr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n`map()`将传入的函数一一作用在数组的每一个元素上。\n\n#### reduce\n`Array`的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n```javascipt\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n```\n\n比如对`Array`求和：\n```javascript\nvar arr = [1, 3, 5, 7, 9];\narr.reduce(function (x, y) {\n    return x + y;\n}); // 25\n```\n\n#### filter\n用于把`Array`的某些元素过滤掉，然后返回剩下的元素\n`Array`的`filter()`接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：\n```javascript\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\nvar r = arr.filter(function (x) {\n    return x % 2 !== 0;\n});\nr; // [1, 5, 9, 15]\n```\n\n#### sort\n可以接收一个比较函数来实现自定义的排序\n要按数字大小排序，我们可以这么写：\n```javascript\nvar arr = [10, 20, 1, 2];\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n}); // [1, 2, 10, 20]\n```\n\n**注意**：`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`\n\n### 闭包\n#### 函数作为返回值\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n比如返回一个求和的函数：\n```javascript\nfunction lazy_sum(arr) {\n    var sum = function () {\n        return arr.reduce(function (x, y) {\n            return x + y;\n        });\n    }\n    return sum;\n}\n```\n当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：\n```javascript\nvar f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\n```\n调用函数f时，才真正计算求和的结果：\n```javascript\nf(); // 15\n```\n当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中`this`不遵循闭包)\n\n#### 闭包\n需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push(function () {\n            return i * i;\n        });\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n```\n\n上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，**或者说返回了三个闭包**.\n调用的结果全是`16`,因为返回函数都引用了变量`i`，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了`4`。\n\n**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function (n) {\n            return function () {\n                return n * n;\n            }\n        })(i));\n    }\n    return arr;\n}\n\nvar results = count();\nvar f1 = results[0];\nvar f2 = results[1];\nvar f3 = results[2];\n\nf1(); // 1\nf2(); // 4\nf3(); // 9\n```\n\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\n```\n(function (x) {\n    return x * x;\n})(3); // 9\n``` \n\n**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            var n =i\n            return function () {\n                return n*n;\n            }\n        })());\n    }\n    return arr;\n}\n```\n相反的，如果内存函数还是用的`i`，那么结果就会全是`16`.\n```javascript\nfunction count() {\n    var arr = [];\n    for (var i=1; i<=3; i++) {\n        arr.push((function () {\n            // var n =i\n            return function () {\n                return i*i;\n            }\n        })());\n    }\n    return arr;\n}\n```\n\n### 箭头函数\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\n```javascript\nx => x*x\n```\n相当于一个输入为`x`输出为`x*x`的匿名函数\n```\nfunction (x) {\n    return x * x;\n}\n```\n如果参数不是一个，就需要用括号()括起来：\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n语法糖，类似于python中的lambda函数\n\n当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。\n试做比较：\n```\n//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = function () {\n            return new Date().getFullYear() - this.birth; // this指向window或undefined\n        };\n        return fn();\n    }\n};\n//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：\nvar obj = {\n    birth: 1990,\n    getAge: function () {\n        var b = this.birth; // 1990\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\n        return fn();\n    }\n};\nobj.getAge(); // 25\n```\n如果使用箭头函数,以前`var that = this;`这种写法就不需要了。\n\n\n### generator\ngenerator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。\n\n定义如下：\n```javascript\nfunction* foo(x) {\n    yield x + 1;\n    yield x + 2;\n    return x + 3;\n}\n```\ngenerator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。好处就是**函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。**(其实这东西很像调试函数时候的断点！)\n\n执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：\n```javascript\nvar f = fib(5);\nf.next(); // {value: 0, done: false}\nf.next(); // {value: 1, done: false}\nf.next(); // {value: 1, done: true}\n```\n`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。\n\n第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：\n```javascript\nfor (var x of fib(5)) {\n    console.log(x); // 依次输出0, 1, 1\n}\n```\n\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。**看起来蛮有用的**\n\n举个例子，要生成一个自增的ID，可以编写一个next_id()函数：\n```javascript\nvar current_id = 0;\n\nfunction next_id() {\n    current_id ++;\n    return current_id;\n}\n```\n\n由于函数无法保存状态，故需要一个全局变量`current_id`来保存数字。现在改用generator：\n```javascript\nfunction* next_id() {\n\tvar i = 0;\n\twhile (true){\n    \tyield ++i;\n   \t}\n}\n```\n\n## 标准对象\n一些原则：\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\n- 判断`Array`要使用`Array.isArray(arr)`；\n- 判断`null`请使用`myVar === null`；\n- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；\n\n### Date\n在JavaScript中，`Date`对象用来表示日期和时间。\n\n要获取系统当前时间，用：\n```javascript\nvar now = new Date();\nnow; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\nnow.getFullYear(); // 2015, 年份\nnow.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月\nnow.getDate(); // 24, 表示24号\nnow.getDay(); // 3, 表示星期三\nnow.getHours(); // 19, 24小时制\nnow.getMinutes(); // 49, 分钟\nnow.getSeconds(); // 22, 秒\nnow.getMilliseconds(); // 875, 毫秒数\nnow.getTime(); // 1435146562875, 以number形式表示的时间戳\n```\n\n如果要创建一个指定日期和时间的Date对象，可以用：\n```javascript\nvar d = new Date(2015, 5, 19, 20, 15, 30, 123);\nd; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)\n```\n\n一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是`0~11`，`0`表示一月，`1`表示二月……，所以要表示`6`月，我们传入的是`5`！\n\n第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：\n```javascript\nvar d = Date.parse('2015-06-24T19:49:22.875+08:00');\nd; // 1435146562875\n```\n但它返回的不是`Date`对象，而是一个**时间戳**。不过有时间戳就可以很容易地把它转换为一个`Date`：\n```javascript\nvar d = new Date(1435146562875);\nd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\n```\n\n时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。\n\n要获取当前时间戳，可以用：\n```javascript\nif (Date.now) {\n    alert(Date.now()); // 老版本IE没有now()方法\n} else {\n    alert(new Date().getTime());\n}\n```\n\n### Json\nJSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：\n- number：和JavaScript的`number`完全一致；\n- boolean：就是JavaScript的`true`或`false`；\n- string：就是JavaScript的`string`；\n- null：就是JavaScript的`null`；\n- array：就是JavaScript的`Array`表示方式——`[]`；\n- object：就是JavaScript的`{ ... }`表示方式。\n\n#### 序列化\n先把小明这个对象序列化成JSON格式的字符串：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\n};\n\nJSON.stringify(xiaoming); // '{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]}'\n```\n\n要输出得好看一些，可以加上参数，按缩进输出：\n```javascript\nJSON.stringify(xiaoming, null, '  ');\n```\n结果：\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：\n```javacript\nJSON.stringify(xiaoming, ['name', 'skills'], '  ');\n```\n结果:\n```javascript\n{\n  \"name\": \"小明\",\n  \"skills\": [\n    \"JavaScript\",\n    \"Java\",\n    \"Python\",\n    \"Lisp\"\n  ]\n}\n```\n还可以传入一个函数，这样对象的每个键值对都会被函数先处理：\n```javascript\nfunction convert(key, value) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value;\n}\n\nJSON.stringify(xiaoming, convert, '  ');\n```\n上面的代码把所有属性值都变成大写：\n\n```javascript\n{\n  \"name\": \"小明\",\n  \"age\": 14,\n  \"gender\": true,\n  \"height\": 1.65,\n  \"grade\": null,\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\n  \"skills\": [\n    \"JAVASCRIPT\",\n    \"JAVA\",\n    \"PYTHON\",\n    \"LISP\"\n  ]\n}\n```\n如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：\n```javascript\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],\n    toJSON: function () {\n        return { // 只输出name和age，并且改变了key：\n            'Name': this.name,\n            'Age': this.age\n        };\n    }\n};\n\nJSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}'\n```\n\n#### 反序列化\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：\n```javascript\nJSON.parse('[1,2,3,true]'); // [1, 2, 3, true]\nJSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}\nJSON.parse('true'); // true\nJSON.parse('123.45'); // 123.45\n```\n`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：\n```javascript\nJSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) {\n    // 把number * 2:\n    if (key === 'name') {\n        return value + '同学';\n    }\n    return value;\n}); // Object {name: '小明同学', age: 14}\n```\n\n## 面向对象编程\nJavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\n\nprototype有点类似于继承，`A`的原型是`B`，意味着，`A`拥有`B`的全部属性。\n```javascript\n// 原型对象:\nvar Student = {\n    name: 'Robot',\n    height: 1.2,\n    run: function () {\n        console.log(this.name + ' is running...');\n    }\n};\n\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 创建对象\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\n\n例如，创建一个`Array`对象：\n```javascript\nvar arr = [1, 2, 3];\n```\n其原型链是：\n```javascript\narr ----> Array.prototype ----> Object.prototype ----> null\n```\n`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。\n\n当我们创建一个函数时：\n```javascript\nfunction foo() {\n    return 0;\n}\n```\n函数也是一个对象，它的原型链是：\n```javascript\nfoo ----> Function.prototype ----> Object.prototype ----> null\n```\n由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。\n\n#### 构造函数\n除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\n```\n注意，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\n\n用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\n\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\n\nxiaoming instanceof Student; // true\n```\n他们之间的关系就是:\n![constructor](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true)\n\n红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。\n\n另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\n\n不过还有一个小问题，注意观察：\n```javascript\nxiaoming.name; // '小明'\nxiaohong.name; // '小红'\nxiaoming.hello; // function: Student.hello()\nxiaohong.hello; // function: Student.hello()\nxiaoming.hello === xiaohong.hello; // false\n```\n`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！\n\n如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。\n要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：\n![constructor2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true)\n修改代码如下：\n```javascript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n### class继承\n新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n我们先回顾用函数实现`Student`的方法：\n```javscript\nfunction Student(name) {\n    this.name = name;\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n}\n```\n\n如果用新的`class`关键字来编写`Student`，可以这样写：\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n\n比较一下就可以发现，`class`的定义包含了**构造函数**`constructor`和定义在原型对象上的函数`hello()`（注意没有`function`关键字），这样就避免了`Student.prototype.hello = function () {...}`这样分散的代码。\n\n最后，创建一个Student对象代码和前面章节完全一样：\n```javascript\nvar xiaoming = new Student('小明');\nxiaoming.hello();\n```\n\n#### class继承\n用`class`定义对象的另一个巨大的好处是继承更方便了,直接通过`extends`来实现：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n\n通过`super(name)`来调用父类的构造函数。`PrimaryStudent`已经自动获得了父类`Student`的`hello`方法，我们又在子类中定义了新的`myGrade`方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JavaScript基本语法","published":1,"updated":"2016-09-18T01:43:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzv60007rgrugihuszkl","content":"<p>参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"external\">廖雪峰的JavaScript教程</a></p>\n<a id=\"more\"></a>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p>JS不区分整数浮点数，统一用<code>Number</code>表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.2345e3</span>; <span class=\"comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class=\"line\"><span class=\"literal\">NaN</span>; <span class=\"comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class=\"line\"><span class=\"literal\">Infinity</span>; <span class=\"comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure></p>\n<p><code>Number</code>可以直接运算：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 7.5</span></div><div class=\"line\"><span class=\"number\">2</span> / <span class=\"number\">0</span>; <span class=\"comment\">// Infinity</span></div><div class=\"line\"><span class=\"number\">0</span> / <span class=\"number\">0</span>; <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"number\">10</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1 (取余)</span></div><div class=\"line\"><span class=\"number\">10.5</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1.5</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本.如<code>&#39;abc&#39;</code> </p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>用<code>true</code>和<code>false</code>表示。</p>\n<h4 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h4><p>JavaScript在设计时，有两种比较运算符：<br>第一种是<code>==</code>比较，它会自动转换数据类型再比较.<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>\n<p><code>NaN</code>这个特殊的<code>Number</code>与所有其他值都不相等，包括它自己：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span> / <span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>JavaScript的数组可以包括任意数据类型。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>另一种创建数组的方法是通过Array()函数实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure></p>\n<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>\n<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">// 返回索引为0的元素，即1</span></div><div class=\"line\">arr[<span class=\"number\">5</span>]; <span class=\"comment\">// 返回索引为5的元素，即true</span></div><div class=\"line\">arr[<span class=\"number\">6</span>]; <span class=\"comment\">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Bob'</span>,</div><div class=\"line\">    age: <span class=\"number\">20</span>,</div><div class=\"line\">    tags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</div><div class=\"line\">    city: <span class=\"string\">'Beijing'</span>,</div><div class=\"line\">    hasCar: <span class=\"literal\">true</span>,</div><div class=\"line\">    zipcode: <span class=\"literal\">null</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JavaScript对象的键都是<strong>字符串类型</strong>，值可以是任意数据类型。</p>\n<p>要获取一个对象的属性，我们用对象变量.属性名的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">person.name; <span class=\"comment\">// 'Bob'</span></div><div class=\"line\">person.zipcode; <span class=\"comment\">// null</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>申明一个变量用var语句，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// 申明了变量a，此时a的值为undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> $b = <span class=\"number\">1</span>; <span class=\"comment\">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class=\"line\"><span class=\"keyword\">var</span> s_007 = <span class=\"string\">'007'</span>; <span class=\"comment\">// s_007是一个字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> Answer = <span class=\"literal\">true</span>; <span class=\"comment\">// Answer是一个布尔值true</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"literal\">null</span>; <span class=\"comment\">// t的值是null</span></div></pre></td></tr></table></figure></p>\n<p>注意只能用var申明一次。</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。</p>\n<p>启用strict模式的方法是在JavaScript代码的第一行写上：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div></pre></td></tr></table></figure></p>\n<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>\n<h3 id=\"字符串-1\"><a href=\"#字符串-1\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好, '</span> + name + <span class=\"string\">', 你今年'</span> + age + <span class=\"string\">'岁了!'</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`你好, <span class=\"subst\">$&#123;name&#125;</span>, 你今年<span class=\"subst\">$&#123;age&#125;</span>岁了!`</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<h4 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a>操作字符串</h4><p>字符串常见的操作如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\">s.length; <span class=\"comment\">// 13</span></div></pre></td></tr></table></figure></p>\n<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s[<span class=\"number\">0</span>]; <span class=\"comment\">// 'H'</span></div><div class=\"line\">s[<span class=\"number\">6</span>]; <span class=\"comment\">// ' '</span></div><div class=\"line\">s[<span class=\"number\">7</span>]; <span class=\"comment\">// 'w'</span></div><div class=\"line\">s[<span class=\"number\">12</span>]; <span class=\"comment\">// '!'</span></div><div class=\"line\">s[<span class=\"number\">13</span>]; <span class=\"comment\">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure></p>\n<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.</p>\n<h4 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase\"></a>toUpperCase</h4><p><code>toUpperCase()</code>返回一个全大写的字符串</p>\n<h4 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase\"></a>toLowerCase</h4><p><code>toLowerCase()</code>f返回一个全小写的字符串</p>\n<h4 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p><code>indexOf()</code>会搜索指定字符串出现的位置:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span>;</div><div class=\"line\">s.indexOf(<span class=\"string\">'world'</span>); <span class=\"comment\">// 返回7</span></div><div class=\"line\">s.indexOf(<span class=\"string\">'World'</span>); <span class=\"comment\">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"substring\"><a href=\"#substring\" class=\"headerlink\" title=\"substring\"></a>substring</h4><p><code>substring()</code>返回指定索引区间的子串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span></div><div class=\"line\">s.substring(<span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class=\"line\">s.substring(<span class=\"number\">7</span>); <span class=\"comment\">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 3</span></div><div class=\"line\">arr.length = <span class=\"number\">6</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class=\"line\">arr.length = <span class=\"number\">2</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2]</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure></p>\n<p><strong>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>\n<h4 id=\"indexOf-1\"><a href=\"#indexOf-1\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p>与<code>String</code>类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</div><div class=\"line\">arr.indexOf(<span class=\"number\">10</span>); <span class=\"comment\">// 元素10的索引为0</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">20</span>); <span class=\"comment\">// 元素20的索引为1</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">30</span>); <span class=\"comment\">// 元素30没有找到，返回-1</span></div><div class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>); <span class=\"comment\">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p><code>slice()</code>就是对应<code>String</code>的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>];</div><div class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class=\"line\">arr.slice(<span class=\"number\">3</span>); <span class=\"comment\">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure></p>\n<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code></p>\n<h4 id=\"push和pop\"><a href=\"#push和pop\" class=\"headerlink\" title=\"push和pop\"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加<strong>若干</strong>元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.push(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A', 'B']</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// pop()返回'B'</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A']</span></div><div class=\"line\">arr.pop(); arr.pop(); arr.pop(); <span class=\"comment\">// 连续pop 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// 空数组继续pop不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"unshift和shift\"><a href=\"#unshift和shift\" class=\"headerlink\" title=\"unshift和shift\"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.unshift(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 1, 2]</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 'A'</span></div><div class=\"line\">arr; <span class=\"comment\">// ['B', 1, 2]</span></div><div class=\"line\">arr.shift(); arr.shift(); arr.shift(); <span class=\"comment\">// 连续shift 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 空数组继续shift不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>reverse()把整个Array的元素给掉个个，也就是反转.</p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class=\"line\">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class=\"line\">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只删除,不添加:</div><div class=\"line\">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只添加,不删除:</div><div class=\"line\">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">added; <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>\n<p>请注意，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。<br>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">arr.concat(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure></p>\n<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>\n<h3 id=\"对象-1\"><a href=\"#对象-1\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小红'</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'No.1 Middle School'</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaohong[<span class=\"string\">'middle-school'</span>]; <span class=\"comment\">// 'No.1 Middle School'</span></div><div class=\"line\">xiaohong[<span class=\"string\">'name'</span>]; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div></pre></td></tr></table></figure></p>\n<p>如果属性名是其他对象，那么需要用<code>[]</code>将其括起来，表示对外部对象执行<code>toString()</code>操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"1weight\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name :  <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">    [weight()] :<span class=\"string\">\"属性名是返回值1weight\"</span>,</div><div class=\"line\">    [weight]:<span class=\"string\">\"属性名是整个function\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xiaoming)</div><div class=\"line\">返回：</div><div class=\"line\">&#123; name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">  <span class=\"string\">'1weight'</span>: <span class=\"string\">'属性名是返回值1weight'</span>,</div><div class=\"line\">  <span class=\"string\">'function () &#123;\\n    return \"1weight\"\\n&#125;'</span>: <span class=\"string\">'属性名是整个function'</span> &#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\">xiaoming.age = <span class=\"number\">18</span>; <span class=\"comment\">// 新增一个age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// 18</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.age; <span class=\"comment\">// 删除age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming[<span class=\"string\">'name'</span>]; <span class=\"comment\">// 删除name属性</span></div><div class=\"line\">xiaoming.name; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.school; <span class=\"comment\">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure></p>\n<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符,不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'name'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'toString'</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Map和Set\"><a href=\"#Map和Set\" class=\"headerlink\" title=\"Map和Set\"></a>Map和Set</h3><p>JS中默认对象表达方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。<br>但是JavaScript的对象有个小问题，就是<strong>键必须是字符串</strong>。但实际上Number或者其他数据类型作为键也是非常合理的。<br>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">95</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">75</span>], [<span class=\"string\">'Tracy'</span>, <span class=\"number\">85</span>]]);</div><div class=\"line\">m.delete(<span class=\"string\">'Adam'</span>); <span class=\"comment\">// 删除key 'Adam'</span></div><div class=\"line\">m.get(<span class=\"string\">'Michael'</span>); <span class=\"comment\">// 95</span></div><div class=\"line\">m.set(<span class=\"string\">'Zachary'</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h4><p>重复元素在Set中自动被过滤：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"string\">'3'</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3, \"3\"&#125;</span></div></pre></td></tr></table></figure></p>\n<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>\n<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>通过delete(key)方法可以删除元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3&#125;</span></div><div class=\"line\">s.delete(<span class=\"number\">3</span>);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"iterable\"><a href=\"#iterable\" class=\"headerlink\" title=\"iterable\"></a>iterable</h3><p>ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>\n<p>用<code>for ... of</code>循环遍历集合，用法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"string\">'x'</span>], [<span class=\"number\">2</span>, <span class=\"string\">'y'</span>], [<span class=\"number\">3</span>, <span class=\"string\">'z'</span>]]);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> a) &#123; <span class=\"comment\">// 遍历Array</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> s) &#123; <span class=\"comment\">// 遍历Set</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> m) &#123; <span class=\"comment\">// 遍历Map</span></div><div class=\"line\">    alert(x[<span class=\"number\">0</span>] + <span class=\"string\">'='</span> + x[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</strong><br><code>for ... in</code>实际上是<strong>对象的属性名称(注意，是键，不是值)</strong>。不要用在<code>Array</code>,<code>Set</code>,<code>Map</code>上，会出现奇怪的问题。<br><code>for ... of</code>循环则完全修复了这些问题，它<strong>只循环得到集合内该出现的元素(注意，是值，不是键)</strong>，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.name = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">a[<span class=\"string\">'4'</span>] = <span class=\"string\">'D'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> num <span class=\"keyword\">of</span> a)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(num)</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">[ <span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, , <span class=\"string\">'D'</span>, name: <span class=\"string\">'Hello'</span> ]</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">D</div></pre></td></tr></table></figure></p>\n<p><code>name</code>由于不是正常<code>Array</code>该有的，所以在<code>for ... of</code>循环时，其对应的值不会被输出。</p>\n<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// element: 指向当前元素的值</span></div><div class=\"line\">    <span class=\"comment\">// index: 指向当前索引</span></div><div class=\"line\">    <span class=\"comment\">// array: 指向Array对象本身</span></div><div class=\"line\">    alert(element);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>Set</code>来说，由于没有索引，<code>index</code>也是指当前元素。<br>对于<code>Map</code>来说，<code>element</code>和<code>index</code>分别对应<code>Value</code>和<code>Key</code>.</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数定义和调用\"><a href=\"#函数定义和调用\" class=\"headerlink\" title=\"函数定义和调用\"></a>函数定义和调用</h3><h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><p>方式一：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>\n<p>方式二：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> abs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>\n<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>\n<h4 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h4><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(<span class=\"number\">10</span>, <span class=\"string\">'blablabla'</span>); <span class=\"comment\">// 返回10</span></div><div class=\"line\">abs(<span class=\"number\">-9</span>, <span class=\"string\">'haha'</span>, <span class=\"string\">'hehe'</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// 返回9</span></div></pre></td></tr></table></figure></p>\n<p>传入的参数比定义的少也没有问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(); <span class=\"comment\">// 返回NaN</span></div></pre></td></tr></table></figure></p>\n<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>\n<p>要避免收到undefined，可以对参数进行检查：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> x) !== <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'Not a number'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    alert(x); <span class=\"comment\">// 10</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++) &#123;</div><div class=\"line\">        alert(<span class=\"built_in\">arguments</span>[i]); <span class=\"comment\">// 10, 20, 30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</div></pre></td></tr></table></figure></p>\n<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。</p>\n<h4 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h4><p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数.<br>ES6标准引入了<code>rest</code>参数，可以将剩余的参数放在<code>rest</code>中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b, ...rest</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a = '</span> + a);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b = '</span> + b);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(rest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = 2</span></div><div class=\"line\"><span class=\"comment\">// Array [ 3, 4, 5 ]</span></div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = undefined</span></div><div class=\"line\"><span class=\"comment\">// Array []</span></div></pre></td></tr></table></figure></p>\n<p><code>rest</code>参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。<br>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code>参数会接收一个空数组（注意不是<code>undefined</code>）。</p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>\n<ul>\n<li>如果一个变量在函数体内部申明，则该变量的作用域为整个<strong>函数体</strong>(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。</li>\n<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量</li>\n<li>如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>\n</ul>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">'Hello, '</span> + y;</div><div class=\"line\">    alert(x);</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"string\">'Bob'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>虽然是<code>strict</code>模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。</p>\n<h4 id=\"名字空间\"><a href=\"#名字空间\" class=\"headerlink\" title=\"名字空间\"></a>名字空间</h4><p>不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一的全局变量MYAPP:</span></div><div class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他变量:</span></div><div class=\"line\">MYAPP.name = <span class=\"string\">'myapp'</span>;</div><div class=\"line\">MYAPP.version = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他函数:</span></div><div class=\"line\">MYAPP.foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>\n<h4 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">100</span>; <span class=\"comment\">// 仍然可以引用变量i</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        sum += i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><p>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.</p>\n<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.14</span>;</div><div class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 某些浏览器不报错，但是无效果！</span></div><div class=\"line\">PI; <span class=\"comment\">// 3.14</span></div></pre></td></tr></table></figure></p>\n<p>注意，一定要加上<code>use strict</code>,否则会报错。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>绑定到对象上的函数称为方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">        <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// function xiaoming.age()</span></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure></p>\n<p>和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.<br>在一个方法内部，<code>this</code>是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>\n<p>让我们拆开写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25, 正常结果</span></div><div class=\"line\">getAge(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？请注意，我们已经进入到了JavaScript的一个大坑里。<br>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？<br>答案是，视情况而定！<br>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。<br>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向<strong>全局对象</strong>.</p>\n<p>更坑爹的是，如果这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = xiaoming.age; <span class=\"comment\">// 先拿到xiaoming的age函数</span></div><div class=\"line\">fn(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>也是不行的！要保证<code>this</code>指向正确，必须要给出明确的上下文，必须用<code>obj.xxx()</code>的形式调用！谁调用，<code>this</code>就是指谁。上面仅仅相当于将<code>age</code>方法赋给<code>fn</code>.</p>\n<p>如果是这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age();</div></pre></td></tr></table></figure></p>\n<p>又不对了。原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！需要这样修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 在方法内部一开始就捕获this</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - that.birth; <span class=\"comment\">// 用that而不是this</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<p>用<code>var that = this</code>;将<code>age</code>中的<code>this</code>捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p>我们还是可以控制<code>this</code>的指向的！</p>\n<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>\n<p>用<code>apply</code>修复<code>getAge()</code>调用:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div><div class=\"line\">getAge.apply(xiaoming, []); <span class=\"comment\">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>\n<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>\n<ul>\n<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>\n<li><code>call()</code>把参数按顺序传入。 </li>\n</ul>\n<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"literal\">null</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure></p>\n<p>对普通函数调用，我们通常把this绑定为null。</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>\n<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新指向新的函数</strong>。</p>\n<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> oldParseInt = <span class=\"built_in\">parseInt</span>; <span class=\"comment\">// 保存原函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.parseInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    count += <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> oldParseInt.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// 调用原函数</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 测试:</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'10'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'20'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'30'</span>);</div><div class=\"line\">count; <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>一个可以接收另一个函数作为参的函数，称为高阶函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p><code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pow</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.map(pow); <span class=\"comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure></p>\n<p><code>map()</code>将传入的函数一一作用在数组的每一个元素上。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p><code>Array</code>的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<p>比如对<code>Array</code>求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素<br><code>Array</code>的<code>filter()</code>接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> r = arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> !== <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">r; <span class=\"comment\">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort-1\"><a href=\"#sort-1\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>可以接收一个比较函数来实现自定义的排序<br>要按数字大小排序，我们可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;); <span class=\"comment\">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>比如返回一个求和的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazy_sum</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = lazy_sum([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// function sum()</span></div></pre></td></tr></table></figure></p>\n<p>调用函数f时，才真正计算求和的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(); <span class=\"comment\">// 15</span></div></pre></td></tr></table></figure></p>\n<p>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中<code>this</code>不遵循闭包)</p>\n<h4 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i * i;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div></pre></td></tr></table></figure></p>\n<p>上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，<strong>或者说返回了三个闭包</strong>.<br>调用的结果全是<code>16</code>,因为返回函数都引用了变量<code>i</code>，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了<code>4</code>。</p>\n<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> n * n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">f1(); <span class=\"comment\">// 1</span></div><div class=\"line\">f2(); <span class=\"comment\">// 4</span></div><div class=\"line\">f3(); <span class=\"comment\">// 9</span></div></pre></td></tr></table></figure></p>\n<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;)(3); // 9</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：</div><div class=\"line\">```javascript</div><div class=\"line\">function count() &#123;</div><div class=\"line\">    var arr = [];</div><div class=\"line\">    for (var i=1; i&lt;=3; i++) &#123;</div><div class=\"line\">        arr.push((function () &#123;</div><div class=\"line\">            var n =i</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                return n*n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>相反的，如果内存函数还是用的<code>i</code>，那么结果就会全是<code>16</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// var n =i</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> i*i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">x =&gt; x*x</div></pre></td></tr></table></figure></p>\n<p>相当于一个输入为<code>x</code>输出为<code>x*x</code>的匿名函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果参数不是一个，就需要用括号()括起来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 两个参数:</span></div><div class=\"line\">(x, y) =&gt; x * x + y * y</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 无参数:</span></div><div class=\"line\">() =&gt; <span class=\"number\">3.14</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可变参数:</span></div><div class=\"line\">(x, y, ...rest) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> i, sum = x + y;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;rest.length; i++) &#123;</div><div class=\"line\">        sum += rest[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>语法糖，类似于python中的lambda函数</p>\n<p>当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。<br>试做比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = function () &#123;</div><div class=\"line\">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div></pre></td></tr></table></figure></p>\n<p>如果使用箭头函数,以前<code>var that = this;</code>这种写法就不需要了。</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>generator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。</p>\n<p>定义如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。好处就是<strong>函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。</strong>(其实这东西很像调试函数时候的断点！)</p>\n<p>执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = fib(<span class=\"number\">5</span>);</div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 0, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: true&#125;</span></div></pre></td></tr></table></figure></p>\n<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>\n<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> fib(<span class=\"number\">5</span>)) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 依次输出0, 1, 1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<strong>看起来蛮有用的</strong></p>\n<p>举个例子，要生成一个自增的ID，可以编写一个next_id()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> current_id = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    current_id ++;</div><div class=\"line\">    <span class=\"keyword\">return</span> current_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。现在改用generator：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    \t<span class=\"keyword\">yield</span> ++i;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"标准对象\"><a href=\"#标准对象\" class=\"headerlink\" title=\"标准对象\"></a>标准对象</h2><p>一些原则：</p>\n<ul>\n<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>\n<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>\n<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>\n<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>\n<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>\n<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>\n<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>\n<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>\n<p>要获取系统当前时间，用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">now; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class=\"line\">now.getFullYear(); <span class=\"comment\">// 2015, 年份</span></div><div class=\"line\">now.getMonth(); <span class=\"comment\">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class=\"line\">now.getDate(); <span class=\"comment\">// 24, 表示24号</span></div><div class=\"line\">now.getDay(); <span class=\"comment\">// 3, 表示星期三</span></div><div class=\"line\">now.getHours(); <span class=\"comment\">// 19, 24小时制</span></div><div class=\"line\">now.getMinutes(); <span class=\"comment\">// 49, 分钟</span></div><div class=\"line\">now.getSeconds(); <span class=\"comment\">// 22, 秒</span></div><div class=\"line\">now.getMilliseconds(); <span class=\"comment\">// 875, 毫秒数</span></div><div class=\"line\">now.getTime(); <span class=\"comment\">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>\n<p>如果要创建一个指定日期和时间的Date对象，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>, <span class=\"number\">30</span>, <span class=\"number\">123</span>);</div><div class=\"line\">d; <span class=\"comment\">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是<code>0~11</code>，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示<code>6</code>月，我们传入的是<code>5</code>！</p>\n<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Date</span>.parse(<span class=\"string\">'2015-06-24T19:49:22.875+08:00'</span>);</div><div class=\"line\">d; <span class=\"comment\">// 1435146562875</span></div></pre></td></tr></table></figure></p>\n<p>但它返回的不是<code>Date</code>对象，而是一个<strong>时间戳</strong>。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1435146562875</span>);</div><div class=\"line\">d; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>\n<p>要获取当前时间戳，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Date</span>.now) &#123;</div><div class=\"line\">    alert(<span class=\"built_in\">Date</span>.now()); <span class=\"comment\">// 老版本IE没有now()方法</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>JSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>\n<ul>\n<li>number：和JavaScript的<code>number</code>完全一致；</li>\n<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>\n<li>string：就是JavaScript的<code>string</code>；</li>\n<li>null：就是JavaScript的<code>null</code>；</li>\n<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>\n<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>\n</ul>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><p>先把小明这个对象序列化成JSON格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>要输出得好看一些，可以加上参数，按缩进输出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, <span class=\"literal\">null</span>, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" Middle School\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value.toUpperCase();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, convert, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码把所有属性值都变成大写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" MIDDLE SCHOOL\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JAVASCRIPT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"JAVA\"</span>,</div><div class=\"line\">    <span class=\"string\">\"PYTHON\"</span>,</div><div class=\"line\">    <span class=\"string\">\"LISP\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>],</div><div class=\"line\">    toJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"comment\">// 只输出name和age，并且改变了key：</span></div><div class=\"line\">            <span class=\"string\">'Name'</span>: <span class=\"keyword\">this</span>.name,</div><div class=\"line\">            <span class=\"string\">'Age'</span>: <span class=\"keyword\">this</span>.age</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"Name\":\"小明\",\"Age\":14&#125;'</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1,2,3,true]'</span>); <span class=\"comment\">// [1, 2, 3, true]</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>); <span class=\"comment\">// Object &#123;name: '小明', age: 14&#125;</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'123.45'</span>); <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure></p>\n<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 把number * 2:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'name'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"string\">'同学'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;); <span class=\"comment\">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>\n<p>prototype有点类似于继承，<code>A</code>的原型是<code>B</code>，意味着，<code>A</code>拥有<code>B</code>的全部属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 原型对象:</span></div><div class=\"line\"><span class=\"keyword\">var</span> Student = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Robot'</span>,</div><div class=\"line\">    height: <span class=\"number\">1.2</span>,</div><div class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running...'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStudent</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 基于Student原型创建一个新对象:</span></div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">Object</span>.create(Student);</div><div class=\"line\">    <span class=\"comment\">// 初始化新对象:</span></div><div class=\"line\">    s.name = name;</div><div class=\"line\">    <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = createStudent(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.run(); <span class=\"comment\">// 小明 is running...</span></div><div class=\"line\">xiaoming.__proto__ === Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>\n<p>例如，创建一个<code>Array</code>对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure></p>\n<p>其原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr ----&gt; <span class=\"built_in\">Array</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>\n<p>当我们创建一个函数时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数也是一个对象，它的原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo ----&gt; <span class=\"built_in\">Function</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaoming.hello(); <span class=\"comment\">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>\n<p>注意，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>\n<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.constructor === Student.prototype.constructor; <span class=\"comment\">// true</span></div><div class=\"line\">Student.prototype.constructor === Student; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">xiaoming <span class=\"keyword\">instanceof</span> Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>他们之间的关系就是:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true\" alt=\"constructor\"></p>\n<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>\n<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>\n<p>不过还有一个小问题，注意观察：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaoming.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaohong.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaoming.hello === xiaohong.hello; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>\n<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。<br>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true\" alt=\"constructor2\"><br>修改代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h3><p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n<p>我们先回顾用函数实现<code>Student</code>的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hello() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，<code>class</code>的定义包含了<strong>构造函数</strong><code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>\n<p>最后，创建一个Student对象代码和前面章节完全一样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.hello();</div></pre></td></tr></table></figure></p>\n<h4 id=\"class继承-1\"><a href=\"#class继承-1\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了,直接通过<code>extends</code>来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimaryStudent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, grade) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name); <span class=\"comment\">// 记得用super调用父类的构造方法!</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.grade = grade;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    myGrade() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'I am at grade '</span> + <span class=\"keyword\">this</span>.grade);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>super(name)</code>来调用父类的构造函数。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>\n","excerpt":"<p>参考自<a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\">廖雪峰的JavaScript教程</a></p>","more":"<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number\"></a>Number</h4><p>JS不区分整数浮点数，统一用<code>Number</code>表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.2345e3</span>; <span class=\"comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class=\"line\"><span class=\"literal\">NaN</span>; <span class=\"comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class=\"line\"><span class=\"literal\">Infinity</span>; <span class=\"comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure></p>\n<p><code>Number</code>可以直接运算：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">5</span> / <span class=\"number\">2</span>; <span class=\"comment\">// 7.5</span></div><div class=\"line\"><span class=\"number\">2</span> / <span class=\"number\">0</span>; <span class=\"comment\">// Infinity</span></div><div class=\"line\"><span class=\"number\">0</span> / <span class=\"number\">0</span>; <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"number\">10</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1 (取余)</span></div><div class=\"line\"><span class=\"number\">10.5</span> % <span class=\"number\">3</span>; <span class=\"comment\">// 1.5</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本.如<code>&#39;abc&#39;</code> </p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>用<code>true</code>和<code>false</code>表示。</p>\n<h4 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h4><p>JavaScript在设计时，有两种比较运算符：<br>第一种是<code>==</code>比较，它会自动转换数据类型再比较.<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>\n<p><code>NaN</code>这个特殊的<code>Number</code>与所有其他值都不相等，包括它自己：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span> / <span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>JavaScript的数组可以包括任意数据类型。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div></pre></td></tr></table></figure></p>\n<p>另一种创建数组的方法是通过Array()函数实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure></p>\n<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>\n<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">// 返回索引为0的元素，即1</span></div><div class=\"line\">arr[<span class=\"number\">5</span>]; <span class=\"comment\">// 返回索引为5的元素，即true</span></div><div class=\"line\">arr[<span class=\"number\">6</span>]; <span class=\"comment\">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Bob'</span>,</div><div class=\"line\">    age: <span class=\"number\">20</span>,</div><div class=\"line\">    tags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</div><div class=\"line\">    city: <span class=\"string\">'Beijing'</span>,</div><div class=\"line\">    hasCar: <span class=\"literal\">true</span>,</div><div class=\"line\">    zipcode: <span class=\"literal\">null</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>JavaScript对象的键都是<strong>字符串类型</strong>，值可以是任意数据类型。</p>\n<p>要获取一个对象的属性，我们用对象变量.属性名的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">person.name; <span class=\"comment\">// 'Bob'</span></div><div class=\"line\">person.zipcode; <span class=\"comment\">// null</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>申明一个变量用var语句，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// 申明了变量a，此时a的值为undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> $b = <span class=\"number\">1</span>; <span class=\"comment\">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class=\"line\"><span class=\"keyword\">var</span> s_007 = <span class=\"string\">'007'</span>; <span class=\"comment\">// s_007是一个字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> Answer = <span class=\"literal\">true</span>; <span class=\"comment\">// Answer是一个布尔值true</span></div><div class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"literal\">null</span>; <span class=\"comment\">// t的值是null</span></div></pre></td></tr></table></figure></p>\n<p>注意只能用var申明一次。</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。</p>\n<p>启用strict模式的方法是在JavaScript代码的第一行写上：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div></pre></td></tr></table></figure></p>\n<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>\n<h3 id=\"字符串-1\"><a href=\"#字符串-1\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好, '</span> + name + <span class=\"string\">', 你今年'</span> + age + <span class=\"string\">'岁了!'</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`你好, <span class=\"subst\">$&#123;name&#125;</span>, 你今年<span class=\"subst\">$&#123;age&#125;</span>岁了!`</span>;</div><div class=\"line\">alert(message);</div></pre></td></tr></table></figure></p>\n<h4 id=\"操作字符串\"><a href=\"#操作字符串\" class=\"headerlink\" title=\"操作字符串\"></a>操作字符串</h4><p>字符串常见的操作如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\">s.length; <span class=\"comment\">// 13</span></div></pre></td></tr></table></figure></p>\n<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello, world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s[<span class=\"number\">0</span>]; <span class=\"comment\">// 'H'</span></div><div class=\"line\">s[<span class=\"number\">6</span>]; <span class=\"comment\">// ' '</span></div><div class=\"line\">s[<span class=\"number\">7</span>]; <span class=\"comment\">// 'w'</span></div><div class=\"line\">s[<span class=\"number\">12</span>]; <span class=\"comment\">// '!'</span></div><div class=\"line\">s[<span class=\"number\">13</span>]; <span class=\"comment\">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure></p>\n<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.</p>\n<h4 id=\"toUpperCase\"><a href=\"#toUpperCase\" class=\"headerlink\" title=\"toUpperCase\"></a>toUpperCase</h4><p><code>toUpperCase()</code>返回一个全大写的字符串</p>\n<h4 id=\"toLowerCase\"><a href=\"#toLowerCase\" class=\"headerlink\" title=\"toLowerCase\"></a>toLowerCase</h4><p><code>toLowerCase()</code>f返回一个全小写的字符串</p>\n<h4 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p><code>indexOf()</code>会搜索指定字符串出现的位置:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span>;</div><div class=\"line\">s.indexOf(<span class=\"string\">'world'</span>); <span class=\"comment\">// 返回7</span></div><div class=\"line\">s.indexOf(<span class=\"string\">'World'</span>); <span class=\"comment\">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"substring\"><a href=\"#substring\" class=\"headerlink\" title=\"substring\"></a>substring</h4><p><code>substring()</code>返回指定索引区间的子串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello, world'</span></div><div class=\"line\">s.substring(<span class=\"number\">0</span>, <span class=\"number\">5</span>); <span class=\"comment\">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class=\"line\">s.substring(<span class=\"number\">7</span>); <span class=\"comment\">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3.14</span>, <span class=\"string\">'Hello'</span>, <span class=\"literal\">null</span>, <span class=\"literal\">true</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.length; <span class=\"comment\">// 3</span></div><div class=\"line\">arr.length = <span class=\"number\">6</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class=\"line\">arr.length = <span class=\"number\">2</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2]</span></div></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'x'</span>;</div><div class=\"line\">arr; <span class=\"comment\">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure></p>\n<p><strong>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>\n<h4 id=\"indexOf-1\"><a href=\"#indexOf-1\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h4><p>与<code>String</code>类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</div><div class=\"line\">arr.indexOf(<span class=\"number\">10</span>); <span class=\"comment\">// 元素10的索引为0</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">20</span>); <span class=\"comment\">// 元素20的索引为1</span></div><div class=\"line\">arr.indexOf(<span class=\"number\">30</span>); <span class=\"comment\">// 元素30没有找到，返回-1</span></div><div class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>); <span class=\"comment\">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p><code>slice()</code>就是对应<code>String</code>的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'D'</span>, <span class=\"string\">'E'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'G'</span>];</div><div class=\"line\">arr.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class=\"line\">arr.slice(<span class=\"number\">3</span>); <span class=\"comment\">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure></p>\n<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code></p>\n<h4 id=\"push和pop\"><a href=\"#push和pop\" class=\"headerlink\" title=\"push和pop\"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加<strong>若干</strong>元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.push(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A', 'B']</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// pop()返回'B'</span></div><div class=\"line\">arr; <span class=\"comment\">// [1, 2, 'A']</span></div><div class=\"line\">arr.pop(); arr.pop(); arr.pop(); <span class=\"comment\">// 连续pop 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.pop(); <span class=\"comment\">// 空数组继续pop不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"unshift和shift\"><a href=\"#unshift和shift\" class=\"headerlink\" title=\"unshift和shift\"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.unshift(<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>); <span class=\"comment\">// 返回Array新的长度: 4</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 1, 2]</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 'A'</span></div><div class=\"line\">arr; <span class=\"comment\">// ['B', 1, 2]</span></div><div class=\"line\">arr.shift(); arr.shift(); arr.shift(); <span class=\"comment\">// 连续shift 3次</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div><div class=\"line\">arr.shift(); <span class=\"comment\">// 空数组继续shift不会报错，而是返回undefined</span></div><div class=\"line\">arr; <span class=\"comment\">// []</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><p>reverse()把整个Array的元素给掉个个，也就是反转.</p>\n<h4 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class=\"line\">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class=\"line\">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只删除,不添加:</div><div class=\"line\">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class=\"line\">// 只添加,不删除:</div><div class=\"line\">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class=\"line\">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">added; <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class=\"line\">arr; <span class=\"comment\">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>\n<p>请注意，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。<br>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">arr.concat(<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure></p>\n<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>\n<h3 id=\"对象-1\"><a href=\"#对象-1\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小红'</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'No.1 Middle School'</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaohong[<span class=\"string\">'middle-school'</span>]; <span class=\"comment\">// 'No.1 Middle School'</span></div><div class=\"line\">xiaohong[<span class=\"string\">'name'</span>]; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div></pre></td></tr></table></figure></p>\n<p>如果属性名是其他对象，那么需要用<code>[]</code>将其括起来，表示对外部对象执行<code>toString()</code>操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> weight = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"1weight\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name :  <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">    [weight()] :<span class=\"string\">\"属性名是返回值1weight\"</span>,</div><div class=\"line\">    [weight]:<span class=\"string\">\"属性名是整个function\"</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(xiaoming)</div><div class=\"line\">返回：</div><div class=\"line\">&#123; name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">  <span class=\"string\">'1weight'</span>: <span class=\"string\">'属性名是返回值1weight'</span>,</div><div class=\"line\">  <span class=\"string\">'function () &#123;\\n    return \"1weight\"\\n&#125;'</span>: <span class=\"string\">'属性名是整个function'</span> &#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\">xiaoming.age = <span class=\"number\">18</span>; <span class=\"comment\">// 新增一个age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// 18</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.age; <span class=\"comment\">// 删除age属性</span></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming[<span class=\"string\">'name'</span>]; <span class=\"comment\">// 删除name属性</span></div><div class=\"line\">xiaoming.name; <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">delete</span> xiaoming.school; <span class=\"comment\">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure></p>\n<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符,不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">'toString'</span> <span class=\"keyword\">in</span> xiaoming; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span></div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'name'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">xiaoming.hasOwnProperty(<span class=\"string\">'toString'</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Map和Set\"><a href=\"#Map和Set\" class=\"headerlink\" title=\"Map和Set\"></a>Map和Set</h3><p>JS中默认对象表达方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。<br>但是JavaScript的对象有个小问题，就是<strong>键必须是字符串</strong>。但实际上Number或者其他数据类型作为键也是非常合理的。<br>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Michael'</span>, <span class=\"number\">95</span>], [<span class=\"string\">'Bob'</span>, <span class=\"number\">75</span>], [<span class=\"string\">'Tracy'</span>, <span class=\"number\">85</span>]]);</div><div class=\"line\">m.delete(<span class=\"string\">'Adam'</span>); <span class=\"comment\">// 删除key 'Adam'</span></div><div class=\"line\">m.get(<span class=\"string\">'Michael'</span>); <span class=\"comment\">// 95</span></div><div class=\"line\">m.set(<span class=\"string\">'Zachary'</span>, <span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<h4 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h4><p>重复元素在Set中自动被过滤：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"string\">'3'</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3, \"3\"&#125;</span></div></pre></td></tr></table></figure></p>\n<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>\n<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div><div class=\"line\">&gt;&gt;&gt; s.add(<span class=\"number\">4</span>)</div><div class=\"line\">&gt;&gt;&gt; s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>通过delete(key)方法可以删除元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2, 3&#125;</span></div><div class=\"line\">s.delete(<span class=\"number\">3</span>);</div><div class=\"line\">s; <span class=\"comment\">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"iterable\"><a href=\"#iterable\" class=\"headerlink\" title=\"iterable\"></a>iterable</h3><p>ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>\n<p>用<code>for ... of</code>循环遍历集合，用法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"number\">1</span>, <span class=\"string\">'x'</span>], [<span class=\"number\">2</span>, <span class=\"string\">'y'</span>], [<span class=\"number\">3</span>, <span class=\"string\">'z'</span>]]);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> a) &#123; <span class=\"comment\">// 遍历Array</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> s) &#123; <span class=\"comment\">// 遍历Set</span></div><div class=\"line\">    alert(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> m) &#123; <span class=\"comment\">// 遍历Map</span></div><div class=\"line\">    alert(x[<span class=\"number\">0</span>] + <span class=\"string\">'='</span> + x[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</strong><br><code>for ... in</code>实际上是<strong>对象的属性名称(注意，是键，不是值)</strong>。不要用在<code>Array</code>,<code>Set</code>,<code>Map</code>上，会出现奇怪的问题。<br><code>for ... of</code>循环则完全修复了这些问题，它<strong>只循环得到集合内该出现的元素(注意，是值，不是键)</strong>，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.name = <span class=\"string\">'Hello'</span>;</div><div class=\"line\">a[<span class=\"string\">'4'</span>] = <span class=\"string\">'D'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a);</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> num <span class=\"keyword\">of</span> a)&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(num)</div><div class=\"line\">&#125;</div><div class=\"line\">输出：</div><div class=\"line\">[ <span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, , <span class=\"string\">'D'</span>, name: <span class=\"string\">'Hello'</span> ]</div><div class=\"line\">A</div><div class=\"line\">B</div><div class=\"line\">C</div><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">D</div></pre></td></tr></table></figure></p>\n<p><code>name</code>由于不是正常<code>Array</code>该有的，所以在<code>for ... of</code>循环时，其对应的值不会被输出。</p>\n<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</div><div class=\"line\">a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">element, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// element: 指向当前元素的值</span></div><div class=\"line\">    <span class=\"comment\">// index: 指向当前索引</span></div><div class=\"line\">    <span class=\"comment\">// array: 指向Array对象本身</span></div><div class=\"line\">    alert(element);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>对于<code>Set</code>来说，由于没有索引，<code>index</code>也是指当前元素。<br>对于<code>Map</code>来说，<code>element</code>和<code>index</code>分别对应<code>Value</code>和<code>Key</code>.</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数定义和调用\"><a href=\"#函数定义和调用\" class=\"headerlink\" title=\"函数定义和调用\"></a>函数定义和调用</h3><h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><p>方式一：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>\n<p>方式二：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> abs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>\n<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>\n<h4 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h4><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(<span class=\"number\">10</span>, <span class=\"string\">'blablabla'</span>); <span class=\"comment\">// 返回10</span></div><div class=\"line\">abs(<span class=\"number\">-9</span>, <span class=\"string\">'haha'</span>, <span class=\"string\">'hehe'</span>, <span class=\"literal\">null</span>); <span class=\"comment\">// 返回9</span></div></pre></td></tr></table></figure></p>\n<p>传入的参数比定义的少也没有问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abs(); <span class=\"comment\">// 返回NaN</span></div></pre></td></tr></table></figure></p>\n<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>\n<p>要避免收到undefined，可以对参数进行检查：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">abs</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"keyword\">typeof</span> x) !== <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"string\">'Not a number'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -x;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    alert(x); <span class=\"comment\">// 10</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">arguments</span>.length; i++) &#123;</div><div class=\"line\">        alert(<span class=\"built_in\">arguments</span>[i]); <span class=\"comment\">// 10, 20, 30</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">foo(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</div></pre></td></tr></table></figure></p>\n<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。</p>\n<h4 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h4><p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数.<br>ES6标准引入了<code>rest</code>参数，可以将剩余的参数放在<code>rest</code>中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b, ...rest</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a = '</span> + a);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b = '</span> + b);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(rest);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = 2</span></div><div class=\"line\"><span class=\"comment\">// Array [ 3, 4, 5 ]</span></div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">// 结果:</span></div><div class=\"line\"><span class=\"comment\">// a = 1</span></div><div class=\"line\"><span class=\"comment\">// b = undefined</span></div><div class=\"line\"><span class=\"comment\">// Array []</span></div></pre></td></tr></table></figure></p>\n<p><code>rest</code>参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。<br>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code>参数会接收一个空数组（注意不是<code>undefined</code>）。</p>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>\n<ul>\n<li>如果一个变量在函数体内部申明，则该变量的作用域为整个<strong>函数体</strong>(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。</li>\n<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量</li>\n<li>如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>\n</ul>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">'Hello, '</span> + y;</div><div class=\"line\">    alert(x);</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"string\">'Bob'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure></p>\n<p>虽然是<code>strict</code>模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>\n<h4 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。</p>\n<h4 id=\"名字空间\"><a href=\"#名字空间\" class=\"headerlink\" title=\"名字空间\"></a>名字空间</h4><p>不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 唯一的全局变量MYAPP:</span></div><div class=\"line\"><span class=\"keyword\">var</span> MYAPP = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他变量:</span></div><div class=\"line\">MYAPP.name = <span class=\"string\">'myapp'</span>;</div><div class=\"line\">MYAPP.version = <span class=\"number\">1.0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 其他函数:</span></div><div class=\"line\">MYAPP.foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>\n<h4 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        <span class=\"comment\">//</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">100</span>; <span class=\"comment\">// 仍然可以引用变量i</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\">        sum += i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    i += <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><p>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.</p>\n<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.14</span>;</div><div class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 某些浏览器不报错，但是无效果！</span></div><div class=\"line\">PI; <span class=\"comment\">// 3.14</span></div></pre></td></tr></table></figure></p>\n<p>注意，一定要加上<code>use strict</code>,否则会报错。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>绑定到对象上的函数称为方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">        <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age; <span class=\"comment\">// function xiaoming.age()</span></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure></p>\n<p>和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.<br>在一个方法内部，<code>this</code>是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>\n<p>让我们拆开写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25, 正常结果</span></div><div class=\"line\">getAge(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？请注意，我们已经进入到了JavaScript的一个大坑里。<br>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？<br>答案是，视情况而定！<br>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。<br>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向<strong>全局对象</strong>.</p>\n<p>更坑爹的是，如果这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fn = xiaoming.age; <span class=\"comment\">// 先拿到xiaoming的age函数</span></div><div class=\"line\">fn(); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure></p>\n<p>也是不行的！要保证<code>this</code>指向正确，必须要给出明确的上下文，必须用<code>obj.xxx()</code>的形式调用！谁调用，<code>this</code>就是指谁。上面仅仅相当于将<code>age</code>方法赋给<code>fn</code>.</p>\n<p>如果是这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age();</div></pre></td></tr></table></figure></p>\n<p>又不对了。原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！需要这样修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; <span class=\"comment\">// 在方法内部一开始就捕获this</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAgeFromBirth</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">            <span class=\"keyword\">return</span> y - that.birth; <span class=\"comment\">// 用that而不是this</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<p>用<code>var that = this</code>;将<code>age</code>中的<code>this</code>捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p>我们还是可以控制<code>this</code>的指向的！</p>\n<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>\n<p>用<code>apply</code>修复<code>getAge()</code>调用:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear();</div><div class=\"line\">    <span class=\"keyword\">return</span> y - <span class=\"keyword\">this</span>.birth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    birth: <span class=\"number\">1990</span>,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">xiaoming.age(); <span class=\"comment\">// 25</span></div><div class=\"line\">getAge.apply(xiaoming, []); <span class=\"comment\">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>\n<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>\n<ul>\n<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>\n<li><code>call()</code>把参数按顺序传入。 </li>\n</ul>\n<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>]); <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"literal\">null</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure></p>\n<p>对普通函数调用，我们通常把this绑定为null。</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>\n<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新指向新的函数</strong>。</p>\n<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> oldParseInt = <span class=\"built_in\">parseInt</span>; <span class=\"comment\">// 保存原函数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.parseInt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    count += <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> oldParseInt.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// 调用原函数</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 测试:</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'10'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'20'</span>);</div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'30'</span>);</div><div class=\"line\">count; <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>一个可以接收另一个函数作为参的函数，称为高阶函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p><code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pow</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.map(pow); <span class=\"comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure></p>\n<p><code>map()</code>将传入的函数一一作用在数组的每一个元素上。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p><code>Array</code>的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<p>比如对<code>Array</code>求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>];</div><div class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素<br><code>Array</code>的<code>filter()</code>接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> r = arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> !== <span class=\"number\">0</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">r; <span class=\"comment\">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sort-1\"><a href=\"#sort-1\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>可以接收一个比较函数来实现自定义的排序<br>要按数字大小排序，我们可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (x &gt; y) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;); <span class=\"comment\">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>比如返回一个求和的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazy_sum</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = lazy_sum([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// function sum()</span></div></pre></td></tr></table></figure></p>\n<p>调用函数f时，才真正计算求和的结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f(); <span class=\"comment\">// 15</span></div></pre></td></tr></table></figure></p>\n<p>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中<code>this</code>不遵循闭包)</p>\n<h4 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> i * i;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div></pre></td></tr></table></figure></p>\n<p>上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，<strong>或者说返回了三个闭包</strong>.<br>调用的结果全是<code>16</code>,因为返回函数都引用了变量<code>i</code>，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了<code>4</code>。</p>\n<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> n * n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> results = count();</div><div class=\"line\"><span class=\"keyword\">var</span> f1 = results[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f2 = results[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> f3 = results[<span class=\"number\">2</span>];</div><div class=\"line\"></div><div class=\"line\">f1(); <span class=\"comment\">// 1</span></div><div class=\"line\">f2(); <span class=\"comment\">// 4</span></div><div class=\"line\">f3(); <span class=\"comment\">// 9</span></div></pre></td></tr></table></figure></p>\n<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;)(3); // 9</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：</div><div class=\"line\">```javascript</div><div class=\"line\">function count() &#123;</div><div class=\"line\">    var arr = [];</div><div class=\"line\">    for (var i=1; i&lt;=3; i++) &#123;</div><div class=\"line\">        arr.push((function () &#123;</div><div class=\"line\">            var n =i</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                return n*n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>相反的，如果内存函数还是用的<code>i</code>，那么结果就会全是<code>16</code>.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">3</span>; i++) &#123;</div><div class=\"line\">        arr.push((<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// var n =i</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> i*i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">x =&gt; x*x</div></pre></td></tr></table></figure></p>\n<p>相当于一个输入为<code>x</code>输出为<code>x*x</code>的匿名函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function (x) &#123;</div><div class=\"line\">    return x * x;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果参数不是一个，就需要用括号()括起来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 两个参数:</span></div><div class=\"line\">(x, y) =&gt; x * x + y * y</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 无参数:</span></div><div class=\"line\">() =&gt; <span class=\"number\">3.14</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 可变参数:</span></div><div class=\"line\">(x, y, ...rest) =&gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> i, sum = x + y;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;rest.length; i++) &#123;</div><div class=\"line\">        sum += rest[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>语法糖，类似于python中的lambda函数</p>\n<p>当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。<br>试做比较：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = function () &#123;</div><div class=\"line\">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class=\"line\">        &#125;;</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div></pre></td></tr></table></figure></p>\n<p>如果使用箭头函数,以前<code>var that = this;</code>这种写法就不需要了。</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>generator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。</p>\n<p>定义如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。好处就是<strong>函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。</strong>(其实这东西很像调试函数时候的断点！)</p>\n<p>执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = fib(<span class=\"number\">5</span>);</div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 0, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></div><div class=\"line\">f.next(); <span class=\"comment\">// &#123;value: 1, done: true&#125;</span></div></pre></td></tr></table></figure></p>\n<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>\n<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> x <span class=\"keyword\">of</span> fib(<span class=\"number\">5</span>)) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// 依次输出0, 1, 1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<strong>看起来蛮有用的</strong></p>\n<p>举个例子，要生成一个自增的ID，可以编写一个next_id()函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> current_id = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    current_id ++;</div><div class=\"line\">    <span class=\"keyword\">return</span> current_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。现在改用generator：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">next_id</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">    \t<span class=\"keyword\">yield</span> ++i;</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"标准对象\"><a href=\"#标准对象\" class=\"headerlink\" title=\"标准对象\"></a>标准对象</h2><p>一些原则：</p>\n<ul>\n<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>\n<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>\n<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>\n<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>\n<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>\n<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>\n<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>\n<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>\n</ul>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>\n<p>要获取系统当前时间，用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">now; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class=\"line\">now.getFullYear(); <span class=\"comment\">// 2015, 年份</span></div><div class=\"line\">now.getMonth(); <span class=\"comment\">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class=\"line\">now.getDate(); <span class=\"comment\">// 24, 表示24号</span></div><div class=\"line\">now.getDay(); <span class=\"comment\">// 3, 表示星期三</span></div><div class=\"line\">now.getHours(); <span class=\"comment\">// 19, 24小时制</span></div><div class=\"line\">now.getMinutes(); <span class=\"comment\">// 49, 分钟</span></div><div class=\"line\">now.getSeconds(); <span class=\"comment\">// 22, 秒</span></div><div class=\"line\">now.getMilliseconds(); <span class=\"comment\">// 875, 毫秒数</span></div><div class=\"line\">now.getTime(); <span class=\"comment\">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>\n<p>如果要创建一个指定日期和时间的Date对象，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>, <span class=\"number\">30</span>, <span class=\"number\">123</span>);</div><div class=\"line\">d; <span class=\"comment\">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是<code>0~11</code>，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示<code>6</code>月，我们传入的是<code>5</code>！</p>\n<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"built_in\">Date</span>.parse(<span class=\"string\">'2015-06-24T19:49:22.875+08:00'</span>);</div><div class=\"line\">d; <span class=\"comment\">// 1435146562875</span></div></pre></td></tr></table></figure></p>\n<p>但它返回的不是<code>Date</code>对象，而是一个<strong>时间戳</strong>。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"number\">1435146562875</span>);</div><div class=\"line\">d; <span class=\"comment\">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>\n<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>\n<p>要获取当前时间戳，可以用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Date</span>.now) &#123;</div><div class=\"line\">    alert(<span class=\"built_in\">Date</span>.now()); <span class=\"comment\">// 老版本IE没有now()方法</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    alert(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Json\"><a href=\"#Json\" class=\"headerlink\" title=\"Json\"></a>Json</h3><p>JSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>\n<ul>\n<li>number：和JavaScript的<code>number</code>完全一致；</li>\n<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>\n<li>string：就是JavaScript的<code>string</code>；</li>\n<li>null：就是JavaScript的<code>null</code>；</li>\n<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>\n<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>\n</ul>\n<h4 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h4><p>先把小明这个对象序列化成JSON格式的字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>要输出得好看一些，可以加上参数，按缩进输出：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, <span class=\"literal\">null</span>, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" Middle School\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div></pre></td></tr></table></figure></p>\n<p>结果:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JavaScript\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Java\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Python\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Lisp\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convert</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value.toUpperCase();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming, convert, <span class=\"string\">'  '</span>);</div></pre></td></tr></table></figure></p>\n<p>上面的代码把所有属性值都变成大写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"小明\"</span>,</div><div class=\"line\">  <span class=\"string\">\"age\"</span>: <span class=\"number\">14</span>,</div><div class=\"line\">  <span class=\"string\">\"gender\"</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"string\">\"height\"</span>: <span class=\"number\">1.65</span>,</div><div class=\"line\">  <span class=\"string\">\"grade\"</span>: <span class=\"literal\">null</span>,</div><div class=\"line\">  <span class=\"string\">\"middle-school\"</span>: <span class=\"string\">\"\\\"W3C\\\" MIDDLE SCHOOL\"</span>,</div><div class=\"line\">  <span class=\"string\">\"skills\"</span>: [</div><div class=\"line\">    <span class=\"string\">\"JAVASCRIPT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"JAVA\"</span>,</div><div class=\"line\">    <span class=\"string\">\"PYTHON\"</span>,</div><div class=\"line\">    <span class=\"string\">\"LISP\"</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = &#123;</div><div class=\"line\">    name: <span class=\"string\">'小明'</span>,</div><div class=\"line\">    age: <span class=\"number\">14</span>,</div><div class=\"line\">    gender: <span class=\"literal\">true</span>,</div><div class=\"line\">    height: <span class=\"number\">1.65</span>,</div><div class=\"line\">    grade: <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'middle-school'</span>: <span class=\"string\">'\\\"W3C\\\" Middle School'</span>,</div><div class=\"line\">    skills: [<span class=\"string\">'JavaScript'</span>, <span class=\"string\">'Java'</span>, <span class=\"string\">'Python'</span>, <span class=\"string\">'Lisp'</span>],</div><div class=\"line\">    toJSON: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"comment\">// 只输出name和age，并且改变了key：</span></div><div class=\"line\">            <span class=\"string\">'Name'</span>: <span class=\"keyword\">this</span>.name,</div><div class=\"line\">            <span class=\"string\">'Age'</span>: <span class=\"keyword\">this</span>.age</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">JSON</span>.stringify(xiaoming); <span class=\"comment\">// '&#123;\"Name\":\"小明\",\"Age\":14&#125;'</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1,2,3,true]'</span>); <span class=\"comment\">// [1, 2, 3, true]</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>); <span class=\"comment\">// Object &#123;name: '小明', age: 14&#125;</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'123.45'</span>); <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure></p>\n<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"name\":\"小明\",\"age\":14&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 把number * 2:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">'name'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"string\">'同学'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;); <span class=\"comment\">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>\n<p>prototype有点类似于继承，<code>A</code>的原型是<code>B</code>，意味着，<code>A</code>拥有<code>B</code>的全部属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 原型对象:</span></div><div class=\"line\"><span class=\"keyword\">var</span> Student = &#123;</div><div class=\"line\">    name: <span class=\"string\">'Robot'</span>,</div><div class=\"line\">    height: <span class=\"number\">1.2</span>,</div><div class=\"line\">    run: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running...'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStudent</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 基于Student原型创建一个新对象:</span></div><div class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">Object</span>.create(Student);</div><div class=\"line\">    <span class=\"comment\">// 初始化新对象:</span></div><div class=\"line\">    s.name = name;</div><div class=\"line\">    <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = createStudent(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.run(); <span class=\"comment\">// 小明 is running...</span></div><div class=\"line\">xiaoming.__proto__ === Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>\n<p>例如，创建一个<code>Array</code>对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure></p>\n<p>其原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">arr ----&gt; <span class=\"built_in\">Array</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>\n<p>当我们创建一个函数时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>函数也是一个对象，它的原型链是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo ----&gt; <span class=\"built_in\">Function</span>.prototype ----&gt; <span class=\"built_in\">Object</span>.prototype ----&gt; <span class=\"literal\">null</span></div></pre></td></tr></table></figure></p>\n<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaoming.hello(); <span class=\"comment\">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>\n<p>注意，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>\n<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.constructor === Student.prototype.constructor; <span class=\"comment\">// true</span></div><div class=\"line\">Student.prototype.constructor === Student; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">xiaoming <span class=\"keyword\">instanceof</span> Student; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p>他们之间的关系就是:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true\" alt=\"constructor\"></p>\n<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>\n<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>\n<p>不过还有一个小问题，注意观察：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming.name; <span class=\"comment\">// '小明'</span></div><div class=\"line\">xiaohong.name; <span class=\"comment\">// '小红'</span></div><div class=\"line\">xiaoming.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaohong.hello; <span class=\"comment\">// function: Student.hello()</span></div><div class=\"line\">xiaoming.hello === xiaohong.hello; <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>\n<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。<br>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true\" alt=\"constructor2\"><br>修改代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Student</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"class继承\"><a href=\"#class继承\" class=\"headerlink\" title=\"class继承\"></a>class继承</h3><p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n<p>我们先回顾用函数实现<code>Student</code>的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    hello() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>比较一下就可以发现，<code>class</code>的定义包含了<strong>构造函数</strong><code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>\n<p>最后，创建一个Student对象代码和前面章节完全一样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> xiaoming = <span class=\"keyword\">new</span> Student(<span class=\"string\">'小明'</span>);</div><div class=\"line\">xiaoming.hello();</div></pre></td></tr></table></figure></p>\n<h4 id=\"class继承-1\"><a href=\"#class继承-1\" class=\"headerlink\" title=\"class继承\"></a>class继承</h4><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了,直接通过<code>extends</code>来实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimaryStudent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, grade) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name); <span class=\"comment\">// 记得用super调用父类的构造方法!</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.grade = grade;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    myGrade() &#123;</div><div class=\"line\">        alert(<span class=\"string\">'I am at grade '</span> + <span class=\"keyword\">this</span>.grade);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>super(name)</code>来调用父类的构造函数。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>"},{"title":"NSLayoutConstraint 学习笔记","date":"2016-09-08T02:07:12.000Z","_content":"\n`AutoLayout`是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。\n参考与[AutoLayout详解](http://www.jianshu.com/p/79f92139ffdf)\n\n<!--more-->\n\n## 代码添加AutoLayout\n### 关闭Autoresizing\n`AutoLayout`旨在替代`Autoresizing`，所以在同一个项目中，`AutoLayout`和`Autoresizing`是不能共存的。要实现自动布局，必须关掉view的`AutoresizeingMask`\n\n```objc\nview.translatesAutoresizingMaskIntoConstraints = NO;\n```\n这里的view指的是需要添加约束的view。\n\n### NSLayoutConstraint相关\n#### 约束方法\n```objc\n+(instancetype)constraintWithItem:(id)view1                  //被约束的视图一\n                        attribute:(NSLayoutAttribute)attr1   //view1的属性\n                        relatedBy:(NSLayoutRelation)relation //左右视图的关系\n                           toItem:(id)view2                  //被约束的视图二\n                        attribute:(NSLayoutAttribute)attr2   //view2的属性\n                       multiplier:(CGFloat)multiplier        //乘数\n                         constant:(CGFloat)c;                //常量\n```\n\n公式是这样的：`view1.attr1 = view2.attr2 * multiplier + constant`\n\n#### NSLayoutAttribute属性\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    NSLayoutAttributeLeft = 1, //左边\n    NSLayoutAttributeRight,    //右边\n    NSLayoutAttributeTop,      //顶部\n    NSLayoutAttributeBottom,   //底部\n    NSLayoutAttributeLeading,  //首部\n    NSLayoutAttributeTrailing, //尾部\n    NSLayoutAttributeWidth,    //宽度\n    NSLayoutAttributeHeight,   //高度\n    NSLayoutAttributeCenterX,  //X轴中心\n    NSLayoutAttributeCenterY,  //Y轴中心\n    NSLayoutAttributeBaseline, //基线\n    NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline,\n    NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0),\n\n    //iOS8的暂时没有研究\n    NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n\n    NSLayoutAttributeNotAnAttribute = 0 //无属性\n};\n```\n\n#### NSLayoutRelation关系\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    NSLayoutRelationLessThanOrEqual = -1,   //小于等于\n    NSLayoutRelationEqual = 0,              //等于\n    NSLayoutRelationGreaterThanOrEqual = 1, //大于等于\n};\n```\n\n### 创建view\n```objc\n//创建view\nUIView *view = [[UIView alloc] init]; //这里不需要设置frame\nview.backgroundColor = [UIColor brownColor];\nview.translatesAutoresizingMaskIntoConstraints = NO; //要实现自动布局，必须把该属性设置为NO\n[self.view addSubview:view];\n\n//添加约束\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeLeft\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeLeft\n                             multiplier:1\n                               constant:20]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeRight\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeRight\n                             multiplier:1\n                               constant:-10]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeTop\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeTop\n                             multiplier:1\n                               constant:30]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeBottom\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeBottom\n                             multiplier:1\n                               constant:-20]];\n```\n\n### 添加约束的规则\n- 对于两个同层级view之间的约束关系，添加到它们的父view上\n- 对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上\n- 对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上\n\n### Autolayout来实现动画功能\n在执行动画时记得调用一下方法：\n```objc\n//在修改了约束之后，只要执行下面代码，就能做动画效果\n[UIView animateWithDuration:0.5 animations:^{\n      [self.view layoutIfNeeded];\n}];\n```\n\n## 第三方框架实现AutoLayout\nMasonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。\n### 框架导入\n这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。\n#### 创建Podfile\n在工程的目录下新建Podfile文件，写入我们需要的第三方库：\n```objc\ntarget 'NSLayoutConstraintDemo' do\npod 'Masonry'\nend\n```\n\n#### 导入第三方库\n进入终端，运行命令`pod install`,导入第三方库。\n\n### Masonry基本使用\n最基本的使用方式：\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.属性.equalTo(另一个view).with.insets(差值);\n}];\n```\n\n### Masonry属性\n```objc\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n@property (nonatomic, strong, readonly) MASConstraint *leading;\n@property (nonatomic, strong, readonly) MASConstraint *trailing;\n@property (nonatomic, strong, readonly) MASConstraint *width;\n@property (nonatomic, strong, readonly) MASConstraint *height;\n@property (nonatomic, strong, readonly) MASConstraint *centerX;\n@property (nonatomic, strong, readonly) MASConstraint *centerY;\n@property (nonatomic, strong, readonly) MASConstraint *baseline;\n```\n其中leading与left trailing与right 在正常情况下是等价的。\n### 使用实例\n居中显示一个view：\n```objc\n//从此以后基本可以抛弃CGRectMake了\nUIView *sv = [UIView new];\n\n//在做autoLayout之前 一定要先将view添加到superview上 否则会报错\n[self.view addSubview:sv];\n\n//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了\n[sv mas_makeConstraints:^(MASConstraintMaker *make) {\n\n    //将sv居中(很容易理解吧?)\n    make.center.equalTo(self.view);\n    \n    //将size设置成(300,300)\n    make.size.mas_equalTo(CGSizeMake(300, 300));\n}];\n```\n\n### 方法简析\n#### 添加autolayout约束\n有三个可以添加约束的方法：\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;\n\n/*\n    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 \n    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况\n    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束\n    \n    三种函数善加利用 就可以应对各种情况了\n*/\n```\n\n#### equalTo 和 mas_equalTo的区别\n`mas_equalTo`只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了`NSNumber`支持的那些数值类型之外 就只支持`CGPoint` `CGSize` `UIEdgeInsets`\n\n### 另一个示例\n```objc\nUIView *sv1 = [UIView new];\n[sv1 showPlaceHolder];\nsv1.backgroundColor = [UIColor redColor];\n[sv addSubview:sv1];\n[sv1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    \n    /* 等价于\n    make.top.equalTo(sv).with.offset(10);\n    make.left.equalTo(sv).with.offset(10);\n    make.bottom.equalTo(sv).with.offset(-10);\n    make.right.equalTo(sv).with.offset(-10);\n    */\n    \n    /* 也等价于\n    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    */\n}];\n```\n可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.\n\n这里and和with 两个函数什么事情都没做.\n\n### 还有一个示例\n```objc\nUIView *lastView = nil;\n    \nfor ( int i = 1 ; i <= count ; ++i ){\n    UIView *subv = [UIView new];\n    [container addSubview:subv];\n    subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 )\n                                      saturation:( arc4random() % 128 / 256.0 ) + 0.5\n                                      brightness:( arc4random() % 128 / 256.0 ) + 0.5\n                                           alpha:1];\n        \n    [subv mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.and.right.equalTo(container);\n        make.height.mas_equalTo(@(20*i));\n           \n        if ( lastView ){\n            make.top.mas_equalTo(lastView.mas_bottom);\n        }\n        else{\n            make.top.mas_equalTo(container.mas_top);\n        }\n    }];\n       \n    lastView = subv;\n}\n   \n    \n[container mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.equalTo(lastView.mas_bottom);\n}];\n```\n\n框架通过范畴为UIView添加了`mas_bottom`、`mas_top`等属性，用来表示view的上下左右的位置。这样，有利于**在view之间的约束条件的建立**，之前的示例都是view与父view的约束关系。\n\n还有一些其他的示例，可以参见[Masonry介绍与使用实践](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)\n\n>Demo 详见NSLayoutConstraintDemo\n\n\n\n\n\n","source":"_posts/NSLayoutConstraint.md","raw":"title: NSLayoutConstraint 学习笔记\ndate: 2016/9/8 10:07:12  \ncategories: IOS\ntags:\n\t- AutoLayout\n\n---\n\n`AutoLayout`是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。\n参考与[AutoLayout详解](http://www.jianshu.com/p/79f92139ffdf)\n\n<!--more-->\n\n## 代码添加AutoLayout\n### 关闭Autoresizing\n`AutoLayout`旨在替代`Autoresizing`，所以在同一个项目中，`AutoLayout`和`Autoresizing`是不能共存的。要实现自动布局，必须关掉view的`AutoresizeingMask`\n\n```objc\nview.translatesAutoresizingMaskIntoConstraints = NO;\n```\n这里的view指的是需要添加约束的view。\n\n### NSLayoutConstraint相关\n#### 约束方法\n```objc\n+(instancetype)constraintWithItem:(id)view1                  //被约束的视图一\n                        attribute:(NSLayoutAttribute)attr1   //view1的属性\n                        relatedBy:(NSLayoutRelation)relation //左右视图的关系\n                           toItem:(id)view2                  //被约束的视图二\n                        attribute:(NSLayoutAttribute)attr2   //view2的属性\n                       multiplier:(CGFloat)multiplier        //乘数\n                         constant:(CGFloat)c;                //常量\n```\n\n公式是这样的：`view1.attr1 = view2.attr2 * multiplier + constant`\n\n#### NSLayoutAttribute属性\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutAttribute) {\n    NSLayoutAttributeLeft = 1, //左边\n    NSLayoutAttributeRight,    //右边\n    NSLayoutAttributeTop,      //顶部\n    NSLayoutAttributeBottom,   //底部\n    NSLayoutAttributeLeading,  //首部\n    NSLayoutAttributeTrailing, //尾部\n    NSLayoutAttributeWidth,    //宽度\n    NSLayoutAttributeHeight,   //高度\n    NSLayoutAttributeCenterX,  //X轴中心\n    NSLayoutAttributeCenterY,  //Y轴中心\n    NSLayoutAttributeBaseline, //基线\n    NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline,\n    NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0),\n\n    //iOS8的暂时没有研究\n    NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n    NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0),\n\n    NSLayoutAttributeNotAnAttribute = 0 //无属性\n};\n```\n\n#### NSLayoutRelation关系\n```objc\ntypedef NS_ENUM(NSInteger, NSLayoutRelation) {\n    NSLayoutRelationLessThanOrEqual = -1,   //小于等于\n    NSLayoutRelationEqual = 0,              //等于\n    NSLayoutRelationGreaterThanOrEqual = 1, //大于等于\n};\n```\n\n### 创建view\n```objc\n//创建view\nUIView *view = [[UIView alloc] init]; //这里不需要设置frame\nview.backgroundColor = [UIColor brownColor];\nview.translatesAutoresizingMaskIntoConstraints = NO; //要实现自动布局，必须把该属性设置为NO\n[self.view addSubview:view];\n\n//添加约束\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeLeft\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeLeft\n                             multiplier:1\n                               constant:20]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeRight\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeRight\n                             multiplier:1\n                               constant:-10]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeTop\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeTop\n                             multiplier:1\n                               constant:30]];\n[self.view addConstraint:\n [NSLayoutConstraint constraintWithItem:view\n                              attribute:NSLayoutAttributeBottom\n                              relatedBy:NSLayoutRelationEqual\n                                 toItem:self.view\n                              attribute:NSLayoutAttributeBottom\n                             multiplier:1\n                               constant:-20]];\n```\n\n### 添加约束的规则\n- 对于两个同层级view之间的约束关系，添加到它们的父view上\n- 对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上\n- 对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上\n\n### Autolayout来实现动画功能\n在执行动画时记得调用一下方法：\n```objc\n//在修改了约束之后，只要执行下面代码，就能做动画效果\n[UIView animateWithDuration:0.5 animations:^{\n      [self.view layoutIfNeeded];\n}];\n```\n\n## 第三方框架实现AutoLayout\nMasonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。\n### 框架导入\n这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。\n#### 创建Podfile\n在工程的目录下新建Podfile文件，写入我们需要的第三方库：\n```objc\ntarget 'NSLayoutConstraintDemo' do\npod 'Masonry'\nend\n```\n\n#### 导入第三方库\n进入终端，运行命令`pod install`,导入第三方库。\n\n### Masonry基本使用\n最基本的使用方式：\n```objc\n[view1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.属性.equalTo(另一个view).with.insets(差值);\n}];\n```\n\n### Masonry属性\n```objc\n@property (nonatomic, strong, readonly) MASConstraint *left;\n@property (nonatomic, strong, readonly) MASConstraint *top;\n@property (nonatomic, strong, readonly) MASConstraint *right;\n@property (nonatomic, strong, readonly) MASConstraint *bottom;\n@property (nonatomic, strong, readonly) MASConstraint *leading;\n@property (nonatomic, strong, readonly) MASConstraint *trailing;\n@property (nonatomic, strong, readonly) MASConstraint *width;\n@property (nonatomic, strong, readonly) MASConstraint *height;\n@property (nonatomic, strong, readonly) MASConstraint *centerX;\n@property (nonatomic, strong, readonly) MASConstraint *centerY;\n@property (nonatomic, strong, readonly) MASConstraint *baseline;\n```\n其中leading与left trailing与right 在正常情况下是等价的。\n### 使用实例\n居中显示一个view：\n```objc\n//从此以后基本可以抛弃CGRectMake了\nUIView *sv = [UIView new];\n\n//在做autoLayout之前 一定要先将view添加到superview上 否则会报错\n[self.view addSubview:sv];\n\n//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了\n[sv mas_makeConstraints:^(MASConstraintMaker *make) {\n\n    //将sv居中(很容易理解吧?)\n    make.center.equalTo(self.view);\n    \n    //将size设置成(300,300)\n    make.size.mas_equalTo(CGSizeMake(300, 300));\n}];\n```\n\n### 方法简析\n#### 添加autolayout约束\n有三个可以添加约束的方法：\n```objc\n- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;\n- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;\n\n/*\n    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 \n    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况\n    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束\n    \n    三种函数善加利用 就可以应对各种情况了\n*/\n```\n\n#### equalTo 和 mas_equalTo的区别\n`mas_equalTo`只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了`NSNumber`支持的那些数值类型之外 就只支持`CGPoint` `CGSize` `UIEdgeInsets`\n\n### 另一个示例\n```objc\nUIView *sv1 = [UIView new];\n[sv1 showPlaceHolder];\nsv1.backgroundColor = [UIColor redColor];\n[sv addSubview:sv1];\n[sv1 mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    \n    /* 等价于\n    make.top.equalTo(sv).with.offset(10);\n    make.left.equalTo(sv).with.offset(10);\n    make.bottom.equalTo(sv).with.offset(-10);\n    make.right.equalTo(sv).with.offset(-10);\n    */\n    \n    /* 也等价于\n    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));\n    */\n}];\n```\n可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.\n\n这里and和with 两个函数什么事情都没做.\n\n### 还有一个示例\n```objc\nUIView *lastView = nil;\n    \nfor ( int i = 1 ; i <= count ; ++i ){\n    UIView *subv = [UIView new];\n    [container addSubview:subv];\n    subv.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 )\n                                      saturation:( arc4random() % 128 / 256.0 ) + 0.5\n                                      brightness:( arc4random() % 128 / 256.0 ) + 0.5\n                                           alpha:1];\n        \n    [subv mas_makeConstraints:^(MASConstraintMaker *make) {\n        make.left.and.right.equalTo(container);\n        make.height.mas_equalTo(@(20*i));\n           \n        if ( lastView ){\n            make.top.mas_equalTo(lastView.mas_bottom);\n        }\n        else{\n            make.top.mas_equalTo(container.mas_top);\n        }\n    }];\n       \n    lastView = subv;\n}\n   \n    \n[container mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.bottom.equalTo(lastView.mas_bottom);\n}];\n```\n\n框架通过范畴为UIView添加了`mas_bottom`、`mas_top`等属性，用来表示view的上下左右的位置。这样，有利于**在view之间的约束条件的建立**，之前的示例都是view与父view的约束关系。\n\n还有一些其他的示例，可以参见[Masonry介绍与使用实践](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)\n\n>Demo 详见NSLayoutConstraintDemo\n\n\n\n\n\n","slug":"NSLayoutConstraint","published":1,"updated":"2016-09-09T02:05:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzv90009rgruj7uaog0x","content":"<p><code>AutoLayout</code>是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。<br>参考与<a href=\"http://www.jianshu.com/p/79f92139ffdf\" target=\"_blank\" rel=\"external\">AutoLayout详解</a></p>\n<a id=\"more\"></a>\n<h2 id=\"代码添加AutoLayout\"><a href=\"#代码添加AutoLayout\" class=\"headerlink\" title=\"代码添加AutoLayout\"></a>代码添加AutoLayout</h2><h3 id=\"关闭Autoresizing\"><a href=\"#关闭Autoresizing\" class=\"headerlink\" title=\"关闭Autoresizing\"></a>关闭Autoresizing</h3><p><code>AutoLayout</code>旨在替代<code>Autoresizing</code>，所以在同一个项目中，<code>AutoLayout</code>和<code>Autoresizing</code>是不能共存的。要实现自动布局，必须关掉view的<code>AutoresizeingMask</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</div></pre></td></tr></table></figure>\n<p>这里的view指的是需要添加约束的view。</p>\n<h3 id=\"NSLayoutConstraint相关\"><a href=\"#NSLayoutConstraint相关\" class=\"headerlink\" title=\"NSLayoutConstraint相关\"></a>NSLayoutConstraint相关</h3><h4 id=\"约束方法\"><a href=\"#约束方法\" class=\"headerlink\" title=\"约束方法\"></a>约束方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"keyword\">instancetype</span>)constraintWithItem:(<span class=\"keyword\">id</span>)view1                  <span class=\"comment\">//被约束的视图一</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr1   <span class=\"comment\">//view1的属性</span></div><div class=\"line\">                        relatedBy:(<span class=\"built_in\">NSLayoutRelation</span>)relation <span class=\"comment\">//左右视图的关系</span></div><div class=\"line\">                           toItem:(<span class=\"keyword\">id</span>)view2                  <span class=\"comment\">//被约束的视图二</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr2   <span class=\"comment\">//view2的属性</span></div><div class=\"line\">                       multiplier:(<span class=\"built_in\">CGFloat</span>)multiplier        <span class=\"comment\">//乘数</span></div><div class=\"line\">                         constant:(<span class=\"built_in\">CGFloat</span>)c;                <span class=\"comment\">//常量</span></div></pre></td></tr></table></figure>\n<p>公式是这样的：<code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<h4 id=\"NSLayoutAttribute属性\"><a href=\"#NSLayoutAttribute属性\" class=\"headerlink\" title=\"NSLayoutAttribute属性\"></a>NSLayoutAttribute属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutAttribute</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeft</span> = <span class=\"number\">1</span>, <span class=\"comment\">//左边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRight</span>,    <span class=\"comment\">//右边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTop</span>,      <span class=\"comment\">//顶部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottom</span>,   <span class=\"comment\">//底部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeading</span>,  <span class=\"comment\">//首部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailing</span>, <span class=\"comment\">//尾部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeWidth</span>,    <span class=\"comment\">//宽度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeHeight</span>,   <span class=\"comment\">//高度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterX</span>,  <span class=\"comment\">//X轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterY</span>,  <span class=\"comment\">//Y轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBaseline</span>, <span class=\"comment\">//基线</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLastBaseline</span> = <span class=\"built_in\">NSLayoutAttributeBaseline</span>,</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeFirstBaseline</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//iOS8的暂时没有研究</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeftMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRightMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTopMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottomMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeadingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterXWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterYWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span> = <span class=\"number\">0</span> <span class=\"comment\">//无属性</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"NSLayoutRelation关系\"><a href=\"#NSLayoutRelation关系\" class=\"headerlink\" title=\"NSLayoutRelation关系\"></a>NSLayoutRelation关系</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutRelation</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationLessThanOrEqual</span> = <span class=\"number\">-1</span>,   <span class=\"comment\">//小于等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationEqual</span> = <span class=\"number\">0</span>,              <span class=\"comment\">//等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span> = <span class=\"number\">1</span>, <span class=\"comment\">//大于等于</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"创建view\"><a href=\"#创建view\" class=\"headerlink\" title=\"创建view\"></a>创建view</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建view</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] init]; <span class=\"comment\">//这里不需要设置frame</span></div><div class=\"line\">view.backgroundColor = [<span class=\"built_in\">UIColor</span> brownColor];</div><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>; <span class=\"comment\">//要实现自动布局，必须把该属性设置为NO</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加约束</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">20</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-10</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">30</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-20</span>]];</div></pre></td></tr></table></figure>\n<h3 id=\"添加约束的规则\"><a href=\"#添加约束的规则\" class=\"headerlink\" title=\"添加约束的规则\"></a>添加约束的规则</h3><ul>\n<li>对于两个同层级view之间的约束关系，添加到它们的父view上</li>\n<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</li>\n<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</li>\n</ul>\n<h3 id=\"Autolayout来实现动画功能\"><a href=\"#Autolayout来实现动画功能\" class=\"headerlink\" title=\"Autolayout来实现动画功能\"></a>Autolayout来实现动画功能</h3><p>在执行动画时记得调用一下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在修改了约束之后，只要执行下面代码，就能做动画效果</span></div><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> animations:^&#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span>.view layoutIfNeeded];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三方框架实现AutoLayout\"><a href=\"#第三方框架实现AutoLayout\" class=\"headerlink\" title=\"第三方框架实现AutoLayout\"></a>第三方框架实现AutoLayout</h2><p>Masonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。</p>\n<h3 id=\"框架导入\"><a href=\"#框架导入\" class=\"headerlink\" title=\"框架导入\"></a>框架导入</h3><p>这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。</p>\n<h4 id=\"创建Podfile\"><a href=\"#创建Podfile\" class=\"headerlink\" title=\"创建Podfile\"></a>创建Podfile</h4><p>在工程的目录下新建Podfile文件，写入我们需要的第三方库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target 'NSLayoutConstraintDemo' do</div><div class=\"line\">pod 'Masonry'</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"导入第三方库\"><a href=\"#导入第三方库\" class=\"headerlink\" title=\"导入第三方库\"></a>导入第三方库</h4><p>进入终端，运行命令<code>pod install</code>,导入第三方库。</p>\n<h3 id=\"Masonry基本使用\"><a href=\"#Masonry基本使用\" class=\"headerlink\" title=\"Masonry基本使用\"></a>Masonry基本使用</h3><p>最基本的使用方式：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.属性.equalTo(另一个view).with.insets(差值);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"Masonry属性\"><a href=\"#Masonry属性\" class=\"headerlink\" title=\"Masonry属性\"></a>Masonry属性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *left;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *top;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *right;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *bottom;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *leading;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *trailing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *width;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *height;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerX;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerY;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *baseline;</div></pre></td></tr></table></figure>\n<p>其中leading与left trailing与right 在正常情况下是等价的。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>居中显示一个view：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从此以后基本可以抛弃CGRectMake了</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *sv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在做autoLayout之前 一定要先将view添加到superview上 否则会报错</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:sv];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了</span></div><div class=\"line\">[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将sv居中(很容易理解吧?)</span></div><div class=\"line\">    make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//将size设置成(300,300)</span></div><div class=\"line\">    make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">300</span>, <span class=\"number\">300</span>));</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"方法简析\"><a href=\"#方法简析\" class=\"headerlink\" title=\"方法简析\"></a>方法简析</h3><h4 id=\"添加autolayout约束\"><a href=\"#添加autolayout约束\" class=\"headerlink\" title=\"添加autolayout约束\"></a>添加autolayout约束</h4><p>有三个可以添加约束的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_updateConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_remakeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class=\"line\">    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class=\"line\">    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class=\"line\">    </div><div class=\"line\">    三种函数善加利用 就可以应对各种情况了</div><div class=\"line\">*/</div></pre></td></tr></table></figure></p>\n<h4 id=\"equalTo-和-mas-equalTo的区别\"><a href=\"#equalTo-和-mas-equalTo的区别\" class=\"headerlink\" title=\"equalTo 和 mas_equalTo的区别\"></a>equalTo 和 mas_equalTo的区别</h4><p><code>mas_equalTo</code>只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了<code>NSNumber</code>支持的那些数值类型之外 就只支持<code>CGPoint</code> <code>CGSize</code> <code>UIEdgeInsets</code></p>\n<h3 id=\"另一个示例\"><a href=\"#另一个示例\" class=\"headerlink\" title=\"另一个示例\"></a>另一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *sv1 = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">[sv1 showPlaceHolder];</div><div class=\"line\">sv1.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">[sv addSubview:sv1];</div><div class=\"line\">[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.edges.equalTo(sv).with.insets(<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 等价于</span></div><div class=\"line\">    make.top.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.left.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.bottom.equalTo(sv).with.offset(-10);</div><div class=\"line\">    make.right.equalTo(sv).with.offset(-10);</div><div class=\"line\">    */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 也等价于</span></div><div class=\"line\">    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));</div><div class=\"line\">    */</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.</p>\n<p>这里and和with 两个函数什么事情都没做.</p>\n<h3 id=\"还有一个示例\"><a href=\"#还有一个示例\" class=\"headerlink\" title=\"还有一个示例\"></a>还有一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *lastView = <span class=\"literal\">nil</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= count ; ++i )&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *subv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">    [container addSubview:subv];</div><div class=\"line\">    subv.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithHue:( arc4random() % <span class=\"number\">256</span> / <span class=\"number\">256.0</span> )</div><div class=\"line\">                                      saturation:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                      brightness:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                           alpha:<span class=\"number\">1</span>];</div><div class=\"line\">        </div><div class=\"line\">    [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.and.right.equalTo(container);</div><div class=\"line\">        make.height.mas_equalTo(@(<span class=\"number\">20</span>*i));</div><div class=\"line\">           </div><div class=\"line\">        <span class=\"keyword\">if</span> ( lastView )&#123;</div><div class=\"line\">            make.top.mas_equalTo(lastView.mas_bottom);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            make.top.mas_equalTo(container.mas_top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">       </div><div class=\"line\">    lastView = subv;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\">    </div><div class=\"line\">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.bottom.equalTo(lastView.mas_bottom);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>框架通过范畴为UIView添加了<code>mas_bottom</code>、<code>mas_top</code>等属性，用来表示view的上下左右的位置。这样，有利于<strong>在view之间的约束条件的建立</strong>，之前的示例都是view与父view的约束关系。</p>\n<p>还有一些其他的示例，可以参见<a href=\"http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/\" target=\"_blank\" rel=\"external\">Masonry介绍与使用实践</a></p>\n<blockquote>\n<p>Demo 详见NSLayoutConstraintDemo</p>\n</blockquote>\n","excerpt":"<p><code>AutoLayout</code>是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。<br>参考与<a href=\"http://www.jianshu.com/p/79f92139ffdf\">AutoLayout详解</a></p>","more":"<h2 id=\"代码添加AutoLayout\"><a href=\"#代码添加AutoLayout\" class=\"headerlink\" title=\"代码添加AutoLayout\"></a>代码添加AutoLayout</h2><h3 id=\"关闭Autoresizing\"><a href=\"#关闭Autoresizing\" class=\"headerlink\" title=\"关闭Autoresizing\"></a>关闭Autoresizing</h3><p><code>AutoLayout</code>旨在替代<code>Autoresizing</code>，所以在同一个项目中，<code>AutoLayout</code>和<code>Autoresizing</code>是不能共存的。要实现自动布局，必须关掉view的<code>AutoresizeingMask</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>;</div></pre></td></tr></table></figure>\n<p>这里的view指的是需要添加约束的view。</p>\n<h3 id=\"NSLayoutConstraint相关\"><a href=\"#NSLayoutConstraint相关\" class=\"headerlink\" title=\"NSLayoutConstraint相关\"></a>NSLayoutConstraint相关</h3><h4 id=\"约束方法\"><a href=\"#约束方法\" class=\"headerlink\" title=\"约束方法\"></a>约束方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(<span class=\"keyword\">instancetype</span>)constraintWithItem:(<span class=\"keyword\">id</span>)view1                  <span class=\"comment\">//被约束的视图一</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr1   <span class=\"comment\">//view1的属性</span></div><div class=\"line\">                        relatedBy:(<span class=\"built_in\">NSLayoutRelation</span>)relation <span class=\"comment\">//左右视图的关系</span></div><div class=\"line\">                           toItem:(<span class=\"keyword\">id</span>)view2                  <span class=\"comment\">//被约束的视图二</span></div><div class=\"line\">                        attribute:(<span class=\"built_in\">NSLayoutAttribute</span>)attr2   <span class=\"comment\">//view2的属性</span></div><div class=\"line\">                       multiplier:(<span class=\"built_in\">CGFloat</span>)multiplier        <span class=\"comment\">//乘数</span></div><div class=\"line\">                         constant:(<span class=\"built_in\">CGFloat</span>)c;                <span class=\"comment\">//常量</span></div></pre></td></tr></table></figure>\n<p>公式是这样的：<code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<h4 id=\"NSLayoutAttribute属性\"><a href=\"#NSLayoutAttribute属性\" class=\"headerlink\" title=\"NSLayoutAttribute属性\"></a>NSLayoutAttribute属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutAttribute</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeft</span> = <span class=\"number\">1</span>, <span class=\"comment\">//左边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRight</span>,    <span class=\"comment\">//右边</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTop</span>,      <span class=\"comment\">//顶部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottom</span>,   <span class=\"comment\">//底部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeading</span>,  <span class=\"comment\">//首部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailing</span>, <span class=\"comment\">//尾部</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeWidth</span>,    <span class=\"comment\">//宽度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeHeight</span>,   <span class=\"comment\">//高度</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterX</span>,  <span class=\"comment\">//X轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterY</span>,  <span class=\"comment\">//Y轴中心</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBaseline</span>, <span class=\"comment\">//基线</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLastBaseline</span> = <span class=\"built_in\">NSLayoutAttributeBaseline</span>,</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeFirstBaseline</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//iOS8的暂时没有研究</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeftMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeRightMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTopMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeBottomMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeLeadingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeTrailingMargin</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterXWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeCenterYWithinMargins</span> <span class=\"built_in\">NS_ENUM_AVAILABLE_IOS</span>(<span class=\"number\">8</span>_0),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">NSLayoutAttributeNotAnAttribute</span> = <span class=\"number\">0</span> <span class=\"comment\">//无属性</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"NSLayoutRelation关系\"><a href=\"#NSLayoutRelation关系\" class=\"headerlink\" title=\"NSLayoutRelation关系\"></a>NSLayoutRelation关系</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSLayoutRelation</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationLessThanOrEqual</span> = <span class=\"number\">-1</span>,   <span class=\"comment\">//小于等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationEqual</span> = <span class=\"number\">0</span>,              <span class=\"comment\">//等于</span></div><div class=\"line\">    <span class=\"built_in\">NSLayoutRelationGreaterThanOrEqual</span> = <span class=\"number\">1</span>, <span class=\"comment\">//大于等于</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"创建view\"><a href=\"#创建view\" class=\"headerlink\" title=\"创建view\"></a>创建view</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建view</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *view = [[<span class=\"built_in\">UIView</span> alloc] init]; <span class=\"comment\">//这里不需要设置frame</span></div><div class=\"line\">view.backgroundColor = [<span class=\"built_in\">UIColor</span> brownColor];</div><div class=\"line\">view.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">NO</span>; <span class=\"comment\">//要实现自动布局，必须把该属性设置为NO</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:view];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//添加约束</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeLeft</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">20</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeRight</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-10</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeTop</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">30</span>]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addConstraint:</div><div class=\"line\"> [<span class=\"built_in\">NSLayoutConstraint</span> constraintWithItem:view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                              relatedBy:<span class=\"built_in\">NSLayoutRelationEqual</span></div><div class=\"line\">                                 toItem:<span class=\"keyword\">self</span>.view</div><div class=\"line\">                              attribute:<span class=\"built_in\">NSLayoutAttributeBottom</span></div><div class=\"line\">                             multiplier:<span class=\"number\">1</span></div><div class=\"line\">                               constant:<span class=\"number\">-20</span>]];</div></pre></td></tr></table></figure>\n<h3 id=\"添加约束的规则\"><a href=\"#添加约束的规则\" class=\"headerlink\" title=\"添加约束的规则\"></a>添加约束的规则</h3><ul>\n<li>对于两个同层级view之间的约束关系，添加到它们的父view上</li>\n<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</li>\n<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</li>\n</ul>\n<h3 id=\"Autolayout来实现动画功能\"><a href=\"#Autolayout来实现动画功能\" class=\"headerlink\" title=\"Autolayout来实现动画功能\"></a>Autolayout来实现动画功能</h3><p>在执行动画时记得调用一下方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//在修改了约束之后，只要执行下面代码，就能做动画效果</span></div><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">0.5</span> animations:^&#123;</div><div class=\"line\">      [<span class=\"keyword\">self</span>.view layoutIfNeeded];</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"第三方框架实现AutoLayout\"><a href=\"#第三方框架实现AutoLayout\" class=\"headerlink\" title=\"第三方框架实现AutoLayout\"></a>第三方框架实现AutoLayout</h2><p>Masonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。</p>\n<h3 id=\"框架导入\"><a href=\"#框架导入\" class=\"headerlink\" title=\"框架导入\"></a>框架导入</h3><p>这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。</p>\n<h4 id=\"创建Podfile\"><a href=\"#创建Podfile\" class=\"headerlink\" title=\"创建Podfile\"></a>创建Podfile</h4><p>在工程的目录下新建Podfile文件，写入我们需要的第三方库：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target 'NSLayoutConstraintDemo' do</div><div class=\"line\">pod 'Masonry'</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<h4 id=\"导入第三方库\"><a href=\"#导入第三方库\" class=\"headerlink\" title=\"导入第三方库\"></a>导入第三方库</h4><p>进入终端，运行命令<code>pod install</code>,导入第三方库。</p>\n<h3 id=\"Masonry基本使用\"><a href=\"#Masonry基本使用\" class=\"headerlink\" title=\"Masonry基本使用\"></a>Masonry基本使用</h3><p>最基本的使用方式：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.属性.equalTo(另一个view).with.insets(差值);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"Masonry属性\"><a href=\"#Masonry属性\" class=\"headerlink\" title=\"Masonry属性\"></a>Masonry属性</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *left;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *top;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *right;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *bottom;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *leading;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *trailing;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *width;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *height;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerX;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *centerY;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>, <span class=\"keyword\">readonly</span>) MASConstraint *baseline;</div></pre></td></tr></table></figure>\n<p>其中leading与left trailing与right 在正常情况下是等价的。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>居中显示一个view：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//从此以后基本可以抛弃CGRectMake了</span></div><div class=\"line\"><span class=\"built_in\">UIView</span> *sv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在做autoLayout之前 一定要先将view添加到superview上 否则会报错</span></div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:sv];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了</span></div><div class=\"line\">[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//将sv居中(很容易理解吧?)</span></div><div class=\"line\">    make.center.equalTo(<span class=\"keyword\">self</span>.view);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//将size设置成(300,300)</span></div><div class=\"line\">    make.size.mas_equalTo(<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">300</span>, <span class=\"number\">300</span>));</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<h3 id=\"方法简析\"><a href=\"#方法简析\" class=\"headerlink\" title=\"方法简析\"></a>方法简析</h3><h4 id=\"添加autolayout约束\"><a href=\"#添加autolayout约束\" class=\"headerlink\" title=\"添加autolayout约束\"></a>添加autolayout约束</h4><p>有三个可以添加约束的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_makeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_updateConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)mas_remakeConstraints:(<span class=\"keyword\">void</span>(^)(MASConstraintMaker *make))block;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class=\"line\">    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class=\"line\">    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class=\"line\">    </div><div class=\"line\">    三种函数善加利用 就可以应对各种情况了</div><div class=\"line\">*/</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"equalTo-和-mas-equalTo的区别\"><a href=\"#equalTo-和-mas-equalTo的区别\" class=\"headerlink\" title=\"equalTo 和 mas_equalTo的区别\"></a>equalTo 和 mas_equalTo的区别</h4><p><code>mas_equalTo</code>只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了<code>NSNumber</code>支持的那些数值类型之外 就只支持<code>CGPoint</code> <code>CGSize</code> <code>UIEdgeInsets</code></p>\n<h3 id=\"另一个示例\"><a href=\"#另一个示例\" class=\"headerlink\" title=\"另一个示例\"></a>另一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *sv1 = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">[sv1 showPlaceHolder];</div><div class=\"line\">sv1.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</div><div class=\"line\">[sv addSubview:sv1];</div><div class=\"line\">[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.edges.equalTo(sv).with.insets(<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 等价于</div><div class=\"line\">    make.top.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.left.equalTo(sv).with.offset(10);</div><div class=\"line\">    make.bottom.equalTo(sv).with.offset(-10);</div><div class=\"line\">    make.right.equalTo(sv).with.offset(-10);</div><div class=\"line\">    */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 也等价于</div><div class=\"line\">    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));</div><div class=\"line\">    */</span></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.</p>\n<p>这里and和with 两个函数什么事情都没做.</p>\n<h3 id=\"还有一个示例\"><a href=\"#还有一个示例\" class=\"headerlink\" title=\"还有一个示例\"></a>还有一个示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *lastView = <span class=\"literal\">nil</span>;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= count ; ++i )&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *subv = [<span class=\"built_in\">UIView</span> new];</div><div class=\"line\">    [container addSubview:subv];</div><div class=\"line\">    subv.backgroundColor = [<span class=\"built_in\">UIColor</span> colorWithHue:( arc4random() % <span class=\"number\">256</span> / <span class=\"number\">256.0</span> )</div><div class=\"line\">                                      saturation:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                      brightness:( arc4random() % <span class=\"number\">128</span> / <span class=\"number\">256.0</span> ) + <span class=\"number\">0.5</span></div><div class=\"line\">                                           alpha:<span class=\"number\">1</span>];</div><div class=\"line\">        </div><div class=\"line\">    [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">        make.left.and.right.equalTo(container);</div><div class=\"line\">        make.height.mas_equalTo(@(<span class=\"number\">20</span>*i));</div><div class=\"line\">           </div><div class=\"line\">        <span class=\"keyword\">if</span> ( lastView )&#123;</div><div class=\"line\">            make.top.mas_equalTo(lastView.mas_bottom);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            make.top.mas_equalTo(container.mas_top);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">       </div><div class=\"line\">    lastView = subv;</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\">    </div><div class=\"line\">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class=\"line\">    make.bottom.equalTo(lastView.mas_bottom);</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<p>框架通过范畴为UIView添加了<code>mas_bottom</code>、<code>mas_top</code>等属性，用来表示view的上下左右的位置。这样，有利于<strong>在view之间的约束条件的建立</strong>，之前的示例都是view与父view的约束关系。</p>\n<p>还有一些其他的示例，可以参见<a href=\"http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/\">Masonry介绍与使用实践</a></p>\n<blockquote>\n<p>Demo 详见NSLayoutConstraintDemo</p>\n</blockquote>"},{"title":"JavaScript基本语法","date":"2016-09-22T02:07:12.000Z","_content":"\n\n\n<!--more-->\n\n","source":"_posts/Nodejs学习笔记.md","raw":"title: JavaScript基本语法\ndate: 2016/9/22 10:07:12  \ncategories: JavaScript\ntags:\n\t- 学习笔记\n\n---\n\n\n\n<!--more-->\n\n","slug":"Nodejs学习笔记","published":1,"updated":"2016-09-22T11:57:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzvb000brgru2ldhy79w","content":"<a id=\"more\"></a>\n","excerpt":"","more":""},{"title":"NSNotification的使用","date":"2016-09-13T06:07:12.000Z","_content":"\n本篇是对ios的通知使用方法的一个简单罗列。\n\n\n<!--more-->\n\n## NSNotificationCenter\n`NSNotificationCenter`就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个`NSNotificationCenter`，让我们可以很方便的进行通知的注册和移除。\n\n## 注册\n### addObserver:selector:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@\"test\" object:nil];\n```\n\n参数：\n- `addObserver`:貌似都是`controller`因为还需要`selector`来执行\n- `name`:通知名。当发送该通知名的通知是，观察者收到消息。\n- `object`:缩小接受通知的范围，只接受相对应的`object`对象发来的通知。`nil`则全部接收。\n\n### addObserverForName:object:queue:usingBlock:\n`NSNotificationCenter`消息的接受线程是基于发送消息的线程的,也就是**同步**的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。\n```objc\nid observer = [[NSNotificationCenter defaultCenter] addObserverForName:notification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(){...}];\n```\n\n参数：\n- `queue`:`block`执行所在的线程。如果是`nil`那么就在当前线程(posting thread)\n- `block`:该种方式不用`selector`而使用`block`回调。\n\n## 删除\n只要往`NSNotificationCenter`注册了，就必须有`remove`的存在。\n\n### removeObserver:\n```objc\n- (void)removeObserver:(id)notificationObserver\n```\n对应`addObserverForName`方式，直接把上面的`id observer`作为参数传入即可。\n对应`addObserver`方式，删除`controller`中全部通知.\n\n### removeObserver:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] removeObserver:self name:NotificationCitySelect object:nil]\n```\n删除指定`name`的通知。\n\n## 发送\n```objc\n[[NSNotificationCenter defaultCenter] postNotificationName:NotificationCitySelectChanged object:@{NotificationCitySelect_ObjectLocationChange:@(YES)}]\n```\n发送指定`objcet`的通知，只有注册时注册了该对象的通知才可以接收。\n\n\n","source":"_posts/NSNotification基本使用.md","raw":"title: NSNotification的使用\ndate: 2016/9/13 14:07:12  \ncategories: IOS\ntags: \n\t- NSNotification\n\t\n---\n\n本篇是对ios的通知使用方法的一个简单罗列。\n\n\n<!--more-->\n\n## NSNotificationCenter\n`NSNotificationCenter`就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个`NSNotificationCenter`，让我们可以很方便的进行通知的注册和移除。\n\n## 注册\n### addObserver:selector:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@\"test\" object:nil];\n```\n\n参数：\n- `addObserver`:貌似都是`controller`因为还需要`selector`来执行\n- `name`:通知名。当发送该通知名的通知是，观察者收到消息。\n- `object`:缩小接受通知的范围，只接受相对应的`object`对象发来的通知。`nil`则全部接收。\n\n### addObserverForName:object:queue:usingBlock:\n`NSNotificationCenter`消息的接受线程是基于发送消息的线程的,也就是**同步**的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。\n```objc\nid observer = [[NSNotificationCenter defaultCenter] addObserverForName:notification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(){...}];\n```\n\n参数：\n- `queue`:`block`执行所在的线程。如果是`nil`那么就在当前线程(posting thread)\n- `block`:该种方式不用`selector`而使用`block`回调。\n\n## 删除\n只要往`NSNotificationCenter`注册了，就必须有`remove`的存在。\n\n### removeObserver:\n```objc\n- (void)removeObserver:(id)notificationObserver\n```\n对应`addObserverForName`方式，直接把上面的`id observer`作为参数传入即可。\n对应`addObserver`方式，删除`controller`中全部通知.\n\n### removeObserver:name:object:\n```objc\n[[NSNotificationCenter defaultCenter] removeObserver:self name:NotificationCitySelect object:nil]\n```\n删除指定`name`的通知。\n\n## 发送\n```objc\n[[NSNotificationCenter defaultCenter] postNotificationName:NotificationCitySelectChanged object:@{NotificationCitySelect_ObjectLocationChange:@(YES)}]\n```\n发送指定`objcet`的通知，只有注册时注册了该对象的通知才可以接收。\n\n\n","slug":"NSNotification基本使用","published":1,"updated":"2016-09-14T03:42:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzvh000grgrutiizq5c9","content":"<p>本篇是对ios的通知使用方法的一个简单罗列。</p>\n<a id=\"more\"></a>\n<h2 id=\"NSNotificationCenter\"><a href=\"#NSNotificationCenter\" class=\"headerlink\" title=\"NSNotificationCenter\"></a>NSNotificationCenter</h2><p><code>NSNotificationCenter</code>就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个<code>NSNotificationCenter</code>，让我们可以很方便的进行通知的注册和移除。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><h3 id=\"addObserver-selector-name-object\"><a href=\"#addObserver-selector-name-object\" class=\"headerlink\" title=\"addObserver:selector:name:object:\"></a>addObserver:selector:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) name:<span class=\"string\">@\"test\"</span> object:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>addObserver</code>:貌似都是<code>controller</code>因为还需要<code>selector</code>来执行</li>\n<li><code>name</code>:通知名。当发送该通知名的通知是，观察者收到消息。</li>\n<li><code>object</code>:缩小接受通知的范围，只接受相对应的<code>object</code>对象发来的通知。<code>nil</code>则全部接收。</li>\n</ul>\n<h3 id=\"addObserverForName-object-queue-usingBlock\"><a href=\"#addObserverForName-object-queue-usingBlock\" class=\"headerlink\" title=\"addObserverForName:object:queue:usingBlock:\"></a>addObserverForName:object:queue:usingBlock:</h3><p><code>NSNotificationCenter</code>消息的接受线程是基于发送消息的线程的,也就是<strong>同步</strong>的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> observer = [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserverForName:notification object:<span class=\"literal\">nil</span> queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] usingBlock:^()&#123;...&#125;];</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>queue</code>:<code>block</code>执行所在的线程。如果是<code>nil</code>那么就在当前线程(posting thread)</li>\n<li><code>block</code>:该种方式不用<code>selector</code>而使用<code>block</code>回调。</li>\n</ul>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>只要往<code>NSNotificationCenter</code>注册了，就必须有<code>remove</code>的存在。</p>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver:\"></a>removeObserver:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"keyword\">id</span>)notificationObserver</div></pre></td></tr></table></figure>\n<p>对应<code>addObserverForName</code>方式，直接把上面的<code>id observer</code>作为参数传入即可。<br>对应<code>addObserver</code>方式，删除<code>controller</code>中全部通知.</p>\n<h3 id=\"removeObserver-name-object\"><a href=\"#removeObserver-name-object\" class=\"headerlink\" title=\"removeObserver:name:object:\"></a>removeObserver:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span> name:NotificationCitySelect object:<span class=\"literal\">nil</span>]</div></pre></td></tr></table></figure>\n<p>删除指定<code>name</code>的通知。</p>\n<h2 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(<span class=\"literal\">YES</span>)&#125;]</div></pre></td></tr></table></figure>\n<p>发送指定<code>objcet</code>的通知，只有注册时注册了该对象的通知才可以接收。</p>\n","excerpt":"<p>本篇是对ios的通知使用方法的一个简单罗列。</p>","more":"<h2 id=\"NSNotificationCenter\"><a href=\"#NSNotificationCenter\" class=\"headerlink\" title=\"NSNotificationCenter\"></a>NSNotificationCenter</h2><p><code>NSNotificationCenter</code>就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个<code>NSNotificationCenter</code>，让我们可以很方便的进行通知的注册和移除。</p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><h3 id=\"addObserver-selector-name-object\"><a href=\"#addObserver-selector-name-object\" class=\"headerlink\" title=\"addObserver:selector:name:object:\"></a>addObserver:selector:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserver:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) name:<span class=\"string\">@\"test\"</span> object:<span class=\"literal\">nil</span>];</div></pre></td></tr></table></figure>\n<p>参数：</p>\n<ul>\n<li><code>addObserver</code>:貌似都是<code>controller</code>因为还需要<code>selector</code>来执行</li>\n<li><code>name</code>:通知名。当发送该通知名的通知是，观察者收到消息。</li>\n<li><code>object</code>:缩小接受通知的范围，只接受相对应的<code>object</code>对象发来的通知。<code>nil</code>则全部接收。</li>\n</ul>\n<h3 id=\"addObserverForName-object-queue-usingBlock\"><a href=\"#addObserverForName-object-queue-usingBlock\" class=\"headerlink\" title=\"addObserverForName:object:queue:usingBlock:\"></a>addObserverForName:object:queue:usingBlock:</h3><p><code>NSNotificationCenter</code>消息的接受线程是基于发送消息的线程的,也就是<strong>同步</strong>的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> observer = [[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] addObserverForName:notification object:<span class=\"literal\">nil</span> queue:[<span class=\"built_in\">NSOperationQueue</span> mainQueue] usingBlock:^()&#123;...&#125;];</div></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li><code>queue</code>:<code>block</code>执行所在的线程。如果是<code>nil</code>那么就在当前线程(posting thread)</li>\n<li><code>block</code>:该种方式不用<code>selector</code>而使用<code>block</code>回调。</li>\n</ul>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>只要往<code>NSNotificationCenter</code>注册了，就必须有<code>remove</code>的存在。</p>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver:\"></a>removeObserver:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeObserver:(<span class=\"keyword\">id</span>)notificationObserver</div></pre></td></tr></table></figure>\n<p>对应<code>addObserverForName</code>方式，直接把上面的<code>id observer</code>作为参数传入即可。<br>对应<code>addObserver</code>方式，删除<code>controller</code>中全部通知.</p>\n<h3 id=\"removeObserver-name-object\"><a href=\"#removeObserver-name-object\" class=\"headerlink\" title=\"removeObserver:name:object:\"></a>removeObserver:name:object:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] removeObserver:<span class=\"keyword\">self</span> name:NotificationCitySelect object:<span class=\"literal\">nil</span>]</div></pre></td></tr></table></figure>\n<p>删除指定<code>name</code>的通知。</p>\n<h2 id=\"发送\"><a href=\"#发送\" class=\"headerlink\" title=\"发送\"></a>发送</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"built_in\">NSNotificationCenter</span> defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(<span class=\"literal\">YES</span>)&#125;]</div></pre></td></tr></table></figure>\n<p>发送指定<code>objcet</code>的通知，只有注册时注册了该对象的通知才可以接收。</p>"},{"title":"UIButton 简介","date":"2016-08-29T06:07:12.000Z","_content":"\n从最基础的控件开始一点点学习。先来总结下UIButton。\n\n<!--more-->\n\n## 基础\n### 创建\n```objc\nUIButton *btn1 = [[UIButton alloc] init];\nCGRect btn1Frame = CGRectMake(50, 50, 200, 100);\nbtn1.frame = btn1Frame;\n[self.view addSubview:btn1];\n```\n\n通过`init`和设置`frame`以及`addSubView`就可以将button添加到Voew上。\n\n### 点击事件\n#### 通过xib关联\n```objc\n- (IBAction)btn2Pressed:(id)sender{\n    NSLog(@\"点击操作\");\n}\n```\n与xib关联即可，其中`(id)sender`就表示的是这个Button\n\n#### 通过代码\n```objc\n//添加\n[btn1 addTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n//移除\n[btn1 removeTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n```\n为`btn1`添加和删除一个`btn1Pressed`的点击事件。\n\n## 设置title和image\nbutton有`imageView`和`titleLabel`两个属性，默认image在左，label在右。\n\n### 添加title和image\n```\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setTitle:@\"BTN1\" forState:UIControlStateNormal];\n```\n这里`forState`常用的有一下几种：\n- UIControlStateNormal  \t\t常态\n- UIControlStateHighlighted \t高亮\n- UIControlStateDisabled\t\t禁用\n- UIControlStateSelected\t\t选中\n\n其中需要说明的是，高亮就是点击时的状态。其实还有一种`UIControlStateSelected | UIControlStateHighlighted`这个组合是选中时候的高亮状态，也是比较有用的。\n\n### 设置button选中\nbutton选中与否是由`UIControlStateSelected`控制的。\n\n可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于*点赞*。一般情况我们实现方式是这样的：\n```objc\n- (void)buttonClick:(UIButton *)button {\n    if ([button.currentImage isEqual:[UIImage imageNamed:@\"like\"]]) {\n        [button setImage:[UIImage imageNamed:@\"like_selected\"] forState:UIControlStateNormal];\n    }\n    else {\n        [button setImage:[UIImage imageNamed:@\"like\"] forState:UIControlStateNormal];\n    }\n}\n```\n\n但是最好不要这样实现。可以使用`UIControlStateSelected`来控制：\n```objc\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected];\n\n//点击事件\n- (void)btn1Pressed:(UIButton *)button{\n    //button.enabled 设置是否可点击。\n    button.selected = !button.selected;\n}\n```\n这样，每次点击的时候切换选中状态达到效果。\n\n但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。\n\n因此，需要将normal->selected以及selected->normal之间的highlight都设置一下:\n```objc\n//normal->selected\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateHighlighted];\n//selected->normal\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected | UIControlStateHighlighted];\n```\n\n好的，这样就完成了切换状态的过程。\n\n### 设置image和title位置\nimage和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。\n\n#### image和title位置互换\n先看代码：\n```objc\n[btn1 setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn1.imageView.bounds.size.width, 0, btn1.imageView.bounds.size.width)];\n[btn1 setImageEdgeInsets:UIEdgeInsetsMake(0, btn1.titleLabel.bounds.size.width, 0, -btn1.titleLabel.bounds.size.width)];\n```\n这里需要强调的是一定要先设置`title`再设置`image`。因为`title`是依赖于`image`的，在如果先设置`image`，这个时候`title`还没有确定，于是`titleLabel.bounds.size.width`一定是`0`，即`image`没有变。\n\n这里的`UIEdgeInsetsMake`里的四个参数分别是`top`,`left`,`bottom`,`right`四个方向的`inset`,默认是`0`，也就是说，所有变化都是针对当前位置的。`-btn1.imageView.bounds.size.width`表示让`title`的左边距**减少**`image`的宽度，同理`btn1.imageView.bounds.size.width`表示让右边距**增加**`image`的宽度。\n\n#### 控制image的大小\n交换了image的位置后，我就想怎么控制image的大小。尝试改变了`UIEdgeInsetsMake`的参数，发现改变`top`和`bottom`可以将图片压缩，但是改变`left` `right`图片始终不动。\n\n经过我不断尝试后终于得出了结论：\n以横轴为例，只有当**左边距+右边距+图片宽度=button宽度**时，继续增加边距，才会导致图片的压缩。当**左边距+右边距+图片宽度<button宽度**时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。\n\n因此，为什么改变`top`和`bottom`可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时`top`和`bottom`都为0，但是由于**image高度=button高度**，此时增加`top`和`bottom`就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。\n\n而在横轴方面，开始时，**左边距+右边距+图片宽度<button宽度**。图片只会平移直到边距增加到使等式相等才会进行压缩。\n\n\n就是这样~~O(∩_∩)O~~","source":"_posts/UIButton基础.md","raw":"title: UIButton 简介\ndate: 2016/8/29 14:07:12  \ncategories: IOS\ntags: \n\t- 基本控件\n\t\n---\n\n从最基础的控件开始一点点学习。先来总结下UIButton。\n\n<!--more-->\n\n## 基础\n### 创建\n```objc\nUIButton *btn1 = [[UIButton alloc] init];\nCGRect btn1Frame = CGRectMake(50, 50, 200, 100);\nbtn1.frame = btn1Frame;\n[self.view addSubview:btn1];\n```\n\n通过`init`和设置`frame`以及`addSubView`就可以将button添加到Voew上。\n\n### 点击事件\n#### 通过xib关联\n```objc\n- (IBAction)btn2Pressed:(id)sender{\n    NSLog(@\"点击操作\");\n}\n```\n与xib关联即可，其中`(id)sender`就表示的是这个Button\n\n#### 通过代码\n```objc\n//添加\n[btn1 addTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n//移除\n[btn1 removeTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];\n```\n为`btn1`添加和删除一个`btn1Pressed`的点击事件。\n\n## 设置title和image\nbutton有`imageView`和`titleLabel`两个属性，默认image在左，label在右。\n\n### 添加title和image\n```\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setTitle:@\"BTN1\" forState:UIControlStateNormal];\n```\n这里`forState`常用的有一下几种：\n- UIControlStateNormal  \t\t常态\n- UIControlStateHighlighted \t高亮\n- UIControlStateDisabled\t\t禁用\n- UIControlStateSelected\t\t选中\n\n其中需要说明的是，高亮就是点击时的状态。其实还有一种`UIControlStateSelected | UIControlStateHighlighted`这个组合是选中时候的高亮状态，也是比较有用的。\n\n### 设置button选中\nbutton选中与否是由`UIControlStateSelected`控制的。\n\n可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于*点赞*。一般情况我们实现方式是这样的：\n```objc\n- (void)buttonClick:(UIButton *)button {\n    if ([button.currentImage isEqual:[UIImage imageNamed:@\"like\"]]) {\n        [button setImage:[UIImage imageNamed:@\"like_selected\"] forState:UIControlStateNormal];\n    }\n    else {\n        [button setImage:[UIImage imageNamed:@\"like\"] forState:UIControlStateNormal];\n    }\n}\n```\n\n但是最好不要这样实现。可以使用`UIControlStateSelected`来控制：\n```objc\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateNormal];\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected];\n\n//点击事件\n- (void)btn1Pressed:(UIButton *)button{\n    //button.enabled 设置是否可点击。\n    button.selected = !button.selected;\n}\n```\n这样，每次点击的时候切换选中状态达到效果。\n\n但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。\n\n因此，需要将normal->selected以及selected->normal之间的highlight都设置一下:\n```objc\n//normal->selected\n[btn1 setImage:[UIImage imageNamed:@\"Image\"] forState:UIControlStateHighlighted];\n//selected->normal\n[btn1 setImage:[UIImage imageNamed:@\"Image2\"] forState:UIControlStateSelected | UIControlStateHighlighted];\n```\n\n好的，这样就完成了切换状态的过程。\n\n### 设置image和title位置\nimage和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。\n\n#### image和title位置互换\n先看代码：\n```objc\n[btn1 setTitleEdgeInsets:UIEdgeInsetsMake(0, -btn1.imageView.bounds.size.width, 0, btn1.imageView.bounds.size.width)];\n[btn1 setImageEdgeInsets:UIEdgeInsetsMake(0, btn1.titleLabel.bounds.size.width, 0, -btn1.titleLabel.bounds.size.width)];\n```\n这里需要强调的是一定要先设置`title`再设置`image`。因为`title`是依赖于`image`的，在如果先设置`image`，这个时候`title`还没有确定，于是`titleLabel.bounds.size.width`一定是`0`，即`image`没有变。\n\n这里的`UIEdgeInsetsMake`里的四个参数分别是`top`,`left`,`bottom`,`right`四个方向的`inset`,默认是`0`，也就是说，所有变化都是针对当前位置的。`-btn1.imageView.bounds.size.width`表示让`title`的左边距**减少**`image`的宽度，同理`btn1.imageView.bounds.size.width`表示让右边距**增加**`image`的宽度。\n\n#### 控制image的大小\n交换了image的位置后，我就想怎么控制image的大小。尝试改变了`UIEdgeInsetsMake`的参数，发现改变`top`和`bottom`可以将图片压缩，但是改变`left` `right`图片始终不动。\n\n经过我不断尝试后终于得出了结论：\n以横轴为例，只有当**左边距+右边距+图片宽度=button宽度**时，继续增加边距，才会导致图片的压缩。当**左边距+右边距+图片宽度<button宽度**时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。\n\n因此，为什么改变`top`和`bottom`可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时`top`和`bottom`都为0，但是由于**image高度=button高度**，此时增加`top`和`bottom`就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。\n\n而在横轴方面，开始时，**左边距+右边距+图片宽度<button宽度**。图片只会平移直到边距增加到使等式相等才会进行压缩。\n\n\n就是这样~~O(∩_∩)O~~","slug":"UIButton基础","published":1,"updated":"2016-09-23T05:46:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzvk000jrgruhb5kdaus","content":"<p>从最基础的控件开始一点点学习。先来总结下UIButton。</p>\n<a id=\"more\"></a>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\"><span class=\"built_in\">CGRect</span> btn1Frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>);</div><div class=\"line\">btn1.frame = btn1Frame;</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</div></pre></td></tr></table></figure>\n<p>通过<code>init</code>和设置<code>frame</code>以及<code>addSubView</code>就可以将button添加到Voew上。</p>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><h4 id=\"通过xib关联\"><a href=\"#通过xib关联\" class=\"headerlink\" title=\"通过xib关联\"></a>通过xib关联</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btn2Pressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"点击操作\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与xib关联即可，其中<code>(id)sender</code>就表示的是这个Button</p>\n<h4 id=\"通过代码\"><a href=\"#通过代码\" class=\"headerlink\" title=\"通过代码\"></a>通过代码</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加</span></div><div class=\"line\">[btn1 addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"><span class=\"comment\">//移除</span></div><div class=\"line\">[btn1 removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>为<code>btn1</code>添加和删除一个<code>btn1Pressed</code>的点击事件。</p>\n<h2 id=\"设置title和image\"><a href=\"#设置title和image\" class=\"headerlink\" title=\"设置title和image\"></a>设置title和image</h2><p>button有<code>imageView</code>和<code>titleLabel</code>两个属性，默认image在左，label在右。</p>\n<h3 id=\"添加title和image\"><a href=\"#添加title和image\" class=\"headerlink\" title=\"添加title和image\"></a>添加title和image</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];</div><div class=\"line\">[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p>这里<code>forState</code>常用的有一下几种：</p>\n<ul>\n<li>UIControlStateNormal          常态</li>\n<li>UIControlStateHighlighted     高亮</li>\n<li>UIControlStateDisabled        禁用</li>\n<li>UIControlStateSelected        选中</li>\n</ul>\n<p>其中需要说明的是，高亮就是点击时的状态。其实还有一种<code>UIControlStateSelected | UIControlStateHighlighted</code>这个组合是选中时候的高亮状态，也是比较有用的。</p>\n<h3 id=\"设置button选中\"><a href=\"#设置button选中\" class=\"headerlink\" title=\"设置button选中\"></a>设置button选中</h3><p>button选中与否是由<code>UIControlStateSelected</code>控制的。</p>\n<p>可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于<em>点赞</em>。一般情况我们实现方式是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick:(<span class=\"built_in\">UIButton</span> *)button &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([button.currentImage isEqual:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>]]) &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like_selected\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是最好不要这样实现。可以使用<code>UIControlStateSelected</code>来控制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//点击事件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)btn1Pressed:(<span class=\"built_in\">UIButton</span> *)button&#123;</div><div class=\"line\">    <span class=\"comment\">//button.enabled 设置是否可点击。</span></div><div class=\"line\">    button.selected = !button.selected;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，每次点击的时候切换选中状态达到效果。</p>\n<p>但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。</p>\n<p>因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//normal-&gt;selected</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</div><div class=\"line\"><span class=\"comment\">//selected-&gt;normal</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span> | <span class=\"built_in\">UIControlStateHighlighted</span>];</div></pre></td></tr></table></figure></p>\n<p>好的，这样就完成了切换状态的过程。</p>\n<h3 id=\"设置image和title位置\"><a href=\"#设置image和title位置\" class=\"headerlink\" title=\"设置image和title位置\"></a>设置image和title位置</h3><p>image和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。</p>\n<h4 id=\"image和title位置互换\"><a href=\"#image和title位置互换\" class=\"headerlink\" title=\"image和title位置互换\"></a>image和title位置互换</h4><p>先看代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setTitleEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, -btn1.imageView.bounds.size.width, <span class=\"number\">0</span>, btn1.imageView.bounds.size.width)];</div><div class=\"line\">[btn1 setImageEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, btn1.titleLabel.bounds.size.width, <span class=\"number\">0</span>, -btn1.titleLabel.bounds.size.width)];</div></pre></td></tr></table></figure></p>\n<p>这里需要强调的是一定要先设置<code>title</code>再设置<code>image</code>。因为<code>title</code>是依赖于<code>image</code>的，在如果先设置<code>image</code>，这个时候<code>title</code>还没有确定，于是<code>titleLabel.bounds.size.width</code>一定是<code>0</code>，即<code>image</code>没有变。</p>\n<p>这里的<code>UIEdgeInsetsMake</code>里的四个参数分别是<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>四个方向的<code>inset</code>,默认是<code>0</code>，也就是说，所有变化都是针对当前位置的。<code>-btn1.imageView.bounds.size.width</code>表示让<code>title</code>的左边距<strong>减少</strong><code>image</code>的宽度，同理<code>btn1.imageView.bounds.size.width</code>表示让右边距<strong>增加</strong><code>image</code>的宽度。</p>\n<h4 id=\"控制image的大小\"><a href=\"#控制image的大小\" class=\"headerlink\" title=\"控制image的大小\"></a>控制image的大小</h4><p>交换了image的位置后，我就想怎么控制image的大小。尝试改变了<code>UIEdgeInsetsMake</code>的参数，发现改变<code>top</code>和<code>bottom</code>可以将图片压缩，但是改变<code>left</code> <code>right</code>图片始终不动。</p>\n<p>经过我不断尝试后终于得出了结论：<br>以横轴为例，只有当<strong>左边距+右边距+图片宽度=button宽度</strong>时，继续增加边距，才会导致图片的压缩。当<strong>左边距+右边距+图片宽度&lt;button宽度</strong>时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。</p>\n<p>因此，为什么改变<code>top</code>和<code>bottom</code>可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时<code>top</code>和<code>bottom</code>都为0，但是由于<strong>image高度=button高度</strong>，此时增加<code>top</code>和<code>bottom</code>就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。</p>\n<p>而在横轴方面，开始时，<strong>左边距+右边距+图片宽度&lt;button宽度</strong>。图片只会平移直到边距增加到使等式相等才会进行压缩。</p>\n<p>就是这样<del>O(∩_∩)O</del></p>\n","excerpt":"<p>从最基础的控件开始一点点学习。先来总结下UIButton。</p>","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [[<span class=\"built_in\">UIButton</span> alloc] init];</div><div class=\"line\"><span class=\"built_in\">CGRect</span> btn1Frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>);</div><div class=\"line\">btn1.frame = btn1Frame;</div><div class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</div></pre></td></tr></table></figure>\n<p>通过<code>init</code>和设置<code>frame</code>以及<code>addSubView</code>就可以将button添加到Voew上。</p>\n<h3 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h3><h4 id=\"通过xib关联\"><a href=\"#通过xib关联\" class=\"headerlink\" title=\"通过xib关联\"></a>通过xib关联</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)btn2Pressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"点击操作\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与xib关联即可，其中<code>(id)sender</code>就表示的是这个Button</p>\n<h4 id=\"通过代码\"><a href=\"#通过代码\" class=\"headerlink\" title=\"通过代码\"></a>通过代码</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//添加</span></div><div class=\"line\">[btn1 addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"><span class=\"comment\">//移除</span></div><div class=\"line\">[btn1 removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(btn1Pressed:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>\n<p>为<code>btn1</code>添加和删除一个<code>btn1Pressed</code>的点击事件。</p>\n<h2 id=\"设置title和image\"><a href=\"#设置title和image\" class=\"headerlink\" title=\"设置title和image\"></a>设置title和image</h2><p>button有<code>imageView</code>和<code>titleLabel</code>两个属性，默认image在左，label在右。</p>\n<h3 id=\"添加title和image\"><a href=\"#添加title和image\" class=\"headerlink\" title=\"添加title和image\"></a>添加title和image</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];</div><div class=\"line\">[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p>这里<code>forState</code>常用的有一下几种：</p>\n<ul>\n<li>UIControlStateNormal          常态</li>\n<li>UIControlStateHighlighted     高亮</li>\n<li>UIControlStateDisabled        禁用</li>\n<li>UIControlStateSelected        选中</li>\n</ul>\n<p>其中需要说明的是，高亮就是点击时的状态。其实还有一种<code>UIControlStateSelected | UIControlStateHighlighted</code>这个组合是选中时候的高亮状态，也是比较有用的。</p>\n<h3 id=\"设置button选中\"><a href=\"#设置button选中\" class=\"headerlink\" title=\"设置button选中\"></a>设置button选中</h3><p>button选中与否是由<code>UIControlStateSelected</code>控制的。</p>\n<p>可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于<em>点赞</em>。一般情况我们实现方式是这样的：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick:(<span class=\"built_in\">UIButton</span> *)button &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([button.currentImage isEqual:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>]]) &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like_selected\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        [button setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"like\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>但是最好不要这样实现。可以使用<code>UIControlStateSelected</code>来控制：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//点击事件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)btn1Pressed:(<span class=\"built_in\">UIButton</span> *)button&#123;</div><div class=\"line\">    <span class=\"comment\">//button.enabled 设置是否可点击。</span></div><div class=\"line\">    button.selected = !button.selected;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，每次点击的时候切换选中状态达到效果。</p>\n<p>但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。</p>\n<p>因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//normal-&gt;selected</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image\"</span>] forState:<span class=\"built_in\">UIControlStateHighlighted</span>];</div><div class=\"line\"><span class=\"comment\">//selected-&gt;normal</span></div><div class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"Image2\"</span>] forState:<span class=\"built_in\">UIControlStateSelected</span> | <span class=\"built_in\">UIControlStateHighlighted</span>];</div></pre></td></tr></table></figure></p>\n<p>好的，这样就完成了切换状态的过程。</p>\n<h3 id=\"设置image和title位置\"><a href=\"#设置image和title位置\" class=\"headerlink\" title=\"设置image和title位置\"></a>设置image和title位置</h3><p>image和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。</p>\n<h4 id=\"image和title位置互换\"><a href=\"#image和title位置互换\" class=\"headerlink\" title=\"image和title位置互换\"></a>image和title位置互换</h4><p>先看代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn1 setTitleEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, -btn1.imageView.bounds.size.width, <span class=\"number\">0</span>, btn1.imageView.bounds.size.width)];</div><div class=\"line\">[btn1 setImageEdgeInsets:<span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">0</span>, btn1.titleLabel.bounds.size.width, <span class=\"number\">0</span>, -btn1.titleLabel.bounds.size.width)];</div></pre></td></tr></table></figure></p>\n<p>这里需要强调的是一定要先设置<code>title</code>再设置<code>image</code>。因为<code>title</code>是依赖于<code>image</code>的，在如果先设置<code>image</code>，这个时候<code>title</code>还没有确定，于是<code>titleLabel.bounds.size.width</code>一定是<code>0</code>，即<code>image</code>没有变。</p>\n<p>这里的<code>UIEdgeInsetsMake</code>里的四个参数分别是<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>四个方向的<code>inset</code>,默认是<code>0</code>，也就是说，所有变化都是针对当前位置的。<code>-btn1.imageView.bounds.size.width</code>表示让<code>title</code>的左边距<strong>减少</strong><code>image</code>的宽度，同理<code>btn1.imageView.bounds.size.width</code>表示让右边距<strong>增加</strong><code>image</code>的宽度。</p>\n<h4 id=\"控制image的大小\"><a href=\"#控制image的大小\" class=\"headerlink\" title=\"控制image的大小\"></a>控制image的大小</h4><p>交换了image的位置后，我就想怎么控制image的大小。尝试改变了<code>UIEdgeInsetsMake</code>的参数，发现改变<code>top</code>和<code>bottom</code>可以将图片压缩，但是改变<code>left</code> <code>right</code>图片始终不动。</p>\n<p>经过我不断尝试后终于得出了结论：<br>以横轴为例，只有当<strong>左边距+右边距+图片宽度=button宽度</strong>时，继续增加边距，才会导致图片的压缩。当<strong>左边距+右边距+图片宽度&lt;button宽度</strong>时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。</p>\n<p>因此，为什么改变<code>top</code>和<code>bottom</code>可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时<code>top</code>和<code>bottom</code>都为0，但是由于<strong>image高度=button高度</strong>，此时增加<code>top</code>和<code>bottom</code>就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。</p>\n<p>而在横轴方面，开始时，<strong>左边距+右边距+图片宽度&lt;button宽度</strong>。图片只会平移直到边距增加到使等式相等才会进行压缩。</p>\n<p>就是这样<del>O(∩_∩)O</del></p>"},{"title":"GCD队列 学习与整理","date":"2016-08-02T06:07:12.000Z","_content":"\nGrand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。\n\n<!--more-->\n\n### 基本概念\n- **Serial vs. Concurrent 串行 vs. 并发**\n这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。\n- **Synchronous vs. Asynchronous 同步 vs. 异步**\n在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。\n\n### 队列分类\n1. **Serial Queues 串行队列**\n这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。\n由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。\n2. **Concurrent Queues 并发队列**\n在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。\n\n### 队列类型\n1. **The main queue**\n与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。\n2. **Global queues**\n全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。\n3. **用户队列**\n用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。\n\n### 队列创建方式\n1. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.serial\", DISPATCH_QUEUE_SERIAL);**\n生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。\n2. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.concurrent\", DISPATCH_QUEUE_CONCURRENT);**\n生成一个并发执行队列。\n3. **dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);**\n获得全局队列。\n4. **dispatch_queue_t queue = dispatch_get_main_queue()**\n获得主线程队列。\n\n### 提交 Job\n向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。\n\n1. **dispatch_async**\ndispatch_async 函数会立即返回, block会在后台异步执行。\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        NSLog(@\"Done doing something long and involved\");\n});\n```\n\t在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [textField setStringValue:@\"Done doing something long and involved\"];\n        });\n});\n```\n2. **dispatch_sync**\ndispatch_sync //同步执行block，函数不返回，一直等到block执行完毕。编译器会根据实际情况优化代码，所以有时候你会发现block其实还在当前线程上执行，并没用产生新线程。\n实际编程经验告诉我们，尽可能避免使用dispatch_sync，嵌套使用时还容易引起程序死锁，比如嵌套调用主线程。\n![gcd_死锁](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true)\n\n**总结：队列是串行或并发的，操作队列的函数是同步或者异步执行的。**\n\n### 常用方法\n1. **dispatch_apply**\n重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_apply([array count], queue, ^(size_t index){\n    [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n});\n[self doSomethingWith:array];\n```\n\t如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_async(queue, ^{\n    dispatch_apply([array count], queue, ^(size_t index){\n        [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n    });\n    [self doSomethingWith:array];\n});\n```\n\t那何时才适合用 dispatch_apply 呢？\n\n\t- 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。\n\n\t- 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。\n\n\t- 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。\n\t\n2. **dispatch_after**\n延迟执行block\n```objc\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n     // code to be executed on the main queue after delay\n});\n```\n3. **dispatch_once**\n保证在APP运行期间，block中的代码只执行一次\n```objc\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    // code to be executed once\n});\n```\n\n4. **dispatch_group**\n一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。\n- *dispatch_group_create*创建一个调度任务组\n- *dispatch_group_async* 把一个任务异步提交到任务组里\n- *dispatch_group_notify* 用来监听任务组事件的执行完毕\n- *dispatch_group_wait* 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\nfor(id obj in array)\n    dispatch_group_async(group, queue, ^{\n        [self doSomethingIntensiveWith:obj];\n    });\ndispatch_group_notify(group, queue, ^{\n    [self doSomethingWith:array];\n});\n```\n\n","source":"_posts/GCD队列.md","raw":"title: GCD队列 学习与整理\ndate: 2016/8/2 14:07:12  \ncategories: IOS\ntags: [GCD]\n\n---\n\nGrand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。\n\n<!--more-->\n\n### 基本概念\n- **Serial vs. Concurrent 串行 vs. 并发**\n这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。\n- **Synchronous vs. Asynchronous 同步 vs. 异步**\n在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。\n\n### 队列分类\n1. **Serial Queues 串行队列**\n这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。\n由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。\n2. **Concurrent Queues 并发队列**\n在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。\n\n### 队列类型\n1. **The main queue**\n与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。\n2. **Global queues**\n全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。\n3. **用户队列**\n用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。\n\n### 队列创建方式\n1. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.serial\", DISPATCH_QUEUE_SERIAL);**\n生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。\n2. **dispatch_queue_t queue = dispatch_queue_create(\"com.dispatch.concurrent\", DISPATCH_QUEUE_CONCURRENT);**\n生成一个并发执行队列。\n3. **dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);**\n获得全局队列。\n4. **dispatch_queue_t queue = dispatch_get_main_queue()**\n获得主线程队列。\n\n### 提交 Job\n向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。\n\n1. **dispatch_async**\ndispatch_async 函数会立即返回, block会在后台异步执行。\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        NSLog(@\"Done doing something long and involved\");\n});\n```\n\t在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：\n```objc\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self goDoSomethingLongAndInvolved];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [textField setStringValue:@\"Done doing something long and involved\"];\n        });\n});\n```\n2. **dispatch_sync**\ndispatch_sync //同步执行block，函数不返回，一直等到block执行完毕。编译器会根据实际情况优化代码，所以有时候你会发现block其实还在当前线程上执行，并没用产生新线程。\n实际编程经验告诉我们，尽可能避免使用dispatch_sync，嵌套使用时还容易引起程序死锁，比如嵌套调用主线程。\n![gcd_死锁](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true)\n\n**总结：队列是串行或并发的，操作队列的函数是同步或者异步执行的。**\n\n### 常用方法\n1. **dispatch_apply**\n重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_apply([array count], queue, ^(size_t index){\n    [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n});\n[self doSomethingWith:array];\n```\n\t如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_async(queue, ^{\n    dispatch_apply([array count], queue, ^(size_t index){\n        [self doSomethingIntensiveWith:[array objectAtIndex:index]];\n    });\n    [self doSomethingWith:array];\n});\n```\n\t那何时才适合用 dispatch_apply 呢？\n\n\t- 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。\n\n\t- 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。\n\n\t- 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。\n\t\n2. **dispatch_after**\n延迟执行block\n```objc\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n     // code to be executed on the main queue after delay\n});\n```\n3. **dispatch_once**\n保证在APP运行期间，block中的代码只执行一次\n```objc\nstatic dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    // code to be executed once\n});\n```\n\n4. **dispatch_group**\n一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。\n- *dispatch_group_create*创建一个调度任务组\n- *dispatch_group_async* 把一个任务异步提交到任务组里\n- *dispatch_group_notify* 用来监听任务组事件的执行完毕\n- *dispatch_group_wait* 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败\n```objc\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\nfor(id obj in array)\n    dispatch_group_async(group, queue, ^{\n        [self doSomethingIntensiveWith:obj];\n    });\ndispatch_group_notify(group, queue, ^{\n    [self doSomethingWith:array];\n});\n```\n\n","slug":"GCD队列","published":1,"updated":"2016-09-23T05:44:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzvl000nrgruulcczc66","content":"<p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><strong>Serial vs. Concurrent 串行 vs. 并发</strong><br>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</li>\n<li><strong>Synchronous vs. Asynchronous 同步 vs. 异步</strong><br>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</li>\n</ul>\n<h3 id=\"队列分类\"><a href=\"#队列分类\" class=\"headerlink\" title=\"队列分类\"></a>队列分类</h3><ol>\n<li><strong>Serial Queues 串行队列</strong><br>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。<br>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。</li>\n<li><strong>Concurrent Queues 并发队列</strong><br>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</li>\n</ol>\n<h3 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h3><ol>\n<li><strong>The main queue</strong><br>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。</li>\n<li><strong>Global queues</strong><br>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。</li>\n<li><strong>用户队列</strong><br>用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。</li>\n</ol>\n<h3 id=\"队列创建方式\"><a href=\"#队列创建方式\" class=\"headerlink\" title=\"队列创建方式\"></a>队列创建方式</h3><ol>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);</strong><br>生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。</li>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);</strong><br>生成一个并发执行队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</strong><br>获得全局队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_main_queue()</strong><br>获得主线程队列。</li>\n</ol>\n<h3 id=\"提交-Job\"><a href=\"#提交-Job\" class=\"headerlink\" title=\"提交 Job\"></a>提交 Job</h3><p>向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。</p>\n<ol>\n<li><p><strong>dispatch_async</strong><br>dispatch_async 函数会立即返回, block会在后台异步执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Done doing something long and involved\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [textField setStringValue:<span class=\"string\">@\"Done doing something long and involved\"</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_sync</strong><br>dispatch_sync //同步执行block，函数不返回，一直等到block执行完毕。编译器会根据实际情况优化代码，所以有时候你会发现block其实还在当前线程上执行，并没用产生新线程。<br>实际编程经验告诉我们，尽可能避免使用dispatch<em>sync，嵌套使用时还容易引起程序死锁，比如嵌套调用主线程。<br>![gcd</em>死锁](<a href=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true\" target=\"_blank\" rel=\"external\">https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true</a>)</p>\n</li>\n</ol>\n<p><strong>总结：队列是串行或并发的，操作队列的函数是同步或者异步执行的。</strong></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ol>\n<li><p><strong>dispatch_apply</strong><br>重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">&#125;);</div><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWith:array];</div></pre></td></tr></table></figure>\n<p> 如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 那何时才适合用 dispatch_apply 呢？</p>\n<ul>\n<li><p>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</p>\n</li>\n<li><p>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</p>\n</li>\n<li><p>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>dispatch_after</strong><br>延迟执行block</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> delayInSeconds = <span class=\"number\">1.0</span>; </div><div class=\"line\">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">     <span class=\"comment\">// code to be executed on the main queue after delay</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_once</strong><br>保证在APP运行期间，block中的代码只执行一次</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// code to be executed once</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_group</strong><br>一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。</p>\n</li>\n</ol>\n<ul>\n<li><em>dispatch_group_create</em>创建一个调度任务组</li>\n<li><em>dispatch_group_async</em> 把一个任务异步提交到任务组里</li>\n<li><em>dispatch_group_notify</em> 用来监听任务组事件的执行完毕</li>\n<li><em>dispatch_group_wait</em> 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array)</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:obj];</div><div class=\"line\">    &#125;);</div><div class=\"line\">dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"<p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><strong>Serial vs. Concurrent 串行 vs. 并发</strong><br>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</li>\n<li><strong>Synchronous vs. Asynchronous 同步 vs. 异步</strong><br>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</li>\n</ul>\n<h3 id=\"队列分类\"><a href=\"#队列分类\" class=\"headerlink\" title=\"队列分类\"></a>队列分类</h3><ol>\n<li><strong>Serial Queues 串行队列</strong><br>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。<br>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。</li>\n<li><strong>Concurrent Queues 并发队列</strong><br>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</li>\n</ol>\n<h3 id=\"队列类型\"><a href=\"#队列类型\" class=\"headerlink\" title=\"队列类型\"></a>队列类型</h3><ol>\n<li><strong>The main queue</strong><br>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。</li>\n<li><strong>Global queues</strong><br>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。</li>\n<li><strong>用户队列</strong><br>用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。</li>\n</ol>\n<h3 id=\"队列创建方式\"><a href=\"#队列创建方式\" class=\"headerlink\" title=\"队列创建方式\"></a>队列创建方式</h3><ol>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);</strong><br>生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。</li>\n<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);</strong><br>生成一个并发执行队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</strong><br>获得全局队列。</li>\n<li><strong>dispatch_queue_t queue = dispatch_get_main_queue()</strong><br>获得主线程队列。</li>\n</ol>\n<h3 id=\"提交-Job\"><a href=\"#提交-Job\" class=\"headerlink\" title=\"提交 Job\"></a>提交 Job</h3><p>向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。</p>\n<ol>\n<li><p><strong>dispatch_async</strong><br>dispatch_async 函数会立即返回, block会在后台异步执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Done doing something long and involved\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> goDoSomethingLongAndInvolved];</div><div class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            [textField setStringValue:<span class=\"string\">@\"Done doing something long and involved\"</span>];</div><div class=\"line\">        &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_sync</strong><br>dispatch_sync //同步执行block，函数不返回，一直等到block执行完毕。编译器会根据实际情况优化代码，所以有时候你会发现block其实还在当前线程上执行，并没用产生新线程。<br>实际编程经验告诉我们，尽可能避免使用dispatch<em>sync，嵌套使用时还容易引起程序死锁，比如嵌套调用主线程。<br>![gcd</em>死锁](<a href=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true\">https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true</a>)</p>\n</li>\n</ol>\n<p><strong>总结：队列是串行或并发的，操作队列的函数是同步或者异步执行的。</strong></p>\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><ol>\n<li><p><strong>dispatch_apply</strong><br>重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">&#125;);</div><div class=\"line\">[<span class=\"keyword\">self</span> doSomethingWith:array];</div></pre></td></tr></table></figure>\n<p> 如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</div><div class=\"line\">    dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 那何时才适合用 dispatch_apply 呢？</p>\n<ul>\n<li><p>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</p>\n</li>\n<li><p>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</p>\n</li>\n<li><p>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>dispatch_after</strong><br>延迟执行block</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> delayInSeconds = <span class=\"number\">1.0</span>; </div><div class=\"line\">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class=\"built_in\">NSEC_PER_SEC</span>));</div><div class=\"line\">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>)&#123;</div><div class=\"line\">     <span class=\"comment\">// code to be executed on the main queue after delay</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_once</strong><br>保证在APP运行期间，block中的代码只执行一次</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</div><div class=\"line\"><span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class=\"line\">    <span class=\"comment\">// code to be executed once</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>dispatch_group</strong><br>一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。</p>\n</li>\n</ol>\n<ul>\n<li><em>dispatch_group_create</em>创建一个调度任务组</li>\n<li><em>dispatch_group_async</em> 把一个任务异步提交到任务组里</li>\n<li><em>dispatch_group_notify</em> 用来监听任务组事件的执行完毕</li>\n<li><em>dispatch_group_wait</em> 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</div><div class=\"line\">dispatch_group_t group = dispatch_group_create();</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array)</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> doSomethingIntensiveWith:obj];</div><div class=\"line\">    &#125;);</div><div class=\"line\">dispatch_group_notify(group, queue, ^&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span> doSomethingWith:array];</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"UIScrollView详细介绍","date":"2016-09-18T06:07:12.000Z","_content":"\n本次将参考[iOS 性能优化之 UIScrollView 实践经验](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)对UIScrollView的使用方式进行详细介绍\n<!--more-->\n\n## ScrollView和Auto Layout\n`UIScrollView` 在 `Auto Layout` 是一个很特殊的 `view`，对于 `UIScrollView` 的 `subview` 来说，它的 `leading/trailing/top/bottom space` 是**相对于 `UIScrollView`的 `contentSize` 而不是 `bounds` 来确定的。**\n\n所以，一般的做法是在`UIScrollVIew`和它的`subViews`之间增加一个`content view`。这样可以方便地给 `subview` 提供 `leading/trailing/top/bottom`，方便 `subview` 的布局，并且可以 通过调整`content view` 的 `size`（调整`constraint` 的 `IBOutlet`）来调整 `contentSize`。\n\n### 添加ContentView的注意点\n`scrollview`中添加的`contentview`和添加一般的视图不同，一般的视图只要只要提供`leading/trailing/top/bottom space`就能唯一确定长宽，位置。\n而`ScrollView`的`contentView`除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。\n\n所以整个`scrollview`的`contentSize`的等式应该是：\n```\nscrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）\n```\n\n**另外一点需要强调两点：**\n1. `ScrollView`的`bounds`早就确定了下来，在设置`contentview`的宽度的时候，如果设置`contentview.width = superview.width + constant`这里的`superview.width`是指`ScrollView.bounds`而不是`contentSize`\n2. 在设置`contentview`的上下左右约束的时候，如果设置`contentview.trailing = superview.trailing + constant`,这里的`superview.trailing`指的是`contentSize.trailing`而不是`bounds`。此时就可以通过上面的公式计算`contentSize`的宽度了。\n\n> Demo参见AutoLayout\n\n## UIScrollView部分属性\n### **contentSize**、**contentInset**和**contentOffset**\n- contentSize: 就是scrollview可以滚动的区域.\n比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。\n- contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。\n比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 \n- contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。\n例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 \n\n/* 上拉刷新一般实现代码如下 */\n```objc\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{     \n    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  \n    float offset=scrollView.contentOffset.y;  \n    float contentHeight=scrollView.contentSize.height;  \n    float sub=contentHeight-offset;  \n    if ((scrollView.height-sub)>20) {//如果上拉距离超过20p，则加载更多数据  \n        //[self loadMoreData];//此处在view底部加载更多数据  \n    }  \n}\n```\n\n\n## UIScrollViewDelegate\n`UIScrollViewDelegate` 是 `UIScrollView` 的 `delegate protocol`，`UIScrollView` 有意思的功能都是通过它的 delegate 方法实现的。\n\n### - (void)scrollViewDidScroll:(UIScrollView *)scrollView\n这个方法在任何方式触发 `contentOffset` 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 `contentOffset` 的变化，并根据当前的 `contentOffset` 对其他 view 做出随动调整。\n\n### - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n用户开始拖动 scroll view 的时候被调用。\n\n### - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n在 didEndDragging 前被调用，当 willEndDragging 方法中 `velocity` 为 `CGPointZero`（结束拖动时两个方向都没有速度）时，didEndDragging 中的 `decelerate` 为 `NO`，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 `velocity` 不为 `CGPointZero` 时，scroll view 会以 `velocity` 为初速度，减速直到 `targetContentOffset`。值得注意的是，这里的 `targetContentOffset` 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。\n\n### - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n在用户结束拖动后被调用，`decelerate` 为 `YES` 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 `NO`，而是要等到减速结束之后，所以**这个 dragging 属性的实际语义更接近 scrolling**。\n\n### - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\n减速动画开始前被调用。\n\n### - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n减速动画结束时被调用。\n\n这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，**并且这时 scroll view 的 `dragging` 和 `decelerating` 属性都是 `YES`**(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。\n\n> Demo参见Delegate\n\n\n\n## 实例\n### Table View 中图片加载逻辑的优化\n**优化目的**：滑动时不加载图片，在滑动停止时加载图片\n\n**优化难点**：前面提到，刚开始拖动的时候，`dragging` 为 `YES`，`decelerating` 为 `NO`；`decelerate` 过程中，`dragging` 和 `decelerating` 都为 `YES`；decelerate 未结束时开始下一次拖动，`dragging` 和 `decelerating` 依然都为 `YES`。所以无法简单通过 table view 的 `dragging` 和 `decelerating` 判断是在用户拖动还是减速过程。\n\n所以不能仅通过`decelerating`来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看[原文](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)比较好）\n\n**优化方法**：\n1. 每次开始拖动时scrollViewWillBeginDragging，通过`NSArray *cells = [self.tableView visibleCells];`获取屏幕上所有显示的`Cell`，全部加载一遍图片（解决问题三）\n2. 利用`scrollViewWillEndDragging: withVelocity: targetContentOffset: `方法，将`targetContentOffset`即最后减速结束后在屏幕上显示的位置，转换为一个`CGRect`，在`CGRect`范围里的`Cell`才在`CellForRowAtIndex`中加载。\n\n> Demo详见LazyLoad\n\n### 分页的几种实现方法\n分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。\n\n#### pagingEnabled\n系统提供的分页方式，实现简单，只需要`_scrollView.pagingEnabled = YES`即可，但是有局限性：\n- 只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。\n- 需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）\n\nSample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：\n- 让 scroll view 的宽度为 page 宽度 + padding，并且设置 `clipsToBounds` 为 `NO`,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:\n- 这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能\n\n![UIScrollView_pagingEnabled](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true)\n\n适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。\n\n#### Snap\n核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。\n\n#### 修改targetContentOffset\n通过修改 `scrollViewWillEndDragging: withVelocity: targetContentOffset:` 方法中的 `targetContentOffset` 直接修改目标 `offset` 为整数页位置。其中核心代码：\n```objc\n- (CGPoint)nearestTargetOffsetForOffset:(CGPoint)offset\n{    CGFloat pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    NSInteger page = roundf(offset.x / pageSize);    CGFloat targetX = pageSize * page;    return CGPointMake(targetX, offset.y);\n}\n\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n{    CGPoint targetOffset = [self nearestTargetOffsetForOffset:*targetContentOffset];\n    targetContentOffset->x = targetOffset.x;\n    targetContentOffset->y = targetOffset.y;\n}\n```\n\n适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。\n\n> Demo详见Pagination\n\n### 重用\n大部分的 iOS 开发应该都清楚 `UITableView` 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，`UIScrollView` 作为 `UITableView` 的父类，在很多场景中也很适合应用重用机制。\n\n可以参照 `UITableView` 的 cell 重用机制，总结重用机制如下：\n- 维护一个重用队列\n- 当元素离开可见范围时，`removeFromSuperview` 并加入重用队列（enqueue）\n- 当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除\n- 如果队列为空，新建元素\n- 将新建元素的view通过`addSubView`添加至 `contentView`上\n- 这些一般都在 `scrollViewDidScroll:` 方法中完成\n\nDemo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo\n\n---\n这里要说明一下Demo中用到的`addChildViewController`。\n\n苹果在iOS 5 添加了一系列的方法，希望我们在使用`addSubView`时，同时调用`[self addChildViewController:child]`方法将sub view对应的viewController也加到当前ViewController的管理中。\n\n对于那些当前暂时不需要显示的subview，只通过`addChildViewController`把subViewController加进去；需要显示时再调用`transitionFromViewController`方法。将其添加进入底层的ViewController中。\n\n这样做的好处：\n1. 对页面中的逻辑更加分明了。相应的View对应相应的ViewController。\n2. 当某个子View没有显示时，将不会被Load，减少了内存的使用。\n3. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。\n4. 可以调用`transitionFromViewController`等系统方法，ios对于显示以及动画做了比较好的封装\n5. 相当于对于 ViewController 实例的保存。实例都保存在`self.childViewControllers`中，需要使用的时候从中取出即可。\n\n当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。\n\n其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候`[self.contentView addSubview:vc.view];`,不需要显示的时候`[vc.view removeFromSuperview];`，就可以达到显示和相应事件的需求了。\n\n---\n\n> Demo详见Reuse\n\n### 联动\n所谓联动，就是当 A 滚动的时候，在 **`scrollViewDidScroll:`** 里根据 A 的 `contentOffset` 动态计算 B 的 `contentOffset` 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。\n\nDemo中的核心代码:\n```objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView{\n    if (scrollView == self.titleScrollView) {\n        CGFloat contentX = self.titleScrollView.contentOffset.x / self.titleScrollView.frame.size.width * self.contentScrollView.frame.size.width;\n        self.contentScrollView.contentOffset = CGPointMake(contentX, 0.0);\n        CGFloat transX = self.titleScrollView.contentOffset.x / (self.titleScrollView.contentSize.width - self.titleScrollView.frame.size.width) * (self.backgroundImage.frame.size.width - self.view.frame.size.width);\n        transX = MAX(0.0, transX);\n        transX = MIN(self.backgroundImage.frame.size.width - self.view.frame.size.width, transX);\n        self.backgroundImage.transform = CGAffineTransformMakeTranslation(-transX, 0.0);\n    }\n}\n```\n通过`titleScrollView`计算`contentX`和`transX`来分别控制`contentScrollView`以及`backgroundImage`这两个View的位置变化。\n\n> Demo参见Parallax\n\n## 总结\nScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.\n\n> 上述所有Demo均在UIScrollViewDemo文件夹中\n\n\n\n\n\n\n","source":"_posts/Scrollview使用详解.md","raw":"title: UIScrollView详细介绍\ndate: 2016/9/18 14:07:12  \ncategories: IOS\ntags: \n\t- 基本控件\n\t\n---\n\n本次将参考[iOS 性能优化之 UIScrollView 实践经验](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)对UIScrollView的使用方式进行详细介绍\n<!--more-->\n\n## ScrollView和Auto Layout\n`UIScrollView` 在 `Auto Layout` 是一个很特殊的 `view`，对于 `UIScrollView` 的 `subview` 来说，它的 `leading/trailing/top/bottom space` 是**相对于 `UIScrollView`的 `contentSize` 而不是 `bounds` 来确定的。**\n\n所以，一般的做法是在`UIScrollVIew`和它的`subViews`之间增加一个`content view`。这样可以方便地给 `subview` 提供 `leading/trailing/top/bottom`，方便 `subview` 的布局，并且可以 通过调整`content view` 的 `size`（调整`constraint` 的 `IBOutlet`）来调整 `contentSize`。\n\n### 添加ContentView的注意点\n`scrollview`中添加的`contentview`和添加一般的视图不同，一般的视图只要只要提供`leading/trailing/top/bottom space`就能唯一确定长宽，位置。\n而`ScrollView`的`contentView`除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。\n\n所以整个`scrollview`的`contentSize`的等式应该是：\n```\nscrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）\n```\n\n**另外一点需要强调两点：**\n1. `ScrollView`的`bounds`早就确定了下来，在设置`contentview`的宽度的时候，如果设置`contentview.width = superview.width + constant`这里的`superview.width`是指`ScrollView.bounds`而不是`contentSize`\n2. 在设置`contentview`的上下左右约束的时候，如果设置`contentview.trailing = superview.trailing + constant`,这里的`superview.trailing`指的是`contentSize.trailing`而不是`bounds`。此时就可以通过上面的公式计算`contentSize`的宽度了。\n\n> Demo参见AutoLayout\n\n## UIScrollView部分属性\n### **contentSize**、**contentInset**和**contentOffset**\n- contentSize: 就是scrollview可以滚动的区域.\n比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。\n- contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。\n比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 \n- contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。\n例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 \n\n/* 上拉刷新一般实现代码如下 */\n```objc\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{     \n    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  \n    float offset=scrollView.contentOffset.y;  \n    float contentHeight=scrollView.contentSize.height;  \n    float sub=contentHeight-offset;  \n    if ((scrollView.height-sub)>20) {//如果上拉距离超过20p，则加载更多数据  \n        //[self loadMoreData];//此处在view底部加载更多数据  \n    }  \n}\n```\n\n\n## UIScrollViewDelegate\n`UIScrollViewDelegate` 是 `UIScrollView` 的 `delegate protocol`，`UIScrollView` 有意思的功能都是通过它的 delegate 方法实现的。\n\n### - (void)scrollViewDidScroll:(UIScrollView *)scrollView\n这个方法在任何方式触发 `contentOffset` 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 `contentOffset` 的变化，并根据当前的 `contentOffset` 对其他 view 做出随动调整。\n\n### - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\n用户开始拖动 scroll view 的时候被调用。\n\n### - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n在 didEndDragging 前被调用，当 willEndDragging 方法中 `velocity` 为 `CGPointZero`（结束拖动时两个方向都没有速度）时，didEndDragging 中的 `decelerate` 为 `NO`，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 `velocity` 不为 `CGPointZero` 时，scroll view 会以 `velocity` 为初速度，减速直到 `targetContentOffset`。值得注意的是，这里的 `targetContentOffset` 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。\n\n### - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n在用户结束拖动后被调用，`decelerate` 为 `YES` 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 `NO`，而是要等到减速结束之后，所以**这个 dragging 属性的实际语义更接近 scrolling**。\n\n### - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\n减速动画开始前被调用。\n\n### - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n减速动画结束时被调用。\n\n这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，**并且这时 scroll view 的 `dragging` 和 `decelerating` 属性都是 `YES`**(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。\n\n> Demo参见Delegate\n\n\n\n## 实例\n### Table View 中图片加载逻辑的优化\n**优化目的**：滑动时不加载图片，在滑动停止时加载图片\n\n**优化难点**：前面提到，刚开始拖动的时候，`dragging` 为 `YES`，`decelerating` 为 `NO`；`decelerate` 过程中，`dragging` 和 `decelerating` 都为 `YES`；decelerate 未结束时开始下一次拖动，`dragging` 和 `decelerating` 依然都为 `YES`。所以无法简单通过 table view 的 `dragging` 和 `decelerating` 判断是在用户拖动还是减速过程。\n\n所以不能仅通过`decelerating`来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看[原文](https://my.oschina.net/zhxx/blog/620969#OSC_h3_11)比较好）\n\n**优化方法**：\n1. 每次开始拖动时scrollViewWillBeginDragging，通过`NSArray *cells = [self.tableView visibleCells];`获取屏幕上所有显示的`Cell`，全部加载一遍图片（解决问题三）\n2. 利用`scrollViewWillEndDragging: withVelocity: targetContentOffset: `方法，将`targetContentOffset`即最后减速结束后在屏幕上显示的位置，转换为一个`CGRect`，在`CGRect`范围里的`Cell`才在`CellForRowAtIndex`中加载。\n\n> Demo详见LazyLoad\n\n### 分页的几种实现方法\n分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。\n\n#### pagingEnabled\n系统提供的分页方式，实现简单，只需要`_scrollView.pagingEnabled = YES`即可，但是有局限性：\n- 只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。\n- 需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）\n\nSample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：\n- 让 scroll view 的宽度为 page 宽度 + padding，并且设置 `clipsToBounds` 为 `NO`,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:\n- 这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能\n\n![UIScrollView_pagingEnabled](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true)\n\n适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。\n\n#### Snap\n核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。\n\n#### 修改targetContentOffset\n通过修改 `scrollViewWillEndDragging: withVelocity: targetContentOffset:` 方法中的 `targetContentOffset` 直接修改目标 `offset` 为整数页位置。其中核心代码：\n```objc\n- (CGPoint)nearestTargetOffsetForOffset:(CGPoint)offset\n{    CGFloat pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    NSInteger page = roundf(offset.x / pageSize);    CGFloat targetX = pageSize * page;    return CGPointMake(targetX, offset.y);\n}\n\n- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset\n{    CGPoint targetOffset = [self nearestTargetOffsetForOffset:*targetContentOffset];\n    targetContentOffset->x = targetOffset.x;\n    targetContentOffset->y = targetOffset.y;\n}\n```\n\n适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。\n\n> Demo详见Pagination\n\n### 重用\n大部分的 iOS 开发应该都清楚 `UITableView` 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，`UIScrollView` 作为 `UITableView` 的父类，在很多场景中也很适合应用重用机制。\n\n可以参照 `UITableView` 的 cell 重用机制，总结重用机制如下：\n- 维护一个重用队列\n- 当元素离开可见范围时，`removeFromSuperview` 并加入重用队列（enqueue）\n- 当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除\n- 如果队列为空，新建元素\n- 将新建元素的view通过`addSubView`添加至 `contentView`上\n- 这些一般都在 `scrollViewDidScroll:` 方法中完成\n\nDemo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo\n\n---\n这里要说明一下Demo中用到的`addChildViewController`。\n\n苹果在iOS 5 添加了一系列的方法，希望我们在使用`addSubView`时，同时调用`[self addChildViewController:child]`方法将sub view对应的viewController也加到当前ViewController的管理中。\n\n对于那些当前暂时不需要显示的subview，只通过`addChildViewController`把subViewController加进去；需要显示时再调用`transitionFromViewController`方法。将其添加进入底层的ViewController中。\n\n这样做的好处：\n1. 对页面中的逻辑更加分明了。相应的View对应相应的ViewController。\n2. 当某个子View没有显示时，将不会被Load，减少了内存的使用。\n3. 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。\n4. 可以调用`transitionFromViewController`等系统方法，ios对于显示以及动画做了比较好的封装\n5. 相当于对于 ViewController 实例的保存。实例都保存在`self.childViewControllers`中，需要使用的时候从中取出即可。\n\n当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。\n\n其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候`[self.contentView addSubview:vc.view];`,不需要显示的时候`[vc.view removeFromSuperview];`，就可以达到显示和相应事件的需求了。\n\n---\n\n> Demo详见Reuse\n\n### 联动\n所谓联动，就是当 A 滚动的时候，在 **`scrollViewDidScroll:`** 里根据 A 的 `contentOffset` 动态计算 B 的 `contentOffset` 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。\n\nDemo中的核心代码:\n```objc\n- (void)scrollViewDidScroll:(UIScrollView *)scrollView{\n    if (scrollView == self.titleScrollView) {\n        CGFloat contentX = self.titleScrollView.contentOffset.x / self.titleScrollView.frame.size.width * self.contentScrollView.frame.size.width;\n        self.contentScrollView.contentOffset = CGPointMake(contentX, 0.0);\n        CGFloat transX = self.titleScrollView.contentOffset.x / (self.titleScrollView.contentSize.width - self.titleScrollView.frame.size.width) * (self.backgroundImage.frame.size.width - self.view.frame.size.width);\n        transX = MAX(0.0, transX);\n        transX = MIN(self.backgroundImage.frame.size.width - self.view.frame.size.width, transX);\n        self.backgroundImage.transform = CGAffineTransformMakeTranslation(-transX, 0.0);\n    }\n}\n```\n通过`titleScrollView`计算`contentX`和`transX`来分别控制`contentScrollView`以及`backgroundImage`这两个View的位置变化。\n\n> Demo参见Parallax\n\n## 总结\nScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.\n\n> 上述所有Demo均在UIScrollViewDemo文件夹中\n\n\n\n\n\n\n","slug":"Scrollview使用详解","published":1,"updated":"2016-09-23T05:47:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzvn000prgrujvbuncsd","content":"<p>本次将参考<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\" target=\"_blank\" rel=\"external\">iOS 性能优化之 UIScrollView 实践经验</a>对UIScrollView的使用方式进行详细介绍<br><a id=\"more\"></a></p>\n<h2 id=\"ScrollView和Auto-Layout\"><a href=\"#ScrollView和Auto-Layout\" class=\"headerlink\" title=\"ScrollView和Auto Layout\"></a>ScrollView和Auto Layout</h2><p><code>UIScrollView</code> 在 <code>Auto Layout</code> 是一个很特殊的 <code>view</code>，对于 <code>UIScrollView</code> 的 <code>subview</code> 来说，它的 <code>leading/trailing/top/bottom space</code> 是<strong>相对于 <code>UIScrollView</code>的 <code>contentSize</code> 而不是 <code>bounds</code> 来确定的。</strong></p>\n<p>所以，一般的做法是在<code>UIScrollVIew</code>和它的<code>subViews</code>之间增加一个<code>content view</code>。这样可以方便地给 <code>subview</code> 提供 <code>leading/trailing/top/bottom</code>，方便 <code>subview</code> 的布局，并且可以 通过调整<code>content view</code> 的 <code>size</code>（调整<code>constraint</code> 的 <code>IBOutlet</code>）来调整 <code>contentSize</code>。</p>\n<h3 id=\"添加ContentView的注意点\"><a href=\"#添加ContentView的注意点\" class=\"headerlink\" title=\"添加ContentView的注意点\"></a>添加ContentView的注意点</h3><p><code>scrollview</code>中添加的<code>contentview</code>和添加一般的视图不同，一般的视图只要只要提供<code>leading/trailing/top/bottom space</code>就能唯一确定长宽，位置。<br>而<code>ScrollView</code>的<code>contentView</code>除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。</p>\n<p>所以整个<code>scrollview</code>的<code>contentSize</code>的等式应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）</div></pre></td></tr></table></figure></p>\n<p><strong>另外一点需要强调两点：</strong></p>\n<ol>\n<li><code>ScrollView</code>的<code>bounds</code>早就确定了下来，在设置<code>contentview</code>的宽度的时候，如果设置<code>contentview.width = superview.width + constant</code>这里的<code>superview.width</code>是指<code>ScrollView.bounds</code>而不是<code>contentSize</code></li>\n<li>在设置<code>contentview</code>的上下左右约束的时候，如果设置<code>contentview.trailing = superview.trailing + constant</code>,这里的<code>superview.trailing</code>指的是<code>contentSize.trailing</code>而不是<code>bounds</code>。此时就可以通过上面的公式计算<code>contentSize</code>的宽度了。</li>\n</ol>\n<blockquote>\n<p>Demo参见AutoLayout</p>\n</blockquote>\n<h2 id=\"UIScrollView部分属性\"><a href=\"#UIScrollView部分属性\" class=\"headerlink\" title=\"UIScrollView部分属性\"></a>UIScrollView部分属性</h2><h3 id=\"contentSize、contentInset和contentOffset\"><a href=\"#contentSize、contentInset和contentOffset\" class=\"headerlink\" title=\"contentSize、contentInset和contentOffset\"></a><strong>contentSize</strong>、<strong>contentInset</strong>和<strong>contentOffset</strong></h3><ul>\n<li>contentSize: 就是scrollview可以滚动的区域.<br>比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。</li>\n<li>contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。<br>比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 </li>\n<li>contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。<br>例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 </li>\n</ul>\n<p>/<em> 上拉刷新一般实现代码如下 </em>/<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView willDecelerate:(<span class=\"built_in\">BOOL</span>)decelerate&#123;     </div><div class=\"line\">    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  </div><div class=\"line\">    <span class=\"keyword\">float</span> offset=scrollView.contentOffset.y;  </div><div class=\"line\">    <span class=\"keyword\">float</span> contentHeight=scrollView.contentSize.height;  </div><div class=\"line\">    <span class=\"keyword\">float</span> sub=contentHeight-offset;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ((scrollView.height-sub)&gt;<span class=\"number\">20</span>) &#123;<span class=\"comment\">//如果上拉距离超过20p，则加载更多数据  </span></div><div class=\"line\">        <span class=\"comment\">//[self loadMoreData];//此处在view底部加载更多数据  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UIScrollViewDelegate\"><a href=\"#UIScrollViewDelegate\" class=\"headerlink\" title=\"UIScrollViewDelegate\"></a>UIScrollViewDelegate</h2><p><code>UIScrollViewDelegate</code> 是 <code>UIScrollView</code> 的 <code>delegate protocol</code>，<code>UIScrollView</code> 有意思的功能都是通过它的 delegate 方法实现的。</p>\n<h3 id=\"void-scrollViewDidScroll-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidScroll-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidScroll:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</h3><p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>\n<h3 id=\"void-scrollViewWillBeginDragging-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDragging-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</h3><p>用户开始拖动 scroll view 的时候被调用。</p>\n<h3 id=\"void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\"><a href=\"#void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\" class=\"headerlink\" title=\"- (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset\"></a>- (void)scrollViewWillEndDragging:(UIScrollView <em>)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint </em>)targetContentOffset</h3><p>在 didEndDragging 前被调用，当 willEndDragging 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，didEndDragging 中的 <code>decelerate</code> 为 <code>NO</code>，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。</p>\n<h3 id=\"void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\"><a href=\"#void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\"></a>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</h3><p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 <code>NO</code>，而是要等到减速结束之后，所以<strong>这个 dragging 属性的实际语义更接近 scrolling</strong>。</p>\n<h3 id=\"void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView</h3><p>减速动画开始前被调用。</p>\n<h3 id=\"void-scrollViewDidEndDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidEndDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</h3><p>减速动画结束时被调用。</p>\n<p>这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，<strong>并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 <code>YES</code></strong>(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。</p>\n<blockquote>\n<p>Demo参见Delegate</p>\n</blockquote>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"Table-View-中图片加载逻辑的优化\"><a href=\"#Table-View-中图片加载逻辑的优化\" class=\"headerlink\" title=\"Table View 中图片加载逻辑的优化\"></a>Table View 中图片加载逻辑的优化</h3><p><strong>优化目的</strong>：滑动时不加载图片，在滑动停止时加载图片</p>\n<p><strong>优化难点</strong>：前面提到，刚开始拖动的时候，<code>dragging</code> 为 <code>YES</code>，<code>decelerating</code> 为 <code>NO</code>；<code>decelerate</code> 过程中，<code>dragging</code> 和 <code>decelerating</code> 都为 <code>YES</code>；decelerate 未结束时开始下一次拖动，<code>dragging</code> 和 <code>decelerating</code> 依然都为 <code>YES</code>。所以无法简单通过 table view 的 <code>dragging</code> 和 <code>decelerating</code> 判断是在用户拖动还是减速过程。</p>\n<p>所以不能仅通过<code>decelerating</code>来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\" target=\"_blank\" rel=\"external\">原文</a>比较好）</p>\n<p><strong>优化方法</strong>：</p>\n<ol>\n<li>每次开始拖动时scrollViewWillBeginDragging，通过<code>NSArray *cells = [self.tableView visibleCells];</code>获取屏幕上所有显示的<code>Cell</code>，全部加载一遍图片（解决问题三）</li>\n<li>利用<code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code>方法，将<code>targetContentOffset</code>即最后减速结束后在屏幕上显示的位置，转换为一个<code>CGRect</code>，在<code>CGRect</code>范围里的<code>Cell</code>才在<code>CellForRowAtIndex</code>中加载。</li>\n</ol>\n<blockquote>\n<p>Demo详见LazyLoad</p>\n</blockquote>\n<h3 id=\"分页的几种实现方法\"><a href=\"#分页的几种实现方法\" class=\"headerlink\" title=\"分页的几种实现方法\"></a>分页的几种实现方法</h3><p>分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。</p>\n<h4 id=\"pagingEnabled\"><a href=\"#pagingEnabled\" class=\"headerlink\" title=\"pagingEnabled\"></a>pagingEnabled</h4><p>系统提供的分页方式，实现简单，只需要<code>_scrollView.pagingEnabled = YES</code>即可，但是有局限性：</p>\n<ul>\n<li>只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。</li>\n<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>\n</ul>\n<p>Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>\n<ul>\n<li>让 scroll view 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 <code>NO</code>,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:</li>\n<li>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true\" alt=\"UIScrollView_pagingEnabled\"></p>\n<p>适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>\n<h4 id=\"Snap\"><a href=\"#Snap\" class=\"headerlink\" title=\"Snap\"></a>Snap</h4><p>核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。</p>\n<h4 id=\"修改targetContentOffset\"><a href=\"#修改targetContentOffset\" class=\"headerlink\" title=\"修改targetContentOffset\"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 <code>offset</code> 为整数页位置。其中核心代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)nearestTargetOffsetForOffset:(<span class=\"built_in\">CGPoint</span>)offset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    <span class=\"built_in\">NSInteger</span> page = roundf(offset.x / pageSize);    <span class=\"built_in\">CGFloat</span> targetX = pageSize * page;    <span class=\"keyword\">return</span> <span class=\"built_in\">CGPointMake</span>(targetX, offset.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGPoint</span> targetOffset = [<span class=\"keyword\">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class=\"line\">    targetContentOffset-&gt;x = targetOffset.x;</div><div class=\"line\">    targetContentOffset-&gt;y = targetOffset.y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>\n<blockquote>\n<p>Demo详见Pagination</p>\n</blockquote>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>大部分的 iOS 开发应该都清楚 <code>UITableView</code> 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，<code>UIScrollView</code> 作为 <code>UITableView</code> 的父类，在很多场景中也很适合应用重用机制。</p>\n<p>可以参照 <code>UITableView</code> 的 cell 重用机制，总结重用机制如下：</p>\n<ul>\n<li>维护一个重用队列</li>\n<li>当元素离开可见范围时，<code>removeFromSuperview</code> 并加入重用队列（enqueue）</li>\n<li>当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除</li>\n<li>如果队列为空，新建元素</li>\n<li>将新建元素的view通过<code>addSubView</code>添加至 <code>contentView</code>上</li>\n<li>这些一般都在 <code>scrollViewDidScroll:</code> 方法中完成</li>\n</ul>\n<p>Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo</p>\n<hr>\n<p>这里要说明一下Demo中用到的<code>addChildViewController</code>。</p>\n<p>苹果在iOS 5 添加了一系列的方法，希望我们在使用<code>addSubView</code>时，同时调用<code>[self addChildViewController:child]</code>方法将sub view对应的viewController也加到当前ViewController的管理中。</p>\n<p>对于那些当前暂时不需要显示的subview，只通过<code>addChildViewController</code>把subViewController加进去；需要显示时再调用<code>transitionFromViewController</code>方法。将其添加进入底层的ViewController中。</p>\n<p>这样做的好处：</p>\n<ol>\n<li>对页面中的逻辑更加分明了。相应的View对应相应的ViewController。</li>\n<li>当某个子View没有显示时，将不会被Load，减少了内存的使用。</li>\n<li>当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。</li>\n<li>可以调用<code>transitionFromViewController</code>等系统方法，ios对于显示以及动画做了比较好的封装</li>\n<li>相当于对于 ViewController 实例的保存。实例都保存在<code>self.childViewControllers</code>中，需要使用的时候从中取出即可。</li>\n</ol>\n<p>当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。</p>\n<p>其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候<code>[self.contentView addSubview:vc.view];</code>,不需要显示的时候<code>[vc.view removeFromSuperview];</code>，就可以达到显示和相应事件的需求了。</p>\n<hr>\n<blockquote>\n<p>Demo详见Reuse</p>\n</blockquote>\n<h3 id=\"联动\"><a href=\"#联动\" class=\"headerlink\" title=\"联动\"></a>联动</h3><p>所谓联动，就是当 A 滚动的时候，在 <strong><code>scrollViewDidScroll:</code></strong> 里根据 A 的 <code>contentOffset</code> 动态计算 B 的 <code>contentOffset</code> 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。</p>\n<p>Demo中的核心代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scrollView == <span class=\"keyword\">self</span>.titleScrollView) &#123;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> contentX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / <span class=\"keyword\">self</span>.titleScrollView.frame.size.width * <span class=\"keyword\">self</span>.contentScrollView.frame.size.width;</div><div class=\"line\">        <span class=\"keyword\">self</span>.contentScrollView.contentOffset = <span class=\"built_in\">CGPointMake</span>(contentX, <span class=\"number\">0.0</span>);</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> transX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / (<span class=\"keyword\">self</span>.titleScrollView.contentSize.width - <span class=\"keyword\">self</span>.titleScrollView.frame.size.width) * (<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width);</div><div class=\"line\">        transX = MAX(<span class=\"number\">0.0</span>, transX);</div><div class=\"line\">        transX = MIN(<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width, transX);</div><div class=\"line\">        <span class=\"keyword\">self</span>.backgroundImage.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(-transX, <span class=\"number\">0.0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>titleScrollView</code>计算<code>contentX</code>和<code>transX</code>来分别控制<code>contentScrollView</code>以及<code>backgroundImage</code>这两个View的位置变化。</p>\n<blockquote>\n<p>Demo参见Parallax</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.</p>\n<blockquote>\n<p>上述所有Demo均在UIScrollViewDemo文件夹中</p>\n</blockquote>\n","excerpt":"<p>本次将参考<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\">iOS 性能优化之 UIScrollView 实践经验</a>对UIScrollView的使用方式进行详细介绍<br>","more":"</p>\n<h2 id=\"ScrollView和Auto-Layout\"><a href=\"#ScrollView和Auto-Layout\" class=\"headerlink\" title=\"ScrollView和Auto Layout\"></a>ScrollView和Auto Layout</h2><p><code>UIScrollView</code> 在 <code>Auto Layout</code> 是一个很特殊的 <code>view</code>，对于 <code>UIScrollView</code> 的 <code>subview</code> 来说，它的 <code>leading/trailing/top/bottom space</code> 是<strong>相对于 <code>UIScrollView</code>的 <code>contentSize</code> 而不是 <code>bounds</code> 来确定的。</strong></p>\n<p>所以，一般的做法是在<code>UIScrollVIew</code>和它的<code>subViews</code>之间增加一个<code>content view</code>。这样可以方便地给 <code>subview</code> 提供 <code>leading/trailing/top/bottom</code>，方便 <code>subview</code> 的布局，并且可以 通过调整<code>content view</code> 的 <code>size</code>（调整<code>constraint</code> 的 <code>IBOutlet</code>）来调整 <code>contentSize</code>。</p>\n<h3 id=\"添加ContentView的注意点\"><a href=\"#添加ContentView的注意点\" class=\"headerlink\" title=\"添加ContentView的注意点\"></a>添加ContentView的注意点</h3><p><code>scrollview</code>中添加的<code>contentview</code>和添加一般的视图不同，一般的视图只要只要提供<code>leading/trailing/top/bottom space</code>就能唯一确定长宽，位置。<br>而<code>ScrollView</code>的<code>contentView</code>除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。</p>\n<p>所以整个<code>scrollview</code>的<code>contentSize</code>的等式应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）</div></pre></td></tr></table></figure></p>\n<p><strong>另外一点需要强调两点：</strong></p>\n<ol>\n<li><code>ScrollView</code>的<code>bounds</code>早就确定了下来，在设置<code>contentview</code>的宽度的时候，如果设置<code>contentview.width = superview.width + constant</code>这里的<code>superview.width</code>是指<code>ScrollView.bounds</code>而不是<code>contentSize</code></li>\n<li>在设置<code>contentview</code>的上下左右约束的时候，如果设置<code>contentview.trailing = superview.trailing + constant</code>,这里的<code>superview.trailing</code>指的是<code>contentSize.trailing</code>而不是<code>bounds</code>。此时就可以通过上面的公式计算<code>contentSize</code>的宽度了。</li>\n</ol>\n<blockquote>\n<p>Demo参见AutoLayout</p>\n</blockquote>\n<h2 id=\"UIScrollView部分属性\"><a href=\"#UIScrollView部分属性\" class=\"headerlink\" title=\"UIScrollView部分属性\"></a>UIScrollView部分属性</h2><h3 id=\"contentSize、contentInset和contentOffset\"><a href=\"#contentSize、contentInset和contentOffset\" class=\"headerlink\" title=\"contentSize、contentInset和contentOffset\"></a><strong>contentSize</strong>、<strong>contentInset</strong>和<strong>contentOffset</strong></h3><ul>\n<li>contentSize: 就是scrollview可以滚动的区域.<br>比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。</li>\n<li>contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。<br>比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 </li>\n<li>contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。<br>例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 </li>\n</ul>\n<p>/<em> 上拉刷新一般实现代码如下 </em>/<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView willDecelerate:(<span class=\"built_in\">BOOL</span>)decelerate&#123;     </div><div class=\"line\">    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  </div><div class=\"line\">    <span class=\"keyword\">float</span> offset=scrollView.contentOffset.y;  </div><div class=\"line\">    <span class=\"keyword\">float</span> contentHeight=scrollView.contentSize.height;  </div><div class=\"line\">    <span class=\"keyword\">float</span> sub=contentHeight-offset;  </div><div class=\"line\">    <span class=\"keyword\">if</span> ((scrollView.height-sub)&gt;<span class=\"number\">20</span>) &#123;<span class=\"comment\">//如果上拉距离超过20p，则加载更多数据  </span></div><div class=\"line\">        <span class=\"comment\">//[self loadMoreData];//此处在view底部加载更多数据  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UIScrollViewDelegate\"><a href=\"#UIScrollViewDelegate\" class=\"headerlink\" title=\"UIScrollViewDelegate\"></a>UIScrollViewDelegate</h2><p><code>UIScrollViewDelegate</code> 是 <code>UIScrollView</code> 的 <code>delegate protocol</code>，<code>UIScrollView</code> 有意思的功能都是通过它的 delegate 方法实现的。</p>\n<h3 id=\"void-scrollViewDidScroll-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidScroll-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidScroll:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</h3><p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>\n<h3 id=\"void-scrollViewWillBeginDragging-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDragging-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</h3><p>用户开始拖动 scroll view 的时候被调用。</p>\n<h3 id=\"void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\"><a href=\"#void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset\" class=\"headerlink\" title=\"- (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset\"></a>- (void)scrollViewWillEndDragging:(UIScrollView <em>)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint </em>)targetContentOffset</h3><p>在 didEndDragging 前被调用，当 willEndDragging 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，didEndDragging 中的 <code>decelerate</code> 为 <code>NO</code>，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。</p>\n<h3 id=\"void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\"><a href=\"#void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\"></a>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</h3><p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 <code>NO</code>，而是要等到减速结束之后，所以<strong>这个 dragging 属性的实际语义更接近 scrolling</strong>。</p>\n<h3 id=\"void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewWillBeginDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView</h3><p>减速动画开始前被调用。</p>\n<h3 id=\"void-scrollViewDidEndDecelerating-UIScrollView-scrollView\"><a href=\"#void-scrollViewDidEndDecelerating-UIScrollView-scrollView\" class=\"headerlink\" title=\"- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\"></a>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</h3><p>减速动画结束时被调用。</p>\n<p>这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，<strong>并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 <code>YES</code></strong>(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。</p>\n<blockquote>\n<p>Demo参见Delegate</p>\n</blockquote>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"Table-View-中图片加载逻辑的优化\"><a href=\"#Table-View-中图片加载逻辑的优化\" class=\"headerlink\" title=\"Table View 中图片加载逻辑的优化\"></a>Table View 中图片加载逻辑的优化</h3><p><strong>优化目的</strong>：滑动时不加载图片，在滑动停止时加载图片</p>\n<p><strong>优化难点</strong>：前面提到，刚开始拖动的时候，<code>dragging</code> 为 <code>YES</code>，<code>decelerating</code> 为 <code>NO</code>；<code>decelerate</code> 过程中，<code>dragging</code> 和 <code>decelerating</code> 都为 <code>YES</code>；decelerate 未结束时开始下一次拖动，<code>dragging</code> 和 <code>decelerating</code> 依然都为 <code>YES</code>。所以无法简单通过 table view 的 <code>dragging</code> 和 <code>decelerating</code> 判断是在用户拖动还是减速过程。</p>\n<p>所以不能仅通过<code>decelerating</code>来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看<a href=\"https://my.oschina.net/zhxx/blog/620969#OSC_h3_11\">原文</a>比较好）</p>\n<p><strong>优化方法</strong>：</p>\n<ol>\n<li>每次开始拖动时scrollViewWillBeginDragging，通过<code>NSArray *cells = [self.tableView visibleCells];</code>获取屏幕上所有显示的<code>Cell</code>，全部加载一遍图片（解决问题三）</li>\n<li>利用<code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code>方法，将<code>targetContentOffset</code>即最后减速结束后在屏幕上显示的位置，转换为一个<code>CGRect</code>，在<code>CGRect</code>范围里的<code>Cell</code>才在<code>CellForRowAtIndex</code>中加载。</li>\n</ol>\n<blockquote>\n<p>Demo详见LazyLoad</p>\n</blockquote>\n<h3 id=\"分页的几种实现方法\"><a href=\"#分页的几种实现方法\" class=\"headerlink\" title=\"分页的几种实现方法\"></a>分页的几种实现方法</h3><p>分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。</p>\n<h4 id=\"pagingEnabled\"><a href=\"#pagingEnabled\" class=\"headerlink\" title=\"pagingEnabled\"></a>pagingEnabled</h4><p>系统提供的分页方式，实现简单，只需要<code>_scrollView.pagingEnabled = YES</code>即可，但是有局限性：</p>\n<ul>\n<li>只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。</li>\n<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>\n</ul>\n<p>Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>\n<ul>\n<li>让 scroll view 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 <code>NO</code>,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:</li>\n<li>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能</li>\n</ul>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true\" alt=\"UIScrollView_pagingEnabled\"></p>\n<p>适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>\n<h4 id=\"Snap\"><a href=\"#Snap\" class=\"headerlink\" title=\"Snap\"></a>Snap</h4><p>核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。</p>\n<h4 id=\"修改targetContentOffset\"><a href=\"#修改targetContentOffset\" class=\"headerlink\" title=\"修改targetContentOffset\"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 <code>offset</code> 为整数页位置。其中核心代码：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)nearestTargetOffsetForOffset:(<span class=\"built_in\">CGPoint</span>)offset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    <span class=\"built_in\">NSInteger</span> page = roundf(offset.x / pageSize);    <span class=\"built_in\">CGFloat</span> targetX = pageSize * page;    <span class=\"keyword\">return</span> <span class=\"built_in\">CGPointMake</span>(targetX, offset.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset</div><div class=\"line\">&#123;    <span class=\"built_in\">CGPoint</span> targetOffset = [<span class=\"keyword\">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class=\"line\">    targetContentOffset-&gt;x = targetOffset.x;</div><div class=\"line\">    targetContentOffset-&gt;y = targetOffset.y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>\n<blockquote>\n<p>Demo详见Pagination</p>\n</blockquote>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>大部分的 iOS 开发应该都清楚 <code>UITableView</code> 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，<code>UIScrollView</code> 作为 <code>UITableView</code> 的父类，在很多场景中也很适合应用重用机制。</p>\n<p>可以参照 <code>UITableView</code> 的 cell 重用机制，总结重用机制如下：</p>\n<ul>\n<li>维护一个重用队列</li>\n<li>当元素离开可见范围时，<code>removeFromSuperview</code> 并加入重用队列（enqueue）</li>\n<li>当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除</li>\n<li>如果队列为空，新建元素</li>\n<li>将新建元素的view通过<code>addSubView</code>添加至 <code>contentView</code>上</li>\n<li>这些一般都在 <code>scrollViewDidScroll:</code> 方法中完成</li>\n</ul>\n<p>Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo</p>\n<hr>\n<p>这里要说明一下Demo中用到的<code>addChildViewController</code>。</p>\n<p>苹果在iOS 5 添加了一系列的方法，希望我们在使用<code>addSubView</code>时，同时调用<code>[self addChildViewController:child]</code>方法将sub view对应的viewController也加到当前ViewController的管理中。</p>\n<p>对于那些当前暂时不需要显示的subview，只通过<code>addChildViewController</code>把subViewController加进去；需要显示时再调用<code>transitionFromViewController</code>方法。将其添加进入底层的ViewController中。</p>\n<p>这样做的好处：</p>\n<ol>\n<li>对页面中的逻辑更加分明了。相应的View对应相应的ViewController。</li>\n<li>当某个子View没有显示时，将不会被Load，减少了内存的使用。</li>\n<li>当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。</li>\n<li>可以调用<code>transitionFromViewController</code>等系统方法，ios对于显示以及动画做了比较好的封装</li>\n<li>相当于对于 ViewController 实例的保存。实例都保存在<code>self.childViewControllers</code>中，需要使用的时候从中取出即可。</li>\n</ol>\n<p>当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。</p>\n<p>其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候<code>[self.contentView addSubview:vc.view];</code>,不需要显示的时候<code>[vc.view removeFromSuperview];</code>，就可以达到显示和相应事件的需求了。</p>\n<hr>\n<blockquote>\n<p>Demo详见Reuse</p>\n</blockquote>\n<h3 id=\"联动\"><a href=\"#联动\" class=\"headerlink\" title=\"联动\"></a>联动</h3><p>所谓联动，就是当 A 滚动的时候，在 <strong><code>scrollViewDidScroll:</code></strong> 里根据 A 的 <code>contentOffset</code> 动态计算 B 的 <code>contentOffset</code> 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。</p>\n<p>Demo中的核心代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewDidScroll:(<span class=\"built_in\">UIScrollView</span> *)scrollView&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scrollView == <span class=\"keyword\">self</span>.titleScrollView) &#123;</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> contentX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / <span class=\"keyword\">self</span>.titleScrollView.frame.size.width * <span class=\"keyword\">self</span>.contentScrollView.frame.size.width;</div><div class=\"line\">        <span class=\"keyword\">self</span>.contentScrollView.contentOffset = <span class=\"built_in\">CGPointMake</span>(contentX, <span class=\"number\">0.0</span>);</div><div class=\"line\">        <span class=\"built_in\">CGFloat</span> transX = <span class=\"keyword\">self</span>.titleScrollView.contentOffset.x / (<span class=\"keyword\">self</span>.titleScrollView.contentSize.width - <span class=\"keyword\">self</span>.titleScrollView.frame.size.width) * (<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width);</div><div class=\"line\">        transX = MAX(<span class=\"number\">0.0</span>, transX);</div><div class=\"line\">        transX = MIN(<span class=\"keyword\">self</span>.backgroundImage.frame.size.width - <span class=\"keyword\">self</span>.view.frame.size.width, transX);</div><div class=\"line\">        <span class=\"keyword\">self</span>.backgroundImage.transform = <span class=\"built_in\">CGAffineTransformMakeTranslation</span>(-transX, <span class=\"number\">0.0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过<code>titleScrollView</code>计算<code>contentX</code>和<code>transX</code>来分别控制<code>contentScrollView</code>以及<code>backgroundImage</code>这两个View的位置变化。</p>\n<blockquote>\n<p>Demo参见Parallax</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.</p>\n<blockquote>\n<p>上述所有Demo均在UIScrollViewDemo文件夹中</p>\n</blockquote>"},{"title":"UIGestureRecognizer","date":"2016-09-05T06:07:12.000Z","_content":"\n在iOS系统中，手势是进行用户交互的重要方式，通过`UIGestureRecognizer`类，我们可以轻松的创建出各种手势应用于app中。关于`UIGestureRecognizer`类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。\n\n<!--more-->\n\n## 手势的抽象类——UIGestureRecognizer\n`UIGestureRecognizer`将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用`UIGestureRecognizer`的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，`UIGestureRecognizer`中抽象出了哪些方法。\n\n### 初始化方法\n`UIGestureRecognizer`类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：\n```objc\n- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action;\n```\n如果我们使用`alloc-init`的方式，也是可以的，下面的方法可以为手势添加触发的`selector`：\n```objc\n- (void)addTarget:(id)target action:(SEL)action;\n```\n与之相对应的，我们也可以将一个`selector`从其手势对象上移除：\n```objc\n- (void)removeTarget:(nullable id)target action:(nullable SEL)action;\n```\n这里的`target`一般都是`self`,因为`selector`一般都是在`self`中定义。\n\n因为`addTarget`方式的存在，iOS系统允许一个手势对象可以添加多个`selector`触发方法，并且触发的时候，所有添加的`selector`都会被执行，我们以点击手势示例如下:\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];\n    [ges addTarget:self action:@selector(haha)];\n     [self.view addGestureRecognizer:ges];\n}\n-(void)click:(UIGestureRecognizer *)ges{\n    \n    NSLog(@\"第一个手势的触发方法\");\n    \n}\n-(void)haha{\n    NSLog(@\"haha\");\n}\n```\n点击屏幕后，两个方法都会触发。\n\n### 手势状态\nUIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:\n```objc\n@property(nonatomic,readonly) UIGestureRecognizerState state;\n```\n枚举值如下：\n```objc\ntypedef NS_ENUM(NSInteger, UIGestureRecognizerState) {\n    UIGestureRecognizerStatePossible,   // 默认的状态，这个时候的手势并没有具体的情形状态\n    UIGestureRecognizerStateBegan,      // 手势开始被识别的状态\n    UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态\n    UIGestureRecognizerStateEnded,      // 手势识别结束，将会执行触发的方法\n    UIGestureRecognizerStateCancelled,  // 手势识别取消\n    UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用\n    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded \n};\n```\n可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。\n\n### 常用属性和方法\n```objc\n//设置代理，具体的协议后面会说\n@property(nullable,nonatomic,weak) id <UIGestureRecognizerDelegate> delegate; \n//设置手势是否有效\n@property(nonatomic, getter=isEnabled) BOOL enabled;\n//获取手势所在的view\n@property(nullable, nonatomic,readonly) UIView *view; \n//获取触发触摸的点\n- (CGPoint)locationInView:(nullable UIView*)view; \n//设置触摸点数\n- (NSUInteger)numberOfTouches; \n//获取某一个触摸点的触摸位置\n- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view;\n```\n其中，`UITouch`也有一个方法是`locationInView:`可以获取触摸点在view中的位置。\n可以通过设置`numberOfTapsRequired`来区分单击双击：\n```objc\nUITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(DoubleTap:)];\ndoubleTap.numberOfTapsRequired = 2; //点击的次数 ＝2 双击\n[_imageView addGestureRecognizer:doubleTap];//给对象添加一个手势监测；\n```\n\n另外还有三个属性用来控制触摸事件：\n```objc\n@property(nonatomic) BOOL cancelsTouchesInView;\n@property(nonatomic) BOOL delaysTouchesBegan;\n@property(nonatomic) BOOL delaysTouchesEnded;\n```\n\n**cancelsTouchesInView**\n默认为YES,这种情况下当手势识别器识别到touch之后，会发送`touchesCancelled:withEvent:`消息,终止触摸事件的传递,以取消 `UIResponder`对touch的响应，这个时候只有手势识别器响应touch。\n当设置成NO时，手势识别器识别到touch之后不会发送`touchesCancelled:withEvent:`消息，这个时候手势识别器和`UIResponder`均响应touch。\n**注意：**发送`touchesCancelled:withEvent:`消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后`touchesCancelled:withEvent:`消息才会生效，屏蔽touch操作。\n\n**delaysTouchesBegan**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给`UIResponder`，两者各自做出响应。\n如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给`UIResponder`，即`UIResponder`不会有任何触摸事件。只有在识别失败之后才会将touch发给`UIResponder`，这种情况下`UIResponder`的响应会延迟约0.15ms。\n\n**delaysTouchesEnded**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给`touchesCancelled:withEvent:`消息给`UIResponder`，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送`touchesEnded:withEvent:`。\n如果设置为NO，则不会延迟，即会立即发送`touchesEnded:withEvent:`以结束当前触摸。\n\n### 手势间的互斥\n有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];;\n    \n    //view.backgroundColor = [UIColor redColor];\n   \n    //ges.delegate=self;\n    [self.view addGestureRecognizer:ges];\n    \n    UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];\n//    ges2.delegate=self;\n        [self.view addGestureRecognizer:ges2];\n}\n\n\n-(void)click:(UIGestureRecognizer *)ges{\n    NSLog(@\"第一个手势的触发方法\");\n}\n-(void)click1:(UIGestureRecognizer *)ges1{\n    NSLog(@\"第二个手势的触发方法\");   \n}\n```\n\n我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：\n```objc\n[ges requireGestureRecognizerToFail:ges2];\n```\n表示如果`ges2`匹配，那么不会执行`ges`。只有当`ges2`不匹配的时候，才会执行`ges`。\n\n### UIGestureRecognizerDelegate\n前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：\n```objc\n//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;\n//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;\n//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;\n//下面这个两个方法也是用来控制手势的互斥执行的\n//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n//这个方法返回YES，第一个和第二个互斥时，第二个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n```\n最下面两个方法用起来还挺麻烦的，因为你不知道哪个是`gestureRecognizer`哪个是`otherGestureRecognizer`,因此，只能笼统的设置。\n\n\n### 手势和触摸的区别\n前一篇我们学习了`UITouch`,可以通过重写`UIResponder`的几个`touch`方法来处理触摸事件。\n`UIGestureRecognizer`和触摸事件是两个独立的事,手势和`UITouch`本身关系不大。不过手势可以通过`cancelsTouchesInView`,`delaysTouchesBegan`,`delaysTouchesEnded`这三个属性来影响触摸事件。\n\n## UIGestureRecognizer的子类\n### 点击手势——UITapGestureRecognizer\n点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：\n```objc\n//设置点击次数，默认为单击\n@property (nonatomic) NSUInteger  numberOfTapsRequired; \n//设置同时点击的手指数\n@property (nonatomic) NSUInteger  numberOfTouchesRequired;\n```\n\n### 捏合手势——UIPinchGestureRecognizer\n捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：\n```objc\n//设置缩放比例\n@property (nonatomic)          CGFloat scale; \n//设置捏合速度\n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完缩放后，一定要把`recognizer.scale`设置为1\n```objc\n- (void)handlePinch:(UIPinchGestureRecognizer*)recognizer{\n    NSLog(@\"缩放操作\");//处理缩放操作\n    //对imageview缩放\n    _imageView.transform = CGAffineTransformScale(_imageView.transform, recognizer.scale, recognizer.scale);\n    recognizer.scale = 1;\n}\n```\n\n### 拖拽手势——UIPanGestureRecognzer\n当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。\n```objc\n//设置触发拖拽的最少触摸点，默认为1\n@property (nonatomic)          NSUInteger minimumNumberOfTouches; \n//设置触发拖拽的最多触摸点\n@property (nonatomic)          NSUInteger maximumNumberOfTouches;  \n//获取当前位置\n- (CGPoint)translationInView:(nullable UIView *)view;            \n//设置当前位置\n- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;\n//设置拖拽速度\n- (CGPoint)velocityInView:(nullable UIView *)view;\n```\n代码示例：\n```objc\n-(void)handlePan:(UIPanGestureRecognizer*)recognizer{\n    NSLog(@\"拖动操作\");\n    //处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右\n    CGPoint translation = [recognizer translationInView:_imageView];\n    recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x,\n                                         recognizer.view.center.y + translation.y);\n    [recognizer setTranslation:CGPointZero inView:_imageView];\n}\n```\n必须使用`setTranslation`设置为`CGPointZero`,不知道为什么\n\n### 滑动手势——UISwipeGestureRecognizer\n滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢\n```objc\n//设置触发滑动手势的触摸点数\n@property(nonatomic) NSUInteger                        numberOfTouchesRequired; \n//设置滑动方向\n@property(nonatomic) UISwipeGestureRecognizerDirection direction;  \n//枚举如下\ntypedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) {\n    UISwipeGestureRecognizerDirectionRight = 1 << 0,\n    UISwipeGestureRecognizerDirectionLeft  = 1 << 1,\n    UISwipeGestureRecognizerDirectionUp    = 1 << 2,\n    UISwipeGestureRecognizerDirectionDown  = 1 << 3\n};\n```\n\n### 旋转手势——UIRotationGestureRecognizer\n进行旋转动作时触发手势方法\n```objc\n//设置旋转角度\n@property (nonatomic)          CGFloat rotation;\n//设置旋转速度 \n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完旋转后，`recognizer.rotation`一定要清零.\n```objc\n- (void)handleRotate:(UIRotationGestureRecognizer*) recognizer{\n    NSLog(@\"旋转操作\");//处理旋转操作\n    //对imageview旋转\n    _imageView.transform = CGAffineTransformRotate(_imageView.transform, recognizer.rotation);\n    recognizer.rotation = 0;    //一定要清零\n}\n```\n\n### 长按手势——UILongPressGestureRecognizer\n进行长按的时候触发的手势方法\n```objc\n//设置触发前的点击次数\n@property (nonatomic) NSUInteger numberOfTapsRequired;    \n//设置触发的触摸点数\n@property (nonatomic) NSUInteger numberOfTouchesRequired; \n//设置最短的长按时间\n@property (nonatomic) CFTimeInterval minimumPressDuration; \n//设置在按触时时允许移动的最大距离 默认为10像素\n@property (nonatomic) CGFloat allowableMovement;\n```\n\n### 手势组合的问题\n这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：\n![手势组合](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true)\n当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。\n\n> Demo 详见UIGestureRecognizer","source":"_posts/UIGestureRecognizer.md","raw":"title: UIGestureRecognizer\ndate: 2016/9/5 14:07:12  \ncategories: IOS\ntags: \n\t- UIGesture\n\t\n---\n\n在iOS系统中，手势是进行用户交互的重要方式，通过`UIGestureRecognizer`类，我们可以轻松的创建出各种手势应用于app中。关于`UIGestureRecognizer`类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。\n\n<!--more-->\n\n## 手势的抽象类——UIGestureRecognizer\n`UIGestureRecognizer`将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用`UIGestureRecognizer`的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，`UIGestureRecognizer`中抽象出了哪些方法。\n\n### 初始化方法\n`UIGestureRecognizer`类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：\n```objc\n- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action;\n```\n如果我们使用`alloc-init`的方式，也是可以的，下面的方法可以为手势添加触发的`selector`：\n```objc\n- (void)addTarget:(id)target action:(SEL)action;\n```\n与之相对应的，我们也可以将一个`selector`从其手势对象上移除：\n```objc\n- (void)removeTarget:(nullable id)target action:(nullable SEL)action;\n```\n这里的`target`一般都是`self`,因为`selector`一般都是在`self`中定义。\n\n因为`addTarget`方式的存在，iOS系统允许一个手势对象可以添加多个`selector`触发方法，并且触发的时候，所有添加的`selector`都会被执行，我们以点击手势示例如下:\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];\n    [ges addTarget:self action:@selector(haha)];\n     [self.view addGestureRecognizer:ges];\n}\n-(void)click:(UIGestureRecognizer *)ges{\n    \n    NSLog(@\"第一个手势的触发方法\");\n    \n}\n-(void)haha{\n    NSLog(@\"haha\");\n}\n```\n点击屏幕后，两个方法都会触发。\n\n### 手势状态\nUIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:\n```objc\n@property(nonatomic,readonly) UIGestureRecognizerState state;\n```\n枚举值如下：\n```objc\ntypedef NS_ENUM(NSInteger, UIGestureRecognizerState) {\n    UIGestureRecognizerStatePossible,   // 默认的状态，这个时候的手势并没有具体的情形状态\n    UIGestureRecognizerStateBegan,      // 手势开始被识别的状态\n    UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态\n    UIGestureRecognizerStateEnded,      // 手势识别结束，将会执行触发的方法\n    UIGestureRecognizerStateCancelled,  // 手势识别取消\n    UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用\n    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded \n};\n```\n可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。\n\n### 常用属性和方法\n```objc\n//设置代理，具体的协议后面会说\n@property(nullable,nonatomic,weak) id <UIGestureRecognizerDelegate> delegate; \n//设置手势是否有效\n@property(nonatomic, getter=isEnabled) BOOL enabled;\n//获取手势所在的view\n@property(nullable, nonatomic,readonly) UIView *view; \n//获取触发触摸的点\n- (CGPoint)locationInView:(nullable UIView*)view; \n//设置触摸点数\n- (NSUInteger)numberOfTouches; \n//获取某一个触摸点的触摸位置\n- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view;\n```\n其中，`UITouch`也有一个方法是`locationInView:`可以获取触摸点在view中的位置。\n可以通过设置`numberOfTapsRequired`来区分单击双击：\n```objc\nUITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(DoubleTap:)];\ndoubleTap.numberOfTapsRequired = 2; //点击的次数 ＝2 双击\n[_imageView addGestureRecognizer:doubleTap];//给对象添加一个手势监测；\n```\n\n另外还有三个属性用来控制触摸事件：\n```objc\n@property(nonatomic) BOOL cancelsTouchesInView;\n@property(nonatomic) BOOL delaysTouchesBegan;\n@property(nonatomic) BOOL delaysTouchesEnded;\n```\n\n**cancelsTouchesInView**\n默认为YES,这种情况下当手势识别器识别到touch之后，会发送`touchesCancelled:withEvent:`消息,终止触摸事件的传递,以取消 `UIResponder`对touch的响应，这个时候只有手势识别器响应touch。\n当设置成NO时，手势识别器识别到touch之后不会发送`touchesCancelled:withEvent:`消息，这个时候手势识别器和`UIResponder`均响应touch。\n**注意：**发送`touchesCancelled:withEvent:`消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后`touchesCancelled:withEvent:`消息才会生效，屏蔽touch操作。\n\n**delaysTouchesBegan**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给`UIResponder`，两者各自做出响应。\n如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给`UIResponder`，即`UIResponder`不会有任何触摸事件。只有在识别失败之后才会将touch发给`UIResponder`，这种情况下`UIResponder`的响应会延迟约0.15ms。\n\n**delaysTouchesEnded**\n在前面`cancelsTouchesInView`属性为NO的基础上.\n默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给`touchesCancelled:withEvent:`消息给`UIResponder`，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送`touchesEnded:withEvent:`。\n如果设置为NO，则不会延迟，即会立即发送`touchesEnded:withEvent:`以结束当前触摸。\n\n### 手势间的互斥\n有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：\n```objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n     UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];;\n    \n    //view.backgroundColor = [UIColor redColor];\n   \n    //ges.delegate=self;\n    [self.view addGestureRecognizer:ges];\n    \n    UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];\n//    ges2.delegate=self;\n        [self.view addGestureRecognizer:ges2];\n}\n\n\n-(void)click:(UIGestureRecognizer *)ges{\n    NSLog(@\"第一个手势的触发方法\");\n}\n-(void)click1:(UIGestureRecognizer *)ges1{\n    NSLog(@\"第二个手势的触发方法\");   \n}\n```\n\n我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：\n```objc\n[ges requireGestureRecognizerToFail:ges2];\n```\n表示如果`ges2`匹配，那么不会执行`ges`。只有当`ges2`不匹配的时候，才会执行`ges`。\n\n### UIGestureRecognizerDelegate\n前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：\n```objc\n//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;\n//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势\n- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;\n//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;\n//下面这个两个方法也是用来控制手势的互斥执行的\n//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n//这个方法返回YES，第一个和第二个互斥时，第二个会失效\n- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);\n```\n最下面两个方法用起来还挺麻烦的，因为你不知道哪个是`gestureRecognizer`哪个是`otherGestureRecognizer`,因此，只能笼统的设置。\n\n\n### 手势和触摸的区别\n前一篇我们学习了`UITouch`,可以通过重写`UIResponder`的几个`touch`方法来处理触摸事件。\n`UIGestureRecognizer`和触摸事件是两个独立的事,手势和`UITouch`本身关系不大。不过手势可以通过`cancelsTouchesInView`,`delaysTouchesBegan`,`delaysTouchesEnded`这三个属性来影响触摸事件。\n\n## UIGestureRecognizer的子类\n### 点击手势——UITapGestureRecognizer\n点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：\n```objc\n//设置点击次数，默认为单击\n@property (nonatomic) NSUInteger  numberOfTapsRequired; \n//设置同时点击的手指数\n@property (nonatomic) NSUInteger  numberOfTouchesRequired;\n```\n\n### 捏合手势——UIPinchGestureRecognizer\n捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：\n```objc\n//设置缩放比例\n@property (nonatomic)          CGFloat scale; \n//设置捏合速度\n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完缩放后，一定要把`recognizer.scale`设置为1\n```objc\n- (void)handlePinch:(UIPinchGestureRecognizer*)recognizer{\n    NSLog(@\"缩放操作\");//处理缩放操作\n    //对imageview缩放\n    _imageView.transform = CGAffineTransformScale(_imageView.transform, recognizer.scale, recognizer.scale);\n    recognizer.scale = 1;\n}\n```\n\n### 拖拽手势——UIPanGestureRecognzer\n当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。\n```objc\n//设置触发拖拽的最少触摸点，默认为1\n@property (nonatomic)          NSUInteger minimumNumberOfTouches; \n//设置触发拖拽的最多触摸点\n@property (nonatomic)          NSUInteger maximumNumberOfTouches;  \n//获取当前位置\n- (CGPoint)translationInView:(nullable UIView *)view;            \n//设置当前位置\n- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;\n//设置拖拽速度\n- (CGPoint)velocityInView:(nullable UIView *)view;\n```\n代码示例：\n```objc\n-(void)handlePan:(UIPanGestureRecognizer*)recognizer{\n    NSLog(@\"拖动操作\");\n    //处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右\n    CGPoint translation = [recognizer translationInView:_imageView];\n    recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x,\n                                         recognizer.view.center.y + translation.y);\n    [recognizer setTranslation:CGPointZero inView:_imageView];\n}\n```\n必须使用`setTranslation`设置为`CGPointZero`,不知道为什么\n\n### 滑动手势——UISwipeGestureRecognizer\n滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢\n```objc\n//设置触发滑动手势的触摸点数\n@property(nonatomic) NSUInteger                        numberOfTouchesRequired; \n//设置滑动方向\n@property(nonatomic) UISwipeGestureRecognizerDirection direction;  \n//枚举如下\ntypedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) {\n    UISwipeGestureRecognizerDirectionRight = 1 << 0,\n    UISwipeGestureRecognizerDirectionLeft  = 1 << 1,\n    UISwipeGestureRecognizerDirectionUp    = 1 << 2,\n    UISwipeGestureRecognizerDirectionDown  = 1 << 3\n};\n```\n\n### 旋转手势——UIRotationGestureRecognizer\n进行旋转动作时触发手势方法\n```objc\n//设置旋转角度\n@property (nonatomic)          CGFloat rotation;\n//设置旋转速度 \n@property (nonatomic,readonly) CGFloat velocity;\n```\n在设置完旋转后，`recognizer.rotation`一定要清零.\n```objc\n- (void)handleRotate:(UIRotationGestureRecognizer*) recognizer{\n    NSLog(@\"旋转操作\");//处理旋转操作\n    //对imageview旋转\n    _imageView.transform = CGAffineTransformRotate(_imageView.transform, recognizer.rotation);\n    recognizer.rotation = 0;    //一定要清零\n}\n```\n\n### 长按手势——UILongPressGestureRecognizer\n进行长按的时候触发的手势方法\n```objc\n//设置触发前的点击次数\n@property (nonatomic) NSUInteger numberOfTapsRequired;    \n//设置触发的触摸点数\n@property (nonatomic) NSUInteger numberOfTouchesRequired; \n//设置最短的长按时间\n@property (nonatomic) CFTimeInterval minimumPressDuration; \n//设置在按触时时允许移动的最大距离 默认为10像素\n@property (nonatomic) CGFloat allowableMovement;\n```\n\n### 手势组合的问题\n这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：\n![手势组合](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true)\n当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。\n\n> Demo 详见UIGestureRecognizer","slug":"UIGestureRecognizer","published":1,"updated":"2016-09-23T05:44:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzwn001hrgrutpudkcbx","content":"<p>在iOS系统中，手势是进行用户交互的重要方式，通过<code>UIGestureRecognizer</code>类，我们可以轻松的创建出各种手势应用于app中。关于<code>UIGestureRecognizer</code>类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。</p>\n<a id=\"more\"></a>\n<h2 id=\"手势的抽象类——UIGestureRecognizer\"><a href=\"#手势的抽象类——UIGestureRecognizer\" class=\"headerlink\" title=\"手势的抽象类——UIGestureRecognizer\"></a>手势的抽象类——UIGestureRecognizer</h2><p><code>UIGestureRecognizer</code>将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用<code>UIGestureRecognizer</code>的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，<code>UIGestureRecognizer</code>中抽象出了哪些方法。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p><code>UIGestureRecognizer</code>类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>如果我们使用<code>alloc-init</code>的方式，也是可以的，下面的方法可以为手势添加触发的<code>selector</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action;</div></pre></td></tr></table></figure></p>\n<p>与之相对应的，我们也可以将一个<code>selector</code>从其手势对象上移除：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>target</code>一般都是<code>self</code>,因为<code>selector</code>一般都是在<code>self</code>中定义。</p>\n<p>因为<code>addTarget</code>方式的存在，iOS系统允许一个手势对象可以添加多个<code>selector</code>触发方法，并且触发的时候，所有添加的<code>selector</code>都会被执行，我们以点击手势示例如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];</div><div class=\"line\">    [ges addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(haha)];</div><div class=\"line\">     [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)haha&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>点击屏幕后，两个方法都会触发。</p>\n<h3 id=\"手势状态\"><a href=\"#手势状态\" class=\"headerlink\" title=\"手势状态\"></a>手势状态</h3><p>UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIGestureRecognizerState</span> state;</div></pre></td></tr></table></figure></p>\n<p>枚举值如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIGestureRecognizerState</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStatePossible</span>,   <span class=\"comment\">// 默认的状态，这个时候的手势并没有具体的情形状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateBegan</span>,      <span class=\"comment\">// 手势开始被识别的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateChanged</span>,    <span class=\"comment\">// 手势识别发生改变的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateEnded</span>,      <span class=\"comment\">// 手势识别结束，将会执行触发的方法</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateCancelled</span>,  <span class=\"comment\">// 手势识别取消</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateFailed</span>,     <span class=\"comment\">// 识别失败，方法将不会被调用</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateRecognized</span> = <span class=\"built_in\">UIGestureRecognizerStateEnded</span> </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。</p>\n<h3 id=\"常用属性和方法\"><a href=\"#常用属性和方法\" class=\"headerlink\" title=\"常用属性和方法\"></a>常用属性和方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置代理，具体的协议后面会说</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class=\"line\"><span class=\"comment\">//设置手势是否有效</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isEnabled) <span class=\"built_in\">BOOL</span> enabled;</div><div class=\"line\"><span class=\"comment\">//获取手势所在的view</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIView</span> *view; </div><div class=\"line\"><span class=\"comment\">//获取触发触摸的点</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view; </div><div class=\"line\"><span class=\"comment\">//设置触摸点数</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfTouches; </div><div class=\"line\"><span class=\"comment\">//获取某一个触摸点的触摸位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationOfTouch:(<span class=\"built_in\">NSUInteger</span>)touchIndex inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view;</div></pre></td></tr></table></figure>\n<p>其中，<code>UITouch</code>也有一个方法是<code>locationInView:</code>可以获取触摸点在view中的位置。<br>可以通过设置<code>numberOfTapsRequired</code>来区分单击双击：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITapGestureRecognizer</span> *doubleTap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(DoubleTap:)];</div><div class=\"line\">doubleTap.numberOfTapsRequired = <span class=\"number\">2</span>; <span class=\"comment\">//点击的次数 ＝2 双击</span></div><div class=\"line\">[_imageView addGestureRecognizer:doubleTap];<span class=\"comment\">//给对象添加一个手势监测；</span></div></pre></td></tr></table></figure></p>\n<p>另外还有三个属性用来控制触摸事件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> cancelsTouchesInView;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesBegan;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesEnded;</div></pre></td></tr></table></figure></p>\n<p><strong>cancelsTouchesInView</strong><br>默认为YES,这种情况下当手势识别器识别到touch之后，会发送<code>touchesCancelled:withEvent:</code>消息,终止触摸事件的传递,以取消 <code>UIResponder</code>对touch的响应，这个时候只有手势识别器响应touch。<br>当设置成NO时，手势识别器识别到touch之后不会发送<code>touchesCancelled:withEvent:</code>消息，这个时候手势识别器和<code>UIResponder</code>均响应touch。<br><strong>注意：</strong>发送<code>touchesCancelled:withEvent:</code>消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后<code>touchesCancelled:withEvent:</code>消息才会生效，屏蔽touch操作。</p>\n<p><strong>delaysTouchesBegan</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给<code>UIResponder</code>，两者各自做出响应。<br>如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给<code>UIResponder</code>，即<code>UIResponder</code>不会有任何触摸事件。只有在识别失败之后才会将touch发给<code>UIResponder</code>，这种情况下<code>UIResponder</code>的响应会延迟约0.15ms。</p>\n<p><strong>delaysTouchesEnded</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给<code>touchesCancelled:withEvent:</code>消息给<code>UIResponder</code>，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送<code>touchesEnded:withEvent:</code>。<br>如果设置为NO，则不会延迟，即会立即发送<code>touchesEnded:withEvent:</code>以结束当前触摸。</p>\n<h3 id=\"手势间的互斥\"><a href=\"#手势间的互斥\" class=\"headerlink\" title=\"手势间的互斥\"></a>手势间的互斥</h3><p>有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//view.backgroundColor = [UIColor redColor];</span></div><div class=\"line\">   </div><div class=\"line\">    <span class=\"comment\">//ges.delegate=self;</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> * ges2 = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click1:)];</div><div class=\"line\"><span class=\"comment\">//    ges2.delegate=self;</span></div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click1:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges1&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二个手势的触发方法\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ges requireGestureRecognizerToFail:ges2];</div></pre></td></tr></table></figure></p>\n<p>表示如果<code>ges2</code>匹配，那么不会执行<code>ges</code>。只有当<code>ges2</code>不匹配的时候，才会执行<code>ges</code>。</p>\n<h3 id=\"UIGestureRecognizerDelegate\"><a href=\"#UIGestureRecognizerDelegate\" class=\"headerlink\" title=\"UIGestureRecognizerDelegate\"></a>UIGestureRecognizerDelegate</h3><p>前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class=\"built_in\">UITouch</span> *)touch;</div><div class=\"line\"><span class=\"comment\">//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizerShouldBegin:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//下面这个两个方法也是用来控制手势的互斥执行的</span></div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个和第二个互斥时，第二个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div></pre></td></tr></table></figure></p>\n<p>最下面两个方法用起来还挺麻烦的，因为你不知道哪个是<code>gestureRecognizer</code>哪个是<code>otherGestureRecognizer</code>,因此，只能笼统的设置。</p>\n<h3 id=\"手势和触摸的区别\"><a href=\"#手势和触摸的区别\" class=\"headerlink\" title=\"手势和触摸的区别\"></a>手势和触摸的区别</h3><p>前一篇我们学习了<code>UITouch</code>,可以通过重写<code>UIResponder</code>的几个<code>touch</code>方法来处理触摸事件。<br><code>UIGestureRecognizer</code>和触摸事件是两个独立的事,手势和<code>UITouch</code>本身关系不大。不过手势可以通过<code>cancelsTouchesInView</code>,<code>delaysTouchesBegan</code>,<code>delaysTouchesEnded</code>这三个属性来影响触摸事件。</p>\n<h2 id=\"UIGestureRecognizer的子类\"><a href=\"#UIGestureRecognizer的子类\" class=\"headerlink\" title=\"UIGestureRecognizer的子类\"></a>UIGestureRecognizer的子类</h2><h3 id=\"点击手势——UITapGestureRecognizer\"><a href=\"#点击手势——UITapGestureRecognizer\" class=\"headerlink\" title=\"点击手势——UITapGestureRecognizer\"></a>点击手势——UITapGestureRecognizer</h3><p>点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置点击次数，默认为单击</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTapsRequired; </div><div class=\"line\"><span class=\"comment\">//设置同时点击的手指数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTouchesRequired;</div></pre></td></tr></table></figure></p>\n<h3 id=\"捏合手势——UIPinchGestureRecognizer\"><a href=\"#捏合手势——UIPinchGestureRecognizer\" class=\"headerlink\" title=\"捏合手势——UIPinchGestureRecognizer\"></a>捏合手势——UIPinchGestureRecognizer</h3><p>捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置缩放比例</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> scale; </div><div class=\"line\"><span class=\"comment\">//设置捏合速度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完缩放后，一定要把<code>recognizer.scale</code>设置为1<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handlePinch:(<span class=\"built_in\">UIPinchGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"缩放操作\"</span>);<span class=\"comment\">//处理缩放操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview缩放</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformScale</span>(_imageView.transform, recognizer.scale, recognizer.scale);</div><div class=\"line\">    recognizer.scale = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"拖拽手势——UIPanGestureRecognzer\"><a href=\"#拖拽手势——UIPanGestureRecognzer\" class=\"headerlink\" title=\"拖拽手势——UIPanGestureRecognzer\"></a>拖拽手势——UIPanGestureRecognzer</h3><p>当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最少触摸点，默认为1</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> minimumNumberOfTouches; </div><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最多触摸点</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> maximumNumberOfTouches;  </div><div class=\"line\"><span class=\"comment\">//获取当前位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)translationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;            </div><div class=\"line\"><span class=\"comment\">//设置当前位置</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setTranslation:(<span class=\"built_in\">CGPoint</span>)translation inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">//设置拖拽速度</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)velocityInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div></pre></td></tr></table></figure></p>\n<p>代码示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"拖动操作\"</span>);</div><div class=\"line\">    <span class=\"comment\">//处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右</span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> translation = [recognizer translationInView:_imageView];</div><div class=\"line\">    recognizer.view.center = <span class=\"built_in\">CGPointMake</span>(recognizer.view.center.x + translation.x,</div><div class=\"line\">                                         recognizer.view.center.y + translation.y);</div><div class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:_imageView];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>必须使用<code>setTranslation</code>设置为<code>CGPointZero</code>,不知道为什么</p>\n<h3 id=\"滑动手势——UISwipeGestureRecognizer\"><a href=\"#滑动手势——UISwipeGestureRecognizer\" class=\"headerlink\" title=\"滑动手势——UISwipeGestureRecognizer\"></a>滑动手势——UISwipeGestureRecognizer</h3><p>滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发滑动手势的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>                        numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置滑动方向</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UISwipeGestureRecognizerDirection</span> direction;  </div><div class=\"line\"><span class=\"comment\">//枚举如下</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionRight</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionLeft</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionUp</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionDown</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"旋转手势——UIRotationGestureRecognizer\"><a href=\"#旋转手势——UIRotationGestureRecognizer\" class=\"headerlink\" title=\"旋转手势——UIRotationGestureRecognizer\"></a>旋转手势——UIRotationGestureRecognizer</h3><p>进行旋转动作时触发手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置旋转角度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> rotation;</div><div class=\"line\"><span class=\"comment\">//设置旋转速度 </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完旋转后，<code>recognizer.rotation</code>一定要清零.<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handleRotate:(<span class=\"built_in\">UIRotationGestureRecognizer</span>*) recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"旋转操作\"</span>);<span class=\"comment\">//处理旋转操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview旋转</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformRotate</span>(_imageView.transform, recognizer.rotation);</div><div class=\"line\">    recognizer.rotation = <span class=\"number\">0</span>;    <span class=\"comment\">//一定要清零</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"长按手势——UILongPressGestureRecognizer\"><a href=\"#长按手势——UILongPressGestureRecognizer\" class=\"headerlink\" title=\"长按手势——UILongPressGestureRecognizer\"></a>长按手势——UILongPressGestureRecognizer</h3><p>进行长按的时候触发的手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发前的点击次数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTapsRequired;    </div><div class=\"line\"><span class=\"comment\">//设置触发的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置最短的长按时间</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CFTimeInterval</span> minimumPressDuration; </div><div class=\"line\"><span class=\"comment\">//设置在按触时时允许移动的最大距离 默认为10像素</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGFloat</span> allowableMovement;</div></pre></td></tr></table></figure></p>\n<h3 id=\"手势组合的问题\"><a href=\"#手势组合的问题\" class=\"headerlink\" title=\"手势组合的问题\"></a>手势组合的问题</h3><p>这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true\" alt=\"手势组合\"><br>当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。</p>\n<blockquote>\n<p>Demo 详见UIGestureRecognizer</p>\n</blockquote>\n","excerpt":"<p>在iOS系统中，手势是进行用户交互的重要方式，通过<code>UIGestureRecognizer</code>类，我们可以轻松的创建出各种手势应用于app中。关于<code>UIGestureRecognizer</code>类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。</p>","more":"<h2 id=\"手势的抽象类——UIGestureRecognizer\"><a href=\"#手势的抽象类——UIGestureRecognizer\" class=\"headerlink\" title=\"手势的抽象类——UIGestureRecognizer\"></a>手势的抽象类——UIGestureRecognizer</h2><p><code>UIGestureRecognizer</code>将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用<code>UIGestureRecognizer</code>的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，<code>UIGestureRecognizer</code>中抽象出了哪些方法。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p><code>UIGestureRecognizer</code>类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>如果我们使用<code>alloc-init</code>的方式，也是可以的，下面的方法可以为手势添加触发的<code>selector</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)addTarget:(<span class=\"keyword\">id</span>)target action:(SEL)action;</div></pre></td></tr></table></figure></p>\n<p>与之相对应的，我们也可以将一个<code>selector</code>从其手势对象上移除：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)removeTarget:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)target action:(<span class=\"keyword\">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>\n<p>这里的<code>target</code>一般都是<code>self</code>,因为<code>selector</code>一般都是在<code>self</code>中定义。</p>\n<p>因为<code>addTarget</code>方式的存在，iOS系统允许一个手势对象可以添加多个<code>selector</code>触发方法，并且触发的时候，所有添加的<code>selector</code>都会被执行，我们以点击手势示例如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];</div><div class=\"line\">    [ges addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(haha)];</div><div class=\"line\">     [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)haha&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"haha\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>点击屏幕后，两个方法都会触发。</p>\n<h3 id=\"手势状态\"><a href=\"#手势状态\" class=\"headerlink\" title=\"手势状态\"></a>手势状态</h3><p>UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIGestureRecognizerState</span> state;</div></pre></td></tr></table></figure></p>\n<p>枚举值如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">UIGestureRecognizerState</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStatePossible</span>,   <span class=\"comment\">// 默认的状态，这个时候的手势并没有具体的情形状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateBegan</span>,      <span class=\"comment\">// 手势开始被识别的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateChanged</span>,    <span class=\"comment\">// 手势识别发生改变的状态</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateEnded</span>,      <span class=\"comment\">// 手势识别结束，将会执行触发的方法</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateCancelled</span>,  <span class=\"comment\">// 手势识别取消</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateFailed</span>,     <span class=\"comment\">// 识别失败，方法将不会被调用</span></div><div class=\"line\">    <span class=\"built_in\">UIGestureRecognizerStateRecognized</span> = <span class=\"built_in\">UIGestureRecognizerStateEnded</span> </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。</p>\n<h3 id=\"常用属性和方法\"><a href=\"#常用属性和方法\" class=\"headerlink\" title=\"常用属性和方法\"></a>常用属性和方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置代理，具体的协议后面会说</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>,<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class=\"line\"><span class=\"comment\">//设置手势是否有效</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">getter</span>=isEnabled) <span class=\"built_in\">BOOL</span> enabled;</div><div class=\"line\"><span class=\"comment\">//获取手势所在的view</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIView</span> *view; </div><div class=\"line\"><span class=\"comment\">//获取触发触摸的点</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view; </div><div class=\"line\"><span class=\"comment\">//设置触摸点数</span></div><div class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)numberOfTouches; </div><div class=\"line\"><span class=\"comment\">//获取某一个触摸点的触摸位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)locationOfTouch:(<span class=\"built_in\">NSUInteger</span>)touchIndex inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span>*)view;</div></pre></td></tr></table></figure>\n<p>其中，<code>UITouch</code>也有一个方法是<code>locationInView:</code>可以获取触摸点在view中的位置。<br>可以通过设置<code>numberOfTapsRequired</code>来区分单击双击：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITapGestureRecognizer</span> *doubleTap = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(DoubleTap:)];</div><div class=\"line\">doubleTap.numberOfTapsRequired = <span class=\"number\">2</span>; <span class=\"comment\">//点击的次数 ＝2 双击</span></div><div class=\"line\">[_imageView addGestureRecognizer:doubleTap];<span class=\"comment\">//给对象添加一个手势监测；</span></div></pre></td></tr></table></figure></p>\n<p>另外还有三个属性用来控制触摸事件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> cancelsTouchesInView;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesBegan;</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> delaysTouchesEnded;</div></pre></td></tr></table></figure></p>\n<p><strong>cancelsTouchesInView</strong><br>默认为YES,这种情况下当手势识别器识别到touch之后，会发送<code>touchesCancelled:withEvent:</code>消息,终止触摸事件的传递,以取消 <code>UIResponder</code>对touch的响应，这个时候只有手势识别器响应touch。<br>当设置成NO时，手势识别器识别到touch之后不会发送<code>touchesCancelled:withEvent:</code>消息，这个时候手势识别器和<code>UIResponder</code>均响应touch。<br><strong>注意：</strong>发送<code>touchesCancelled:withEvent:</code>消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后<code>touchesCancelled:withEvent:</code>消息才会生效，屏蔽touch操作。</p>\n<p><strong>delaysTouchesBegan</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给<code>UIResponder</code>，两者各自做出响应。<br>如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给<code>UIResponder</code>，即<code>UIResponder</code>不会有任何触摸事件。只有在识别失败之后才会将touch发给<code>UIResponder</code>，这种情况下<code>UIResponder</code>的响应会延迟约0.15ms。</p>\n<p><strong>delaysTouchesEnded</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给<code>touchesCancelled:withEvent:</code>消息给<code>UIResponder</code>，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送<code>touchesEnded:withEvent:</code>。<br>如果设置为NO，则不会延迟，即会立即发送<code>touchesEnded:withEvent:</code>以结束当前触摸。</p>\n<h3 id=\"手势间的互斥\"><a href=\"#手势间的互斥\" class=\"headerlink\" title=\"手势间的互斥\"></a>手势间的互斥</h3><p>有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"comment\">// Do any additional setup after loading the view, typically from a nib.</span></div><div class=\"line\">     <span class=\"built_in\">UITapGestureRecognizer</span> * ges = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click:)];;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//view.backgroundColor = [UIColor redColor];</span></div><div class=\"line\">   </div><div class=\"line\">    <span class=\"comment\">//ges.delegate=self;</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">UITapGestureRecognizer</span> * ges2 = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc]initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(click1:)];</div><div class=\"line\"><span class=\"comment\">//    ges2.delegate=self;</span></div><div class=\"line\">        [<span class=\"keyword\">self</span>.view addGestureRecognizer:ges2];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)click:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第一个手势的触发方法\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"keyword\">void</span>)click1:(<span class=\"built_in\">UIGestureRecognizer</span> *)ges1&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第二个手势的触发方法\"</span>);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ges requireGestureRecognizerToFail:ges2];</div></pre></td></tr></table></figure></p>\n<p>表示如果<code>ges2</code>匹配，那么不会执行<code>ges</code>。只有当<code>ges2</code>不匹配的时候，才会执行<code>ges</code>。</p>\n<h3 id=\"UIGestureRecognizerDelegate\"><a href=\"#UIGestureRecognizerDelegate\" class=\"headerlink\" title=\"UIGestureRecognizerDelegate\"></a>UIGestureRecognizerDelegate</h3><p>前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class=\"built_in\">UITouch</span> *)touch;</div><div class=\"line\"><span class=\"comment\">//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizerShouldBegin:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class=\"line\"><span class=\"comment\">//下面这个两个方法也是用来控制手势的互斥执行的</span></div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div><div class=\"line\"><span class=\"comment\">//这个方法返回YES，第一个和第二个互斥时，第二个会失效</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)gestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class=\"built_in\">UIGestureRecognizer</span> *)otherGestureRecognizer <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">7</span>_0);</div></pre></td></tr></table></figure></p>\n<p>最下面两个方法用起来还挺麻烦的，因为你不知道哪个是<code>gestureRecognizer</code>哪个是<code>otherGestureRecognizer</code>,因此，只能笼统的设置。</p>\n<h3 id=\"手势和触摸的区别\"><a href=\"#手势和触摸的区别\" class=\"headerlink\" title=\"手势和触摸的区别\"></a>手势和触摸的区别</h3><p>前一篇我们学习了<code>UITouch</code>,可以通过重写<code>UIResponder</code>的几个<code>touch</code>方法来处理触摸事件。<br><code>UIGestureRecognizer</code>和触摸事件是两个独立的事,手势和<code>UITouch</code>本身关系不大。不过手势可以通过<code>cancelsTouchesInView</code>,<code>delaysTouchesBegan</code>,<code>delaysTouchesEnded</code>这三个属性来影响触摸事件。</p>\n<h2 id=\"UIGestureRecognizer的子类\"><a href=\"#UIGestureRecognizer的子类\" class=\"headerlink\" title=\"UIGestureRecognizer的子类\"></a>UIGestureRecognizer的子类</h2><h3 id=\"点击手势——UITapGestureRecognizer\"><a href=\"#点击手势——UITapGestureRecognizer\" class=\"headerlink\" title=\"点击手势——UITapGestureRecognizer\"></a>点击手势——UITapGestureRecognizer</h3><p>点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置点击次数，默认为单击</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTapsRequired; </div><div class=\"line\"><span class=\"comment\">//设置同时点击的手指数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>  numberOfTouchesRequired;</div></pre></td></tr></table></figure></p>\n<h3 id=\"捏合手势——UIPinchGestureRecognizer\"><a href=\"#捏合手势——UIPinchGestureRecognizer\" class=\"headerlink\" title=\"捏合手势——UIPinchGestureRecognizer\"></a>捏合手势——UIPinchGestureRecognizer</h3><p>捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置缩放比例</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> scale; </div><div class=\"line\"><span class=\"comment\">//设置捏合速度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完缩放后，一定要把<code>recognizer.scale</code>设置为1<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handlePinch:(<span class=\"built_in\">UIPinchGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"缩放操作\"</span>);<span class=\"comment\">//处理缩放操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview缩放</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformScale</span>(_imageView.transform, recognizer.scale, recognizer.scale);</div><div class=\"line\">    recognizer.scale = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"拖拽手势——UIPanGestureRecognzer\"><a href=\"#拖拽手势——UIPanGestureRecognzer\" class=\"headerlink\" title=\"拖拽手势——UIPanGestureRecognzer\"></a>拖拽手势——UIPanGestureRecognzer</h3><p>当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最少触摸点，默认为1</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> minimumNumberOfTouches; </div><div class=\"line\"><span class=\"comment\">//设置触发拖拽的最多触摸点</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">NSUInteger</span> maximumNumberOfTouches;  </div><div class=\"line\"><span class=\"comment\">//获取当前位置</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)translationInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;            </div><div class=\"line\"><span class=\"comment\">//设置当前位置</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setTranslation:(<span class=\"built_in\">CGPoint</span>)translation inView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">//设置拖拽速度</span></div><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)velocityInView:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIView</span> *)view;</div></pre></td></tr></table></figure></p>\n<p>代码示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)handlePan:(<span class=\"built_in\">UIPanGestureRecognizer</span>*)recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"拖动操作\"</span>);</div><div class=\"line\">    <span class=\"comment\">//处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右</span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> translation = [recognizer translationInView:_imageView];</div><div class=\"line\">    recognizer.view.center = <span class=\"built_in\">CGPointMake</span>(recognizer.view.center.x + translation.x,</div><div class=\"line\">                                         recognizer.view.center.y + translation.y);</div><div class=\"line\">    [recognizer setTranslation:<span class=\"built_in\">CGPointZero</span> inView:_imageView];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>必须使用<code>setTranslation</code>设置为<code>CGPointZero</code>,不知道为什么</p>\n<h3 id=\"滑动手势——UISwipeGestureRecognizer\"><a href=\"#滑动手势——UISwipeGestureRecognizer\" class=\"headerlink\" title=\"滑动手势——UISwipeGestureRecognizer\"></a>滑动手势——UISwipeGestureRecognizer</h3><p>滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发滑动手势的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span>                        numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置滑动方向</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UISwipeGestureRecognizerDirection</span> direction;  </div><div class=\"line\"><span class=\"comment\">//枚举如下</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, <span class=\"built_in\">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionRight</span> = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionLeft</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionUp</span>    = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"built_in\">UISwipeGestureRecognizerDirectionDown</span>  = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"旋转手势——UIRotationGestureRecognizer\"><a href=\"#旋转手势——UIRotationGestureRecognizer\" class=\"headerlink\" title=\"旋转手势——UIRotationGestureRecognizer\"></a>旋转手势——UIRotationGestureRecognizer</h3><p>进行旋转动作时触发手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置旋转角度</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>)          <span class=\"built_in\">CGFloat</span> rotation;</div><div class=\"line\"><span class=\"comment\">//设置旋转速度 </span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>\n<p>在设置完旋转后，<code>recognizer.rotation</code>一定要清零.<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)handleRotate:(<span class=\"built_in\">UIRotationGestureRecognizer</span>*) recognizer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"旋转操作\"</span>);<span class=\"comment\">//处理旋转操作</span></div><div class=\"line\">    <span class=\"comment\">//对imageview旋转</span></div><div class=\"line\">    _imageView.transform = <span class=\"built_in\">CGAffineTransformRotate</span>(_imageView.transform, recognizer.rotation);</div><div class=\"line\">    recognizer.rotation = <span class=\"number\">0</span>;    <span class=\"comment\">//一定要清零</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"长按手势——UILongPressGestureRecognizer\"><a href=\"#长按手势——UILongPressGestureRecognizer\" class=\"headerlink\" title=\"长按手势——UILongPressGestureRecognizer\"></a>长按手势——UILongPressGestureRecognizer</h3><p>进行长按的时候触发的手势方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//设置触发前的点击次数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTapsRequired;    </div><div class=\"line\"><span class=\"comment\">//设置触发的触摸点数</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSUInteger</span> numberOfTouchesRequired; </div><div class=\"line\"><span class=\"comment\">//设置最短的长按时间</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CFTimeInterval</span> minimumPressDuration; </div><div class=\"line\"><span class=\"comment\">//设置在按触时时允许移动的最大距离 默认为10像素</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">CGFloat</span> allowableMovement;</div></pre></td></tr></table></figure></p>\n<h3 id=\"手势组合的问题\"><a href=\"#手势组合的问题\" class=\"headerlink\" title=\"手势组合的问题\"></a>手势组合的问题</h3><p>这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true\" alt=\"手势组合\"><br>当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。</p>\n<blockquote>\n<p>Demo 详见UIGestureRecognizer</p>\n</blockquote>"},{"title":"UITableView 基础","date":"2016-08-30T06:07:12.000Z","_content":"\nUITableView是最常用的基本控件。此处对其一般用法进行总结。\n\n<!--more-->\n\n\n## UITableView基础\n### UITableView 的样式\n1. UITableViewStylePlain\t\t将会保持在顶部直到被顶掉\n2. UITableViewStyleGrouped\t\t将会随着cell一起滚动\n\n```objc\nUITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyle];\n```\n\n其中`CGRectZero`表示`equivalent to CGRectMake(0, 0, 0, 0)`.之后代码会改UITableView的Frame，所以暂且都是0。\n\n### UITableView对象提供数据\nUITableView不包含任何数据，需要提供一个数据源.  \n我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。  \n在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议\n```objc\n@interface BNRAppDelegate: UIResponder <UIApplicationDelegate,UITableViewDataSource>\n@property (nonatomic) UITableView *taskTable;\n@property (nonatomic) NSMutable Array *tasks;\n@end\n```\n\n在.m中向UITableView发送`setDataSource`消息，将BNRAPPDelegate实例设置为数据源\n\n```objc\nself.taskTable.dataSource = self;\n```\n\nUITableViewDataSource设置了两个必须方法：\n\n1. 根据指定的表格索引给出相应表格段包含的行数（`tableView：numberOfRowsInSection：`）\n2. 根据指定表格段索引和行索引给出相应的UITableViewCell对象（`tableView：cellForRowAtIndexPath：`）\n```objc\n@implementation BNRAppDelegate\n-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{\n\t    return [self.tasks count];\n}\n-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n        UITableViewCell *c = [self.taskTable dequeueReusableCellWithIdentifier:@“cell”];\n\t    //重用cell\n\t    NSString *item = [self.tasks objectAtIndex:indexPath.row];\n\t    c.textLabel.text = item;\n\t    return c;\n}\n```\n\n刷新表格：`[self.taskTable reloadData];`\n\n### 重用UITableViewCell对象\n需要将自定义的cell类和identifier进行关联。  \n在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell\n```objc\n-(void)viewDidLoad{\n\t[super viewDidLoad];\n\t[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@“UITableViewCell”];\n}\n```\n\n这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联\n```objc\n[self.tableView registerNib:[UINib nibWithNibName:@\"MineUserInfoCell\" bundle:nil]  forCellReuseIdentifier:@\"MineUserInfoCellIdentifier\"];\n```\n\n### 使用UIViewController创建tabeView\n需要自己创建tableview属性：\n```objc\n@property (nonatomic, strong) UITableView *tableView;\n```\n这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。\n如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。\n\n### 创建多个section的tableview\n创建多个section的tableview需要实现方法`numberOfSectionsInTableView:`返回tableview中section的个数。其余使用和单个section一样。\n\n在`cellForRowAtIndexPath:`方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数`(NSIndexPath *)indexPath`。\n\n`NSIndexPath`是一个结构体，具有两个属性`row`和`section`。表示所在section和section内row。\n`NSIndexPath`中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。\n创建方式:\n```objc\nNSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:1];\n```\n\n### TableView表头视图\n表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。\n```objc\nUIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@\"HotelReviewsHeaderView\" owner:nil options:nil]lastObject];\n```\n\n**loadNibNamed:owner:options:**返回的是个数组，保存了xib中的各个view。`initWithNibName`的实现和该方法类似，其中也会用到该方法。不过`initWithNibName`用在获取Controller的xib中。\n`initWithNibName`是延迟加载，view上的控件是 nil 的,只有到 需要显示时，才会不是 nil. `loadNibNamed:`是即时加载。\n`initWithNibName`的class是所属Controller，`loadNibNamed:`的class是NSObject。\n\n```objc\n- (void)viewDidLoad{\n\tUIView *header = self.headerView;\n\t[self.tableView setTableHeaderView:header];\n}\n```\n加载完headerView后，将其设置为UITableView对象的表头视图。\n也可以在 **(UIView \\*)tableView:viewForHeaderInSection:**方法中设置，当只有一个section时效果相同。\n```objc\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{\n    UIView *view = [[[NSBundle mainBundle] loadNibNamed:@\"HeaderView\" owner:nil options:nil] lastObject];\n    return view;\n}\n```\n\n### tableview的字母索引\n实现`sectionIndexTitlesForTableView`方法，返回一个字符串数组：\n```objc\n- (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView{\n    NSMutableArray *indexs = [[NSMutableArray alloc]init];\n    [indexs addObject:@\"我\"];\n    [indexs addObject:@\"是\"];\n    return indexs;\n}\n```\n这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。\n\n### 点击cell中button获取所属indexpath\nbutton点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。\n```objc\n[cell.btn addTarget:self action:@selector(cellBtnClicked:event:) forControlEvents:UIControlEventTouchUpInside];\n\n- (void)cellBtnClicked:(id)sender event:(id)event\n{\n    NSSet *touches =[event allTouches];\n    UITouch *touch =[touches anyObject];\n    CGPoint currentTouchPosition = [touch locationInView:_tableView];\n    NSIndexPath *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];\n    if (indexPath!= nil)\n    {\n        // do something\n    }\n}\n```\n\n可以通过`event`拿到在tableView中的位置`cure`，再通过`indexPathForRowAtPoint:`方法获取`NSIndexPath`。\n\n另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：\n```objc\n//cell.h中的声明\n- (IBAction)buttonPressed :(id)；\n\n//cell.m中的实现，设置代理\n- (void)buttonPressed:(id)sender{\n    [self.delegate buttonPressed:self event:event];\n}\n\n//viewcontroller中的实现\n- (void)buttonPressed:(TableViewCell1 *)cell{\n    NSIndexPath *indexPath2 = [_tableView indexPathForCell:cell];\n    NSLog(@\"所属行数：%ld\",(long)indexPath2.row+1);\n}\n```\n\n通过设置delegate，将button的点击事件交给viewController完成。\n\n## 编辑UITableView\n### 编辑模式下的UITableView\n#### 进入编辑模式\n通过调用`[_tableView setEditing:!_tableView.isEditing animated:true]`进入编辑模式,可实现添加，删除，移动操作。\n默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。\n\n#### TableView 编辑行\n使用**setEditing:animated:**方法让tableView进入编辑模式.可以使用**tableView:canEditRowAtIndexPath**方法筛选能进入编辑模式的行：\n```objc\n- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {\n    if(indexPath.row == (10 | 12 | 14)){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n如果不实现该方法，默认为YES。\n\n#### 编辑模式\n通过设置`UITableViewCellEditingStyle`可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的`commitEditingStyle:forRowAtIndexPath:`方法的入参传入。\n```objc\n-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{\n    if (condition) {\n        return UITableViewCellEditingStyleInsert;\n    }else{\n   \t\treturn UITableViewCellEditingStyleDelete;\n\t}\n}\n```\n\n#### 编辑模式下的插入和删除行\n实现`tableView:commitEditingStyle:forRowAtIndexPath:`方法。传入三个参数。  \n第一个实参是发送该消息的UITableView对象。  \n第二个实参是`UITableViewCellEditingStyle`类型的常数(删除表格行时，传入的是`UITableViewCellEditingStyleDelete`;插入表格行时，传入的是`UITableViewCellEditingStyleInsert`)。  \n第三个实参是一个NSIndexPath对象。\n```objc\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n    if (editingStyle == UITableViewCellEditingStyleDelete) {\n        [self.dataSource removeObjectAtIndex:indexPath.row];\n        [self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];\n    }else if (editingStyle == UITableViewCellEditingStyleInsert){\n    \t[self.dataSource insertObject:@\"我是新来的\" atIndex:indexPath.row];\n        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom];\n    }\n}\n```\n使用`deleteRowsAtIndexPaths`和`insertRowsAtIndexPaths`可以进行局部刷新，节省资源，并且还能添加指定动画。\ndelete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。\n\n#### cell的移动\n进入编辑模式后\n实现`tableView:moveRowAtIndexPath:`方法\n```objc\n- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{\n    if(sourceIndexPath == destinationIndexPath){\n        return ;\n    }else{\n        Comment *comment = [self.dataSource objectAtIndex:sourceIndexPath.row];\n        [self.dataSource removeObjectAtIndex:sourceIndexPath.row];\n        [self.dataSource insertObject:comment atIndex:destinationIndexPath.row];\n    }\n}\n```\n一定要对数据源进行正确操作。\n\n#### TableView 修改删除按钮\n```objc\n- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return @\"删除\";\n}\n```\n\n### 不在编辑模式下的编辑方式\n#### 刷新方式\n简单总结一些UITableView的刷新方法：\n- reloadData\t\t\t\t\t\t\t\t\t刷新整个表格\n- reloadRowsAtIndexPaths:withRowAnimation:\t\t刷新indexPath指向的cell\n- reloadSections:withRowAnimation:\t\t\t\t刷新NSIndexSet内包含的Section\n\n这三个分别刷新tableview的各个部分\n第一个没有动画效果。\n第二个可以传入一个数组\n```objc\n[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];\n```\n第三个可以传入一个NSIndexSet集合\n```objc\n[self.tableView reloadSections:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)] withRowAnimation:UITableViewRowAnimationFade];\n[_tableView reloadSections:[NSIndexSet indexSetWithIndex:indexPath.section]withRowAnimation:UITableViewRowAnimationLeft];\n```\n\n#### 插入删除\n在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。\n- deleteRowsAtIndexPaths:withRowAnimation:\n- insertRowsAtIndexPaths:withRowAnimation:\n\n就不举例了。同上面一样。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/UITableView基础.md","raw":"title: UITableView 基础\ndate: 2016/8/30 14:07:12  \ncategories: IOS \ntags: \n\t- 基本控件\n\n\t\n---\n\nUITableView是最常用的基本控件。此处对其一般用法进行总结。\n\n<!--more-->\n\n\n## UITableView基础\n### UITableView 的样式\n1. UITableViewStylePlain\t\t将会保持在顶部直到被顶掉\n2. UITableViewStyleGrouped\t\t将会随着cell一起滚动\n\n```objc\nUITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyle];\n```\n\n其中`CGRectZero`表示`equivalent to CGRectMake(0, 0, 0, 0)`.之后代码会改UITableView的Frame，所以暂且都是0。\n\n### UITableView对象提供数据\nUITableView不包含任何数据，需要提供一个数据源.  \n我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。  \n在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议\n```objc\n@interface BNRAppDelegate: UIResponder <UIApplicationDelegate,UITableViewDataSource>\n@property (nonatomic) UITableView *taskTable;\n@property (nonatomic) NSMutable Array *tasks;\n@end\n```\n\n在.m中向UITableView发送`setDataSource`消息，将BNRAPPDelegate实例设置为数据源\n\n```objc\nself.taskTable.dataSource = self;\n```\n\nUITableViewDataSource设置了两个必须方法：\n\n1. 根据指定的表格索引给出相应表格段包含的行数（`tableView：numberOfRowsInSection：`）\n2. 根据指定表格段索引和行索引给出相应的UITableViewCell对象（`tableView：cellForRowAtIndexPath：`）\n```objc\n@implementation BNRAppDelegate\n-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{\n\t    return [self.tasks count];\n}\n-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n        UITableViewCell *c = [self.taskTable dequeueReusableCellWithIdentifier:@“cell”];\n\t    //重用cell\n\t    NSString *item = [self.tasks objectAtIndex:indexPath.row];\n\t    c.textLabel.text = item;\n\t    return c;\n}\n```\n\n刷新表格：`[self.taskTable reloadData];`\n\n### 重用UITableViewCell对象\n需要将自定义的cell类和identifier进行关联。  \n在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell\n```objc\n-(void)viewDidLoad{\n\t[super viewDidLoad];\n\t[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@“UITableViewCell”];\n}\n```\n\n这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联\n```objc\n[self.tableView registerNib:[UINib nibWithNibName:@\"MineUserInfoCell\" bundle:nil]  forCellReuseIdentifier:@\"MineUserInfoCellIdentifier\"];\n```\n\n### 使用UIViewController创建tabeView\n需要自己创建tableview属性：\n```objc\n@property (nonatomic, strong) UITableView *tableView;\n```\n这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。\n如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。\n\n### 创建多个section的tableview\n创建多个section的tableview需要实现方法`numberOfSectionsInTableView:`返回tableview中section的个数。其余使用和单个section一样。\n\n在`cellForRowAtIndexPath:`方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数`(NSIndexPath *)indexPath`。\n\n`NSIndexPath`是一个结构体，具有两个属性`row`和`section`。表示所在section和section内row。\n`NSIndexPath`中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。\n创建方式:\n```objc\nNSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:1];\n```\n\n### TableView表头视图\n表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。\n```objc\nUIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@\"HotelReviewsHeaderView\" owner:nil options:nil]lastObject];\n```\n\n**loadNibNamed:owner:options:**返回的是个数组，保存了xib中的各个view。`initWithNibName`的实现和该方法类似，其中也会用到该方法。不过`initWithNibName`用在获取Controller的xib中。\n`initWithNibName`是延迟加载，view上的控件是 nil 的,只有到 需要显示时，才会不是 nil. `loadNibNamed:`是即时加载。\n`initWithNibName`的class是所属Controller，`loadNibNamed:`的class是NSObject。\n\n```objc\n- (void)viewDidLoad{\n\tUIView *header = self.headerView;\n\t[self.tableView setTableHeaderView:header];\n}\n```\n加载完headerView后，将其设置为UITableView对象的表头视图。\n也可以在 **(UIView \\*)tableView:viewForHeaderInSection:**方法中设置，当只有一个section时效果相同。\n```objc\n- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{\n    UIView *view = [[[NSBundle mainBundle] loadNibNamed:@\"HeaderView\" owner:nil options:nil] lastObject];\n    return view;\n}\n```\n\n### tableview的字母索引\n实现`sectionIndexTitlesForTableView`方法，返回一个字符串数组：\n```objc\n- (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView{\n    NSMutableArray *indexs = [[NSMutableArray alloc]init];\n    [indexs addObject:@\"我\"];\n    [indexs addObject:@\"是\"];\n    return indexs;\n}\n```\n这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。\n\n### 点击cell中button获取所属indexpath\nbutton点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。\n```objc\n[cell.btn addTarget:self action:@selector(cellBtnClicked:event:) forControlEvents:UIControlEventTouchUpInside];\n\n- (void)cellBtnClicked:(id)sender event:(id)event\n{\n    NSSet *touches =[event allTouches];\n    UITouch *touch =[touches anyObject];\n    CGPoint currentTouchPosition = [touch locationInView:_tableView];\n    NSIndexPath *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];\n    if (indexPath!= nil)\n    {\n        // do something\n    }\n}\n```\n\n可以通过`event`拿到在tableView中的位置`cure`，再通过`indexPathForRowAtPoint:`方法获取`NSIndexPath`。\n\n另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：\n```objc\n//cell.h中的声明\n- (IBAction)buttonPressed :(id)；\n\n//cell.m中的实现，设置代理\n- (void)buttonPressed:(id)sender{\n    [self.delegate buttonPressed:self event:event];\n}\n\n//viewcontroller中的实现\n- (void)buttonPressed:(TableViewCell1 *)cell{\n    NSIndexPath *indexPath2 = [_tableView indexPathForCell:cell];\n    NSLog(@\"所属行数：%ld\",(long)indexPath2.row+1);\n}\n```\n\n通过设置delegate，将button的点击事件交给viewController完成。\n\n## 编辑UITableView\n### 编辑模式下的UITableView\n#### 进入编辑模式\n通过调用`[_tableView setEditing:!_tableView.isEditing animated:true]`进入编辑模式,可实现添加，删除，移动操作。\n默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。\n\n#### TableView 编辑行\n使用**setEditing:animated:**方法让tableView进入编辑模式.可以使用**tableView:canEditRowAtIndexPath**方法筛选能进入编辑模式的行：\n```objc\n- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {\n    if(indexPath.row == (10 | 12 | 14)){\n        return NO;\n    }else{\n        return YES;\n    }\n}\n```\n如果不实现该方法，默认为YES。\n\n#### 编辑模式\n通过设置`UITableViewCellEditingStyle`可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的`commitEditingStyle:forRowAtIndexPath:`方法的入参传入。\n```objc\n-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath{\n    if (condition) {\n        return UITableViewCellEditingStyleInsert;\n    }else{\n   \t\treturn UITableViewCellEditingStyleDelete;\n\t}\n}\n```\n\n#### 编辑模式下的插入和删除行\n实现`tableView:commitEditingStyle:forRowAtIndexPath:`方法。传入三个参数。  \n第一个实参是发送该消息的UITableView对象。  \n第二个实参是`UITableViewCellEditingStyle`类型的常数(删除表格行时，传入的是`UITableViewCellEditingStyleDelete`;插入表格行时，传入的是`UITableViewCellEditingStyleInsert`)。  \n第三个实参是一个NSIndexPath对象。\n```objc\n- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {\n    if (editingStyle == UITableViewCellEditingStyleDelete) {\n        [self.dataSource removeObjectAtIndex:indexPath.row];\n        [self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];\n    }else if (editingStyle == UITableViewCellEditingStyleInsert){\n    \t[self.dataSource insertObject:@\"我是新来的\" atIndex:indexPath.row];\n        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom];\n    }\n}\n```\n使用`deleteRowsAtIndexPaths`和`insertRowsAtIndexPaths`可以进行局部刷新，节省资源，并且还能添加指定动画。\ndelete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。\n\n#### cell的移动\n进入编辑模式后\n实现`tableView:moveRowAtIndexPath:`方法\n```objc\n- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{\n    if(sourceIndexPath == destinationIndexPath){\n        return ;\n    }else{\n        Comment *comment = [self.dataSource objectAtIndex:sourceIndexPath.row];\n        [self.dataSource removeObjectAtIndex:sourceIndexPath.row];\n        [self.dataSource insertObject:comment atIndex:destinationIndexPath.row];\n    }\n}\n```\n一定要对数据源进行正确操作。\n\n#### TableView 修改删除按钮\n```objc\n- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return @\"删除\";\n}\n```\n\n### 不在编辑模式下的编辑方式\n#### 刷新方式\n简单总结一些UITableView的刷新方法：\n- reloadData\t\t\t\t\t\t\t\t\t刷新整个表格\n- reloadRowsAtIndexPaths:withRowAnimation:\t\t刷新indexPath指向的cell\n- reloadSections:withRowAnimation:\t\t\t\t刷新NSIndexSet内包含的Section\n\n这三个分别刷新tableview的各个部分\n第一个没有动画效果。\n第二个可以传入一个数组\n```objc\n[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop];\n```\n第三个可以传入一个NSIndexSet集合\n```objc\n[self.tableView reloadSections:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)] withRowAnimation:UITableViewRowAnimationFade];\n[_tableView reloadSections:[NSIndexSet indexSetWithIndex:indexPath.section]withRowAnimation:UITableViewRowAnimationLeft];\n```\n\n#### 插入删除\n在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。\n- deleteRowsAtIndexPaths:withRowAnimation:\n- insertRowsAtIndexPaths:withRowAnimation:\n\n就不举例了。同上面一样。\n\n\n\n\n\n\n\n\n\n\n","slug":"UITableView基础","published":1,"updated":"2016-09-23T05:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzwq001jrgru1lh6jr6u","content":"<p>UITableView是最常用的基本控件。此处对其一般用法进行总结。</p>\n<a id=\"more\"></a>\n<h2 id=\"UITableView基础\"><a href=\"#UITableView基础\" class=\"headerlink\" title=\"UITableView基础\"></a>UITableView基础</h2><h3 id=\"UITableView-的样式\"><a href=\"#UITableView-的样式\" class=\"headerlink\" title=\"UITableView 的样式\"></a>UITableView 的样式</h3><ol>\n<li>UITableViewStylePlain        将会保持在顶部直到被顶掉</li>\n<li>UITableViewStyleGrouped        将会随着cell一起滚动</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITableView</span> *tableView = [[<span class=\"built_in\">UITableView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectZero</span> style:<span class=\"built_in\">UITableViewStyle</span>];</div></pre></td></tr></table></figure>\n<p>其中<code>CGRectZero</code>表示<code>equivalent to CGRectMake(0, 0, 0, 0)</code>.之后代码会改UITableView的Frame，所以暂且都是0。</p>\n<h3 id=\"UITableView对象提供数据\"><a href=\"#UITableView对象提供数据\" class=\"headerlink\" title=\"UITableView对象提供数据\"></a>UITableView对象提供数据</h3><p>UITableView不包含任何数据，需要提供一个数据源.<br>我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。<br>在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRAppDelegate</span>: <span class=\"title\">UIResponder</span> &lt;<span class=\"title\">UIApplicationDelegate</span>,<span class=\"title\">UITableViewDataSource</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UITableView</span> *taskTable;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSMutable</span> Array *tasks;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中向UITableView发送<code>setDataSource</code>消息，将BNRAPPDelegate实例设置为数据源</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.taskTable.dataSource = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>UITableViewDataSource设置了两个必须方法：</p>\n<ol>\n<li>根据指定的表格索引给出相应表格段包含的行数（<code>tableView：numberOfRowsInSection：</code>）</li>\n<li>根据指定表格段索引和行索引给出相应的UITableViewCell对象（<code>tableView：cellForRowAtIndexPath：</code>）<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BNRAppDelegate</span></span></div><div class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.tasks count];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">        <span class=\"built_in\">UITableViewCell</span> *c = [<span class=\"keyword\">self</span>.taskTable dequeueReusableCellWithIdentifier:@“cell”];</div><div class=\"line\">\t    <span class=\"comment\">//重用cell</span></div><div class=\"line\">\t    <span class=\"built_in\">NSString</span> *item = [<span class=\"keyword\">self</span>.tasks objectAtIndex:indexPath.row];</div><div class=\"line\">\t    c.textLabel.text = item;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> c;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>刷新表格：<code>[self.taskTable reloadData];</code></p>\n<h3 id=\"重用UITableViewCell对象\"><a href=\"#重用UITableViewCell对象\" class=\"headerlink\" title=\"重用UITableViewCell对象\"></a>重用UITableViewCell对象</h3><p>需要将自定义的cell类和identifier进行关联。<br>在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView registerClass:[<span class=\"built_in\">UITableViewCell</span> <span class=\"keyword\">class</span>] forCellReuseIdentifier:@“<span class=\"built_in\">UITableViewCell</span>”];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView registerNib:[<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"MineUserInfoCell\"</span> bundle:<span class=\"literal\">nil</span>]  forCellReuseIdentifier:<span class=\"string\">@\"MineUserInfoCellIdentifier\"</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用UIViewController创建tabeView\"><a href=\"#使用UIViewController创建tabeView\" class=\"headerlink\" title=\"使用UIViewController创建tabeView\"></a>使用UIViewController创建tabeView</h3><p>需要自己创建tableview属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITableView</span> *tableView;</div></pre></td></tr></table></figure></p>\n<p>这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。<br>如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。</p>\n<h3 id=\"创建多个section的tableview\"><a href=\"#创建多个section的tableview\" class=\"headerlink\" title=\"创建多个section的tableview\"></a>创建多个section的tableview</h3><p>创建多个section的tableview需要实现方法<code>numberOfSectionsInTableView:</code>返回tableview中section的个数。其余使用和单个section一样。</p>\n<p>在<code>cellForRowAtIndexPath:</code>方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数<code>(NSIndexPath *)indexPath</code>。</p>\n<p><code>NSIndexPath</code>是一个结构体，具有两个属性<code>row</code>和<code>section</code>。表示所在section和section内row。<br><code>NSIndexPath</code>中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。<br>创建方式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:<span class=\"number\">1</span> inSection:<span class=\"number\">1</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"TableView表头视图\"><a href=\"#TableView表头视图\" class=\"headerlink\" title=\"TableView表头视图\"></a>TableView表头视图</h3><p>表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *headerView = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HotelReviewsHeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>]lastObject];</div></pre></td></tr></table></figure></p>\n<p><strong>loadNibNamed:owner:options:</strong>返回的是个数组，保存了xib中的各个view。<code>initWithNibName</code>的实现和该方法类似，其中也会用到该方法。不过<code>initWithNibName</code>用在获取Controller的xib中。<br><code>initWithNibName</code>是延迟加载，view上的控件是 nil 的,只有到 需要显示时，才会不是 nil. <code>loadNibNamed:</code>是即时加载。<br><code>initWithNibName</code>的class是所属Controller，<code>loadNibNamed:</code>的class是NSObject。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t<span class=\"built_in\">UIView</span> *header = <span class=\"keyword\">self</span>.headerView;</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView setTableHeaderView:header];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载完headerView后，将其设置为UITableView对象的表头视图。<br>也可以在 <strong>(UIView *)tableView:viewForHeaderInSection:</strong>方法中设置，当只有一个section时效果相同。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView viewForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>] lastObject];</div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"tableview的字母索引\"><a href=\"#tableview的字母索引\" class=\"headerlink\" title=\"tableview的字母索引\"></a>tableview的字母索引</h3><p>实现<code>sectionIndexTitlesForTableView</code>方法，返回一个字符串数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class=\"built_in\">UITableView</span> *)tableView&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *indexs = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"我\"</span>];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"是\"</span>];</div><div class=\"line\">    <span class=\"keyword\">return</span> indexs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。</p>\n<h3 id=\"点击cell中button获取所属indexpath\"><a href=\"#点击cell中button获取所属indexpath\" class=\"headerlink\" title=\"点击cell中button获取所属indexpath\"></a>点击cell中button获取所属indexpath</h3><p>button点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[cell.btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(cellBtnClicked:event:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cellBtnClicked:(<span class=\"keyword\">id</span>)sender event:(<span class=\"keyword\">id</span>)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSSet</span> *touches =[event allTouches];</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch =[touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> currentTouchPosition = [touch locationInView:_tableView];</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexPath!= <span class=\"literal\">nil</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>event</code>拿到在tableView中的位置<code>cure</code>，再通过<code>indexPathForRowAtPoint:</code>方法获取<code>NSIndexPath</code>。</p>\n<p>另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//cell.h中的声明</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)buttonPressed :(<span class=\"keyword\">id</span>)；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//cell.m中的实现，设置代理</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.delegate buttonPressed:<span class=\"keyword\">self</span> event:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewcontroller中的实现</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(TableViewCell1 *)cell&#123;</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath2 = [_tableView indexPathForCell:cell];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"所属行数：%ld\"</span>,(<span class=\"keyword\">long</span>)indexPath2.row+<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过设置delegate，将button的点击事件交给viewController完成。</p>\n<h2 id=\"编辑UITableView\"><a href=\"#编辑UITableView\" class=\"headerlink\" title=\"编辑UITableView\"></a>编辑UITableView</h2><h3 id=\"编辑模式下的UITableView\"><a href=\"#编辑模式下的UITableView\" class=\"headerlink\" title=\"编辑模式下的UITableView\"></a>编辑模式下的UITableView</h3><h4 id=\"进入编辑模式\"><a href=\"#进入编辑模式\" class=\"headerlink\" title=\"进入编辑模式\"></a>进入编辑模式</h4><p>通过调用<code>[_tableView setEditing:!_tableView.isEditing animated:true]</code>进入编辑模式,可实现添加，删除，移动操作。<br>默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。</p>\n<h4 id=\"TableView-编辑行\"><a href=\"#TableView-编辑行\" class=\"headerlink\" title=\"TableView 编辑行\"></a>TableView 编辑行</h4><p>使用<strong>setEditing:animated:</strong>方法让tableView进入编辑模式.可以使用<strong>tableView:canEditRowAtIndexPath</strong>方法筛选能进入编辑模式的行：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView canEditRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(indexPath.row == (<span class=\"number\">10</span> | <span class=\"number\">12</span> | <span class=\"number\">14</span>))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果不实现该方法，默认为YES。</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>通过设置<code>UITableViewCellEditingStyle</code>可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的<code>commitEditingStyle:forRowAtIndexPath:</code>方法的入参传入。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UITableViewCellEditingStyle</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑模式下的插入和删除行\"><a href=\"#编辑模式下的插入和删除行\" class=\"headerlink\" title=\"编辑模式下的插入和删除行\"></a>编辑模式下的插入和删除行</h4><p>实现<code>tableView:commitEditingStyle:forRowAtIndexPath:</code>方法。传入三个参数。<br>第一个实参是发送该消息的UITableView对象。<br>第二个实参是<code>UITableViewCellEditingStyle</code>类型的常数(删除表格行时，传入的是<code>UITableViewCellEditingStyleDelete</code>;插入表格行时，传入的是<code>UITableViewCellEditingStyleInsert</code>)。<br>第三个实参是一个NSIndexPath对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView commitEditingStyle:(<span class=\"built_in\">UITableViewCellEditingStyle</span>)editingStyle forRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:indexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.tableView deleteRowsAtIndexPaths:[<span class=\"built_in\">NSArray</span> arrayWithObject:indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>)&#123;</div><div class=\"line\">    \t[<span class=\"keyword\">self</span>.dataSource insertObject:<span class=\"string\">@\"我是新来的\"</span> atIndex:indexPath.row];</div><div class=\"line\">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationBottom</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<code>deleteRowsAtIndexPaths</code>和<code>insertRowsAtIndexPaths</code>可以进行局部刷新，节省资源，并且还能添加指定动画。<br>delete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。</p>\n<h4 id=\"cell的移动\"><a href=\"#cell的移动\" class=\"headerlink\" title=\"cell的移动\"></a>cell的移动</h4><p>进入编辑模式后<br>实现<code>tableView:moveRowAtIndexPath:</code>方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView moveRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)destinationIndexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(sourceIndexPath == destinationIndexPath)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        Comment *comment = [<span class=\"keyword\">self</span>.dataSource objectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource insertObject:comment atIndex:destinationIndexPath.row];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定要对数据源进行正确操作。</p>\n<h4 id=\"TableView-修改删除按钮\"><a href=\"#TableView-修改删除按钮\" class=\"headerlink\" title=\"TableView 修改删除按钮\"></a>TableView 修改删除按钮</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"删除\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"不在编辑模式下的编辑方式\"><a href=\"#不在编辑模式下的编辑方式\" class=\"headerlink\" title=\"不在编辑模式下的编辑方式\"></a>不在编辑模式下的编辑方式</h3><h4 id=\"刷新方式\"><a href=\"#刷新方式\" class=\"headerlink\" title=\"刷新方式\"></a>刷新方式</h4><p>简单总结一些UITableView的刷新方法：</p>\n<ul>\n<li>reloadData                                    刷新整个表格</li>\n<li>reloadRowsAtIndexPaths:withRowAnimation:        刷新indexPath指向的cell</li>\n<li>reloadSections:withRowAnimation:                刷新NSIndexSet内包含的Section</li>\n</ul>\n<p>这三个分别刷新tableview的各个部分<br>第一个没有动画效果。<br>第二个可以传入一个数组<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationTop</span>];</div></pre></td></tr></table></figure></p>\n<p>第三个可以传入一个NSIndexSet集合<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">[_tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndex:indexPath.section]withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationLeft</span>];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入删除\"><a href=\"#插入删除\" class=\"headerlink\" title=\"插入删除\"></a>插入删除</h4><p>在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。</p>\n<ul>\n<li>deleteRowsAtIndexPaths:withRowAnimation:</li>\n<li>insertRowsAtIndexPaths:withRowAnimation:</li>\n</ul>\n<p>就不举例了。同上面一样。</p>\n","excerpt":"<p>UITableView是最常用的基本控件。此处对其一般用法进行总结。</p>","more":"<h2 id=\"UITableView基础\"><a href=\"#UITableView基础\" class=\"headerlink\" title=\"UITableView基础\"></a>UITableView基础</h2><h3 id=\"UITableView-的样式\"><a href=\"#UITableView-的样式\" class=\"headerlink\" title=\"UITableView 的样式\"></a>UITableView 的样式</h3><ol>\n<li>UITableViewStylePlain        将会保持在顶部直到被顶掉</li>\n<li>UITableViewStyleGrouped        将会随着cell一起滚动</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITableView</span> *tableView = [[<span class=\"built_in\">UITableView</span> alloc] initWithFrame:<span class=\"built_in\">CGRectZero</span> style:<span class=\"built_in\">UITableViewStyle</span>];</div></pre></td></tr></table></figure>\n<p>其中<code>CGRectZero</code>表示<code>equivalent to CGRectMake(0, 0, 0, 0)</code>.之后代码会改UITableView的Frame，所以暂且都是0。</p>\n<h3 id=\"UITableView对象提供数据\"><a href=\"#UITableView对象提供数据\" class=\"headerlink\" title=\"UITableView对象提供数据\"></a>UITableView对象提供数据</h3><p>UITableView不包含任何数据，需要提供一个数据源.<br>我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。<br>在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRAppDelegate</span>: <span class=\"title\">UIResponder</span> &lt;<span class=\"title\">UIApplicationDelegate</span>,<span class=\"title\">UITableViewDataSource</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">UITableView</span> *taskTable;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSMutable</span> Array *tasks;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中向UITableView发送<code>setDataSource</code>消息，将BNRAPPDelegate实例设置为数据源</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.taskTable.dataSource = <span class=\"keyword\">self</span>;</div></pre></td></tr></table></figure>\n<p>UITableViewDataSource设置了两个必须方法：</p>\n<ol>\n<li>根据指定的表格索引给出相应表格段包含的行数（<code>tableView：numberOfRowsInSection：</code>）</li>\n<li>根据指定表格段索引和行索引给出相应的UITableViewCell对象（<code>tableView：cellForRowAtIndexPath：</code>）<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">BNRAppDelegate</span></span></div><div class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.tasks count];</div><div class=\"line\">&#125;</div><div class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">        <span class=\"built_in\">UITableViewCell</span> *c = [<span class=\"keyword\">self</span>.taskTable dequeueReusableCellWithIdentifier:@“cell”];</div><div class=\"line\">\t    <span class=\"comment\">//重用cell</span></div><div class=\"line\">\t    <span class=\"built_in\">NSString</span> *item = [<span class=\"keyword\">self</span>.tasks objectAtIndex:indexPath.row];</div><div class=\"line\">\t    c.textLabel.text = item;</div><div class=\"line\">\t    <span class=\"keyword\">return</span> c;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>刷新表格：<code>[self.taskTable reloadData];</code></p>\n<h3 id=\"重用UITableViewCell对象\"><a href=\"#重用UITableViewCell对象\" class=\"headerlink\" title=\"重用UITableViewCell对象\"></a>重用UITableViewCell对象</h3><p>需要将自定义的cell类和identifier进行关联。<br>在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView registerClass:[<span class=\"built_in\">UITableViewCell</span> <span class=\"keyword\">class</span>] forCellReuseIdentifier:@“<span class=\"built_in\">UITableViewCell</span>”];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView registerNib:[<span class=\"built_in\">UINib</span> nibWithNibName:<span class=\"string\">@\"MineUserInfoCell\"</span> bundle:<span class=\"literal\">nil</span>]  forCellReuseIdentifier:<span class=\"string\">@\"MineUserInfoCellIdentifier\"</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用UIViewController创建tabeView\"><a href=\"#使用UIViewController创建tabeView\" class=\"headerlink\" title=\"使用UIViewController创建tabeView\"></a>使用UIViewController创建tabeView</h3><p>需要自己创建tableview属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UITableView</span> *tableView;</div></pre></td></tr></table></figure></p>\n<p>这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。<br>如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。</p>\n<h3 id=\"创建多个section的tableview\"><a href=\"#创建多个section的tableview\" class=\"headerlink\" title=\"创建多个section的tableview\"></a>创建多个section的tableview</h3><p>创建多个section的tableview需要实现方法<code>numberOfSectionsInTableView:</code>返回tableview中section的个数。其余使用和单个section一样。</p>\n<p>在<code>cellForRowAtIndexPath:</code>方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数<code>(NSIndexPath *)indexPath</code>。</p>\n<p><code>NSIndexPath</code>是一个结构体，具有两个属性<code>row</code>和<code>section</code>。表示所在section和section内row。<br><code>NSIndexPath</code>中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。<br>创建方式:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"built_in\">NSIndexPath</span> indexPathForRow:<span class=\"number\">1</span> inSection:<span class=\"number\">1</span>];</div></pre></td></tr></table></figure></p>\n<h3 id=\"TableView表头视图\"><a href=\"#TableView表头视图\" class=\"headerlink\" title=\"TableView表头视图\"></a>TableView表头视图</h3><p>表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *headerView = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HotelReviewsHeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>]lastObject];</div></pre></td></tr></table></figure></p>\n<p><strong>loadNibNamed:owner:options:</strong>返回的是个数组，保存了xib中的各个view。<code>initWithNibName</code>的实现和该方法类似，其中也会用到该方法。不过<code>initWithNibName</code>用在获取Controller的xib中。<br><code>initWithNibName</code>是延迟加载，view上的控件是 nil 的,只有到 需要显示时，才会不是 nil. <code>loadNibNamed:</code>是即时加载。<br><code>initWithNibName</code>的class是所属Controller，<code>loadNibNamed:</code>的class是NSObject。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad&#123;</div><div class=\"line\">\t<span class=\"built_in\">UIView</span> *header = <span class=\"keyword\">self</span>.headerView;</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.tableView setTableHeaderView:header];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加载完headerView后，将其设置为UITableView对象的表头视图。<br>也可以在 <strong>(UIView *)tableView:viewForHeaderInSection:</strong>方法中设置，当只有一个section时效果相同。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView viewForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section&#123;</div><div class=\"line\">    <span class=\"built_in\">UIView</span> *view = [[[<span class=\"built_in\">NSBundle</span> mainBundle] loadNibNamed:<span class=\"string\">@\"HeaderView\"</span> owner:<span class=\"literal\">nil</span> options:<span class=\"literal\">nil</span>] lastObject];</div><div class=\"line\">    <span class=\"keyword\">return</span> view;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"tableview的字母索引\"><a href=\"#tableview的字母索引\" class=\"headerlink\" title=\"tableview的字母索引\"></a>tableview的字母索引</h3><p>实现<code>sectionIndexTitlesForTableView</code>方法，返回一个字符串数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class=\"built_in\">UITableView</span> *)tableView&#123;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *indexs = [[<span class=\"built_in\">NSMutableArray</span> alloc]init];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"我\"</span>];</div><div class=\"line\">    [indexs addObject:<span class=\"string\">@\"是\"</span>];</div><div class=\"line\">    <span class=\"keyword\">return</span> indexs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。</p>\n<h3 id=\"点击cell中button获取所属indexpath\"><a href=\"#点击cell中button获取所属indexpath\" class=\"headerlink\" title=\"点击cell中button获取所属indexpath\"></a>点击cell中button获取所属indexpath</h3><p>button点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">[cell.btn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(cellBtnClicked:event:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)cellBtnClicked:(<span class=\"keyword\">id</span>)sender event:(<span class=\"keyword\">id</span>)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSSet</span> *touches =[event allTouches];</div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch =[touches anyObject];</div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> currentTouchPosition = [touch locationInView:_tableView];</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];</div><div class=\"line\">    <span class=\"keyword\">if</span> (indexPath!= <span class=\"literal\">nil</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// do something</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以通过<code>event</code>拿到在tableView中的位置<code>cure</code>，再通过<code>indexPathForRowAtPoint:</code>方法获取<code>NSIndexPath</code>。</p>\n<p>另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//cell.h中的声明</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)buttonPressed :(<span class=\"keyword\">id</span>)；</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//cell.m中的实现，设置代理</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">    [<span class=\"keyword\">self</span>.delegate buttonPressed:<span class=\"keyword\">self</span> event:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//viewcontroller中的实现</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)buttonPressed:(TableViewCell1 *)cell&#123;</div><div class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *indexPath2 = [_tableView indexPathForCell:cell];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"所属行数：%ld\"</span>,(<span class=\"keyword\">long</span>)indexPath2.row+<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过设置delegate，将button的点击事件交给viewController完成。</p>\n<h2 id=\"编辑UITableView\"><a href=\"#编辑UITableView\" class=\"headerlink\" title=\"编辑UITableView\"></a>编辑UITableView</h2><h3 id=\"编辑模式下的UITableView\"><a href=\"#编辑模式下的UITableView\" class=\"headerlink\" title=\"编辑模式下的UITableView\"></a>编辑模式下的UITableView</h3><h4 id=\"进入编辑模式\"><a href=\"#进入编辑模式\" class=\"headerlink\" title=\"进入编辑模式\"></a>进入编辑模式</h4><p>通过调用<code>[_tableView setEditing:!_tableView.isEditing animated:true]</code>进入编辑模式,可实现添加，删除，移动操作。<br>默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。</p>\n<h4 id=\"TableView-编辑行\"><a href=\"#TableView-编辑行\" class=\"headerlink\" title=\"TableView 编辑行\"></a>TableView 编辑行</h4><p>使用<strong>setEditing:animated:</strong>方法让tableView进入编辑模式.可以使用<strong>tableView:canEditRowAtIndexPath</strong>方法筛选能进入编辑模式的行：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView canEditRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(indexPath.row == (<span class=\"number\">10</span> | <span class=\"number\">12</span> | <span class=\"number\">14</span>))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果不实现该方法，默认为YES。</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>通过设置<code>UITableViewCellEditingStyle</code>可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的<code>commitEditingStyle:forRowAtIndexPath:</code>方法的入参传入。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UITableViewCellEditingStyle</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">   \t\t<span class=\"keyword\">return</span> <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑模式下的插入和删除行\"><a href=\"#编辑模式下的插入和删除行\" class=\"headerlink\" title=\"编辑模式下的插入和删除行\"></a>编辑模式下的插入和删除行</h4><p>实现<code>tableView:commitEditingStyle:forRowAtIndexPath:</code>方法。传入三个参数。<br>第一个实参是发送该消息的UITableView对象。<br>第二个实参是<code>UITableViewCellEditingStyle</code>类型的常数(删除表格行时，传入的是<code>UITableViewCellEditingStyleDelete</code>;插入表格行时，传入的是<code>UITableViewCellEditingStyleInsert</code>)。<br>第三个实参是一个NSIndexPath对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView commitEditingStyle:(<span class=\"built_in\">UITableViewCellEditingStyle</span>)editingStyle forRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleDelete</span>) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:indexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.tableView deleteRowsAtIndexPaths:[<span class=\"built_in\">NSArray</span> arrayWithObject:indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (editingStyle == <span class=\"built_in\">UITableViewCellEditingStyleInsert</span>)&#123;</div><div class=\"line\">    \t[<span class=\"keyword\">self</span>.dataSource insertObject:<span class=\"string\">@\"我是新来的\"</span> atIndex:indexPath.row];</div><div class=\"line\">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationBottom</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<code>deleteRowsAtIndexPaths</code>和<code>insertRowsAtIndexPaths</code>可以进行局部刷新，节省资源，并且还能添加指定动画。<br>delete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。</p>\n<h4 id=\"cell的移动\"><a href=\"#cell的移动\" class=\"headerlink\" title=\"cell的移动\"></a>cell的移动</h4><p>进入编辑模式后<br>实现<code>tableView:moveRowAtIndexPath:</code>方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView moveRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)destinationIndexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(sourceIndexPath == destinationIndexPath)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        Comment *comment = [<span class=\"keyword\">self</span>.dataSource objectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource removeObjectAtIndex:sourceIndexPath.row];</div><div class=\"line\">        [<span class=\"keyword\">self</span>.dataSource insertObject:comment atIndex:destinationIndexPath.row];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定要对数据源进行正确操作。</p>\n<h4 id=\"TableView-修改删除按钮\"><a href=\"#TableView-修改删除按钮\" class=\"headerlink\" title=\"TableView 修改删除按钮\"></a>TableView 修改删除按钮</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSString</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"删除\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"不在编辑模式下的编辑方式\"><a href=\"#不在编辑模式下的编辑方式\" class=\"headerlink\" title=\"不在编辑模式下的编辑方式\"></a>不在编辑模式下的编辑方式</h3><h4 id=\"刷新方式\"><a href=\"#刷新方式\" class=\"headerlink\" title=\"刷新方式\"></a>刷新方式</h4><p>简单总结一些UITableView的刷新方法：</p>\n<ul>\n<li>reloadData                                    刷新整个表格</li>\n<li>reloadRowsAtIndexPaths:withRowAnimation:        刷新indexPath指向的cell</li>\n<li>reloadSections:withRowAnimation:                刷新NSIndexSet内包含的Section</li>\n</ul>\n<p>这三个分别刷新tableview的各个部分<br>第一个没有动画效果。<br>第二个可以传入一个数组<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationTop</span>];</div></pre></td></tr></table></figure></p>\n<p>第三个可以传入一个NSIndexSet集合<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndexesInRange:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)] withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationFade</span>];</div><div class=\"line\">[_tableView reloadSections:[<span class=\"built_in\">NSIndexSet</span> indexSetWithIndex:indexPath.section]withRowAnimation:<span class=\"built_in\">UITableViewRowAnimationLeft</span>];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入删除\"><a href=\"#插入删除\" class=\"headerlink\" title=\"插入删除\"></a>插入删除</h4><p>在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。</p>\n<ul>\n<li>deleteRowsAtIndexPaths:withRowAnimation:</li>\n<li>insertRowsAtIndexPaths:withRowAnimation:</li>\n</ul>\n<p>就不举例了。同上面一样。</p>"},{"title":"UILabel高度控制","date":"2016-09-12T06:07:12.000Z","_content":"\n在[tableview自适应高度](https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/)一篇中学习了如何用`systemLayoutSizeFittingSize:`方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。\n\n<!--more-->\n\n## sizeThatFits的使用\n`sizeThatFits`是UIView中的方法：\n```objc\n- (CGSize)sizeThatFits:(CGSize)size;\n```\n\n官方文档的注释：\n>return 'best' size to fit given size. does not actually resize view. Default is return existing view size\n也就是说，该方法将会根据传入的`size`,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。\n\nUILabel会根据传入的`size`的`width`自动换行，得到`height`后，将这两个值作为估算出的`CGSize`返回。\n如果传入的是`CGSizeZero`相当于不设置换行宽度，一行到底。\n\n由于`SizeThatFits`只估算，不修改。在得到估算值后，需要手动设置UILabel的`frame`或者`constraint`：\n```objc\n- (void) useSizeThatFitsZeroWithLabel:(UILabel *)label{\n    //使用CGSizeZero相当于不设置换行宽度，一行到底\n    CGSize size = [label sizeThatFits:CGSizeZero];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n\n- (void) useSizeThatFitsCustomWithLabel:(UILabel *)label{\n    //使用自定义的CGSize，会根据size的宽度进行换行\n    CGSize size = [label sizeThatFits:CGSizeMake(50, 50)];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n```\n\n## SizeToFit\n`SizeToFit`的方法：\n```objc\n- (void)sizeToFit;  \n```\n\n`SizeToFit`的文档注释：\n> calls sizeThatFits: with current view bounds and changes bounds size.\n也就是说，它会调用`SizeThatFits`,并且直接设置View的`bounds`。\n\n既然要调用`sizeThatFits`那就需要传入一个`CGSize`。这个`CGSize`就是设置View的`frame`时传入的`height`,`width`。\n\n\n\n\n\n## frame与constraint\n在代码添加View时，init都会使用`initWithFrame:`方法。在AutoLayout后，`constraint`被使用，是为了适配不同屏幕的机器。\n\n- 设置好View之间的`constraint`后，一个View的约束改变，将会联动改变其他View的位置、大小。\n- 设置好View的`frame`或者`bound`后，改变View的`frame`，不会对其它View造成任何影响。\n- 在设置好`constraint`后，显示的View就以约束为准。修改`frame`，View的显示没有任何改变，虽然`frame`确实变了。\n\n```objc\nNSLog(@\"改变前%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n_label.frame = CGRectMake(0, 0, 200, 200);\nNSLog(@\"改变后%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n\n2016-09-12 15:32:44.458 Parallax[2126:578089] 66.000000,147.000000,180.000000,117.000000\n2016-09-12 15:32:44.459 Parallax[2126:578089] 改变后200.000000,200.000000,0.000000,0.000000\n```\n\n\n## 与systemLayoutSizeFittingSize的比较\n`systemLayoutSizeFittingSize`方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了`sizeThatFits`吧)，得到最适合的supview的高度。\n\n`sizetofit`和`sizethatfits`则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。\n\n> Demo 详见 UIScrollViewDemo/Parallax","source":"_posts/UILabel的高度计算.md","raw":"title: UILabel高度控制\ndate: 2016/9/12 14:07:12  \ncategories: IOS \ntags: \n\t- UI\n\t\n\n---\n\n在[tableview自适应高度](https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/)一篇中学习了如何用`systemLayoutSizeFittingSize:`方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。\n\n<!--more-->\n\n## sizeThatFits的使用\n`sizeThatFits`是UIView中的方法：\n```objc\n- (CGSize)sizeThatFits:(CGSize)size;\n```\n\n官方文档的注释：\n>return 'best' size to fit given size. does not actually resize view. Default is return existing view size\n也就是说，该方法将会根据传入的`size`,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。\n\nUILabel会根据传入的`size`的`width`自动换行，得到`height`后，将这两个值作为估算出的`CGSize`返回。\n如果传入的是`CGSizeZero`相当于不设置换行宽度，一行到底。\n\n由于`SizeThatFits`只估算，不修改。在得到估算值后，需要手动设置UILabel的`frame`或者`constraint`：\n```objc\n- (void) useSizeThatFitsZeroWithLabel:(UILabel *)label{\n    //使用CGSizeZero相当于不设置换行宽度，一行到底\n    CGSize size = [label sizeThatFits:CGSizeZero];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n\n- (void) useSizeThatFitsCustomWithLabel:(UILabel *)label{\n    //使用自定义的CGSize，会根据size的宽度进行换行\n    CGSize size = [label sizeThatFits:CGSizeMake(50, 50)];\n    label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);\n}\n```\n\n## SizeToFit\n`SizeToFit`的方法：\n```objc\n- (void)sizeToFit;  \n```\n\n`SizeToFit`的文档注释：\n> calls sizeThatFits: with current view bounds and changes bounds size.\n也就是说，它会调用`SizeThatFits`,并且直接设置View的`bounds`。\n\n既然要调用`sizeThatFits`那就需要传入一个`CGSize`。这个`CGSize`就是设置View的`frame`时传入的`height`,`width`。\n\n\n\n\n\n## frame与constraint\n在代码添加View时，init都会使用`initWithFrame:`方法。在AutoLayout后，`constraint`被使用，是为了适配不同屏幕的机器。\n\n- 设置好View之间的`constraint`后，一个View的约束改变，将会联动改变其他View的位置、大小。\n- 设置好View的`frame`或者`bound`后，改变View的`frame`，不会对其它View造成任何影响。\n- 在设置好`constraint`后，显示的View就以约束为准。修改`frame`，View的显示没有任何改变，虽然`frame`确实变了。\n\n```objc\nNSLog(@\"改变前%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n_label.frame = CGRectMake(0, 0, 200, 200);\nNSLog(@\"改变后%f,%f,%f,%f\",_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);\n\n2016-09-12 15:32:44.458 Parallax[2126:578089] 66.000000,147.000000,180.000000,117.000000\n2016-09-12 15:32:44.459 Parallax[2126:578089] 改变后200.000000,200.000000,0.000000,0.000000\n```\n\n\n## 与systemLayoutSizeFittingSize的比较\n`systemLayoutSizeFittingSize`方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了`sizeThatFits`吧)，得到最适合的supview的高度。\n\n`sizetofit`和`sizethatfits`则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。\n\n> Demo 详见 UIScrollViewDemo/Parallax","slug":"UILabel的高度计算","published":1,"updated":"2016-09-12T07:44:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzwt001mrgru60si0yo4","content":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/\">tableview自适应高度</a>一篇中学习了如何用<code>systemLayoutSizeFittingSize:</code>方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。</p>\n<a id=\"more\"></a>\n<h2 id=\"sizeThatFits的使用\"><a href=\"#sizeThatFits的使用\" class=\"headerlink\" title=\"sizeThatFits的使用\"></a>sizeThatFits的使用</h2><p><code>sizeThatFits</code>是UIView中的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeThatFits:(<span class=\"built_in\">CGSize</span>)size;</div></pre></td></tr></table></figure></p>\n<p>官方文档的注释：</p>\n<blockquote>\n<p>return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size<br>也就是说，该方法将会根据传入的<code>size</code>,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。</p>\n</blockquote>\n<p>UILabel会根据传入的<code>size</code>的<code>width</code>自动换行，得到<code>height</code>后，将这两个值作为估算出的<code>CGSize</code>返回。<br>如果传入的是<code>CGSizeZero</code>相当于不设置换行宽度，一行到底。</p>\n<p>由于<code>SizeThatFits</code>只估算，不修改。在得到估算值后，需要手动设置UILabel的<code>frame</code>或者<code>constraint</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsZeroWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用CGSizeZero相当于不设置换行宽度，一行到底</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeZero</span>];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsCustomWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用自定义的CGSize，会根据size的宽度进行换行</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>)];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"SizeToFit\"><a href=\"#SizeToFit\" class=\"headerlink\" title=\"SizeToFit\"></a>SizeToFit</h2><p><code>SizeToFit</code>的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sizeToFit;</div></pre></td></tr></table></figure></p>\n<p><code>SizeToFit</code>的文档注释：</p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size.<br>也就是说，它会调用<code>SizeThatFits</code>,并且直接设置View的<code>bounds</code>。</p>\n</blockquote>\n<p>既然要调用<code>sizeThatFits</code>那就需要传入一个<code>CGSize</code>。这个<code>CGSize</code>就是设置View的<code>frame</code>时传入的<code>height</code>,<code>width</code>。</p>\n<h2 id=\"frame与constraint\"><a href=\"#frame与constraint\" class=\"headerlink\" title=\"frame与constraint\"></a>frame与constraint</h2><p>在代码添加View时，init都会使用<code>initWithFrame:</code>方法。在AutoLayout后，<code>constraint</code>被使用，是为了适配不同屏幕的机器。</p>\n<ul>\n<li>设置好View之间的<code>constraint</code>后，一个View的约束改变，将会联动改变其他View的位置、大小。</li>\n<li>设置好View的<code>frame</code>或者<code>bound</code>后，改变View的<code>frame</code>，不会对其它View造成任何影响。</li>\n<li>在设置好<code>constraint</code>后，显示的View就以约束为准。修改<code>frame</code>，View的显示没有任何改变，虽然<code>frame</code>确实变了。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变前%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\">_label.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变后%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.458</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] <span class=\"number\">66.000000</span>,<span class=\"number\">147.000000</span>,<span class=\"number\">180.000000</span>,<span class=\"number\">117.000000</span></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.459</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] 改变后<span class=\"number\">200.000000</span>,<span class=\"number\">200.000000</span>,<span class=\"number\">0.000000</span>,<span class=\"number\">0.000000</span></div></pre></td></tr></table></figure>\n<h2 id=\"与systemLayoutSizeFittingSize的比较\"><a href=\"#与systemLayoutSizeFittingSize的比较\" class=\"headerlink\" title=\"与systemLayoutSizeFittingSize的比较\"></a>与systemLayoutSizeFittingSize的比较</h2><p><code>systemLayoutSizeFittingSize</code>方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了<code>sizeThatFits</code>吧)，得到最适合的supview的高度。</p>\n<p><code>sizetofit</code>和<code>sizethatfits</code>则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。</p>\n<blockquote>\n<p>Demo 详见 UIScrollViewDemo/Parallax</p>\n</blockquote>\n","excerpt":"<p>在<a href=\"https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/\">tableview自适应高度</a>一篇中学习了如何用<code>systemLayoutSizeFittingSize:</code>方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。</p>","more":"<h2 id=\"sizeThatFits的使用\"><a href=\"#sizeThatFits的使用\" class=\"headerlink\" title=\"sizeThatFits的使用\"></a>sizeThatFits的使用</h2><p><code>sizeThatFits</code>是UIView中的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeThatFits:(<span class=\"built_in\">CGSize</span>)size;</div></pre></td></tr></table></figure></p>\n<p>官方文档的注释：</p>\n<blockquote>\n<p>return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size<br>也就是说，该方法将会根据传入的<code>size</code>,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。</p>\n</blockquote>\n<p>UILabel会根据传入的<code>size</code>的<code>width</code>自动换行，得到<code>height</code>后，将这两个值作为估算出的<code>CGSize</code>返回。<br>如果传入的是<code>CGSizeZero</code>相当于不设置换行宽度，一行到底。</p>\n<p>由于<code>SizeThatFits</code>只估算，不修改。在得到估算值后，需要手动设置UILabel的<code>frame</code>或者<code>constraint</code>：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsZeroWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用CGSizeZero相当于不设置换行宽度，一行到底</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeZero</span>];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>) useSizeThatFitsCustomWithLabel:(<span class=\"built_in\">UILabel</span> *)label&#123;</div><div class=\"line\">    <span class=\"comment\">//使用自定义的CGSize，会根据size的宽度进行换行</span></div><div class=\"line\">    <span class=\"built_in\">CGSize</span> size = [label sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>)];</div><div class=\"line\">    label.frame = <span class=\"built_in\">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"SizeToFit\"><a href=\"#SizeToFit\" class=\"headerlink\" title=\"SizeToFit\"></a>SizeToFit</h2><p><code>SizeToFit</code>的方法：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)sizeToFit;</div></pre></td></tr></table></figure></p>\n<p><code>SizeToFit</code>的文档注释：</p>\n<blockquote>\n<p>calls sizeThatFits: with current view bounds and changes bounds size.<br>也就是说，它会调用<code>SizeThatFits</code>,并且直接设置View的<code>bounds</code>。</p>\n</blockquote>\n<p>既然要调用<code>sizeThatFits</code>那就需要传入一个<code>CGSize</code>。这个<code>CGSize</code>就是设置View的<code>frame</code>时传入的<code>height</code>,<code>width</code>。</p>\n<h2 id=\"frame与constraint\"><a href=\"#frame与constraint\" class=\"headerlink\" title=\"frame与constraint\"></a>frame与constraint</h2><p>在代码添加View时，init都会使用<code>initWithFrame:</code>方法。在AutoLayout后，<code>constraint</code>被使用，是为了适配不同屏幕的机器。</p>\n<ul>\n<li>设置好View之间的<code>constraint</code>后，一个View的约束改变，将会联动改变其他View的位置、大小。</li>\n<li>设置好View的<code>frame</code>或者<code>bound</code>后，改变View的<code>frame</code>，不会对其它View造成任何影响。</li>\n<li>在设置好<code>constraint</code>后，显示的View就以约束为准。修改<code>frame</code>，View的显示没有任何改变，虽然<code>frame</code>确实变了。</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变前%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\">_label.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">200</span>, <span class=\"number\">200</span>);</div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"改变后%f,%f,%f,%f\"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.458</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] <span class=\"number\">66.000000</span>,<span class=\"number\">147.000000</span>,<span class=\"number\">180.000000</span>,<span class=\"number\">117.000000</span></div><div class=\"line\"><span class=\"number\">2016</span><span class=\"number\">-09</span><span class=\"number\">-12</span> <span class=\"number\">15</span>:<span class=\"number\">32</span>:<span class=\"number\">44.459</span> Parallax[<span class=\"number\">2126</span>:<span class=\"number\">578089</span>] 改变后<span class=\"number\">200.000000</span>,<span class=\"number\">200.000000</span>,<span class=\"number\">0.000000</span>,<span class=\"number\">0.000000</span></div></pre></td></tr></table></figure>\n<h2 id=\"与systemLayoutSizeFittingSize的比较\"><a href=\"#与systemLayoutSizeFittingSize的比较\" class=\"headerlink\" title=\"与systemLayoutSizeFittingSize的比较\"></a>与systemLayoutSizeFittingSize的比较</h2><p><code>systemLayoutSizeFittingSize</code>方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了<code>sizeThatFits</code>吧)，得到最适合的supview的高度。</p>\n<p><code>sizetofit</code>和<code>sizethatfits</code>则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。</p>\n<blockquote>\n<p>Demo 详见 UIScrollViewDemo/Parallax</p>\n</blockquote>"},{"title":"Xcode插件XVim安装与使用","date":"2016-09-23T02:07:12.000Z","_content":"\nXVim是Xcode中支持Vim的插件，尝试安装和使用\n\n<!--more-->\n## 安装\n\n慕名下载了[Xcode](https://github.com/XVimProject/XVim)，但是安装起来有点曲折。\n\n先用SourceTree创建了本地仓库，`clone`了代码。貌似Xcode8和Xcode7安装起来有点区别。由于我的版本还是7.3.1，就省略了Xcode8的步骤。\n\nXcode7不能用最新的版本，需要使用`commit`在`809527b`之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。\n\n打开xcode，编译XVim。\n\n接下来这部最坑，由于没有Linux经验，文档上直接\n```\n$ make\n```\n但是没说路径，我也不知道在哪里执行，一直都是报没有`makefile`的错。而且文档上\n```\n$ xcode-select -p\n```\n也误导了我。\n\n网上搜了半天，google到了(Baidu这个垃圾)，在`clone`下来的XVim目录中执行，进入目录果然有`MakeFile`，好的，直接`make`。\n\n重启xcode，会提示是否使用Xvim，选择`load`就OK了。\n\n## 使用\n除了Vim自身的命令外,XVim还有几个Xcode命令:\n\n![XVim_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true)\n\n附带Vim使用详解：\n![XVim_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true)","source":"_posts/XVim安装.md","raw":"title: Xcode插件XVim安装与使用\ndate: 2016/9/23 10:07:12  \ncategories: IOS\ntags:\n\t- Xcode\n\n---\n\nXVim是Xcode中支持Vim的插件，尝试安装和使用\n\n<!--more-->\n## 安装\n\n慕名下载了[Xcode](https://github.com/XVimProject/XVim)，但是安装起来有点曲折。\n\n先用SourceTree创建了本地仓库，`clone`了代码。貌似Xcode8和Xcode7安装起来有点区别。由于我的版本还是7.3.1，就省略了Xcode8的步骤。\n\nXcode7不能用最新的版本，需要使用`commit`在`809527b`之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。\n\n打开xcode，编译XVim。\n\n接下来这部最坑，由于没有Linux经验，文档上直接\n```\n$ make\n```\n但是没说路径，我也不知道在哪里执行，一直都是报没有`makefile`的错。而且文档上\n```\n$ xcode-select -p\n```\n也误导了我。\n\n网上搜了半天，google到了(Baidu这个垃圾)，在`clone`下来的XVim目录中执行，进入目录果然有`MakeFile`，好的，直接`make`。\n\n重启xcode，会提示是否使用Xvim，选择`load`就OK了。\n\n## 使用\n除了Vim自身的命令外,XVim还有几个Xcode命令:\n\n![XVim_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true)\n\n附带Vim使用详解：\n![XVim_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true)","slug":"XVim安装","published":1,"updated":"2016-09-23T06:45:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzwx001qrgruxaabg5p5","content":"<p>XVim是Xcode中支持Vim的插件，尝试安装和使用</p>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>慕名下载了<a href=\"https://github.com/XVimProject/XVim\" target=\"_blank\" rel=\"external\">Xcode</a>，但是安装起来有点曲折。</p>\n<p>先用SourceTree创建了本地仓库，<code>clone</code>了代码。貌似Xcode8和Xcode7安装起来有点区别。由于我的版本还是7.3.1，就省略了Xcode8的步骤。</p>\n<p>Xcode7不能用最新的版本，需要使用<code>commit</code>在<code>809527b</code>之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。</p>\n<p>打开xcode，编译XVim。</p>\n<p>接下来这部最坑，由于没有Linux经验，文档上直接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ make</div></pre></td></tr></table></figure></p>\n<p>但是没说路径，我也不知道在哪里执行，一直都是报没有<code>makefile</code>的错。而且文档上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcode-select -p</div></pre></td></tr></table></figure></p>\n<p>也误导了我。</p>\n<p>网上搜了半天，google到了(Baidu这个垃圾)，在<code>clone</code>下来的XVim目录中执行，进入目录果然有<code>MakeFile</code>，好的，直接<code>make</code>。</p>\n<p>重启xcode，会提示是否使用Xvim，选择<code>load</code>就OK了。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>除了Vim自身的命令外,XVim还有几个Xcode命令:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true\" alt=\"XVim_1\"></p>\n<p>附带Vim使用详解：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true\" alt=\"XVim_2\"></p>\n","excerpt":"<p>XVim是Xcode中支持Vim的插件，尝试安装和使用</p>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>慕名下载了<a href=\"https://github.com/XVimProject/XVim\">Xcode</a>，但是安装起来有点曲折。</p>\n<p>先用SourceTree创建了本地仓库，<code>clone</code>了代码。貌似Xcode8和Xcode7安装起来有点区别。由于我的版本还是7.3.1，就省略了Xcode8的步骤。</p>\n<p>Xcode7不能用最新的版本，需要使用<code>commit</code>在<code>809527b</code>之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。</p>\n<p>打开xcode，编译XVim。</p>\n<p>接下来这部最坑，由于没有Linux经验，文档上直接<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ make</div></pre></td></tr></table></figure></p>\n<p>但是没说路径，我也不知道在哪里执行，一直都是报没有<code>makefile</code>的错。而且文档上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcode-select -p</div></pre></td></tr></table></figure></p>\n<p>也误导了我。</p>\n<p>网上搜了半天，google到了(Baidu这个垃圾)，在<code>clone</code>下来的XVim目录中执行，进入目录果然有<code>MakeFile</code>，好的，直接<code>make</code>。</p>\n<p>重启xcode，会提示是否使用Xvim，选择<code>load</code>就OK了。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>除了Vim自身的命令外,XVim还有几个Xcode命令:</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true\" alt=\"XVim_1\"></p>\n<p>附带Vim使用详解：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true\" alt=\"XVim_2\"></p>"},{"title":"UICollectionView 使用方法总结","date":"2016-08-05T06:07:12.000Z","_content":"\nUICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。\n\n<!--more-->\n\n## 视图\nUICollectionView上面显示内容的视图有三种**Cell**视图、**Supplementary View**和**Decoration View**。\n- Cell视图\nCollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。\n- Supplementary View\n它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。\n例如flow layout当中的headers和footers就是可选的Supplementary View。\n- Decoration View\n这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。\n\n## 注册与重用\n### 注册\n在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。\n- registerClass: forCellWithReuseIdentifier:\n- registerNib: forCellWithReuseIdentifier:\n- registerClass: forSupplementaryViewOfKind: withReuseIdentifier:\n- registerNib: forSupplementaryViewOfKind: withReuseIdentifier:\n\n前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。\n\n### 重用\n注册后，调用一下方法进行重用:\n- dequeueReusableCellWithReuseIdentifier:forIndexPath:\n- dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:\n\n## 数据源方法\n### 基本方法\n数据源方法与UITableView类似，主要有：\n- numberOfSectionsInCollectionView:\n- collectionView: numberOfItemsInSection:\n- collectionView: cellForItemAtIndexPath:\n- collectionView: viewForSupplementaryElementOfKind: atIndexPath:\n\n### 添加头部和尾部视图\ncollection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。\n```objc\n-(UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{\n    if ([kind isEqual:UICollectionElementKindSectionFooter] ) {\n        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];\n        mineTicketListReusableView.delegate = self;\n        return mineTicketListReusableView;\n    }else{\n    \treturn nil;\n    }\n}\n\n```\n\n## 部分代理方法\n###  移动cell\n```objc\n//返回YES允许其item移动\n- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n//移动item时回调\n- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath {\n}\n\n//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势\nUILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handlelongGesture:)];\n    [self.collectionView addGestureRecognizer:longGesture];\n    \n//再实现手势操作\n- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture {\n    //判断手势状态\n    switch (longGesture.state) {\n        case UIGestureRecognizerStateBegan:{\n            //判断手势落点位置是否在路径上\n            NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:[longGesture locationInView:self.collectionView]];\n            if (indexPath == nil) {\n                break;\n            }\n            //在路径上则开始移动该路径上的cell\n            [self.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];\n        }\n            break;\n        case UIGestureRecognizerStateChanged:\n            //移动过程当中随时更新cell位置\n            [self.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:self.collectionView]];\n            break;\n        case UIGestureRecognizerStateEnded:\n            //移动结束后关闭cell移动\n            [self.collectionView endInteractiveMovement];\n            break;\n        default:\n            [self.collectionView cancelInteractiveMovement];\n            break;\n    }\n}\n\n```\n\n### 点击cell高亮\n```objc\n// 允许选中时，高亮\n-(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n// 高亮完成后回调  \n// 放大缩小效果\n-(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f);\n    }];\n}\n\n// 由高亮转成非高亮完成时的回调  \n-(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(1.0f, 1.0f);\n    }];\n}\n```\n\n### 点击cell选中\n```objc\n// 设置是否允许选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 设置是否允许取消选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n  \n// 取消选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n```\n\n## FlowLayout代理方法\n### 设置每个item大小\n- @property (CGSize)itemSize\n- -collectionView:ayout:sizeForItemAtIndexPath:\n\n可以设置全局属性也可以对某个cell定制尺寸。\n\n\n### item间隔\n- @property (CGSize) minimumInteritemSpacing\n- @property (CGSize) minimumLineSpacing\n- -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:\n- -collectionView:layout:minimumLineSpacingForSectionAtIndex:\n\n同itemsize，可以设置全局属性也可以定制。\n\n### 缩进（padding）\n- @property UIEdgeInsets sectionInset;\n- -collectionView:layout:insetForSectionAtIndex:\n\n同上。\n\n### 设置headerview的layout\n- @property (CGSize) headerReferenceSize\n- @property (CGSize) footerReferenceSize\n- -collectionView:layout:referenceSizeForHeaderInSection:\n- -collectionView:layout:referenceSizeForFooterInSection:\n\n同上。\n\n## UICollectionViewLayout子类\n## 基本方法\nUICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。\n\n子类需要覆盖父类以下3个方法：\n- prepareLayout\n- layoutAttributesForElementsInRect:(CGRect)rect\n- collectionViewContentSize\n\n---\n应用场景示例：\n为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。\n因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。\n\n---\n\n### -(void)prepareLayout\n初始化参数\n\n### -(CGSize)collectionViewContentSize\n布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。\n\n### -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\n实现必须返回一个包含**UICollectionViewLayoutAttributes**对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。\n\n传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。\n\n## 其他设置\n### 对齐 \n- **-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：**\n当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。\n每次移动整数个view的长度，示例代码：\n```objc\n- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity {\n    CGFloat index = roundf((self.scrollDirection == UICollectionViewScrollDirectionVertical ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);\n    if (self.scrollDirection == UICollectionViewScrollDirectionVertical) {\n        proposedContentOffset.y = _itemHeight * index;\n    } else {\n        proposedContentOffset.x = _itemHeight * index;\n    }\n    return proposedContentOffset;\n}\n```\n\n### 对item缩放翻转\n在layoutAttributesForElementsInRect:(CGRect)rect方法中设置**transform3D**的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：\n- m11主要负责x轴缩放\n- m22主要负责y轴缩放\n- m33主要负责z轴缩放\n- 其余值综合控制旋转与翻折\n\n具体使用方法以后再写。\n\n### 是否刷新布局\n```objc\n-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds\n{\n    return !CGRectEqualToRect(newBounds, self.collectionView.bounds);\n}\n```\n划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。\n\n### 删除item\n```\n-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    [self.dataArr removeObjectAtIndex:indexPath.item];\n    //TODO:  这个方法 特别注意 删除item的方法\n    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];\n}\n```\n\n\n\n\n","source":"_posts/UICollectionView.md","raw":"title: UICollectionView 使用方法总结\ndate: 2016/8/5 14:07:12  \ncategories: IOS\ntags: \n\t- 基本控件\t\n\n---\n\nUICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。\n\n<!--more-->\n\n## 视图\nUICollectionView上面显示内容的视图有三种**Cell**视图、**Supplementary View**和**Decoration View**。\n- Cell视图\nCollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。\n- Supplementary View\n它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。\n例如flow layout当中的headers和footers就是可选的Supplementary View。\n- Decoration View\n这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。\n\n## 注册与重用\n### 注册\n在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。\n- registerClass: forCellWithReuseIdentifier:\n- registerNib: forCellWithReuseIdentifier:\n- registerClass: forSupplementaryViewOfKind: withReuseIdentifier:\n- registerNib: forSupplementaryViewOfKind: withReuseIdentifier:\n\n前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。\n\n### 重用\n注册后，调用一下方法进行重用:\n- dequeueReusableCellWithReuseIdentifier:forIndexPath:\n- dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:\n\n## 数据源方法\n### 基本方法\n数据源方法与UITableView类似，主要有：\n- numberOfSectionsInCollectionView:\n- collectionView: numberOfItemsInSection:\n- collectionView: cellForItemAtIndexPath:\n- collectionView: viewForSupplementaryElementOfKind: atIndexPath:\n\n### 添加头部和尾部视图\ncollection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。\n```objc\n-(UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{\n    if ([kind isEqual:UICollectionElementKindSectionFooter] ) {\n        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];\n        mineTicketListReusableView.delegate = self;\n        return mineTicketListReusableView;\n    }else{\n    \treturn nil;\n    }\n}\n\n```\n\n## 部分代理方法\n###  移动cell\n```objc\n//返回YES允许其item移动\n- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n//移动item时回调\n- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath {\n}\n\n//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势\nUILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handlelongGesture:)];\n    [self.collectionView addGestureRecognizer:longGesture];\n    \n//再实现手势操作\n- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture {\n    //判断手势状态\n    switch (longGesture.state) {\n        case UIGestureRecognizerStateBegan:{\n            //判断手势落点位置是否在路径上\n            NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:[longGesture locationInView:self.collectionView]];\n            if (indexPath == nil) {\n                break;\n            }\n            //在路径上则开始移动该路径上的cell\n            [self.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];\n        }\n            break;\n        case UIGestureRecognizerStateChanged:\n            //移动过程当中随时更新cell位置\n            [self.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:self.collectionView]];\n            break;\n        case UIGestureRecognizerStateEnded:\n            //移动结束后关闭cell移动\n            [self.collectionView endInteractiveMovement];\n            break;\n        default:\n            [self.collectionView cancelInteractiveMovement];\n            break;\n    }\n}\n\n```\n\n### 点击cell高亮\n```objc\n// 允许选中时，高亮\n-(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    return YES;\n}\n\n// 高亮完成后回调  \n// 放大缩小效果\n-(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f);\n    }];\n}\n\n// 由高亮转成非高亮完成时的回调  \n-(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath{\n    UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];\n    [UIView animateWithDuration:kAnimationDuration animations:^{\n        selectedCell.transform = CGAffineTransformMakeScale(1.0f, 1.0f);\n    }];\n}\n```\n\n### 点击cell选中\n```objc\n// 设置是否允许选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 设置是否允许取消选中  \n- (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n  return YES;  \n}  \n  \n// 选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n  \n// 取消选中操作  \n- (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath {  \n  NSLog(@\"%s\", __FUNCTION__);  \n}  \n```\n\n## FlowLayout代理方法\n### 设置每个item大小\n- @property (CGSize)itemSize\n- -collectionView:ayout:sizeForItemAtIndexPath:\n\n可以设置全局属性也可以对某个cell定制尺寸。\n\n\n### item间隔\n- @property (CGSize) minimumInteritemSpacing\n- @property (CGSize) minimumLineSpacing\n- -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:\n- -collectionView:layout:minimumLineSpacingForSectionAtIndex:\n\n同itemsize，可以设置全局属性也可以定制。\n\n### 缩进（padding）\n- @property UIEdgeInsets sectionInset;\n- -collectionView:layout:insetForSectionAtIndex:\n\n同上。\n\n### 设置headerview的layout\n- @property (CGSize) headerReferenceSize\n- @property (CGSize) footerReferenceSize\n- -collectionView:layout:referenceSizeForHeaderInSection:\n- -collectionView:layout:referenceSizeForFooterInSection:\n\n同上。\n\n## UICollectionViewLayout子类\n## 基本方法\nUICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。\n\n子类需要覆盖父类以下3个方法：\n- prepareLayout\n- layoutAttributesForElementsInRect:(CGRect)rect\n- collectionViewContentSize\n\n---\n应用场景示例：\n为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。\n因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。\n\n---\n\n### -(void)prepareLayout\n初始化参数\n\n### -(CGSize)collectionViewContentSize\n布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。\n\n### -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\n实现必须返回一个包含**UICollectionViewLayoutAttributes**对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。\n\n传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。\n\n## 其他设置\n### 对齐 \n- **-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：**\n当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。\n每次移动整数个view的长度，示例代码：\n```objc\n- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity {\n    CGFloat index = roundf((self.scrollDirection == UICollectionViewScrollDirectionVertical ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);\n    if (self.scrollDirection == UICollectionViewScrollDirectionVertical) {\n        proposedContentOffset.y = _itemHeight * index;\n    } else {\n        proposedContentOffset.x = _itemHeight * index;\n    }\n    return proposedContentOffset;\n}\n```\n\n### 对item缩放翻转\n在layoutAttributesForElementsInRect:(CGRect)rect方法中设置**transform3D**的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：\n- m11主要负责x轴缩放\n- m22主要负责y轴缩放\n- m33主要负责z轴缩放\n- 其余值综合控制旋转与翻折\n\n具体使用方法以后再写。\n\n### 是否刷新布局\n```objc\n-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds\n{\n    return !CGRectEqualToRect(newBounds, self.collectionView.bounds);\n}\n```\n划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。\n\n### 删除item\n```\n-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    [self.dataArr removeObjectAtIndex:indexPath.item];\n    //TODO:  这个方法 特别注意 删除item的方法\n    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];\n}\n```\n\n\n\n\n","slug":"UICollectionView","published":1,"updated":"2016-09-23T05:44:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzwz001trgru8eukaq72","content":"<p>UICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。</p>\n<a id=\"more\"></a>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>UICollectionView上面显示内容的视图有三种<strong>Cell</strong>视图、<strong>Supplementary View</strong>和<strong>Decoration View</strong>。</p>\n<ul>\n<li>Cell视图<br>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</li>\n<li>Supplementary View<br>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。<br>例如flow layout当中的headers和footers就是可选的Supplementary View。</li>\n<li>Decoration View<br>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</li>\n</ul>\n<h2 id=\"注册与重用\"><a href=\"#注册与重用\" class=\"headerlink\" title=\"注册与重用\"></a>注册与重用</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。</p>\n<ul>\n<li>registerClass: forCellWithReuseIdentifier:</li>\n<li>registerNib: forCellWithReuseIdentifier:</li>\n<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n</ul>\n<p>前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。</p>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>注册后，调用一下方法进行重用:</p>\n<ul>\n<li>dequeueReusableCellWithReuseIdentifier:forIndexPath:</li>\n<li>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</li>\n</ul>\n<h2 id=\"数据源方法\"><a href=\"#数据源方法\" class=\"headerlink\" title=\"数据源方法\"></a>数据源方法</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><p>数据源方法与UITableView类似，主要有：</p>\n<ul>\n<li>numberOfSectionsInCollectionView:</li>\n<li>collectionView: numberOfItemsInSection:</li>\n<li>collectionView: cellForItemAtIndexPath:</li>\n<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>\n</ul>\n<h3 id=\"添加头部和尾部视图\"><a href=\"#添加头部和尾部视图\" class=\"headerlink\" title=\"添加头部和尾部视图\"></a>添加头部和尾部视图</h3><p>collection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UICollectionReusableView</span> *)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class=\"built_in\">NSString</span> *)kind atIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([kind isEqual:<span class=\"built_in\">UICollectionElementKindSectionFooter</span>] ) &#123;</div><div class=\"line\">        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:<span class=\"built_in\">UICollectionElementKindSectionFooter</span> withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];</div><div class=\"line\">        mineTicketListReusableView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> mineTicketListReusableView;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"部分代理方法\"><a href=\"#部分代理方法\" class=\"headerlink\" title=\"部分代理方法\"></a>部分代理方法</h2><h3 id=\"移动cell\"><a href=\"#移动cell\" class=\"headerlink\" title=\"移动cell\"></a>移动cell</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回YES允许其item移动</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移动item时回调</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span>*)destinationIndexPath &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势</span></div><div class=\"line\"><span class=\"built_in\">UILongPressGestureRecognizer</span> *longGesture = [[<span class=\"built_in\">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(handlelongGesture:)];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView addGestureRecognizer:longGesture];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//再实现手势操作</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)handlelongGesture:(<span class=\"built_in\">UILongPressGestureRecognizer</span> *)longGesture &#123;</div><div class=\"line\">    <span class=\"comment\">//判断手势状态</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (longGesture.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateBegan</span>:&#123;</div><div class=\"line\">            <span class=\"comment\">//判断手势落点位置是否在路径上</span></div><div class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"keyword\">self</span>.collectionView indexPathForItemAtPoint:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">if</span> (indexPath == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//在路径上则开始移动该路径上的cell</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateChanged</span>:</div><div class=\"line\">            <span class=\"comment\">//移动过程当中随时更新cell位置</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateEnded</span>:</div><div class=\"line\">            <span class=\"comment\">//移动结束后关闭cell移动</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView endInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView cancelInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell高亮\"><a href=\"#点击cell高亮\" class=\"headerlink\" title=\"点击cell高亮\"></a>点击cell高亮</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 允许选中时，高亮</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 高亮完成后回调  </span></div><div class=\"line\"><span class=\"comment\">// 放大缩小效果</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">2.0</span>f, <span class=\"number\">2.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 由高亮转成非高亮完成时的回调  </span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell选中\"><a href=\"#点击cell选中\" class=\"headerlink\" title=\"点击cell选中\"></a>点击cell选中</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置是否允许选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 设置是否允许取消选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 取消选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"FlowLayout代理方法\"><a href=\"#FlowLayout代理方法\" class=\"headerlink\" title=\"FlowLayout代理方法\"></a>FlowLayout代理方法</h2><h3 id=\"设置每个item大小\"><a href=\"#设置每个item大小\" class=\"headerlink\" title=\"设置每个item大小\"></a>设置每个item大小</h3><ul>\n<li>@property (CGSize)itemSize</li>\n<li>-collectionView:ayout:sizeForItemAtIndexPath:</li>\n</ul>\n<p>可以设置全局属性也可以对某个cell定制尺寸。</p>\n<h3 id=\"item间隔\"><a href=\"#item间隔\" class=\"headerlink\" title=\"item间隔\"></a>item间隔</h3><ul>\n<li>@property (CGSize) minimumInteritemSpacing</li>\n<li>@property (CGSize) minimumLineSpacing</li>\n<li>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:</li>\n<li>-collectionView:layout:minimumLineSpacingForSectionAtIndex:</li>\n</ul>\n<p>同itemsize，可以设置全局属性也可以定制。</p>\n<h3 id=\"缩进（padding）\"><a href=\"#缩进（padding）\" class=\"headerlink\" title=\"缩进（padding）\"></a>缩进（padding）</h3><ul>\n<li>@property UIEdgeInsets sectionInset;</li>\n<li>-collectionView:layout:insetForSectionAtIndex:</li>\n</ul>\n<p>同上。</p>\n<h3 id=\"设置headerview的layout\"><a href=\"#设置headerview的layout\" class=\"headerlink\" title=\"设置headerview的layout\"></a>设置headerview的layout</h3><ul>\n<li>@property (CGSize) headerReferenceSize</li>\n<li>@property (CGSize) footerReferenceSize</li>\n<li>-collectionView:layout:referenceSizeForHeaderInSection:</li>\n<li>-collectionView:layout:referenceSizeForFooterInSection:</li>\n</ul>\n<p>同上。</p>\n<h2 id=\"UICollectionViewLayout子类\"><a href=\"#UICollectionViewLayout子类\" class=\"headerlink\" title=\"UICollectionViewLayout子类\"></a>UICollectionViewLayout子类</h2><h2 id=\"基本方法-1\"><a href=\"#基本方法-1\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><p>UICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。</p>\n<p>子类需要覆盖父类以下3个方法：</p>\n<ul>\n<li>prepareLayout</li>\n<li>layoutAttributesForElementsInRect:(CGRect)rect</li>\n<li>collectionViewContentSize</li>\n</ul>\n<hr>\n<p>应用场景示例：<br>为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。<br>因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。</p>\n<hr>\n<h3 id=\"void-prepareLayout\"><a href=\"#void-prepareLayout\" class=\"headerlink\" title=\"-(void)prepareLayout\"></a>-(void)prepareLayout</h3><p>初始化参数</p>\n<h3 id=\"CGSize-collectionViewContentSize\"><a href=\"#CGSize-collectionViewContentSize\" class=\"headerlink\" title=\"-(CGSize)collectionViewContentSize\"></a>-(CGSize)collectionViewContentSize</h3><p>布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。</p>\n<h3 id=\"NSArray-layoutAttributesForElementsInRect-CGRect-rect\"><a href=\"#NSArray-layoutAttributesForElementsInRect-CGRect-rect\" class=\"headerlink\" title=\"-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\"></a>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</h3><p>实现必须返回一个包含<strong>UICollectionViewLayoutAttributes</strong>对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。</p>\n<p>传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。</p>\n<h2 id=\"其他设置\"><a href=\"#其他设置\" class=\"headerlink\" title=\"其他设置\"></a>其他设置</h2><h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><ul>\n<li><strong>-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：</strong><br>当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。<br>每次移动整数个view的长度，示例代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class=\"built_in\">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class=\"built_in\">CGPoint</span>)velocity &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> index = roundf((<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span> ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span>) &#123;</div><div class=\"line\">        proposedContentOffset.y = _itemHeight * index;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        proposedContentOffset.x = _itemHeight * index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> proposedContentOffset;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"对item缩放翻转\"><a href=\"#对item缩放翻转\" class=\"headerlink\" title=\"对item缩放翻转\"></a>对item缩放翻转</h3><p>在layoutAttributesForElementsInRect:(CGRect)rect方法中设置<strong>transform3D</strong>的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：</p>\n<ul>\n<li>m11主要负责x轴缩放</li>\n<li>m22主要负责y轴缩放</li>\n<li>m33主要负责z轴缩放</li>\n<li>其余值综合控制旋转与翻折</li>\n</ul>\n<p>具体使用方法以后再写。</p>\n<h3 id=\"是否刷新布局\"><a href=\"#是否刷新布局\" class=\"headerlink\" title=\"是否刷新布局\"></a>是否刷新布局</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class=\"built_in\">CGRect</span>)newBounds</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">CGRectEqualToRect</span>(newBounds, <span class=\"keyword\">self</span>.collectionView.bounds);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。</p>\n<h3 id=\"删除item\"><a href=\"#删除item\" class=\"headerlink\" title=\"删除item\"></a>删除item</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dataArr removeObjectAtIndex:indexPath.item];</div><div class=\"line\">    //TODO:  这个方法 特别注意 删除item的方法</div><div class=\"line\">    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>UICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。</p>","more":"<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>UICollectionView上面显示内容的视图有三种<strong>Cell</strong>视图、<strong>Supplementary View</strong>和<strong>Decoration View</strong>。</p>\n<ul>\n<li>Cell视图<br>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</li>\n<li>Supplementary View<br>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。<br>例如flow layout当中的headers和footers就是可选的Supplementary View。</li>\n<li>Decoration View<br>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</li>\n</ul>\n<h2 id=\"注册与重用\"><a href=\"#注册与重用\" class=\"headerlink\" title=\"注册与重用\"></a>注册与重用</h2><h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。</p>\n<ul>\n<li>registerClass: forCellWithReuseIdentifier:</li>\n<li>registerNib: forCellWithReuseIdentifier:</li>\n<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>\n</ul>\n<p>前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。</p>\n<h3 id=\"重用\"><a href=\"#重用\" class=\"headerlink\" title=\"重用\"></a>重用</h3><p>注册后，调用一下方法进行重用:</p>\n<ul>\n<li>dequeueReusableCellWithReuseIdentifier:forIndexPath:</li>\n<li>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</li>\n</ul>\n<h2 id=\"数据源方法\"><a href=\"#数据源方法\" class=\"headerlink\" title=\"数据源方法\"></a>数据源方法</h2><h3 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h3><p>数据源方法与UITableView类似，主要有：</p>\n<ul>\n<li>numberOfSectionsInCollectionView:</li>\n<li>collectionView: numberOfItemsInSection:</li>\n<li>collectionView: cellForItemAtIndexPath:</li>\n<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>\n</ul>\n<h3 id=\"添加头部和尾部视图\"><a href=\"#添加头部和尾部视图\" class=\"headerlink\" title=\"添加头部和尾部视图\"></a>添加头部和尾部视图</h3><p>collection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">UICollectionReusableView</span> *)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class=\"built_in\">NSString</span> *)kind atIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ([kind isEqual:<span class=\"built_in\">UICollectionElementKindSectionFooter</span>] ) &#123;</div><div class=\"line\">        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:<span class=\"built_in\">UICollectionElementKindSectionFooter</span> withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];</div><div class=\"line\">        mineTicketListReusableView.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> mineTicketListReusableView;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"部分代理方法\"><a href=\"#部分代理方法\" class=\"headerlink\" title=\"部分代理方法\"></a>部分代理方法</h2><h3 id=\"移动cell\"><a href=\"#移动cell\" class=\"headerlink\" title=\"移动cell\"></a>移动cell</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//返回YES允许其item移动</span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//移动item时回调</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class=\"built_in\">NSIndexPath</span>*)destinationIndexPath &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势</span></div><div class=\"line\"><span class=\"built_in\">UILongPressGestureRecognizer</span> *longGesture = [[<span class=\"built_in\">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(handlelongGesture:)];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.collectionView addGestureRecognizer:longGesture];</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//再实现手势操作</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)handlelongGesture:(<span class=\"built_in\">UILongPressGestureRecognizer</span> *)longGesture &#123;</div><div class=\"line\">    <span class=\"comment\">//判断手势状态</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (longGesture.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateBegan</span>:&#123;</div><div class=\"line\">            <span class=\"comment\">//判断手势落点位置是否在路径上</span></div><div class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [<span class=\"keyword\">self</span>.collectionView indexPathForItemAtPoint:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">if</span> (indexPath == <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">//在路径上则开始移动该路径上的cell</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateChanged</span>:</div><div class=\"line\">            <span class=\"comment\">//移动过程当中随时更新cell位置</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:<span class=\"keyword\">self</span>.collectionView]];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"built_in\">UIGestureRecognizerStateEnded</span>:</div><div class=\"line\">            <span class=\"comment\">//移动结束后关闭cell移动</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView endInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            [<span class=\"keyword\">self</span>.collectionView cancelInteractiveMovement];</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell高亮\"><a href=\"#点击cell高亮\" class=\"headerlink\" title=\"点击cell高亮\"></a>点击cell高亮</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 允许选中时，高亮</span></div><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 高亮完成后回调  </span></div><div class=\"line\"><span class=\"comment\">// 放大缩小效果</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">2.0</span>f, <span class=\"number\">2.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 由高亮转成非高亮完成时的回调  </span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    <span class=\"built_in\">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class=\"line\">        selectedCell.transform = <span class=\"built_in\">CGAffineTransformMakeScale</span>(<span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"点击cell选中\"><a href=\"#点击cell选中\" class=\"headerlink\" title=\"点击cell选中\"></a>点击cell选中</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 设置是否允许选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 设置是否允许取消选中  </span></div><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView shouldDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// 取消选中操作  </span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)collectionView:(<span class=\"built_in\">UICollectionView</span> *)collectionView didDeselectItemAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;  </div><div class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>, __FUNCTION__);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"FlowLayout代理方法\"><a href=\"#FlowLayout代理方法\" class=\"headerlink\" title=\"FlowLayout代理方法\"></a>FlowLayout代理方法</h2><h3 id=\"设置每个item大小\"><a href=\"#设置每个item大小\" class=\"headerlink\" title=\"设置每个item大小\"></a>设置每个item大小</h3><ul>\n<li>@property (CGSize)itemSize</li>\n<li>-collectionView:ayout:sizeForItemAtIndexPath:</li>\n</ul>\n<p>可以设置全局属性也可以对某个cell定制尺寸。</p>\n<h3 id=\"item间隔\"><a href=\"#item间隔\" class=\"headerlink\" title=\"item间隔\"></a>item间隔</h3><ul>\n<li>@property (CGSize) minimumInteritemSpacing</li>\n<li>@property (CGSize) minimumLineSpacing</li>\n<li>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:</li>\n<li>-collectionView:layout:minimumLineSpacingForSectionAtIndex:</li>\n</ul>\n<p>同itemsize，可以设置全局属性也可以定制。</p>\n<h3 id=\"缩进（padding）\"><a href=\"#缩进（padding）\" class=\"headerlink\" title=\"缩进（padding）\"></a>缩进（padding）</h3><ul>\n<li>@property UIEdgeInsets sectionInset;</li>\n<li>-collectionView:layout:insetForSectionAtIndex:</li>\n</ul>\n<p>同上。</p>\n<h3 id=\"设置headerview的layout\"><a href=\"#设置headerview的layout\" class=\"headerlink\" title=\"设置headerview的layout\"></a>设置headerview的layout</h3><ul>\n<li>@property (CGSize) headerReferenceSize</li>\n<li>@property (CGSize) footerReferenceSize</li>\n<li>-collectionView:layout:referenceSizeForHeaderInSection:</li>\n<li>-collectionView:layout:referenceSizeForFooterInSection:</li>\n</ul>\n<p>同上。</p>\n<h2 id=\"UICollectionViewLayout子类\"><a href=\"#UICollectionViewLayout子类\" class=\"headerlink\" title=\"UICollectionViewLayout子类\"></a>UICollectionViewLayout子类</h2><h2 id=\"基本方法-1\"><a href=\"#基本方法-1\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><p>UICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。</p>\n<p>子类需要覆盖父类以下3个方法：</p>\n<ul>\n<li>prepareLayout</li>\n<li>layoutAttributesForElementsInRect:(CGRect)rect</li>\n<li>collectionViewContentSize</li>\n</ul>\n<hr>\n<p>应用场景示例：<br>为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。<br>因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。</p>\n<hr>\n<h3 id=\"void-prepareLayout\"><a href=\"#void-prepareLayout\" class=\"headerlink\" title=\"-(void)prepareLayout\"></a>-(void)prepareLayout</h3><p>初始化参数</p>\n<h3 id=\"CGSize-collectionViewContentSize\"><a href=\"#CGSize-collectionViewContentSize\" class=\"headerlink\" title=\"-(CGSize)collectionViewContentSize\"></a>-(CGSize)collectionViewContentSize</h3><p>布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。</p>\n<h3 id=\"NSArray-layoutAttributesForElementsInRect-CGRect-rect\"><a href=\"#NSArray-layoutAttributesForElementsInRect-CGRect-rect\" class=\"headerlink\" title=\"-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect\"></a>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</h3><p>实现必须返回一个包含<strong>UICollectionViewLayoutAttributes</strong>对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。</p>\n<p>传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。</p>\n<h2 id=\"其他设置\"><a href=\"#其他设置\" class=\"headerlink\" title=\"其他设置\"></a>其他设置</h2><h3 id=\"对齐\"><a href=\"#对齐\" class=\"headerlink\" title=\"对齐\"></a>对齐</h3><ul>\n<li><strong>-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：</strong><br>当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。<br>每次移动整数个view的长度，示例代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class=\"built_in\">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class=\"built_in\">CGPoint</span>)velocity &#123;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> index = roundf((<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span> ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.scrollDirection == <span class=\"built_in\">UICollectionViewScrollDirectionVertical</span>) &#123;</div><div class=\"line\">        proposedContentOffset.y = _itemHeight * index;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        proposedContentOffset.x = _itemHeight * index;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> proposedContentOffset;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"对item缩放翻转\"><a href=\"#对item缩放翻转\" class=\"headerlink\" title=\"对item缩放翻转\"></a>对item缩放翻转</h3><p>在layoutAttributesForElementsInRect:(CGRect)rect方法中设置<strong>transform3D</strong>的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：</p>\n<ul>\n<li>m11主要负责x轴缩放</li>\n<li>m22主要负责y轴缩放</li>\n<li>m33主要负责z轴缩放</li>\n<li>其余值综合控制旋转与翻折</li>\n</ul>\n<p>具体使用方法以后再写。</p>\n<h3 id=\"是否刷新布局\"><a href=\"#是否刷新布局\" class=\"headerlink\" title=\"是否刷新布局\"></a>是否刷新布局</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"built_in\">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class=\"built_in\">CGRect</span>)newBounds</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"built_in\">CGRectEqualToRect</span>(newBounds, <span class=\"keyword\">self</span>.collectionView.bounds);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。</p>\n<h3 id=\"删除item\"><a href=\"#删除item\" class=\"headerlink\" title=\"删除item\"></a>删除item</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.dataArr removeObjectAtIndex:indexPath.item];</div><div class=\"line\">    //TODO:  这个方法 特别注意 删除item的方法</div><div class=\"line\">    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Hello World","date":"2016-07-29T06:07:12.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016/7/29 14:07:12  \ncategories: 无处置放\ntags: Hexo\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-09-23T05:44:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzx2001wrgrutraaoagj","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>"},{"title":"ios响应机制","date":"2016-09-03T02:07:12.000Z","_content":"\n从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自[史上最详细的iOS之事件的传递和响应机制\n](http://www.jianshu.com/p/2e074db792ba)\n\n<!--more-->\n\n## iOS中的事件\nios中的事件可以被分为三类：**触摸事件**，**加速计事件**，**远程控制事件**。本文讨论的是触摸事件。\n\n### 响应者对象(UIResponder)\n在iOS中不是任何对象都能处理事件，只有继承了`UIResponder`的对象才能接受并处理事件，我们称之为“响应者对象”。\n\n以下都是继承自`UIResponder`的，所以都能接收并处理事件:\n- UIApplication\n- UIViewController\n- UIView\n\n那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。\n```objc\nUIResponder内部提供了以下方法来处理事件触摸事件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n加速计事件\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n远程控制事件\n- (void)remoteControlReceivedWithEvent:(UIEvent *)event;\n```\n\n## 事件的处理\n### 触摸事件：\n下面以UIView为例来说明触摸事件的处理:\n```objc\n// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件\n// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n// 提示：touches中存放的都是UITouch对象\n```\n需要注意的是：\n- 以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：**如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。**\n- 如果两根手指同时触摸一个view，那么view只会调用一次`touchesBegan:withEvent:`方法，`touches`参数中装着2个`UITouch`对象.\n- 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次`touchesBegan:withEvent:`方法，并且每次调用时的`touches`参数中只包含一个`UITouch`对象.\n\n### UITouch\n当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。\n\n#### UITouch作用\n- 保存着跟手指相关的信息，比如触摸的位置、时间、阶段\n- 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置\n- 当手指离开屏幕时，系统会销毁相应的UITouch对象\n\n#### UITouch属性\n```objc\n触摸产生时所处的窗口\n@property(nonatomic,readonly,retain) UIWindow *window;\n\n触摸产生时所处的视图\n@property(nonatomic,readonly,retain) UIView *view\n;\n\n短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击\n@property(nonatomic,readonly) NSUInteger tapCount;\n\n记录了触摸事件产生或变化时的时间，单位是秒\n@property(nonatomic,readonly) NSTimeInterval timestamp;\n\n当前触摸事件所处的状态\n@property(nonatomic,readonly) UITouchPhase phase;\n```\n\n#### UITouch方法\n```objc\n(CGPoint)locationInView:(UIView *)view;\n// 返回值表示触摸在view上的位置\n// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）\n// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置\n\n(CGPoint)previousLocationInView:(UIView *)view;\n// 该方法记录了前一个触摸点的位置\n```\n\n#### 使用UITouch实现UIView的拖拽\n```objc\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ \n    // 想让控件随着手指移动而移动,监听手指移动 \n    // 获取UITouch对象 \n    UITouch *touch = [touches anyObject]; \n    // 获取当前点的位置 \n    CGPoint curP = [touch locationInView:self]; \n    // 获取上一个点的位置 \n    CGPoint preP = [touch previousLocationInView:self]; \n    // 获取它们x轴的偏移量,每次都是相对上一次 \n    CGFloat offsetX = curP.x - preP.x; \n    // 获取y轴的偏移量 \n    CGFloat offsetY = curP.y - preP.y; \n    // 修改控件的形变或者frame,center,就可以控制控件的位置 \n    // 形变也是相对上一次形变(平移) \n    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 \n    // make:相对于最原始的位置形变 \n    // CGAffineTransform t:相对这个t的形变的基础上再去形变 \n    // 如果相对哪个形变再次形变,就传入它的形变 \n    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);\n}\n```\n通过UITouch对象获得当前点和上一个点的位置，求得偏移量\n\n## iOS中的事件的产生和传递\n### 事件的产生过程\n1. 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。\n2. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。\n3. 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。\n\t1. 首先判断主窗口（keyWindow）自己是否能接受触摸事件。\n\t2. 判断触摸点是否在自己身上。\n\t3. 子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。\n\t4. 如果触摸点在子控件上，那么重复3\n\t5. 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。\n4. 找到最合适的view后，**将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件**。\n\n触摸事件的传递是从父控件传递到子控件,也就是UIApplication->window->寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。\n\n### UIView不能接受触摸事件的三种情况\n- 不允许交互：`userInteractionEnabled = NO`\n- 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件\n- 透明度：如果设置一个控件的透明度<0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。\n\n**注 意**:\n- 默认UIImageView不能接受触摸事件，因为不允许交互，即`userInteractionEnabled = NO`，所以如果希望UIImageView可以交互，需要`userInteractionEnabled = YES`。\n- 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！\n\n### 找到最合适控件的方法\n#### hitTest：withEvent：\n只要事件一传递给一个控件,这个控件就会调用他自己的`hitTest：withEvent：`方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)\n\n#### 拦截事件\n不管点击哪里，最合适的view都是`hitTest：withEvent：`方法中返回的那个view。因此，可以通过重写`hitTest：withEvent：`方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用`[super touchesMoved:touches withEvent:event];`\n\n#### 注意\n- **`hitTest：withEvent：`是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View**\n- 不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用`hitTest:withEvent:`方法。`hitTest`的这个`CGPoint point`表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的`locationInView:`方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。\n- `hitTest：withEvent：`找到最佳View后，会一层层返回，将这个View返回给ViewController。如`hitTest:withEvent:`方法中返回`nil`，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。\n\n#### 技巧\n想让谁成为最合适的view就重写谁自己的父控件的`hitTest:withEvent:`方法返回指定的子控件。这里又要注意，最好不要在子控件内`return self`。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。\n\n例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的`hitTest:withEvent:`方法中`return self.subViews[0]`;这种情况下在redView的`hitTest:withEvent:`方法中`return self;`是不好使的！\n\n#### hitTest:withEvent：的底层实现\n```objc\n#import \"WSWindow.h\"\n@implementation WSWindow\n// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法\n// 作用:寻找并返回最合适的view\n// UIApplication -> [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统\n// point:当前手指触摸的点\n// point:是方法调用者坐标系上的点\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    // 1.判断下窗口能否接收事件\n     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil; \n    // 2.判断下点在不在窗口上 \n    // 不在窗口上 \n    if ([self pointInside:point withEvent:event] == NO) return nil; \n    // 3.从后往前遍历子控件数组 \n    int count = (int)self.subviews.count; \n    for (int i = count - 1; i >= 0; i--) { \n    \t// 获取子控件\n    \tUIView *childView = self.subviews[i]; \n    \t// 坐标系的转换,把窗口上的点转换为子控件上的点 \n    \t// 把自己控件上的点转换成子控件上的点 \n    \tCGPoint childP = [self convertPoint:point toView:childView]; \n    \tUIView *fitView = [childView hitTest:childP withEvent:event]; \n    \tif (fitView) {\n    \t\t// 如果能找到最合适的view \n    \t\treturn fitView; \n    \t}\n    } \n    // 4.没有找到更合适的view，也就是没有比自己更合适的view \n    return self;\n}\n// 作用:判断下传入过来的点在不在方法调用者的坐标系上\n// point:是方法调用者坐标系上的点\n//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n//\t\treturn NO;\n//}\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n    NSLog(@\"%s\",__func__);\n}\n@end\n```\n\n`hit:withEvent:`方法底层会调用`pointInside:withEvent:`方法判断点在不在方法调用者的坐标系上。\n\n#### pointInside:withEvent:方法\n`pointInside:withEvent:`方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。\n\n\n## 事件的响应\n### 事件的传递与响应区别\n前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -> UIWindow -> UIView -> initial view,以上就是事件的传递，也就是寻找最合适的view的过程。\n\n在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了`touches...`方法，则这个事件将由该控件来接受，如果调用了`[super touches….]`;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的`touches….`方法。\n\ntouches默认做法是把事件顺着响应者链条向上抛：\n```objc\n#import \"WSView.h\"\n@implementation WSView \n//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件\n// 上一个响应者可能是父控件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理\n\t[super touchesBegan:touches withEvent:event]; \n\t// 注意不是调用父控件的touches方法，而是调用父类的touches方法\n\t// super是父类 superview是父控件 \n\t// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。\n}\n@end\n```\n\n事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。\n\n**注意：**ViewController中如果自定义了`touchesBegan:withEvent:`方法，任何情况都会执行。只有在UIView中定义的`touchesBegan:withEvent:`方法，才会根据`hitTest：withEvent：`的不同返回，执行返回View的`touchesBegan:withEvent:`方法。估计是因为UIViewController中没有`hitTest：withEvent：`方法的缘故。\n\n### 一个事件多个对象处理\n因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 1.自己先处理事件...\n\tNSLog(@\"do somthing...\");\n\t// 2.再调用系统的默认做法，再把事件交给上一个响应者处理\n\t[super touchesBegan:touches withEvent:event]; \n}\n```\n\n\n\n>Demo 请看UIGestureRecognizer\n\n\n\n\n\n\n\n\n","source":"_posts/ios响应事件.md","raw":"title: ios响应机制\ndate: 2016/9/3 10:07:12  \ncategories: IOS\ntags:\n\t- UIResponder\n\n---\n\n从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自[史上最详细的iOS之事件的传递和响应机制\n](http://www.jianshu.com/p/2e074db792ba)\n\n<!--more-->\n\n## iOS中的事件\nios中的事件可以被分为三类：**触摸事件**，**加速计事件**，**远程控制事件**。本文讨论的是触摸事件。\n\n### 响应者对象(UIResponder)\n在iOS中不是任何对象都能处理事件，只有继承了`UIResponder`的对象才能接受并处理事件，我们称之为“响应者对象”。\n\n以下都是继承自`UIResponder`的，所以都能接收并处理事件:\n- UIApplication\n- UIViewController\n- UIView\n\n那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。\n```objc\nUIResponder内部提供了以下方法来处理事件触摸事件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;\n加速计事件\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n远程控制事件\n- (void)remoteControlReceivedWithEvent:(UIEvent *)event;\n```\n\n## 事件的处理\n### 触摸事件：\n下面以UIView为例来说明触摸事件的处理:\n```objc\n// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件\n// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event\n// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event\n// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法\n- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event\n// 提示：touches中存放的都是UITouch对象\n```\n需要注意的是：\n- 以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：**如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。**\n- 如果两根手指同时触摸一个view，那么view只会调用一次`touchesBegan:withEvent:`方法，`touches`参数中装着2个`UITouch`对象.\n- 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次`touchesBegan:withEvent:`方法，并且每次调用时的`touches`参数中只包含一个`UITouch`对象.\n\n### UITouch\n当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。\n\n#### UITouch作用\n- 保存着跟手指相关的信息，比如触摸的位置、时间、阶段\n- 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置\n- 当手指离开屏幕时，系统会销毁相应的UITouch对象\n\n#### UITouch属性\n```objc\n触摸产生时所处的窗口\n@property(nonatomic,readonly,retain) UIWindow *window;\n\n触摸产生时所处的视图\n@property(nonatomic,readonly,retain) UIView *view\n;\n\n短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击\n@property(nonatomic,readonly) NSUInteger tapCount;\n\n记录了触摸事件产生或变化时的时间，单位是秒\n@property(nonatomic,readonly) NSTimeInterval timestamp;\n\n当前触摸事件所处的状态\n@property(nonatomic,readonly) UITouchPhase phase;\n```\n\n#### UITouch方法\n```objc\n(CGPoint)locationInView:(UIView *)view;\n// 返回值表示触摸在view上的位置\n// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）\n// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置\n\n(CGPoint)previousLocationInView:(UIView *)view;\n// 该方法记录了前一个触摸点的位置\n```\n\n#### 使用UITouch实现UIView的拖拽\n```objc\n- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ \n    // 想让控件随着手指移动而移动,监听手指移动 \n    // 获取UITouch对象 \n    UITouch *touch = [touches anyObject]; \n    // 获取当前点的位置 \n    CGPoint curP = [touch locationInView:self]; \n    // 获取上一个点的位置 \n    CGPoint preP = [touch previousLocationInView:self]; \n    // 获取它们x轴的偏移量,每次都是相对上一次 \n    CGFloat offsetX = curP.x - preP.x; \n    // 获取y轴的偏移量 \n    CGFloat offsetY = curP.y - preP.y; \n    // 修改控件的形变或者frame,center,就可以控制控件的位置 \n    // 形变也是相对上一次形变(平移) \n    // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 \n    // make:相对于最原始的位置形变 \n    // CGAffineTransform t:相对这个t的形变的基础上再去形变 \n    // 如果相对哪个形变再次形变,就传入它的形变 \n    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);\n}\n```\n通过UITouch对象获得当前点和上一个点的位置，求得偏移量\n\n## iOS中的事件的产生和传递\n### 事件的产生过程\n1. 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。\n2. UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。\n3. 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。\n\t1. 首先判断主窗口（keyWindow）自己是否能接受触摸事件。\n\t2. 判断触摸点是否在自己身上。\n\t3. 子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。\n\t4. 如果触摸点在子控件上，那么重复3\n\t5. 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。\n4. 找到最合适的view后，**将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件**。\n\n触摸事件的传递是从父控件传递到子控件,也就是UIApplication->window->寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。\n\n### UIView不能接受触摸事件的三种情况\n- 不允许交互：`userInteractionEnabled = NO`\n- 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件\n- 透明度：如果设置一个控件的透明度<0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。\n\n**注 意**:\n- 默认UIImageView不能接受触摸事件，因为不允许交互，即`userInteractionEnabled = NO`，所以如果希望UIImageView可以交互，需要`userInteractionEnabled = YES`。\n- 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！\n\n### 找到最合适控件的方法\n#### hitTest：withEvent：\n只要事件一传递给一个控件,这个控件就会调用他自己的`hitTest：withEvent：`方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)\n\n#### 拦截事件\n不管点击哪里，最合适的view都是`hitTest：withEvent：`方法中返回的那个view。因此，可以通过重写`hitTest：withEvent：`方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用`[super touchesMoved:touches withEvent:event];`\n\n#### 注意\n- **`hitTest：withEvent：`是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View**\n- 不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用`hitTest:withEvent:`方法。`hitTest`的这个`CGPoint point`表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的`locationInView:`方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。\n- `hitTest：withEvent：`找到最佳View后，会一层层返回，将这个View返回给ViewController。如`hitTest:withEvent:`方法中返回`nil`，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。\n\n#### 技巧\n想让谁成为最合适的view就重写谁自己的父控件的`hitTest:withEvent:`方法返回指定的子控件。这里又要注意，最好不要在子控件内`return self`。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。\n\n例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的`hitTest:withEvent:`方法中`return self.subViews[0]`;这种情况下在redView的`hitTest:withEvent:`方法中`return self;`是不好使的！\n\n#### hitTest:withEvent：的底层实现\n```objc\n#import \"WSWindow.h\"\n@implementation WSWindow\n// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法\n// 作用:寻找并返回最合适的view\n// UIApplication -> [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统\n// point:当前手指触摸的点\n// point:是方法调用者坐标系上的点\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{\n    // 1.判断下窗口能否接收事件\n     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil; \n    // 2.判断下点在不在窗口上 \n    // 不在窗口上 \n    if ([self pointInside:point withEvent:event] == NO) return nil; \n    // 3.从后往前遍历子控件数组 \n    int count = (int)self.subviews.count; \n    for (int i = count - 1; i >= 0; i--) { \n    \t// 获取子控件\n    \tUIView *childView = self.subviews[i]; \n    \t// 坐标系的转换,把窗口上的点转换为子控件上的点 \n    \t// 把自己控件上的点转换成子控件上的点 \n    \tCGPoint childP = [self convertPoint:point toView:childView]; \n    \tUIView *fitView = [childView hitTest:childP withEvent:event]; \n    \tif (fitView) {\n    \t\t// 如果能找到最合适的view \n    \t\treturn fitView; \n    \t}\n    } \n    // 4.没有找到更合适的view，也就是没有比自己更合适的view \n    return self;\n}\n// 作用:判断下传入过来的点在不在方法调用者的坐标系上\n// point:是方法调用者坐标系上的点\n//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n//\t\treturn NO;\n//}\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n    NSLog(@\"%s\",__func__);\n}\n@end\n```\n\n`hit:withEvent:`方法底层会调用`pointInside:withEvent:`方法判断点在不在方法调用者的坐标系上。\n\n#### pointInside:withEvent:方法\n`pointInside:withEvent:`方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。\n\n\n## 事件的响应\n### 事件的传递与响应区别\n前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -> UIWindow -> UIView -> initial view,以上就是事件的传递，也就是寻找最合适的view的过程。\n\n在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了`touches...`方法，则这个事件将由该控件来接受，如果调用了`[super touches….]`;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的`touches….`方法。\n\ntouches默认做法是把事件顺着响应者链条向上抛：\n```objc\n#import \"WSView.h\"\n@implementation WSView \n//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件\n// 上一个响应者可能是父控件\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理\n\t[super touchesBegan:touches withEvent:event]; \n\t// 注意不是调用父控件的touches方法，而是调用父类的touches方法\n\t// super是父类 superview是父控件 \n\t// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。\n}\n@end\n```\n\n事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。\n\n**注意：**ViewController中如果自定义了`touchesBegan:withEvent:`方法，任何情况都会执行。只有在UIView中定义的`touchesBegan:withEvent:`方法，才会根据`hitTest：withEvent：`的不同返回，执行返回View的`touchesBegan:withEvent:`方法。估计是因为UIViewController中没有`hitTest：withEvent：`方法的缘故。\n\n### 一个事件多个对象处理\n因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。\n\n```objc\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\t// 1.自己先处理事件...\n\tNSLog(@\"do somthing...\");\n\t// 2.再调用系统的默认做法，再把事件交给上一个响应者处理\n\t[super touchesBegan:touches withEvent:event]; \n}\n```\n\n\n\n>Demo 请看UIGestureRecognizer\n\n\n\n\n\n\n\n\n","slug":"ios响应事件","published":1,"updated":"2016-09-23T05:46:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzx4001zrgrujvidzneu","content":"<p>从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自<a href=\"http://www.jianshu.com/p/2e074db792ba\" target=\"_blank\" rel=\"external\">史上最详细的iOS之事件的传递和响应机制\n</a></p>\n<a id=\"more\"></a>\n<h2 id=\"iOS中的事件\"><a href=\"#iOS中的事件\" class=\"headerlink\" title=\"iOS中的事件\"></a>iOS中的事件</h2><p>ios中的事件可以被分为三类：<strong>触摸事件</strong>，<strong>加速计事件</strong>，<strong>远程控制事件</strong>。本文讨论的是触摸事件。</p>\n<h3 id=\"响应者对象-UIResponder\"><a href=\"#响应者对象-UIResponder\" class=\"headerlink\" title=\"响应者对象(UIResponder)\"></a>响应者对象(UIResponder)</h3><p>在iOS中不是任何对象都能处理事件，只有继承了<code>UIResponder</code>的对象才能接受并处理事件，我们称之为“响应者对象”。</p>\n<p>以下都是继承自<code>UIResponder</code>的，所以都能接收并处理事件:</p>\n<ul>\n<li>UIApplication</li>\n<li>UIViewController</li>\n<li>UIView</li>\n</ul>\n<p>那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIResponder</span>内部提供了以下方法来处理事件触摸事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">加速计事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionBegan:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionEnded:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionCancelled:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">远程控制事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)remoteControlReceivedWithEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件的处理\"><a href=\"#事件的处理\" class=\"headerlink\" title=\"事件的处理\"></a>事件的处理</h2><h3 id=\"触摸事件：\"><a href=\"#触摸事件：\" class=\"headerlink\" title=\"触摸事件：\"></a>触摸事件：</h3><p>下面以UIView为例来说明触摸事件的处理:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</span></div><div class=\"line\"><span class=\"comment\">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 提示：touches中存放的都是UITouch对象</span></div></pre></td></tr></table></figure></p>\n<p>需要注意的是：</p>\n<ul>\n<li>以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：<strong>如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。</strong></li>\n<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，<code>touches</code>参数中装着2个<code>UITouch</code>对象.</li>\n<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的<code>touches</code>参数中只包含一个<code>UITouch</code>对象.</li>\n</ul>\n<h3 id=\"UITouch\"><a href=\"#UITouch\" class=\"headerlink\" title=\"UITouch\"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。</p>\n<h4 id=\"UITouch作用\"><a href=\"#UITouch作用\" class=\"headerlink\" title=\"UITouch作用\"></a>UITouch作用</h4><ul>\n<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>\n<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>\n<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>\n</ul>\n<h4 id=\"UITouch属性\"><a href=\"#UITouch属性\" class=\"headerlink\" title=\"UITouch属性\"></a>UITouch属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">触摸产生时所处的窗口</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIWindow</span> *window;</div><div class=\"line\"></div><div class=\"line\">触摸产生时所处的视图</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIView</span> *view</div><div class=\"line\">;</div><div class=\"line\"></div><div class=\"line\">短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> tapCount;</div><div class=\"line\"></div><div class=\"line\">记录了触摸事件产生或变化时的时间，单位是秒</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> timestamp;</div><div class=\"line\"></div><div class=\"line\">当前触摸事件所处的状态</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UITouchPhase</span> phase;</div></pre></td></tr></table></figure>\n<h4 id=\"UITouch方法\"><a href=\"#UITouch方法\" class=\"headerlink\" title=\"UITouch方法\"></a>UITouch方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 返回值表示触摸在view上的位置</span></div><div class=\"line\"><span class=\"comment\">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></div><div class=\"line\"><span class=\"comment\">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)previousLocationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 该方法记录了前一个触摸点的位置</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用UITouch实现UIView的拖拽\"><a href=\"#使用UITouch实现UIView的拖拽\" class=\"headerlink\" title=\"使用UITouch实现UIView的拖拽\"></a>使用UITouch实现UIView的拖拽</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"comment\">// 想让控件随着手指移动而移动,监听手指移动 </span></div><div class=\"line\">    <span class=\"comment\">// 获取UITouch对象 </span></div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject]; </div><div class=\"line\">    <span class=\"comment\">// 获取当前点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> curP = [touch locationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取上一个点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> preP = [touch previousLocationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取它们x轴的偏移量,每次都是相对上一次 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetX = curP.x - preP.x; </div><div class=\"line\">    <span class=\"comment\">// 获取y轴的偏移量 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = curP.y - preP.y; </div><div class=\"line\">    <span class=\"comment\">// 修改控件的形变或者frame,center,就可以控制控件的位置 </span></div><div class=\"line\">    <span class=\"comment\">// 形变也是相对上一次形变(平移) </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 </span></div><div class=\"line\">    <span class=\"comment\">// make:相对于最原始的位置形变 </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransform t:相对这个t的形变的基础上再去形变 </span></div><div class=\"line\">    <span class=\"comment\">// 如果相对哪个形变再次形变,就传入它的形变 </span></div><div class=\"line\">    <span class=\"keyword\">self</span>.transform = <span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"keyword\">self</span>.transform, offsetX, offsetY);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过UITouch对象获得当前点和上一个点的位置，求得偏移量</p>\n<h2 id=\"iOS中的事件的产生和传递\"><a href=\"#iOS中的事件的产生和传递\" class=\"headerlink\" title=\"iOS中的事件的产生和传递\"></a>iOS中的事件的产生和传递</h2><h3 id=\"事件的产生过程\"><a href=\"#事件的产生过程\" class=\"headerlink\" title=\"事件的产生过程\"></a>事件的产生过程</h3><ol>\n<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>\n<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>\n<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<ol>\n<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件。</li>\n<li>判断触摸点是否在自己身上。</li>\n<li>子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。</li>\n<li>如果触摸点在子控件上，那么重复3</li>\n<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li>\n</ol>\n</li>\n<li>找到最合适的view后，<strong>将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件</strong>。</li>\n</ol>\n<p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。</p>\n<h3 id=\"UIView不能接受触摸事件的三种情况\"><a href=\"#UIView不能接受触摸事件的三种情况\" class=\"headerlink\" title=\"UIView不能接受触摸事件的三种情况\"></a>UIView不能接受触摸事件的三种情况</h3><ul>\n<li>不允许交互：<code>userInteractionEnabled = NO</code></li>\n<li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>\n<li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>\n</ul>\n<p><strong>注 意</strong>:</p>\n<ul>\n<li>默认UIImageView不能接受触摸事件，因为不允许交互，即<code>userInteractionEnabled = NO</code>，所以如果希望UIImageView可以交互，需要<code>userInteractionEnabled = YES</code>。</li>\n<li>不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！</li>\n</ul>\n<h3 id=\"找到最合适控件的方法\"><a href=\"#找到最合适控件的方法\" class=\"headerlink\" title=\"找到最合适控件的方法\"></a>找到最合适控件的方法</h3><h4 id=\"hitTest：withEvent：\"><a href=\"#hitTest：withEvent：\" class=\"headerlink\" title=\"hitTest：withEvent：\"></a>hitTest：withEvent：</h4><p>只要事件一传递给一个控件,这个控件就会调用他自己的<code>hitTest：withEvent：</code>方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)</p>\n<h4 id=\"拦截事件\"><a href=\"#拦截事件\" class=\"headerlink\" title=\"拦截事件\"></a>拦截事件</h4><p>不管点击哪里，最合适的view都是<code>hitTest：withEvent：</code>方法中返回的那个view。因此，可以通过重写<code>hitTest：withEvent：</code>方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用<code>[super touchesMoved:touches withEvent:event];</code></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><strong><code>hitTest：withEvent：</code>是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View</strong></li>\n<li>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用<code>hitTest:withEvent:</code>方法。<code>hitTest</code>的这个<code>CGPoint point</code>表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的<code>locationInView:</code>方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。</li>\n<li><code>hitTest：withEvent：</code>找到最佳View后，会一层层返回，将这个View返回给ViewController。如<code>hitTest:withEvent:</code>方法中返回<code>nil</code>，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</li>\n</ul>\n<h4 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的<code>hitTest:withEvent:</code>方法返回指定的子控件。这里又要注意，最好不要在子控件内<code>return self</code>。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。</p>\n<p>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的<code>hitTest:withEvent:</code>方法中<code>return self.subViews[0]</code>;这种情况下在redView的<code>hitTest:withEvent:</code>方法中<code>return self;</code>是不好使的！</p>\n<h4 id=\"hitTest-withEvent：的底层实现\"><a href=\"#hitTest-withEvent：的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent：的底层实现\"></a>hitTest:withEvent：的底层实现</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSWindow.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSWindow</span></span></div><div class=\"line\"><span class=\"comment\">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span></div><div class=\"line\"><span class=\"comment\">// 作用:寻找并返回最合适的view</span></div><div class=\"line\"><span class=\"comment\">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span></div><div class=\"line\"><span class=\"comment\">// point:当前手指触摸的点</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.判断下窗口能否接收事件</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.userInteractionEnabled == <span class=\"literal\">NO</span> || <span class=\"keyword\">self</span>.hidden == <span class=\"literal\">YES</span> ||  <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 2.判断下点在不在窗口上 </span></div><div class=\"line\">    <span class=\"comment\">// 不在窗口上 </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> pointInside:point withEvent:event] == <span class=\"literal\">NO</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 3.从后往前遍历子控件数组 </span></div><div class=\"line\">    <span class=\"keyword\">int</span> count = (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.subviews.count; </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; </div><div class=\"line\">    \t<span class=\"comment\">// 获取子控件</span></div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *childView = <span class=\"keyword\">self</span>.subviews[i]; </div><div class=\"line\">    \t<span class=\"comment\">// 坐标系的转换,把窗口上的点转换为子控件上的点 </span></div><div class=\"line\">    \t<span class=\"comment\">// 把自己控件上的点转换成子控件上的点 </span></div><div class=\"line\">    \t<span class=\"built_in\">CGPoint</span> childP = [<span class=\"keyword\">self</span> convertPoint:point toView:childView]; </div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *fitView = [childView hitTest:childP withEvent:event]; </div><div class=\"line\">    \t<span class=\"keyword\">if</span> (fitView) &#123;</div><div class=\"line\">    \t\t<span class=\"comment\">// 如果能找到最合适的view </span></div><div class=\"line\">    \t\t<span class=\"keyword\">return</span> fitView; </div><div class=\"line\">    \t&#125;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// 4.没有找到更合适的view，也就是没有比自己更合适的view </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\"><span class=\"comment\">//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span></div><div class=\"line\"><span class=\"comment\">//\t\treturn NO;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>hit:withEvent:</code>方法底层会调用<code>pointInside:withEvent:</code>方法判断点在不在方法调用者的坐标系上。</p>\n<h4 id=\"pointInside-withEvent-方法\"><a href=\"#pointInside-withEvent-方法\" class=\"headerlink\" title=\"pointInside:withEvent:方法\"></a>pointInside:withEvent:方法</h4><p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>\n<h2 id=\"事件的响应\"><a href=\"#事件的响应\" class=\"headerlink\" title=\"事件的响应\"></a>事件的响应</h2><h3 id=\"事件的传递与响应区别\"><a href=\"#事件的传递与响应区别\" class=\"headerlink\" title=\"事件的传递与响应区别\"></a>事件的传递与响应区别</h3><p>前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>\n<p>在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了<code>touches...</code>方法，则这个事件将由该控件来接受，如果调用了<code>[super touches….]</code>;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的<code>touches….</code>方法。</p>\n<p>touches默认做法是把事件顺着响应者链条向上抛：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSView.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSView</span> </span></div><div class=\"line\"><span class=\"comment\">//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 上一个响应者可能是父控件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">\t<span class=\"comment\">// 注意不是调用父控件的touches方法，而是调用父类的touches方法</span></div><div class=\"line\">\t<span class=\"comment\">// super是父类 superview是父控件 </span></div><div class=\"line\">\t<span class=\"comment\">// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>\n<p><strong>注意：</strong>ViewController中如果自定义了<code>touchesBegan:withEvent:</code>方法，任何情况都会执行。只有在UIView中定义的<code>touchesBegan:withEvent:</code>方法，才会根据<code>hitTest：withEvent：</code>的不同返回，执行返回View的<code>touchesBegan:withEvent:</code>方法。估计是因为UIViewController中没有<code>hitTest：withEvent：</code>方法的缘故。</p>\n<h3 id=\"一个事件多个对象处理\"><a href=\"#一个事件多个对象处理\" class=\"headerlink\" title=\"一个事件多个对象处理\"></a>一个事件多个对象处理</h3><p>因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 1.自己先处理事件...</span></div><div class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"do somthing...\"</span>);</div><div class=\"line\">\t<span class=\"comment\">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo 请看UIGestureRecognizer</p>\n</blockquote>\n","excerpt":"<p>从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自<a href=\"http://www.jianshu.com/p/2e074db792ba\">史上最详细的iOS之事件的传递和响应机制\n</a></p>","more":"<h2 id=\"iOS中的事件\"><a href=\"#iOS中的事件\" class=\"headerlink\" title=\"iOS中的事件\"></a>iOS中的事件</h2><p>ios中的事件可以被分为三类：<strong>触摸事件</strong>，<strong>加速计事件</strong>，<strong>远程控制事件</strong>。本文讨论的是触摸事件。</p>\n<h3 id=\"响应者对象-UIResponder\"><a href=\"#响应者对象-UIResponder\" class=\"headerlink\" title=\"响应者对象(UIResponder)\"></a>响应者对象(UIResponder)</h3><p>在iOS中不是任何对象都能处理事件，只有继承了<code>UIResponder</code>的对象才能接受并处理事件，我们称之为“响应者对象”。</p>\n<p>以下都是继承自<code>UIResponder</code>的，所以都能接收并处理事件:</p>\n<ul>\n<li>UIApplication</li>\n<li>UIViewController</li>\n<li>UIView</li>\n</ul>\n<p>那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIResponder</span>内部提供了以下方法来处理事件触摸事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesEnded:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">加速计事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionBegan:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionEnded:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)motionCancelled:(<span class=\"built_in\">UIEventSubtype</span>)motion withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div><div class=\"line\">远程控制事件</div><div class=\"line\">- (<span class=\"keyword\">void</span>)remoteControlReceivedWithEvent:(<span class=\"built_in\">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>\n<h2 id=\"事件的处理\"><a href=\"#事件的处理\" class=\"headerlink\" title=\"事件的处理\"></a>事件的处理</h2><h3 id=\"触摸事件：\"><a href=\"#触摸事件：\" class=\"headerlink\" title=\"触摸事件：\"></a>触摸事件：</h3><p>下面以UIView为例来说明触摸事件的处理:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</span></div><div class=\"line\"><span class=\"comment\">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesCancelled:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\"><span class=\"comment\">// 提示：touches中存放的都是UITouch对象</span></div></pre></td></tr></table></figure></p>\n<p>需要注意的是：</p>\n<ul>\n<li>以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：<strong>如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。</strong></li>\n<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，<code>touches</code>参数中装着2个<code>UITouch</code>对象.</li>\n<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的<code>touches</code>参数中只包含一个<code>UITouch</code>对象.</li>\n</ul>\n<h3 id=\"UITouch\"><a href=\"#UITouch\" class=\"headerlink\" title=\"UITouch\"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。</p>\n<h4 id=\"UITouch作用\"><a href=\"#UITouch作用\" class=\"headerlink\" title=\"UITouch作用\"></a>UITouch作用</h4><ul>\n<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>\n<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>\n<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>\n</ul>\n<h4 id=\"UITouch属性\"><a href=\"#UITouch属性\" class=\"headerlink\" title=\"UITouch属性\"></a>UITouch属性</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">触摸产生时所处的窗口</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIWindow</span> *window;</div><div class=\"line\"></div><div class=\"line\">触摸产生时所处的视图</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) <span class=\"built_in\">UIView</span> *view</div><div class=\"line\">;</div><div class=\"line\"></div><div class=\"line\">短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSUInteger</span> tapCount;</div><div class=\"line\"></div><div class=\"line\">记录了触摸事件产生或变化时的时间，单位是秒</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSTimeInterval</span> timestamp;</div><div class=\"line\"></div><div class=\"line\">当前触摸事件所处的状态</div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UITouchPhase</span> phase;</div></pre></td></tr></table></figure>\n<h4 id=\"UITouch方法\"><a href=\"#UITouch方法\" class=\"headerlink\" title=\"UITouch方法\"></a>UITouch方法</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)locationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 返回值表示触摸在view上的位置</span></div><div class=\"line\"><span class=\"comment\">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></div><div class=\"line\"><span class=\"comment\">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">CGPoint</span>)previousLocationInView:(<span class=\"built_in\">UIView</span> *)view;</div><div class=\"line\"><span class=\"comment\">// 该方法记录了前一个触摸点的位置</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用UITouch实现UIView的拖拽\"><a href=\"#使用UITouch实现UIView的拖拽\" class=\"headerlink\" title=\"使用UITouch实现UIView的拖拽\"></a>使用UITouch实现UIView的拖拽</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesMoved:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"comment\">// 想让控件随着手指移动而移动,监听手指移动 </span></div><div class=\"line\">    <span class=\"comment\">// 获取UITouch对象 </span></div><div class=\"line\">    <span class=\"built_in\">UITouch</span> *touch = [touches anyObject]; </div><div class=\"line\">    <span class=\"comment\">// 获取当前点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> curP = [touch locationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取上一个点的位置 </span></div><div class=\"line\">    <span class=\"built_in\">CGPoint</span> preP = [touch previousLocationInView:<span class=\"keyword\">self</span>]; </div><div class=\"line\">    <span class=\"comment\">// 获取它们x轴的偏移量,每次都是相对上一次 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetX = curP.x - preP.x; </div><div class=\"line\">    <span class=\"comment\">// 获取y轴的偏移量 </span></div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> offsetY = curP.y - preP.y; </div><div class=\"line\">    <span class=\"comment\">// 修改控件的形变或者frame,center,就可以控制控件的位置 </span></div><div class=\"line\">    <span class=\"comment\">// 形变也是相对上一次形变(平移) </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 </span></div><div class=\"line\">    <span class=\"comment\">// make:相对于最原始的位置形变 </span></div><div class=\"line\">    <span class=\"comment\">// CGAffineTransform t:相对这个t的形变的基础上再去形变 </span></div><div class=\"line\">    <span class=\"comment\">// 如果相对哪个形变再次形变,就传入它的形变 </span></div><div class=\"line\">    <span class=\"keyword\">self</span>.transform = <span class=\"built_in\">CGAffineTransformTranslate</span>(<span class=\"keyword\">self</span>.transform, offsetX, offsetY);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过UITouch对象获得当前点和上一个点的位置，求得偏移量</p>\n<h2 id=\"iOS中的事件的产生和传递\"><a href=\"#iOS中的事件的产生和传递\" class=\"headerlink\" title=\"iOS中的事件的产生和传递\"></a>iOS中的事件的产生和传递</h2><h3 id=\"事件的产生过程\"><a href=\"#事件的产生过程\" class=\"headerlink\" title=\"事件的产生过程\"></a>事件的产生过程</h3><ol>\n<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>\n<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>\n<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<ol>\n<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件。</li>\n<li>判断触摸点是否在自己身上。</li>\n<li>子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。</li>\n<li>如果触摸点在子控件上，那么重复3</li>\n<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li>\n</ol>\n</li>\n<li>找到最合适的view后，<strong>将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件</strong>。</li>\n</ol>\n<p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。</p>\n<h3 id=\"UIView不能接受触摸事件的三种情况\"><a href=\"#UIView不能接受触摸事件的三种情况\" class=\"headerlink\" title=\"UIView不能接受触摸事件的三种情况\"></a>UIView不能接受触摸事件的三种情况</h3><ul>\n<li>不允许交互：<code>userInteractionEnabled = NO</code></li>\n<li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>\n<li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>\n</ul>\n<p><strong>注 意</strong>:</p>\n<ul>\n<li>默认UIImageView不能接受触摸事件，因为不允许交互，即<code>userInteractionEnabled = NO</code>，所以如果希望UIImageView可以交互，需要<code>userInteractionEnabled = YES</code>。</li>\n<li>不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！</li>\n</ul>\n<h3 id=\"找到最合适控件的方法\"><a href=\"#找到最合适控件的方法\" class=\"headerlink\" title=\"找到最合适控件的方法\"></a>找到最合适控件的方法</h3><h4 id=\"hitTest：withEvent：\"><a href=\"#hitTest：withEvent：\" class=\"headerlink\" title=\"hitTest：withEvent：\"></a>hitTest：withEvent：</h4><p>只要事件一传递给一个控件,这个控件就会调用他自己的<code>hitTest：withEvent：</code>方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)</p>\n<h4 id=\"拦截事件\"><a href=\"#拦截事件\" class=\"headerlink\" title=\"拦截事件\"></a>拦截事件</h4><p>不管点击哪里，最合适的view都是<code>hitTest：withEvent：</code>方法中返回的那个view。因此，可以通过重写<code>hitTest：withEvent：</code>方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用<code>[super touchesMoved:touches withEvent:event];</code></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><strong><code>hitTest：withEvent：</code>是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View</strong></li>\n<li>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用<code>hitTest:withEvent:</code>方法。<code>hitTest</code>的这个<code>CGPoint point</code>表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的<code>locationInView:</code>方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。</li>\n<li><code>hitTest：withEvent：</code>找到最佳View后，会一层层返回，将这个View返回给ViewController。如<code>hitTest:withEvent:</code>方法中返回<code>nil</code>，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</li>\n</ul>\n<h4 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的<code>hitTest:withEvent:</code>方法返回指定的子控件。这里又要注意，最好不要在子控件内<code>return self</code>。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。</p>\n<p>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的<code>hitTest:withEvent:</code>方法中<code>return self.subViews[0]</code>;这种情况下在redView的<code>hitTest:withEvent:</code>方法中<code>return self;</code>是不好使的！</p>\n<h4 id=\"hitTest-withEvent：的底层实现\"><a href=\"#hitTest-withEvent：的底层实现\" class=\"headerlink\" title=\"hitTest:withEvent：的底层实现\"></a>hitTest:withEvent：的底层实现</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSWindow.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSWindow</span></span></div><div class=\"line\"><span class=\"comment\">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span></div><div class=\"line\"><span class=\"comment\">// 作用:寻找并返回最合适的view</span></div><div class=\"line\"><span class=\"comment\">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span></div><div class=\"line\"><span class=\"comment\">// point:当前手指触摸的点</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.判断下窗口能否接收事件</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.userInteractionEnabled == <span class=\"literal\">NO</span> || <span class=\"keyword\">self</span>.hidden == <span class=\"literal\">YES</span> ||  <span class=\"keyword\">self</span>.alpha &lt;= <span class=\"number\">0.01</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 2.判断下点在不在窗口上 </span></div><div class=\"line\">    <span class=\"comment\">// 不在窗口上 </span></div><div class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> pointInside:point withEvent:event] == <span class=\"literal\">NO</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>; </div><div class=\"line\">    <span class=\"comment\">// 3.从后往前遍历子控件数组 </span></div><div class=\"line\">    <span class=\"keyword\">int</span> count = (<span class=\"keyword\">int</span>)<span class=\"keyword\">self</span>.subviews.count; </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = count - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123; </div><div class=\"line\">    \t<span class=\"comment\">// 获取子控件</span></div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *childView = <span class=\"keyword\">self</span>.subviews[i]; </div><div class=\"line\">    \t<span class=\"comment\">// 坐标系的转换,把窗口上的点转换为子控件上的点 </span></div><div class=\"line\">    \t<span class=\"comment\">// 把自己控件上的点转换成子控件上的点 </span></div><div class=\"line\">    \t<span class=\"built_in\">CGPoint</span> childP = [<span class=\"keyword\">self</span> convertPoint:point toView:childView]; </div><div class=\"line\">    \t<span class=\"built_in\">UIView</span> *fitView = [childView hitTest:childP withEvent:event]; </div><div class=\"line\">    \t<span class=\"keyword\">if</span> (fitView) &#123;</div><div class=\"line\">    \t\t<span class=\"comment\">// 如果能找到最合适的view </span></div><div class=\"line\">    \t\t<span class=\"keyword\">return</span> fitView; </div><div class=\"line\">    \t&#125;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">// 4.没有找到更合适的view，也就是没有比自己更合适的view </span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class=\"line\"><span class=\"comment\">// point:是方法调用者坐标系上的点</span></div><div class=\"line\"><span class=\"comment\">//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span></div><div class=\"line\"><span class=\"comment\">//\t\treturn NO;</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%s\"</span>,__func__);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p><code>hit:withEvent:</code>方法底层会调用<code>pointInside:withEvent:</code>方法判断点在不在方法调用者的坐标系上。</p>\n<h4 id=\"pointInside-withEvent-方法\"><a href=\"#pointInside-withEvent-方法\" class=\"headerlink\" title=\"pointInside:withEvent:方法\"></a>pointInside:withEvent:方法</h4><p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>\n<h2 id=\"事件的响应\"><a href=\"#事件的响应\" class=\"headerlink\" title=\"事件的响应\"></a>事件的响应</h2><h3 id=\"事件的传递与响应区别\"><a href=\"#事件的传递与响应区别\" class=\"headerlink\" title=\"事件的传递与响应区别\"></a>事件的传递与响应区别</h3><p>前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>\n<p>在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了<code>touches...</code>方法，则这个事件将由该控件来接受，如果调用了<code>[super touches….]</code>;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的<code>touches….</code>方法。</p>\n<p>touches默认做法是把事件顺着响应者链条向上抛：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"WSView.h\"</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">WSView</span> </span></div><div class=\"line\"><span class=\"comment\">//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件</span></div><div class=\"line\"><span class=\"comment\">// 上一个响应者可能是父控件</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">\t<span class=\"comment\">// 注意不是调用父控件的touches方法，而是调用父类的touches方法</span></div><div class=\"line\">\t<span class=\"comment\">// super是父类 superview是父控件 </span></div><div class=\"line\">\t<span class=\"comment\">// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>\n<p><strong>注意：</strong>ViewController中如果自定义了<code>touchesBegan:withEvent:</code>方法，任何情况都会执行。只有在UIView中定义的<code>touchesBegan:withEvent:</code>方法，才会根据<code>hitTest：withEvent：</code>的不同返回，执行返回View的<code>touchesBegan:withEvent:</code>方法。估计是因为UIViewController中没有<code>hitTest：withEvent：</code>方法的缘故。</p>\n<h3 id=\"一个事件多个对象处理\"><a href=\"#一个事件多个对象处理\" class=\"headerlink\" title=\"一个事件多个对象处理\"></a>一个事件多个对象处理</h3><p>因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </div><div class=\"line\">\t<span class=\"comment\">// 1.自己先处理事件...</span></div><div class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"do somthing...\"</span>);</div><div class=\"line\">\t<span class=\"comment\">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</span></div><div class=\"line\">\t[<span class=\"keyword\">super</span> touchesBegan:touches withEvent:event]; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo 请看UIGestureRecognizer</p>\n</blockquote>"},{"title":"tableview自适应高度","date":"2016-08-26T06:07:12.000Z","_content":"\n由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。\n\n<!--more-->\n\n## 设置布局约束\n在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。\n\n记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。\n\n下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：\n\n![布局示例](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true)\n\n可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。\n\n**需要注意的是：**\n1. 如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；\n2. label要显示多行，需要将其`Lines`设置为0。\n3. 题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。\n\n## cell的自适应\n### label的ios8实现\n在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的`rowHeight`属性设置为常量`UITableViewAutomaticDimension`。然后，只需将tableView的`estimatedRowHeight`属性设置为一个非零值即可开启行高估算功能,如：\n```objc\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 设置为一个接近于行高“平均值”的数值\n```\n\n这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算`contentView`的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在`viewDidLoad`或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n### label的ios7实现\n首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作`tableView:cellForRowAtIndexPath:`方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。\n**因为要在`heightForRowAtIndexPath`中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。**\n\n然后，强制cell立即更新子视图的布局，再在cell的`contentView`上调用`systemLayoutSizeFittingSize:`方法以计算出cell所需的高度。使用`UILayoutFittingCompressedSize`参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为`tableView:heightForRowAtIndexPath:`方法的返回值返回给table view。\n\n通过`systemLayoutSizeFittingSize:`方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。\n\niOS7中，你可以（也绝对应当）使用table view的`estimatedRowHeight`属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过`tableView:heightForRowAtIndexPath:`方法），估算的行高会被替换掉。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.label.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGFloat height = textHeight.height+1>90?textHeight.height+1:90;\n    return height;\n}\n```\n\n### textView的自适应\ntextViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用`systemLayoutSizeFittingSize`方法返回的高度并不包含textview的高度，需要调用`sizeThatFits`方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.textView.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGSize textViewSize = [_cell.textView sizeThatFits:CGSizeMake(_cell.textView.frame.size.width, FLT_MAX)];\n    CGFloat h  = textHeight.height + textViewSize.height;\n    CGFloat height = h+1>90?h+1:90;\n    return height;\n}\n```\n\n## UITableView+FDTemplateLayoutCell使用简介\n这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过`systemLayoutSizeFittingSize`方法计算高度，但是该框架通过**缓存**及**预加载**将效率大幅的地提高。\n\n这里就不具体分析该框架的实现原理了。可以参考[框架学习](http://blog.qiji.tech/archives/9538?utm_source=tuicool&utm_medium=referral)跟进。\n\n这里主要列举下使用方法,其实在[forkingdog的github](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)上都有，我这里只是摘录下。\n\n### 基本使用(不带cache)\n```objc\n#import \"UITableView+FDTemplateLayoutCell.h\"\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [tableView fd_heightForCellWithIdentifier:@\"reuse identifer\" configuration:^(id cell) {\n        // Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"\n        // Like:\n        //    cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，`systemLayoutSizeFittingSize:`所必须的。\n\n### 带cache的方法\n#### 以indexPath区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n缓存下每个indexPath对应的高度。\n\n#### 以key区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    Entity *entity = self.entities[indexPath.row];\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByKey:entity.uid configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n用户将要展示的cell分类，然后将分类的key传入。\n\n### Frame layout mode\n对于`Auto layout mode `和`Frame layout mode`。框架提供了两种方式，默认是自动布局。 \n\n### 再次注意\n需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。\n\n","source":"_posts/UITableview自适应高度.md","raw":"title: tableview自适应高度\ndate: 2016/8/26 14:07:12  \ncategories: IOS \ntags: \n\t- UI\n\t\n\n---\n\n由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。\n\n<!--more-->\n\n## 设置布局约束\n在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。\n\n记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。\n\n下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：\n\n![布局示例](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true)\n\n可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。\n\n**需要注意的是：**\n1. 如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；\n2. label要显示多行，需要将其`Lines`设置为0。\n3. 题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。\n\n## cell的自适应\n### label的ios8实现\n在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的`rowHeight`属性设置为常量`UITableViewAutomaticDimension`。然后，只需将tableView的`estimatedRowHeight`属性设置为一个非零值即可开启行高估算功能,如：\n```objc\nself.tableView.rowHeight = UITableViewAutomaticDimension;\nself.tableView.estimatedRowHeight = 44.0; // 设置为一个接近于行高“平均值”的数值\n```\n\n这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算`contentView`的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在`viewDidLoad`或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n### label的ios7实现\n首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作`tableView:cellForRowAtIndexPath:`方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。\n**因为要在`heightForRowAtIndexPath`中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。**\n\n然后，强制cell立即更新子视图的布局，再在cell的`contentView`上调用`systemLayoutSizeFittingSize:`方法以计算出cell所需的高度。使用`UILayoutFittingCompressedSize`参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为`tableView:heightForRowAtIndexPath:`方法的返回值返回给table view。\n\n通过`systemLayoutSizeFittingSize:`方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。\n\niOS7中，你可以（也绝对应当）使用table view的`estimatedRowHeight`属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过`tableView:heightForRowAtIndexPath:`方法），估算的行高会被替换掉。\n\n一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的`estimatedRowHeight`属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现`tableView:estimatedHeightForRowAtIndexPath:`方法，为每一行返回一个更精确的估算值。\n\n这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.label.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGFloat height = textHeight.height+1>90?textHeight.height+1:90;\n    return height;\n}\n```\n\n### textView的自适应\ntextViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用`systemLayoutSizeFittingSize`方法返回的高度并不包含textview的高度，需要调用`sizeThatFits`方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。\n\n示例：\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    _cell.textView.text = [_data objectAtIndex:indexPath.row];\n    CGSize textHeight = [_cell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];\n    CGSize textViewSize = [_cell.textView sizeThatFits:CGSizeMake(_cell.textView.frame.size.width, FLT_MAX)];\n    CGFloat h  = textHeight.height + textViewSize.height;\n    CGFloat height = h+1>90?h+1:90;\n    return height;\n}\n```\n\n## UITableView+FDTemplateLayoutCell使用简介\n这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过`systemLayoutSizeFittingSize`方法计算高度，但是该框架通过**缓存**及**预加载**将效率大幅的地提高。\n\n这里就不具体分析该框架的实现原理了。可以参考[框架学习](http://blog.qiji.tech/archives/9538?utm_source=tuicool&utm_medium=referral)跟进。\n\n这里主要列举下使用方法,其实在[forkingdog的github](https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)上都有，我这里只是摘录下。\n\n### 基本使用(不带cache)\n```objc\n#import \"UITableView+FDTemplateLayoutCell.h\"\n\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [tableView fd_heightForCellWithIdentifier:@\"reuse identifer\" configuration:^(id cell) {\n        // Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"\n        // Like:\n        //    cell.entity = self.feedEntities[indexPath.row];\n    }];\n}\n```\n\n使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，`systemLayoutSizeFittingSize:`所必须的。\n\n### 带cache的方法\n#### 以indexPath区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n缓存下每个indexPath对应的高度。\n\n#### 以key区分\n```objc\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n    Entity *entity = self.entities[indexPath.row];\n    return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByKey:entity.uid configuration:^(id cell) {\n        // configurations\n    }];\n}\n```\n用户将要展示的cell分类，然后将分类的key传入。\n\n### Frame layout mode\n对于`Auto layout mode `和`Frame layout mode`。框架提供了两种方式，默认是自动布局。 \n\n### 再次注意\n需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。\n\n","slug":"UITableview自适应高度","published":1,"updated":"2016-09-23T05:45:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxa0024rgruv76ouxdg","content":"<p>由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。</p>\n<a id=\"more\"></a>\n<h2 id=\"设置布局约束\"><a href=\"#设置布局约束\" class=\"headerlink\" title=\"设置布局约束\"></a>设置布局约束</h2><p>在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。</p>\n<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>\n<p>下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true\" alt=\"布局示例\"></p>\n<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。</p>\n<p><strong>需要注意的是：</strong></p>\n<ol>\n<li>如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；</li>\n<li>label要显示多行，需要将其<code>Lines</code>设置为0。</li>\n<li>题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。</li>\n</ol>\n<h2 id=\"cell的自适应\"><a href=\"#cell的自适应\" class=\"headerlink\" title=\"cell的自适应\"></a>cell的自适应</h2><h3 id=\"label的ios8实现\"><a href=\"#label的ios8实现\" class=\"headerlink\" title=\"label的ios8实现\"></a>label的ios8实现</h3><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能,如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">44.0</span>; <span class=\"comment\">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure></p>\n<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<h3 id=\"label的ios7实现\"><a href=\"#label的ios7实现\" class=\"headerlink\" title=\"label的ios7实现\"></a>label的ios7实现</h3><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。<br><strong>因为要在<code>heightForRowAtIndexPath</code>中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。</strong></p>\n<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>\n<p>通过<code>systemLayoutSizeFittingSize:</code>方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。</p>\n<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<p>这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.label.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = textHeight.height+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?textHeight.height+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"textView的自适应\"><a href=\"#textView的自适应\" class=\"headerlink\" title=\"textView的自适应\"></a>textView的自适应</h3><p>textViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用<code>systemLayoutSizeFittingSize</code>方法返回的高度并不包含textview的高度，需要调用<code>sizeThatFits</code>方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.textView.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textViewSize = [_cell.textView sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(_cell.textView.frame.size.width, FLT_MAX)];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> h  = textHeight.height + textViewSize.height;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = h+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?h+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UITableView-FDTemplateLayoutCell使用简介\"><a href=\"#UITableView-FDTemplateLayoutCell使用简介\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell使用简介\"></a>UITableView+FDTemplateLayoutCell使用简介</h2><p>这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过<code>systemLayoutSizeFittingSize</code>方法计算高度，但是该框架通过<strong>缓存</strong>及<strong>预加载</strong>将效率大幅的地提高。</p>\n<p>这里就不具体分析该框架的实现原理了。可以参考<a href=\"http://blog.qiji.tech/archives/9538?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">框架学习</a>跟进。</p>\n<p>这里主要列举下使用方法,其实在<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\" target=\"_blank\" rel=\"external\">forkingdog的github</a>上都有，我这里只是摘录下。</p>\n<h3 id=\"基本使用-不带cache\"><a href=\"#基本使用-不带cache\" class=\"headerlink\" title=\"基本使用(不带cache)\"></a>基本使用(不带cache)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UITableView+FDTemplateLayoutCell.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"reuse identifer\"</span> configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"</span></div><div class=\"line\">        <span class=\"comment\">// Like:</span></div><div class=\"line\">        <span class=\"comment\">//    cell.entity = self.feedEntities[indexPath.row];</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，<code>systemLayoutSizeFittingSize:</code>所必须的。</p>\n<h3 id=\"带cache的方法\"><a href=\"#带cache的方法\" class=\"headerlink\" title=\"带cache的方法\"></a>带cache的方法</h3><h4 id=\"以indexPath区分\"><a href=\"#以indexPath区分\" class=\"headerlink\" title=\"以indexPath区分\"></a>以indexPath区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>缓存下每个indexPath对应的高度。</p>\n<h4 id=\"以key区分\"><a href=\"#以key区分\" class=\"headerlink\" title=\"以key区分\"></a>以key区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    Entity *entity = <span class=\"keyword\">self</span>.entities[indexPath.row];</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByKey:entity.uid configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用户将要展示的cell分类，然后将分类的key传入。</p>\n<h3 id=\"Frame-layout-mode\"><a href=\"#Frame-layout-mode\" class=\"headerlink\" title=\"Frame layout mode\"></a>Frame layout mode</h3><p>对于<code>Auto layout mode</code>和<code>Frame layout mode</code>。框架提供了两种方式，默认是自动布局。 </p>\n<h3 id=\"再次注意\"><a href=\"#再次注意\" class=\"headerlink\" title=\"再次注意\"></a>再次注意</h3><p>需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。</p>\n","excerpt":"<p>由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。</p>","more":"<h2 id=\"设置布局约束\"><a href=\"#设置布局约束\" class=\"headerlink\" title=\"设置布局约束\"></a>设置布局约束</h2><p>在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。</p>\n<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>\n<p>下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true\" alt=\"布局示例\"></p>\n<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。</p>\n<p><strong>需要注意的是：</strong></p>\n<ol>\n<li>如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；</li>\n<li>label要显示多行，需要将其<code>Lines</code>设置为0。</li>\n<li>题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。</li>\n</ol>\n<h2 id=\"cell的自适应\"><a href=\"#cell的自适应\" class=\"headerlink\" title=\"cell的自适应\"></a>cell的自适应</h2><h3 id=\"label的ios8实现\"><a href=\"#label的ios8实现\" class=\"headerlink\" title=\"label的ios8实现\"></a>label的ios8实现</h3><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能,如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">self</span>.tableView.rowHeight = <span class=\"built_in\">UITableViewAutomaticDimension</span>;</div><div class=\"line\"><span class=\"keyword\">self</span>.tableView.estimatedRowHeight = <span class=\"number\">44.0</span>; <span class=\"comment\">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure></p>\n<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<h3 id=\"label的ios7实现\"><a href=\"#label的ios7实现\" class=\"headerlink\" title=\"label的ios7实现\"></a>label的ios7实现</h3><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。<br><strong>因为要在<code>heightForRowAtIndexPath</code>中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。</strong></p>\n<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>\n<p>通过<code>systemLayoutSizeFittingSize:</code>方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。</p>\n<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>\n<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>\n<p>这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.label.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = textHeight.height+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?textHeight.height+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"textView的自适应\"><a href=\"#textView的自适应\" class=\"headerlink\" title=\"textView的自适应\"></a>textView的自适应</h3><p>textViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用<code>systemLayoutSizeFittingSize</code>方法返回的高度并不包含textview的高度，需要调用<code>sizeThatFits</code>方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。</p>\n<p>示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath&#123;</div><div class=\"line\">    _cell.textView.text = [_data objectAtIndex:indexPath.row];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class=\"built_in\">UILayoutFittingCompressedSize</span>];</div><div class=\"line\">    <span class=\"built_in\">CGSize</span> textViewSize = [_cell.textView sizeThatFits:<span class=\"built_in\">CGSizeMake</span>(_cell.textView.frame.size.width, FLT_MAX)];</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> h  = textHeight.height + textViewSize.height;</div><div class=\"line\">    <span class=\"built_in\">CGFloat</span> height = h+<span class=\"number\">1</span>&gt;<span class=\"number\">90</span>?h+<span class=\"number\">1</span>:<span class=\"number\">90</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> height;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"UITableView-FDTemplateLayoutCell使用简介\"><a href=\"#UITableView-FDTemplateLayoutCell使用简介\" class=\"headerlink\" title=\"UITableView+FDTemplateLayoutCell使用简介\"></a>UITableView+FDTemplateLayoutCell使用简介</h2><p>这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过<code>systemLayoutSizeFittingSize</code>方法计算高度，但是该框架通过<strong>缓存</strong>及<strong>预加载</strong>将效率大幅的地提高。</p>\n<p>这里就不具体分析该框架的实现原理了。可以参考<a href=\"http://blog.qiji.tech/archives/9538?utm_source=tuicool&amp;utm_medium=referral\">框架学习</a>跟进。</p>\n<p>这里主要列举下使用方法,其实在<a href=\"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell\">forkingdog的github</a>上都有，我这里只是摘录下。</p>\n<h3 id=\"基本使用-不带cache\"><a href=\"#基本使用-不带cache\" class=\"headerlink\" title=\"基本使用(不带cache)\"></a>基本使用(不带cache)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UITableView+FDTemplateLayoutCell.h\"</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"reuse identifer\"</span> configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// Configure this cell with data, same as what you've done in \"-tableView:cellForRowAtIndexPath:\"</span></div><div class=\"line\">        <span class=\"comment\">// Like:</span></div><div class=\"line\">        <span class=\"comment\">//    cell.entity = self.feedEntities[indexPath.row];</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，<code>systemLayoutSizeFittingSize:</code>所必须的。</p>\n<h3 id=\"带cache的方法\"><a href=\"#带cache的方法\" class=\"headerlink\" title=\"带cache的方法\"></a>带cache的方法</h3><h4 id=\"以indexPath区分\"><a href=\"#以indexPath区分\" class=\"headerlink\" title=\"以indexPath区分\"></a>以indexPath区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByIndexPath:indexPath configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>缓存下每个indexPath对应的高度。</p>\n<h4 id=\"以key区分\"><a href=\"#以key区分\" class=\"headerlink\" title=\"以key区分\"></a>以key区分</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath &#123;</div><div class=\"line\">    Entity *entity = <span class=\"keyword\">self</span>.entities[indexPath.row];</div><div class=\"line\">    <span class=\"keyword\">return</span> [tableView fd_heightForCellWithIdentifier:<span class=\"string\">@\"identifer\"</span> cacheByKey:entity.uid configuration:^(<span class=\"keyword\">id</span> cell) &#123;</div><div class=\"line\">        <span class=\"comment\">// configurations</span></div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>用户将要展示的cell分类，然后将分类的key传入。</p>\n<h3 id=\"Frame-layout-mode\"><a href=\"#Frame-layout-mode\" class=\"headerlink\" title=\"Frame layout mode\"></a>Frame layout mode</h3><p>对于<code>Auto layout mode</code>和<code>Frame layout mode</code>。框架提供了两种方式，默认是自动布局。 </p>\n<h3 id=\"再次注意\"><a href=\"#再次注意\" class=\"headerlink\" title=\"再次注意\"></a>再次注意</h3><p>需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。</p>"},{"title":"lldb 调试方法","date":"2016-09-21T06:07:12.000Z","_content":"\n偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章[与调试器共舞 - LLDB 的华尔兹](https://objccn.io/issue-19-2/)这篇文章帮助最大。\n\n<!--more-->\nXcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。\n\nLLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：\n1. 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态\n2. 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序\n\n不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。\n\n\n## expression\nexpression的几个命令是最常用的，能提升debug效率的命令。\n\n### print\n打印一个对象:\n![print](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true)\n可以直接缩写`p`达到同样的效果。\n\n结果中有个`$0`，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以`$`开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：\n![print2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true)\n\n### expression\n#### 使用\n如果想要改变一个值，或者执行一个方法。可以使用`expression`或者`e`：\n![expression](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true)\n\nprint其实是特殊的expression，比如`p count =18`其结果和`expression count = 18`结果一样。事实上，`print`是 `expression --` 的缩写。\n\n#### 应用\n由于`expression`可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：\n```objc\n// 改变颜色\n(lldb) expression self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression [CATransaction flush]\n```\n不只是改变颜色，frame，animation等都能改变，非常有用。\n\n如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。\n\n### po\n`print`输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：\n```objc\n(lldb) p @[ @\"foo\", @\"bar\" ]\n\n(NSArray *) $8 = 0x00007fdb9b71b3e0 @\"2 objects\" \n```\n\n这个时候可以使用`po`(print object 的缩写)，相当于调用对象的`description`方法。\n```objc\n(lldb) po $8\n<__NSArrayI 0x7fdb9b71b3e0>(\nfoo,\nbar\n)\n(lldb) po @\"lunar\"\nlunar\n```\n\n## thread\n### bt\n可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:\n![frame](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true)\n\n### thread return\n这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。\n\n它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后**立刻执行返回命令，跳出当前栈帧**。这意味这函数剩余的部分**不会被执行**。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是**在函数的开头执行这个命令**，是个非常好的隔离这个函数，伪造返回值的方式 。\n\n比如下图所示：\n![return](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true)\n正常通过`isOdd`方法，一定是`return NO`的，但是通过`(lldb) thread return YES`，跳过了`isOdd`方法里的方法块，直接`return YES`\n\n正如上面所述，必须要在断点进行到如图所示的地方才可以使用`thread return`，因为:\n1. 此时当前栈帧是`isOdd`\n2. 不会造成引用问题\n\n## breakpoint\n断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.\n\n### 流程控制\n当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:\n![debug](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true)\n意义都很明确，不多说了，列举下对应的命令：\n1. continue按钮 => `continue`,缩写`c`\n2. step over按钮 => `next`，缩写`n`\n3. step in按钮 => `step`,缩写`s`\n4. step out按钮 => `finish`\n\n### 设置断点\n在断点处右击，选择`Edit Breakpoint`弹出如下设置框：\n![breakpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true)\n\n#### 蓝色的勾\n表示enable和disable断点。\n#### Condition\n指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，**不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法**）。\n#### Ignore\n忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。\n#### Action\n它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：\n![menu](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true)\n默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：\n1. **Debugger Command**：默认的选项，可以让断点执行LLDB调试命令。\n2. **Log Message**：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用`@exp@`形式。\n\n#### Options\n一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。\n### 断点类型\n#### 异常断点\n异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true)\n\n#### 符号断点\n他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true)\n\n它比普通断点的自定义设置界面多出了两个内容\n- **Symbol**：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:\n\t```objc\n\t-[MyViewController viewDidAppear:]\n\t+[MyViewController sharedInstance]\n\t```\n- **Module**：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。\n\n需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。\n\n### watchpoint\n有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用`watchpoin`t来监视一个指针的指向。\n\n当指针指向变化时，`watchpoint`会触发:\n![watchpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true)\n#### set\n添加watchpoint的方式如上图所示\n```objc\n(lldb) watchpoint set variable xxx\n```\n这里要说明一下，watchpoint要监听的对象必须是**当前类的对象**：\n![watchpoint2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true)\n由于`self.view`是从`UIViewController`中继承过来的，因此无法监听。\n\n另外，上面的`addr = 0x1556747f0`**不是指`_myView`在栈中的索引**，而是指这个Watchpoint在堆中的地址。\n\nWatchpoint的**原理**应该是在这个地址中写入了原来`_myView`指向的地址，然后对新`_myView`指向的地址和Watchpoint指向的地址是否相同来做出判断的。\n\n#### disable/delete/enable\nwatchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：\n![watchpoint3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true)\n\n## 其他技巧\n### run\n这是我比较喜欢的方法，所以单独列出来。\n\n调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入`run`就能直接让程序重新加载了。\n\n### 通过地址操作\n比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。\n\n本来想要监控`self.view.backgroundColor`的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。\n\n因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。\n\n### 代替NSLog\n看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的`debug log`的，而是`error log`；每次`NSLog`都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。\n\n\n","source":"_posts/lldb调试方法.md","raw":"title: lldb 调试方法\ndate: 2016/9/21 14:07:12  \ncategories: IOS\ntags:\n\t- Debug\n\n---\n\n偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章[与调试器共舞 - LLDB 的华尔兹](https://objccn.io/issue-19-2/)这篇文章帮助最大。\n\n<!--more-->\nXcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。\n\nLLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：\n1. 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态\n2. 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序\n\n不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。\n\n\n## expression\nexpression的几个命令是最常用的，能提升debug效率的命令。\n\n### print\n打印一个对象:\n![print](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true)\n可以直接缩写`p`达到同样的效果。\n\n结果中有个`$0`，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以`$`开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：\n![print2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true)\n\n### expression\n#### 使用\n如果想要改变一个值，或者执行一个方法。可以使用`expression`或者`e`：\n![expression](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true)\n\nprint其实是特殊的expression，比如`p count =18`其结果和`expression count = 18`结果一样。事实上，`print`是 `expression --` 的缩写。\n\n#### 应用\n由于`expression`可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：\n```objc\n// 改变颜色\n(lldb) expression self.view.backgroundColor = [UIColor redColor]\n// 刷新界面\n(lldb) expression [CATransaction flush]\n```\n不只是改变颜色，frame，animation等都能改变，非常有用。\n\n如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。\n\n### po\n`print`输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：\n```objc\n(lldb) p @[ @\"foo\", @\"bar\" ]\n\n(NSArray *) $8 = 0x00007fdb9b71b3e0 @\"2 objects\" \n```\n\n这个时候可以使用`po`(print object 的缩写)，相当于调用对象的`description`方法。\n```objc\n(lldb) po $8\n<__NSArrayI 0x7fdb9b71b3e0>(\nfoo,\nbar\n)\n(lldb) po @\"lunar\"\nlunar\n```\n\n## thread\n### bt\n可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:\n![frame](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true)\n\n### thread return\n这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。\n\n它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后**立刻执行返回命令，跳出当前栈帧**。这意味这函数剩余的部分**不会被执行**。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是**在函数的开头执行这个命令**，是个非常好的隔离这个函数，伪造返回值的方式 。\n\n比如下图所示：\n![return](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true)\n正常通过`isOdd`方法，一定是`return NO`的，但是通过`(lldb) thread return YES`，跳过了`isOdd`方法里的方法块，直接`return YES`\n\n正如上面所述，必须要在断点进行到如图所示的地方才可以使用`thread return`，因为:\n1. 此时当前栈帧是`isOdd`\n2. 不会造成引用问题\n\n## breakpoint\n断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.\n\n### 流程控制\n当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:\n![debug](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true)\n意义都很明确，不多说了，列举下对应的命令：\n1. continue按钮 => `continue`,缩写`c`\n2. step over按钮 => `next`，缩写`n`\n3. step in按钮 => `step`,缩写`s`\n4. step out按钮 => `finish`\n\n### 设置断点\n在断点处右击，选择`Edit Breakpoint`弹出如下设置框：\n![breakpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true)\n\n#### 蓝色的勾\n表示enable和disable断点。\n#### Condition\n指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，**不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法**）。\n#### Ignore\n忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。\n#### Action\n它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：\n![menu](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true)\n默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：\n1. **Debugger Command**：默认的选项，可以让断点执行LLDB调试命令。\n2. **Log Message**：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用`@exp@`形式。\n\n#### Options\n一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。\n### 断点类型\n#### 异常断点\n异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true)\n\n#### 符号断点\n他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:\n![exception](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true)\n\n它比普通断点的自定义设置界面多出了两个内容\n- **Symbol**：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:\n\t```objc\n\t-[MyViewController viewDidAppear:]\n\t+[MyViewController sharedInstance]\n\t```\n- **Module**：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。\n\n需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。\n\n### watchpoint\n有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用`watchpoin`t来监视一个指针的指向。\n\n当指针指向变化时，`watchpoint`会触发:\n![watchpoint](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true)\n#### set\n添加watchpoint的方式如上图所示\n```objc\n(lldb) watchpoint set variable xxx\n```\n这里要说明一下，watchpoint要监听的对象必须是**当前类的对象**：\n![watchpoint2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true)\n由于`self.view`是从`UIViewController`中继承过来的，因此无法监听。\n\n另外，上面的`addr = 0x1556747f0`**不是指`_myView`在栈中的索引**，而是指这个Watchpoint在堆中的地址。\n\nWatchpoint的**原理**应该是在这个地址中写入了原来`_myView`指向的地址，然后对新`_myView`指向的地址和Watchpoint指向的地址是否相同来做出判断的。\n\n#### disable/delete/enable\nwatchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：\n![watchpoint3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true)\n\n## 其他技巧\n### run\n这是我比较喜欢的方法，所以单独列出来。\n\n调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入`run`就能直接让程序重新加载了。\n\n### 通过地址操作\n比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。\n\n本来想要监控`self.view.backgroundColor`的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。\n\n因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。\n\n### 代替NSLog\n看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的`debug log`的，而是`error log`；每次`NSLog`都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。\n\n\n","slug":"lldb调试方法","published":1,"updated":"2016-09-23T05:45:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxb0025rgru9mi2jjzv","content":"<p>偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章<a href=\"https://objccn.io/issue-19-2/\" target=\"_blank\" rel=\"external\">与调试器共舞 - LLDB 的华尔兹</a>这篇文章帮助最大。</p>\n<a id=\"more\"></a>\n<p>Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。</p>\n<p>LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：</p>\n<ol>\n<li>断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态</li>\n<li>直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序</li>\n</ol>\n<p>不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。</p>\n<h2 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"expression\"></a>expression</h2><p>expression的几个命令是最常用的，能提升debug效率的命令。</p>\n<h3 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h3><p>打印一个对象:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true\" alt=\"print\"><br>可以直接缩写<code>p</code>达到同样的效果。</p>\n<p>结果中有个<code>$0</code>，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以<code>$</code>开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true\" alt=\"print2\"></p>\n<h3 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression\"></a>expression</h3><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>如果想要改变一个值，或者执行一个方法。可以使用<code>expression</code>或者<code>e</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true\" alt=\"expression\"></p>\n<p>print其实是特殊的expression，比如<code>p count =18</code>其结果和<code>expression count = 18</code>结果一样。事实上，<code>print</code>是 <code>expression --</code> 的缩写。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>由于<code>expression</code>可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 改变颜色</span></div><div class=\"line\">(lldb) expression <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor]</div><div class=\"line\"><span class=\"comment\">// 刷新界面</span></div><div class=\"line\">(lldb) expression [<span class=\"built_in\">CATransaction</span> flush]</div></pre></td></tr></table></figure></p>\n<p>不只是改变颜色，frame，animation等都能改变，非常有用。</p>\n<p>如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。</p>\n<h3 id=\"po\"><a href=\"#po\" class=\"headerlink\" title=\"po\"></a>po</h3><p><code>print</code>输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p @[ <span class=\"string\">@\"foo\"</span>, <span class=\"string\">@\"bar\"</span> ]</div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">NSArray</span> *) $<span class=\"number\">8</span> = <span class=\"number\">0x00007fdb9b71b3e0</span> <span class=\"string\">@\"2 objects\"</span></div></pre></td></tr></table></figure></p>\n<p>这个时候可以使用<code>po</code>(print object 的缩写)，相当于调用对象的<code>description</code>方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $<span class=\"number\">8</span></div><div class=\"line\">&lt;__NSArrayI <span class=\"number\">0x7fdb9b71b3e0</span>&gt;(</div><div class=\"line\">foo,</div><div class=\"line\">bar</div><div class=\"line\">)</div><div class=\"line\">(lldb) po <span class=\"string\">@\"lunar\"</span></div><div class=\"line\">lunar</div></pre></td></tr></table></figure></p>\n<h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><h3 id=\"bt\"><a href=\"#bt\" class=\"headerlink\" title=\"bt\"></a>bt</h3><p>可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true\" alt=\"frame\"></p>\n<h3 id=\"thread-return\"><a href=\"#thread-return\" class=\"headerlink\" title=\"thread return\"></a>thread return</h3><p>这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。</p>\n<p>它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后<strong>立刻执行返回命令，跳出当前栈帧</strong>。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是<strong>在函数的开头执行这个命令</strong>，是个非常好的隔离这个函数，伪造返回值的方式 。</p>\n<p>比如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true\" alt=\"return\"><br>正常通过<code>isOdd</code>方法，一定是<code>return NO</code>的，但是通过<code>(lldb) thread return YES</code>，跳过了<code>isOdd</code>方法里的方法块，直接<code>return YES</code></p>\n<p>正如上面所述，必须要在断点进行到如图所示的地方才可以使用<code>thread return</code>，因为:</p>\n<ol>\n<li>此时当前栈帧是<code>isOdd</code></li>\n<li>不会造成引用问题</li>\n</ol>\n<h2 id=\"breakpoint\"><a href=\"#breakpoint\" class=\"headerlink\" title=\"breakpoint\"></a>breakpoint</h2><p>断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.</p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p>当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true\" alt=\"debug\"><br>意义都很明确，不多说了，列举下对应的命令：</p>\n<ol>\n<li>continue按钮 =&gt; <code>continue</code>,缩写<code>c</code></li>\n<li>step over按钮 =&gt; <code>next</code>，缩写<code>n</code></li>\n<li>step in按钮 =&gt; <code>step</code>,缩写<code>s</code></li>\n<li>step out按钮 =&gt; <code>finish</code></li>\n</ol>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><p>在断点处右击，选择<code>Edit Breakpoint</code>弹出如下设置框：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true\" alt=\"breakpoint\"></p>\n<h4 id=\"蓝色的勾\"><a href=\"#蓝色的勾\" class=\"headerlink\" title=\"蓝色的勾\"></a>蓝色的勾</h4><p>表示enable和disable断点。</p>\n<h4 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h4><p>指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，<strong>不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法</strong>）。</p>\n<h4 id=\"Ignore\"><a href=\"#Ignore\" class=\"headerlink\" title=\"Ignore\"></a>Ignore</h4><p>忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。</p>\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true\" alt=\"menu\"><br>默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：</p>\n<ol>\n<li><strong>Debugger Command</strong>：默认的选项，可以让断点执行LLDB调试命令。</li>\n<li><strong>Log Message</strong>：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用<code>@exp@</code>形式。</li>\n</ol>\n<h4 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h4><p>一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。</p>\n<h3 id=\"断点类型\"><a href=\"#断点类型\" class=\"headerlink\" title=\"断点类型\"></a>断点类型</h3><h4 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h4><p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true\" alt=\"exception\"></p>\n<h4 id=\"符号断点\"><a href=\"#符号断点\" class=\"headerlink\" title=\"符号断点\"></a>符号断点</h4><p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true\" alt=\"exception\"></p>\n<p>它比普通断点的自定义设置界面多出了两个内容</p>\n<ul>\n<li><p><strong>Symbol</strong>：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[MyViewController viewDidAppear:]</div><div class=\"line\">+[MyViewController sharedInstance]</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Module</strong>：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>\n</li>\n</ul>\n<p>需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。</p>\n<h3 id=\"watchpoint\"><a href=\"#watchpoint\" class=\"headerlink\" title=\"watchpoint\"></a>watchpoint</h3><p>有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用<code>watchpoin</code>t来监视一个指针的指向。</p>\n<p>当指针指向变化时，<code>watchpoint</code>会触发:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true\" alt=\"watchpoint\"></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>添加watchpoint的方式如上图所示<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) watchpoint set variable xxx</div></pre></td></tr></table></figure></p>\n<p>这里要说明一下，watchpoint要监听的对象必须是<strong>当前类的对象</strong>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true\" alt=\"watchpoint2\"><br>由于<code>self.view</code>是从<code>UIViewController</code>中继承过来的，因此无法监听。</p>\n<p>另外，上面的<code>addr = 0x1556747f0</code><strong>不是指<code>_myView</code>在栈中的索引</strong>，而是指这个Watchpoint在堆中的地址。</p>\n<p>Watchpoint的<strong>原理</strong>应该是在这个地址中写入了原来<code>_myView</code>指向的地址，然后对新<code>_myView</code>指向的地址和Watchpoint指向的地址是否相同来做出判断的。</p>\n<h4 id=\"disable-delete-enable\"><a href=\"#disable-delete-enable\" class=\"headerlink\" title=\"disable/delete/enable\"></a>disable/delete/enable</h4><p>watchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true\" alt=\"watchpoint3\"></p>\n<h2 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h2><h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>这是我比较喜欢的方法，所以单独列出来。</p>\n<p>调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入<code>run</code>就能直接让程序重新加载了。</p>\n<h3 id=\"通过地址操作\"><a href=\"#通过地址操作\" class=\"headerlink\" title=\"通过地址操作\"></a>通过地址操作</h3><p>比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。</p>\n<p>本来想要监控<code>self.view.backgroundColor</code>的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。</p>\n<p>因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。</p>\n<h3 id=\"代替NSLog\"><a href=\"#代替NSLog\" class=\"headerlink\" title=\"代替NSLog\"></a>代替NSLog</h3><p>看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的<code>debug log</code>的，而是<code>error log</code>；每次<code>NSLog</code>都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。</p>\n","excerpt":"<p>偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章<a href=\"https://objccn.io/issue-19-2/\">与调试器共舞 - LLDB 的华尔兹</a>这篇文章帮助最大。</p>","more":"<p>Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。</p>\n<p>LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：</p>\n<ol>\n<li>断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态</li>\n<li>直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序</li>\n</ol>\n<p>不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。</p>\n<h2 id=\"expression\"><a href=\"#expression\" class=\"headerlink\" title=\"expression\"></a>expression</h2><p>expression的几个命令是最常用的，能提升debug效率的命令。</p>\n<h3 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print\"></a>print</h3><p>打印一个对象:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true\" alt=\"print\"><br>可以直接缩写<code>p</code>达到同样的效果。</p>\n<p>结果中有个<code>$0</code>，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以<code>$</code>开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true\" alt=\"print2\"></p>\n<h3 id=\"expression-1\"><a href=\"#expression-1\" class=\"headerlink\" title=\"expression\"></a>expression</h3><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>如果想要改变一个值，或者执行一个方法。可以使用<code>expression</code>或者<code>e</code>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true\" alt=\"expression\"></p>\n<p>print其实是特殊的expression，比如<code>p count =18</code>其结果和<code>expression count = 18</code>结果一样。事实上，<code>print</code>是 <code>expression --</code> 的缩写。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>由于<code>expression</code>可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 改变颜色</span></div><div class=\"line\">(lldb) expression <span class=\"keyword\">self</span>.view.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor]</div><div class=\"line\"><span class=\"comment\">// 刷新界面</span></div><div class=\"line\">(lldb) expression [<span class=\"built_in\">CATransaction</span> flush]</div></pre></td></tr></table></figure></p>\n<p>不只是改变颜色，frame，animation等都能改变，非常有用。</p>\n<p>如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。</p>\n<h3 id=\"po\"><a href=\"#po\" class=\"headerlink\" title=\"po\"></a>po</h3><p><code>print</code>输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) p @[ <span class=\"string\">@\"foo\"</span>, <span class=\"string\">@\"bar\"</span> ]</div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">NSArray</span> *) $<span class=\"number\">8</span> = <span class=\"number\">0x00007fdb9b71b3e0</span> <span class=\"string\">@\"2 objects\"</span></div></pre></td></tr></table></figure></p>\n<p>这个时候可以使用<code>po</code>(print object 的缩写)，相当于调用对象的<code>description</code>方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) po $<span class=\"number\">8</span></div><div class=\"line\">&lt;__NSArrayI <span class=\"number\">0x7fdb9b71b3e0</span>&gt;(</div><div class=\"line\">foo,</div><div class=\"line\">bar</div><div class=\"line\">)</div><div class=\"line\">(lldb) po <span class=\"string\">@\"lunar\"</span></div><div class=\"line\">lunar</div></pre></td></tr></table></figure></p>\n<h2 id=\"thread\"><a href=\"#thread\" class=\"headerlink\" title=\"thread\"></a>thread</h2><h3 id=\"bt\"><a href=\"#bt\" class=\"headerlink\" title=\"bt\"></a>bt</h3><p>可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true\" alt=\"frame\"></p>\n<h3 id=\"thread-return\"><a href=\"#thread-return\" class=\"headerlink\" title=\"thread return\"></a>thread return</h3><p>这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。</p>\n<p>它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后<strong>立刻执行返回命令，跳出当前栈帧</strong>。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是<strong>在函数的开头执行这个命令</strong>，是个非常好的隔离这个函数，伪造返回值的方式 。</p>\n<p>比如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true\" alt=\"return\"><br>正常通过<code>isOdd</code>方法，一定是<code>return NO</code>的，但是通过<code>(lldb) thread return YES</code>，跳过了<code>isOdd</code>方法里的方法块，直接<code>return YES</code></p>\n<p>正如上面所述，必须要在断点进行到如图所示的地方才可以使用<code>thread return</code>，因为:</p>\n<ol>\n<li>此时当前栈帧是<code>isOdd</code></li>\n<li>不会造成引用问题</li>\n</ol>\n<h2 id=\"breakpoint\"><a href=\"#breakpoint\" class=\"headerlink\" title=\"breakpoint\"></a>breakpoint</h2><p>断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.</p>\n<h3 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h3><p>当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true\" alt=\"debug\"><br>意义都很明确，不多说了，列举下对应的命令：</p>\n<ol>\n<li>continue按钮 =&gt; <code>continue</code>,缩写<code>c</code></li>\n<li>step over按钮 =&gt; <code>next</code>，缩写<code>n</code></li>\n<li>step in按钮 =&gt; <code>step</code>,缩写<code>s</code></li>\n<li>step out按钮 =&gt; <code>finish</code></li>\n</ol>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><p>在断点处右击，选择<code>Edit Breakpoint</code>弹出如下设置框：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true\" alt=\"breakpoint\"></p>\n<h4 id=\"蓝色的勾\"><a href=\"#蓝色的勾\" class=\"headerlink\" title=\"蓝色的勾\"></a>蓝色的勾</h4><p>表示enable和disable断点。</p>\n<h4 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h4><p>指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，<strong>不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法</strong>）。</p>\n<h4 id=\"Ignore\"><a href=\"#Ignore\" class=\"headerlink\" title=\"Ignore\"></a>Ignore</h4><p>忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。</p>\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true\" alt=\"menu\"><br>默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：</p>\n<ol>\n<li><strong>Debugger Command</strong>：默认的选项，可以让断点执行LLDB调试命令。</li>\n<li><strong>Log Message</strong>：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用<code>@exp@</code>形式。</li>\n</ol>\n<h4 id=\"Options\"><a href=\"#Options\" class=\"headerlink\" title=\"Options\"></a>Options</h4><p>一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。</p>\n<h3 id=\"断点类型\"><a href=\"#断点类型\" class=\"headerlink\" title=\"断点类型\"></a>断点类型</h3><h4 id=\"异常断点\"><a href=\"#异常断点\" class=\"headerlink\" title=\"异常断点\"></a>异常断点</h4><p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true\" alt=\"exception\"></p>\n<h4 id=\"符号断点\"><a href=\"#符号断点\" class=\"headerlink\" title=\"符号断点\"></a>符号断点</h4><p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true\" alt=\"exception\"></p>\n<p>它比普通断点的自定义设置界面多出了两个内容</p>\n<ul>\n<li><p><strong>Symbol</strong>：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[MyViewController viewDidAppear:]</div><div class=\"line\">+[MyViewController sharedInstance]</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Module</strong>：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>\n</li>\n</ul>\n<p>需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。</p>\n<h3 id=\"watchpoint\"><a href=\"#watchpoint\" class=\"headerlink\" title=\"watchpoint\"></a>watchpoint</h3><p>有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用<code>watchpoin</code>t来监视一个指针的指向。</p>\n<p>当指针指向变化时，<code>watchpoint</code>会触发:<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true\" alt=\"watchpoint\"></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>添加watchpoint的方式如上图所示<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(lldb) watchpoint set variable xxx</div></pre></td></tr></table></figure></p>\n<p>这里要说明一下，watchpoint要监听的对象必须是<strong>当前类的对象</strong>：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true\" alt=\"watchpoint2\"><br>由于<code>self.view</code>是从<code>UIViewController</code>中继承过来的，因此无法监听。</p>\n<p>另外，上面的<code>addr = 0x1556747f0</code><strong>不是指<code>_myView</code>在栈中的索引</strong>，而是指这个Watchpoint在堆中的地址。</p>\n<p>Watchpoint的<strong>原理</strong>应该是在这个地址中写入了原来<code>_myView</code>指向的地址，然后对新<code>_myView</code>指向的地址和Watchpoint指向的地址是否相同来做出判断的。</p>\n<h4 id=\"disable-delete-enable\"><a href=\"#disable-delete-enable\" class=\"headerlink\" title=\"disable/delete/enable\"></a>disable/delete/enable</h4><p>watchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true\" alt=\"watchpoint3\"></p>\n<h2 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h2><h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>这是我比较喜欢的方法，所以单独列出来。</p>\n<p>调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入<code>run</code>就能直接让程序重新加载了。</p>\n<h3 id=\"通过地址操作\"><a href=\"#通过地址操作\" class=\"headerlink\" title=\"通过地址操作\"></a>通过地址操作</h3><p>比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。</p>\n<p>本来想要监控<code>self.view.backgroundColor</code>的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。</p>\n<p>因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。</p>\n<h3 id=\"代替NSLog\"><a href=\"#代替NSLog\" class=\"headerlink\" title=\"代替NSLog\"></a>代替NSLog</h3><p>看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的<code>debug log</code>的，而是<code>error log</code>；每次<code>NSLog</code>都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。</p>"},{"title":"objective-c 学习笔记","date":"2016-07-31T02:07:12.000Z","_content":"\n开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。\n\n<!--more-->\n\n### 函数\n函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。\n\n### 全局变量\n在函数外声明的变量，只要类被import就能使用。  \nJava中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。  \n为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。  \n**那么这和@property有什么区别？**静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。\n\n### 指针\n&表示取地址，*表示取值。  \n空指针用nil而不是null。\n\n### 结构\n使用结构保存多个相关数据。\n```objc\nstruct Person{\n\tfloat height；\n\tint age；\n}；\n```\n使用：`struct Person mikey；`  \n使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。\n```objc\ntypedef struct {\n\tfloat height；\n\tint age；\n} Person；\n```\n使用：`Person mikey；`\n\n### 获取结构中的属性：\n当结构的使用者是一个指针时，使用->表示先获取指针p指向的数据结构，然后返回该结构的成员变量。  \n当结构的使用者是一个实例时，使用.表示访问属性。\n\n### id %@\nid表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。\nInstanceType表示方法的返回类型。  \n%@表示占位符，代表指针，会向相应指针变量对象发送description消息。\n\n### NSString\n@“…”表示创建一个NSString对象。需要知道字符串完整内容。  \n也可使用stringWithFormat方法动态创建：\n```objc\nNSString *dateString = [NSString stringWithFormat:@“The date is %@”, now]\n```\n\n### NSArray\n创建：\n```objc\nNSArray *dateList = @[now, tomorrow ,yesterday];\n```\nNSArray是无法改变的，被创建后无法添加删除以及改变顺序。  \n快速遍历数组： \n```objc\nfor(NSDate *d in daeList){}\n```\n\n### NSMutableArray\n可变数组，可添加删除和修改顺序。  \ninsertObject：atIndex在指定位置插入  \nremoveObject：atIndex删除数组中对象  \n快速遍历时不能添加删除数组内数据。\n\n### 自定义一个类\n头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始\n取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。\n\n### self\nself是指针，指向运行当前方法的对象。\n\n### 属性\n属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。  \n使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。\n\n### 继承\nNSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。\n\n### @class\n一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.  \n如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB\n\n### 类拓展\n类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。\n```objc\n\t#import “BNREmployee.h”\n\t@interface BNREmployee()\t\n\t@property (nonatomic) unsigned int officeAlarmCode;\n\t@end\n```\n注意要有括号，写在implement前面。  \n头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。\n\n### 弱引用\n通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。\n\n### Collection类\nNSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。  \nNSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。  \nNSMutable是NS的子类。  \ncollection不能保存nil。如果要保存nil则要保存NSNull类的实例。\n```objc\n[hotel addObject:[NSNull null]];\n```\n\n### 常量\n可以通过两种途径定义常量，#define和全局变量。  \n1. #define A B 告诉编译器看到A用B替换\n2. extern NSString const *NSLocaleCurrencyCode；  \nconst表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义\n\n### #include和#import\nimport会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。\n\n\n\n### 协议\n协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。  \nUITableView数据源协议是UITableViewDataSource，方法声明如下：\n```objc\n@protocal UITableViewDataSource<NSObject>\n@required\n- (NSInteger)tableView:(UITableView *)tv\n\tnumberOfRowsInSection:(NSInteger) section;\n@optional\n……. \n```\n\n### 范畴\n通过范畴（category）可以为任何已有的类添加方法。  \n创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。  \n打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。\n声明示例：NSString+MD5.h\n```objc\n@interface NSString (MD5)\n+ (NSString *)md5:(NSString *)originalStr;\n@end\n```\n\n\n","source":"_posts/objectice-c.md","raw":"title: objective-c 学习笔记\ndate: 2016/7/31 10:07:12  \ncategories: IOS\ntags:\n\t- Objective-C\n\t- 学习笔记\n\n---\n\n开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。\n\n<!--more-->\n\n### 函数\n函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。\n\n### 全局变量\n在函数外声明的变量，只要类被import就能使用。  \nJava中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。  \n为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。  \n**那么这和@property有什么区别？**静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。\n\n### 指针\n&表示取地址，*表示取值。  \n空指针用nil而不是null。\n\n### 结构\n使用结构保存多个相关数据。\n```objc\nstruct Person{\n\tfloat height；\n\tint age；\n}；\n```\n使用：`struct Person mikey；`  \n使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。\n```objc\ntypedef struct {\n\tfloat height；\n\tint age；\n} Person；\n```\n使用：`Person mikey；`\n\n### 获取结构中的属性：\n当结构的使用者是一个指针时，使用->表示先获取指针p指向的数据结构，然后返回该结构的成员变量。  \n当结构的使用者是一个实例时，使用.表示访问属性。\n\n### id %@\nid表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。\nInstanceType表示方法的返回类型。  \n%@表示占位符，代表指针，会向相应指针变量对象发送description消息。\n\n### NSString\n@“…”表示创建一个NSString对象。需要知道字符串完整内容。  \n也可使用stringWithFormat方法动态创建：\n```objc\nNSString *dateString = [NSString stringWithFormat:@“The date is %@”, now]\n```\n\n### NSArray\n创建：\n```objc\nNSArray *dateList = @[now, tomorrow ,yesterday];\n```\nNSArray是无法改变的，被创建后无法添加删除以及改变顺序。  \n快速遍历数组： \n```objc\nfor(NSDate *d in daeList){}\n```\n\n### NSMutableArray\n可变数组，可添加删除和修改顺序。  \ninsertObject：atIndex在指定位置插入  \nremoveObject：atIndex删除数组中对象  \n快速遍历时不能添加删除数组内数据。\n\n### 自定义一个类\n头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始\n取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。\n\n### self\nself是指针，指向运行当前方法的对象。\n\n### 属性\n属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。  \n使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。\n\n### 继承\nNSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。\n\n### @class\n一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.  \n如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB\n\n### 类拓展\n类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。\n```objc\n\t#import “BNREmployee.h”\n\t@interface BNREmployee()\t\n\t@property (nonatomic) unsigned int officeAlarmCode;\n\t@end\n```\n注意要有括号，写在implement前面。  \n头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。\n\n### 弱引用\n通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。\n\n### Collection类\nNSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。  \nNSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。  \nNSMutable是NS的子类。  \ncollection不能保存nil。如果要保存nil则要保存NSNull类的实例。\n```objc\n[hotel addObject:[NSNull null]];\n```\n\n### 常量\n可以通过两种途径定义常量，#define和全局变量。  \n1. #define A B 告诉编译器看到A用B替换\n2. extern NSString const *NSLocaleCurrencyCode；  \nconst表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义\n\n### #include和#import\nimport会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。\n\n\n\n### 协议\n协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。  \nUITableView数据源协议是UITableViewDataSource，方法声明如下：\n```objc\n@protocal UITableViewDataSource<NSObject>\n@required\n- (NSInteger)tableView:(UITableView *)tv\n\tnumberOfRowsInSection:(NSInteger) section;\n@optional\n……. \n```\n\n### 范畴\n通过范畴（category）可以为任何已有的类添加方法。  \n创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。  \n打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。\n声明示例：NSString+MD5.h\n```objc\n@interface NSString (MD5)\n+ (NSString *)md5:(NSString *)originalStr;\n@end\n```\n\n\n","slug":"objectice-c","published":1,"updated":"2016-09-23T05:52:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxd0029rgruobw5o3t6","content":"<p>开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。</p>\n<a id=\"more\"></a>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数外声明的变量，只要类被import就能使用。<br>Java中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。<br>为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。<br><strong>那么这和@property有什么区别？</strong>静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;表示取地址，*表示取值。<br>空指针用nil而不是null。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>使用结构保存多个相关数据。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125;；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>struct Person mikey；</code><br>使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125; Person；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>Person mikey；</code></p>\n<h3 id=\"获取结构中的属性：\"><a href=\"#获取结构中的属性：\" class=\"headerlink\" title=\"获取结构中的属性：\"></a>获取结构中的属性：</h3><p>当结构的使用者是一个指针时，使用-&gt;表示先获取指针p指向的数据结构，然后返回该结构的成员变量。<br>当结构的使用者是一个实例时，使用.表示访问属性。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id %@\"></a>id %@</h3><p>id表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。<br>InstanceType表示方法的返回类型。<br>%@表示占位符，代表指针，会向相应指针变量对象发送description消息。</p>\n<h3 id=\"NSString\"><a href=\"#NSString\" class=\"headerlink\" title=\"NSString\"></a>NSString</h3><p>@“…”表示创建一个NSString对象。需要知道字符串完整内容。<br>也可使用stringWithFormat方法动态创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *dateString = [<span class=\"built_in\">NSString</span> stringWithFormat:@“The date is %@”, now]</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSArray\"><a href=\"#NSArray\" class=\"headerlink\" title=\"NSArray\"></a>NSArray</h3><p>创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *dateList = @[now, tomorrow ,yesterday];</div></pre></td></tr></table></figure></p>\n<p>NSArray是无法改变的，被创建后无法添加删除以及改变顺序。<br>快速遍历数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">NSDate</span> *d <span class=\"keyword\">in</span> daeList)&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSMutableArray\"><a href=\"#NSMutableArray\" class=\"headerlink\" title=\"NSMutableArray\"></a>NSMutableArray</h3><p>可变数组，可添加删除和修改顺序。<br>insertObject：atIndex在指定位置插入<br>removeObject：atIndex删除数组中对象<br>快速遍历时不能添加删除数组内数据。</p>\n<h3 id=\"自定义一个类\"><a href=\"#自定义一个类\" class=\"headerlink\" title=\"自定义一个类\"></a>自定义一个类</h3><p>头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始<br>取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。</p>\n<h3 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h3><p>self是指针，指向运行当前方法的对象。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。<br>使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>NSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"@class\"></a>@class</h3><p>一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.<br>如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB</p>\n<h3 id=\"类拓展\"><a href=\"#类拓展\" class=\"headerlink\" title=\"类拓展\"></a>类拓展</h3><p>类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import “BNREmployee.h”</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNREmployee</span>()\t</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> officeAlarmCode;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意要有括号，写在implement前面。<br>头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。</p>\n<h3 id=\"Collection类\"><a href=\"#Collection类\" class=\"headerlink\" title=\"Collection类\"></a>Collection类</h3><p>NSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。<br>NSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。<br>NSMutable是NS的子类。<br>collection不能保存nil。如果要保存nil则要保存NSNull类的实例。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[hotel addObject:[<span class=\"built_in\">NSNull</span> null]];</div></pre></td></tr></table></figure></p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>可以通过两种途径定义常量，#define和全局变量。  </p>\n<ol>\n<li>#define A B 告诉编译器看到A用B替换</li>\n<li>extern NSString const *NSLocaleCurrencyCode；<br>const表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>\n</ol>\n<h3 id=\"include和-import\"><a href=\"#include和-import\" class=\"headerlink\" title=\"#include和#import\"></a>#include和#import</h3><p>import会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。<br>UITableView数据源协议是UITableViewDataSource，方法声明如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocal <span class=\"built_in\">UITableViewDataSource</span>&lt;<span class=\"built_in\">NSObject</span>&gt;</div><div class=\"line\"><span class=\"keyword\">@required</span></div><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tv</div><div class=\"line\">\tnumberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>) section;</div><div class=\"line\"><span class=\"keyword\">@optional</span></div><div class=\"line\">…….</div></pre></td></tr></table></figure></p>\n<h3 id=\"范畴\"><a href=\"#范畴\" class=\"headerlink\" title=\"范畴\"></a>范畴</h3><p>通过范畴（category）可以为任何已有的类添加方法。<br>创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。<br>打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。<br>声明示例：NSString+MD5.h<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">MD5</span>)</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)md5:(<span class=\"built_in\">NSString</span> *)originalStr;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n","excerpt":"<p>开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。</p>","more":"<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>在函数外声明的变量，只要类被import就能使用。<br>Java中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。<br>为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。<br><strong>那么这和@property有什么区别？</strong>静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;表示取地址，*表示取值。<br>空指针用nil而不是null。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>使用结构保存多个相关数据。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Person&#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125;；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>struct Person mikey；</code><br>使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">float</span> height；</div><div class=\"line\">\t<span class=\"keyword\">int</span> age；</div><div class=\"line\">&#125; Person；</div></pre></td></tr></table></figure></p>\n<p>使用：<code>Person mikey；</code></p>\n<h3 id=\"获取结构中的属性：\"><a href=\"#获取结构中的属性：\" class=\"headerlink\" title=\"获取结构中的属性：\"></a>获取结构中的属性：</h3><p>当结构的使用者是一个指针时，使用-&gt;表示先获取指针p指向的数据结构，然后返回该结构的成员变量。<br>当结构的使用者是一个实例时，使用.表示访问属性。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id %@\"></a>id %@</h3><p>id表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。<br>InstanceType表示方法的返回类型。<br>%@表示占位符，代表指针，会向相应指针变量对象发送description消息。</p>\n<h3 id=\"NSString\"><a href=\"#NSString\" class=\"headerlink\" title=\"NSString\"></a>NSString</h3><p>@“…”表示创建一个NSString对象。需要知道字符串完整内容。<br>也可使用stringWithFormat方法动态创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSString</span> *dateString = [<span class=\"built_in\">NSString</span> stringWithFormat:@“The date is %@”, now]</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSArray\"><a href=\"#NSArray\" class=\"headerlink\" title=\"NSArray\"></a>NSArray</h3><p>创建：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">NSArray</span> *dateList = @[now, tomorrow ,yesterday];</div></pre></td></tr></table></figure></p>\n<p>NSArray是无法改变的，被创建后无法添加删除以及改变顺序。<br>快速遍历数组：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"built_in\">NSDate</span> *d <span class=\"keyword\">in</span> daeList)&#123;&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"NSMutableArray\"><a href=\"#NSMutableArray\" class=\"headerlink\" title=\"NSMutableArray\"></a>NSMutableArray</h3><p>可变数组，可添加删除和修改顺序。<br>insertObject：atIndex在指定位置插入<br>removeObject：atIndex删除数组中对象<br>快速遍历时不能添加删除数组内数据。</p>\n<h3 id=\"自定义一个类\"><a href=\"#自定义一个类\" class=\"headerlink\" title=\"自定义一个类\"></a>自定义一个类</h3><p>头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始<br>取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。</p>\n<h3 id=\"self\"><a href=\"#self\" class=\"headerlink\" title=\"self\"></a>self</h3><p>self是指针，指向运行当前方法的对象。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。<br>使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>NSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"@class\"></a>@class</h3><p>一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.<br>如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB</p>\n<h3 id=\"类拓展\"><a href=\"#类拓展\" class=\"headerlink\" title=\"类拓展\"></a>类拓展</h3><p>类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import “BNREmployee.h”</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNREmployee</span>()\t</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> officeAlarmCode;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>注意要有括号，写在implement前面。<br>头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。</p>\n<h3 id=\"Collection类\"><a href=\"#Collection类\" class=\"headerlink\" title=\"Collection类\"></a>Collection类</h3><p>NSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。<br>NSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。<br>NSMutable是NS的子类。<br>collection不能保存nil。如果要保存nil则要保存NSNull类的实例。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[hotel addObject:[<span class=\"built_in\">NSNull</span> null]];</div></pre></td></tr></table></figure></p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>可以通过两种途径定义常量，#define和全局变量。  </p>\n<ol>\n<li>#define A B 告诉编译器看到A用B替换</li>\n<li>extern NSString const *NSLocaleCurrencyCode；<br>const表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>\n</ol>\n<h3 id=\"include和-import\"><a href=\"#include和-import\" class=\"headerlink\" title=\"#include和#import\"></a>#include和#import</h3><p>import会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。<br>UITableView数据源协议是UITableViewDataSource，方法声明如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocal <span class=\"built_in\">UITableViewDataSource</span>&lt;<span class=\"built_in\">NSObject</span>&gt;</div><div class=\"line\"><span class=\"keyword\">@required</span></div><div class=\"line\">- (<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> *)tv</div><div class=\"line\">\tnumberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>) section;</div><div class=\"line\"><span class=\"keyword\">@optional</span></div><div class=\"line\">…….</div></pre></td></tr></table></figure></p>\n<h3 id=\"范畴\"><a href=\"#范畴\" class=\"headerlink\" title=\"范畴\"></a>范畴</h3><p>通过范畴（category）可以为任何已有的类添加方法。<br>创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。<br>打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。<br>声明示例：NSString+MD5.h<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSString</span> (<span class=\"title\">MD5</span>)</span></div><div class=\"line\">+ (<span class=\"built_in\">NSString</span> *)md5:(<span class=\"built_in\">NSString</span> *)originalStr;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>"},{"title":"移位与枚举","date":"2016-09-07T02:07:12.000Z","_content":"\noc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（<<）来定义枚举的值，其原因是什么呢？\n\n<!--more-->\n## enum的基本用法使用\n定义一组常量。\n```objc\ntypedef enum{\n\tBlenderSpeedStir=1，\n\tBlenderSpeedChop=1<<1，\n} BlenderSpeed；\n```\n\n还可以写成这样：\n```objc\ntypedef NS_ENUM(NSInteger, BlenderSpeed) {\n//以下是枚举成员\n    Test1A = 1,\n    Test1B = 1<<1,\n    Test1C = 1<<2,\n    Test1D = 1<<3\n};\n```\n使用： \n```\nBlenderSpeed speed = Test1A；\n```\n使用`BlenderSpeed`代替`NSInteger`。\n\n\n## 移位定义enum\n### 使用移位定义enum的好处\nenum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：**用移位来定义枚举能把1的位置错开，可以使用`按位或`将几个枚举值表示成一个数，而不会互相影响**。如果用数字就要使用一个数组。\n\n比如：\n```objc\n[UIView animateWithDuration:1 delay:0 options:UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat animations:^{\n\tnil\n} completion:^(BOOL finished) {\n\tnil;\n}];\n```\n\n其中`options`只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入`UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat`表示既`FlipFromRight`又`repeat`。\n\n### 取出enum值\n将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下`按位与&`操作符的特性：\n\n>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。\n所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。\n\n因此，我们可以这样取出枚举值：\n```objc\ntypedef enum{\n    a = 1 << 0,\n    b = 1 << 1,\n    c = 1 << 2,\n    d = 1 << 3\n}testEnum;\n\ntestEnum e = a | b;\n\nif (e & a) {\n    printf(\"满足条件a\");\n    //满足a要做的事\n}\nif (e & b) {\n    printf(\"满足条件b\");\n    //满足b要做的事\n}\nif (e & c) {\n    printf(\"满足条件c\");\n    //满足c要做的事\n}\n```\n将数值与各个枚举值按位与，非零即包含该枚举值。\n\n也可以通过一个for循环，再通过switch-case处理：\n```objc\ntypedef NS_ENUM(NSInteger, AnimationType) {\n    //以下是枚举成员\n    BaseAnimation = 1,\n    KeyFrameAnimation_Value = 1<<1,\n    KeyFrameAnimation_Path = 1<<2,\n    KeyFrameAnimation_shake = 1<<3,\n    Transition = 1<<4,\n    AnimationGroup = 1<<5,\n    ViewAnimation = 1<<6\n};\n\n- (void)initAnimationWithType:(NSInteger)type{\n    for (NSInteger animationType = 1; animationType<(ViewAnimation<<1); animationType = animationType<<1) {\n        if (type & animationType) {\n            [self startAnimationInitialWithType:animationType];\n        }\n    }\n}\n\n- (void)startAnimationInitialWithType:(NSInteger)type{\n    \n    switch (type) {\n        case BaseAnimation:{\n            CALayer *myLayer=[CALayer layer];\n            myLayer.bounds=CGRectMake(0, 0, 50, 80);\n            myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n            myLayer.position=CGPointMake(50, 50);\n            myLayer.anchorPoint=CGPointMake(0, 0);\n            myLayer.cornerRadius=20;\n            //添加layer\n            [self.view.layer addSublayer:myLayer];\n            self.myLayer=myLayer;\n        }\n            break;\n        case Transition:\n            _index = 1;\n            break;\n        default:\n            break;\n    }\n}\n```\n\n**需要注意的是**：`case`中如果声明了变量，必须要用`{}`包住，这是编译器强制的，不然会报错，应该是为了避免[switch case语句里面不能定义对象，有语法错误，除非加一个花括号](http://blog.csdn.net/fanjunxi1990/article/details/9162945)这个问题。\n\n### 引申\n上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。\n比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：\n```objc\n\ntypedef enum{\n    a = 0 << 0,\n    b = 1 << 0,\n    c = 2 << 0,\n    d = 3 << 0,\n\n    e = 0 << 4,\n    f = 1 << 4,\n    g = 2 << 4,\n    h = 3 << 4\n}testEnum;\n```\n\na b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和`00001111`按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与`11110000`按位与得到另外一组。\n\n>Demo详见CALayer_Transform\n","source":"_posts/oc中的枚举.md","raw":"title: 移位与枚举\ndate: 2016/9/7 10:07:12  \ncategories: IOS\ntags:\n\t- Objective-C\n\n---\n\noc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（<<）来定义枚举的值，其原因是什么呢？\n\n<!--more-->\n## enum的基本用法使用\n定义一组常量。\n```objc\ntypedef enum{\n\tBlenderSpeedStir=1，\n\tBlenderSpeedChop=1<<1，\n} BlenderSpeed；\n```\n\n还可以写成这样：\n```objc\ntypedef NS_ENUM(NSInteger, BlenderSpeed) {\n//以下是枚举成员\n    Test1A = 1,\n    Test1B = 1<<1,\n    Test1C = 1<<2,\n    Test1D = 1<<3\n};\n```\n使用： \n```\nBlenderSpeed speed = Test1A；\n```\n使用`BlenderSpeed`代替`NSInteger`。\n\n\n## 移位定义enum\n### 使用移位定义enum的好处\nenum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：**用移位来定义枚举能把1的位置错开，可以使用`按位或`将几个枚举值表示成一个数，而不会互相影响**。如果用数字就要使用一个数组。\n\n比如：\n```objc\n[UIView animateWithDuration:1 delay:0 options:UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat animations:^{\n\tnil\n} completion:^(BOOL finished) {\n\tnil;\n}];\n```\n\n其中`options`只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入`UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat`表示既`FlipFromRight`又`repeat`。\n\n### 取出enum值\n将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下`按位与&`操作符的特性：\n\n>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。\n所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。\n\n因此，我们可以这样取出枚举值：\n```objc\ntypedef enum{\n    a = 1 << 0,\n    b = 1 << 1,\n    c = 1 << 2,\n    d = 1 << 3\n}testEnum;\n\ntestEnum e = a | b;\n\nif (e & a) {\n    printf(\"满足条件a\");\n    //满足a要做的事\n}\nif (e & b) {\n    printf(\"满足条件b\");\n    //满足b要做的事\n}\nif (e & c) {\n    printf(\"满足条件c\");\n    //满足c要做的事\n}\n```\n将数值与各个枚举值按位与，非零即包含该枚举值。\n\n也可以通过一个for循环，再通过switch-case处理：\n```objc\ntypedef NS_ENUM(NSInteger, AnimationType) {\n    //以下是枚举成员\n    BaseAnimation = 1,\n    KeyFrameAnimation_Value = 1<<1,\n    KeyFrameAnimation_Path = 1<<2,\n    KeyFrameAnimation_shake = 1<<3,\n    Transition = 1<<4,\n    AnimationGroup = 1<<5,\n    ViewAnimation = 1<<6\n};\n\n- (void)initAnimationWithType:(NSInteger)type{\n    for (NSInteger animationType = 1; animationType<(ViewAnimation<<1); animationType = animationType<<1) {\n        if (type & animationType) {\n            [self startAnimationInitialWithType:animationType];\n        }\n    }\n}\n\n- (void)startAnimationInitialWithType:(NSInteger)type{\n    \n    switch (type) {\n        case BaseAnimation:{\n            CALayer *myLayer=[CALayer layer];\n            myLayer.bounds=CGRectMake(0, 0, 50, 80);\n            myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n            myLayer.position=CGPointMake(50, 50);\n            myLayer.anchorPoint=CGPointMake(0, 0);\n            myLayer.cornerRadius=20;\n            //添加layer\n            [self.view.layer addSublayer:myLayer];\n            self.myLayer=myLayer;\n        }\n            break;\n        case Transition:\n            _index = 1;\n            break;\n        default:\n            break;\n    }\n}\n```\n\n**需要注意的是**：`case`中如果声明了变量，必须要用`{}`包住，这是编译器强制的，不然会报错，应该是为了避免[switch case语句里面不能定义对象，有语法错误，除非加一个花括号](http://blog.csdn.net/fanjunxi1990/article/details/9162945)这个问题。\n\n### 引申\n上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。\n比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：\n```objc\n\ntypedef enum{\n    a = 0 << 0,\n    b = 1 << 0,\n    c = 2 << 0,\n    d = 3 << 0,\n\n    e = 0 << 4,\n    f = 1 << 4,\n    g = 2 << 4,\n    h = 3 << 4\n}testEnum;\n```\n\na b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和`00001111`按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与`11110000`按位与得到另外一组。\n\n>Demo详见CALayer_Transform\n","slug":"oc中的枚举","published":1,"updated":"2016-09-23T05:46:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxf002crgruokqadd1g","content":"<p>oc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（&lt;&lt;）来定义枚举的值，其原因是什么呢？</p>\n<a id=\"more\"></a>\n<h2 id=\"enum的基本用法使用\"><a href=\"#enum的基本用法使用\" class=\"headerlink\" title=\"enum的基本用法使用\"></a>enum的基本用法使用</h2><p>定义一组常量。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">\tBlenderSpeedStir=<span class=\"number\">1</span>，</div><div class=\"line\">\tBlenderSpeedChop=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>，</div><div class=\"line\">&#125; BlenderSpeed；</div></pre></td></tr></table></figure></p>\n<p>还可以写成这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, BlenderSpeed) &#123;</div><div class=\"line\"><span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    Test1A = <span class=\"number\">1</span>,</div><div class=\"line\">    Test1B = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    Test1C = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    Test1D = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">BlenderSpeed speed = Test1A；</div></pre></td></tr></table></figure></p>\n<p>使用<code>BlenderSpeed</code>代替<code>NSInteger</code>。</p>\n<h2 id=\"移位定义enum\"><a href=\"#移位定义enum\" class=\"headerlink\" title=\"移位定义enum\"></a>移位定义enum</h2><h3 id=\"使用移位定义enum的好处\"><a href=\"#使用移位定义enum的好处\" class=\"headerlink\" title=\"使用移位定义enum的好处\"></a>使用移位定义enum的好处</h3><p>enum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：<strong>用移位来定义枚举能把1的位置错开，可以使用<code>按位或</code>将几个枚举值表示成一个数，而不会互相影响</strong>。如果用数字就要使用一个数组。</p>\n<p>比如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1</span> delay:<span class=\"number\">0</span> options:<span class=\"built_in\">UIViewAnimationOptionTransitionFlipFromRight</span> |<span class=\"built_in\">UIViewAnimationOptionRepeat</span> animations:^&#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span></div><div class=\"line\">&#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>其中<code>options</code>只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入<code>UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat</code>表示既<code>FlipFromRight</code>又<code>repeat</code>。</p>\n<h3 id=\"取出enum值\"><a href=\"#取出enum值\" class=\"headerlink\" title=\"取出enum值\"></a>取出enum值</h3><p>将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下<code>按位与&amp;</code>操作符的特性：</p>\n<blockquote>\n<p>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。<br>所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。</p>\n</blockquote>\n<p>因此，我们可以这样取出枚举值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    c = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    d = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;testEnum;</div><div class=\"line\"></div><div class=\"line\">testEnum e = a | b;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; a) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件a\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足a要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; b) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件b\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足b要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; c) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件c\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足c要做的事</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将数值与各个枚举值按位与，非零即包含该枚举值。</p>\n<p>也可以通过一个for循环，再通过switch-case处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, AnimationType) &#123;</div><div class=\"line\">    <span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    BaseAnimation = <span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Value = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Path = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    KeyFrameAnimation_shake = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">    Transition = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>,</div><div class=\"line\">    AnimationGroup = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>,</div><div class=\"line\">    ViewAnimation = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)initAnimationWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> animationType = <span class=\"number\">1</span>; animationType&lt;(ViewAnimation&lt;&lt;<span class=\"number\">1</span>); animationType = animationType&lt;&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (type &amp; animationType) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> startAnimationInitialWithType:animationType];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startAnimationInitialWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseAnimation:&#123;</div><div class=\"line\">            <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">            myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">            myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">            myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">            myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">            myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">            <span class=\"comment\">//添加layer</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">            <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> Transition:</div><div class=\"line\">            _index = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是</strong>：<code>case</code>中如果声明了变量，必须要用<code>{}</code>包住，这是编译器强制的，不然会报错，应该是为了避免<a href=\"http://blog.csdn.net/fanjunxi1990/article/details/9162945\" target=\"_blank\" rel=\"external\">switch case语句里面不能定义对象，有语法错误，除非加一个花括号</a>这个问题。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。<br>比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    c = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    d = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\"></div><div class=\"line\">    e = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    f = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    g = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    h = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">4</span></div><div class=\"line\">&#125;testEnum;</div></pre></td></tr></table></figure></p>\n<p>a b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和<code>00001111</code>按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与<code>11110000</code>按位与得到另外一组。</p>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>\n","excerpt":"<p>oc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（&lt;&lt;）来定义枚举的值，其原因是什么呢？</p>","more":"<h2 id=\"enum的基本用法使用\"><a href=\"#enum的基本用法使用\" class=\"headerlink\" title=\"enum的基本用法使用\"></a>enum的基本用法使用</h2><p>定义一组常量。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">\tBlenderSpeedStir=<span class=\"number\">1</span>，</div><div class=\"line\">\tBlenderSpeedChop=<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>，</div><div class=\"line\">&#125; BlenderSpeed；</div></pre></td></tr></table></figure></p>\n<p>还可以写成这样：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, BlenderSpeed) &#123;</div><div class=\"line\"><span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    Test1A = <span class=\"number\">1</span>,</div><div class=\"line\">    Test1B = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    Test1C = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    Test1D = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">BlenderSpeed speed = Test1A；</div></pre></td></tr></table></figure></p>\n<p>使用<code>BlenderSpeed</code>代替<code>NSInteger</code>。</p>\n<h2 id=\"移位定义enum\"><a href=\"#移位定义enum\" class=\"headerlink\" title=\"移位定义enum\"></a>移位定义enum</h2><h3 id=\"使用移位定义enum的好处\"><a href=\"#使用移位定义enum的好处\" class=\"headerlink\" title=\"使用移位定义enum的好处\"></a>使用移位定义enum的好处</h3><p>enum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：<strong>用移位来定义枚举能把1的位置错开，可以使用<code>按位或</code>将几个枚举值表示成一个数，而不会互相影响</strong>。如果用数字就要使用一个数组。</p>\n<p>比如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"built_in\">UIView</span> animateWithDuration:<span class=\"number\">1</span> delay:<span class=\"number\">0</span> options:<span class=\"built_in\">UIViewAnimationOptionTransitionFlipFromRight</span> |<span class=\"built_in\">UIViewAnimationOptionRepeat</span> animations:^&#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span></div><div class=\"line\">&#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">\t<span class=\"literal\">nil</span>;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure></p>\n<p>其中<code>options</code>只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入<code>UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat</code>表示既<code>FlipFromRight</code>又<code>repeat</code>。</p>\n<h3 id=\"取出enum值\"><a href=\"#取出enum值\" class=\"headerlink\" title=\"取出enum值\"></a>取出enum值</h3><p>将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下<code>按位与&amp;</code>操作符的特性：</p>\n<blockquote>\n<p>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。<br>所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。</p>\n</blockquote>\n<p>因此，我们可以这样取出枚举值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</div><div class=\"line\">    c = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</div><div class=\"line\">    d = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span></div><div class=\"line\">&#125;testEnum;</div><div class=\"line\"></div><div class=\"line\">testEnum e = a | b;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; a) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件a\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足a要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; b) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件b\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足b要做的事</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">if</span> (e &amp; c) &#123;</div><div class=\"line\">    printf(<span class=\"string\">\"满足条件c\"</span>);</div><div class=\"line\">    <span class=\"comment\">//满足c要做的事</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将数值与各个枚举值按位与，非零即包含该枚举值。</p>\n<p>也可以通过一个for循环，再通过switch-case处理：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, AnimationType) &#123;</div><div class=\"line\">    <span class=\"comment\">//以下是枚举成员</span></div><div class=\"line\">    BaseAnimation = <span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Value = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>,</div><div class=\"line\">    KeyFrameAnimation_Path = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>,</div><div class=\"line\">    KeyFrameAnimation_shake = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>,</div><div class=\"line\">    Transition = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>,</div><div class=\"line\">    AnimationGroup = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>,</div><div class=\"line\">    ViewAnimation = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)initAnimationWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> animationType = <span class=\"number\">1</span>; animationType&lt;(ViewAnimation&lt;&lt;<span class=\"number\">1</span>); animationType = animationType&lt;&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (type &amp; animationType) &#123;</div><div class=\"line\">            [<span class=\"keyword\">self</span> startAnimationInitialWithType:animationType];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)startAnimationInitialWithType:(<span class=\"built_in\">NSInteger</span>)type&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> BaseAnimation:&#123;</div><div class=\"line\">            <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">            myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">            myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">            myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">            myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">            myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">            <span class=\"comment\">//添加layer</span></div><div class=\"line\">            [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">            <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">        &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> Transition:</div><div class=\"line\">            _index = <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>需要注意的是</strong>：<code>case</code>中如果声明了变量，必须要用<code>{}</code>包住，这是编译器强制的，不然会报错，应该是为了避免<a href=\"http://blog.csdn.net/fanjunxi1990/article/details/9162945\">switch case语句里面不能定义对象，有语法错误，除非加一个花括号</a>这个问题。</p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。<br>比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</div><div class=\"line\">    a = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    b = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    c = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\">    d = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">0</span>,</div><div class=\"line\"></div><div class=\"line\">    e = <span class=\"number\">0</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    f = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    g = <span class=\"number\">2</span> &lt;&lt; <span class=\"number\">4</span>,</div><div class=\"line\">    h = <span class=\"number\">3</span> &lt;&lt; <span class=\"number\">4</span></div><div class=\"line\">&#125;testEnum;</div></pre></td></tr></table></figure></p>\n<p>a b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和<code>00001111</code>按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与<code>11110000</code>按位与得到另外一组。</p>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>"},{"title":"python 3.5 函数","date":"2016-08-07T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n### 调用函数\n#### 数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数\n\n#### 函数名\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”\n```python\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1\n```\n\n### 定义函数\n定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n```python\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.\n\n#### 空函数\n用pass语句定义一个什么事都不做的空函数，不用pass会报错。\n```python\ndef nop():\n    pass\n# 或者    \nif age >= 18:\n    pass\n```\n\n#### 返回多个值\n```python\nimport math\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n```\n\n得到返回值\n```python\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n```\n其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n### 函数的参数\n#### 默认参数\npython不支持重载，可以使用默认参数的方式替代。\n```python\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).\n\n但是需要注意：\n1. 必选参数在前，默认参数在后，否则Python的解释器会报错。**如果不按顺序提供参数时，需要写成 参数名=xx 的形式。**\n2. 默认参数必须指向不变对象。\n例如：\n```python\ndef add_end(L=[]):\n    L.append('END')\n    return L\n    \n>>> add_end()\n['END']\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n```\n当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。\n\n如果要默认是list，可以这么写：\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 可变参数\n通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n```\n**可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list**\n**不是可变参数的话，参数需要一一对应**\n\n如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：\n```python\n>>> nums = [1, 2, 3]\n>>> print(nums)\n[1, 2, 3]\n>>> print(*nums)\n1, 2, 3\n# 调用\n>>> calc(*nums)\n14\n```\n**nums表示一个数组或者元组\n\\*nums表示取出nums这个list里的所有元素，代表多个参数**\n\n#### 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：\n```python\n# 定义函数\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n# 调用\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n# 另一种简化写法\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n**kw表示一个dict\n\\*\\*kw表示取出kw中的所有键值对元素，代表多个参数**\n\n**另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。**\n\n#### 命名关键字参数\n不知道这么脑残的语法有什么意义。\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n","source":"_posts/python_函数.md","raw":"title: python 3.5 函数\ndate: 2016/8/7 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n### 调用函数\n#### 数据类型转换\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数\n\n#### 函数名\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”\n```python\n>>> a = abs # 变量a指向abs函数\n>>> a(-1) # 所以也可以通过a调用abs函数\n1\n```\n\n### 定义函数\n定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n```python\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.\n\n#### 空函数\n用pass语句定义一个什么事都不做的空函数，不用pass会报错。\n```python\ndef nop():\n    pass\n# 或者    \nif age >= 18:\n    pass\n```\n\n#### 返回多个值\n```python\nimport math\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n```\n\n得到返回值\n```python\n>>> x, y = move(100, 100, 60, math.pi / 6)\n>>> print(x, y)\n151.96152422706632 70.0\n>>> r = move(100, 100, 60, math.pi / 6)\n>>> print(r)\n(151.96152422706632, 70.0)\n```\n其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n\n### 函数的参数\n#### 默认参数\npython不支持重载，可以使用默认参数的方式替代。\n```python\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).\n\n但是需要注意：\n1. 必选参数在前，默认参数在后，否则Python的解释器会报错。**如果不按顺序提供参数时，需要写成 参数名=xx 的形式。**\n2. 默认参数必须指向不变对象。\n例如：\n```python\ndef add_end(L=[]):\n    L.append('END')\n    return L\n    \n>>> add_end()\n['END']\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n```\n当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。\n\n如果要默认是list，可以这么写：\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n#### 可变参数\n通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n>>> calc(1, 2, 3)\n14\n>>> calc(1, 3, 5, 7)\n84\n```\n**可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list**\n**不是可变参数的话，参数需要一一对应**\n\n如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：\n```python\n>>> nums = [1, 2, 3]\n>>> print(nums)\n[1, 2, 3]\n>>> print(*nums)\n1, 2, 3\n# 调用\n>>> calc(*nums)\n14\n```\n**nums表示一个数组或者元组\n\\*nums表示取出nums这个list里的所有元素，代表多个参数**\n\n#### 关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：\n```python\n# 定义函数\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n# 调用\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n# 另一种简化写法\n>>> extra = {'city': 'Beijing', 'job': 'Engineer'}\n>>> person('Jack', 24, **extra)\nname: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}\n```\n**kw表示一个dict\n\\*\\*kw表示取出kw中的所有键值对元素，代表多个参数**\n\n**另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。**\n\n#### 命名关键字参数\n不知道这么脑残的语法有什么意义。\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n","slug":"python_函数","published":1,"updated":"2016-09-23T05:53:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxi002ergruzf8k6a63","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><h4 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数</p>\n<h4 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = abs <span class=\"comment\"># 变量a指向abs函数</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a(<span class=\"number\">-1</span>) <span class=\"comment\"># 所以也可以通过a调用abs函数</span></div><div class=\"line\"><span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -x</div></pre></td></tr></table></figure></p>\n<p>可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.</p>\n<h4 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h4><p>用pass语句定义一个什么事都不做的空函数，不用pass会报错。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"comment\"># 或者    </span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(x, y, step, angle=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">    nx = x + step * math.cos(angle)</div><div class=\"line\">    ny = y - step * math.sin(angle)</div><div class=\"line\">    <span class=\"keyword\">return</span> nx, ny</div></pre></td></tr></table></figure>\n<p>得到返回值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x, y = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(x, y)</div><div class=\"line\"><span class=\"number\">151.96152422706632</span> <span class=\"number\">70.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(r)</div><div class=\"line\">(<span class=\"number\">151.96152422706632</span>, <span class=\"number\">70.0</span>)</div></pre></td></tr></table></figure></p>\n<p>其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>python不支持重载，可以使用默认参数的方式替代。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div></pre></td></tr></table></figure></p>\n<p>第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).</p>\n<p>但是需要注意：</p>\n<ol>\n<li>必选参数在前，默认参数在后，否则Python的解释器会报错。<strong>如果不按顺序提供参数时，需要写成 参数名=xx 的形式。</strong></li>\n<li>默认参数必须指向不变对象。<br>例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=[])</span>:</span></div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。</p>\n<p>如果要默认是list，可以这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"number\">84</span></div></pre></td></tr></table></figure></p>\n<p><strong>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list</strong><br><strong>不是可变参数的话，参数需要一一对应</strong></p>\n<p>如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(nums)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(*nums)</div><div class=\"line\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(*nums)</div><div class=\"line\"><span class=\"number\">14</span></div></pre></td></tr></table></figure></p>\n<p><strong>nums表示一个数组或者元组<br>*nums表示取出nums这个list里的所有元素，代表多个参数</strong></p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</div><div class=\"line\">name: Adam age: <span class=\"number\">45</span> other: &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"comment\"># 另一种简化写法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Jack'</span>, <span class=\"number\">24</span>, **extra)</div><div class=\"line\">name: Jack age: <span class=\"number\">24</span> other: &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>kw表示一个dict<br>**kw表示取出kw中的所有键值对元素，代表多个参数</strong></p>\n<p><strong>另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。</strong></p>\n<h4 id=\"命名关键字参数\"><a href=\"#命名关键字参数\" class=\"headerlink\" title=\"命名关键字参数\"></a>命名关键字参数</h4><p>不知道这么脑残的语法有什么意义。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h3><h4 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数</p>\n<h4 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = abs <span class=\"comment\"># 变量a指向abs函数</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a(<span class=\"number\">-1</span>) <span class=\"comment\"># 所以也可以通过a调用abs函数</span></div><div class=\"line\"><span class=\"number\">1</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h3><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> -x</div></pre></td></tr></table></figure></p>\n<p>可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.</p>\n<h4 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h4><p>用pass语句定义一个什么事都不做的空函数，不用pass会报错。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"comment\"># 或者    </span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> math</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">move</span><span class=\"params\">(x, y, step, angle=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">    nx = x + step * math.cos(angle)</div><div class=\"line\">    ny = y - step * math.sin(angle)</div><div class=\"line\">    <span class=\"keyword\">return</span> nx, ny</div></pre></td></tr></table></figure>\n<p>得到返回值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x, y = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(x, y)</div><div class=\"line\"><span class=\"number\">151.96152422706632</span> <span class=\"number\">70.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = move(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">60</span>, math.pi / <span class=\"number\">6</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(r)</div><div class=\"line\">(<span class=\"number\">151.96152422706632</span>, <span class=\"number\">70.0</span>)</div></pre></td></tr></table></figure></p>\n<p>其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>\n<h3 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h3><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>python不支持重载，可以使用默认参数的方式替代。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(x, n=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    s = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        n = n - <span class=\"number\">1</span></div><div class=\"line\">        s = s * x</div><div class=\"line\">    <span class=\"keyword\">return</span> s</div></pre></td></tr></table></figure></p>\n<p>第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).</p>\n<p>但是需要注意：</p>\n<ol>\n<li>必选参数在前，默认参数在后，否则Python的解释器会报错。<strong>如果不按顺序提供参数时，需要写成 参数名=xx 的形式。</strong></li>\n<li>默认参数必须指向不变对象。<br>例如：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=[])</span>:</span></div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>add_end()</div><div class=\"line\">[<span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>, <span class=\"string\">'END'</span>]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。</p>\n<p>如果要默认是list，可以这么写：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        L = []</div><div class=\"line\">    L.append(<span class=\"string\">'END'</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc</span><span class=\"params\">(*numbers)</span>:</span></div><div class=\"line\">    sum = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> numbers:</div><div class=\"line\">        sum = sum + n * n</div><div class=\"line\">    <span class=\"keyword\">return</span> sum</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"number\">14</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"number\">84</span></div></pre></td></tr></table></figure></p>\n<p><strong>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list</strong><br><strong>不是可变参数的话，参数需要一一对应</strong></p>\n<p>如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(nums)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(*nums)</div><div class=\"line\"><span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>calc(*nums)</div><div class=\"line\"><span class=\"number\">14</span></div></pre></td></tr></table></figure></p>\n<p><strong>nums表示一个数组或者元组<br>*nums表示取出nums这个list里的所有元素，代表多个参数</strong></p>\n<h4 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h4><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 定义函数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw)</div><div class=\"line\"><span class=\"comment\"># 调用</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</div><div class=\"line\">name: Adam age: <span class=\"number\">45</span> other: &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"comment\"># 另一种简化写法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>extra = &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>person(<span class=\"string\">'Jack'</span>, <span class=\"number\">24</span>, **extra)</div><div class=\"line\">name: Jack age: <span class=\"number\">24</span> other: &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>kw表示一个dict<br>**kw表示取出kw中的所有键值对元素，代表多个参数</strong></p>\n<p><strong>另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。</strong></p>\n<h4 id=\"命名关键字参数\"><a href=\"#命名关键字参数\" class=\"headerlink\" title=\"命名关键字参数\"></a>命名关键字参数</h4><p>不知道这么脑残的语法有什么意义。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 IO编程","date":"2016-08-15T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 文件读写\n#### 读文件\n使用Python内置的open()函数，传入文件名和标示符\n```python\n>>> f = open('/Users/test.txt', 'r')\n```\n标示符'r'表示读.\n\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n```python\n>>> f.read()\n'Hello, world!'\n```\n\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的\n```python\n>>> f.close()\n```\n\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n```python\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n```\n\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n```python\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n```\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```python\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n\n#### 二进制文件\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n```python\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n```\n\n#### 文件读写\n\n阅读: 100273\n读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。\n\n读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n读文件\n\n要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：\n\n>>> f = open('/Users/michael/test.txt', 'r')\n标示符'r'表示读，这样，我们就成功地打开了一个文件。\n\n如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：\n\n>>> f=open('/Users/michael/notfound.txt', 'r')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n\n>>> f.read()\n'Hello, world!'\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：\n\n>>> f.close()\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\nfile-like Object\n\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。\n\nStringIO就是在内存中创建的file-like Object，常用作临时缓冲。\n\n#### 二进制文件\n\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n字符编码\n\n#### 字符编码\n要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')\n>>> f.read()\n'测试'\n```\n\n遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')\n```\n\n#### 写文件\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：\n```python\n>>> f = open('/Users/michael/test.txt', 'w')\n>>> f.write('Hello, world!')\n>>> f.close()\n```\n\n你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：\n```python\nwith open('/Users/michael/test.txt', 'w') as f:\n    f.write('Hello, world!')\n```\n\n### StringIO和BytesIO\n读取写内容到内存中，不写了。用到再看。\n\n### 操作文件和目录\n```python\n>>> import os\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n```\n把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：\n```python\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\n```\n\n文件操作\n```python\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n```\n\n### 序列化\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n\nPython提供了pickle模块来实现序列化。\n```python\n>>> import pickle\n>>> d = dict(name='Bob', age=20, score=88)\n>>> f = open('dump.txt', 'wb')\n>>> pickle.dump(d, f)\n>>> f.close()\n```\npickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.\n当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:\n```python\n>>> f = open('dump.txt', 'rb')\n>>> d = pickle.load(f)\n>>> f.close()\n>>> d\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n### JSON\nPython内置的json模块提供了非常完善的Python对象到JSON格式的转换。\n```python\n>>> import json\n>>> d = dict(name='Bob', age=20, score=88)\n>>> json.dumps(d)\n'{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n```\ndumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。\n\n要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：\n```python\n>>> json_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n>>> json.loads(json_str)\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_IO编程.md","raw":"title: python 3.5 IO编程\ndate: 2016/8/15 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 文件读写\n#### 读文件\n使用Python内置的open()函数，传入文件名和标示符\n```python\n>>> f = open('/Users/test.txt', 'r')\n```\n标示符'r'表示读.\n\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n```python\n>>> f.read()\n'Hello, world!'\n```\n\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的\n```python\n>>> f.close()\n```\n\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n```python\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n```\n\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n```python\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n```\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```python\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n\n#### 二进制文件\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n```python\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n```\n\n#### 文件读写\n\n阅读: 100273\n读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。\n\n读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n读文件\n\n要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：\n\n>>> f = open('/Users/michael/test.txt', 'r')\n标示符'r'表示读，这样，我们就成功地打开了一个文件。\n\n如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：\n\n>>> f=open('/Users/michael/notfound.txt', 'r')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nFileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'\n如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：\n\n>>> f.read()\n'Hello, world!'\n最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：\n\n>>> f.close()\n由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：\n\ntry:\n    f = open('/path/to/file', 'r')\n    print(f.read())\nfinally:\n    if f:\n        f.close()\n但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：\n\nwith open('/path/to/file', 'r') as f:\n    print(f.read())\n这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。\n\n调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\nfile-like Object\n\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。\n\nStringIO就是在内存中创建的file-like Object，常用作临时缓冲。\n\n#### 二进制文件\n\n前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可：\n\n>>> f = open('/Users/michael/test.jpg', 'rb')\n>>> f.read()\nb'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节\n字符编码\n\n#### 字符编码\n要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')\n>>> f.read()\n'测试'\n```\n\n遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：\n```python\n>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')\n```\n\n#### 写文件\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件：\n```python\n>>> f = open('/Users/michael/test.txt', 'w')\n>>> f.write('Hello, world!')\n>>> f.close()\n```\n\n你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：\n```python\nwith open('/Users/michael/test.txt', 'w') as f:\n    f.write('Hello, world!')\n```\n\n### StringIO和BytesIO\n读取写内容到内存中，不写了。用到再看。\n\n### 操作文件和目录\n```python\n>>> import os\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n```\n把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：\n```python\n>>> os.path.split('/Users/michael/testdir/file.txt')\n('/Users/michael/testdir', 'file.txt')\n```\n\n文件操作\n```python\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n```\n\n### 序列化\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n\nPython提供了pickle模块来实现序列化。\n```python\n>>> import pickle\n>>> d = dict(name='Bob', age=20, score=88)\n>>> f = open('dump.txt', 'wb')\n>>> pickle.dump(d, f)\n>>> f.close()\n```\npickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.\n当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:\n```python\n>>> f = open('dump.txt', 'rb')\n>>> d = pickle.load(f)\n>>> f.close()\n>>> d\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n### JSON\nPython内置的json模块提供了非常完善的Python对象到JSON格式的转换。\n```python\n>>> import json\n>>> d = dict(name='Bob', age=20, score=88)\n>>> json.dumps(d)\n'{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n```\ndumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。\n\n要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：\n```python\n>>> json_str = '{\"age\": 20, \"score\": 88, \"name\": \"Bob\"}'\n>>> json.loads(json_str)\n{'age': 20, 'score': 88, 'name': 'Bob'}\n```\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_IO编程","published":1,"updated":"2016-09-23T05:53:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxl002irgruxp32je2o","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h3><h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><p>使用Python内置的open()函数，传入文件名和标示符<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/test.txt'</span>, <span class=\"string\">'r'</span>)</div></pre></td></tr></table></figure></p>\n<p>标示符’r’表示读.</p>\n<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'Hello, world!'</span></div></pre></td></tr></table></figure></p>\n<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    f = open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</div><div class=\"line\">    print(f.read())</div><div class=\"line\"><span class=\"keyword\">finally</span>:</div><div class=\"line\">    <span class=\"keyword\">if</span> f:</div><div class=\"line\">        f.close()</div></pre></td></tr></table></figure></p>\n<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    print(f.read())</div></pre></td></tr></table></figure></p>\n<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</div><div class=\"line\">    print(line.strip()) <span class=\"comment\"># 把末尾的'\\n'删掉</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"二进制文件\"><a href=\"#二进制文件\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.jpg'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">b'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...'</span> <span class=\"comment\"># 十六进制表示的字节</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"文件读写-1\"><a href=\"#文件读写-1\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h4><p>阅读: 100273<br>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>\n<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<p>读文件</p>\n<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.txt’, ‘r’)<br>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f=open(‘/Users/michael/notfound.txt’, ‘r’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>FileNotFoundError: [Errno 2] No such file or directory: ‘/Users/michael/notfound.txt’<br>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</module></stdin></p>\n<p>f.read()<br>‘Hello, world!’<br>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>\n<p>f.close()<br>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>try:<br>    f = open(‘/path/to/file’, ‘r’)<br>    print(f.read())<br>finally:<br>    if f:<br>        f.close()<br>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>\n<p>with open(‘/path/to/file’, ‘r’) as f:<br>    print(f.read())<br>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>\n<p>for line in f.readlines():<br>    print(line.strip()) # 把末尾的’\\n’删掉<br>file-like Object</p>\n<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>\n<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<h4 id=\"二进制文件-1\"><a href=\"#二进制文件-1\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.jpg’, ‘rb’)<br>f.read()<br>b’\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00…’ # 十六进制表示的字节<br>字符编码</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'测试'</span></div></pre></td></tr></table></figure></p>\n<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>, errors=<span class=\"string\">'ignore'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.write(<span class=\"string\">'Hello, world!'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(<span class=\"string\">'Hello, world!'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"StringIO和BytesIO\"><a href=\"#StringIO和BytesIO\" class=\"headerlink\" title=\"StringIO和BytesIO\"></a>StringIO和BytesIO</h3><p>读取写内容到内存中，不写了。用到再看。</p>\n<h3 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.abspath(<span class=\"string\">'.'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></div><div class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>\n<p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。<br>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.split(<span class=\"string\">'/Users/michael/testdir/file.txt'</span>)</div><div class=\"line\">(<span class=\"string\">'/Users/michael/testdir'</span>, <span class=\"string\">'file.txt'</span>)</div></pre></td></tr></table></figure></p>\n<p>文件操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 对文件重命名:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉文件:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.remove(<span class=\"string\">'test.py'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>\n<p>Python提供了pickle模块来实现序列化。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> pickle</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'wb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</div><div class=\"line\"><span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>\n<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_str = <span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h3><h4 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h4><p>使用Python内置的open()函数，传入文件名和标示符<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/test.txt'</span>, <span class=\"string\">'r'</span>)</div></pre></td></tr></table></figure></p>\n<p>标示符’r’表示读.</p>\n<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'Hello, world!'</span></div></pre></td></tr></table></figure></p>\n<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>:</div><div class=\"line\">    f = open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</div><div class=\"line\">    print(f.read())</div><div class=\"line\"><span class=\"keyword\">finally</span>:</div><div class=\"line\">    <span class=\"keyword\">if</span> f:</div><div class=\"line\">        f.close()</div></pre></td></tr></table></figure></p>\n<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    print(f.read())</div></pre></td></tr></table></figure></p>\n<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f.readlines():</div><div class=\"line\">    print(line.strip()) <span class=\"comment\"># 把末尾的'\\n'删掉</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"二进制文件\"><a href=\"#二进制文件\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.jpg'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">b'\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...'</span> <span class=\"comment\"># 十六进制表示的字节</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"文件读写-1\"><a href=\"#文件读写-1\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h4><p>阅读: 100273<br>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>\n<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<p>读文件</p>\n<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.txt’, ‘r’)<br>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f=open(‘/Users/michael/notfound.txt’, ‘r’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>FileNotFoundError: [Errno 2] No such file or directory: ‘/Users/michael/notfound.txt’<br>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</p>\n<p>f.read()<br>‘Hello, world!’<br>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>\n<p>f.close()<br>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>try:<br>    f = open(‘/path/to/file’, ‘r’)<br>    print(f.read())<br>finally:<br>    if f:<br>        f.close()<br>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>\n<p>with open(‘/path/to/file’, ‘r’) as f:<br>    print(f.read())<br>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>\n<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>\n<p>for line in f.readlines():<br>    print(line.strip()) # 把末尾的’\\n’删掉<br>file-like Object</p>\n<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>\n<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<h4 id=\"二进制文件-1\"><a href=\"#二进制文件-1\" class=\"headerlink\" title=\"二进制文件\"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>f = open(‘/Users/michael/test.jpg’, ‘rb’)<br>f.read()<br>b’\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00…’ # 十六进制表示的字节<br>字符编码</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h4 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.read()</div><div class=\"line\"><span class=\"string\">'测试'</span></div></pre></td></tr></table></figure></p>\n<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">'gbk'</span>, errors=<span class=\"string\">'ignore'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.write(<span class=\"string\">'Hello, world!'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/michael/test.txt'</span>, <span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</div><div class=\"line\">    f.write(<span class=\"string\">'Hello, world!'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"StringIO和BytesIO\"><a href=\"#StringIO和BytesIO\" class=\"headerlink\" title=\"StringIO和BytesIO\"></a>StringIO和BytesIO</h3><p>读取写内容到内存中，不写了。用到再看。</p>\n<h3 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> os</div><div class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.abspath(<span class=\"string\">'.'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael'</span></div><div class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</div><div class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></div><div class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>\n<p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。<br>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.path.split(<span class=\"string\">'/Users/michael/testdir/file.txt'</span>)</div><div class=\"line\">(<span class=\"string\">'/Users/michael/testdir'</span>, <span class=\"string\">'file.txt'</span>)</div></pre></td></tr></table></figure></p>\n<p>文件操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 对文件重命名:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 删掉文件:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>os.remove(<span class=\"string\">'test.py'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>\n<p>Python提供了pickle模块来实现序列化。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> pickle</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'wb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>\n<p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = open(<span class=\"string\">'dump.txt'</span>, <span class=\"string\">'rb'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f.close()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h3><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict(name=<span class=\"string\">'Bob'</span>, age=<span class=\"number\">20</span>, score=<span class=\"number\">88</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</div><div class=\"line\"><span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>\n<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json_str = <span class=\"string\">'&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class=\"line\">&#123;<span class=\"string\">'age'</span>: <span class=\"number\">20</span>, <span class=\"string\">'score'</span>: <span class=\"number\">88</span>, <span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 模块","date":"2016-08-08T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n### 高阶函数\n#### 变量可以指向函数\n把函数本身赋值给变量,即：变量可以指向函数。\n```python\n>>> f = abs\n>>> f(-10)\n10\n```\n说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n\n#### 传入函数\n那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数\n```python\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n\n#### map\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n```python\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数**必须接收两个参数**，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n```python\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n#### filter\nfilter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n```python\ndef is_odd(n):\n    return n % 2 == 1\nlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n# 结果: [1, 5, 9, 15]\n```\n\n#### sorted\n使用sorted()函数就可以对list进行排序。\nsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：\n```python\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36]\n```\n**key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：**\n```python\nlist = [36, 5, -12, 9, -21]\nkeys = [36, 5,  12, 9,  21]\n```\n\n### 返回函数\n高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。\n```python\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n```\n本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。\n因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n\n### 匿名函数\n```python\nlambda x: x * x\n=>\ndef f(x):\n    return x * x\n```\n\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n匿名函数有个限制，就是**只能有一个表达式**，不用写return，返回值就是该表达式的结果。\n匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\n\n### 装饰器\n#### 不带参数\n在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n    \t# 函数对象有一个__name__属性，可以拿到函数的名字\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n@log\ndef now():\n    print('2015-3-25')\n    \n>>> now()\ncall now():\n2015-3-25\n```\n\n此处把**@log**放到**now()**定义处，相当于执行了\n**now = log(now)**: **now() => wrapper()**\n将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。\n\n#### 带参数\n如果log带参数\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print('2015-3-25')\n```\n\n首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即**now()=>wrapper()**\n\n#### 带来的问题\n上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用**now.__name__**时，结果就会使wrapper，而不是now。\n因此，需要将**wrapper.__name__ = func.__name__**。可以使用python内置的方法**functools.wraps**\n\n```\nimport functools\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 或者\nimport functools\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator  \n```\n\n### 偏函数\n使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单\n\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\n```python\ndef int2(x, base=2):\n    return int(x, base)\n```\n\n我们可以使用**functools.partial**创建一个偏函数，不需要自己定义int2\n```python\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n```\n简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单\n\n创建偏函数时，实际上可以接收函数对象、\\*args和\\*\\*kw这3个参数.\n```python\nmax2 = functools.partial(max, 10)\n```\n实际上会把10作为\\*args的一部分**自动加到左边**，也就是：\n```python\nmax2(5, 6, 7)\n相当于：\nargs = (10, 5, 6, 7)\nmax(*args)\n```\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_函数式编程.md","raw":"title: python 3.5 模块\ndate: 2016/8/8 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n### 高阶函数\n#### 变量可以指向函数\n把函数本身赋值给变量,即：变量可以指向函数。\n```python\n>>> f = abs\n>>> f(-10)\n10\n```\n说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n\n#### 传入函数\n那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数\n```python\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n\n#### map\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n```python\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数**必须接收两个参数**，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n```python\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n\n#### filter\nfilter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n```python\ndef is_odd(n):\n    return n % 2 == 1\nlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n# 结果: [1, 5, 9, 15]\n```\n\n#### sorted\n使用sorted()函数就可以对list进行排序。\nsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：\n```python\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36]\n```\n**key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：**\n```python\nlist = [36, 5, -12, 9, -21]\nkeys = [36, 5,  12, 9,  21]\n```\n\n### 返回函数\n高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。\n```python\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n```\n本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。\n因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n\n### 匿名函数\n```python\nlambda x: x * x\n=>\ndef f(x):\n    return x * x\n```\n\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n匿名函数有个限制，就是**只能有一个表达式**，不用写return，返回值就是该表达式的结果。\n匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\n\n### 装饰器\n#### 不带参数\n在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n```python\ndef log(func):\n    def wrapper(*args, **kw):\n    \t# 函数对象有一个__name__属性，可以拿到函数的名字\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n@log\ndef now():\n    print('2015-3-25')\n    \n>>> now()\ncall now():\n2015-3-25\n```\n\n此处把**@log**放到**now()**定义处，相当于执行了\n**now = log(now)**: **now() => wrapper()**\n将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。\n\n#### 带参数\n如果log带参数\n```python\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print('2015-3-25')\n```\n\n首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即**now()=>wrapper()**\n\n#### 带来的问题\n上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用**now.__name__**时，结果就会使wrapper，而不是now。\n因此，需要将**wrapper.__name__ = func.__name__**。可以使用python内置的方法**functools.wraps**\n\n```\nimport functools\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 或者\nimport functools\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator  \n```\n\n### 偏函数\n使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单\n\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\n```python\ndef int2(x, base=2):\n    return int(x, base)\n```\n\n我们可以使用**functools.partial**创建一个偏函数，不需要自己定义int2\n```python\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n```\n简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单\n\n创建偏函数时，实际上可以接收函数对象、\\*args和\\*\\*kw这3个参数.\n```python\nmax2 = functools.partial(max, 10)\n```\n实际上会把10作为\\*args的一部分**自动加到左边**，也就是：\n```python\nmax2(5, 6, 7)\n相当于：\nargs = (10, 5, 6, 7)\nmax(*args)\n```\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_函数式编程","published":1,"updated":"2016-09-23T05:53:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxn002mrgrugnhevmf3","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><h4 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h4><p>把函数本身赋值给变量,即：变量可以指向函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = abs</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">-10</span>)</div><div class=\"line\"><span class=\"number\">10</span></div></pre></td></tr></table></figure></p>\n<p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>\n<h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</div></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x * x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = map(f, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(r)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</div></pre></td></tr></table></figure></p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数<strong>必须接收两个参数</strong>，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>filter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_odd</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span></div><div class=\"line\">list(filter(is_odd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>]))</div><div class=\"line\"><span class=\"comment\"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h4><p>使用sorted()函数就可以对list进行排序。<br>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>], key=abs)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">-12</span>, <span class=\"number\">-21</span>, <span class=\"number\">36</span>]</div></pre></td></tr></table></figure></p>\n<p><strong>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>]</div><div class=\"line\">keys = [<span class=\"number\">36</span>, <span class=\"number\">5</span>,  <span class=\"number\">12</span>, <span class=\"number\">9</span>,  <span class=\"number\">21</span>]</div></pre></td></tr></table></figure></p>\n<h3 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h3><p>高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    fs = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></div><div class=\"line\">             <span class=\"keyword\">return</span> i*i</div><div class=\"line\">        fs.append(f)</div><div class=\"line\">    <span class=\"keyword\">return</span> fs</div><div class=\"line\"></div><div class=\"line\">f1, f2, f3 = count()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</div><div class=\"line\"><span class=\"number\">9</span></div></pre></td></tr></table></figure></p>\n<p>本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。<br>因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">lambda</span> x: x * x</div><div class=\"line\">=&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x * x</div></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写return，返回值就是该表达式的结果。<br>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h4 id=\"不带参数\"><a href=\"#不带参数\" class=\"headerlink\" title=\"不带参数\"></a>不带参数</h4><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">    \t<span class=\"comment\"># 函数对象有一个__name__属性，可以拿到函数的名字</span></div><div class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</div><div class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"><span class=\"meta\">@log</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</div><div class=\"line\">call now():</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-3</span><span class=\"number\">-25</span></div></pre></td></tr></table></figure></p>\n<p>此处把<strong>@log</strong>放到<strong>now()</strong>定义处，相当于执行了<br><strong>now = log(now)</strong>: <strong>now() =&gt; wrapper()</strong><br>将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。</p>\n<h4 id=\"带参数\"><a href=\"#带参数\" class=\"headerlink\" title=\"带参数\"></a>带参数</h4><p>如果log带参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</div><div class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">        <span class=\"keyword\">return</span> wrapper</div><div class=\"line\">    <span class=\"keyword\">return</span> decorator</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@log('execute')</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div></pre></td></tr></table></figure></p>\n<p>首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即<strong>now()=&gt;wrapper()</strong></p>\n<h4 id=\"带来的问题\"><a href=\"#带来的问题\" class=\"headerlink\" title=\"带来的问题\"></a>带来的问题</h4><p>上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用<strong>now.<strong>name</strong></strong>时，结果就会使wrapper，而不是now。<br>因此，需要将<strong>wrapper.<strong>name</strong> = func.<strong>name</strong></strong>。可以使用python内置的方法<strong>functools.wraps</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import functools</div><div class=\"line\">def log(func):</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def wrapper(*args, **kw):</div><div class=\"line\">        print(&apos;call %s():&apos; % func.__name__)</div><div class=\"line\">        return func(*args, **kw)</div><div class=\"line\">    return wrapper</div><div class=\"line\"># 或者</div><div class=\"line\">import functools</div><div class=\"line\">def log(text):</div><div class=\"line\">    def decorator(func):</div><div class=\"line\">        @functools.wraps(func)</div><div class=\"line\">        def wrapper(*args, **kw):</div><div class=\"line\">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class=\"line\">            return func(*args, **kw)</div><div class=\"line\">        return wrapper</div><div class=\"line\">    return decorator</div></pre></td></tr></table></figure>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>\n<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int2</span><span class=\"params\">(x, base=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> int(x, base)</div></pre></td></tr></table></figure></p>\n<p>我们可以使用<strong>functools.partial</strong>创建一个偏函数，不需要自己定义int2<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> functools</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1000000'</span>)</div><div class=\"line\"><span class=\"number\">64</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1010101'</span>)</div><div class=\"line\"><span class=\"number\">85</span></div></pre></td></tr></table></figure></p>\n<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>\n<p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2 = functools.partial(max, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p>实际上会把10作为*args的一部分<strong>自动加到左边</strong>，也就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">相当于：</div><div class=\"line\">args = (<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">max(*args)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><h4 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h4><p>把函数本身赋值给变量,即：变量可以指向函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f = abs</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f(<span class=\"number\">-10</span>)</div><div class=\"line\"><span class=\"number\">10</span></div></pre></td></tr></table></figure></p>\n<p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>\n<h4 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h4><p>那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</div></pre></td></tr></table></figure></p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> x * x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>r = map(f, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>list(r)</div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span>, <span class=\"number\">36</span>, <span class=\"number\">49</span>, <span class=\"number\">64</span>, <span class=\"number\">81</span>]</div></pre></td></tr></table></figure></p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数<strong>必须接收两个参数</strong>，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>filter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_odd</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span></div><div class=\"line\">list(filter(is_odd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>]))</div><div class=\"line\"><span class=\"comment\"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h4><p>使用sorted()函数就可以对list进行排序。<br>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>], key=abs)</div><div class=\"line\">[<span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">-12</span>, <span class=\"number\">-21</span>, <span class=\"number\">36</span>]</div></pre></td></tr></table></figure></p>\n<p><strong>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">-12</span>, <span class=\"number\">9</span>, <span class=\"number\">-21</span>]</div><div class=\"line\">keys = [<span class=\"number\">36</span>, <span class=\"number\">5</span>,  <span class=\"number\">12</span>, <span class=\"number\">9</span>,  <span class=\"number\">21</span>]</div></pre></td></tr></table></figure></p>\n<h3 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h3><p>高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    fs = []</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></div><div class=\"line\">             <span class=\"keyword\">return</span> i*i</div><div class=\"line\">        fs.append(f)</div><div class=\"line\">    <span class=\"keyword\">return</span> fs</div><div class=\"line\"></div><div class=\"line\">f1, f2, f3 = count()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f1()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f2()</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>f3()</div><div class=\"line\"><span class=\"number\">9</span></div></pre></td></tr></table></figure></p>\n<p>本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。<br>因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">lambda</span> x: x * x</div><div class=\"line\">=&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x * x</div></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写return，返回值就是该表达式的结果。<br>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><h4 id=\"不带参数\"><a href=\"#不带参数\" class=\"headerlink\" title=\"不带参数\"></a>不带参数</h4><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">    \t<span class=\"comment\"># 函数对象有一个__name__属性，可以拿到函数的名字</span></div><div class=\"line\">        print(<span class=\"string\">'call %s():'</span> % func.__name__)</div><div class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">    <span class=\"keyword\">return</span> wrapper</div><div class=\"line\"><span class=\"meta\">@log</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now()</div><div class=\"line\">call now():</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-3</span><span class=\"number\">-25</span></div></pre></td></tr></table></figure></p>\n<p>此处把<strong>@log</strong>放到<strong>now()</strong>定义处，相当于执行了<br><strong>now = log(now)</strong>: <strong>now() =&gt; wrapper()</strong><br>将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。</p>\n<h4 id=\"带参数\"><a href=\"#带参数\" class=\"headerlink\" title=\"带参数\"></a>带参数</h4><p>如果log带参数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></div><div class=\"line\">            print(<span class=\"string\">'%s %s():'</span> % (text, func.__name__))</div><div class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</div><div class=\"line\">        <span class=\"keyword\">return</span> wrapper</div><div class=\"line\">    <span class=\"keyword\">return</span> decorator</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@log('execute')</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'2015-3-25'</span>)</div></pre></td></tr></table></figure></p>\n<p>首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即<strong>now()=&gt;wrapper()</strong></p>\n<h4 id=\"带来的问题\"><a href=\"#带来的问题\" class=\"headerlink\" title=\"带来的问题\"></a>带来的问题</h4><p>上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用<strong>now.<strong>name</strong></strong>时，结果就会使wrapper，而不是now。<br>因此，需要将<strong>wrapper.<strong>name</strong> = func.<strong>name</strong></strong>。可以使用python内置的方法<strong>functools.wraps</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">import functools</div><div class=\"line\">def log(func):</div><div class=\"line\">    @functools.wraps(func)</div><div class=\"line\">    def wrapper(*args, **kw):</div><div class=\"line\">        print(&apos;call %s():&apos; % func.__name__)</div><div class=\"line\">        return func(*args, **kw)</div><div class=\"line\">    return wrapper</div><div class=\"line\"># 或者</div><div class=\"line\">import functools</div><div class=\"line\">def log(text):</div><div class=\"line\">    def decorator(func):</div><div class=\"line\">        @functools.wraps(func)</div><div class=\"line\">        def wrapper(*args, **kw):</div><div class=\"line\">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class=\"line\">            return func(*args, **kw)</div><div class=\"line\">        return wrapper</div><div class=\"line\">    return decorator</div></pre></td></tr></table></figure>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>\n<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">int2</span><span class=\"params\">(x, base=<span class=\"number\">2</span>)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">return</span> int(x, base)</div></pre></td></tr></table></figure></p>\n<p>我们可以使用<strong>functools.partial</strong>创建一个偏函数，不需要自己定义int2<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> functools</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1000000'</span>)</div><div class=\"line\"><span class=\"number\">64</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>int2(<span class=\"string\">'1010101'</span>)</div><div class=\"line\"><span class=\"number\">85</span></div></pre></td></tr></table></figure></p>\n<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>\n<p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2 = functools.partial(max, <span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p>实际上会把10作为*args的一部分<strong>自动加到左边</strong>，也就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">max2(<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">相当于：</div><div class=\"line\">args = (<span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">max(*args)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 常用內建模块","date":"2016-08-23T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### datetime\n#### 获取当前日期和时间\ndatetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n如果仅导入import datetime，则必须引用全名datetime.datetime。\n```python\n>>> from datetime import datetime\n>>> now = datetime.now() # 获取当前datetime\n>>> print(now)\n2015-05-18 16:28:07.198690\n>>> print(type(now))\n<class 'datetime.datetime'>\n```\ndatetime.now()返回当前日期和时间，其类型是datetime。\n\n#### 获取指定日期和时间\n要指定某个日期和时间，我们直接用参数构造一个datetime：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> print(dt)\n2015-04-19 12:20:00\n```\n\n#### datetime转换为timestamp\n把一个datetime类型转换为timestamp只需要简单调用**timestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> dt.timestamp() # 把datetime转换为timestamp\n1429417200.0\n```\n注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。\n某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.\n\n#### timestamp转换为datetime\n要把timestamp转换为datetime，使用datetime提供的**fromtimestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> t = 1429417200.0\n>>> print(datetime.fromtimestamp(t))\n2015-04-19 12:20:00\n```\n\n#### str转换为datetime\n转换方法是通过**datetime.strptime()**实现，需要一个日期和时间的格式化字符串：\n```python\n>>> from datetime import datetime\n>>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')\n>>> print(cday)\n2015-06-01 18:19:59\n```\n\n#### datetime转换为str\n如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的\n```python\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(now.strftime('%a, %b %d %H:%M'))\nMon, May 05 16:28\n```\n\n#### datetime加减\n对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类\n```python\n>>> from datetime import datetime, timedelta\n>>> now = datetime.now()\n>>> now\ndatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)\n>>> now + timedelta(hours=10)\ndatetime.datetime(2015, 5, 19, 2, 57, 3, 540997)\n>>> now - timedelta(days=1)\ndatetime.datetime(2015, 5, 17, 16, 57, 3, 540997)\n>>> now + timedelta(days=2, hours=12)\ndatetime.datetime(2015, 5, 21, 4, 57, 3, 540997)\n```\n使用timedelta你可以很容易地算出前几天和后几天的时刻\n\n\n### collections\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。\n#### namedtuple\n`namedtuple`是一个函数，它用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备`tuple`的不变性，又可以根据属性来引用，使用十分方便。\n```python\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> p = Point(1, 2)\n>>> p.x\n1\n>>> p.y\n2\n\n# namedtuple('名称', [属性list]):\nCircle = namedtuple('Circle', ['x', 'y', 'r'])\n\n```\n\n#### deque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。\n`deque`是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\n```python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n`deque`除了实现list的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。\n\n#### defaultdict\n使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：\n```python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n注意默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n#### OrderedDict\n使用`dict`时，Key是无序的。在对`dict`做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用`OrderedDict`：\n```python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n注意，`OrderedDict`的Key会按照插入的顺序排列，不是Key本身排序：\n\n#### Counter\n`Counter`是一个简单的计数器，例如，统计字符出现的个数：\n```python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n```\n`Counter`实际上也是`dict`的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_常用內建模块.md","raw":"title: python 3.5 常用內建模块\ndate: 2016/8/23 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### datetime\n#### 获取当前日期和时间\ndatetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。\n如果仅导入import datetime，则必须引用全名datetime.datetime。\n```python\n>>> from datetime import datetime\n>>> now = datetime.now() # 获取当前datetime\n>>> print(now)\n2015-05-18 16:28:07.198690\n>>> print(type(now))\n<class 'datetime.datetime'>\n```\ndatetime.now()返回当前日期和时间，其类型是datetime。\n\n#### 获取指定日期和时间\n要指定某个日期和时间，我们直接用参数构造一个datetime：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> print(dt)\n2015-04-19 12:20:00\n```\n\n#### datetime转换为timestamp\n把一个datetime类型转换为timestamp只需要简单调用**timestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime\n>>> dt.timestamp() # 把datetime转换为timestamp\n1429417200.0\n```\n注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。\n某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.\n\n#### timestamp转换为datetime\n要把timestamp转换为datetime，使用datetime提供的**fromtimestamp()**方法：\n```python\n>>> from datetime import datetime\n>>> t = 1429417200.0\n>>> print(datetime.fromtimestamp(t))\n2015-04-19 12:20:00\n```\n\n#### str转换为datetime\n转换方法是通过**datetime.strptime()**实现，需要一个日期和时间的格式化字符串：\n```python\n>>> from datetime import datetime\n>>> cday = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')\n>>> print(cday)\n2015-06-01 18:19:59\n```\n\n#### datetime转换为str\n如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的\n```python\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(now.strftime('%a, %b %d %H:%M'))\nMon, May 05 16:28\n```\n\n#### datetime加减\n对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类\n```python\n>>> from datetime import datetime, timedelta\n>>> now = datetime.now()\n>>> now\ndatetime.datetime(2015, 5, 18, 16, 57, 3, 540997)\n>>> now + timedelta(hours=10)\ndatetime.datetime(2015, 5, 19, 2, 57, 3, 540997)\n>>> now - timedelta(days=1)\ndatetime.datetime(2015, 5, 17, 16, 57, 3, 540997)\n>>> now + timedelta(days=2, hours=12)\ndatetime.datetime(2015, 5, 21, 4, 57, 3, 540997)\n```\n使用timedelta你可以很容易地算出前几天和后几天的时刻\n\n\n### collections\ncollections是Python内建的一个集合模块，提供了许多有用的集合类。\n#### namedtuple\n`namedtuple`是一个函数，它用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备`tuple`的不变性，又可以根据属性来引用，使用十分方便。\n```python\n>>> from collections import namedtuple\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> p = Point(1, 2)\n>>> p.x\n1\n>>> p.y\n2\n\n# namedtuple('名称', [属性list]):\nCircle = namedtuple('Circle', ['x', 'y', 'r'])\n\n```\n\n#### deque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。\n`deque`是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\n```python\n>>> from collections import deque\n>>> q = deque(['a', 'b', 'c'])\n>>> q.append('x')\n>>> q.appendleft('y')\n>>> q\ndeque(['y', 'a', 'b', 'c', 'x'])\n```\n`deque`除了实现list的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。\n\n#### defaultdict\n使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：\n```python\n>>> from collections import defaultdict\n>>> dd = defaultdict(lambda: 'N/A')\n>>> dd['key1'] = 'abc'\n>>> dd['key1'] # key1存在\n'abc'\n>>> dd['key2'] # key2不存在，返回默认值\n'N/A'\n```\n注意默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n#### OrderedDict\n使用`dict`时，Key是无序的。在对`dict`做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用`OrderedDict`：\n```python\n>>> from collections import OrderedDict\n>>> d = dict([('a', 1), ('b', 2), ('c', 3)])\n>>> d # dict的Key是无序的\n{'a': 1, 'c': 3, 'b': 2}\n>>> od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])\n>>> od # OrderedDict的Key是有序的\nOrderedDict([('a', 1), ('b', 2), ('c', 3)])\n```\n注意，`OrderedDict`的Key会按照插入的顺序排列，不是Key本身排序：\n\n#### Counter\n`Counter`是一个简单的计数器，例如，统计字符出现的个数：\n```python\n>>> from collections import Counter\n>>> c = Counter()\n>>> for ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\n>>> c\nCounter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n```\n`Counter`实际上也是`dict`的一个子类，上面的结果可以看出，字符'g'、'm'、'r'各出现了两次，其他字符各出现了一次。\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_常用內建模块","published":1,"updated":"2016-09-23T05:52:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxp002qrgruunjoo5h4","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"datetime\"><a href=\"#datetime\" class=\"headerlink\" title=\"datetime\"></a>datetime</h3><h4 id=\"获取当前日期和时间\"><a href=\"#获取当前日期和时间\" class=\"headerlink\" title=\"获取当前日期和时间\"></a>获取当前日期和时间</h4><p>datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now() <span class=\"comment\"># 获取当前datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-05</span><span class=\"number\">-18</span> <span class=\"number\">16</span>:<span class=\"number\">28</span>:<span class=\"number\">07.198690</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(now))</div><div class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">datetime</span>.<span class=\"title\">datetime</span>'&gt;</span></div></pre></td></tr></table></figure></p>\n<p>datetime.now()返回当前日期和时间，其类型是datetime。</p>\n<h4 id=\"获取指定日期和时间\"><a href=\"#获取指定日期和时间\" class=\"headerlink\" title=\"获取指定日期和时间\"></a>获取指定日期和时间</h4><p>要指定某个日期和时间，我们直接用参数构造一个datetime：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(dt)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为timestamp\"><a href=\"#datetime转换为timestamp\" class=\"headerlink\" title=\"datetime转换为timestamp\"></a>datetime转换为timestamp</h4><p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt.timestamp() <span class=\"comment\"># 把datetime转换为timestamp</span></div><div class=\"line\"><span class=\"number\">1429417200.0</span></div></pre></td></tr></table></figure></p>\n<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。<br>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.</p>\n<h4 id=\"timestamp转换为datetime\"><a href=\"#timestamp转换为datetime\" class=\"headerlink\" title=\"timestamp转换为datetime\"></a>timestamp转换为datetime</h4><p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = <span class=\"number\">1429417200.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"str转换为datetime\"><a href=\"#str转换为datetime\" class=\"headerlink\" title=\"str转换为datetime\"></a>str转换为datetime</h4><p>转换方法是通过<strong>datetime.strptime()</strong>实现，需要一个日期和时间的格式化字符串：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class=\"string\">'2015-6-1 18:19:59'</span>, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(cday)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-06</span><span class=\"number\">-01</span> <span class=\"number\">18</span>:<span class=\"number\">19</span>:<span class=\"number\">59</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为str\"><a href=\"#datetime转换为str\" class=\"headerlink\" title=\"datetime转换为str\"></a>datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now.strftime(<span class=\"string\">'%a, %b %d %H:%M'</span>))</div><div class=\"line\">Mon, May <span class=\"number\">05</span> <span class=\"number\">16</span>:<span class=\"number\">28</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime加减\"><a href=\"#datetime加减\" class=\"headerlink\" title=\"datetime加减\"></a>datetime加减</h4><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime, timedelta</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(hours=<span class=\"number\">10</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">2</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now - timedelta(days=<span class=\"number\">1</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">17</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(days=<span class=\"number\">2</span>, hours=<span class=\"number\">12</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">21</span>, <span class=\"number\">4</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div></pre></td></tr></table></figure></p>\n<p>使用timedelta你可以很容易地算出前几天和后几天的时刻</p>\n<h3 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h3><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>\n<h4 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h4><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.x</div><div class=\"line\"><span class=\"number\">1</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.y</div><div class=\"line\"><span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list]):</span></div><div class=\"line\">Circle = namedtuple(<span class=\"string\">'Circle'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'r'</span>])</div></pre></td></tr></table></figure></p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。<br><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</div><div class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</div></pre></td></tr></table></figure></p>\n<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>\n<h4 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h4><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></div><div class=\"line\"><span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></div><div class=\"line\"><span class=\"string\">'N/A'</span></div></pre></td></tr></table></figure></p>\n<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h4 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></div><div class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></div><div class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div></pre></td></tr></table></figure></p>\n<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</div><div class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</div><div class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"datetime\"><a href=\"#datetime\" class=\"headerlink\" title=\"datetime\"></a>datetime</h3><h4 id=\"获取当前日期和时间\"><a href=\"#获取当前日期和时间\" class=\"headerlink\" title=\"获取当前日期和时间\"></a>获取当前日期和时间</h4><p>datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now() <span class=\"comment\"># 获取当前datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-05</span><span class=\"number\">-18</span> <span class=\"number\">16</span>:<span class=\"number\">28</span>:<span class=\"number\">07.198690</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(now))</div><div class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">datetime</span>.<span class=\"title\">datetime</span>'&gt;</span></div></pre></td></tr></table></figure></p>\n<p>datetime.now()返回当前日期和时间，其类型是datetime。</p>\n<h4 id=\"获取指定日期和时间\"><a href=\"#获取指定日期和时间\" class=\"headerlink\" title=\"获取指定日期和时间\"></a>获取指定日期和时间</h4><p>要指定某个日期和时间，我们直接用参数构造一个datetime：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(dt)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为timestamp\"><a href=\"#datetime转换为timestamp\" class=\"headerlink\" title=\"datetime转换为timestamp\"></a>datetime转换为timestamp</h4><p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt = datetime(<span class=\"number\">2015</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">12</span>, <span class=\"number\">20</span>) <span class=\"comment\"># 用指定日期时间创建datetime</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dt.timestamp() <span class=\"comment\"># 把datetime转换为timestamp</span></div><div class=\"line\"><span class=\"number\">1429417200.0</span></div></pre></td></tr></table></figure></p>\n<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。<br>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.</p>\n<h4 id=\"timestamp转换为datetime\"><a href=\"#timestamp转换为datetime\" class=\"headerlink\" title=\"timestamp转换为datetime\"></a>timestamp转换为datetime</h4><p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()</strong>方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>t = <span class=\"number\">1429417200.0</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-04</span><span class=\"number\">-19</span> <span class=\"number\">12</span>:<span class=\"number\">20</span>:<span class=\"number\">00</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"str转换为datetime\"><a href=\"#str转换为datetime\" class=\"headerlink\" title=\"str转换为datetime\"></a>str转换为datetime</h4><p>转换方法是通过<strong>datetime.strptime()</strong>实现，需要一个日期和时间的格式化字符串：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class=\"string\">'2015-6-1 18:19:59'</span>, <span class=\"string\">'%Y-%m-%d %H:%M:%S'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(cday)</div><div class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-06</span><span class=\"number\">-01</span> <span class=\"number\">18</span>:<span class=\"number\">19</span>:<span class=\"number\">59</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime转换为str\"><a href=\"#datetime转换为str\" class=\"headerlink\" title=\"datetime转换为str\"></a>datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(now.strftime(<span class=\"string\">'%a, %b %d %H:%M'</span>))</div><div class=\"line\">Mon, May <span class=\"number\">05</span> <span class=\"number\">16</span>:<span class=\"number\">28</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"datetime加减\"><a href=\"#datetime加减\" class=\"headerlink\" title=\"datetime加减\"></a>datetime加减</h4><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime, timedelta</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now = datetime.now()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">18</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(hours=<span class=\"number\">10</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">19</span>, <span class=\"number\">2</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now - timedelta(days=<span class=\"number\">1</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">17</span>, <span class=\"number\">16</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>now + timedelta(days=<span class=\"number\">2</span>, hours=<span class=\"number\">12</span>)</div><div class=\"line\">datetime.datetime(<span class=\"number\">2015</span>, <span class=\"number\">5</span>, <span class=\"number\">21</span>, <span class=\"number\">4</span>, <span class=\"number\">57</span>, <span class=\"number\">3</span>, <span class=\"number\">540997</span>)</div></pre></td></tr></table></figure></p>\n<p>使用timedelta你可以很容易地算出前几天和后几天的时刻</p>\n<h3 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h3><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>\n<h4 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h4><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.x</div><div class=\"line\"><span class=\"number\">1</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p.y</div><div class=\"line\"><span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># namedtuple('名称', [属性list]):</span></div><div class=\"line\">Circle = namedtuple(<span class=\"string\">'Circle'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>, <span class=\"string\">'r'</span>])</div></pre></td></tr></table></figure></p>\n<h4 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h4><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。<br><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> deque</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = deque([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.append(<span class=\"string\">'x'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q.appendleft(<span class=\"string\">'y'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q</div><div class=\"line\">deque([<span class=\"string\">'y'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'x'</span>])</div></pre></td></tr></table></figure></p>\n<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>\n<h4 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h4><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> defaultdict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd = defaultdict(<span class=\"keyword\">lambda</span>: <span class=\"string\">'N/A'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] = <span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key1'</span>] <span class=\"comment\"># key1存在</span></div><div class=\"line\"><span class=\"string\">'abc'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>dd[<span class=\"string\">'key2'</span>] <span class=\"comment\"># key2不存在，返回默认值</span></div><div class=\"line\"><span class=\"string\">'N/A'</span></div></pre></td></tr></table></figure></p>\n<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h4 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = dict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d <span class=\"comment\"># dict的Key是无序的</span></div><div class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od = OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>od <span class=\"comment\"># OrderedDict的Key是有序的</span></div><div class=\"line\">OrderedDict([(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>), (<span class=\"string\">'b'</span>, <span class=\"number\">2</span>), (<span class=\"string\">'c'</span>, <span class=\"number\">3</span>)])</div></pre></td></tr></table></figure></p>\n<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>\n<h4 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = Counter()</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</div><div class=\"line\"><span class=\"meta\">... </span>    c[ch] = c[ch] + <span class=\"number\">1</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c</div><div class=\"line\">Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 模块","date":"2016-08-09T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n\nPython又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。\n请注意，每一个包目录下面都会有一个__init\\_\\_.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init\\_\\_.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块\n\n### 使用模块\n```python\nimport sys\ndef test():\n\tpass\nif __name__=='__main__':\n\ttest()\n```\n导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\nsys模块有一个argv变量，用list存储了**命令行的所有参数**。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。\n在命令行运行该模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n作用域：\n- 正常的函数和变量名是公开的（public），可以被直接引用\n- 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途。\n- 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。\n\n### 安装第三方模块\n使用pip3 install XXX 安装第三方库\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n搜索路径存放在sys模块的path变量中\n```python\nimport sys\nprint(sys.path)\n```\n当要添加自己的搜索目录时可以\n1. 直接修改sys.path:**sys.path.append('/Users/xxx/xxx')**\n2. 设置环境变量PYTHONPATH\n\n\n最后再次感谢廖老师的辛勤劳动。\n","source":"_posts/python_模块.md","raw":"title: python 3.5 模块\ndate: 2016/8/9 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n\nPython又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。\n请注意，每一个包目录下面都会有一个__init\\_\\_.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init\\_\\_.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块\n\n### 使用模块\n```python\nimport sys\ndef test():\n\tpass\nif __name__=='__main__':\n\ttest()\n```\n导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\nsys模块有一个argv变量，用list存储了**命令行的所有参数**。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。\n在命令行运行该模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n作用域：\n- 正常的函数和变量名是公开的（public），可以被直接引用\n- 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途。\n- 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。\n\n### 安装第三方模块\n使用pip3 install XXX 安装第三方库\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n搜索路径存放在sys模块的path变量中\n```python\nimport sys\nprint(sys.path)\n```\n当要添加自己的搜索目录时可以\n1. 直接修改sys.path:**sys.path.append('/Users/xxx/xxx')**\n2. 设置环境变量PYTHONPATH\n\n\n最后再次感谢廖老师的辛勤劳动。\n","slug":"python_模块","published":1,"updated":"2016-09-23T05:53:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxt002srgrutan8agw7","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。<br>请注意，每一个包目录下面都会有一个<strong>init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</strong>init__.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">\ttest()</div></pre></td></tr></table></figure>\n<p>导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。<br>sys模块有一个argv变量，用list存储了<strong>命令行的所有参数</strong>。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>在命令行运行该模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<p>作用域：</p>\n<ul>\n<li>正常的函数和变量名是公开的（public），可以被直接引用</li>\n<li>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。</li>\n<li>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</li>\n</ul>\n<h3 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h3><p>使用pip3 install XXX 安装第三方库<br>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。<br>搜索路径存放在sys模块的path变量中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">print(sys.path)</div></pre></td></tr></table></figure></p>\n<p>当要添加自己的搜索目录时可以</p>\n<ol>\n<li>直接修改sys.path:<strong>sys.path.append(‘/Users/xxx/xxx’)</strong></li>\n<li>设置环境变量PYTHONPATH</li>\n</ol>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。<br>请注意，每一个包目录下面都会有一个<strong>init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</strong>init__.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">\ttest()</div></pre></td></tr></table></figure>\n<p>导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。<br>sys模块有一个argv变量，用list存储了<strong>命令行的所有参数</strong>。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>在命令行运行该模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<p>作用域：</p>\n<ul>\n<li>正常的函数和变量名是公开的（public），可以被直接引用</li>\n<li>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。</li>\n<li>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</li>\n</ul>\n<h3 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h3><p>使用pip3 install XXX 安装第三方库<br>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。<br>搜索路径存放在sys模块的path变量中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\">print(sys.path)</div></pre></td></tr></table></figure></p>\n<p>当要添加自己的搜索目录时可以</p>\n<ol>\n<li>直接修改sys.path:<strong>sys.path.append(‘/Users/xxx/xxx’)</strong></li>\n<li>设置环境变量PYTHONPATH</li>\n</ol>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 正则表达式","date":"2016-08-20T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 基本用法\n- \\d可以匹配一个数字\n- \\w可以匹配一个字母或数字\n- .可以匹配任意字符\n- *表示任意个字符（包括0个）\n- 用+表示至少一个字符\n- 用?表示0个或1个字符\n- 用{n}表示n个字符\n- 用{n,m}表示n-m个字符\n- \\s可以匹配一个空格（也包括Tab等空白符）\n- 要做更精确地匹配，可以用[]表示范围\t\n + [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n- [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n + (P|p)ython可以匹配'Python'或者'python'\n- ^表示行的开头\n- $表示行的结束\n- ^py$就变成了整行匹配,就只能匹配'py'\n\n### re模块\nPython提供re模块，包含所有正则表达式的功能。\nPython的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：\n```python\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\n```\n\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：\n```python\ntest = '用户输入的字符串'\nif re.match(r'正则表达式', test):\n    print('ok')\nelse:\n    print('failed')\n```\n\n### 切分字符串\n```python\n>>> re.split(r'[\\s\\,\\;]+', 'a,b;; c  d')\n['a', 'b', 'c', 'd']\n```\n\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：**^(\\d{3})-(\\d{3,8})$**分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\n```python\n>>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')\n>>> m\n<_sre.SRE_Match object; span=(0, 9), match='010-12345'>\n>>> m.group(0)\n'010-12345'\n>>> m.group(1)\n'010'\n>>> m.group(2)\n'12345'\n```\n注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。\n\n### 贪婪匹配\n正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：\n```python\n>>> re.match(r'^(\\d+)(0*)$', '102300').groups()\n('102300', '')\n```\n由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。\n必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：\n```python\n>>> re.match(r'^(\\d+?)(0*)$', '102300').groups()\n('1023', '00')\n```\n### 编译\n如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：\n```python\n>>> import re\n# 编译:\n>>> re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$')\n# 使用：\n>>> re_telephone.match('010-12345').groups()\n('010', '12345')\n>>> re_telephone.match('010-8086').groups()\n('010', '8086')\n```\n\n\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_正则表达式.md","raw":"title: python 3.5 正则表达式\ndate: 2016/8/20 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 基本用法\n- \\d可以匹配一个数字\n- \\w可以匹配一个字母或数字\n- .可以匹配任意字符\n- *表示任意个字符（包括0个）\n- 用+表示至少一个字符\n- 用?表示0个或1个字符\n- 用{n}表示n个字符\n- 用{n,m}表示n-m个字符\n- \\s可以匹配一个空格（也包括Tab等空白符）\n- 要做更精确地匹配，可以用[]表示范围\t\n + [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n- [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线\n + (P|p)ython可以匹配'Python'或者'python'\n- ^表示行的开头\n- $表示行的结束\n- ^py$就变成了整行匹配,就只能匹配'py'\n\n### re模块\nPython提供re模块，包含所有正则表达式的功能。\nPython的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：\n```python\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\n```\n\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：\n```python\ntest = '用户输入的字符串'\nif re.match(r'正则表达式', test):\n    print('ok')\nelse:\n    print('failed')\n```\n\n### 切分字符串\n```python\n>>> re.split(r'[\\s\\,\\;]+', 'a,b;; c  d')\n['a', 'b', 'c', 'd']\n```\n\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：**^(\\d{3})-(\\d{3,8})$**分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\n```python\n>>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')\n>>> m\n<_sre.SRE_Match object; span=(0, 9), match='010-12345'>\n>>> m.group(0)\n'010-12345'\n>>> m.group(1)\n'010'\n>>> m.group(2)\n'12345'\n```\n注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。\n\n### 贪婪匹配\n正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：\n```python\n>>> re.match(r'^(\\d+)(0*)$', '102300').groups()\n('102300', '')\n```\n由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。\n必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：\n```python\n>>> re.match(r'^(\\d+?)(0*)$', '102300').groups()\n('1023', '00')\n```\n### 编译\n如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：\n```python\n>>> import re\n# 编译:\n>>> re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$')\n# 使用：\n>>> re_telephone.match('010-12345').groups()\n('010', '12345')\n>>> re_telephone.match('010-8086').groups()\n('010', '8086')\n```\n\n\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_正则表达式","published":1,"updated":"2016-09-23T05:53:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxw002wrgrusb9dvn6v","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ul>\n<li>\\d可以匹配一个数字</li>\n<li>\\w可以匹配一个字母或数字</li>\n<li>.可以匹配任意字符</li>\n<li>*表示任意个字符（包括0个）</li>\n<li>用+表示至少一个字符</li>\n<li>用?表示0个或1个字符</li>\n<li>用{n}表示n个字符</li>\n<li>用{n,m}表示n-m个字符</li>\n<li>\\s可以匹配一个空格（也包括Tab等空白符）</li>\n<li>要做更精确地匹配，可以用[]表示范围    <ul>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>\n</ul>\n</li>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线<ul>\n<li>(P|p)ython可以匹配’Python’或者’python’</li>\n</ul>\n</li>\n<li>^表示行的开头</li>\n<li>$表示行的结束</li>\n<li>^py$就变成了整行匹配,就只能匹配’py’</li>\n</ul>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python提供re模块，包含所有正则表达式的功能。<br>Python的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = <span class=\"string\">r'ABC\\-001'</span> <span class=\"comment\"># Python的字符串</span></div><div class=\"line\"><span class=\"comment\"># 对应的正则表达式字符串不变：</span></div><div class=\"line\"><span class=\"comment\"># 'ABC\\-001'</span></div></pre></td></tr></table></figure></p>\n<p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"string\">'用户输入的字符串'</span></div><div class=\"line\"><span class=\"keyword\">if</span> re.match(<span class=\"string\">r'正则表达式'</span>, test):</div><div class=\"line\">    print(<span class=\"string\">'ok'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'failed'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"切分字符串\"><a href=\"#切分字符串\" class=\"headerlink\" title=\"切分字符串\"></a>切分字符串</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">r'[\\s\\,\\;]+'</span>, <span class=\"string\">'a,b;; c  d'</span>)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：<strong>^(\\d{3})-(\\d{3,8})$</strong>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = re.match(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>, <span class=\"string\">'010-12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</div><div class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">9</span>), match=<span class=\"string\">'010-12345'</span>&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"string\">'010-12345'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"string\">'010'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"string\">'12345'</span></div></pre></td></tr></table></figure></p>\n<p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p>\n<h3 id=\"贪婪匹配\"><a href=\"#贪婪匹配\" class=\"headerlink\" title=\"贪婪匹配\"></a>贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'102300'</span>, <span class=\"string\">''</span>)</div></pre></td></tr></table></figure></p>\n<p>由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+?)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'1023'</span>, <span class=\"string\">'00'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</div><div class=\"line\"><span class=\"comment\"># 编译:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>)</div><div class=\"line\"><span class=\"comment\"># 使用：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-12345'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-8086'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'8086'</span>)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><ul>\n<li>\\d可以匹配一个数字</li>\n<li>\\w可以匹配一个字母或数字</li>\n<li>.可以匹配任意字符</li>\n<li>*表示任意个字符（包括0个）</li>\n<li>用+表示至少一个字符</li>\n<li>用?表示0个或1个字符</li>\n<li>用{n}表示n个字符</li>\n<li>用{n,m}表示n-m个字符</li>\n<li>\\s可以匹配一个空格（也包括Tab等空白符）</li>\n<li>要做更精确地匹配，可以用[]表示范围    <ul>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>\n</ul>\n</li>\n<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线<ul>\n<li>(P|p)ython可以匹配’Python’或者’python’</li>\n</ul>\n</li>\n<li>^表示行的开头</li>\n<li>$表示行的结束</li>\n<li>^py$就变成了整行匹配,就只能匹配’py’</li>\n</ul>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python提供re模块，包含所有正则表达式的功能。<br>Python的字符串本身也用\\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s = <span class=\"string\">r'ABC\\-001'</span> <span class=\"comment\"># Python的字符串</span></div><div class=\"line\"><span class=\"comment\"># 对应的正则表达式字符串不变：</span></div><div class=\"line\"><span class=\"comment\"># 'ABC\\-001'</span></div></pre></td></tr></table></figure></p>\n<p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">test = <span class=\"string\">'用户输入的字符串'</span></div><div class=\"line\"><span class=\"keyword\">if</span> re.match(<span class=\"string\">r'正则表达式'</span>, test):</div><div class=\"line\">    print(<span class=\"string\">'ok'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'failed'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"切分字符串\"><a href=\"#切分字符串\" class=\"headerlink\" title=\"切分字符串\"></a>切分字符串</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.split(<span class=\"string\">r'[\\s\\,\\;]+'</span>, <span class=\"string\">'a,b;; c  d'</span>)</div><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]</div></pre></td></tr></table></figure>\n<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：<strong>^(\\d{3})-(\\d{3,8})$</strong>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = re.match(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>, <span class=\"string\">'010-12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</div><div class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">9</span>), match=<span class=\"string\">'010-12345'</span>&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"string\">'010-12345'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"string\">'010'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.group(<span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"string\">'12345'</span></div></pre></td></tr></table></figure></p>\n<p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p>\n<h3 id=\"贪婪匹配\"><a href=\"#贪婪匹配\" class=\"headerlink\" title=\"贪婪匹配\"></a>贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'102300'</span>, <span class=\"string\">''</span>)</div></pre></td></tr></table></figure></p>\n<p>由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.match(<span class=\"string\">r'^(\\d+?)(0*)$'</span>, <span class=\"string\">'102300'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'1023'</span>, <span class=\"string\">'00'</span>)</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</div><div class=\"line\"><span class=\"comment\"># 编译:</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class=\"string\">r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$'</span>)</div><div class=\"line\"><span class=\"comment\"># 使用：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-12345'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'12345'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re_telephone.match(<span class=\"string\">'010-8086'</span>).groups()</div><div class=\"line\">(<span class=\"string\">'010'</span>, <span class=\"string\">'8086'</span>)</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 进程与线程","date":"2016-08-18T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 多进程\n#### multiprocessing\nmultiprocessing模块就是跨平台版本的多进程模块。\nmultiprocessing模块提供了一个Process类来代表一个进程对象\n```python\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid()))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    print('Child process will start.')\n    p.start()\n    p.join()\n    print('Child process end.')\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n#### pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    p.join()\n    print('All subprocesses done.')\n```\n结果如下：\n```python\nParent process 669.\nWaiting for all subprocesses done...\nRun task 0 (671)...\nRun task 1 (672)...\nRun task 2 (673)...\nRun task 3 (674)...\nTask 2 runs 0.14 seconds.\nRun task 4 (673)...\nTask 1 runs 0.27 seconds.\nTask 3 runs 0.86 seconds.\nTask 0 runs 1.41 seconds.\nTask 4 runs 1.91 seconds.\nAll subprocesses done.\n```\n\n对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。\n注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：`p = ool(5)`就可以同时跑5个进程。\n\n#### 子进程&进程间通信\n到时候再看\n\n### 多线程\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```python\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while n < 5:\n        n = n + 1\n        print('thread %s >>> %s' % (threading.current_thread().name, n))\n        time.sleep(1)\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n```\n执行结果如下:\n\n```python\nthread MainThread is running...\nthread LoopThread is running...\nthread LoopThread >>> 1\nthread LoopThread >>> 2\nthread LoopThread >>> 3\nthread LoopThread >>> 4\nthread LoopThread >>> 5\nthread LoopThread ended.\nthread MainThread ended.\n```\n任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2\n\n#### Lock\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n```python\nbalance = 0\nlock = threading.Lock()\n\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n```\n创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try...finally来确保锁一定会被释放。\n\n\n### ThreadLocal\n一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。\n```python\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    print('Hello, %s (in %s)' % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n执行结果：\n\n```python\nHello, Alice (in Thread-A)\nHello, Bob (in Thread-B)\n```\n\n全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。\n\n可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。\n\nThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 分布式进程\n用到再看\n","source":"_posts/python_进程与线程.md","raw":"title: python 3.5 进程与线程\ndate: 2016/8/18 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n### 多进程\n#### multiprocessing\nmultiprocessing模块就是跨平台版本的多进程模块。\nmultiprocessing模块提供了一个Process类来代表一个进程对象\n```python\nfrom multiprocessing import Process\nimport os\n\n# 子进程要执行的代码\ndef run_proc(name):\n    print('Run child process %s (%s)...' % (name, os.getpid()))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Process(target=run_proc, args=('test',))\n    print('Child process will start.')\n    p.start()\n    p.join()\n    print('Child process end.')\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n#### pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```python\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print('Run task %s (%s)...' % (name, os.getpid()))\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print('Task %s runs %0.2f seconds.' % (name, (end - start)))\n\nif __name__=='__main__':\n    print('Parent process %s.' % os.getpid())\n    p = Pool(4)\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print('Waiting for all subprocesses done...')\n    p.close()\n    p.join()\n    print('All subprocesses done.')\n```\n结果如下：\n```python\nParent process 669.\nWaiting for all subprocesses done...\nRun task 0 (671)...\nRun task 1 (672)...\nRun task 2 (673)...\nRun task 3 (674)...\nTask 2 runs 0.14 seconds.\nRun task 4 (673)...\nTask 1 runs 0.27 seconds.\nTask 3 runs 0.86 seconds.\nTask 0 runs 1.41 seconds.\nTask 4 runs 1.91 seconds.\nAll subprocesses done.\n```\n\n对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。\n注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：`p = ool(5)`就可以同时跑5个进程。\n\n#### 子进程&进程间通信\n到时候再看\n\n### 多线程\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```python\nimport time, threading\n\n# 新线程执行的代码:\ndef loop():\n    print('thread %s is running...' % threading.current_thread().name)\n    n = 0\n    while n < 5:\n        n = n + 1\n        print('thread %s >>> %s' % (threading.current_thread().name, n))\n        time.sleep(1)\n    print('thread %s ended.' % threading.current_thread().name)\n\nprint('thread %s is running...' % threading.current_thread().name)\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint('thread %s ended.' % threading.current_thread().name)\n```\n执行结果如下:\n\n```python\nthread MainThread is running...\nthread LoopThread is running...\nthread LoopThread >>> 1\nthread LoopThread >>> 2\nthread LoopThread >>> 3\nthread LoopThread >>> 4\nthread LoopThread >>> 5\nthread LoopThread ended.\nthread MainThread ended.\n```\n任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2\n\n#### Lock\n多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n```python\nbalance = 0\nlock = threading.Lock()\n\ndef run_thread(n):\n    for i in range(100000):\n        # 先要获取锁:\n        lock.acquire()\n        try:\n            # 放心地改吧:\n            change_it(n)\n        finally:\n            # 改完了一定要释放锁:\n            lock.release()\n```\n创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try...finally来确保锁一定会被释放。\n\n\n### ThreadLocal\n一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。\n```python\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    # 获取当前线程关联的student:\n    std = local_school.student\n    print('Hello, %s (in %s)' % (std, threading.current_thread().name))\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n执行结果：\n\n```python\nHello, Alice (in Thread-A)\nHello, Bob (in Thread-B)\n```\n\n全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。\n\n可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。\n\nThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 分布式进程\n用到再看\n","slug":"python_进程与线程","published":1,"updated":"2016-09-23T05:53:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzxy002zrgru7moueni9","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h4><p>multiprocessing模块就是跨平台版本的多进程模块。<br>multiprocessing模块提供了一个Process类来代表一个进程对象<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 子进程要执行的代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</div><div class=\"line\">    print(<span class=\"string\">'Child process will start.'</span>)</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'Child process end.'</span>)</div></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<h4 id=\"pool\"><a href=\"#pool\" class=\"headerlink\" title=\"pool\"></a>pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">import</span> os, time, random</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\">    start = time.time()</div><div class=\"line\">    time.sleep(random.random() * <span class=\"number\">3</span>)</div><div class=\"line\">    end = time.time()</div><div class=\"line\">    print(<span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Pool(<span class=\"number\">4</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</div><div class=\"line\">        p.apply_async(long_time_task, args=(i,))</div><div class=\"line\">    print(<span class=\"string\">'Waiting for all subprocesses done...'</span>)</div><div class=\"line\">    p.close()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Parent process <span class=\"number\">669.</span></div><div class=\"line\">Waiting <span class=\"keyword\">for</span> all subprocesses done...</div><div class=\"line\">Run task <span class=\"number\">0</span> (<span class=\"number\">671</span>)...</div><div class=\"line\">Run task <span class=\"number\">1</span> (<span class=\"number\">672</span>)...</div><div class=\"line\">Run task <span class=\"number\">2</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Run task <span class=\"number\">3</span> (<span class=\"number\">674</span>)...</div><div class=\"line\">Task <span class=\"number\">2</span> runs <span class=\"number\">0.14</span> seconds.</div><div class=\"line\">Run task <span class=\"number\">4</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Task <span class=\"number\">1</span> runs <span class=\"number\">0.27</span> seconds.</div><div class=\"line\">Task <span class=\"number\">3</span> runs <span class=\"number\">0.86</span> seconds.</div><div class=\"line\">Task <span class=\"number\">0</span> runs <span class=\"number\">1.41</span> seconds.</div><div class=\"line\">Task <span class=\"number\">4</span> runs <span class=\"number\">1.91</span> seconds.</div><div class=\"line\">All subprocesses done.</div></pre></td></tr></table></figure></p>\n<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = ool(5)</code>就可以同时跑5个进程。</p>\n<h4 id=\"子进程-amp-进程间通信\"><a href=\"#子进程-amp-进程间通信\" class=\"headerlink\" title=\"子进程&amp;进程间通信\"></a>子进程&amp;进程间通信</h4><p>到时候再看</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time, threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 新线程执行的代码:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">    n = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class=\"line\">        time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\">    print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">t = threading.Thread(target=loop, name=<span class=\"string\">'LoopThread'</span>)</div><div class=\"line\">t.start()</div><div class=\"line\">t.join()</div><div class=\"line\">print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure></p>\n<p>执行结果如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread MainThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">1</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">2</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">3</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">4</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">5</span></div><div class=\"line\">thread LoopThread ended.</div><div class=\"line\">thread MainThread ended.</div></pre></td></tr></table></figure>\n<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">balance = <span class=\"number\">0</span></div><div class=\"line\">lock = threading.Lock()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100000</span>):</div><div class=\"line\">        <span class=\"comment\"># 先要获取锁:</span></div><div class=\"line\">        lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># 放心地改吧:</span></div><div class=\"line\">            change_it(n)</div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># 改完了一定要释放锁:</span></div><div class=\"line\">            lock.release()</div></pre></td></tr></table></figure></p>\n<p>创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></div><div class=\"line\">local_school = threading.local()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 获取当前线程关联的student:</span></div><div class=\"line\">    std = local_school.student</div><div class=\"line\">    print(<span class=\"string\">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></div><div class=\"line\">    local_school.student = name</div><div class=\"line\">    process_student()</div><div class=\"line\"></div><div class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</div><div class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</div><div class=\"line\">t1.start()</div><div class=\"line\">t2.start()</div><div class=\"line\">t1.join()</div><div class=\"line\">t2.join()</div></pre></td></tr></table></figure></p>\n<p>执行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello, Alice (<span class=\"keyword\">in</span> Thread-A)</div><div class=\"line\">Hello, Bob (<span class=\"keyword\">in</span> Thread-B)</div></pre></td></tr></table></figure>\n<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>\n<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>\n<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>用到再看</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><h4 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h4><p>multiprocessing模块就是跨平台版本的多进程模块。<br>multiprocessing模块提供了一个Process类来代表一个进程对象<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</div><div class=\"line\"><span class=\"keyword\">import</span> os</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 子进程要执行的代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_proc</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</div><div class=\"line\">    print(<span class=\"string\">'Child process will start.'</span>)</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'Child process end.'</span>)</div></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<h4 id=\"pool\"><a href=\"#pool\" class=\"headerlink\" title=\"pool\"></a>pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Pool</div><div class=\"line\"><span class=\"keyword\">import</span> os, time, random</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">long_time_task</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class=\"line\">    start = time.time()</div><div class=\"line\">    time.sleep(random.random() * <span class=\"number\">3</span>)</div><div class=\"line\">    end = time.time()</div><div class=\"line\">    print(<span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</div><div class=\"line\">    print(<span class=\"string\">'Parent process %s.'</span> % os.getpid())</div><div class=\"line\">    p = Pool(<span class=\"number\">4</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</div><div class=\"line\">        p.apply_async(long_time_task, args=(i,))</div><div class=\"line\">    print(<span class=\"string\">'Waiting for all subprocesses done...'</span>)</div><div class=\"line\">    p.close()</div><div class=\"line\">    p.join()</div><div class=\"line\">    print(<span class=\"string\">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Parent process <span class=\"number\">669.</span></div><div class=\"line\">Waiting <span class=\"keyword\">for</span> all subprocesses done...</div><div class=\"line\">Run task <span class=\"number\">0</span> (<span class=\"number\">671</span>)...</div><div class=\"line\">Run task <span class=\"number\">1</span> (<span class=\"number\">672</span>)...</div><div class=\"line\">Run task <span class=\"number\">2</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Run task <span class=\"number\">3</span> (<span class=\"number\">674</span>)...</div><div class=\"line\">Task <span class=\"number\">2</span> runs <span class=\"number\">0.14</span> seconds.</div><div class=\"line\">Run task <span class=\"number\">4</span> (<span class=\"number\">673</span>)...</div><div class=\"line\">Task <span class=\"number\">1</span> runs <span class=\"number\">0.27</span> seconds.</div><div class=\"line\">Task <span class=\"number\">3</span> runs <span class=\"number\">0.86</span> seconds.</div><div class=\"line\">Task <span class=\"number\">0</span> runs <span class=\"number\">1.41</span> seconds.</div><div class=\"line\">Task <span class=\"number\">4</span> runs <span class=\"number\">1.91</span> seconds.</div><div class=\"line\">All subprocesses done.</div></pre></td></tr></table></figure></p>\n<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = ool(5)</code>就可以同时跑5个进程。</p>\n<h4 id=\"子进程-amp-进程间通信\"><a href=\"#子进程-amp-进程间通信\" class=\"headerlink\" title=\"子进程&amp;进程间通信\"></a>子进程&amp;进程间通信</h4><p>到时候再看</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> time, threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 新线程执行的代码:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">loop</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">    n = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; <span class=\"number\">5</span>:</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">        print(<span class=\"string\">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class=\"line\">        time.sleep(<span class=\"number\">1</span>)</div><div class=\"line\">    print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div><div class=\"line\"></div><div class=\"line\">print(<span class=\"string\">'thread %s is running...'</span> % threading.current_thread().name)</div><div class=\"line\">t = threading.Thread(target=loop, name=<span class=\"string\">'LoopThread'</span>)</div><div class=\"line\">t.start()</div><div class=\"line\">t.join()</div><div class=\"line\">print(<span class=\"string\">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure></p>\n<p>执行结果如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread MainThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread <span class=\"keyword\">is</span> running...</div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">1</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">2</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">3</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">4</span></div><div class=\"line\">thread LoopThread &gt;&gt;&gt; <span class=\"number\">5</span></div><div class=\"line\">thread LoopThread ended.</div><div class=\"line\">thread MainThread ended.</div></pre></td></tr></table></figure>\n<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">balance = <span class=\"number\">0</span></div><div class=\"line\">lock = threading.Lock()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">100000</span>):</div><div class=\"line\">        <span class=\"comment\"># 先要获取锁:</span></div><div class=\"line\">        lock.acquire()</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># 放心地改吧:</span></div><div class=\"line\">            change_it(n)</div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># 改完了一定要释放锁:</span></div><div class=\"line\">            lock.release()</div></pre></td></tr></table></figure></p>\n<p>创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> threading</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></div><div class=\"line\">local_school = threading.local()</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 获取当前线程关联的student:</span></div><div class=\"line\">    std = local_school.student</div><div class=\"line\">    print(<span class=\"string\">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></div><div class=\"line\">    local_school.student = name</div><div class=\"line\">    process_student()</div><div class=\"line\"></div><div class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</div><div class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</div><div class=\"line\">t1.start()</div><div class=\"line\">t2.start()</div><div class=\"line\">t1.join()</div><div class=\"line\">t2.join()</div></pre></td></tr></table></figure></p>\n<p>执行结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello, Alice (<span class=\"keyword\">in</span> Thread-A)</div><div class=\"line\">Hello, Bob (<span class=\"keyword\">in</span> Thread-B)</div></pre></td></tr></table></figure>\n<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>\n<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>\n<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>用到再看</p>"},{"title":"python 3.5 面向对象编程","date":"2016-08-09T02:07:12.000Z","_content":"\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 类和实例\n定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。\n```python\nclass Student(object)\n\tpass\n```\n\n定义好类，就可以创建出实例了。\n```python\nbart = Student()\n```\n\n可以**自由地给一个实例变量绑定属性**，比如，给实例bart绑定一个name属性：\n```python\nbart.name = 'Zachary'\n```\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。\n\n创建实例的时候可以使用特殊的**__init__**方法初始化：\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n```\n注意：\n1. 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n2. 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。\n\n另外：\n1. 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n2. 如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。\n\n### 访问限制\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。\n\noc中使用.h和.m定义属性的方式区分共有私有。\nJava中通过public，private的方式区分共有私有。\npython通过__的方式区分共有私有。\n\n以_开头的变量表示：可以访问，但是最好视为私有变量。\n\n### 继承和多态\n继承和多态和其他语言没什么不同，就不重复了。\n\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了\n\n### 获取对象信息\n#### type\n使用type()函数,判断对象类型\n```python\n>>> import types\n>>> def fn():\n...     pass\n...\n>>> type(fn)==types.FunctionType\nTrue\n>>> type(abs)==types.BuiltinFunctionType\nTrue\n>>> type(lambda x: x)==types.LambdaType\nTrue\n>>> type((x for x in range(10)))==types.GeneratorType\nTrue\n```\n\n#### isinstance()\n使用isinstance()函数,判断class的继承关系\n判断基本类型：\n```python\n>>> isinstance('a', str)\nTrue\n>>> isinstance(123, int)\nTrue\n>>> isinstance(b'a', bytes)\nTrue\n```\n判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：\n```python\n>>> isinstance([1, 2, 3], (list, tuple))\nTrue\n>>> isinstance((1, 2, 3), (list, tuple))\nTrue\n```\n\n#### dir()\n如果要获得一个对象的**所有属性和方法**，可以使用dir()函数，它返回一个包含字符串的list.\n\n仅仅把属性和方法列出来是不够的，配合**getattr()**、**setattr()**以及**hasattr()**，我们可以直接**操作一个对象的状态**：\n```python\n>>> class MyObject(object):\n...     def __init__(self):\n...         self.x = 9\n...     def power(self):\n...         return self.x * self.x\n...\n>>> obj = MyObject()\n```\n紧接着，可以测试该对象的属性：\n```python\n>>> hasattr(obj, 'x') # 有属性'x'吗？\nTrue\n>>> obj.x\n9\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nFalse\n>>> setattr(obj, 'y', 19) # 设置一个属性'y'\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nTrue\n>>> getattr(obj, 'y') # 获取属性'y'\n19\n>>> obj.y # 获取属性'y'\n19\n```\n如果试图获取不存在的属性，会抛出AttributeError的错误\n可以传入一个default参数，如果属性不存在，就返回默认值：\n```python\n>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404\n404\n```\n\n也可以获得对象的方法：\n```python\n>>> hasattr(obj, 'power') # 有属性'power'吗？\nTrue\n>>> getattr(obj, 'power') # 获取属性'power'\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn\n>>> fn # fn指向obj.power\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn() # 调用fn()与调用obj.power()是一样的\n81\n```\n\n**感觉上，用set，get，has方法和直接设置没什么太大区别。**\n\n### 实例属性和类属性\npython中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：\n```python\n>>> class Student(object):\n...     name = 'Student'\n...\n>>> s = Student() # 创建实例s\n>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性\nStudent\n>>> print(Student.name) # 打印类的name属性\nStudent\n>>> s.name = 'Michael' # 给实例绑定name属性\n>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性\nMichael\n>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问\nStudent\n>>> del s.name # 如果删除实例的name属性\n>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了\nStudent\n```\n在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_面向对象编程.md","raw":"title: python 3.5 面向对象编程\ndate: 2016/8/9 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 类和实例\n定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。\n```python\nclass Student(object)\n\tpass\n```\n\n定义好类，就可以创建出实例了。\n```python\nbart = Student()\n```\n\n可以**自由地给一个实例变量绑定属性**，比如，给实例bart绑定一个name属性：\n```python\nbart.name = 'Zachary'\n```\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。\n\n创建实例的时候可以使用特殊的**__init__**方法初始化：\n```python\nclass Student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n```\n注意：\n1. 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n2. 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。\n\n另外：\n1. 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数\n2. 如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。\n\n### 访问限制\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。\n\noc中使用.h和.m定义属性的方式区分共有私有。\nJava中通过public，private的方式区分共有私有。\npython通过__的方式区分共有私有。\n\n以_开头的变量表示：可以访问，但是最好视为私有变量。\n\n### 继承和多态\n继承和多态和其他语言没什么不同，就不重复了。\n\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了\n\n### 获取对象信息\n#### type\n使用type()函数,判断对象类型\n```python\n>>> import types\n>>> def fn():\n...     pass\n...\n>>> type(fn)==types.FunctionType\nTrue\n>>> type(abs)==types.BuiltinFunctionType\nTrue\n>>> type(lambda x: x)==types.LambdaType\nTrue\n>>> type((x for x in range(10)))==types.GeneratorType\nTrue\n```\n\n#### isinstance()\n使用isinstance()函数,判断class的继承关系\n判断基本类型：\n```python\n>>> isinstance('a', str)\nTrue\n>>> isinstance(123, int)\nTrue\n>>> isinstance(b'a', bytes)\nTrue\n```\n判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：\n```python\n>>> isinstance([1, 2, 3], (list, tuple))\nTrue\n>>> isinstance((1, 2, 3), (list, tuple))\nTrue\n```\n\n#### dir()\n如果要获得一个对象的**所有属性和方法**，可以使用dir()函数，它返回一个包含字符串的list.\n\n仅仅把属性和方法列出来是不够的，配合**getattr()**、**setattr()**以及**hasattr()**，我们可以直接**操作一个对象的状态**：\n```python\n>>> class MyObject(object):\n...     def __init__(self):\n...         self.x = 9\n...     def power(self):\n...         return self.x * self.x\n...\n>>> obj = MyObject()\n```\n紧接着，可以测试该对象的属性：\n```python\n>>> hasattr(obj, 'x') # 有属性'x'吗？\nTrue\n>>> obj.x\n9\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nFalse\n>>> setattr(obj, 'y', 19) # 设置一个属性'y'\n>>> hasattr(obj, 'y') # 有属性'y'吗？\nTrue\n>>> getattr(obj, 'y') # 获取属性'y'\n19\n>>> obj.y # 获取属性'y'\n19\n```\n如果试图获取不存在的属性，会抛出AttributeError的错误\n可以传入一个default参数，如果属性不存在，就返回默认值：\n```python\n>>> getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404\n404\n```\n\n也可以获得对象的方法：\n```python\n>>> hasattr(obj, 'power') # 有属性'power'吗？\nTrue\n>>> getattr(obj, 'power') # 获取属性'power'\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn\n>>> fn # fn指向obj.power\n<bound method MyObject.power of <__main__.MyObject object at 0x10077a6a0>>\n>>> fn() # 调用fn()与调用obj.power()是一样的\n81\n```\n\n**感觉上，用set，get，has方法和直接设置没什么太大区别。**\n\n### 实例属性和类属性\npython中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：\n```python\n>>> class Student(object):\n...     name = 'Student'\n...\n>>> s = Student() # 创建实例s\n>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性\nStudent\n>>> print(Student.name) # 打印类的name属性\nStudent\n>>> s.name = 'Michael' # 给实例绑定name属性\n>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性\nMichael\n>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问\nStudent\n>>> del s.name # 如果删除实例的name属性\n>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了\nStudent\n```\n在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_面向对象编程","published":1,"updated":"2016-09-23T05:53:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzy20033rgruirfymhbe","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h3><p>定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Student(object)</div><div class=\"line\">\tpass</div></pre></td></tr></table></figure></p>\n<p>定义好类，就可以创建出实例了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart = Student()</div></pre></td></tr></table></figure></p>\n<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart.name = <span class=\"string\">'Zachary'</span></div></pre></td></tr></table></figure></p>\n<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>\n<p>创建实例的时候可以使用特殊的<strong><strong>init</strong></strong>方法初始化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, score)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\">        self.score = score</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</li>\n<li>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</li>\n</ol>\n<p>另外：</p>\n<ol>\n<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</li>\n<li>如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。</li>\n</ol>\n<h3 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>\n<p>oc中使用.h和.m定义属性的方式区分共有私有。<br>Java中通过public，private的方式区分共有私有。<br>python通过__的方式区分共有私有。</p>\n<p>以_开头的变量表示：可以访问，但是最好视为私有变量。</p>\n<h3 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h3><p>继承和多态和其他语言没什么不同，就不重复了。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</p>\n<h3 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>使用type()函数,判断对象类型<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> types</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">()</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">pass</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(<span class=\"keyword\">lambda</span> x: x)==types.LambdaType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)))==types.GeneratorType</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h4><p>使用isinstance()函数,判断class的继承关系<br>判断基本类型：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">'a'</span>, str)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"number\">123</span>, int)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">b'a'</span>, bytes)</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<p>判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance((<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h4><p>如果要获得一个对象的<strong>所有属性和方法</strong>，可以使用dir()函数，它返回一个包含字符串的list.</p>\n<p>仅仅把属性和方法列出来是不够的，配合<strong>getattr()</strong>、<strong>setattr()</strong>以及<strong>hasattr()</strong>，我们可以直接<strong>操作一个对象的状态</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.x = <span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> self.x * self.x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure></p>\n<p>紧接着，可以测试该对象的属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'x'</span>) <span class=\"comment\"># 有属性'x'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.x</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">False</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>) <span class=\"comment\"># 设置一个属性'y'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.y <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div></pre></td></tr></table></figure></p>\n<p>如果试图获取不存在的属性，会抛出AttributeError的错误<br>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'z'</span>, <span class=\"number\">404</span>) <span class=\"comment\"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class=\"line\"><span class=\"number\">404</span></div></pre></td></tr></table></figure></p>\n<p>也可以获得对象的方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 有属性'power'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn = getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'并赋值到变量fn</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn <span class=\"comment\"># fn指向obj.power</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn() <span class=\"comment\"># 调用fn()与调用obj.power()是一样的</span></div><div class=\"line\"><span class=\"number\">81</span></div></pre></td></tr></table></figure></p>\n<p><strong>感觉上，用set，get，has方法和直接设置没什么太大区别。</strong></p>\n<h3 id=\"实例属性和类属性\"><a href=\"#实例属性和类属性\" class=\"headerlink\" title=\"实例属性和类属性\"></a>实例属性和类属性</h3><p>python中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    name = <span class=\"string\">'Student'</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student() <span class=\"comment\"># 创建实例s</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 打印类的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.name = <span class=\"string\">'Michael'</span> <span class=\"comment\"># 给实例绑定name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class=\"line\">Michael</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">del</span> s.name <span class=\"comment\"># 如果删除实例的name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class=\"line\">Student</div></pre></td></tr></table></figure></p>\n<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h3><p>定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Student(object)</div><div class=\"line\">\tpass</div></pre></td></tr></table></figure></p>\n<p>定义好类，就可以创建出实例了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart = Student()</div></pre></td></tr></table></figure></p>\n<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bart.name = <span class=\"string\">'Zachary'</span></div></pre></td></tr></table></figure></p>\n<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>\n<p>创建实例的时候可以使用特殊的<strong><strong>init</strong></strong>方法初始化：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, score)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\">        self.score = score</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</li>\n<li>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</li>\n</ol>\n<p>另外：</p>\n<ol>\n<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</li>\n<li>如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。</li>\n</ol>\n<h3 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>\n<p>oc中使用.h和.m定义属性的方式区分共有私有。<br>Java中通过public，private的方式区分共有私有。<br>python通过__的方式区分共有私有。</p>\n<p>以_开头的变量表示：可以访问，但是最好视为私有变量。</p>\n<h3 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h3><p>继承和多态和其他语言没什么不同，就不重复了。</p>\n<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</p>\n<h3 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>使用type()函数,判断对象类型<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> types</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">()</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">pass</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type(<span class=\"keyword\">lambda</span> x: x)==types.LambdaType</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>type((x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>)))==types.GeneratorType</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h4><p>使用isinstance()函数,判断class的继承关系<br>判断基本类型：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">'a'</span>, str)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"number\">123</span>, int)</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance(<span class=\"string\">b'a'</span>, bytes)</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<p>判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>isinstance((<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>), (list, tuple))</div><div class=\"line\"><span class=\"keyword\">True</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h4><p>如果要获得一个对象的<strong>所有属性和方法</strong>，可以使用dir()函数，它返回一个包含字符串的list.</p>\n<p>仅仅把属性和方法列出来是不够的，配合<strong>getattr()</strong>、<strong>setattr()</strong>以及<strong>hasattr()</strong>，我们可以直接<strong>操作一个对象的状态</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.x = <span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> self.x * self.x</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure></p>\n<p>紧接着，可以测试该对象的属性：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'x'</span>) <span class=\"comment\"># 有属性'x'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.x</div><div class=\"line\"><span class=\"number\">9</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">False</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>) <span class=\"comment\"># 设置一个属性'y'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 有属性'y'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'y'</span>) <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>obj.y <span class=\"comment\"># 获取属性'y'</span></div><div class=\"line\"><span class=\"number\">19</span></div></pre></td></tr></table></figure></p>\n<p>如果试图获取不存在的属性，会抛出AttributeError的错误<br>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'z'</span>, <span class=\"number\">404</span>) <span class=\"comment\"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class=\"line\"><span class=\"number\">404</span></div></pre></td></tr></table></figure></p>\n<p>也可以获得对象的方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 有属性'power'吗？</span></div><div class=\"line\"><span class=\"keyword\">True</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn = getattr(obj, <span class=\"string\">'power'</span>) <span class=\"comment\"># 获取属性'power'并赋值到变量fn</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn <span class=\"comment\"># fn指向obj.power</span></div><div class=\"line\">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class=\"number\">0x10077a6a0</span>&gt;&gt;</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>fn() <span class=\"comment\"># 调用fn()与调用obj.power()是一样的</span></div><div class=\"line\"><span class=\"number\">81</span></div></pre></td></tr></table></figure></p>\n<p><strong>感觉上，用set，get，has方法和直接设置没什么太大区别。</strong></p>\n<h3 id=\"实例属性和类属性\"><a href=\"#实例属性和类属性\" class=\"headerlink\" title=\"实例属性和类属性\"></a>实例属性和类属性</h3><p>python中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    name = <span class=\"string\">'Student'</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student() <span class=\"comment\"># 创建实例s</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 打印类的name属性</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.name = <span class=\"string\">'Michael'</span> <span class=\"comment\"># 给实例绑定name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class=\"line\">Michael</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student.name) <span class=\"comment\"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class=\"line\">Student</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">del</span> s.name <span class=\"comment\"># 如果删除实例的name属性</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(s.name) <span class=\"comment\"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class=\"line\">Student</div></pre></td></tr></table></figure></p>\n<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 面向对象高级编程","date":"2016-08-10T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 使用__slots__\n我们可以给实例绑定任何属性和方法。\n创建实例：\n```python\nclass Student(object):\n    pass\n```\n\n给实例绑定方法：\n```python\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n**注意：**\n1. 这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 \n2. MethodType()这个方法不要用在给类绑定属性上。\n\n给类绑定方法:\n```python\n>>> def set_score(self, score):\n...     self.score = score\n...\n>>> Student.set_score = set_score\n```\n**注意：**像这样给类绑定方法后，实例变量不用自己传入self了。\n\n如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用__slots__来限制属性。\n```python\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即**__slots__属性并不会被继承**\n\nslots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是__slots__的副作用。\n\n### 使用@property\n类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。\n```python\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n注意：\n1. 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.\n2. 只定义getter方法，不定义setter方法就是一个只读属性。\n\n### 多重继承\npython允许多重继承：\n```python\nclass Dog(Mammal, Runnable):\n    pass\n```\n**如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。**\n\n在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。\n```python\nclass Dog(Mammal, RunnableMixIn, CarnivorousMixIn):\n    pass\n```\n\n感觉MixIn就是个约定啊，并没有太多实质效果啊=。=\n\n### 定制类\n形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。\n\n#### __str__\n怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：\n```python\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n#### __iter__\n如果一个类想被用于**for...in**循环，类似list或tuple那样，就必须实现一个**__iter__()**方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的**__next__()**方法拿到循环的下一个值，直到遇到**StopIteration**错误时退出循环。\n```python\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration();\n        return self.a # 返回下一个值\n\n>>> for n in Fib():\n...     print(n)\n```\n\n#### __getitem__\n要表现得像list那样按照下标取出元素，需要实现__getitem__()方法。__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice:\n```python\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n#### __getattr__\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。\n```python\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\n```\n\n当调用**不存在的属性**时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值.\n\n#### __call__\n任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。\n```python\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n\n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n### 枚举类\nPython提供了Enum类来实现这个功能\n```python\nfrom enum import Enum\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\nfor name, member in Month.__members__.items():\n    print(name, '=>', member, ',', member.value)\n```\n\nvalue属性则是自动赋给成员的int常量，默认从1开始计数。\n如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：\n\n```python\nfrom enum import Enum, unique\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n### 元类\n没看\n\n最后再次感谢廖老师的辛勤劳动。","source":"_posts/python_面向对象高级编程.md","raw":"title: python 3.5 面向对象高级编程\ndate: 2016/8/10 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n### 使用__slots__\n我们可以给实例绑定任何属性和方法。\n创建实例：\n```python\nclass Student(object):\n    pass\n```\n\n给实例绑定方法：\n```python\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n```\n**注意：**\n1. 这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 \n2. MethodType()这个方法不要用在给类绑定属性上。\n\n给类绑定方法:\n```python\n>>> def set_score(self, score):\n...     self.score = score\n...\n>>> Student.set_score = set_score\n```\n**注意：**像这样给类绑定方法后，实例变量不用自己传入self了。\n\n如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用__slots__来限制属性。\n```python\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即**__slots__属性并不会被继承**\n\nslots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是__slots__的副作用。\n\n### 使用@property\n类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。\n```python\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n```\n注意：\n1. 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.\n2. 只定义getter方法，不定义setter方法就是一个只读属性。\n\n### 多重继承\npython允许多重继承：\n```python\nclass Dog(Mammal, Runnable):\n    pass\n```\n**如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。**\n\n在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。\n```python\nclass Dog(Mammal, RunnableMixIn, CarnivorousMixIn):\n    pass\n```\n\n感觉MixIn就是个约定啊，并没有太多实质效果啊=。=\n\n### 定制类\n形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。\n\n#### __str__\n怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：\n```python\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n```\n\n#### __iter__\n如果一个类想被用于**for...in**循环，类似list或tuple那样，就必须实现一个**__iter__()**方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的**__next__()**方法拿到循环的下一个值，直到遇到**StopIteration**错误时退出循环。\n```python\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration();\n        return self.a # 返回下一个值\n\n>>> for n in Fib():\n...     print(n)\n```\n\n#### __getitem__\n要表现得像list那样按照下标取出元素，需要实现__getitem__()方法。__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice:\n```python\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n#### __getattr__\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。\n```python\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\n```\n\n当调用**不存在的属性**时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值.\n\n#### __call__\n任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。\n```python\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n\n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n```\n\n### 枚举类\nPython提供了Enum类来实现这个功能\n```python\nfrom enum import Enum\nMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))\n\nfor name, member in Month.__members__.items():\n    print(name, '=>', member, ',', member.value)\n```\n\nvalue属性则是自动赋给成员的int常量，默认从1开始计数。\n如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：\n\n```python\nfrom enum import Enum, unique\nclass Weekday(Enum):\n    Sun = 0 # Sun的value被设定为0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n```\n\n### 元类\n没看\n\n最后再次感谢廖老师的辛勤劳动。","slug":"python_面向对象高级编程","published":1,"updated":"2016-09-23T05:53:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzy40036rgrurix5k8ly","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"使用slots\"><a href=\"#使用slots\" class=\"headerlink\" title=\"使用slots\"></a>使用<strong>slots</strong></h3><p>我们可以给实例绑定任何属性和方法。<br>创建实例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>给实例绑定方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_age</span><span class=\"params\">(self, age)</span>:</span> <span class=\"comment\"># 定义一个函数作为实例方法</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.age = age</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> types <span class=\"keyword\">import</span> MethodType</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class=\"comment\"># 给实例绑定一个方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age(<span class=\"number\">25</span>) <span class=\"comment\"># 调用实例方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.age <span class=\"comment\"># 测试结果</span></div><div class=\"line\"><span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 </li>\n<li>MethodType()这个方法不要用在给类绑定属性上。</li>\n</ol>\n<p>给类绑定方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(self, score)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.score = score</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>像这样给类绑定方法后，实例变量不用自己传入self了。</p>\n<p>如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用<strong>slots</strong>来限制属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure></p>\n<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即<strong><strong>slots</strong>属性并不会被继承</strong></p>\n<p>slots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是<strong>slots</strong>的副作用。</p>\n<h3 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用@property</h3><p>类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @property</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self._score</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @score.setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self, value)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</div><div class=\"line\">        self._score = value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.</li>\n<li>只定义getter方法，不定义setter方法就是一个只读属性。</li>\n</ol>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>python允许多重继承：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, Runnable)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p><strong>如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。</strong></p>\n<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>感觉MixIn就是个约定啊，并没有太多实质效果啊=。=</p>\n<h3 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h3><p>形如<strong>xxx</strong>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>\n<h4 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a><strong>str</strong></h4><p>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.name = name</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % self.name</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student(<span class=\"string\">'Michael'</span>))</div><div class=\"line\">Student object (name: Michael)</div></pre></td></tr></table></figure></p>\n<h4 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"iter\"></a><strong>iter</strong></h4><p>如果一个类想被用于<strong>for…in</strong>循环，类似list或tuple那样，就必须实现一个<strong><strong>iter</strong>()</strong>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong><strong>next</strong>()</strong>方法拿到循环的下一个值，直到遇到<strong>StopIteration</strong>错误时退出循环。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span> <span class=\"comment\"># 初始化两个计数器a，b</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = self.b, self.a + self.b <span class=\"comment\"># 计算下一个值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.a &gt; <span class=\"number\">100000</span>: <span class=\"comment\"># 退出循环的条件</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> StopIteration();</div><div class=\"line\">        <span class=\"keyword\">return</span> self.a <span class=\"comment\"># 返回下一个值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib():</div><div class=\"line\"><span class=\"meta\">... </span>    print(n)</div></pre></td></tr></table></figure></p>\n<h4 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"getitem\"></a><strong>getitem</strong></h4><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int): <span class=\"comment\"># n是索引</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> a</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice): <span class=\"comment\"># n是切片</span></div><div class=\"line\">            start = n.start</div><div class=\"line\">            stop = n.stop</div><div class=\"line\">            <span class=\"keyword\">if</span> start <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">                start = <span class=\"number\">0</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            L = []</div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(stop):</div><div class=\"line\">                <span class=\"keyword\">if</span> x &gt;= start:</div><div class=\"line\">                    L.append(a)</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr\"></a><strong>getattr</strong></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.name = <span class=\"string\">'Michael'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, attr)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></div></pre></td></tr></table></figure></p>\n<p>当调用<strong>不存在的属性</strong>时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a><strong>call</strong></h4><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % self.name)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"string\">'Michael'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s() <span class=\"comment\"># self参数不要传入</span></div><div class=\"line\">My name <span class=\"keyword\">is</span> Michael.</div></pre></td></tr></table></figure></p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><p>Python提供了Enum类来实现这个功能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum</div><div class=\"line\">Month = Enum(<span class=\"string\">'Month'</span>, (<span class=\"string\">'Jan'</span>, <span class=\"string\">'Feb'</span>, <span class=\"string\">'Mar'</span>, <span class=\"string\">'Apr'</span>, <span class=\"string\">'May'</span>, <span class=\"string\">'Jun'</span>, <span class=\"string\">'Jul'</span>, <span class=\"string\">'Aug'</span>, <span class=\"string\">'Sep'</span>, <span class=\"string\">'Oct'</span>, <span class=\"string\">'Nov'</span>, <span class=\"string\">'Dec'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> name, member <span class=\"keyword\">in</span> Month.__members__.items():</div><div class=\"line\">    print(name, <span class=\"string\">'=&gt;'</span>, member, <span class=\"string\">','</span>, member.value)</div></pre></td></tr></table></figure></p>\n<p>value属性则是自动赋给成员的int常量，默认从1开始计数。<br>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum, unique</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Weekday</span><span class=\"params\">(Enum)</span>:</span></div><div class=\"line\">    Sun = <span class=\"number\">0</span> <span class=\"comment\"># Sun的value被设定为0</span></div><div class=\"line\">    Mon = <span class=\"number\">1</span></div><div class=\"line\">    Tue = <span class=\"number\">2</span></div><div class=\"line\">    Wed = <span class=\"number\">3</span></div><div class=\"line\">    Thu = <span class=\"number\">4</span></div><div class=\"line\">    Fri = <span class=\"number\">5</span></div><div class=\"line\">    Sat = <span class=\"number\">6</span></div></pre></td></tr></table></figure>\n<h3 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h3><p>没看</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"使用slots\"><a href=\"#使用slots\" class=\"headerlink\" title=\"使用slots\"></a>使用<strong>slots</strong></h3><p>我们可以给实例绑定任何属性和方法。<br>创建实例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>给实例绑定方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_age</span><span class=\"params\">(self, age)</span>:</span> <span class=\"comment\"># 定义一个函数作为实例方法</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.age = age</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> types <span class=\"keyword\">import</span> MethodType</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class=\"comment\"># 给实例绑定一个方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.set_age(<span class=\"number\">25</span>) <span class=\"comment\"># 调用实例方法</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s.age <span class=\"comment\"># 测试结果</span></div><div class=\"line\"><span class=\"number\">25</span></div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 </li>\n<li>MethodType()这个方法不要用在给类绑定属性上。</li>\n</ol>\n<p>给类绑定方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(self, score)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    self.score = score</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>像这样给类绑定方法后，实例变量不用自己传入self了。</p>\n<p>如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用<strong>slots</strong>来限制属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure></p>\n<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即<strong><strong>slots</strong>属性并不会被继承</strong></p>\n<p>slots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是<strong>slots</strong>的副作用。</p>\n<h3 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用@property</h3><p>类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @property</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self._score</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @score.setter</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self, value)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</div><div class=\"line\">        self._score = value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.</li>\n<li>只定义getter方法，不定义setter方法就是一个只读属性。</li>\n</ol>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>python允许多重继承：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, Runnable)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p><strong>如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。</strong></p>\n<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span><span class=\"params\">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure></p>\n<p>感觉MixIn就是个约定啊，并没有太多实质效果啊=。=</p>\n<h3 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h3><p>形如<strong>xxx</strong>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>\n<h4 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a><strong>str</strong></h4><p>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        self.name = name</div><div class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % self.name</div><div class=\"line\">...</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(Student(<span class=\"string\">'Michael'</span>))</div><div class=\"line\">Student object (name: Michael)</div></pre></td></tr></table></figure></p>\n<h4 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"iter\"></a><strong>iter</strong></h4><p>如果一个类想被用于<strong>for…in</strong>循环，类似list或tuple那样，就必须实现一个<strong><strong>iter</strong>()</strong>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong><strong>next</strong>()</strong>方法拿到循环的下一个值，直到遇到<strong>StopIteration</strong>错误时退出循环。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = <span class=\"number\">0</span>, <span class=\"number\">1</span> <span class=\"comment\"># 初始化两个计数器a，b</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">return</span> self <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.a, self.b = self.b, self.a + self.b <span class=\"comment\"># 计算下一个值</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.a &gt; <span class=\"number\">100000</span>: <span class=\"comment\"># 退出循环的条件</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> StopIteration();</div><div class=\"line\">        <span class=\"keyword\">return</span> self.a <span class=\"comment\"># 返回下一个值</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib():</div><div class=\"line\"><span class=\"meta\">... </span>    print(n)</div></pre></td></tr></table></figure></p>\n<h4 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"getitem\"></a><strong>getitem</strong></h4><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int): <span class=\"comment\"># n是索引</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> a</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice): <span class=\"comment\"># n是切片</span></div><div class=\"line\">            start = n.start</div><div class=\"line\">            stop = n.stop</div><div class=\"line\">            <span class=\"keyword\">if</span> start <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">                start = <span class=\"number\">0</span></div><div class=\"line\">            a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></div><div class=\"line\">            L = []</div><div class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(stop):</div><div class=\"line\">                <span class=\"keyword\">if</span> x &gt;= start:</div><div class=\"line\">                    L.append(a)</div><div class=\"line\">                a, b = b, a + b</div><div class=\"line\">            <span class=\"keyword\">return</span> L</div></pre></td></tr></table></figure></p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<h4 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"getattr\"></a><strong>getattr</strong></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.name = <span class=\"string\">'Michael'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, attr)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></div></pre></td></tr></table></figure></p>\n<p>当调用<strong>不存在的属性</strong>时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a><strong>call</strong></h4><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></div><div class=\"line\">        self.name = name</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % self.name)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = Student(<span class=\"string\">'Michael'</span>)</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s() <span class=\"comment\"># self参数不要传入</span></div><div class=\"line\">My name <span class=\"keyword\">is</span> Michael.</div></pre></td></tr></table></figure></p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><p>Python提供了Enum类来实现这个功能<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum</div><div class=\"line\">Month = Enum(<span class=\"string\">'Month'</span>, (<span class=\"string\">'Jan'</span>, <span class=\"string\">'Feb'</span>, <span class=\"string\">'Mar'</span>, <span class=\"string\">'Apr'</span>, <span class=\"string\">'May'</span>, <span class=\"string\">'Jun'</span>, <span class=\"string\">'Jul'</span>, <span class=\"string\">'Aug'</span>, <span class=\"string\">'Sep'</span>, <span class=\"string\">'Oct'</span>, <span class=\"string\">'Nov'</span>, <span class=\"string\">'Dec'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> name, member <span class=\"keyword\">in</span> Month.__members__.items():</div><div class=\"line\">    print(name, <span class=\"string\">'=&gt;'</span>, member, <span class=\"string\">','</span>, member.value)</div></pre></td></tr></table></figure></p>\n<p>value属性则是自动赋给成员的int常量，默认从1开始计数。<br>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> enum <span class=\"keyword\">import</span> Enum, unique</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Weekday</span><span class=\"params\">(Enum)</span>:</span></div><div class=\"line\">    Sun = <span class=\"number\">0</span> <span class=\"comment\"># Sun的value被设定为0</span></div><div class=\"line\">    Mon = <span class=\"number\">1</span></div><div class=\"line\">    Tue = <span class=\"number\">2</span></div><div class=\"line\">    Wed = <span class=\"number\">3</span></div><div class=\"line\">    Thu = <span class=\"number\">4</span></div><div class=\"line\">    Fri = <span class=\"number\">5</span></div><div class=\"line\">    Sat = <span class=\"number\">6</span></div></pre></td></tr></table></figure>\n<h3 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h3><p>没看</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 高级特性","date":"2016-08-08T02:07:12.000Z","_content":"\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n### 切片\n切片（Slice）操作符用来简化经常取指定索引范围的操作\n```python\n>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n>>> L[0:3]\n['Michael', 'Sarah', 'Tracy']\n```\n从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.\n\n各种用法示例：\n```python\n# Python支持L[-1]取倒数第一个元素,同样支持倒数切片\n>>> L[-2:]\n['Bob', 'Jack']\n>>> L[-2:-1]\n['Bob']\n\n# 前10个数，每两个取一个：\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n\n# 所有数，每5个取一个：\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n# 什么都不写，只写[:]就可以原样复制一个list\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n\n# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n\n#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n### 迭代\n我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。\n\n判断一个对象是否是可迭代对象：\n```python\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n### 列表生成式\n感觉没啥用。\n\n### 生成器\n列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。\n例如实现斐波那契函数：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n    \nfor n in fib(6):\n\tprint(n)\n```\n如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n","source":"_posts/python_高级特性.md","raw":"title: python 3.5 高级特性\ndate: 2016/8/8 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n\n\n\n\n### 切片\n切片（Slice）操作符用来简化经常取指定索引范围的操作\n```python\n>>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n>>> L[0:3]\n['Michael', 'Sarah', 'Tracy']\n```\n从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.\n\n各种用法示例：\n```python\n# Python支持L[-1]取倒数第一个元素,同样支持倒数切片\n>>> L[-2:]\n['Bob', 'Jack']\n>>> L[-2:-1]\n['Bob']\n\n# 前10个数，每两个取一个：\n>>> L[:10:2]\n[0, 2, 4, 6, 8]\n\n# 所有数，每5个取一个：\n>>> L[::5]\n[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]\n\n# 什么都不写，只写[:]就可以原样复制一个list\n>>> L[:]\n[0, 1, 2, 3, ..., 99]\n\n# tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple\n>>> (0, 1, 2, 3, 4, 5)[:3]\n(0, 1, 2)\n\n#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n```\n\n### 迭代\n我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。\n\n判断一个对象是否是可迭代对象：\n```python\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n### 列表生成式\n感觉没啥用。\n\n### 生成器\n列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。\n例如实现斐波那契函数：\n```python\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n    \nfor n in fib(6):\n\tprint(n)\n```\n如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n","slug":"python_高级特性","published":1,"updated":"2016-09-23T05:52:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzy80039rgrulzs6a9kb","content":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>切片（Slice）操作符用来简化经常取指定索引范围的操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">0</span>:<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.</p>\n<p>各种用法示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Python支持L[-1]取倒数第一个元素,同样支持倒数切片</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:<span class=\"number\">-1</span>]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 前10个数，每两个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 所有数，每5个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[::<span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>, <span class=\"number\">50</span>, <span class=\"number\">55</span>, <span class=\"number\">60</span>, <span class=\"number\">65</span>, <span class=\"number\">70</span>, <span class=\"number\">75</span>, <span class=\"number\">80</span>, <span class=\"number\">85</span>, <span class=\"number\">90</span>, <span class=\"number\">95</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 什么都不写，只写[:]就可以原样复制一个list</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, ..., <span class=\"number\">99</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)[:<span class=\"number\">3</span>]</div><div class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"string\">'ABC'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"string\">'ACEG'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。</p>\n<p>判断一个对象是否是可迭代对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</div><div class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable)</div></pre></td></tr></table></figure></p>\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>感觉没啥用。</p>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。<br>例如实现斐波那契函数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></div><div class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</div><div class=\"line\">        <span class=\"keyword\">yield</span> b</div><div class=\"line\">        a, b = b, a + b</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'done'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</div><div class=\"line\">\tprint(n)</div></pre></td></tr></table></figure></p>\n<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<h3 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h3><p>切片（Slice）操作符用来简化经常取指定索引范围的操作<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">0</span>:<span class=\"number\">3</span>]</div><div class=\"line\">[<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.</p>\n<p>各种用法示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Python支持L[-1]取倒数第一个元素,同样支持倒数切片</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[<span class=\"number\">-2</span>:<span class=\"number\">-1</span>]</div><div class=\"line\">[<span class=\"string\">'Bob'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 前10个数，每两个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 所有数，每5个取一个：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[::<span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">20</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>, <span class=\"number\">35</span>, <span class=\"number\">40</span>, <span class=\"number\">45</span>, <span class=\"number\">50</span>, <span class=\"number\">55</span>, <span class=\"number\">60</span>, <span class=\"number\">65</span>, <span class=\"number\">70</span>, <span class=\"number\">75</span>, <span class=\"number\">80</span>, <span class=\"number\">85</span>, <span class=\"number\">90</span>, <span class=\"number\">95</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 什么都不写，只写[:]就可以原样复制一个list</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>L[:]</div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, ..., <span class=\"number\">99</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)[:<span class=\"number\">3</span>]</div><div class=\"line\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"string\">'ABC'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"string\">'ACEG'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p>我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。</p>\n<p>判断一个对象是否是可迭代对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Iterable</div><div class=\"line\">isinstance(<span class=\"string\">'abc'</span>, Iterable)</div></pre></td></tr></table></figure></p>\n<h3 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h3><p>感觉没啥用。</p>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。<br>例如实现斐波那契函数：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(max)</span>:</span></div><div class=\"line\">    n, a, b = <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">while</span> n &lt; max:</div><div class=\"line\">        <span class=\"keyword\">yield</span> b</div><div class=\"line\">        a, b = b, a + b</div><div class=\"line\">        n = n + <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'done'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</div><div class=\"line\">\tprint(n)</div></pre></td></tr></table></figure></p>\n<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。</p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"python 3.5 基础语法","date":"2016-08-07T02:07:12.000Z","_content":"\npython还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n  \n\nPython采用缩进方式,写出来的代码就像下面的样子：\n```python\n# print absolute value of an integer:\na = 100\nif a >= 0:\n    print(a)\nelse:\n    print(-a)\n```\n以#开头的语句是注释\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.\n\n### 数据类型和变量\n#### 字符串\n字符串是以单引号'或双引号\"括起来的任意文本.如果字符串内部既包含'又包含\",可以用转义字符\\来标识。\n要计算str包含多少个字符，可以用len()函数。\n%运算符就是用来格式化字符串，如：\n```python\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n```\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.\n\n#### 布尔值\n一个布尔值只有True、False两种值\n布尔值可以用and、or和not运算。\n\n#### 空值\n空值是Python里一个特殊的值，用None表示。\n\n#### 变量\n等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量\n\n### 数组和元组\n#### list\nlist是一种**可变的**有序的集合，用len()函数可以获得list元素的个数\n```python\nclassmates = ['Michael', 'Bob', 'Tracy']\n```\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置\nlist里面的元素的数据类型也可以不同\n列表可以看成一个多维数组 s[2][1]拿到元素。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0\n\n#### tuple\n另一种有序列表叫元组，但是tuple一旦初始化就不能修改\n```python\nclassmates = ('Michael', 'Bob', 'Tracy')\n```\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.\n\n如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下\n```python\nt = (1,)\n```\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义\n\n### 条件判断\nif-else语句实现：\n```python\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n```\n注意不要少写了冒号:\n完全可以用elif做更细致的判断,elif是else if的缩写\n\n### 循环\n#### for...in\n依次把list或tuple中的每个元素迭代出来\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\nPython提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for...in中可以简写成range()\n```python\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n#### while\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n### 容器\n#### dict\n```python\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n```\n**要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key**\n\n#### set\nset和dict类似，**也是一组key的集合**，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，需要**提供一个list作为输入集合**：\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n重复元素在set中自动被过滤\n```python\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n\n\n\n\n\n","source":"_posts/python语法.md","raw":"title: python 3.5 基础语法\ndate: 2016/8/7 10:07:12  \ncategories: python\ntags:\n\t- 学习笔记\n\n---\n\npython还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。\n当时学的是2.x版本，有点过时了，现在看了[廖雪峰的博客](http://www.liaoxuefeng.com/)的3.5版本的语法介绍，做一些摘录。\n\n<!--more-->\n  \n\nPython采用缩进方式,写出来的代码就像下面的样子：\n```python\n# print absolute value of an integer:\na = 100\nif a >= 0:\n    print(a)\nelse:\n    print(-a)\n```\n以#开头的语句是注释\n其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.\n\n### 数据类型和变量\n#### 字符串\n字符串是以单引号'或双引号\"括起来的任意文本.如果字符串内部既包含'又包含\",可以用转义字符\\来标识。\n要计算str包含多少个字符，可以用len()函数。\n%运算符就是用来格式化字符串，如：\n```python\n>>> 'Hello, %s' % 'world'\n'Hello, world'\n>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)\n'Hi, Michael, you have $1000000.'\n```\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.\n\n#### 布尔值\n一个布尔值只有True、False两种值\n布尔值可以用and、or和not运算。\n\n#### 空值\n空值是Python里一个特殊的值，用None表示。\n\n#### 变量\n等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量\n\n### 数组和元组\n#### list\nlist是一种**可变的**有序的集合，用len()函数可以获得list元素的个数\n```python\nclassmates = ['Michael', 'Bob', 'Tracy']\n```\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置\nlist里面的元素的数据类型也可以不同\n列表可以看成一个多维数组 s[2][1]拿到元素。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0\n\n#### tuple\n另一种有序列表叫元组，但是tuple一旦初始化就不能修改\n```python\nclassmates = ('Michael', 'Bob', 'Tracy')\n```\n因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.\n\n如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下\n```python\nt = (1,)\n```\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义\n\n### 条件判断\nif-else语句实现：\n```python\nage = 20\nif age >= 18:\n    print('your age is', age)\n    print('adult')\nelse:\n    print('your age is', age)\n    print('teenager')\n```\n注意不要少写了冒号:\n完全可以用elif做更细致的判断,elif是else if的缩写\n\n### 循环\n#### for...in\n依次把list或tuple中的每个元素迭代出来\n```python\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\nPython提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for...in中可以简写成range()\n```python\nsum = 0\nfor x in range(101):\n    sum = sum + x\nprint(sum)\n```\n\n#### while\n```python\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n\n### 容器\n#### dict\n```python\nd = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\n```\n**要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key**\n\n#### set\nset和dict类似，**也是一组key的集合**，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，需要**提供一个list作为输入集合**：\n```python\n>>> s = set([1, 2, 3])\n>>> s\n{1, 2, 3}\n```\n重复元素在set中自动被过滤\n```python\n>>> s = set([1, 1, 2, 2, 3, 3])\n>>> s\n{1, 2, 3}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最后再次感谢廖老师的辛勤劳动。\n\n\n\n\n\n\n","slug":"python语法","published":1,"updated":"2016-09-23T05:53:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzya003crgru2pzy904h","content":"<p>python还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。<br>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"external\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>\n<a id=\"more\"></a>\n<p>Python采用缩进方式,写出来的代码就像下面的样子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print absolute value of an integer:</span></div><div class=\"line\">a = <span class=\"number\">100</span></div><div class=\"line\"><span class=\"keyword\">if</span> a &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">    print(a)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(-a)</div></pre></td></tr></table></figure></p>\n<p>以#开头的语句是注释<br>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.</p>\n<h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本.如果字符串内部既包含’又包含”,可以用转义字符\\来标识。<br>要计算str包含多少个字符，可以用len()函数。<br>%运算符就是用来格式化字符串，如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hello, %s'</span> % <span class=\"string\">'world'</span></div><div class=\"line\"><span class=\"string\">'Hello, world'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hi, %s, you have $%d.'</span> % (<span class=\"string\">'Michael'</span>, <span class=\"number\">1000000</span>)</div><div class=\"line\"><span class=\"string\">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>\n<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.</p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>一个布尔值只有True、False两种值<br>布尔值可以用and、or和not运算。</p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h4><p>空值是Python里一个特殊的值，用None表示。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>\n<h3 id=\"数组和元组\"><a href=\"#数组和元组\" class=\"headerlink\" title=\"数组和元组\"></a>数组和元组</h3><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>list是一种<strong>可变的</strong>有序的集合，用len()函数可以获得list元素的个数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>列表可以看成一个多维数组 s[2][1]拿到元素。<br>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>另一种有序列表叫元组，但是tuple一旦初始化就不能修改<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = (<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>)</div></pre></td></tr></table></figure></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.</p>\n<p>如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">t = (<span class=\"number\">1</span>,)</div></pre></td></tr></table></figure></p>\n<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义</p>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>if-else语句实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'adult'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'teenager'</span>)</div></pre></td></tr></table></figure></p>\n<p>注意不要少写了冒号:<br>完全可以用elif做更细致的判断,elif是else if的缩写</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>依次把list或tuple中的每个元素迭代出来<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">names = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names:</div><div class=\"line\">    print(name)</div></pre></td></tr></table></figure></p>\n<p>Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for…in中可以简写成range()<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</div><div class=\"line\">    sum = sum + x</div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\">n = <span class=\"number\">99</span></div><div class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">    sum = sum + n</div><div class=\"line\">    n = n - <span class=\"number\">2</span></div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">d = &#123;<span class=\"string\">'Michael'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Bob'</span>: <span class=\"number\">75</span>, <span class=\"string\">'Tracy'</span>: <span class=\"number\">85</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>set和dict类似，<strong>也是一组key的集合</strong>，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要<strong>提供一个list作为输入集合</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复元素在set中自动被过滤<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>\n","excerpt":"<p>python还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。<br>当时学的是2.x版本，有点过时了，现在看了<a href=\"http://www.liaoxuefeng.com/\">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>","more":"<p>Python采用缩进方式,写出来的代码就像下面的样子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># print absolute value of an integer:</span></div><div class=\"line\">a = <span class=\"number\">100</span></div><div class=\"line\"><span class=\"keyword\">if</span> a &gt;= <span class=\"number\">0</span>:</div><div class=\"line\">    print(a)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(-a)</div></pre></td></tr></table></figure></p>\n<p>以#开头的语句是注释<br>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.</p>\n<h3 id=\"数据类型和变量\"><a href=\"#数据类型和变量\" class=\"headerlink\" title=\"数据类型和变量\"></a>数据类型和变量</h3><h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本.如果字符串内部既包含’又包含”,可以用转义字符\\来标识。<br>要计算str包含多少个字符，可以用len()函数。<br>%运算符就是用来格式化字符串，如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hello, %s'</span> % <span class=\"string\">'world'</span></div><div class=\"line\"><span class=\"string\">'Hello, world'</span></div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">'Hi, %s, you have $%d.'</span> % (<span class=\"string\">'Michael'</span>, <span class=\"number\">1000000</span>)</div><div class=\"line\"><span class=\"string\">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>\n<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.</p>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>一个布尔值只有True、False两种值<br>布尔值可以用and、or和not运算。</p>\n<h4 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h4><p>空值是Python里一个特殊的值，用None表示。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>\n<h3 id=\"数组和元组\"><a href=\"#数组和元组\" class=\"headerlink\" title=\"数组和元组\"></a>数组和元组</h3><h4 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h4><p>list是一种<strong>可变的</strong>有序的集合，用len()函数可以获得list元素的个数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div></pre></td></tr></table></figure></p>\n<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>列表可以看成一个多维数组 s[2][1]拿到元素。<br>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</p>\n<h4 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h4><p>另一种有序列表叫元组，但是tuple一旦初始化就不能修改<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">classmates = (<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>)</div></pre></td></tr></table></figure></p>\n<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.</p>\n<p>如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">t = (<span class=\"number\">1</span>,)</div></pre></td></tr></table></figure></p>\n<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义</p>\n<h3 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h3><p>if-else语句实现：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">age = <span class=\"number\">20</span></div><div class=\"line\"><span class=\"keyword\">if</span> age &gt;= <span class=\"number\">18</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'adult'</span>)</div><div class=\"line\"><span class=\"keyword\">else</span>:</div><div class=\"line\">    print(<span class=\"string\">'your age is'</span>, age)</div><div class=\"line\">    print(<span class=\"string\">'teenager'</span>)</div></pre></td></tr></table></figure></p>\n<p>注意不要少写了冒号:<br>完全可以用elif做更细致的判断,elif是else if的缩写</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><h4 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h4><p>依次把list或tuple中的每个元素迭代出来<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">names = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tracy'</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names:</div><div class=\"line\">    print(name)</div></pre></td></tr></table></figure></p>\n<p>Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for…in中可以简写成range()<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">101</span>):</div><div class=\"line\">    sum = sum + x</div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">sum = <span class=\"number\">0</span></div><div class=\"line\">n = <span class=\"number\">99</span></div><div class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</div><div class=\"line\">    sum = sum + n</div><div class=\"line\">    n = n - <span class=\"number\">2</span></div><div class=\"line\">print(sum)</div></pre></td></tr></table></figure>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">d = &#123;<span class=\"string\">'Michael'</span>: <span class=\"number\">95</span>, <span class=\"string\">'Bob'</span>: <span class=\"number\">75</span>, <span class=\"string\">'Tracy'</span>: <span class=\"number\">85</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p>\n<h4 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h4><p>set和dict类似，<strong>也是一组key的集合</strong>，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要<strong>提供一个list作为输入集合</strong>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>重复元素在set中自动被过滤<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = set([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</div><div class=\"line\">&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>最后再次感谢廖老师的辛勤劳动。</p>"},{"title":"runtime原理笔记","date":"2016-08-22T06:07:12.000Z","_content":"\n最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。\n所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)\t\n<!--more-->\n\n## Runtime基础\n在Objective-C中，使用`[receiver message]`语法并不会马上执行`receiver`对象的`message`方法的代码，而是向`receiver`发送一条`message`消息。\n其实`[receiver message]`被编译器转化为:\n```objc\nid objc_msgSend ( id self, SEL op, ... );\n```\n现在可以看出`[receiver message]`真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送`message`这条消息，而`receive`将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的`selector`，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个`selector`对应的实现内容，要么就干脆玩完崩溃掉。\n\n### id\n`objc_msgSend`第一个参数类型为`id`,它是一个指向`objc_object`结构体指针,它包含一个`Class isa`指针(完整的定义在`objc_private.h`中)：\n```objc\ntypedef struct objc_object *id;\n\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\n### SEL\n`objc_msgSend`函数第二个参数类型为`SEL`，它是`selector`在Objc中的表示类型.`selector`是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是`SEL`:\n```objc\ntypedef struct objc_selector *SEL;\n```\n\n### Class\n之所以说`isa`是指针是因为`Class`其实是一个指向`objc_class`结构体的指针：\n```objc\ntypedef struct objc_class *Class;\n```\n\n这个结构体在`runtime.h`中有定义:\n```objc\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n其中`OBJC2_UNAVAILABLE`表示：在objc2中这些属性已经不在此定义。\n\n在objc2中，`objc_class`的完整定义在`objc-runtime-new.h`中：\n```objc\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n\nstruct objc_class : objc_object {\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n};\n```\n\n和`runtime.h`中的定义对比，少了许多属性，多出一个`bits`属性。这些属性都包含在了`class_rw_t`的`data`对象中。\n\n注意到`objc_class`中也有一个`isa`对象(继承自`objc_object`)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 **元类 (Meta Class)**的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。**类方法就定义于此处**，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。\n当你发出一个类似`[NSObject alloc]`的消息时，你事实上是把这个消息发给了一个**类对象 (Class Object)** ，这个类对象必须是一个元类的实例，而这个元类同时也是一个**根元类 (root meta class)**的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 `[NSObject alloc]`这条消息发给类对象的时候，`objc_msgSend()`会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。\n![Class isa and superclass relationship](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true)\n\n### class_rw_t\n`bits` 中包含了一个指向 `class_rw_t` 结构体的指针，它的定义如下:\n```objc\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n}\n```\n\n其中，`const class_ro_t *ro`包含了所有**成员变量**的一维数组以及**各个基础的(base)属性、方法和协议**\n`method_array_t methods`、`property_array_t properties`、`protocol_array_t protocols`则包含了所有**拓展的属性方法和协议**。**注意：这里的属性只是getset方法，不包含成员变量。**\n这也就解释了，开篇不能添加成员变量的原因。\n\n具体如何应用可看下一篇。\n\n### 部分类的声明\n这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。\n\n#### class_ro_t:\n```objc\nstruct class_ro_t {\n\t...\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    property_list_t *baseProperties;\n    ...\n};\n```\n#### method_t\n`method_list_t`和`method_array_t`内都是`method_t`类型:\n```objc\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n}\n```\n- 方法名类型为`SEL`\n- 方法类型`types`是个`char`指针，其实存储着方法的参数类型和返回值类型。\n- `imp`指向了方法的实现，本质上是一个函数指针\n\n#### ivar_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n}\n```\n\n#### property_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n#### protocol_t\n`protocol_list_t`和`protocol_array_t`内都是`protocol_t`类型:\n```objc\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n};\n```\n\n#### Ivar,Method,Category,objc_property_t\n外部可以通过一系列的方法获得类的信息，诸如：`class_copyIvarList`,`class_copyPropertyList`等方法，可以获得类的实例变量和属性，对应的类型是`Ivar`、`objc_property_t`，它们分别是`ivar_t`,`property_t`类型的指针。\n\n```objc\ntypedef struct method_t *Method;\ntypedef struct ivar_t *Ivar;\ntypedef struct category_t *Category;\ntypedef struct property_t *objc_property_t;\n```\n\n## 消息\n### objc_msgSend函数\n看起来像是`objc_msgSend`返回了数据，其实`objc_msgSend`从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：\n1. 检测这个 `selector` 是不是要忽略的。比如有了垃圾回收就不理会 `retain`, `release` 这些函数了。\n2. 检测这个 `target` 是不是 `nil` 对象。ObjC 的特性是允许对一个 `nil`对象执行任何一个方法不会 Crash，因为会被忽略掉。\n3. 如果上面两个都过了，那就开始查找这个类的 `IMP`，先从 `cache` 里面找，完了找得到就跳到对应的函数去执行。\n4. 如果 `cache` 找不到就找一下方法分发表。\n5. 如果分发表找不到就到超类的分发表去找，一直找，直到找到`NSObject`类为止。\n6. 如果还找不到就要开始进入动态方法解析了.\n\n编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`Super`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`stret`的函数。\n\n当我们调用`[super selector]` 时，Runtime 会调用 `objc_msgSendSuper `方法，`objc_msgSendSuper` 方法有两个参数，`super` 和 `op`，`Runtime` 会把 `selector` 方法选择器赋值给 `op`。而 `super` 是一个 `objc_super` 结构体指针，`objc_super` 结构体定义如下：\n```objc\nstruct objc_super { id receiver; Class class; };\n```\n需要注意的是：这里的`receiver`仍然是`self`本身。当我们想通过`[super class]`获取超类时，编译器只是将指向`self`的`id`指针和`class`的`SEL`传递给了`objc_msgSendSuper`函数，因为只有在`NSObject`类才能找到`class`方法，然后`class`方法调用`object_getClass()`，接着调用`objc_msgSend(objc_super->receiver, @selector(class))`，传入的第一个参数是指向`self`的`id`指针，与调用`[self class]`相同，所以我们得到的永远都是`self`的类型。\n\n举个栗子，问下面的代码输出什么：\n\n```objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n答案是全部输出 `Son`.\n\n当调用 `[super class]` 时，会转换成 `objc_msgSendSuper` 函数：\n1. 先构造 `objc_super` 结构体，结构体第一个成员就是 `self`。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))`.\n2. 去 `Father` 这个类里去找 `- (Class)class`，没有，然后去 `NSObject` 类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))` 去调用，此时已经和 `[self class]` 调用相同了，所以两个输出结果都是 `Son`。\n\n这里调用`class`只是举例，所有调用`super`的方法，最后都变成了`self`的调用。\n\n\n## Category 的实现原理\n### 概述\nruntime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:\n```objc\nvoid _objc_init(void)\n└──const char \\*map_2_images(...)\n    └──const char \\*map_images_nolock(...)\n        └──void _read_images(header_info **hList, uint32_t hCount)\n        \t└──static void remethodizeClass(Class cls)\n        \t\t└──static void attachCategories(Class cls, category_list *cats, bool flush_caches)\n```\n### Category 相关的数据结构\n首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：\n```objc\nstruct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\n\n### 处理 Category\n对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:\n```objc\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches) {\n    if (!cats) return;\n    bool isMeta = cls->isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)malloc(cats->count * sizeof(*mlists));\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n}\n```\n\n首先，通过 `while` 循环，我们遍历所有的 category，也就是参数 `cats` 中的 `list` 属性。对于每一个 category，得到它的方法列表 `mlist` 并存入 `mlists` 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。\n\n在 `while` 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:\n```objc\nauto rw = cls->data();\nrw->methods.attachLists(mlists, mcount);\n```\n`rw` 是一个 `class_rw_t`类型的结构体指针。根据 runtime 中的数据结构，它有一个 `methods` 结构体成员，并从父类继承了 `attachLists` 方法，用来合并 category 中的方法:\n```objc\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n    if (addedCount == 0) return;\n    uint32_t oldCount = array()->count;\n    uint32_t newCount = oldCount + addedCount;\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));\n    memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));\n}\n```\n需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。\n\n","source":"_posts/runtime原理.md","raw":"title: runtime原理笔记\ndate: 2016/8/22 14:07:12  \ncategories: IOS\ntags: [Runtime]\n\n---\n\n最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。\n所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)\t\n<!--more-->\n\n## Runtime基础\n在Objective-C中，使用`[receiver message]`语法并不会马上执行`receiver`对象的`message`方法的代码，而是向`receiver`发送一条`message`消息。\n其实`[receiver message]`被编译器转化为:\n```objc\nid objc_msgSend ( id self, SEL op, ... );\n```\n现在可以看出`[receiver message]`真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送`message`这条消息，而`receive`将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的`selector`，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个`selector`对应的实现内容，要么就干脆玩完崩溃掉。\n\n### id\n`objc_msgSend`第一个参数类型为`id`,它是一个指向`objc_object`结构体指针,它包含一个`Class isa`指针(完整的定义在`objc_private.h`中)：\n```objc\ntypedef struct objc_object *id;\n\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n```\n\n### SEL\n`objc_msgSend`函数第二个参数类型为`SEL`，它是`selector`在Objc中的表示类型.`selector`是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是`SEL`:\n```objc\ntypedef struct objc_selector *SEL;\n```\n\n### Class\n之所以说`isa`是指针是因为`Class`其实是一个指向`objc_class`结构体的指针：\n```objc\ntypedef struct objc_class *Class;\n```\n\n这个结构体在`runtime.h`中有定义:\n```objc\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n其中`OBJC2_UNAVAILABLE`表示：在objc2中这些属性已经不在此定义。\n\n在objc2中，`objc_class`的完整定义在`objc-runtime-new.h`中：\n```objc\nstruct objc_object {\n    Class isa  OBJC_ISA_AVAILABILITY;\n};\n\nstruct objc_class : objc_object {\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() { \n        return bits.data();\n    }\n};\n```\n\n和`runtime.h`中的定义对比，少了许多属性，多出一个`bits`属性。这些属性都包含在了`class_rw_t`的`data`对象中。\n\n注意到`objc_class`中也有一个`isa`对象(继承自`objc_object`)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 **元类 (Meta Class)**的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。**类方法就定义于此处**，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。\n当你发出一个类似`[NSObject alloc]`的消息时，你事实上是把这个消息发给了一个**类对象 (Class Object)** ，这个类对象必须是一个元类的实例，而这个元类同时也是一个**根元类 (root meta class)**的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 `[NSObject alloc]`这条消息发给类对象的时候，`objc_msgSend()`会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。\n![Class isa and superclass relationship](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true)\n\n### class_rw_t\n`bits` 中包含了一个指向 `class_rw_t` 结构体的指针，它的定义如下:\n```objc\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n}\n```\n\n其中，`const class_ro_t *ro`包含了所有**成员变量**的一维数组以及**各个基础的(base)属性、方法和协议**\n`method_array_t methods`、`property_array_t properties`、`protocol_array_t protocols`则包含了所有**拓展的属性方法和协议**。**注意：这里的属性只是getset方法，不包含成员变量。**\n这也就解释了，开篇不能添加成员变量的原因。\n\n具体如何应用可看下一篇。\n\n### 部分类的声明\n这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。\n\n#### class_ro_t:\n```objc\nstruct class_ro_t {\n\t...\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars;\n    property_list_t *baseProperties;\n    ...\n};\n```\n#### method_t\n`method_list_t`和`method_array_t`内都是`method_t`类型:\n```objc\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n}\n```\n- 方法名类型为`SEL`\n- 方法类型`types`是个`char`指针，其实存储着方法的参数类型和返回值类型。\n- `imp`指向了方法的实现，本质上是一个函数指针\n\n#### ivar_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct ivar_t {\n    int32_t *offset;\n    const char *name;\n    const char *type;\n}\n```\n\n#### property_t\n`ivar_list_t`和`ivar_array_t`内都是`ivar_t`类型:\n```objc\nstruct property_t {\n    const char *name;\n    const char *attributes;\n};\n```\n\n#### protocol_t\n`protocol_list_t`和`protocol_array_t`内都是`protocol_t`类型:\n```objc\nstruct protocol_t : objc_object {\n    const char *mangledName;\n    struct protocol_list_t *protocols;\n    method_list_t *instanceMethods;\n    method_list_t *classMethods;\n    method_list_t *optionalInstanceMethods;\n    method_list_t *optionalClassMethods;\n    property_list_t *instanceProperties;\n    uint32_t size;   // sizeof(protocol_t)\n    uint32_t flags;\n};\n```\n\n#### Ivar,Method,Category,objc_property_t\n外部可以通过一系列的方法获得类的信息，诸如：`class_copyIvarList`,`class_copyPropertyList`等方法，可以获得类的实例变量和属性，对应的类型是`Ivar`、`objc_property_t`，它们分别是`ivar_t`,`property_t`类型的指针。\n\n```objc\ntypedef struct method_t *Method;\ntypedef struct ivar_t *Ivar;\ntypedef struct category_t *Category;\ntypedef struct property_t *objc_property_t;\n```\n\n## 消息\n### objc_msgSend函数\n看起来像是`objc_msgSend`返回了数据，其实`objc_msgSend`从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：\n1. 检测这个 `selector` 是不是要忽略的。比如有了垃圾回收就不理会 `retain`, `release` 这些函数了。\n2. 检测这个 `target` 是不是 `nil` 对象。ObjC 的特性是允许对一个 `nil`对象执行任何一个方法不会 Crash，因为会被忽略掉。\n3. 如果上面两个都过了，那就开始查找这个类的 `IMP`，先从 `cache` 里面找，完了找得到就跳到对应的函数去执行。\n4. 如果 `cache` 找不到就找一下方法分发表。\n5. 如果分发表找不到就到超类的分发表去找，一直找，直到找到`NSObject`类为止。\n6. 如果还找不到就要开始进入动态方法解析了.\n\n编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`Super`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`stret`的函数。\n\n当我们调用`[super selector]` 时，Runtime 会调用 `objc_msgSendSuper `方法，`objc_msgSendSuper` 方法有两个参数，`super` 和 `op`，`Runtime` 会把 `selector` 方法选择器赋值给 `op`。而 `super` 是一个 `objc_super` 结构体指针，`objc_super` 结构体定义如下：\n```objc\nstruct objc_super { id receiver; Class class; };\n```\n需要注意的是：这里的`receiver`仍然是`self`本身。当我们想通过`[super class]`获取超类时，编译器只是将指向`self`的`id`指针和`class`的`SEL`传递给了`objc_msgSendSuper`函数，因为只有在`NSObject`类才能找到`class`方法，然后`class`方法调用`object_getClass()`，接着调用`objc_msgSend(objc_super->receiver, @selector(class))`，传入的第一个参数是指向`self`的`id`指针，与调用`[self class]`相同，所以我们得到的永远都是`self`的类型。\n\n举个栗子，问下面的代码输出什么：\n\n```objc\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n答案是全部输出 `Son`.\n\n当调用 `[super class]` 时，会转换成 `objc_msgSendSuper` 函数：\n1. 先构造 `objc_super` 结构体，结构体第一个成员就是 `self`。第二个成员是 `(id)class_getSuperclass(objc_getClass(“Son”))`.\n2. 去 `Father` 这个类里去找 `- (Class)class`，没有，然后去 `NSObject` 类去找，找到了。最后内部是使用 `objc_msgSend(objc_super->receiver, @selector(class))` 去调用，此时已经和 `[self class]` 调用相同了，所以两个输出结果都是 `Son`。\n\n这里调用`class`只是举例，所有调用`super`的方法，最后都变成了`self`的调用。\n\n\n## Category 的实现原理\n### 概述\nruntime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:\n```objc\nvoid _objc_init(void)\n└──const char \\*map_2_images(...)\n    └──const char \\*map_images_nolock(...)\n        └──void _read_images(header_info **hList, uint32_t hCount)\n        \t└──static void remethodizeClass(Class cls)\n        \t\t└──static void attachCategories(Class cls, category_list *cats, bool flush_caches)\n```\n### Category 相关的数据结构\n首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：\n```objc\nstruct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n```\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\n\n### 处理 Category\n对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:\n```objc\nstatic void attachCategories(Class cls, category_list *cats, bool flush_caches) {\n    if (!cats) return;\n    bool isMeta = cls->isMetaClass();\n\n    method_list_t **mlists = (method_list_t **)malloc(cats->count * sizeof(*mlists));\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    while (i--) {\n        auto& entry = cats->list[i];\n\n        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n        }\n    }\n\n    auto rw = cls->data();\n\n    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);\n    rw->methods.attachLists(mlists, mcount);\n    free(mlists);\n    if (flush_caches  &&  mcount > 0) flushCaches(cls);\n}\n```\n\n首先，通过 `while` 循环，我们遍历所有的 category，也就是参数 `cats` 中的 `list` 属性。对于每一个 category，得到它的方法列表 `mlist` 并存入 `mlists` 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。\n\n在 `while` 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:\n```objc\nauto rw = cls->data();\nrw->methods.attachLists(mlists, mcount);\n```\n`rw` 是一个 `class_rw_t`类型的结构体指针。根据 runtime 中的数据结构，它有一个 `methods` 结构体成员，并从父类继承了 `attachLists` 方法，用来合并 category 中的方法:\n```objc\nvoid attachLists(List* const * addedLists, uint32_t addedCount) {\n    if (addedCount == 0) return;\n    uint32_t oldCount = array()->count;\n    uint32_t newCount = oldCount + addedCount;\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    memmove(array()->lists + addedCount, array()->lists, oldCount * sizeof(array()->lists[0]));\n    memcpy(array()->lists, addedLists, addedCount * sizeof(array()->lists[0]));\n}\n```\n需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。\n\n","slug":"runtime原理","published":1,"updated":"2016-09-23T05:45:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyf003frgruek30vapr","content":"<p>最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。<br>所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C Runtime</a><br><a id=\"more\"></a></p>\n<h2 id=\"Runtime基础\"><a href=\"#Runtime基础\" class=\"headerlink\" title=\"Runtime基础\"></a>Runtime基础</h2><p>在Objective-C中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息。<br>其实<code>[receiver message]</code>被编译器转化为:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_msgSend ( <span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL op, ... );</div></pre></td></tr></table></figure></p>\n<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>,它是一个指向<code>objc_object</code>结构体指针,它包含一个<code>Class isa</code>指针(完整的定义在<code>objc_private.h</code>中)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"keyword\">id</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型.<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>\n<p>这个结构体在<code>runtime.h</code>中有定义:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>其中<code>OBJC2_UNAVAILABLE</code>表示：在objc2中这些属性已经不在此定义。</p>\n<p>在objc2中，<code>objc_class</code>的完整定义在<code>objc-runtime-new.h</code>中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></div><div class=\"line\">    class_data_bits_t bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>和<code>runtime.h</code>中的定义对比，少了许多属性，多出一个<code>bits</code>属性。这些属性都包含在了<code>class_rw_t</code>的<code>data</code>对象中。</p>\n<p>注意到<code>objc_class</code>中也有一个<code>isa</code>对象(继承自<code>objc_object</code>)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 <strong>元类 (Meta Class)</strong>的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。<strong>类方法就定义于此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。<br>当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个<strong>类对象 (Class Object)</strong> ，这个类对象必须是一个元类的实例，而这个元类同时也是一个<strong>根元类 (root meta class)</strong>的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code>这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true\" alt=\"Class isa and superclass relationship\"></p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;</div><div class=\"line\">    property_array_t properties;</div><div class=\"line\">    protocol_array_t protocols;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>const class_ro_t *ro</code>包含了所有<strong>成员变量</strong>的一维数组以及<strong>各个基础的(base)属性、方法和协议</strong><br><code>method_array_t methods</code>、<code>property_array_t properties</code>、<code>protocol_array_t protocols</code>则包含了所有<strong>拓展的属性方法和协议</strong>。<strong>注意：这里的属性只是getset方法，不包含成员变量。</strong><br>这也就解释了，开篇不能添加成员变量的原因。</p>\n<p>具体如何应用可看下一篇。</p>\n<h3 id=\"部分类的声明\"><a href=\"#部分类的声明\" class=\"headerlink\" title=\"部分类的声明\"></a>部分类的声明</h3><p>这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。</p>\n<h4 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t:\"></a>class_ro_t:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</div><div class=\"line\">\t...</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h4><p><code>method_list_t</code>和<code>method_array_t</code>内都是<code>method_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>方法名类型为<code>SEL</code></li>\n<li>方法类型<code>types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>\n<li><code>imp</code>指向了方法的实现，本质上是一个函数指针</li>\n</ul>\n<h4 id=\"ivar-t\"><a href=\"#ivar-t\" class=\"headerlink\" title=\"ivar_t\"></a>ivar_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"property-t\"><a href=\"#property-t\" class=\"headerlink\" title=\"property_t\"></a>property_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h4><p><code>protocol_list_t</code>和<code>protocol_array_t</code>内都是<code>protocol_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> protocol_t : objc_object &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    method_list_t *instanceMethods;</div><div class=\"line\">    method_list_t *classMethods;</div><div class=\"line\">    method_list_t *optionalInstanceMethods;</div><div class=\"line\">    method_list_t *optionalClassMethods;</div><div class=\"line\">    property_list_t *instanceProperties;</div><div class=\"line\">    uint32_t size;   <span class=\"comment\">// sizeof(protocol_t)</span></div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Ivar-Method-Category-objc-property-t\"><a href=\"#Ivar-Method-Category-objc-property-t\" class=\"headerlink\" title=\"Ivar,Method,Category,objc_property_t\"></a>Ivar,Method,Category,objc_property_t</h4><p>外部可以通过一系列的方法获得类的信息，诸如：<code>class_copyIvarList</code>,<code>class_copyPropertyList</code>等方法，可以获得类的实例变量和属性，对应的类型是<code>Ivar</code>、<code>objc_property_t</code>，它们分别是<code>ivar_t</code>,<code>property_t</code>类型的指针。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> method_t *Method;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ivar_t *Ivar;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> category_t *Category;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> property_t *objc_property_t;</div></pre></td></tr></table></figure>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h3 id=\"objc-msgSend函数\"><a href=\"#objc-msgSend函数\" class=\"headerlink\" title=\"objc_msgSend函数\"></a>objc_msgSend函数</h3><p>看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>\n<ol>\n<li>检测这个 <code>selector</code> 是不是要忽略的。比如有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>\n<li>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>\n<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>\n<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>\n<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>\n<li>如果还找不到就要开始进入动态方法解析了.</li>\n</ol>\n<p>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。</p>\n<p>当我们调用<code>[super selector]</code> 时，Runtime 会调用 <code>objc_msgSendSuper</code>方法，<code>objc_msgSendSuper</code> 方法有两个参数，<code>super</code> 和 <code>op</code>，<code>Runtime</code> 会把 <code>selector</code> 方法选择器赋值给 <code>op</code>。而 <code>super</code> 是一个 <code>objc_super</code> 结构体指针，<code>objc_super</code> 结构体定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123; <span class=\"keyword\">id</span> receiver; Class <span class=\"keyword\">class</span>; &#125;;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是：这里的<code>receiver</code>仍然是<code>self</code>本身。当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>\n<p>举个栗子，问下面的代码输出什么：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>答案是全部输出 <code>Son</code>.</p>\n<p>当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 函数：</p>\n<ol>\n<li>先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code>。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>.</li>\n<li>去 <code>Father</code> 这个类里去找 <code>- (Class)class</code>，没有，然后去 <code>NSObject</code> 类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code> 去调用，此时已经和 <code>[self class]</code> 调用相同了，所以两个输出结果都是 <code>Son</code>。</li>\n</ol>\n<p>这里调用<code>class</code>只是举例，所有调用<code>super</code>的方法，最后都变成了<code>self</code>的调用。</p>\n<h2 id=\"Category-的实现原理\"><a href=\"#Category-的实现原理\" class=\"headerlink\" title=\"Category 的实现原理\"></a>Category 的实现原理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> _objc_init(<span class=\"keyword\">void</span>)</div><div class=\"line\">└──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_2_images(...)</div><div class=\"line\">    └──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_images_nolock(...)</div><div class=\"line\">        └──<span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount)</div><div class=\"line\">        \t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> remethodizeClass(Class cls)</div><div class=\"line\">        \t\t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Category-相关的数据结构\"><a href=\"#Category-相关的数据结构\" class=\"headerlink\" title=\"Category 相关的数据结构\"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> category_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *instanceMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *classMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    <span class=\"keyword\">struct</span> property_list_t *instanceProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>\n<h3 id=\"处理-Category\"><a href=\"#处理-Category\" class=\"headerlink\" title=\"处理 Category\"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</div><div class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></div><div class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</div><div class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\"></div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle);</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">    free(mlists);</div><div class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，通过 <code>while</code> 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。</p>\n<p>在 <code>while</code> 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto rw = cls-&gt;data();</div><div class=\"line\">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure></p>\n<p><code>rw</code> 是一个 <code>class_rw_t</code>类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> attachLists(List* <span class=\"keyword\">const</span> * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (addedCount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">    uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">    array()-&gt;count = newCount;</div><div class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>\n","excerpt":"<p>最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。<br>所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\">Objective-C Runtime</a><br>","more":"</p>\n<h2 id=\"Runtime基础\"><a href=\"#Runtime基础\" class=\"headerlink\" title=\"Runtime基础\"></a>Runtime基础</h2><p>在Objective-C中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息。<br>其实<code>[receiver message]</code>被编译器转化为:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">id</span> objc_msgSend ( <span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL op, ... );</div></pre></td></tr></table></figure></p>\n<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>,它是一个指向<code>objc_object</code>结构体指针,它包含一个<code>Class isa</code>指针(完整的定义在<code>objc_private.h</code>中)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"keyword\">id</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型.<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>\n<p>这个结构体在<code>runtime.h</code>中有定义:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>\n<p>其中<code>OBJC2_UNAVAILABLE</code>表示：在objc2中这些属性已经不在此定义。</p>\n<p>在objc2中，<code>objc_class</code>的完整定义在<code>objc-runtime-new.h</code>中：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> objc_class : objc_object &#123;</div><div class=\"line\">    Class superclass;</div><div class=\"line\">    cache_t cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></div><div class=\"line\">    class_data_bits_t bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></div><div class=\"line\"></div><div class=\"line\">    class_rw_t *data() &#123; </div><div class=\"line\">        <span class=\"keyword\">return</span> bits.data();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>和<code>runtime.h</code>中的定义对比，少了许多属性，多出一个<code>bits</code>属性。这些属性都包含在了<code>class_rw_t</code>的<code>data</code>对象中。</p>\n<p>注意到<code>objc_class</code>中也有一个<code>isa</code>对象(继承自<code>objc_object</code>)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 <strong>元类 (Meta Class)</strong>的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。<strong>类方法就定义于此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。<br>当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个<strong>类对象 (Class Object)</strong> ，这个类对象必须是一个元类的实例，而这个元类同时也是一个<strong>根元类 (root meta class)</strong>的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code>这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true\" alt=\"Class isa and superclass relationship\"></p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">    uint32_t version;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">const</span> class_ro_t *ro;</div><div class=\"line\"></div><div class=\"line\">    method_array_t methods;</div><div class=\"line\">    property_array_t properties;</div><div class=\"line\">    protocol_array_t protocols;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中，<code>const class_ro_t *ro</code>包含了所有<strong>成员变量</strong>的一维数组以及<strong>各个基础的(base)属性、方法和协议</strong><br><code>method_array_t methods</code>、<code>property_array_t properties</code>、<code>protocol_array_t protocols</code>则包含了所有<strong>拓展的属性方法和协议</strong>。<strong>注意：这里的属性只是getset方法，不包含成员变量。</strong><br>这也就解释了，开篇不能添加成员变量的原因。</p>\n<p>具体如何应用可看下一篇。</p>\n<h3 id=\"部分类的声明\"><a href=\"#部分类的声明\" class=\"headerlink\" title=\"部分类的声明\"></a>部分类的声明</h3><p>这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。</p>\n<h4 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t:\"></a>class_ro_t:</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</div><div class=\"line\">\t...</div><div class=\"line\">    method_list_t * baseMethodList;</div><div class=\"line\">    protocol_list_t * baseProtocols;</div><div class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars;</div><div class=\"line\">    property_list_t *baseProperties;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h4><p><code>method_list_t</code>和<code>method_array_t</code>内都是<code>method_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> method_t &#123;</div><div class=\"line\">    SEL name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>方法名类型为<code>SEL</code></li>\n<li>方法类型<code>types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>\n<li><code>imp</code>指向了方法的实现，本质上是一个函数指针</li>\n</ul>\n<h4 id=\"ivar-t\"><a href=\"#ivar-t\" class=\"headerlink\" title=\"ivar_t\"></a>ivar_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> ivar_t &#123;</div><div class=\"line\">    int32_t *offset;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"property-t\"><a href=\"#property-t\" class=\"headerlink\" title=\"property_t\"></a>property_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> property_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *attributes;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"protocol-t\"><a href=\"#protocol-t\" class=\"headerlink\" title=\"protocol_t\"></a>protocol_t</h4><p><code>protocol_list_t</code>和<code>protocol_array_t</code>内都是<code>protocol_t</code>类型:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> protocol_t : objc_object &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mangledName;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    method_list_t *instanceMethods;</div><div class=\"line\">    method_list_t *classMethods;</div><div class=\"line\">    method_list_t *optionalInstanceMethods;</div><div class=\"line\">    method_list_t *optionalClassMethods;</div><div class=\"line\">    property_list_t *instanceProperties;</div><div class=\"line\">    uint32_t size;   <span class=\"comment\">// sizeof(protocol_t)</span></div><div class=\"line\">    uint32_t flags;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Ivar-Method-Category-objc-property-t\"><a href=\"#Ivar-Method-Category-objc-property-t\" class=\"headerlink\" title=\"Ivar,Method,Category,objc_property_t\"></a>Ivar,Method,Category,objc_property_t</h4><p>外部可以通过一系列的方法获得类的信息，诸如：<code>class_copyIvarList</code>,<code>class_copyPropertyList</code>等方法，可以获得类的实例变量和属性，对应的类型是<code>Ivar</code>、<code>objc_property_t</code>，它们分别是<code>ivar_t</code>,<code>property_t</code>类型的指针。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> method_t *Method;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> ivar_t *Ivar;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> category_t *Category;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> property_t *objc_property_t;</div></pre></td></tr></table></figure>\n<h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h3 id=\"objc-msgSend函数\"><a href=\"#objc-msgSend函数\" class=\"headerlink\" title=\"objc_msgSend函数\"></a>objc_msgSend函数</h3><p>看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>\n<ol>\n<li>检测这个 <code>selector</code> 是不是要忽略的。比如有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>\n<li>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>\n<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>\n<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>\n<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>\n<li>如果还找不到就要开始进入动态方法解析了.</li>\n</ol>\n<p>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。</p>\n<p>当我们调用<code>[super selector]</code> 时，Runtime 会调用 <code>objc_msgSendSuper</code>方法，<code>objc_msgSendSuper</code> 方法有两个参数，<code>super</code> 和 <code>op</code>，<code>Runtime</code> 会把 <code>selector</code> 方法选择器赋值给 <code>op</code>。而 <code>super</code> 是一个 <code>objc_super</code> 结构体指针，<code>objc_super</code> 结构体定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123; <span class=\"keyword\">id</span> receiver; Class <span class=\"keyword\">class</span>; &#125;;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是：这里的<code>receiver</code>仍然是<code>self</code>本身。当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>\n<p>举个栗子，问下面的代码输出什么：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Son</span> : <span class=\"title\">Father</span></span></div><div class=\"line\">- (<span class=\"keyword\">id</span>)init</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>答案是全部输出 <code>Son</code>.</p>\n<p>当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 函数：</p>\n<ol>\n<li>先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code>。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>.</li>\n<li>去 <code>Father</code> 这个类里去找 <code>- (Class)class</code>，没有，然后去 <code>NSObject</code> 类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code> 去调用，此时已经和 <code>[self class]</code> 调用相同了，所以两个输出结果都是 <code>Son</code>。</li>\n</ol>\n<p>这里调用<code>class</code>只是举例，所有调用<code>super</code>的方法，最后都变成了<code>self</code>的调用。</p>\n<h2 id=\"Category-的实现原理\"><a href=\"#Category-的实现原理\" class=\"headerlink\" title=\"Category 的实现原理\"></a>Category 的实现原理</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> _objc_init(<span class=\"keyword\">void</span>)</div><div class=\"line\">└──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_2_images(...)</div><div class=\"line\">    └──<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> \\*map_images_nolock(...)</div><div class=\"line\">        └──<span class=\"keyword\">void</span> _read_images(header_info **hList, uint32_t hCount)</div><div class=\"line\">        \t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> remethodizeClass(Class cls)</div><div class=\"line\">        \t\t└──<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches)</div></pre></td></tr></table></figure></p>\n<h3 id=\"Category-相关的数据结构\"><a href=\"#Category-相关的数据结构\" class=\"headerlink\" title=\"Category 相关的数据结构\"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> category_t &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *instanceMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> method_list_t *classMethods;</div><div class=\"line\">    <span class=\"keyword\">struct</span> protocol_list_t *protocols;</div><div class=\"line\">    <span class=\"keyword\">struct</span> property_list_t *instanceProperties;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>\n<h3 id=\"处理-Category\"><a href=\"#处理-Category\" class=\"headerlink\" title=\"处理 Category\"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> attachCategories(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flush_caches) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class=\"line\"></div><div class=\"line\">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</div><div class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></div><div class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</div><div class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</div><div class=\"line\">        auto&amp; entry = cats-&gt;list[i];</div><div class=\"line\"></div><div class=\"line\">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    auto rw = cls-&gt;data();</div><div class=\"line\"></div><div class=\"line\">    prepareMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle);</div><div class=\"line\">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class=\"line\">    free(mlists);</div><div class=\"line\">    <span class=\"keyword\">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class=\"number\">0</span>) flushCaches(cls);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先，通过 <code>while</code> 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。</p>\n<p>在 <code>while</code> 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto rw = cls-&gt;data();</div><div class=\"line\">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure></p>\n<p><code>rw</code> 是一个 <code>class_rw_t</code>类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> attachLists(List* <span class=\"keyword\">const</span> * addedLists, uint32_t addedCount) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (addedCount == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    uint32_t oldCount = array()-&gt;count;</div><div class=\"line\">    uint32_t newCount = oldCount + addedCount;</div><div class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class=\"line\">    array()-&gt;count = newCount;</div><div class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class=\"keyword\">sizeof</span>(array()-&gt;lists[<span class=\"number\">0</span>]));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>"},{"title":"runtime应用笔记","date":"2016-08-23T06:07:12.000Z","_content":"\n了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考[Runtime全方位装逼指南](http://www.jianshu.com/p/efeb33712445)，总结了以下几点应用场景。\n\n<!--more-->\n\n## 给category添加属性\n### 原理\n**对象关联**允许开发者对已经存在的类在 Category 中添加自定义的属性：\n```objc\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n- object 是源对象.\n- value 是被关联的对象.\n- key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.\n- policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：\n```objc\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：\n```objc\nobjc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n```\n\nobjc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.\n\n### 示例：\n新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n@property (nonatomic,copy) clickBlock click;\n@end\n```\n\n在.m中设置click的set，get方法(UIButton+ClickBlock.m):\n```objc\n#import \"UIButton+ClickBlock.h\"\n#import <objc/runtime.h>\n\nstatic const void *associatedKey = \"associatedKey\";\n\n@implementation UIButton (ClickBlock)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n-(clickBlock)click{\n    return objc_getAssociatedObject(self, associatedKey);\n}\n\n-(void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n```\n\n其中，在set方法中使用`addTarget:action:forControlEvents:`给button设置了点击事件。\n\n`self.click()`表示使用`self.click`获得block，再通过`block()`执行块。\n\n为什么不直接给click赋值，而是通过runtime的`objc_setAssociatedObject`方法呢？\n@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。\n\n@property在本例中只是为了在.h里声明一个getset方法。可替换成：\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n//@property (nonatomic,copy) clickBlock click;\n- (clickBlock)click;\n- (void)setClick:(clickBlock)click;\n@end\n```\n\n## 字典与模型转换\n### 原理\n字典转模型的时候：\n1. 根据字典的 key 生成 setter 方法.\n2. 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.\n\n模型转字典的时候：\n1. 调用 class_copyPropertyList 方法获取当前 Model 的所有属性.\n2. 调用 property_getName 获取属性名称.\n3. 根据属性名称生成 getter 方法.\n4. 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.\n\n### 示例\n```objc\n@interface NSObject (KeyValues)\n\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary;\n\n-(NSDictionary *)keyValuesWithObject;\n\n@end\n\n\n#import \"NSObject+KeyValues.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation NSObject (KeyValues)\n\n//字典转模型\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary{\n    id objc = [[self alloc] init];\n    for (NSString *key in aDictionary.allKeys) {\n        id value = aDictionary[key];\n        \n        /*判断当前属性是不是Model*/\n        objc_property_t property = class_getProperty(self, key.UTF8String);\n        unsigned int outCount = 0;\n        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &outCount);\n        objc_property_attribute_t attribute = attributeList[0];\n        NSString *typeString = [NSString stringWithUTF8String:attribute.value];\n        if ([typeString isEqualToString:@\"@\\\"TestModel\\\"\"]) {\n            value = [self objectWithKeyValues:value];\n        }\n        /**********************/\n        \n        //生成setter方法，并用objc_msgSend调用\n        NSString *methodName = [NSString stringWithFormat:@\"set%@%@:\",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];\n        SEL setter = sel_registerName(methodName.UTF8String);\n        if ([objc respondsToSelector:setter]) {\n            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);\n        }\n        free(attributeList);\n    }\n    return objc;\n}\n\n//模型转字典\n-(NSDictionary *)keyValuesWithObject{\n    unsigned int outCount = 0;\n    objc_property_t *propertyList = class_copyPropertyList([self class], &outCount);\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (int i = 0; i < outCount; i ++) {\n        objc_property_t property = propertyList[i];\n        \n        //生成getter方法，并用objc_msgSend调用\n        const char *propertyName = property_getName(property);\n        SEL getter = sel_registerName(propertyName);\n        if ([self respondsToSelector:getter]) {\n            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);\n            \n            /*判断当前属性是不是Model*/\n            if ([value isKindOfClass:[self class]] && value) {\n                value = [value keyValuesWithObject];\n            }\n            /**********************/\n            \n            if (value) {\n                NSString *key = [NSString stringWithUTF8String:propertyName];\n                [dict setObject:value forKey:key];\n            }\n        }\n        \n    }\n    free(propertyList);\n    return dict;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyValuesTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    NSLog(@\"name is %@\",model.name);\n    NSLog(@\"son name is %@\",model.son.name);\n    \n    NSDictionary *dict = [model keyValuesWithObject];\n    NSLog(@\"dict is %@\",dict);\n}\n```\n\n注意：\n1. 在NSObject中添加类方法，其中的`self`指的是`TestModel`这个类。\n2. `objc_property_t`具有两个属性，name和attribute。调用`property_getAttribute`将返回attribute的字符串。调用`property_copyAttributeList`则将字符串切分，返回一个`objc_property_attribute_t`类型的指针，`outCount`返回了属性的数量。\n\n---\noutCount使用了**指向指针的指针**的方式，使没有返回outCount的情况下，修改了outCount的值。\n\n例：\n```objc\n- (NSArray *)scanBeginStr:(NSString *)beginstr endStr:(NSString *)endstr inText:(NSMutableString * *)textPointer{\n    NSRange range1,range2;\n    NSUInteger location =0,length=0;\n    range1.location = 0;\n    NSMutableString *text = *textPointer;\n    NSMutableArray *rangeArray = [NSMutableArray array];\n    while (range1.location != NSNotFound) {\n        range1 = [text rangeOfString:beginstr];\n        range2 = [text rangeOfString:endstr];\n        if (range1.location != NSNotFound) {\n            location = range1.location;\n            length = range2.location - range1.location - 1;\n            if (length > 5000)break;\n            [text replaceOccurrencesOfString:beginstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];\n            [text replaceOccurrencesOfString:endstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];\n        }\n        [rangeArray addObject:@{@\"location\":@(location),@\"length\":@(length)}];\n    }\n    return rangeArray;\n}\n```\n使用：通过&取指针的地址\n```\n NSArray *rangeArray = [self scanBegin3Str:@\"<\" endStr:@\">\" inText:&mutableText];\n```\n\n---\n\n## 自动归档\n### 原理\n归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：\n```objc\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    [aCoder encodeObject:self.name forKey:@\"name\"];\n    [aCoder encodeObject:self.ID forKey:@\"ID\"];\n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        self.ID = [aDecoder decodeObjectForKey:@\"ID\"];\n        self.name = [aDecoder decodeObjectForKey:@\"name\"];\n    }\n    return self;\n}\n```\n如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：\n1. 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.\n2. 使用 ivar_getName 方法获取成员变量的名称.\n3. 通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.\n\n### 示例：\n```objc\n#import \"TestModel.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation TestModel\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    unsigned int outCount = 0;\n    Ivar *vars = class_copyIvarList([self class], &outCount);\n    for (int i = 0; i < outCount; i ++) {\n        Ivar var = vars[i];\n        const char *name = ivar_getName(var);\n        NSString *key = [NSString stringWithUTF8String:name];\n        \n        // 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法\n        // 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值\n        // 所以这里不需要再另外处理成员变量名称的“_”前缀\n        id value = [self valueForKey:key];\n        [aCoder encodeObject:value forKey:key];\n    }\n    free(vars);\n}\n\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        unsigned int outCount = 0;\n        Ivar *vars = class_copyIvarList([self class], &outCount);\n        for (int i = 0; i < outCount; i ++) {\n            Ivar var = vars[i];\n            const char *name = ivar_getName(var);\n            NSString *key = [NSString stringWithUTF8String:name];\n            id value = [aDecoder decodeObjectForKey:key];\n            [self setValue:value forKey:key];\n        }\n        free(vars);\n    }\n    return self;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyedArchiverTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    \n    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;\n    path = [path stringByAppendingPathComponent:@\"test\"];\n    [NSKeyedArchiver archiveRootObject:model toFile:path];\n    \n    TestModel *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n    NSLog(@\"m.name is %@\",m.name);\n    NSLog(@\"m.son name is %@\",m.son.name);\n}\n```\n\n## 动态方法解析与消息转发\n### 原理\n消息转发的大致过程如图：\n\n![消息转发流程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true)\n\n1. 当 Runtime 系统在`Cache`和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用`resolveInstanceMethod:`或`resolveClassMethod:`(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回`NO`，则进入下一步，若返回`YES`，则通过 `class_addMethod` 函数动态地添加方法，消息得到处理，此流程完毕.\n2. `resolveInstanceMethod:` 方法返回 `NO` 时，就会进入 `forwardingTargetForSelector:` 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 `selector`。返回`nil`，进入下一步，返回某个对象，则会调用该对象的方法.\n3. 若 `forwardingTargetForSelector:` 返回的是`nil`，则我们首先要通过 `methodSignatureForSelector:` 来指定方法签名，返回`nil`，表示不处理，若返回方法签名，则会进入下一步.\n4. 当第 `methodSignatureForSelector:` 方法返回方法签名后，就会调用 `forwardInvocation:` 方法，我们可以通过 `anInvocation` 对象做很多处理，比如修改实现方法，修改响应对象等.\n5. 如果到最后，消息还是没有得到响应，程序就会crash.\n\n### 示例：\n```objc\n#import \"Monkey.h\"\n#import \"Bird.h\"\n#import <objc/runtime.h>\n\n@implementation Monkey\n\n-(void)jump{\n    NSLog(@\"monkey can not fly, but! monkey can jump\");\n}\n\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    /*\n     如果当前对象调用了一个不存在的方法\n     Runtime会调用resolveInstanceMethod:来进行动态方法解析\n     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作\n     返回NO，则进入下一步forwardingTargetForSelector:\n     */\n    \n\tif(sel == @selector(fly)){\n    \tclass_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(\"jump\")), \"v@:\");\n    \treturn YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n    \n    /*\n     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会\n     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象\n     返回nil则进步下一步forwardInvocation:\n     */\n    \n#if 0\n    return nil;\n#else\n    return [[Bird alloc] init];\n#endif\n}\n\n-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    /*\n     获取方法签名进入下一步，进行消息转发\n     */\n    \n    return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n}\n\n-(void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    /*\n     消息转发\n     */\n    \n    return [anInvocation invokeWithTarget:[[Bird alloc] init]];\n}\n\n@end\n```\n\n其中 `\"v@:\"` 表示返回值和参数,这个符号涉及[Type Encoding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)以及[关于type encodings的理解--runtime programming guide](http://www.jianshu.com/p/f4129b5194c0)。\n\n---\n其中**v**表示返回`void`类型，**@**表示参数`id(self)`，**：**表示`SEL(_cmd)`这几个是必须要有的，后面可以接入参类型。\n\n举个例子：`\"i@:@\"`\n**i**表示返回值类型`int`\n**@：**和上面意义相同\n**@**最后一个@表示有一个入参，是`id`类型。\n\n不过，实际上，这个东西好像没什么用，因为在`class_addMethod`上试验过，随便传任何字符串都一样能正常运行。\n\n---\n一般来说可以使用`method_getTypeEncoding()`获取更详细的Type_Encoding,下面例子中也会用到。\n\n### 转发与多继承\n转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。\n![runtime_transmit](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true)\n\n这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中`Warrior`和`Diplomat`没有继承关系，但是`Warrior`将`negotiate`消息转发给了`Diplomat`后，就好似`Diplomat`是`Warrior`的超类一样。\n\n消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。\n\n## Runtime-动态创建类添加属性和方法\n```objc\n- (void)createClass\n{\n    Class MyClass = objc_allocateClassPair([NSObject class], \"myclass\", 0);\n    //添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型\n    if (class_addIvar(MyClass, \"itest\", sizeof(NSString *), 0, \"@\")) {\n        NSLog(@\"add ivar success\");\n    }\n    //myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding\n    class_addMethod(MyClass, @selector(myclasstest:), (IMP)myclasstest, \"v@:\");\n    //注册这个类到runtime系统中就可以使用他了\n    objc_registerClassPair(MyClass);\n    //生成了一个实例化对象\n    id myobj = [[MyClass alloc] init];\n    NSString *str = @\"asdb\";\n    //给刚刚添加的变量赋值\n    //    object_setInstanceVariable(myobj, \"itest\", (void *)&str);在ARC下不允许使用\n    [myobj setValue:str forKey:@\"itest\"];\n    //调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息\n    [myobj myclasstest:10];\n\n}\n//这个方法实际上没有被调用,但是必须实现否则编译都不能通过\n- (void)myclasstest:(int)a\n{\n    \n}\n//调用的是这个方法\nstatic void myclasstest(id self, SEL _cmd, int a) //self和_cmd是必须的，在之后可以随意添加其他参数\n{\n    \n    Ivar v = class_getInstanceVariable([self class], \"itest\");\n    //返回名为itest的ivar的变量的值\n    id o = object_getIvar(self, v);\n    //成功打印出结果\n    NSLog(@\"%@\", o);\n    NSLog(@\"int a is %d\", a);\n}\n```\n\n## Method Swizzling\n此部分参考自[Objective-C的方法替换](http://blog.csdn.net/horkychen/article/details/8532087)、[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)等系列文章\n### 例子\n```objc\n#import <objc/runtime.h> \n \n@implementation UIViewController (Tracking) \n \n+ (void)load { \n    static dispatch_once_t onceToken; \n    dispatch_once(&onceToken, ^{ \n        Class aClass = [self class]; \n \n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n        \n        // When swizzling a class method, use the following:\n        // Class aClass = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(aClass, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n \n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n \n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        } \n    }); \n} \n \n#pragma mark - Method Swizzling \n \n- (void)xxx_viewWillAppear:(BOOL)animated { \n    [self xxx_viewWillAppear:animated]; \n    NSLog(@\"viewWillAppear: %@\", self); \n} \n \n@end\n```\n\n### 原理\n#### 概述\n在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。\n\n每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图\n![runtime_swizzling_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true)\n\n通过Swizzling需要实现的是偷换selector的IMP，如下图所示：\n![runtime_swizzling_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true)\n\n#### 实现过程\n上面的代码通过添加一个`Tracking`类别到`UIViewController`类中，将`UIViewController`类的`viewWillAppear:`方法和`Tracking`类别中`xxx_viewWillAppear:`方法的实现相互调换。Swizzling 应该在`+load`方法中实现，因为`+load`是在一个类最开始加载时调用。`dispatch_once`是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。\n\n实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉`UIViewController`中的`viewWillAppear:`方法。这两种情况要区别对待。\n\n对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(`xxx_viewWillAppear:`)，然后将复写的方法替换为原先的实现(`viewWillAppear:`).\n\n```objc\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n```\n`class_addMethod`将本来不存在于被操作的Class里的`swizzledMethod`的实现添加在被操作的Class里,并使用`originalSelector`作为其选择子。如果发现方法已经存在，会失败返回。\n\n---\n通过上一篇[runtime原理](https://zhang759740844.github.io/2016/08/22/runtime原理/)的分析，`class_addMethod`应该是先在类的method数组里找是否有这个`SEL`,如果没有就添加一个`method_t`。\n\n---\n\n如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:\n```objc\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n```\n`addMethod`会让当前类的方法(IMP)指向新的实现(SEL)，使用`replaceMethod`再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法`SEL`来调用，就会实现新方法的`IMP`，通过新方法的`SEL`来调用，就会实现旧方法的`IMP`。\n\n如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过`method_exchangeImplementations`直接交换两个`method_t`的`IMP`:\n```objc\nelse {\n    method_exchangeImplementations(originalMethod, overrideMethod);\n}\n```\n\n所以本例中由于`viewWillAppear:`已经在UIViewController中实现过了，所以，`class_addMethod`失败，通过`method_exchangeImplementations`达到交换实现。如果要通过`class_addMethod`添加，需要自定义一个View继承UIViewController，再在这个类中替换`viewWillAppear:`。\n\n\n如果类中没有想被替换实现的原方法时，`class_replaceMethod`相当于直接调用`class_addMethod`向类中添加该方法的实现。\n\n`method_exchangeImplementations`方法做的事情与如下的原子操作等价：\n```objc\nIMP imp1 = method_getImplementation(m1);\nIMP imp2 = method_getImplementation(m2);\nmethod_setImplementation(m1, imp2);\nmethod_setImplementation(m2, imp1);\n```\n直接设置了`method`:`m1`,`m2`的`IMP`，简单暴力。\n\n对于注释了的这几行:\n```objc\n// When swizzling a class method, use the following:\n// Class aClass = object_getClass((id)self);\n// ...\n// Method originalMethod = class_getClassMethod(aClass, originalSelector);\n// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n```\n`object_getClass((id)self)` 与 `[self class]` 返回的结果类型都是 `Class`,但前者为元类,后者为其本身,因为此时 `self` 为 `Class` 而不是实例.注意 `[NSObject class]` 与 `[object实例 class]` 的区别：\n```objc\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n`object_getClass()`方法返回对象的`isa`。\n\n最后，`xxx_viewWillAppear:`方法的定义看似是递归调用引发死循环，其实不会的。因为`[self xxx_viewWillAppear:animated]`消息会动态找到`xxx_viewWillAppear:`方法的实现，而它的实现已经被我们与`viewWillAppear:`方法实现进行了互换，所以这段代码不仅不会死循环，如果你把`[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]`反而会引发死循环。\n\n> Demo 详见RuntimeLearn\n\n\n","source":"_posts/runtime应用.md","raw":"title: runtime应用笔记\ndate: 2016/8/23 14:07:12  \ncategories: IOS\ntags: [Runtime]\n\n---\n\n了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考[Runtime全方位装逼指南](http://www.jianshu.com/p/efeb33712445)，总结了以下几点应用场景。\n\n<!--more-->\n\n## 给category添加属性\n### 原理\n**对象关联**允许开发者对已经存在的类在 Category 中添加自定义的属性：\n```objc\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n- object 是源对象.\n- value 是被关联的对象.\n- key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.\n- policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：\n```objc\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：\n```objc\nobjc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n```\n\nobjc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.\n\n### 示例：\n新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n@property (nonatomic,copy) clickBlock click;\n@end\n```\n\n在.m中设置click的set，get方法(UIButton+ClickBlock.m):\n```objc\n#import \"UIButton+ClickBlock.h\"\n#import <objc/runtime.h>\n\nstatic const void *associatedKey = \"associatedKey\";\n\n@implementation UIButton (ClickBlock)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n-(clickBlock)click{\n    return objc_getAssociatedObject(self, associatedKey);\n}\n\n-(void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n```\n\n其中，在set方法中使用`addTarget:action:forControlEvents:`给button设置了点击事件。\n\n`self.click()`表示使用`self.click`获得block，再通过`block()`执行块。\n\n为什么不直接给click赋值，而是通过runtime的`objc_setAssociatedObject`方法呢？\n@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。\n\n@property在本例中只是为了在.h里声明一个getset方法。可替换成：\n```objc\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (ClickBlock)\n//@property (nonatomic,copy) clickBlock click;\n- (clickBlock)click;\n- (void)setClick:(clickBlock)click;\n@end\n```\n\n## 字典与模型转换\n### 原理\n字典转模型的时候：\n1. 根据字典的 key 生成 setter 方法.\n2. 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.\n\n模型转字典的时候：\n1. 调用 class_copyPropertyList 方法获取当前 Model 的所有属性.\n2. 调用 property_getName 获取属性名称.\n3. 根据属性名称生成 getter 方法.\n4. 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.\n\n### 示例\n```objc\n@interface NSObject (KeyValues)\n\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary;\n\n-(NSDictionary *)keyValuesWithObject;\n\n@end\n\n\n#import \"NSObject+KeyValues.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation NSObject (KeyValues)\n\n//字典转模型\n+(id)objectWithKeyValues:(NSDictionary *)aDictionary{\n    id objc = [[self alloc] init];\n    for (NSString *key in aDictionary.allKeys) {\n        id value = aDictionary[key];\n        \n        /*判断当前属性是不是Model*/\n        objc_property_t property = class_getProperty(self, key.UTF8String);\n        unsigned int outCount = 0;\n        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &outCount);\n        objc_property_attribute_t attribute = attributeList[0];\n        NSString *typeString = [NSString stringWithUTF8String:attribute.value];\n        if ([typeString isEqualToString:@\"@\\\"TestModel\\\"\"]) {\n            value = [self objectWithKeyValues:value];\n        }\n        /**********************/\n        \n        //生成setter方法，并用objc_msgSend调用\n        NSString *methodName = [NSString stringWithFormat:@\"set%@%@:\",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];\n        SEL setter = sel_registerName(methodName.UTF8String);\n        if ([objc respondsToSelector:setter]) {\n            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);\n        }\n        free(attributeList);\n    }\n    return objc;\n}\n\n//模型转字典\n-(NSDictionary *)keyValuesWithObject{\n    unsigned int outCount = 0;\n    objc_property_t *propertyList = class_copyPropertyList([self class], &outCount);\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    for (int i = 0; i < outCount; i ++) {\n        objc_property_t property = propertyList[i];\n        \n        //生成getter方法，并用objc_msgSend调用\n        const char *propertyName = property_getName(property);\n        SEL getter = sel_registerName(propertyName);\n        if ([self respondsToSelector:getter]) {\n            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);\n            \n            /*判断当前属性是不是Model*/\n            if ([value isKindOfClass:[self class]] && value) {\n                value = [value keyValuesWithObject];\n            }\n            /**********************/\n            \n            if (value) {\n                NSString *key = [NSString stringWithUTF8String:propertyName];\n                [dict setObject:value forKey:key];\n            }\n        }\n        \n    }\n    free(propertyList);\n    return dict;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyValuesTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    NSLog(@\"name is %@\",model.name);\n    NSLog(@\"son name is %@\",model.son.name);\n    \n    NSDictionary *dict = [model keyValuesWithObject];\n    NSLog(@\"dict is %@\",dict);\n}\n```\n\n注意：\n1. 在NSObject中添加类方法，其中的`self`指的是`TestModel`这个类。\n2. `objc_property_t`具有两个属性，name和attribute。调用`property_getAttribute`将返回attribute的字符串。调用`property_copyAttributeList`则将字符串切分，返回一个`objc_property_attribute_t`类型的指针，`outCount`返回了属性的数量。\n\n---\noutCount使用了**指向指针的指针**的方式，使没有返回outCount的情况下，修改了outCount的值。\n\n例：\n```objc\n- (NSArray *)scanBeginStr:(NSString *)beginstr endStr:(NSString *)endstr inText:(NSMutableString * *)textPointer{\n    NSRange range1,range2;\n    NSUInteger location =0,length=0;\n    range1.location = 0;\n    NSMutableString *text = *textPointer;\n    NSMutableArray *rangeArray = [NSMutableArray array];\n    while (range1.location != NSNotFound) {\n        range1 = [text rangeOfString:beginstr];\n        range2 = [text rangeOfString:endstr];\n        if (range1.location != NSNotFound) {\n            location = range1.location;\n            length = range2.location - range1.location - 1;\n            if (length > 5000)break;\n            [text replaceOccurrencesOfString:beginstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];\n            [text replaceOccurrencesOfString:endstr withString:@\"\" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];\n        }\n        [rangeArray addObject:@{@\"location\":@(location),@\"length\":@(length)}];\n    }\n    return rangeArray;\n}\n```\n使用：通过&取指针的地址\n```\n NSArray *rangeArray = [self scanBegin3Str:@\"<\" endStr:@\">\" inText:&mutableText];\n```\n\n---\n\n## 自动归档\n### 原理\n归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：\n```objc\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    [aCoder encodeObject:self.name forKey:@\"name\"];\n    [aCoder encodeObject:self.ID forKey:@\"ID\"];\n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        self.ID = [aDecoder decodeObjectForKey:@\"ID\"];\n        self.name = [aDecoder decodeObjectForKey:@\"name\"];\n    }\n    return self;\n}\n```\n如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：\n1. 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.\n2. 使用 ivar_getName 方法获取成员变量的名称.\n3. 通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.\n\n### 示例：\n```objc\n#import \"TestModel.h\"\n#import <objc/runtime.h>\n#import <objc/message.h>\n\n@implementation TestModel\n- (void)encodeWithCoder:(NSCoder *)aCoder{\n    unsigned int outCount = 0;\n    Ivar *vars = class_copyIvarList([self class], &outCount);\n    for (int i = 0; i < outCount; i ++) {\n        Ivar var = vars[i];\n        const char *name = ivar_getName(var);\n        NSString *key = [NSString stringWithUTF8String:name];\n        \n        // 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法\n        // 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值\n        // 所以这里不需要再另外处理成员变量名称的“_”前缀\n        id value = [self valueForKey:key];\n        [aCoder encodeObject:value forKey:key];\n    }\n    free(vars);\n}\n\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder{\n    if (self = [super init]) {\n        unsigned int outCount = 0;\n        Ivar *vars = class_copyIvarList([self class], &outCount);\n        for (int i = 0; i < outCount; i ++) {\n            Ivar var = vars[i];\n            const char *name = ivar_getName(var);\n            NSString *key = [NSString stringWithUTF8String:name];\n            id value = [aDecoder decodeObjectForKey:key];\n            [self setValue:value forKey:key];\n        }\n        free(vars);\n    }\n    return self;\n}\n@end\n```\n\n使用：\n```objc\n-(void)keyedArchiverTest{\n    \n    TestModel *model = [TestModel objectWithKeyValues:dictionary];\n    \n    NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;\n    path = [path stringByAppendingPathComponent:@\"test\"];\n    [NSKeyedArchiver archiveRootObject:model toFile:path];\n    \n    TestModel *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n    NSLog(@\"m.name is %@\",m.name);\n    NSLog(@\"m.son name is %@\",m.son.name);\n}\n```\n\n## 动态方法解析与消息转发\n### 原理\n消息转发的大致过程如图：\n\n![消息转发流程](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true)\n\n1. 当 Runtime 系统在`Cache`和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用`resolveInstanceMethod:`或`resolveClassMethod:`(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回`NO`，则进入下一步，若返回`YES`，则通过 `class_addMethod` 函数动态地添加方法，消息得到处理，此流程完毕.\n2. `resolveInstanceMethod:` 方法返回 `NO` 时，就会进入 `forwardingTargetForSelector:` 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 `selector`。返回`nil`，进入下一步，返回某个对象，则会调用该对象的方法.\n3. 若 `forwardingTargetForSelector:` 返回的是`nil`，则我们首先要通过 `methodSignatureForSelector:` 来指定方法签名，返回`nil`，表示不处理，若返回方法签名，则会进入下一步.\n4. 当第 `methodSignatureForSelector:` 方法返回方法签名后，就会调用 `forwardInvocation:` 方法，我们可以通过 `anInvocation` 对象做很多处理，比如修改实现方法，修改响应对象等.\n5. 如果到最后，消息还是没有得到响应，程序就会crash.\n\n### 示例：\n```objc\n#import \"Monkey.h\"\n#import \"Bird.h\"\n#import <objc/runtime.h>\n\n@implementation Monkey\n\n-(void)jump{\n    NSLog(@\"monkey can not fly, but! monkey can jump\");\n}\n\n+(BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    /*\n     如果当前对象调用了一个不存在的方法\n     Runtime会调用resolveInstanceMethod:来进行动态方法解析\n     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作\n     返回NO，则进入下一步forwardingTargetForSelector:\n     */\n    \n\tif(sel == @selector(fly)){\n    \tclass_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName(\"jump\")), \"v@:\");\n    \treturn YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n\n-(id)forwardingTargetForSelector:(SEL)aSelector{\n    \n    /*\n     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会\n     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象\n     返回nil则进步下一步forwardInvocation:\n     */\n    \n#if 0\n    return nil;\n#else\n    return [[Bird alloc] init];\n#endif\n}\n\n-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    /*\n     获取方法签名进入下一步，进行消息转发\n     */\n    \n    return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n}\n\n-(void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    /*\n     消息转发\n     */\n    \n    return [anInvocation invokeWithTarget:[[Bird alloc] init]];\n}\n\n@end\n```\n\n其中 `\"v@:\"` 表示返回值和参数,这个符号涉及[Type Encoding](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html)以及[关于type encodings的理解--runtime programming guide](http://www.jianshu.com/p/f4129b5194c0)。\n\n---\n其中**v**表示返回`void`类型，**@**表示参数`id(self)`，**：**表示`SEL(_cmd)`这几个是必须要有的，后面可以接入参类型。\n\n举个例子：`\"i@:@\"`\n**i**表示返回值类型`int`\n**@：**和上面意义相同\n**@**最后一个@表示有一个入参，是`id`类型。\n\n不过，实际上，这个东西好像没什么用，因为在`class_addMethod`上试验过，随便传任何字符串都一样能正常运行。\n\n---\n一般来说可以使用`method_getTypeEncoding()`获取更详细的Type_Encoding,下面例子中也会用到。\n\n### 转发与多继承\n转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。\n![runtime_transmit](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true)\n\n这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中`Warrior`和`Diplomat`没有继承关系，但是`Warrior`将`negotiate`消息转发给了`Diplomat`后，就好似`Diplomat`是`Warrior`的超类一样。\n\n消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。\n\n## Runtime-动态创建类添加属性和方法\n```objc\n- (void)createClass\n{\n    Class MyClass = objc_allocateClassPair([NSObject class], \"myclass\", 0);\n    //添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型\n    if (class_addIvar(MyClass, \"itest\", sizeof(NSString *), 0, \"@\")) {\n        NSLog(@\"add ivar success\");\n    }\n    //myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding\n    class_addMethod(MyClass, @selector(myclasstest:), (IMP)myclasstest, \"v@:\");\n    //注册这个类到runtime系统中就可以使用他了\n    objc_registerClassPair(MyClass);\n    //生成了一个实例化对象\n    id myobj = [[MyClass alloc] init];\n    NSString *str = @\"asdb\";\n    //给刚刚添加的变量赋值\n    //    object_setInstanceVariable(myobj, \"itest\", (void *)&str);在ARC下不允许使用\n    [myobj setValue:str forKey:@\"itest\"];\n    //调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息\n    [myobj myclasstest:10];\n\n}\n//这个方法实际上没有被调用,但是必须实现否则编译都不能通过\n- (void)myclasstest:(int)a\n{\n    \n}\n//调用的是这个方法\nstatic void myclasstest(id self, SEL _cmd, int a) //self和_cmd是必须的，在之后可以随意添加其他参数\n{\n    \n    Ivar v = class_getInstanceVariable([self class], \"itest\");\n    //返回名为itest的ivar的变量的值\n    id o = object_getIvar(self, v);\n    //成功打印出结果\n    NSLog(@\"%@\", o);\n    NSLog(@\"int a is %d\", a);\n}\n```\n\n## Method Swizzling\n此部分参考自[Objective-C的方法替换](http://blog.csdn.net/horkychen/article/details/8532087)、[Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)等系列文章\n### 例子\n```objc\n#import <objc/runtime.h> \n \n@implementation UIViewController (Tracking) \n \n+ (void)load { \n    static dispatch_once_t onceToken; \n    dispatch_once(&onceToken, ^{ \n        Class aClass = [self class]; \n \n        SEL originalSelector = @selector(viewWillAppear:); \n        SEL swizzledSelector = @selector(xxx_viewWillAppear:); \n \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); \n        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); \n        \n        // When swizzling a class method, use the following:\n        // Class aClass = object_getClass((id)self);\n        // ...\n        // Method originalMethod = class_getClassMethod(aClass, originalSelector);\n        // Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n \n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n \n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n        } else { \n            method_exchangeImplementations(originalMethod, swizzledMethod); \n        } \n    }); \n} \n \n#pragma mark - Method Swizzling \n \n- (void)xxx_viewWillAppear:(BOOL)animated { \n    [self xxx_viewWillAppear:animated]; \n    NSLog(@\"viewWillAppear: %@\", self); \n} \n \n@end\n```\n\n### 原理\n#### 概述\n在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。\n\n每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图\n![runtime_swizzling_1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true)\n\n通过Swizzling需要实现的是偷换selector的IMP，如下图所示：\n![runtime_swizzling_2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true)\n\n#### 实现过程\n上面的代码通过添加一个`Tracking`类别到`UIViewController`类中，将`UIViewController`类的`viewWillAppear:`方法和`Tracking`类别中`xxx_viewWillAppear:`方法的实现相互调换。Swizzling 应该在`+load`方法中实现，因为`+load`是在一个类最开始加载时调用。`dispatch_once`是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。\n\n实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉`UIViewController`中的`viewWillAppear:`方法。这两种情况要区别对待。\n\n对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(`xxx_viewWillAppear:`)，然后将复写的方法替换为原先的实现(`viewWillAppear:`).\n\n```objc\n        BOOL didAddMethod = \n            class_addMethod(aClass, \n                originalSelector, \n                method_getImplementation(swizzledMethod), \n                method_getTypeEncoding(swizzledMethod)); \n```\n`class_addMethod`将本来不存在于被操作的Class里的`swizzledMethod`的实现添加在被操作的Class里,并使用`originalSelector`作为其选择子。如果发现方法已经存在，会失败返回。\n\n---\n通过上一篇[runtime原理](https://zhang759740844.github.io/2016/08/22/runtime原理/)的分析，`class_addMethod`应该是先在类的method数组里找是否有这个`SEL`,如果没有就添加一个`method_t`。\n\n---\n\n如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:\n```objc\n        if (didAddMethod) { \n            class_replaceMethod(aClass, \n                swizzledSelector, \n                method_getImplementation(originalMethod), \n                method_getTypeEncoding(originalMethod)); \n```\n`addMethod`会让当前类的方法(IMP)指向新的实现(SEL)，使用`replaceMethod`再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法`SEL`来调用，就会实现新方法的`IMP`，通过新方法的`SEL`来调用，就会实现旧方法的`IMP`。\n\n如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过`method_exchangeImplementations`直接交换两个`method_t`的`IMP`:\n```objc\nelse {\n    method_exchangeImplementations(originalMethod, overrideMethod);\n}\n```\n\n所以本例中由于`viewWillAppear:`已经在UIViewController中实现过了，所以，`class_addMethod`失败，通过`method_exchangeImplementations`达到交换实现。如果要通过`class_addMethod`添加，需要自定义一个View继承UIViewController，再在这个类中替换`viewWillAppear:`。\n\n\n如果类中没有想被替换实现的原方法时，`class_replaceMethod`相当于直接调用`class_addMethod`向类中添加该方法的实现。\n\n`method_exchangeImplementations`方法做的事情与如下的原子操作等价：\n```objc\nIMP imp1 = method_getImplementation(m1);\nIMP imp2 = method_getImplementation(m2);\nmethod_setImplementation(m1, imp2);\nmethod_setImplementation(m2, imp1);\n```\n直接设置了`method`:`m1`,`m2`的`IMP`，简单暴力。\n\n对于注释了的这几行:\n```objc\n// When swizzling a class method, use the following:\n// Class aClass = object_getClass((id)self);\n// ...\n// Method originalMethod = class_getClassMethod(aClass, originalSelector);\n// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);\n```\n`object_getClass((id)self)` 与 `[self class]` 返回的结果类型都是 `Class`,但前者为元类,后者为其本身,因为此时 `self` 为 `Class` 而不是实例.注意 `[NSObject class]` 与 `[object实例 class]` 的区别：\n```objc\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n`object_getClass()`方法返回对象的`isa`。\n\n最后，`xxx_viewWillAppear:`方法的定义看似是递归调用引发死循环，其实不会的。因为`[self xxx_viewWillAppear:animated]`消息会动态找到`xxx_viewWillAppear:`方法的实现，而它的实现已经被我们与`viewWillAppear:`方法实现进行了互换，所以这段代码不仅不会死循环，如果你把`[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]`反而会引发死循环。\n\n> Demo 详见RuntimeLearn\n\n\n","slug":"runtime应用","published":1,"updated":"2016-09-23T05:45:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyh003irgru41ycfaa6","content":"<p>了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考<a href=\"http://www.jianshu.com/p/efeb33712445\" target=\"_blank\" rel=\"external\">Runtime全方位装逼指南</a>，总结了以下几点应用场景。</p>\n<a id=\"more\"></a>\n<h2 id=\"给category添加属性\"><a href=\"#给category添加属性\" class=\"headerlink\" title=\"给category添加属性\"></a>给category添加属性</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>对象关联</strong>允许开发者对已经存在的类在 Category 中添加自定义的属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>object 是源对象.</li>\n<li>value 是被关联的对象.</li>\n<li>key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.</li>\n<li>policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </span></div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </span></div><div class=\"line\">                                            *   The association is not made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</span></div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</span></div><div class=\"line\">                                            *   The association is made atomically. */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>\n<p>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</p>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><p>新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中设置click的set，get方法(UIButton+ClickBlock.m):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+ClickBlock.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *associatedKey = <span class=\"string\">\"associatedKey\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(clickBlock)click&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)buttonClick&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.click();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>其中，在set方法中使用<code>addTarget:action:forControlEvents:</code>给button设置了点击事件。</p>\n<p><code>self.click()</code>表示使用<code>self.click</code>获得block，再通过<code>block()</code>执行块。</p>\n<p>为什么不直接给click赋值，而是通过runtime的<code>objc_setAssociatedObject</code>方法呢？<br>@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。</p>\n<p>@property在本例中只是为了在.h里声明一个getset方法。可替换成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"comment\">//@property (nonatomic,copy) clickBlock click;</span></div><div class=\"line\">- (clickBlock)click;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setClick:(clickBlock)click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"字典与模型转换\"><a href=\"#字典与模型转换\" class=\"headerlink\" title=\"字典与模型转换\"></a>字典与模型转换</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>字典转模型的时候：</p>\n<ol>\n<li>根据字典的 key 生成 setter 方法.</li>\n<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>\n</ol>\n<p>模型转字典的时候：</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSObject+KeyValues.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典转模型</span></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> aDictionary.allKeys) &#123;</div><div class=\"line\">        <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">        objc_property_t property = class_getProperty(<span class=\"keyword\">self</span>, key.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class=\"line\">        objc_property_attribute_t attribute = attributeList[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *typeString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:attribute.value];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([typeString isEqualToString:<span class=\"string\">@\"@\\\"TestModel\\\"\"</span>]) &#123;</div><div class=\"line\">            value = [<span class=\"keyword\">self</span> objectWithKeyValues:value];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**********************/</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成setter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"set%@%@:\"</span>,[key substringToIndex:<span class=\"number\">1</span>].uppercaseString,[key substringFromIndex:<span class=\"number\">1</span>]];</div><div class=\"line\">        SEL <span class=\"keyword\">setter</span> = sel_registerName(methodName.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([objc respondsToSelector:<span class=\"keyword\">setter</span>]) &#123;</div><div class=\"line\">            ((<span class=\"keyword\">void</span> (*) (<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">id</span>)) objc_msgSend) (objc,<span class=\"keyword\">setter</span>,value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(attributeList);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//模型转字典</span></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    objc_property_t *propertyList = class_copyPropertyList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        objc_property_t property = propertyList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成getter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(property);</div><div class=\"line\">        SEL <span class=\"keyword\">getter</span> = sel_registerName(propertyName);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">getter</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">id</span> value = ((<span class=\"keyword\">id</span> (*) (<span class=\"keyword\">id</span>,SEL)) objc_msgSend) (<span class=\"keyword\">self</span>,<span class=\"keyword\">getter</span>);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]] &amp;&amp; value) &#123;</div><div class=\"line\">                value = [value keyValuesWithObject];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**********************/</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (value) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName];</div><div class=\"line\">                [dict setObject:value forKey:key];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    free(propertyList);</div><div class=\"line\">    <span class=\"keyword\">return</span> dict;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyValuesTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name is %@\"</span>,model.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"son name is %@\"</span>,model.son.name);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *dict = [model keyValuesWithObject];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"dict is %@\"</span>,dict);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在NSObject中添加类方法，其中的<code>self</code>指的是<code>TestModel</code>这个类。</li>\n<li><code>objc_property_t</code>具有两个属性，name和attribute。调用<code>property_getAttribute</code>将返回attribute的字符串。调用<code>property_copyAttributeList</code>则将字符串切分，返回一个<code>objc_property_attribute_t</code>类型的指针，<code>outCount</code>返回了属性的数量。</li>\n</ol>\n<hr>\n<p>outCount使用了<strong>指向指针的指针</strong>的方式，使没有返回outCount的情况下，修改了outCount的值。</p>\n<p>例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)scanBeginStr:(<span class=\"built_in\">NSString</span> *)beginstr endStr:(<span class=\"built_in\">NSString</span> *)endstr inText:(<span class=\"built_in\">NSMutableString</span> * *)textPointer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> range1,range2;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> location =<span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">    range1.location = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *text = *textPointer;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *rangeArray = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">    <span class=\"keyword\">while</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">        range1 = [text rangeOfString:beginstr];</div><div class=\"line\">        range2 = [text rangeOfString:endstr];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            location = range1.location;</div><div class=\"line\">            length = range2.location - range1.location - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">5000</span>)<span class=\"keyword\">break</span>;</div><div class=\"line\">            [text replaceOccurrencesOfString:beginstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range1.location + range1.length)];</div><div class=\"line\">            [text replaceOccurrencesOfString:endstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range2.location + range2.length - <span class=\"number\">1</span>)];</div><div class=\"line\">        &#125;</div><div class=\"line\">        [rangeArray addObject:@&#123;<span class=\"string\">@\"location\"</span>:@(location),<span class=\"string\">@\"length\"</span>:@(length)&#125;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rangeArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用：通过&amp;取指针的地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText];</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"自动归档\"><a href=\"#自动归档\" class=\"headerlink\" title=\"自动归档\"></a>自动归档</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.ID forKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.ID = [aDecoder decodeObjectForKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：</p>\n<ol>\n<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>\n<li>使用 ivar_getName 方法获取成员变量的名称.</li>\n<li>通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</li>\n</ol>\n<h3 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TestModel.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestModel</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        Ivar var = vars[i];</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></div><div class=\"line\">        <span class=\"comment\">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></div><div class=\"line\">        <span class=\"comment\">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = [<span class=\"keyword\">self</span> valueForKey:key];</div><div class=\"line\">        [aCoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">            Ivar var = vars[i];</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">            <span class=\"keyword\">id</span> value = [aDecoder decodeObjectForKey:key];</div><div class=\"line\">            [<span class=\"keyword\">self</span> setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(vars);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyedArchiverTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).lastObject;</div><div class=\"line\">    path = [path stringByAppendingPathComponent:<span class=\"string\">@\"test\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:model toFile:path];</div><div class=\"line\">    </div><div class=\"line\">    TestModel *m = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.name is %@\"</span>,m.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.son name is %@\"</span>,m.son.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"动态方法解析与消息转发\"><a href=\"#动态方法解析与消息转发\" class=\"headerlink\" title=\"动态方法解析与消息转发\"></a>动态方法解析与消息转发</h2><h3 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>消息转发的大致过程如图：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true\" alt=\"消息转发流程\"></p>\n<ol>\n<li>当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回<code>NO</code>，则进入下一步，若返回<code>YES</code>，则通过 <code>class_addMethod</code> 函数动态地添加方法，消息得到处理，此流程完毕.</li>\n<li><code>resolveInstanceMethod:</code> 方法返回 <code>NO</code> 时，就会进入 <code>forwardingTargetForSelector:</code> 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 <code>selector</code>。返回<code>nil</code>，进入下一步，返回某个对象，则会调用该对象的方法.</li>\n<li>若 <code>forwardingTargetForSelector:</code> 返回的是<code>nil</code>，则我们首先要通过 <code>methodSignatureForSelector:</code> 来指定方法签名，返回<code>nil</code>，表示不处理，若返回方法签名，则会进入下一步.</li>\n<li>当第 <code>methodSignatureForSelector:</code> 方法返回方法签名后，就会调用 <code>forwardInvocation:</code> 方法，我们可以通过 <code>anInvocation</code> 对象做很多处理，比如修改实现方法，修改响应对象等.</li>\n<li>如果到最后，消息还是没有得到响应，程序就会crash.</li>\n</ol>\n<h3 id=\"示例：-2\"><a href=\"#示例：-2\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Monkey.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Bird.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Monkey</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)jump&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"monkey can not fly, but! monkey can jump\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     如果当前对象调用了一个不存在的方法</div><div class=\"line\">     Runtime会调用resolveInstanceMethod:来进行动态方法解析</div><div class=\"line\">     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作</div><div class=\"line\">     返回NO，则进入下一步forwardingTargetForSelector:</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"keyword\">if</span>(sel == <span class=\"keyword\">@selector</span>(fly))&#123;</div><div class=\"line\">    \tclass_addMethod(<span class=\"keyword\">self</span>, sel, class_getMethodImplementation(<span class=\"keyword\">self</span>, sel_registerName(<span class=\"string\">\"jump\"</span>)), <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会</div><div class=\"line\">     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象</div><div class=\"line\">     返回nil则进步下一步forwardInvocation:</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">#if 0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\">    <span class=\"keyword\">return</span> [[Bird alloc] init];</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     获取方法签名进入下一步，进行消息转发</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     消息转发</div><div class=\"line\">     */</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [anInvocation invokeWithTarget:[[Bird alloc] init]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中 <code>&quot;v@:&quot;</code> 表示返回值和参数,这个符号涉及<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\" target=\"_blank\" rel=\"external\">Type Encoding</a>以及<a href=\"http://www.jianshu.com/p/f4129b5194c0\" target=\"_blank\" rel=\"external\">关于type encodings的理解–runtime programming guide</a>。</p>\n<hr>\n<p>其中<strong>v</strong>表示返回<code>void</code>类型，<strong>@</strong>表示参数<code>id(self)</code>，<strong>：</strong>表示<code>SEL(_cmd)</code>这几个是必须要有的，后面可以接入参类型。</p>\n<p>举个例子：<code>&quot;i@:@&quot;</code><br><strong>i</strong>表示返回值类型<code>int</code><br><strong>@：</strong>和上面意义相同<br><strong>@</strong>最后一个@表示有一个入参，是<code>id</code>类型。</p>\n<p>不过，实际上，这个东西好像没什么用，因为在<code>class_addMethod</code>上试验过，随便传任何字符串都一样能正常运行。</p>\n<hr>\n<p>一般来说可以使用<code>method_getTypeEncoding()</code>获取更详细的Type_Encoding,下面例子中也会用到。</p>\n<h3 id=\"转发与多继承\"><a href=\"#转发与多继承\" class=\"headerlink\" title=\"转发与多继承\"></a>转发与多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true\" alt=\"runtime_transmit\"></p>\n<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>\n<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>\n<h2 id=\"Runtime-动态创建类添加属性和方法\"><a href=\"#Runtime-动态创建类添加属性和方法\" class=\"headerlink\" title=\"Runtime-动态创建类添加属性和方法\"></a>Runtime-动态创建类添加属性和方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)createClass</div><div class=\"line\">&#123;</div><div class=\"line\">    Class MyClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"myclass\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (class_addIvar(MyClass, <span class=\"string\">\"itest\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">NSString</span> *), <span class=\"number\">0</span>, <span class=\"string\">\"@\"</span>)) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"add ivar success\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding</span></div><div class=\"line\">    class_addMethod(MyClass, <span class=\"keyword\">@selector</span>(myclasstest:), (IMP)myclasstest, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    <span class=\"comment\">//注册这个类到runtime系统中就可以使用他了</span></div><div class=\"line\">    objc_registerClassPair(MyClass);</div><div class=\"line\">    <span class=\"comment\">//生成了一个实例化对象</span></div><div class=\"line\">    <span class=\"keyword\">id</span> myobj = [[MyClass alloc] init];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"asdb\"</span>;</div><div class=\"line\">    <span class=\"comment\">//给刚刚添加的变量赋值</span></div><div class=\"line\">    <span class=\"comment\">//    object_setInstanceVariable(myobj, \"itest\", (void *)&amp;str);在ARC下不允许使用</span></div><div class=\"line\">    [myobj setValue:str forKey:<span class=\"string\">@\"itest\"</span>];</div><div class=\"line\">    <span class=\"comment\">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></div><div class=\"line\">    [myobj myclasstest:<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这个方法实际上没有被调用,但是必须实现否则编译都不能通过</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myclasstest:(<span class=\"keyword\">int</span>)a</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//调用的是这个方法</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> myclasstest(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">int</span> a) <span class=\"comment\">//self和_cmd是必须的，在之后可以随意添加其他参数</span></div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    Ivar v = class_getInstanceVariable([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"itest\"</span>);</div><div class=\"line\">    <span class=\"comment\">//返回名为itest的ivar的变量的值</span></div><div class=\"line\">    <span class=\"keyword\">id</span> o = object_getIvar(<span class=\"keyword\">self</span>, v);</div><div class=\"line\">    <span class=\"comment\">//成功打印出结果</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, o);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int a is %d\"</span>, a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h2><p>此部分参考自<a href=\"http://blog.csdn.net/horkychen/article/details/8532087\" target=\"_blank\" rel=\"external\">Objective-C的方法替换</a>、<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C Runtime</a>等系列文章</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span> </span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>) </span></div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123; </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken; </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class=\"line\">        Class aClass = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; </div><div class=\"line\"> </div><div class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:); </div><div class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:); </div><div class=\"line\"> </div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\">        <span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">            class_addMethod(aClass, </div><div class=\"line\">                originalSelector, </div><div class=\"line\">                method_getImplementation(swizzledMethod), </div><div class=\"line\">                method_getTypeEncoding(swizzledMethod)); </div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">            class_replaceMethod(aClass, </div><div class=\"line\">                swizzledSelector, </div><div class=\"line\">                method_getImplementation(originalMethod), </div><div class=\"line\">                method_getTypeEncoding(originalMethod)); </div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling </span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123; </div><div class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated]; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>\n<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true\" alt=\"runtime_swizzling_1\"></p>\n<p>通过Swizzling需要实现的是偷换selector的IMP，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true\" alt=\"runtime_swizzling_2\"></p>\n<h4 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h4><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>\n<p>实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉<code>UIViewController</code>中的<code>viewWillAppear:</code>方法。这两种情况要区别对待。</p>\n<p>对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(<code>xxx_viewWillAppear:</code>)，然后将复写的方法替换为原先的实现(<code>viewWillAppear:</code>).</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">    class_addMethod(aClass, </div><div class=\"line\">        originalSelector, </div><div class=\"line\">        method_getImplementation(swizzledMethod), </div><div class=\"line\">        method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure>\n<p><code>class_addMethod</code>将本来不存在于被操作的Class里的<code>swizzledMethod</code>的实现添加在被操作的Class里,并使用<code>originalSelector</code>作为其选择子。如果发现方法已经存在，会失败返回。</p>\n<hr>\n<p>通过上一篇<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime原理</a>的分析，<code>class_addMethod</code>应该是先在类的method数组里找是否有这个<code>SEL</code>,如果没有就添加一个<code>method_t</code>。</p>\n<hr>\n<p>如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">    class_replaceMethod(aClass, </div><div class=\"line\">        swizzledSelector, </div><div class=\"line\">        method_getImplementation(originalMethod), </div><div class=\"line\">        method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>\n<p><code>addMethod</code>会让当前类的方法(IMP)指向新的实现(SEL)，使用<code>replaceMethod</code>再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法<code>SEL</code>来调用，就会实现新方法的<code>IMP</code>，通过新方法的<code>SEL</code>来调用，就会实现旧方法的<code>IMP</code>。</p>\n<p>如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过<code>method_exchangeImplementations</code>直接交换两个<code>method_t</code>的<code>IMP</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    method_exchangeImplementations(originalMethod, overrideMethod);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以本例中由于<code>viewWillAppear:</code>已经在UIViewController中实现过了，所以，<code>class_addMethod</code>失败，通过<code>method_exchangeImplementations</code>达到交换实现。如果要通过<code>class_addMethod</code>添加，需要自定义一个View继承UIViewController，再在这个类中替换<code>viewWillAppear:</code>。</p>\n<p>如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现。</p>\n<p><code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">method_setImplementation(m1, imp2);</div><div class=\"line\">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>\n<p>直接设置了<code>method</code>:<code>m1</code>,<code>m2</code>的<code>IMP</code>，简单暴力。</p>\n<p>对于注释了的这几行:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\"><span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"><span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\"><span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure></p>\n<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object实例 class]</code> 的区别：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>object_getClass()</code>方法返回对象的<code>isa</code>。</p>\n<p>最后，<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]</code>反而会引发死循环。</p>\n<blockquote>\n<p>Demo 详见RuntimeLearn</p>\n</blockquote>\n","excerpt":"<p>了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考<a href=\"http://www.jianshu.com/p/efeb33712445\">Runtime全方位装逼指南</a>，总结了以下几点应用场景。</p>","more":"<h2 id=\"给category添加属性\"><a href=\"#给category添加属性\" class=\"headerlink\" title=\"给category添加属性\"></a>给category添加属性</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong>对象关联</strong>允许开发者对已经存在的类在 Category 中添加自定义的属性：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OBJC_EXPORT <span class=\"keyword\">void</span> objc_setAssociatedObject(<span class=\"keyword\">id</span> object, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, <span class=\"keyword\">id</span> value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure></p>\n<ul>\n<li>object 是源对象.</li>\n<li>value 是被关联的对象.</li>\n<li>key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.</li>\n<li>policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </div><div class=\"line\">                                            *   The association is not made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </div><div class=\"line\">                                            *   The association is not made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</div><div class=\"line\">                                            *   The association is made atomically. */</span></div><div class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</div><div class=\"line\">                                            *   The association is made atomically. */</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>\n<p>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</p>\n<h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><p>新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>在.m中设置click的set，get方法(UIButton+ClickBlock.m):<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+ClickBlock.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *associatedKey = <span class=\"string\">\"associatedKey\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</div><div class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</div><div class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(clickBlock)click&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, associatedKey);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)buttonClick&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.click();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>其中，在set方法中使用<code>addTarget:action:forControlEvents:</code>给button设置了点击事件。</p>\n<p><code>self.click()</code>表示使用<code>self.click</code>获得block，再通过<code>block()</code>执行块。</p>\n<p>为什么不直接给click赋值，而是通过runtime的<code>objc_setAssociatedObject</code>方法呢？<br>@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。</p>\n<p>@property在本例中只是为了在.h里声明一个getset方法。可替换成：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">ClickBlock</span>)</span></div><div class=\"line\"><span class=\"comment\">//@property (nonatomic,copy) clickBlock click;</span></div><div class=\"line\">- (clickBlock)click;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)setClick:(clickBlock)click;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"字典与模型转换\"><a href=\"#字典与模型转换\" class=\"headerlink\" title=\"字典与模型转换\"></a>字典与模型转换</h2><h3 id=\"原理-1\"><a href=\"#原理-1\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>字典转模型的时候：</p>\n<ol>\n<li>根据字典的 key 生成 setter 方法.</li>\n<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>\n</ol>\n<p>模型转字典的时候：</p>\n<ol>\n<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>\n<li>调用 property_getName 获取属性名称.</li>\n<li>根据属性名称生成 getter 方法.</li>\n<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"NSObject+KeyValues.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">KeyValues</span>)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典转模型</span></div><div class=\"line\">+(<span class=\"keyword\">id</span>)objectWithKeyValues:(<span class=\"built_in\">NSDictionary</span> *)aDictionary&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> aDictionary.allKeys) &#123;</div><div class=\"line\">        <span class=\"keyword\">id</span> value = aDictionary[key];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">        objc_property_t property = class_getProperty(<span class=\"keyword\">self</span>, key.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class=\"line\">        objc_property_attribute_t attribute = attributeList[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *typeString = [<span class=\"built_in\">NSString</span> stringWithUTF8String:attribute.value];</div><div class=\"line\">        <span class=\"keyword\">if</span> ([typeString isEqualToString:<span class=\"string\">@\"@\\\"TestModel\\\"\"</span>]) &#123;</div><div class=\"line\">            value = [<span class=\"keyword\">self</span> objectWithKeyValues:value];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/**********************/</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成setter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"set%@%@:\"</span>,[key substringToIndex:<span class=\"number\">1</span>].uppercaseString,[key substringFromIndex:<span class=\"number\">1</span>]];</div><div class=\"line\">        SEL <span class=\"keyword\">setter</span> = sel_registerName(methodName.UTF8String);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([objc respondsToSelector:<span class=\"keyword\">setter</span>]) &#123;</div><div class=\"line\">            ((<span class=\"keyword\">void</span> (*) (<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">id</span>)) objc_msgSend) (objc,<span class=\"keyword\">setter</span>,value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(attributeList);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//模型转字典</span></div><div class=\"line\">-(<span class=\"built_in\">NSDictionary</span> *)keyValuesWithObject&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    objc_property_t *propertyList = class_copyPropertyList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"built_in\">NSMutableDictionary</span> *dict = [<span class=\"built_in\">NSMutableDictionary</span> dictionary];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        objc_property_t property = propertyList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//生成getter方法，并用objc_msgSend调用</span></div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *propertyName = property_getName(property);</div><div class=\"line\">        SEL <span class=\"keyword\">getter</span> = sel_registerName(propertyName);</div><div class=\"line\">        <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">getter</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">id</span> value = ((<span class=\"keyword\">id</span> (*) (<span class=\"keyword\">id</span>,SEL)) objc_msgSend) (<span class=\"keyword\">self</span>,<span class=\"keyword\">getter</span>);</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">/*判断当前属性是不是Model*/</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]] &amp;&amp; value) &#123;</div><div class=\"line\">                value = [value keyValuesWithObject];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"comment\">/**********************/</span></div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (value) &#123;</div><div class=\"line\">                <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:propertyName];</div><div class=\"line\">                [dict setObject:value forKey:key];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    free(propertyList);</div><div class=\"line\">    <span class=\"keyword\">return</span> dict;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyValuesTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"name is %@\"</span>,model.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"son name is %@\"</span>,model.son.name);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSDictionary</span> *dict = [model keyValuesWithObject];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"dict is %@\"</span>,dict);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>在NSObject中添加类方法，其中的<code>self</code>指的是<code>TestModel</code>这个类。</li>\n<li><code>objc_property_t</code>具有两个属性，name和attribute。调用<code>property_getAttribute</code>将返回attribute的字符串。调用<code>property_copyAttributeList</code>则将字符串切分，返回一个<code>objc_property_attribute_t</code>类型的指针，<code>outCount</code>返回了属性的数量。</li>\n</ol>\n<hr>\n<p>outCount使用了<strong>指向指针的指针</strong>的方式，使没有返回outCount的情况下，修改了outCount的值。</p>\n<p>例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">NSArray</span> *)scanBeginStr:(<span class=\"built_in\">NSString</span> *)beginstr endStr:(<span class=\"built_in\">NSString</span> *)endstr inText:(<span class=\"built_in\">NSMutableString</span> * *)textPointer&#123;</div><div class=\"line\">    <span class=\"built_in\">NSRange</span> range1,range2;</div><div class=\"line\">    <span class=\"built_in\">NSUInteger</span> location =<span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">    range1.location = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *text = *textPointer;</div><div class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *rangeArray = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">    <span class=\"keyword\">while</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">        range1 = [text rangeOfString:beginstr];</div><div class=\"line\">        range2 = [text rangeOfString:endstr];</div><div class=\"line\">        <span class=\"keyword\">if</span> (range1.location != <span class=\"built_in\">NSNotFound</span>) &#123;</div><div class=\"line\">            location = range1.location;</div><div class=\"line\">            length = range2.location - range1.location - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &gt; <span class=\"number\">5000</span>)<span class=\"keyword\">break</span>;</div><div class=\"line\">            [text replaceOccurrencesOfString:beginstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range1.location + range1.length)];</div><div class=\"line\">            [text replaceOccurrencesOfString:endstr withString:<span class=\"string\">@\"\"</span> options:<span class=\"built_in\">NSCaseInsensitiveSearch</span> range:<span class=\"built_in\">NSMakeRange</span>(<span class=\"number\">0</span>, range2.location + range2.length - <span class=\"number\">1</span>)];</div><div class=\"line\">        &#125;</div><div class=\"line\">        [rangeArray addObject:@&#123;<span class=\"string\">@\"location\"</span>:@(location),<span class=\"string\">@\"length\"</span>:@(length)&#125;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> rangeArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用：通过&amp;取指针的地址<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText];</div></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"自动归档\"><a href=\"#自动归档\" class=\"headerlink\" title=\"自动归档\"></a>自动归档</h2><h3 id=\"原理-2\"><a href=\"#原理-2\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.name forKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    [aCoder encodeObject:<span class=\"keyword\">self</span>.ID forKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">id</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.ID = [aDecoder decodeObjectForKey:<span class=\"string\">@\"ID\"</span>];</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = [aDecoder decodeObjectForKey:<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：</p>\n<ol>\n<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>\n<li>使用 ivar_getName 方法获取成员变量的名称.</li>\n<li>通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</li>\n</ol>\n<h3 id=\"示例：-1\"><a href=\"#示例：-1\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"TestModel.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/message.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">TestModel</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)encodeWithCoder:(<span class=\"built_in\">NSCoder</span> *)aCoder&#123;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">    Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">        Ivar var = vars[i];</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></div><div class=\"line\">        <span class=\"comment\">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></div><div class=\"line\">        <span class=\"comment\">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = [<span class=\"keyword\">self</span> valueForKey:key];</div><div class=\"line\">        [aCoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(vars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">instancetype</span>)initWithCoder:(<span class=\"built_in\">NSCoder</span> *)aDecoder&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</div><div class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount = <span class=\"number\">0</span>;</div><div class=\"line\">        Ivar *vars = class_copyIvarList([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], &amp;outCount);</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; outCount; i ++) &#123;</div><div class=\"line\">            Ivar var = vars[i];</div><div class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name = ivar_getName(var);</div><div class=\"line\">            <span class=\"built_in\">NSString</span> *key = [<span class=\"built_in\">NSString</span> stringWithUTF8String:name];</div><div class=\"line\">            <span class=\"keyword\">id</span> value = [aDecoder decodeObjectForKey:key];</div><div class=\"line\">            [<span class=\"keyword\">self</span> setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        free(vars);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>使用：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)keyedArchiverTest&#123;</div><div class=\"line\">    </div><div class=\"line\">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">NSString</span> *path = <span class=\"built_in\">NSSearchPathForDirectoriesInDomains</span>(<span class=\"built_in\">NSDocumentDirectory</span>, <span class=\"built_in\">NSUserDomainMask</span>, <span class=\"literal\">YES</span>).lastObject;</div><div class=\"line\">    path = [path stringByAppendingPathComponent:<span class=\"string\">@\"test\"</span>];</div><div class=\"line\">    [<span class=\"built_in\">NSKeyedArchiver</span> archiveRootObject:model toFile:path];</div><div class=\"line\">    </div><div class=\"line\">    TestModel *m = [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.name is %@\"</span>,m.name);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"m.son name is %@\"</span>,m.son.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"动态方法解析与消息转发\"><a href=\"#动态方法解析与消息转发\" class=\"headerlink\" title=\"动态方法解析与消息转发\"></a>动态方法解析与消息转发</h2><h3 id=\"原理-3\"><a href=\"#原理-3\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>消息转发的大致过程如图：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true\" alt=\"消息转发流程\"></p>\n<ol>\n<li>当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回<code>NO</code>，则进入下一步，若返回<code>YES</code>，则通过 <code>class_addMethod</code> 函数动态地添加方法，消息得到处理，此流程完毕.</li>\n<li><code>resolveInstanceMethod:</code> 方法返回 <code>NO</code> 时，就会进入 <code>forwardingTargetForSelector:</code> 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 <code>selector</code>。返回<code>nil</code>，进入下一步，返回某个对象，则会调用该对象的方法.</li>\n<li>若 <code>forwardingTargetForSelector:</code> 返回的是<code>nil</code>，则我们首先要通过 <code>methodSignatureForSelector:</code> 来指定方法签名，返回<code>nil</code>，表示不处理，若返回方法签名，则会进入下一步.</li>\n<li>当第 <code>methodSignatureForSelector:</code> 方法返回方法签名后，就会调用 <code>forwardInvocation:</code> 方法，我们可以通过 <code>anInvocation</code> 对象做很多处理，比如修改实现方法，修改响应对象等.</li>\n<li>如果到最后，消息还是没有得到响应，程序就会crash.</li>\n</ol>\n<h3 id=\"示例：-2\"><a href=\"#示例：-2\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Monkey.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Bird.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Monkey</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)jump&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"monkey can not fly, but! monkey can jump\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     如果当前对象调用了一个不存在的方法</div><div class=\"line\">     Runtime会调用resolveInstanceMethod:来进行动态方法解析</div><div class=\"line\">     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作</div><div class=\"line\">     返回NO，则进入下一步forwardingTargetForSelector:</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">\t<span class=\"keyword\">if</span>(sel == <span class=\"keyword\">@selector</span>(fly))&#123;</div><div class=\"line\">    \tclass_addMethod(<span class=\"keyword\">self</span>, sel, class_getMethodImplementation(<span class=\"keyword\">self</span>, sel_registerName(<span class=\"string\">\"jump\"</span>)), <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会</div><div class=\"line\">     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象</div><div class=\"line\">     返回nil则进步下一步forwardInvocation:</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"meta\">#if 0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</div><div class=\"line\"><span class=\"meta\">#else</span></div><div class=\"line\">    <span class=\"keyword\">return</span> [[Bird alloc] init];</div><div class=\"line\"><span class=\"meta\">#endif</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     获取方法签名进入下一步，进行消息转发</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">     消息转发</div><div class=\"line\">     */</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [anInvocation invokeWithTarget:[[Bird alloc] init]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中 <code>&quot;v@:&quot;</code> 表示返回值和参数,这个符号涉及<a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html\">Type Encoding</a>以及<a href=\"http://www.jianshu.com/p/f4129b5194c0\">关于type encodings的理解–runtime programming guide</a>。</p>\n<hr>\n<p>其中<strong>v</strong>表示返回<code>void</code>类型，<strong>@</strong>表示参数<code>id(self)</code>，<strong>：</strong>表示<code>SEL(_cmd)</code>这几个是必须要有的，后面可以接入参类型。</p>\n<p>举个例子：<code>&quot;i@:@&quot;</code><br><strong>i</strong>表示返回值类型<code>int</code><br><strong>@：</strong>和上面意义相同<br><strong>@</strong>最后一个@表示有一个入参，是<code>id</code>类型。</p>\n<p>不过，实际上，这个东西好像没什么用，因为在<code>class_addMethod</code>上试验过，随便传任何字符串都一样能正常运行。</p>\n<hr>\n<p>一般来说可以使用<code>method_getTypeEncoding()</code>获取更详细的Type_Encoding,下面例子中也会用到。</p>\n<h3 id=\"转发与多继承\"><a href=\"#转发与多继承\" class=\"headerlink\" title=\"转发与多继承\"></a>转发与多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true\" alt=\"runtime_transmit\"></p>\n<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>\n<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>\n<h2 id=\"Runtime-动态创建类添加属性和方法\"><a href=\"#Runtime-动态创建类添加属性和方法\" class=\"headerlink\" title=\"Runtime-动态创建类添加属性和方法\"></a>Runtime-动态创建类添加属性和方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)createClass</div><div class=\"line\">&#123;</div><div class=\"line\">    Class MyClass = objc_allocateClassPair([<span class=\"built_in\">NSObject</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"myclass\"</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (class_addIvar(MyClass, <span class=\"string\">\"itest\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">NSString</span> *), <span class=\"number\">0</span>, <span class=\"string\">\"@\"</span>)) &#123;</div><div class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"add ivar success\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//myclasstest是已经实现的函数，\"v@:\"这种写法见type encoding</span></div><div class=\"line\">    class_addMethod(MyClass, <span class=\"keyword\">@selector</span>(myclasstest:), (IMP)myclasstest, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    <span class=\"comment\">//注册这个类到runtime系统中就可以使用他了</span></div><div class=\"line\">    objc_registerClassPair(MyClass);</div><div class=\"line\">    <span class=\"comment\">//生成了一个实例化对象</span></div><div class=\"line\">    <span class=\"keyword\">id</span> myobj = [[MyClass alloc] init];</div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"asdb\"</span>;</div><div class=\"line\">    <span class=\"comment\">//给刚刚添加的变量赋值</span></div><div class=\"line\">    <span class=\"comment\">//    object_setInstanceVariable(myobj, \"itest\", (void *)&amp;str);在ARC下不允许使用</span></div><div class=\"line\">    [myobj setValue:str forKey:<span class=\"string\">@\"itest\"</span>];</div><div class=\"line\">    <span class=\"comment\">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></div><div class=\"line\">    [myobj myclasstest:<span class=\"number\">10</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这个方法实际上没有被调用,但是必须实现否则编译都不能通过</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)myclasstest:(<span class=\"keyword\">int</span>)a</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//调用的是这个方法</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> myclasstest(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">int</span> a) <span class=\"comment\">//self和_cmd是必须的，在之后可以随意添加其他参数</span></div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">    Ivar v = class_getInstanceVariable([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>], <span class=\"string\">\"itest\"</span>);</div><div class=\"line\">    <span class=\"comment\">//返回名为itest的ivar的变量的值</span></div><div class=\"line\">    <span class=\"keyword\">id</span> o = object_getIvar(<span class=\"keyword\">self</span>, v);</div><div class=\"line\">    <span class=\"comment\">//成功打印出结果</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, o);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"int a is %d\"</span>, a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Method-Swizzling\"><a href=\"#Method-Swizzling\" class=\"headerlink\" title=\"Method Swizzling\"></a>Method Swizzling</h2><p>此部分参考自<a href=\"http://blog.csdn.net/horkychen/article/details/8532087\">Objective-C的方法替换</a>、<a href=\"http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/\">Objective-C Runtime</a>等系列文章</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span> </span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIViewController</span> (<span class=\"title\">Tracking</span>) </span></div><div class=\"line\"> </div><div class=\"line\">+ (<span class=\"keyword\">void</span>)load &#123; </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken; </div><div class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class=\"line\">        Class aClass = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; </div><div class=\"line\"> </div><div class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(viewWillAppear:); </div><div class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(xxx_viewWillAppear:); </div><div class=\"line\"> </div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\">        <span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\">        <span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div><div class=\"line\"> </div><div class=\"line\">        <span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">            class_addMethod(aClass, </div><div class=\"line\">                originalSelector, </div><div class=\"line\">                method_getImplementation(swizzledMethod), </div><div class=\"line\">                method_getTypeEncoding(swizzledMethod)); </div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">            class_replaceMethod(aClass, </div><div class=\"line\">                swizzledSelector, </div><div class=\"line\">                method_getImplementation(originalMethod), </div><div class=\"line\">                method_getTypeEncoding(originalMethod)); </div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class=\"line\">        &#125; </div><div class=\"line\">    &#125;); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"meta\">#pragma mark - Method Swizzling </span></div><div class=\"line\"> </div><div class=\"line\">- (<span class=\"keyword\">void</span>)xxx_viewWillAppear:(<span class=\"built_in\">BOOL</span>)animated &#123; </div><div class=\"line\">    [<span class=\"keyword\">self</span> xxx_viewWillAppear:animated]; </div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"viewWillAppear: %@\"</span>, <span class=\"keyword\">self</span>); </div><div class=\"line\">&#125; </div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"原理-4\"><a href=\"#原理-4\" class=\"headerlink\" title=\"原理\"></a>原理</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>\n<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true\" alt=\"runtime_swizzling_1\"></p>\n<p>通过Swizzling需要实现的是偷换selector的IMP，如下图所示：<br><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true\" alt=\"runtime_swizzling_2\"></p>\n<h4 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h4><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>\n<p>实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉<code>UIViewController</code>中的<code>viewWillAppear:</code>方法。这两种情况要区别对待。</p>\n<p>对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(<code>xxx_viewWillAppear:</code>)，然后将复写的方法替换为原先的实现(<code>viewWillAppear:</code>).</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">BOOL</span> didAddMethod = </div><div class=\"line\">    class_addMethod(aClass, </div><div class=\"line\">        originalSelector, </div><div class=\"line\">        method_getImplementation(swizzledMethod), </div><div class=\"line\">        method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure>\n<p><code>class_addMethod</code>将本来不存在于被操作的Class里的<code>swizzledMethod</code>的实现添加在被操作的Class里,并使用<code>originalSelector</code>作为其选择子。如果发现方法已经存在，会失败返回。</p>\n<hr>\n<p>通过上一篇<a href=\"https://zhang759740844.github.io/2016/08/22/runtime原理/\">runtime原理</a>的分析，<code>class_addMethod</code>应该是先在类的method数组里找是否有这个<code>SEL</code>,如果没有就添加一个<code>method_t</code>。</p>\n<hr>\n<p>如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (didAddMethod) &#123; </div><div class=\"line\">    class_replaceMethod(aClass, </div><div class=\"line\">        swizzledSelector, </div><div class=\"line\">        method_getImplementation(originalMethod), </div><div class=\"line\">        method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>\n<p><code>addMethod</code>会让当前类的方法(IMP)指向新的实现(SEL)，使用<code>replaceMethod</code>再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法<code>SEL</code>来调用，就会实现新方法的<code>IMP</code>，通过新方法的<code>SEL</code>来调用，就会实现旧方法的<code>IMP</code>。</p>\n<p>如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过<code>method_exchangeImplementations</code>直接交换两个<code>method_t</code>的<code>IMP</code>:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    method_exchangeImplementations(originalMethod, overrideMethod);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以本例中由于<code>viewWillAppear:</code>已经在UIViewController中实现过了，所以，<code>class_addMethod</code>失败，通过<code>method_exchangeImplementations</code>达到交换实现。如果要通过<code>class_addMethod</code>添加，需要自定义一个View继承UIViewController，再在这个类中替换<code>viewWillAppear:</code>。</p>\n<p>如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现。</p>\n<p><code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">IMP imp1 = method_getImplementation(m1);</div><div class=\"line\">IMP imp2 = method_getImplementation(m2);</div><div class=\"line\">method_setImplementation(m1, imp2);</div><div class=\"line\">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>\n<p>直接设置了<code>method</code>:<code>m1</code>,<code>m2</code>的<code>IMP</code>，简单暴力。</p>\n<p>对于注释了的这几行:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// When swizzling a class method, use the following:</span></div><div class=\"line\"><span class=\"comment\">// Class aClass = object_getClass((id)self);</span></div><div class=\"line\"><span class=\"comment\">// ...</span></div><div class=\"line\"><span class=\"comment\">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class=\"line\"><span class=\"comment\">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure></p>\n<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object实例 class]</code> 的区别：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (Class)<span class=\"keyword\">class</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>object_getClass()</code>方法返回对象的<code>isa</code>。</p>\n<p>最后，<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]</code>反而会引发死循环。</p>\n<blockquote>\n<p>Demo 详见RuntimeLearn</p>\n</blockquote>"},{"title":"ios编程(第四版) 学习笔记","date":"2016-07-31T06:07:12.000Z","_content":"\n本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。\n\n<!--more-->\n## 第一个ios应用\n### 声明插座变量\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n声明了一个叫questionLabel的插座变量.  \n**IBOutlet**告诉Xcode需要使用Interface Builder关联该插座变量。\n\n### 声明动作方法\n```objc\n- (IBAction)showQuestion:(id)sender{\n\t……\n}\n```\n**IBAction**关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。\n\n### 应用图标\nImages.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。\n\n## objective-c\n### 类方法\n实例方法使用的字符是-，类方法使用字符+。  \n类方法作用通常是创建对象，获取类的某些全局属性。\n\n## 通过ARC管理内存\n### copy\n当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。  \n当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。\n\ncopy和strong的区别就是：\n- 对于不可修改对象没有区别，都是直接返回对象地址\n- 对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。\n\n\n\n## 视图与视图层次结构\n### 视图层次结构\n任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。\n层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。\n\n### 创建UIView子类\nUIView子类模板会自动生成一个方法 **initWithFrame:**，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。\n\n```objc\n@property （nonatomic） CGRect frame；\n```\n\nCGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。    \n创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；\n  \n可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。  \n每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。  \nbounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。\n\n### 图形绘制\n没看\n\n## 视图：重绘与UIScrollView\n### ScrollView\n设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。  \n在scrollview中addSubView。\n\n## 视图控制器\n### 视图控制器\n视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。\n使用UITabBarController的类在两个视图控制器间切换。  \n\nUIViewController有一个重要属性：\n\n```objc \n@property (nonatomic, strong) UIView *view;\n```\n\n这个view就是视图的根视图。\n\n### 创建视图层次结构\n1. 覆盖UIViewController的loadView方法\n```objc\n-(void)loadView{\n        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];\n        self.view = backgroundView;\n}\n```\n\n\t此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。\n2. 通过xib创建\n.m中声明各个控件(注意控件使用弱引用)\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n\n\t再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。\n\n### 设置根视图控制器\nUIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。\n```objc\nBNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];\nself.window.rootViewController = hvc;\n```\n\nsetRootViewController其实就是将ViewController的view设置为其subview。\n\n### 加载nib文件\n加载不同名的nib文件时，需要使用**initWithNibName:Bundle:**方法。该方法的两个参数，分别用于指定NIB文件文件名和其**所在的程序包**。如果是Bundle传入nil默认是[NSBundle mainBundle];\n\n### UITabBarController\nUITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   \n\n在APPDelegate中创建两个视图控制器，加入Tabbar的**viewControllers**属性中，并将tabbar设置为rootViewController\n```objc\nUITabBarController *tabBarController = [[UITabBarController alloc] init];\ntabBarController.viewControllers = @[hvc,rvc] //两个viewController 可以写在tabbarController的viewDidLoad方法里\nself.window.rootViewController = tabBarController;\n```\n\n设置标签项，使用**tabBarItem**属性：\n\n```objc\n    UIImage *orderImage = [UIImage imageNamed:@\"tab_order\"];\n    UIImage *orderImageSel = [UIImage imageNamed:@\"tab_order_active\"];\n    orderImage = [orderImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    orderImageSel = [orderImageSel imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    UITabBarItem *orderTabBarItem = [[UITabBarItem alloc] initWithTitle:@\"订单\" image:orderImage selectedImage:orderImageSel];\n    orderNav.tabBarItem = orderTabBarItem;\n```\n\n为tabbar添加subview，UITabBarController里有一个**tabBar**的view\n\n```objc\nUIView *backview = [[UIView alloc] initWithFrame:self.tabBar.bounds];\n[backview setBackgroundColor:[UIColor whiteColor]];\n[self.tabBar addSubview:backview];\n```\n\n\n### 本地通知\n本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。\n```objc\nUILocalNotification *note = [][UILocalNotification alloc] init];\nnote.alertBody = @\"xxx\";\nnote.fireDate = date;\n[[UIApplication sharedApplication] scheduleLocalNotification:note];\n```\n\n### 加载和显示视图\nviewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。  \n另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。\n  \n如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。\n\n### 与视图控制器及其视图交互\n**application:didFinishLaunchingWithOptions:**\t该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。      \n**initWithNibName：bundle：**该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。  \n**loadView：**覆盖该方法，使用代码方式设置视图控制的的view属性。  \n**viewDidLoad：**该方法会在视图控制器加载完视图后被调用。  \n**viewWillAppear：**该方法会在视图控制器的view显示在屏幕上时被调用。  \n\n## 委托与文本输入\n### 委托（代理模式）\n当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。  \n例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  \n\n类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。\n\n### 协议\n凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  \n\n协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束  \n使用@optional指令，可以将写在指令后的全部声明为可选的。  \n发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  \n\n声明示例：\n```objc\n@interface BNRHypnosisViewController()<UITextFieldDelegate>\n@end\n```\n### 设置异常断点\n当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。\n\n### 类方法与实例方法\n这里需要注意：\n1. 类方法可以调用类方法。\n2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。\n3. 类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。\n + 实例方法里面的self，是对象的首地址。\n + 类方法里面的self，是Class.\n4. 类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。\n\n## UINavigationController\n### UINavigationController对象\nUINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。\n\nUINavigationController对象有一个名为**viewControllers**的属性，指向一个负责保存视图控制器的数组。**topViewController**属性是一个指针，指向当前位于栈顶的视图控制器。\n\nUINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有**两个子视图**：一个是**UINavigationBar对象**，一个是**topViewController的视图**。\n\n初始化UINavigationController对象：\n```objc\nUINavigationController *navController = [[UINavigationController alloc]initWithRootViewController:viewController];\n```\n\n### 关联xib\n不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）\n\n在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。\n\n设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。\n\n### 将视图控制器压入栈\n使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。\n```objc\n[self.navigationController pushViewController:detailController animated:YES];\n```\n视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。\n\n### 视图控制器间传递数据\n\n### NavigationBar\nUIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。\n\nUINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。\n\n创建一个buttonItem：\n```objc\n- (void)initNavigationView{\n    UIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 26, 44)];\n    [backBtn setImage:[UIImage imageNamed:@\"systemback\"] forState:UIControlStateNormal];\n    [backBtn addTarget:self action:@selector(backButtonPressedForOrder:) forControlEvents:UIControlEventTouchUpInside];\n    UIBarButtonItem *leftItem  = [[UIBarButtonItem alloc]initWithCustomView:backBtn];\n    [self.navigationItem setLeftBarButtonItem:leftItem];\n}\n```\n","source":"_posts/ios编程（第四版.md","raw":"title: ios编程(第四版) 学习笔记\ndate: 2016/7/31 14:07:12  \ncategories: IOS\ntags: \n\t- 学习笔记\n\n---\n\n本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。\n\n<!--more-->\n## 第一个ios应用\n### 声明插座变量\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n声明了一个叫questionLabel的插座变量.  \n**IBOutlet**告诉Xcode需要使用Interface Builder关联该插座变量。\n\n### 声明动作方法\n```objc\n- (IBAction)showQuestion:(id)sender{\n\t……\n}\n```\n**IBAction**关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。\n\n### 应用图标\nImages.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。\n\n## objective-c\n### 类方法\n实例方法使用的字符是-，类方法使用字符+。  \n类方法作用通常是创建对象，获取类的某些全局属性。\n\n## 通过ARC管理内存\n### copy\n当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。  \n当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。\n\ncopy和strong的区别就是：\n- 对于不可修改对象没有区别，都是直接返回对象地址\n- 对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。\n\n\n\n## 视图与视图层次结构\n### 视图层次结构\n任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。\n层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。\n\n### 创建UIView子类\nUIView子类模板会自动生成一个方法 **initWithFrame:**，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。\n\n```objc\n@property （nonatomic） CGRect frame；\n```\n\nCGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。    \n创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；\n  \n可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。  \n每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。  \nbounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。\n\n### 图形绘制\n没看\n\n## 视图：重绘与UIScrollView\n### ScrollView\n设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。  \n在scrollview中addSubView。\n\n## 视图控制器\n### 视图控制器\n视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。\n使用UITabBarController的类在两个视图控制器间切换。  \n\nUIViewController有一个重要属性：\n\n```objc \n@property (nonatomic, strong) UIView *view;\n```\n\n这个view就是视图的根视图。\n\n### 创建视图层次结构\n1. 覆盖UIViewController的loadView方法\n```objc\n-(void)loadView{\n        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];\n        self.view = backgroundView;\n}\n```\n\n\t此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。\n2. 通过xib创建\n.m中声明各个控件(注意控件使用弱引用)\n```objc\n@property(nonatomic, weak) IBOutlet UILabel *questionLabel\n```\n\n\t再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。\n\n### 设置根视图控制器\nUIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。\n```objc\nBNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];\nself.window.rootViewController = hvc;\n```\n\nsetRootViewController其实就是将ViewController的view设置为其subview。\n\n### 加载nib文件\n加载不同名的nib文件时，需要使用**initWithNibName:Bundle:**方法。该方法的两个参数，分别用于指定NIB文件文件名和其**所在的程序包**。如果是Bundle传入nil默认是[NSBundle mainBundle];\n\n### UITabBarController\nUITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   \n\n在APPDelegate中创建两个视图控制器，加入Tabbar的**viewControllers**属性中，并将tabbar设置为rootViewController\n```objc\nUITabBarController *tabBarController = [[UITabBarController alloc] init];\ntabBarController.viewControllers = @[hvc,rvc] //两个viewController 可以写在tabbarController的viewDidLoad方法里\nself.window.rootViewController = tabBarController;\n```\n\n设置标签项，使用**tabBarItem**属性：\n\n```objc\n    UIImage *orderImage = [UIImage imageNamed:@\"tab_order\"];\n    UIImage *orderImageSel = [UIImage imageNamed:@\"tab_order_active\"];\n    orderImage = [orderImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    orderImageSel = [orderImageSel imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n    UITabBarItem *orderTabBarItem = [[UITabBarItem alloc] initWithTitle:@\"订单\" image:orderImage selectedImage:orderImageSel];\n    orderNav.tabBarItem = orderTabBarItem;\n```\n\n为tabbar添加subview，UITabBarController里有一个**tabBar**的view\n\n```objc\nUIView *backview = [[UIView alloc] initWithFrame:self.tabBar.bounds];\n[backview setBackgroundColor:[UIColor whiteColor]];\n[self.tabBar addSubview:backview];\n```\n\n\n### 本地通知\n本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。\n```objc\nUILocalNotification *note = [][UILocalNotification alloc] init];\nnote.alertBody = @\"xxx\";\nnote.fireDate = date;\n[[UIApplication sharedApplication] scheduleLocalNotification:note];\n```\n\n### 加载和显示视图\nviewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。  \n另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。\n  \n如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。\n\n### 与视图控制器及其视图交互\n**application:didFinishLaunchingWithOptions:**\t该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。      \n**initWithNibName：bundle：**该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。  \n**loadView：**覆盖该方法，使用代码方式设置视图控制的的view属性。  \n**viewDidLoad：**该方法会在视图控制器加载完视图后被调用。  \n**viewWillAppear：**该方法会在视图控制器的view显示在屏幕上时被调用。  \n\n## 委托与文本输入\n### 委托（代理模式）\n当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。  \n例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  \n\n类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。\n\n### 协议\n凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  \n\n协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束  \n使用@optional指令，可以将写在指令后的全部声明为可选的。  \n发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  \n\n声明示例：\n```objc\n@interface BNRHypnosisViewController()<UITextFieldDelegate>\n@end\n```\n### 设置异常断点\n当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。\n\n### 类方法与实例方法\n这里需要注意：\n1. 类方法可以调用类方法。\n2. 类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。\n3. 类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。\n + 实例方法里面的self，是对象的首地址。\n + 类方法里面的self，是Class.\n4. 类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。\n\n## UINavigationController\n### UINavigationController对象\nUINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。\n\nUINavigationController对象有一个名为**viewControllers**的属性，指向一个负责保存视图控制器的数组。**topViewController**属性是一个指针，指向当前位于栈顶的视图控制器。\n\nUINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有**两个子视图**：一个是**UINavigationBar对象**，一个是**topViewController的视图**。\n\n初始化UINavigationController对象：\n```objc\nUINavigationController *navController = [[UINavigationController alloc]initWithRootViewController:viewController];\n```\n\n### 关联xib\n不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）\n\n在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。\n\n设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。\n\n### 将视图控制器压入栈\n使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。\n```objc\n[self.navigationController pushViewController:detailController animated:YES];\n```\n视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。\n\n### 视图控制器间传递数据\n\n### NavigationBar\nUIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。\n\nUINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。\n\n创建一个buttonItem：\n```objc\n- (void)initNavigationView{\n    UIButton *backBtn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 26, 44)];\n    [backBtn setImage:[UIImage imageNamed:@\"systemback\"] forState:UIControlStateNormal];\n    [backBtn addTarget:self action:@selector(backButtonPressedForOrder:) forControlEvents:UIControlEventTouchUpInside];\n    UIBarButtonItem *leftItem  = [[UIBarButtonItem alloc]initWithCustomView:backBtn];\n    [self.navigationItem setLeftBarButtonItem:leftItem];\n}\n```\n","slug":"ios编程（第四版","published":1,"updated":"2016-09-23T05:53:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyj003mrgrupcvi5o7e","content":"<p>本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。</p>\n<a id=\"more\"></a>\n<h2 id=\"第一个ios应用\"><a href=\"#第一个ios应用\" class=\"headerlink\" title=\"第一个ios应用\"></a>第一个ios应用</h2><h3 id=\"声明插座变量\"><a href=\"#声明插座变量\" class=\"headerlink\" title=\"声明插座变量\"></a>声明插座变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p>声明了一个叫questionLabel的插座变量.<br><strong>IBOutlet</strong>告诉Xcode需要使用Interface Builder关联该插座变量。</p>\n<h3 id=\"声明动作方法\"><a href=\"#声明动作方法\" class=\"headerlink\" title=\"声明动作方法\"></a>声明动作方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)showQuestion:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>IBAction</strong>关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。</p>\n<h3 id=\"应用图标\"><a href=\"#应用图标\" class=\"headerlink\" title=\"应用图标\"></a>应用图标</h3><p>Images.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。</p>\n<h2 id=\"objective-c\"><a href=\"#objective-c\" class=\"headerlink\" title=\"objective-c\"></a>objective-c</h2><h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法使用的字符是-，类方法使用字符+。<br>类方法作用通常是创建对象，获取类的某些全局属性。</p>\n<h2 id=\"通过ARC管理内存\"><a href=\"#通过ARC管理内存\" class=\"headerlink\" title=\"通过ARC管理内存\"></a>通过ARC管理内存</h2><h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。<br>当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。</p>\n<p>copy和strong的区别就是：</p>\n<ul>\n<li>对于不可修改对象没有区别，都是直接返回对象地址</li>\n<li>对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。</li>\n</ul>\n<h2 id=\"视图与视图层次结构\"><a href=\"#视图与视图层次结构\" class=\"headerlink\" title=\"视图与视图层次结构\"></a>视图与视图层次结构</h2><h3 id=\"视图层次结构\"><a href=\"#视图层次结构\" class=\"headerlink\" title=\"视图层次结构\"></a>视图层次结构</h3><p>任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。<br>层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。</p>\n<h3 id=\"创建UIView子类\"><a href=\"#创建UIView子类\" class=\"headerlink\" title=\"创建UIView子类\"></a>创建UIView子类</h3><p>UIView子类模板会自动生成一个方法 <strong>initWithFrame:</strong>，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">nonatomic</span>） <span class=\"built_in\">CGRect</span> frame；</div></pre></td></tr></table></figure>\n<p>CGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。<br>创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；</p>\n<p>可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。<br>每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。<br>bounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。</p>\n<h3 id=\"图形绘制\"><a href=\"#图形绘制\" class=\"headerlink\" title=\"图形绘制\"></a>图形绘制</h3><p>没看</p>\n<h2 id=\"视图：重绘与UIScrollView\"><a href=\"#视图：重绘与UIScrollView\" class=\"headerlink\" title=\"视图：重绘与UIScrollView\"></a>视图：重绘与UIScrollView</h2><h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。<br>在scrollview中addSubView。</p>\n<h2 id=\"视图控制器\"><a href=\"#视图控制器\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h2><h3 id=\"视图控制器-1\"><a href=\"#视图控制器-1\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h3><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。<br>使用UITabBarController的类在两个视图控制器间切换。  </p>\n<p>UIViewController有一个重要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</div></pre></td></tr></table></figure>\n<p>这个view就是视图的根视图。</p>\n<h3 id=\"创建视图层次结构\"><a href=\"#创建视图层次结构\" class=\"headerlink\" title=\"创建视图层次结构\"></a>创建视图层次结构</h3><ol>\n<li><p>覆盖UIViewController的loadView方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)loadView&#123;</div><div class=\"line\">        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];</div><div class=\"line\">        <span class=\"keyword\">self</span>.view = backgroundView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。</p>\n</li>\n<li><p>通过xib创建<br>.m中声明各个控件(注意控件使用弱引用)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p> 再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。</p>\n</li>\n</ol>\n<h3 id=\"设置根视图控制器\"><a href=\"#设置根视图控制器\" class=\"headerlink\" title=\"设置根视图控制器\"></a>设置根视图控制器</h3><p>UIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">BNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = hvc;</div></pre></td></tr></table></figure></p>\n<p>setRootViewController其实就是将ViewController的view设置为其subview。</p>\n<h3 id=\"加载nib文件\"><a href=\"#加载nib文件\" class=\"headerlink\" title=\"加载nib文件\"></a>加载nib文件</h3><p>加载不同名的nib文件时，需要使用<strong>initWithNibName:Bundle:</strong>方法。该方法的两个参数，分别用于指定NIB文件文件名和其<strong>所在的程序包</strong>。如果是Bundle传入nil默认是[NSBundle mainBundle];</p>\n<h3 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h3><p>UITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   </p>\n<p>在APPDelegate中创建两个视图控制器，加入Tabbar的<strong>viewControllers</strong>属性中，并将tabbar设置为rootViewController<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = [[<span class=\"built_in\">UITabBarController</span> alloc] init];</div><div class=\"line\">tabBarController.viewControllers = @[hvc,rvc] <span class=\"comment\">//两个viewController 可以写在tabbarController的viewDidLoad方法里</span></div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = tabBarController;</div></pre></td></tr></table></figure></p>\n<p>设置标签项，使用<strong>tabBarItem</strong>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order\"</span>];</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImageSel = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order_active\"</span>];</div><div class=\"line\">orderImage = [orderImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\">orderImageSel = [orderImageSel imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\"><span class=\"built_in\">UITabBarItem</span> *orderTabBarItem = [[<span class=\"built_in\">UITabBarItem</span> alloc] initWithTitle:<span class=\"string\">@\"订单\"</span> image:orderImage selectedImage:orderImageSel];</div><div class=\"line\">orderNav.tabBarItem = orderTabBarItem;</div></pre></td></tr></table></figure>\n<p>为tabbar添加subview，UITabBarController里有一个<strong>tabBar</strong>的view</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *backview = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.tabBar.bounds];</div><div class=\"line\">[backview setBackgroundColor:[<span class=\"built_in\">UIColor</span> whiteColor]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.tabBar addSubview:backview];</div></pre></td></tr></table></figure>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UILocalNotification</span> *note = [][<span class=\"built_in\">UILocalNotification</span> alloc] init];</div><div class=\"line\">note.alertBody = <span class=\"string\">@\"xxx\"</span>;</div><div class=\"line\">note.fireDate = date;</div><div class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] scheduleLocalNotification:note];</div></pre></td></tr></table></figure></p>\n<h3 id=\"加载和显示视图\"><a href=\"#加载和显示视图\" class=\"headerlink\" title=\"加载和显示视图\"></a>加载和显示视图</h3><p>viewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。<br>另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。</p>\n<p>如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。</p>\n<h3 id=\"与视图控制器及其视图交互\"><a href=\"#与视图控制器及其视图交互\" class=\"headerlink\" title=\"与视图控制器及其视图交互\"></a>与视图控制器及其视图交互</h3><p><strong>application:didFinishLaunchingWithOptions:</strong>    该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。<br><strong>initWithNibName：bundle：</strong>该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。<br><strong>loadView：</strong>覆盖该方法，使用代码方式设置视图控制的的view属性。<br><strong>viewDidLoad：</strong>该方法会在视图控制器加载完视图后被调用。<br><strong>viewWillAppear：</strong>该方法会在视图控制器的view显示在屏幕上时被调用。  </p>\n<h2 id=\"委托与文本输入\"><a href=\"#委托与文本输入\" class=\"headerlink\" title=\"委托与文本输入\"></a>委托与文本输入</h2><h3 id=\"委托（代理模式）\"><a href=\"#委托（代理模式）\" class=\"headerlink\" title=\"委托（代理模式）\"></a>委托（代理模式）</h3><p>当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。<br>例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  </p>\n<p>类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  </p>\n<p>协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束<br>使用@optional指令，可以将写在指令后的全部声明为可选的。<br>发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  </p>\n<p>声明示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRHypnosisViewController</span>()&lt;<span class=\"title\">UITextFieldDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"设置异常断点\"><a href=\"#设置异常断点\" class=\"headerlink\" title=\"设置异常断点\"></a>设置异常断点</h3><p>当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。</p>\n<h3 id=\"类方法与实例方法\"><a href=\"#类方法与实例方法\" class=\"headerlink\" title=\"类方法与实例方法\"></a>类方法与实例方法</h3><p>这里需要注意：</p>\n<ol>\n<li>类方法可以调用类方法。</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。</li>\n<li>类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<ul>\n<li>实例方法里面的self，是对象的首地址。</li>\n<li>类方法里面的self，是Class.</li>\n</ul>\n</li>\n<li>类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</li>\n</ol>\n<h2 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h2><h3 id=\"UINavigationController对象\"><a href=\"#UINavigationController对象\" class=\"headerlink\" title=\"UINavigationController对象\"></a>UINavigationController对象</h3><p>UINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。</p>\n<p>UINavigationController对象有一个名为<strong>viewControllers</strong>的属性，指向一个负责保存视图控制器的数组。<strong>topViewController</strong>属性是一个指针，指向当前位于栈顶的视图控制器。</p>\n<p>UINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有<strong>两个子视图</strong>：一个是<strong>UINavigationBar对象</strong>，一个是<strong>topViewController的视图</strong>。</p>\n<p>初始化UINavigationController对象：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navController = [[<span class=\"built_in\">UINavigationController</span> alloc]initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>\n<h3 id=\"关联xib\"><a href=\"#关联xib\" class=\"headerlink\" title=\"关联xib\"></a>关联xib</h3><p>不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）</p>\n<p>在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。</p>\n<p>设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。</p>\n<h3 id=\"将视图控制器压入栈\"><a href=\"#将视图控制器压入栈\" class=\"headerlink\" title=\"将视图控制器压入栈\"></a>将视图控制器压入栈</h3><p>使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:detailController animated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure></p>\n<p>视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。</p>\n<h3 id=\"视图控制器间传递数据\"><a href=\"#视图控制器间传递数据\" class=\"headerlink\" title=\"视图控制器间传递数据\"></a>视图控制器间传递数据</h3><h3 id=\"NavigationBar\"><a href=\"#NavigationBar\" class=\"headerlink\" title=\"NavigationBar\"></a>NavigationBar</h3><p>UIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。</p>\n<p>UINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。</p>\n<p>创建一个buttonItem：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initNavigationView&#123;</div><div class=\"line\">    <span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">    [backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"systemback\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    [backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(backButtonPressedForOrder:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"built_in\">UIBarButtonItem</span> *leftItem  = [[<span class=\"built_in\">UIBarButtonItem</span> alloc]initWithCustomView:backBtn];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.navigationItem setLeftBarButtonItem:leftItem];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。</p>","more":"<h2 id=\"第一个ios应用\"><a href=\"#第一个ios应用\" class=\"headerlink\" title=\"第一个ios应用\"></a>第一个ios应用</h2><h3 id=\"声明插座变量\"><a href=\"#声明插座变量\" class=\"headerlink\" title=\"声明插座变量\"></a>声明插座变量</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p>声明了一个叫questionLabel的插座变量.<br><strong>IBOutlet</strong>告诉Xcode需要使用Interface Builder关联该插座变量。</p>\n<h3 id=\"声明动作方法\"><a href=\"#声明动作方法\" class=\"headerlink\" title=\"声明动作方法\"></a>声明动作方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)showQuestion:(<span class=\"keyword\">id</span>)sender&#123;</div><div class=\"line\">\t……</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>IBAction</strong>关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。</p>\n<h3 id=\"应用图标\"><a href=\"#应用图标\" class=\"headerlink\" title=\"应用图标\"></a>应用图标</h3><p>Images.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。</p>\n<h2 id=\"objective-c\"><a href=\"#objective-c\" class=\"headerlink\" title=\"objective-c\"></a>objective-c</h2><h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>实例方法使用的字符是-，类方法使用字符+。<br>类方法作用通常是创建对象，获取类的某些全局属性。</p>\n<h2 id=\"通过ARC管理内存\"><a href=\"#通过ARC管理内存\" class=\"headerlink\" title=\"通过ARC管理内存\"></a>通过ARC管理内存</h2><h3 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h3><p>当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。<br>当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。</p>\n<p>copy和strong的区别就是：</p>\n<ul>\n<li>对于不可修改对象没有区别，都是直接返回对象地址</li>\n<li>对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。</li>\n</ul>\n<h2 id=\"视图与视图层次结构\"><a href=\"#视图与视图层次结构\" class=\"headerlink\" title=\"视图与视图层次结构\"></a>视图与视图层次结构</h2><h3 id=\"视图层次结构\"><a href=\"#视图层次结构\" class=\"headerlink\" title=\"视图层次结构\"></a>视图层次结构</h3><p>任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。<br>层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。</p>\n<h3 id=\"创建UIView子类\"><a href=\"#创建UIView子类\" class=\"headerlink\" title=\"创建UIView子类\"></a>创建UIView子类</h3><p>UIView子类模板会自动生成一个方法 <strong>initWithFrame:</strong>，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> （<span class=\"keyword\">nonatomic</span>） <span class=\"built_in\">CGRect</span> frame；</div></pre></td></tr></table></figure>\n<p>CGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。<br>创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；</p>\n<p>可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。<br>每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。<br>bounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。</p>\n<h3 id=\"图形绘制\"><a href=\"#图形绘制\" class=\"headerlink\" title=\"图形绘制\"></a>图形绘制</h3><p>没看</p>\n<h2 id=\"视图：重绘与UIScrollView\"><a href=\"#视图：重绘与UIScrollView\" class=\"headerlink\" title=\"视图：重绘与UIScrollView\"></a>视图：重绘与UIScrollView</h2><h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p>设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。<br>在scrollview中addSubView。</p>\n<h2 id=\"视图控制器\"><a href=\"#视图控制器\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h2><h3 id=\"视图控制器-1\"><a href=\"#视图控制器-1\" class=\"headerlink\" title=\"视图控制器\"></a>视图控制器</h3><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。<br>使用UITabBarController的类在两个视图控制器间切换。  </p>\n<p>UIViewController有一个重要属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIView</span> *view;</div></pre></td></tr></table></figure>\n<p>这个view就是视图的根视图。</p>\n<h3 id=\"创建视图层次结构\"><a href=\"#创建视图层次结构\" class=\"headerlink\" title=\"创建视图层次结构\"></a>创建视图层次结构</h3><ol>\n<li><p>覆盖UIViewController的loadView方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)loadView&#123;</div><div class=\"line\">        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];</div><div class=\"line\">        <span class=\"keyword\">self</span>.view = backgroundView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。</p>\n</li>\n<li><p>通过xib创建<br>.m中声明各个控件(注意控件使用弱引用)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>\n<p> 再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。</p>\n</li>\n</ol>\n<h3 id=\"设置根视图控制器\"><a href=\"#设置根视图控制器\" class=\"headerlink\" title=\"设置根视图控制器\"></a>设置根视图控制器</h3><p>UIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">BNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];</div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = hvc;</div></pre></td></tr></table></figure></p>\n<p>setRootViewController其实就是将ViewController的view设置为其subview。</p>\n<h3 id=\"加载nib文件\"><a href=\"#加载nib文件\" class=\"headerlink\" title=\"加载nib文件\"></a>加载nib文件</h3><p>加载不同名的nib文件时，需要使用<strong>initWithNibName:Bundle:</strong>方法。该方法的两个参数，分别用于指定NIB文件文件名和其<strong>所在的程序包</strong>。如果是Bundle传入nil默认是[NSBundle mainBundle];</p>\n<h3 id=\"UITabBarController\"><a href=\"#UITabBarController\" class=\"headerlink\" title=\"UITabBarController\"></a>UITabBarController</h3><p>UITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   </p>\n<p>在APPDelegate中创建两个视图控制器，加入Tabbar的<strong>viewControllers</strong>属性中，并将tabbar设置为rootViewController<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UITabBarController</span> *tabBarController = [[<span class=\"built_in\">UITabBarController</span> alloc] init];</div><div class=\"line\">tabBarController.viewControllers = @[hvc,rvc] <span class=\"comment\">//两个viewController 可以写在tabbarController的viewDidLoad方法里</span></div><div class=\"line\"><span class=\"keyword\">self</span>.window.rootViewController = tabBarController;</div></pre></td></tr></table></figure></p>\n<p>设置标签项，使用<strong>tabBarItem</strong>属性：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImage = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order\"</span>];</div><div class=\"line\"><span class=\"built_in\">UIImage</span> *orderImageSel = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"tab_order_active\"</span>];</div><div class=\"line\">orderImage = [orderImage imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\">orderImageSel = [orderImageSel imageWithRenderingMode:<span class=\"built_in\">UIImageRenderingModeAlwaysTemplate</span>];</div><div class=\"line\"><span class=\"built_in\">UITabBarItem</span> *orderTabBarItem = [[<span class=\"built_in\">UITabBarItem</span> alloc] initWithTitle:<span class=\"string\">@\"订单\"</span> image:orderImage selectedImage:orderImageSel];</div><div class=\"line\">orderNav.tabBarItem = orderTabBarItem;</div></pre></td></tr></table></figure>\n<p>为tabbar添加subview，UITabBarController里有一个<strong>tabBar</strong>的view</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UIView</span> *backview = [[<span class=\"built_in\">UIView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.tabBar.bounds];</div><div class=\"line\">[backview setBackgroundColor:[<span class=\"built_in\">UIColor</span> whiteColor]];</div><div class=\"line\">[<span class=\"keyword\">self</span>.tabBar addSubview:backview];</div></pre></td></tr></table></figure>\n<h3 id=\"本地通知\"><a href=\"#本地通知\" class=\"headerlink\" title=\"本地通知\"></a>本地通知</h3><p>本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UILocalNotification</span> *note = [][<span class=\"built_in\">UILocalNotification</span> alloc] init];</div><div class=\"line\">note.alertBody = <span class=\"string\">@\"xxx\"</span>;</div><div class=\"line\">note.fireDate = date;</div><div class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] scheduleLocalNotification:note];</div></pre></td></tr></table></figure></p>\n<h3 id=\"加载和显示视图\"><a href=\"#加载和显示视图\" class=\"headerlink\" title=\"加载和显示视图\"></a>加载和显示视图</h3><p>viewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。<br>另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。</p>\n<p>如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。</p>\n<h3 id=\"与视图控制器及其视图交互\"><a href=\"#与视图控制器及其视图交互\" class=\"headerlink\" title=\"与视图控制器及其视图交互\"></a>与视图控制器及其视图交互</h3><p><strong>application:didFinishLaunchingWithOptions:</strong>    该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。<br><strong>initWithNibName：bundle：</strong>该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。<br><strong>loadView：</strong>覆盖该方法，使用代码方式设置视图控制的的view属性。<br><strong>viewDidLoad：</strong>该方法会在视图控制器加载完视图后被调用。<br><strong>viewWillAppear：</strong>该方法会在视图控制器的view显示在屏幕上时被调用。  </p>\n<h2 id=\"委托与文本输入\"><a href=\"#委托与文本输入\" class=\"headerlink\" title=\"委托与文本输入\"></a>委托与文本输入</h2><h3 id=\"委托（代理模式）\"><a href=\"#委托（代理模式）\" class=\"headerlink\" title=\"委托（代理模式）\"></a>委托（代理模式）</h3><p>当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。<br>例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  </p>\n<p>类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  </p>\n<p>协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束<br>使用@optional指令，可以将写在指令后的全部声明为可选的。<br>发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  </p>\n<p>声明示例：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">BNRHypnosisViewController</span>()&lt;<span class=\"title\">UITextFieldDelegate</span>&gt;</span></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"设置异常断点\"><a href=\"#设置异常断点\" class=\"headerlink\" title=\"设置异常断点\"></a>设置异常断点</h3><p>当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。</p>\n<h3 id=\"类方法与实例方法\"><a href=\"#类方法与实例方法\" class=\"headerlink\" title=\"类方法与实例方法\"></a>类方法与实例方法</h3><p>这里需要注意：</p>\n<ol>\n<li>类方法可以调用类方法。</li>\n<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。</li>\n<li>类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<ul>\n<li>实例方法里面的self，是对象的首地址。</li>\n<li>类方法里面的self，是Class.</li>\n</ul>\n</li>\n<li>类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</li>\n</ol>\n<h2 id=\"UINavigationController\"><a href=\"#UINavigationController\" class=\"headerlink\" title=\"UINavigationController\"></a>UINavigationController</h2><h3 id=\"UINavigationController对象\"><a href=\"#UINavigationController对象\" class=\"headerlink\" title=\"UINavigationController对象\"></a>UINavigationController对象</h3><p>UINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。</p>\n<p>UINavigationController对象有一个名为<strong>viewControllers</strong>的属性，指向一个负责保存视图控制器的数组。<strong>topViewController</strong>属性是一个指针，指向当前位于栈顶的视图控制器。</p>\n<p>UINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有<strong>两个子视图</strong>：一个是<strong>UINavigationBar对象</strong>，一个是<strong>topViewController的视图</strong>。</p>\n<p>初始化UINavigationController对象：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">UINavigationController</span> *navController = [[<span class=\"built_in\">UINavigationController</span> alloc]initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>\n<h3 id=\"关联xib\"><a href=\"#关联xib\" class=\"headerlink\" title=\"关联xib\"></a>关联xib</h3><p>不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）</p>\n<p>在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。</p>\n<p>设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。</p>\n<h3 id=\"将视图控制器压入栈\"><a href=\"#将视图控制器压入栈\" class=\"headerlink\" title=\"将视图控制器压入栈\"></a>将视图控制器压入栈</h3><p>使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"keyword\">self</span>.navigationController pushViewController:detailController animated:<span class=\"literal\">YES</span>];</div></pre></td></tr></table></figure></p>\n<p>视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。</p>\n<h3 id=\"视图控制器间传递数据\"><a href=\"#视图控制器间传递数据\" class=\"headerlink\" title=\"视图控制器间传递数据\"></a>视图控制器间传递数据</h3><h3 id=\"NavigationBar\"><a href=\"#NavigationBar\" class=\"headerlink\" title=\"NavigationBar\"></a>NavigationBar</h3><p>UIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。</p>\n<p>UINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。</p>\n<p>创建一个buttonItem：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)initNavigationView&#123;</div><div class=\"line\">    <span class=\"built_in\">UIButton</span> *backBtn = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">44</span>)];</div><div class=\"line\">    [backBtn setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"systemback\"</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</div><div class=\"line\">    [backBtn addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(backButtonPressedForOrder:) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</div><div class=\"line\">    <span class=\"built_in\">UIBarButtonItem</span> *leftItem  = [[<span class=\"built_in\">UIBarButtonItem</span> alloc]initWithCustomView:backBtn];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.navigationItem setLeftBarButtonItem:leftItem];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"初识Provisioning Profile","date":"2016-08-26T06:07:12.000Z","_content":"\n真机调试的时候遇到了*provisioning profile即将过期*的警告，于是搜索并对provisioning profile作了一定了解。结合[关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系](http://www.cnblogs.com/cywin888/p/3263027.html)进行梳理。\n\n<!--more-->\n\n## 基本概念\n### Certificate\n证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。\n\n众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 \n\n![证书的私钥和公钥](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true)\n\n证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）\n\n### APP ID\nApp ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：\n- Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。\n- Wildcard App ID：通配符App ID，用于标识一组应用程序。例如\\*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。\n\n每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。\n\n### Device\nDevice最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。\n\n每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。\n\n### Provisioning Profile\n一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。\n\n试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。\n\n例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。\n\n![Provisioning Profile组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true)\n\n如上所述，在一台设备上运行应用程序的过程如下：\n\n![Provisioning Profile验证](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true)\n\n与证书一样，Provisioning Profile也分为Development和Distribution两种\n\n## Xcode 7+ 免证书真机调试\n在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app\n\n### 使用方法\n1. 打开自己已有的工程或者打开Xcode新建一个简单工程\n2. 菜单栏选择Xcode,下拉菜单中选择Preferences...(快捷键 command + , )\n\t![1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true)\n3. 在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。\n\t![2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true)\n4. 将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。\n\t![3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true)\n5. Xcode报错如下图所示，直接点击Fix Issue。\n\t![4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true)\n6. 警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。\n\t![5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true)\n\n\n\n","source":"_posts/初识Provisioning_Profile.md","raw":"title: 初识Provisioning Profile\ndate: 2016/8/26 14:07:12  \ncategories: IOS\ntags: [Xcode]\n\n---\n\n真机调试的时候遇到了*provisioning profile即将过期*的警告，于是搜索并对provisioning profile作了一定了解。结合[关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系](http://www.cnblogs.com/cywin888/p/3263027.html)进行梳理。\n\n<!--more-->\n\n## 基本概念\n### Certificate\n证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。\n\n众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 \n\n![证书的私钥和公钥](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true)\n\n证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）\n\n### APP ID\nApp ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：\n- Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。\n- Wildcard App ID：通配符App ID，用于标识一组应用程序。例如\\*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。\n\n每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。\n\n### Device\nDevice最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。\n\n每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。\n\n### Provisioning Profile\n一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。\n\n试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。\n\n例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。\n\n![Provisioning Profile组成](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true)\n\n如上所述，在一台设备上运行应用程序的过程如下：\n\n![Provisioning Profile验证](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true)\n\n与证书一样，Provisioning Profile也分为Development和Distribution两种\n\n## Xcode 7+ 免证书真机调试\n在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app\n\n### 使用方法\n1. 打开自己已有的工程或者打开Xcode新建一个简单工程\n2. 菜单栏选择Xcode,下拉菜单中选择Preferences...(快捷键 command + , )\n\t![1](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true)\n3. 在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。\n\t![2](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true)\n4. 将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。\n\t![3](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true)\n5. Xcode报错如下图所示，直接点击Fix Issue。\n\t![4](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true)\n6. 警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。\n\t![5](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true)\n\n\n\n","slug":"初识Provisioning_Profile","published":1,"updated":"2016-09-23T05:45:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyl003prgruwp2njx5s","content":"<p>真机调试的时候遇到了<em>provisioning profile即将过期</em>的警告，于是搜索并对provisioning profile作了一定了解。结合<a href=\"http://www.cnblogs.com/cywin888/p/3263027.html\" target=\"_blank\" rel=\"external\">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a>进行梳理。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Certificate\"><a href=\"#Certificate\" class=\"headerlink\" title=\"Certificate\"></a>Certificate</h3><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。</p>\n<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true\" alt=\"证书的私钥和公钥\"></p>\n<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）</p>\n<h3 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>\n<ul>\n<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>\n<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>\n</ul>\n<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。</p>\n<h3 id=\"Device\"><a href=\"#Device\" class=\"headerlink\" title=\"Device\"></a>Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>\n<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>\n<h3 id=\"Provisioning-Profile\"><a href=\"#Provisioning-Profile\" class=\"headerlink\" title=\"Provisioning Profile\"></a>Provisioning Profile</h3><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>\n<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>\n<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true\" alt=\"Provisioning Profile组成\"></p>\n<p>如上所述，在一台设备上运行应用程序的过程如下：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true\" alt=\"Provisioning Profile验证\"></p>\n<p>与证书一样，Provisioning Profile也分为Development和Distribution两种</p>\n<h2 id=\"Xcode-7-免证书真机调试\"><a href=\"#Xcode-7-免证书真机调试\" class=\"headerlink\" title=\"Xcode 7+ 免证书真机调试\"></a>Xcode 7+ 免证书真机调试</h2><p>在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ol>\n<li>打开自己已有的工程或者打开Xcode新建一个简单工程</li>\n<li>菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , )<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true\" alt=\"1\"></li>\n<li>在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true\" alt=\"2\"></li>\n<li>将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true\" alt=\"3\"></li>\n<li>Xcode报错如下图所示，直接点击Fix Issue。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true\" alt=\"4\"></li>\n<li>警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true\" alt=\"5\"></li>\n</ol>\n","excerpt":"<p>真机调试的时候遇到了<em>provisioning profile即将过期</em>的警告，于是搜索并对provisioning profile作了一定了解。结合<a href=\"http://www.cnblogs.com/cywin888/p/3263027.html\">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a>进行梳理。</p>","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Certificate\"><a href=\"#Certificate\" class=\"headerlink\" title=\"Certificate\"></a>Certificate</h3><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。</p>\n<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true\" alt=\"证书的私钥和公钥\"></p>\n<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）</p>\n<h3 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>\n<ul>\n<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>\n<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>\n</ul>\n<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。</p>\n<h3 id=\"Device\"><a href=\"#Device\" class=\"headerlink\" title=\"Device\"></a>Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>\n<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>\n<h3 id=\"Provisioning-Profile\"><a href=\"#Provisioning-Profile\" class=\"headerlink\" title=\"Provisioning Profile\"></a>Provisioning Profile</h3><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>\n<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>\n<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true\" alt=\"Provisioning Profile组成\"></p>\n<p>如上所述，在一台设备上运行应用程序的过程如下：</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true\" alt=\"Provisioning Profile验证\"></p>\n<p>与证书一样，Provisioning Profile也分为Development和Distribution两种</p>\n<h2 id=\"Xcode-7-免证书真机调试\"><a href=\"#Xcode-7-免证书真机调试\" class=\"headerlink\" title=\"Xcode 7+ 免证书真机调试\"></a>Xcode 7+ 免证书真机调试</h2><p>在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app</p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><ol>\n<li>打开自己已有的工程或者打开Xcode新建一个简单工程</li>\n<li>菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , )<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true\" alt=\"1\"></li>\n<li>在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true\" alt=\"2\"></li>\n<li>将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true\" alt=\"3\"></li>\n<li>Xcode报错如下图所示，直接点击Fix Issue。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true\" alt=\"4\"></li>\n<li>警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。<br> <img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true\" alt=\"5\"></li>\n</ol>"},{"title":"ios核心动画","date":"2016-08-16T06:07:12.000Z","_content":"依旧是[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)关于核心动画的内容。作为入门\n\n**核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。**\n\n<!--more-->\n\n## 核心动画简介\nCAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。\n\nCAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation\n它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@\"position\"为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果\n\n常见属性：\n- duration：动画的持续时间\n- repeatCount：动画的重复次数\n- repeatDuration：动画的重复时间\n- removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards\n- fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后\n- beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间\n- timingFunction：速度控制函数，控制动画运行的节奏\n- delegate：动画代理\n\n## 基础动画\n### 简介\nCABasicAnimation，是CApropertyAnimation的子类\n\n属性：\n- fromValue：keyPath相应属性的初始值\n- toValue：keyPath相应属性的结束值\n\n随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue\n\n如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但**在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。**比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。\n\n### 示例\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,strong)CALayer *myLayer;\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    //创建layer\n    CALayer *myLayer=[CALayer layer];\n    //设置layer的属性\n    myLayer.bounds=CGRectMake(0, 0, 50, 80);\n    myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n    myLayer.position=CGPointMake(50, 50);\n    myLayer.anchorPoint=CGPointMake(0, 0);\n    myLayer.cornerRadius=20;\n    //添加layer\n    [self.view.layer addSublayer:myLayer];\n    self.myLayer=myLayer;\n}\n//设置 平移 动画\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    //    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:<#(NSString *)#>]\n    CABasicAnimation *anima=[CABasicAnimation animation];\n    \n    //1.1告诉系统要执行什么样的动画\n    anima.keyPath=@\"position\";\n    //设置通过动画，将layer从哪儿移动到哪儿\n    anima.fromValue=[NSValue valueWithCGPoint:CGPointMake(0, 0)];\n    anima.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 300)];\n    \n    //1.2设置动画执行完毕之后不删除动画\n    anima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    anima.fillMode=kCAFillModeForwards;\n\n    //2.添加核心动画到layer\n    [self.myLayer addAnimation:anima forKey:nil];\n\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始执行动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    //动画执行完毕，打印执行完毕后的position值\n    NSString *str=NSStringFromCGPoint(self.myLayer.position);\n    NSLog(@\"执行后：%@\",str);\n}\n\n@end\n```\n\n其中keypath的值决定产生什么动画\n1. position：执行平移动画\n2. bounds：执行缩放动画\n3. transform：执行旋转动画\n\n## 关键帧动画\n### 简介\nCAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值\n\n属性：\n- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧\n- path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略\n- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的\n\n说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation\n\n### 示例\n#### 使用value\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    NSValue *value1=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    NSValue *value2=[NSValue valueWithCGPoint:CGPointMake(200, 100)];\n    NSValue *value3=[NSValue valueWithCGPoint:CGPointMake(200, 200)];\n    NSValue *value4=[NSValue valueWithCGPoint:CGPointMake(100, 200)];\n    NSValue *value5=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    keyAnima.values=@[value1,value2,value3,value4,value5];\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=4.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:nil];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n#### 使用path\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    //创建一条路径\n    CGMutablePathRef path=CGPathCreateMutable();\n    //设置一个圆的路径\n    CGPathAddEllipseInRect(path, NULL, CGRectMake(150, 100, 100, 100));\n    keyAnima.path=path;\n    \n    //有create就一定要有release\n    CGPathRelease(path);\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=5.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:@\"wendingding\"];\n}\n\n- (IBAction)stopOnClick:(UIButton *)sender {\n    //停止self.customView.layer上名称标示为wendingding的动画\n    [self.customView.layer removeAnimationForKey:@\"wendingding\"];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n点击停止动画，程序内部会调用  `[self.customView.layer removeAnimationForKey:@\"wendingding\"];`停止`self.customView.layer`上名称标示为wendingding的动画。\n\n#### 图标抖动\n```objc\n\n#import \"YYViewController.h\"\n#define angle2Radian(angle)  ((angle)/180.0*M_PI)\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n@end\n\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    keyAnima.keyPath=@\"transform.rotation\";\n    //设置动画时间\n    keyAnima.duration=0.1;\n    //设置图标抖动弧度\n    //把度数转换为弧度  度数/180*M_PI\n    keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];\n    //设置动画的重复次数(设置为最大值)\n    keyAnima.repeatCount=MAXFLOAT;\n    \n    keyAnima.fillMode=kCAFillModeForwards;\n    keyAnima.removedOnCompletion=NO;\n    //2.添加动画\n    [self.iconView.layer addAnimation:keyAnima forKey:nil];\n}\n\n@end\n```\n\n其中，`keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];`表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。\n\n**@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象**\n\n## 转场动画和组动画\n### 介绍\nCATransition用于做转场动画\n属性：\n- type：动画过渡类型\n- subtype：动画过渡方向\n- startProgress：动画起点(在整体动画的百分比)\n- endProgress：动画终点(在整体动画的百分比)\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,assign) int index;\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n- (IBAction)preOnClick:(UIButton *)sender;\n- (IBAction)nextOnClick:(UIButton *)sender;\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.index=1;\n\n}\n\n- (IBAction)preOnClick:(UIButton *)sender {\n    self.index--;\n    if (self.index<1) {\n        self.index=7;\n    }\n    self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //创建核心动画\n    CATransition *ca=[CATransition animation];\n    //告诉要执行什么动画\n    //设置过度效果\n    ca.type=@\"cube\";\n    //设置动画的过度方向（向左）\n    ca.subtype=kCATransitionFromLeft;\n    //设置动画的时间\n    ca.duration=2.0;\n    //添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n//下一张\n- (IBAction)nextOnClick:(UIButton *)sender {\n    self.index++;\n    if (self.index>7) {\n        self.index=1;\n    }\n        self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //1.创建核心动画\n    CATransition *ca=[CATransition animation];\n    \n    //1.1告诉要执行什么动画\n    //1.2设置过度效果\n    ca.type=@\"cube\";\n    //1.3设置动画的过度方向（向右）\n    ca.subtype=kCATransitionFromRight;\n    //1.4设置动画的时间\n    ca.duration=2.0;\n    //1.5设置动画的起点\n    ca.startProgress=0.5;\n    //1.6设置动画的终点\n//    ca.endProgress=0.5;\n    \n    //2.添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n@end\n```\n\n### 组动画\n将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *iconView;\n\n@end\n\n@implementation NJViewController\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{\n    // 平移动画\n    CABasicAnimation *a1 = [CABasicAnimation animation];\n    a1.keyPath = @\"transform.translation.y\";\n    a1.toValue = @(100);\n    // 缩放动画\n    CABasicAnimation *a2 = [CABasicAnimation animation];\n    a2.keyPath = @\"transform.scale\";\n    a2.toValue = @(0.0);\n    // 旋转动画\n    CABasicAnimation *a3 = [CABasicAnimation animation];\n    a3.keyPath = @\"transform.rotation\";\n    a3.toValue = @(M_PI_2);\n    // 组动画\n    CAAnimationGroup *groupAnima = [CAAnimationGroup animation];\n    \n    groupAnima.animations = @[a1, a2, a3];\n    \n    //设置组动画的时间\n    groupAnima.duration = 2;\n    groupAnima.fillMode = kCAFillModeForwards;\n    groupAnima.removedOnCompletion = NO;\n    \n    [self.iconView.layer addAnimation:groupAnima forKey:nil];\n}\n\n@end\n```\n\n## UIView封装动画\n### UIView动画（首尾）\n#### 简介\n执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。\n常见方法：\n- **+ (void)setAnimationDelegate:(id)delegate**     设置动画代理对象，当动画开始或者结束时会发消息给代理对象\n- **+ (void)setAnimationWillStartSelector:(SEL)selector**   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDidStopSelector:(SEL)selector**  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDuration:(NSTimeInterval)duration**   动画的持续时间，秒为单位\n- **+ (void)setAnimationDelay:(NSTimeInterval)delay**  动画延迟delay秒后再开始\n- **+ (void)setAnimationStartDate:(NSDate \\*)startDate**   动画的开始时间，默认为now\n- **+ (void)setAnimationCurve:(UIViewAnimationCurve)curve**  动画的节奏控制\n- **+ (void)setAnimationRepeatCount:(float)repeatCount**  动画的重复次数\n- **+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses**  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反\n- **+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView \\*)view cache:(BOOL)cache**  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好\n\n#### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n}\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //打印动画块的位置\n    NSLog(@\"动画执行之前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n    \n    //首尾式动画\n    [UIView beginAnimations:nil context:nil];\n    //执行动画\n    //设置动画执行时间\n    [UIView setAnimationDuration:2.0];\n    //设置代理\n    [UIView setAnimationDelegate:self];\n    //设置动画执行完毕调用的事件\n    [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];\n    self.customView.center=CGPointMake(200, 300);\n    [UIView commitAnimations];\n\n}\n\n-(void)didStopAnimation\n{\n    NSLog(@\"动画执行完毕\");\n    //打印动画块的位置\n    NSLog(@\"动画执行之后的位置：%@\",NSStringFromCGPoint(self.customView.center));\n}\n\n@end\n```\n\n#### UIView封装的动画与CALayer动画的对比\n使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。\n\n**CALayer核心动画与UIView动画的区别**：\nUIView封装的动画，改变`view`或者`layer`执行完毕之后不会反弹。如果是通过**CALayer核心动画**改变`layer`的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。\n\n### block动画\n#### 方法：\n- **+(void)animateWithDuration:delay:options:animations:completion:**\n- **+(void)transitionWithView:duration:options:animations:completion:**\n- **+(void)transitionFromView:toView:duration:options:completion:**\n属性简介：\n1. duration：动画的持续时间\n2. delay：动画延迟delay秒后开始\n3. options：动画的节奏控制/转场动画的类型(重复，转场等)\n4. animations：将改变视图属性的代码放在这个block中\n5. completion：动画结束后，会自动调用这个block\n\n前两个方法用起来好像没什么区别。\n\n#### 示例：\n```objc\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //block代码块动画\n        [UIView transitionWithView:self.customView duration:3.0 options:0 animations:^{\n            //执行的动画\n            NSLog(@\"动画开始执行前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n            self.customView.center=CGPointMake(200, 300);\n        } completion:^(BOOL finished) {\n            //动画执行完毕后的首位操作\n            NSLog(@\"动画执行完毕\");\n            NSLog(@\"动画执行完毕后的位置：%@\",NSStringFromCGPoint( self.customView.center));\n        }];\n}\n```\n\n> Demo详见CALayer_Transform\n\n\n","source":"_posts/ios动画.md","raw":"title: ios核心动画\ndate: 2016/8/16 14:07:12  \ncategories: IOS\ntags: [Animation]\n\n---\n依旧是[文顶顶的ios开发UI篇](http://www.cnblogs.com/wendingding/tag/UI高级/)关于核心动画的内容。作为入门\n\n**核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。**\n\n<!--more-->\n\n## 核心动画简介\nCAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。\n\nCAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation\n它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@\"position\"为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果\n\n常见属性：\n- duration：动画的持续时间\n- repeatCount：动画的重复次数\n- repeatDuration：动画的重复时间\n- removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards\n- fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后\n- beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间\n- timingFunction：速度控制函数，控制动画运行的节奏\n- delegate：动画代理\n\n## 基础动画\n### 简介\nCABasicAnimation，是CApropertyAnimation的子类\n\n属性：\n- fromValue：keyPath相应属性的初始值\n- toValue：keyPath相应属性的结束值\n\n随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue\n\n如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但**在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。**比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。\n\n### 示例\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,strong)CALayer *myLayer;\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    //创建layer\n    CALayer *myLayer=[CALayer layer];\n    //设置layer的属性\n    myLayer.bounds=CGRectMake(0, 0, 50, 80);\n    myLayer.backgroundColor=[UIColor yellowColor].CGColor;\n    myLayer.position=CGPointMake(50, 50);\n    myLayer.anchorPoint=CGPointMake(0, 0);\n    myLayer.cornerRadius=20;\n    //添加layer\n    [self.view.layer addSublayer:myLayer];\n    self.myLayer=myLayer;\n}\n//设置 平移 动画\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    //    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:<#(NSString *)#>]\n    CABasicAnimation *anima=[CABasicAnimation animation];\n    \n    //1.1告诉系统要执行什么样的动画\n    anima.keyPath=@\"position\";\n    //设置通过动画，将layer从哪儿移动到哪儿\n    anima.fromValue=[NSValue valueWithCGPoint:CGPointMake(0, 0)];\n    anima.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 300)];\n    \n    //1.2设置动画执行完毕之后不删除动画\n    anima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    anima.fillMode=kCAFillModeForwards;\n\n    //2.添加核心动画到layer\n    [self.myLayer addAnimation:anima forKey:nil];\n\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始执行动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    //动画执行完毕，打印执行完毕后的position值\n    NSString *str=NSStringFromCGPoint(self.myLayer.position);\n    NSLog(@\"执行后：%@\",str);\n}\n\n@end\n```\n\n其中keypath的值决定产生什么动画\n1. position：执行平移动画\n2. bounds：执行缩放动画\n3. transform：执行旋转动画\n\n## 关键帧动画\n### 简介\nCAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值\n\n属性：\n- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧\n- path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略\n- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的\n\n说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation\n\n### 示例\n#### 使用value\n```objc\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    NSValue *value1=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    NSValue *value2=[NSValue valueWithCGPoint:CGPointMake(200, 100)];\n    NSValue *value3=[NSValue valueWithCGPoint:CGPointMake(200, 200)];\n    NSValue *value4=[NSValue valueWithCGPoint:CGPointMake(100, 200)];\n    NSValue *value5=[NSValue valueWithCGPoint:CGPointMake(100, 100)];\n    keyAnima.values=@[value1,value2,value3,value4,value5];\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=4.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:nil];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n#### 使用path\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n@end\n\n@implementation YYViewController\n\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    //平移\n    keyAnima.keyPath=@\"position\";\n    //1.1告诉系统要执行什么动画\n    //创建一条路径\n    CGMutablePathRef path=CGPathCreateMutable();\n    //设置一个圆的路径\n    CGPathAddEllipseInRect(path, NULL, CGRectMake(150, 100, 100, 100));\n    keyAnima.path=path;\n    \n    //有create就一定要有release\n    CGPathRelease(path);\n    //1.2设置动画执行完毕后，不删除动画\n    keyAnima.removedOnCompletion=NO;\n    //1.3设置保存动画的最新状态\n    keyAnima.fillMode=kCAFillModeForwards;\n    //1.4设置动画执行的时间\n    keyAnima.duration=5.0;\n    //1.5设置动画的节奏\n    keyAnima.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    \n    //设置代理，开始—结束\n    keyAnima.delegate=self;\n    //2.添加核心动画\n    [self.customView.layer addAnimation:keyAnima forKey:@\"wendingding\"];\n}\n\n- (IBAction)stopOnClick:(UIButton *)sender {\n    //停止self.customView.layer上名称标示为wendingding的动画\n    [self.customView.layer removeAnimationForKey:@\"wendingding\"];\n}\n\n-(void)animationDidStart:(CAAnimation *)anim\n{\n    NSLog(@\"开始动画\");\n}\n\n-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag\n{\n    NSLog(@\"结束动画\");\n}\n@end\n```\n\n点击停止动画，程序内部会调用  `[self.customView.layer removeAnimationForKey:@\"wendingding\"];`停止`self.customView.layer`上名称标示为wendingding的动画。\n\n#### 图标抖动\n```objc\n\n#import \"YYViewController.h\"\n#define angle2Radian(angle)  ((angle)/180.0*M_PI)\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n@end\n\n\n@implementation YYViewController\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //1.创建核心动画\n    CAKeyframeAnimation *keyAnima=[CAKeyframeAnimation animation];\n    keyAnima.keyPath=@\"transform.rotation\";\n    //设置动画时间\n    keyAnima.duration=0.1;\n    //设置图标抖动弧度\n    //把度数转换为弧度  度数/180*M_PI\n    keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];\n    //设置动画的重复次数(设置为最大值)\n    keyAnima.repeatCount=MAXFLOAT;\n    \n    keyAnima.fillMode=kCAFillModeForwards;\n    keyAnima.removedOnCompletion=NO;\n    //2.添加动画\n    [self.iconView.layer addAnimation:keyAnima forKey:nil];\n}\n\n@end\n```\n\n其中，`keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];`表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。\n\n**@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象**\n\n## 转场动画和组动画\n### 介绍\nCATransition用于做转场动画\n属性：\n- type：动画过渡类型\n- subtype：动画过渡方向\n- startProgress：动画起点(在整体动画的百分比)\n- endProgress：动画终点(在整体动画的百分比)\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property(nonatomic,assign) int index;\n@property (weak, nonatomic) IBOutlet UIImageView *iconView;\n\n- (IBAction)preOnClick:(UIButton *)sender;\n- (IBAction)nextOnClick:(UIButton *)sender;\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.index=1;\n\n}\n\n- (IBAction)preOnClick:(UIButton *)sender {\n    self.index--;\n    if (self.index<1) {\n        self.index=7;\n    }\n    self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //创建核心动画\n    CATransition *ca=[CATransition animation];\n    //告诉要执行什么动画\n    //设置过度效果\n    ca.type=@\"cube\";\n    //设置动画的过度方向（向左）\n    ca.subtype=kCATransitionFromLeft;\n    //设置动画的时间\n    ca.duration=2.0;\n    //添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n//下一张\n- (IBAction)nextOnClick:(UIButton *)sender {\n    self.index++;\n    if (self.index>7) {\n        self.index=1;\n    }\n        self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@\"%d.jpg\",self.index]];\n    \n    //1.创建核心动画\n    CATransition *ca=[CATransition animation];\n    \n    //1.1告诉要执行什么动画\n    //1.2设置过度效果\n    ca.type=@\"cube\";\n    //1.3设置动画的过度方向（向右）\n    ca.subtype=kCATransitionFromRight;\n    //1.4设置动画的时间\n    ca.duration=2.0;\n    //1.5设置动画的起点\n    ca.startProgress=0.5;\n    //1.6设置动画的终点\n//    ca.endProgress=0.5;\n    \n    //2.添加动画\n    [self.iconView.layer addAnimation:ca forKey:nil];\n}\n\n@end\n```\n\n### 组动画\n将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.\n\n### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *iconView;\n\n@end\n\n@implementation NJViewController\n\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{\n    // 平移动画\n    CABasicAnimation *a1 = [CABasicAnimation animation];\n    a1.keyPath = @\"transform.translation.y\";\n    a1.toValue = @(100);\n    // 缩放动画\n    CABasicAnimation *a2 = [CABasicAnimation animation];\n    a2.keyPath = @\"transform.scale\";\n    a2.toValue = @(0.0);\n    // 旋转动画\n    CABasicAnimation *a3 = [CABasicAnimation animation];\n    a3.keyPath = @\"transform.rotation\";\n    a3.toValue = @(M_PI_2);\n    // 组动画\n    CAAnimationGroup *groupAnima = [CAAnimationGroup animation];\n    \n    groupAnima.animations = @[a1, a2, a3];\n    \n    //设置组动画的时间\n    groupAnima.duration = 2;\n    groupAnima.fillMode = kCAFillModeForwards;\n    groupAnima.removedOnCompletion = NO;\n    \n    [self.iconView.layer addAnimation:groupAnima forKey:nil];\n}\n\n@end\n```\n\n## UIView封装动画\n### UIView动画（首尾）\n#### 简介\n执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。\n常见方法：\n- **+ (void)setAnimationDelegate:(id)delegate**     设置动画代理对象，当动画开始或者结束时会发消息给代理对象\n- **+ (void)setAnimationWillStartSelector:(SEL)selector**   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDidStopSelector:(SEL)selector**  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector\n- **+ (void)setAnimationDuration:(NSTimeInterval)duration**   动画的持续时间，秒为单位\n- **+ (void)setAnimationDelay:(NSTimeInterval)delay**  动画延迟delay秒后再开始\n- **+ (void)setAnimationStartDate:(NSDate \\*)startDate**   动画的开始时间，默认为now\n- **+ (void)setAnimationCurve:(UIViewAnimationCurve)curve**  动画的节奏控制\n- **+ (void)setAnimationRepeatCount:(float)repeatCount**  动画的重复次数\n- **+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses**  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反\n- **+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView \\*)view cache:(BOOL)cache**  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好\n\n#### 示例\n```objc\n\n#import \"YYViewController.h\"\n\n@interface YYViewController ()\n@property (weak, nonatomic) IBOutlet UIView *customView;\n\n\n@end\n\n@implementation YYViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n}\n\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //打印动画块的位置\n    NSLog(@\"动画执行之前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n    \n    //首尾式动画\n    [UIView beginAnimations:nil context:nil];\n    //执行动画\n    //设置动画执行时间\n    [UIView setAnimationDuration:2.0];\n    //设置代理\n    [UIView setAnimationDelegate:self];\n    //设置动画执行完毕调用的事件\n    [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];\n    self.customView.center=CGPointMake(200, 300);\n    [UIView commitAnimations];\n\n}\n\n-(void)didStopAnimation\n{\n    NSLog(@\"动画执行完毕\");\n    //打印动画块的位置\n    NSLog(@\"动画执行之后的位置：%@\",NSStringFromCGPoint(self.customView.center));\n}\n\n@end\n```\n\n#### UIView封装的动画与CALayer动画的对比\n使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。\n\n**CALayer核心动画与UIView动画的区别**：\nUIView封装的动画，改变`view`或者`layer`执行完毕之后不会反弹。如果是通过**CALayer核心动画**改变`layer`的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。\n\n### block动画\n#### 方法：\n- **+(void)animateWithDuration:delay:options:animations:completion:**\n- **+(void)transitionWithView:duration:options:animations:completion:**\n- **+(void)transitionFromView:toView:duration:options:completion:**\n属性简介：\n1. duration：动画的持续时间\n2. delay：动画延迟delay秒后开始\n3. options：动画的节奏控制/转场动画的类型(重复，转场等)\n4. animations：将改变视图属性的代码放在这个block中\n5. completion：动画结束后，会自动调用这个block\n\n前两个方法用起来好像没什么区别。\n\n#### 示例：\n```objc\n-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n    //block代码块动画\n        [UIView transitionWithView:self.customView duration:3.0 options:0 animations:^{\n            //执行的动画\n            NSLog(@\"动画开始执行前的位置：%@\",NSStringFromCGPoint(self.customView.center));\n            self.customView.center=CGPointMake(200, 300);\n        } completion:^(BOOL finished) {\n            //动画执行完毕后的首位操作\n            NSLog(@\"动画执行完毕\");\n            NSLog(@\"动画执行完毕后的位置：%@\",NSStringFromCGPoint( self.customView.center));\n        }];\n}\n```\n\n> Demo详见CALayer_Transform\n\n\n","slug":"ios动画","published":1,"updated":"2016-09-23T05:46:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyo003trgrur7gwfoff","content":"<p>依旧是<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\" target=\"_blank\" rel=\"external\">文顶顶的ios开发UI篇</a>关于核心动画的内容。作为入门</p>\n<p><strong>核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"核心动画简介\"><a href=\"#核心动画简介\" class=\"headerlink\" title=\"核心动画简介\"></a>核心动画简介</h2><p>CAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。</p>\n<p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation<br>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>\n<p>常见属性：</p>\n<ul>\n<li>duration：动画的持续时间</li>\n<li>repeatCount：动画的重复次数</li>\n<li>repeatDuration：动画的重复时间</li>\n<li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li>\n<li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li>\n<li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li>\n<li>timingFunction：速度控制函数，控制动画运行的节奏</li>\n<li>delegate：动画代理</li>\n</ul>\n<h2 id=\"基础动画\"><a href=\"#基础动画\" class=\"headerlink\" title=\"基础动画\"></a>基础动画</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CABasicAnimation，是CApropertyAnimation的子类</p>\n<p>属性：</p>\n<ul>\n<li>fromValue：keyPath相应属性的初始值</li>\n<li>toValue：keyPath相应属性的结束值</li>\n</ul>\n<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>\n<p>如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但<strong>在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</strong>比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>)<span class=\"built_in\">CALayer</span> *myLayer;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">    myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">    myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"comment\">//添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设置 平移 动画</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"comment\">//    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:&lt;#(NSString *)#&gt;]</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *anima=[<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么样的动画</span></div><div class=\"line\">    anima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置通过动画，将layer从哪儿移动到哪儿</span></div><div class=\"line\">    anima.fromValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>)];</div><div class=\"line\">    anima.toValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕之后不删除动画</span></div><div class=\"line\">    anima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    anima.fillMode=kCAFillModeForwards;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画到layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.myLayer addAnimation:anima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始执行动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//动画执行完毕，打印执行完毕后的position值</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str=<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.myLayer.position);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"执行后：%@\"</span>,str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中keypath的值决定产生什么动画</p>\n<ol>\n<li>position：执行平移动画</li>\n<li>bounds：执行缩放动画</li>\n<li>transform：执行旋转动画</li>\n</ol>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>\n<p>属性：</p>\n<ul>\n<li>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>\n<li>path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</li>\n<li>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>\n</ul>\n<p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"使用value\"><a href=\"#使用value\" class=\"headerlink\" title=\"使用value\"></a>使用value</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value1=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value2=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value3=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value4=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value5=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    keyAnima.values=@[value1,value2,value3,value4,value5];</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">4.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用path\"><a href=\"#使用path\" class=\"headerlink\" title=\"使用path\"></a>使用path</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//创建一条路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path=<span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"comment\">//设置一个圆的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">150</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    keyAnima.path=path;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//有create就一定要有release</span></div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">5.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)stopOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//停止self.customView.layer上名称标示为wendingding的动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer removeAnimationForKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>点击停止动画，程序内部会调用  <code>[self.customView.layer removeAnimationForKey:@&quot;wendingding&quot;];</code>停止<code>self.customView.layer</code>上名称标示为wendingding的动画。</p>\n<h4 id=\"图标抖动\"><a href=\"#图标抖动\" class=\"headerlink\" title=\"图标抖动\"></a>图标抖动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#define angle2Radian(angle)  ((angle)/180.0*M_PI)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">0.1</span>;</div><div class=\"line\">    <span class=\"comment\">//设置图标抖动弧度</span></div><div class=\"line\">    <span class=\"comment\">//把度数转换为弧度  度数/180*M_PI</span></div><div class=\"line\">    keyAnima.values=@[@(-angle2Radian(<span class=\"number\">4</span>)),@(angle2Radian(<span class=\"number\">4</span>)),@(-angle2Radian(<span class=\"number\">4</span>))];</div><div class=\"line\">    <span class=\"comment\">//设置动画的重复次数(设置为最大值)</span></div><div class=\"line\">    keyAnima.repeatCount=MAXFLOAT;</div><div class=\"line\">    </div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中，<code>keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];</code>表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。</p>\n<p><strong>@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象</strong></p>\n<h2 id=\"转场动画和组动画\"><a href=\"#转场动画和组动画\" class=\"headerlink\" title=\"转场动画和组动画\"></a>转场动画和组动画</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CATransition用于做转场动画<br>属性：</p>\n<ul>\n<li>type：动画过渡类型</li>\n<li>subtype：动画过渡方向</li>\n<li>startProgress：动画起点(在整体动画的百分比)</li>\n<li>endProgress：动画终点(在整体动画的百分比)</li>\n</ul>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> index;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index--;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">7</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    <span class=\"comment\">//告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画的过度方向（向左）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromLeft;</div><div class=\"line\">    <span class=\"comment\">//设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下一张</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&gt;<span class=\"number\">7</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//1.2设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置动画的过度方向（向右）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromRight;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的起点</span></div><div class=\"line\">    ca.startProgress=<span class=\"number\">0.5</span>;</div><div class=\"line\">    <span class=\"comment\">//1.6设置动画的终点</span></div><div class=\"line\"><span class=\"comment\">//    ca.endProgress=0.5;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"组动画\"><a href=\"#组动画\" class=\"headerlink\" title=\"组动画\"></a>组动画</h3><p>将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.</p>\n<h3 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NJViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 平移动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a1 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a1.keyPath = <span class=\"string\">@\"transform.translation.y\"</span>;</div><div class=\"line\">    a1.toValue = @(<span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"comment\">// 缩放动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a2 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a2.keyPath = <span class=\"string\">@\"transform.scale\"</span>;</div><div class=\"line\">    a2.toValue = @(<span class=\"number\">0.0</span>);</div><div class=\"line\">    <span class=\"comment\">// 旋转动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a3 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a3.keyPath = <span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    a3.toValue = @(M_PI_2);</div><div class=\"line\">    <span class=\"comment\">// 组动画</span></div><div class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *groupAnima = [<span class=\"built_in\">CAAnimationGroup</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    groupAnima.animations = @[a1, a2, a3];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置组动画的时间</span></div><div class=\"line\">    groupAnima.duration = <span class=\"number\">2</span>;</div><div class=\"line\">    groupAnima.fillMode = kCAFillModeForwards;</div><div class=\"line\">    groupAnima.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:groupAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"UIView封装动画\"><a href=\"#UIView封装动画\" class=\"headerlink\" title=\"UIView封装动画\"></a>UIView封装动画</h2><h3 id=\"UIView动画（首尾）\"><a href=\"#UIView动画（首尾）\" class=\"headerlink\" title=\"UIView动画（首尾）\"></a>UIView动画（首尾）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。<br>常见方法：</p>\n<ul>\n<li><strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象</li>\n<li><strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位</li>\n<li><strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始</li>\n<li><strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now</li>\n<li><strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制</li>\n<li><strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数</li>\n<li><strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</li>\n<li><strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</li>\n</ul>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//首尾式动画</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"literal\">nil</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//执行动画</span></div><div class=\"line\">    <span class=\"comment\">//设置动画执行时间</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    <span class=\"comment\">//设置动画执行完毕调用的事件</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDidStopSelector:<span class=\"keyword\">@selector</span>(didStopAnimation)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> commitAnimations];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)didStopAnimation</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"UIView封装的动画与CALayer动画的对比\"><a href=\"#UIView封装的动画与CALayer动画的对比\" class=\"headerlink\" title=\"UIView封装的动画与CALayer动画的对比\"></a>UIView封装的动画与CALayer动画的对比</h4><p>使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>\n<p><strong>CALayer核心动画与UIView动画的区别</strong>：<br>UIView封装的动画，改变<code>view</code>或者<code>layer</code>执行完毕之后不会反弹。如果是通过<strong>CALayer核心动画</strong>改变<code>layer</code>的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</p>\n<h3 id=\"block动画\"><a href=\"#block动画\" class=\"headerlink\" title=\"block动画\"></a>block动画</h3><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li><strong>+(void)animateWithDuration:delay:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionWithView:duration:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionFromView:toView:duration:options:completion:</strong><br>属性简介：</li>\n</ul>\n<ol>\n<li>duration：动画的持续时间</li>\n<li>delay：动画延迟delay秒后开始</li>\n<li>options：动画的节奏控制/转场动画的类型(重复，转场等)</li>\n<li>animations：将改变视图属性的代码放在这个block中</li>\n<li>completion：动画结束后，会自动调用这个block</li>\n</ol>\n<p>前两个方法用起来好像没什么区别。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//block代码块动画</span></div><div class=\"line\">        [<span class=\"built_in\">UIView</span> transitionWithView:<span class=\"keyword\">self</span>.customView duration:<span class=\"number\">3.0</span> options:<span class=\"number\">0</span> animations:^&#123;</div><div class=\"line\">            <span class=\"comment\">//执行的动画</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画开始执行前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">            <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">            <span class=\"comment\">//动画执行完毕后的首位操作</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>( <span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">        &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>\n","excerpt":"<p>依旧是<a href=\"http://www.cnblogs.com/wendingding/tag/UI高级/\">文顶顶的ios开发UI篇</a>关于核心动画的内容。作为入门</p>\n<p><strong>核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。</strong></p>","more":"<h2 id=\"核心动画简介\"><a href=\"#核心动画简介\" class=\"headerlink\" title=\"核心动画简介\"></a>核心动画简介</h2><p>CAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。</p>\n<p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation<br>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>\n<p>常见属性：</p>\n<ul>\n<li>duration：动画的持续时间</li>\n<li>repeatCount：动画的重复次数</li>\n<li>repeatDuration：动画的重复时间</li>\n<li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li>\n<li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li>\n<li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li>\n<li>timingFunction：速度控制函数，控制动画运行的节奏</li>\n<li>delegate：动画代理</li>\n</ul>\n<h2 id=\"基础动画\"><a href=\"#基础动画\" class=\"headerlink\" title=\"基础动画\"></a>基础动画</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CABasicAnimation，是CApropertyAnimation的子类</p>\n<p>属性：</p>\n<ul>\n<li>fromValue：keyPath相应属性的初始值</li>\n<li>toValue：keyPath相应属性的结束值</li>\n</ul>\n<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>\n<p>如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但<strong>在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</strong>比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>)<span class=\"built_in\">CALayer</span> *myLayer;</div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建layer</span></div><div class=\"line\">    <span class=\"built_in\">CALayer</span> *myLayer=[<span class=\"built_in\">CALayer</span> layer];</div><div class=\"line\">    <span class=\"comment\">//设置layer的属性</span></div><div class=\"line\">    myLayer.bounds=<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">50</span>, <span class=\"number\">80</span>);</div><div class=\"line\">    myLayer.backgroundColor=[<span class=\"built_in\">UIColor</span> yellowColor].CGColor;</div><div class=\"line\">    myLayer.position=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>);</div><div class=\"line\">    myLayer.anchorPoint=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    myLayer.cornerRadius=<span class=\"number\">20</span>;</div><div class=\"line\">    <span class=\"comment\">//添加layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.view.layer addSublayer:myLayer];</div><div class=\"line\">    <span class=\"keyword\">self</span>.myLayer=myLayer;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//设置 平移 动画</span></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"comment\">//    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:&lt;#(NSString *)#&gt;]</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *anima=[<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么样的动画</span></div><div class=\"line\">    anima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置通过动画，将layer从哪儿移动到哪儿</span></div><div class=\"line\">    anima.fromValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>)];</div><div class=\"line\">    anima.toValue=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>)];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕之后不删除动画</span></div><div class=\"line\">    anima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    anima.fillMode=kCAFillModeForwards;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画到layer</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.myLayer addAnimation:anima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始执行动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//动画执行完毕，打印执行完毕后的position值</span></div><div class=\"line\">    <span class=\"built_in\">NSString</span> *str=<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.myLayer.position);</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"执行后：%@\"</span>,str);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中keypath的值决定产生什么动画</p>\n<ol>\n<li>position：执行平移动画</li>\n<li>bounds：执行缩放动画</li>\n<li>transform：执行旋转动画</li>\n</ol>\n<h2 id=\"关键帧动画\"><a href=\"#关键帧动画\" class=\"headerlink\" title=\"关键帧动画\"></a>关键帧动画</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>CAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>\n<p>属性：</p>\n<ul>\n<li>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>\n<li>path：可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</li>\n<li>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>\n</ul>\n<p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><h4 id=\"使用value\"><a href=\"#使用value\" class=\"headerlink\" title=\"使用value\"></a>使用value</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value1=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value2=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value3=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value4=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>)];</div><div class=\"line\">    <span class=\"built_in\">NSValue</span> *value5=[<span class=\"built_in\">NSValue</span> valueWithCGPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>)];</div><div class=\"line\">    keyAnima.values=@[value1,value2,value3,value4,value5];</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">4.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"使用path\"><a href=\"#使用path\" class=\"headerlink\" title=\"使用path\"></a>使用path</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    <span class=\"comment\">//平移</span></div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"position\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.1告诉系统要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//创建一条路径</span></div><div class=\"line\">    <span class=\"built_in\">CGMutablePathRef</span> path=<span class=\"built_in\">CGPathCreateMutable</span>();</div><div class=\"line\">    <span class=\"comment\">//设置一个圆的路径</span></div><div class=\"line\">    <span class=\"built_in\">CGPathAddEllipseInRect</span>(path, <span class=\"literal\">NULL</span>, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">150</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>));</div><div class=\"line\">    keyAnima.path=path;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//有create就一定要有release</span></div><div class=\"line\">    <span class=\"built_in\">CGPathRelease</span>(path);</div><div class=\"line\">    <span class=\"comment\">//1.2设置动画执行完毕后，不删除动画</span></div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置保存动画的最新状态</span></div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画执行的时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">5.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的节奏</span></div><div class=\"line\">    keyAnima.timingFunction=[<span class=\"built_in\">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置代理，开始—结束</span></div><div class=\"line\">    keyAnima.delegate=<span class=\"keyword\">self</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加核心动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer addAnimation:keyAnima forKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)stopOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"comment\">//停止self.customView.layer上名称标示为wendingding的动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.customView.layer removeAnimationForKey:<span class=\"string\">@\"wendingding\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStart:(<span class=\"built_in\">CAAnimation</span> *)anim</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"开始动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)animationDidStop:(<span class=\"built_in\">CAAnimation</span> *)anim finished:(<span class=\"built_in\">BOOL</span>)flag</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"结束动画\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>点击停止动画，程序内部会调用  <code>[self.customView.layer removeAnimationForKey:@&quot;wendingding&quot;];</code>停止<code>self.customView.layer</code>上名称标示为wendingding的动画。</p>\n<h4 id=\"图标抖动\"><a href=\"#图标抖动\" class=\"headerlink\" title=\"图标抖动\"></a>图标抖动</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#define angle2Radian(angle)  ((angle)/180.0*M_PI)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CAKeyframeAnimation</span> *keyAnima=[<span class=\"built_in\">CAKeyframeAnimation</span> animation];</div><div class=\"line\">    keyAnima.keyPath=<span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画时间</span></div><div class=\"line\">    keyAnima.duration=<span class=\"number\">0.1</span>;</div><div class=\"line\">    <span class=\"comment\">//设置图标抖动弧度</span></div><div class=\"line\">    <span class=\"comment\">//把度数转换为弧度  度数/180*M_PI</span></div><div class=\"line\">    keyAnima.values=@[@(-angle2Radian(<span class=\"number\">4</span>)),@(angle2Radian(<span class=\"number\">4</span>)),@(-angle2Radian(<span class=\"number\">4</span>))];</div><div class=\"line\">    <span class=\"comment\">//设置动画的重复次数(设置为最大值)</span></div><div class=\"line\">    keyAnima.repeatCount=MAXFLOAT;</div><div class=\"line\">    </div><div class=\"line\">    keyAnima.fillMode=kCAFillModeForwards;</div><div class=\"line\">    keyAnima.removedOnCompletion=<span class=\"literal\">NO</span>;</div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:keyAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<p>其中，<code>keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];</code>表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。</p>\n<p><strong>@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象</strong></p>\n<h2 id=\"转场动画和组动画\"><a href=\"#转场动画和组动画\" class=\"headerlink\" title=\"转场动画和组动画\"></a>转场动画和组动画</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>CATransition用于做转场动画<br>属性：</p>\n<ul>\n<li>type：动画过渡类型</li>\n<li>subtype：动画过渡方向</li>\n<li>startProgress：动画起点(在整体动画的百分比)</li>\n<li>endProgress：动画终点(在整体动画的百分比)</li>\n</ul>\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"keyword\">int</span> index;</div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIImageView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)preOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index--;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&lt;<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">7</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    <span class=\"comment\">//告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//设置动画的过度方向（向左）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromLeft;</div><div class=\"line\">    <span class=\"comment\">//设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//下一张</span></div><div class=\"line\">- (<span class=\"keyword\">IBAction</span>)nextOnClick:(<span class=\"built_in\">UIButton</span> *)sender &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.index++;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.index&gt;<span class=\"number\">7</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.index=<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.iconView.image=[<span class=\"built_in\">UIImage</span> imageNamed: [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%d.jpg\"</span>,<span class=\"keyword\">self</span>.index]];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.创建核心动画</span></div><div class=\"line\">    <span class=\"built_in\">CATransition</span> *ca=[<span class=\"built_in\">CATransition</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//1.1告诉要执行什么动画</span></div><div class=\"line\">    <span class=\"comment\">//1.2设置过度效果</span></div><div class=\"line\">    ca.type=<span class=\"string\">@\"cube\"</span>;</div><div class=\"line\">    <span class=\"comment\">//1.3设置动画的过度方向（向右）</span></div><div class=\"line\">    ca.subtype=kCATransitionFromRight;</div><div class=\"line\">    <span class=\"comment\">//1.4设置动画的时间</span></div><div class=\"line\">    ca.duration=<span class=\"number\">2.0</span>;</div><div class=\"line\">    <span class=\"comment\">//1.5设置动画的起点</span></div><div class=\"line\">    ca.startProgress=<span class=\"number\">0.5</span>;</div><div class=\"line\">    <span class=\"comment\">//1.6设置动画的终点</span></div><div class=\"line\"><span class=\"comment\">//    ca.endProgress=0.5;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//2.添加动画</span></div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:ca forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h3 id=\"组动画\"><a href=\"#组动画\" class=\"headerlink\" title=\"组动画\"></a>组动画</h3><p>将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.</p>\n<h3 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *iconView;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NJViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123;</div><div class=\"line\">    <span class=\"comment\">// 平移动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a1 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a1.keyPath = <span class=\"string\">@\"transform.translation.y\"</span>;</div><div class=\"line\">    a1.toValue = @(<span class=\"number\">100</span>);</div><div class=\"line\">    <span class=\"comment\">// 缩放动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a2 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a2.keyPath = <span class=\"string\">@\"transform.scale\"</span>;</div><div class=\"line\">    a2.toValue = @(<span class=\"number\">0.0</span>);</div><div class=\"line\">    <span class=\"comment\">// 旋转动画</span></div><div class=\"line\">    <span class=\"built_in\">CABasicAnimation</span> *a3 = [<span class=\"built_in\">CABasicAnimation</span> animation];</div><div class=\"line\">    a3.keyPath = <span class=\"string\">@\"transform.rotation\"</span>;</div><div class=\"line\">    a3.toValue = @(M_PI_2);</div><div class=\"line\">    <span class=\"comment\">// 组动画</span></div><div class=\"line\">    <span class=\"built_in\">CAAnimationGroup</span> *groupAnima = [<span class=\"built_in\">CAAnimationGroup</span> animation];</div><div class=\"line\">    </div><div class=\"line\">    groupAnima.animations = @[a1, a2, a3];</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//设置组动画的时间</span></div><div class=\"line\">    groupAnima.duration = <span class=\"number\">2</span>;</div><div class=\"line\">    groupAnima.fillMode = kCAFillModeForwards;</div><div class=\"line\">    groupAnima.removedOnCompletion = <span class=\"literal\">NO</span>;</div><div class=\"line\">    </div><div class=\"line\">    [<span class=\"keyword\">self</span>.iconView.layer addAnimation:groupAnima forKey:<span class=\"literal\">nil</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h2 id=\"UIView封装动画\"><a href=\"#UIView封装动画\" class=\"headerlink\" title=\"UIView封装动画\"></a>UIView封装动画</h2><h3 id=\"UIView动画（首尾）\"><a href=\"#UIView动画（首尾）\" class=\"headerlink\" title=\"UIView动画（首尾）\"></a>UIView动画（首尾）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。<br>常见方法：</p>\n<ul>\n<li><strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象</li>\n<li><strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>\n<li><strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位</li>\n<li><strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始</li>\n<li><strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now</li>\n<li><strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制</li>\n<li><strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数</li>\n<li><strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</li>\n<li><strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</li>\n</ul>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"YYViewController.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">YYViewController</span> ()</span></div><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">weak</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">IBOutlet</span> <span class=\"built_in\">UIView</span> *customView;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">YYViewController</span></span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//首尾式动画</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> beginAnimations:<span class=\"literal\">nil</span> context:<span class=\"literal\">nil</span>];</div><div class=\"line\">    <span class=\"comment\">//执行动画</span></div><div class=\"line\">    <span class=\"comment\">//设置动画执行时间</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDuration:<span class=\"number\">2.0</span>];</div><div class=\"line\">    <span class=\"comment\">//设置代理</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDelegate:<span class=\"keyword\">self</span>];</div><div class=\"line\">    <span class=\"comment\">//设置动画执行完毕调用的事件</span></div><div class=\"line\">    [<span class=\"built_in\">UIView</span> setAnimationDidStopSelector:<span class=\"keyword\">@selector</span>(didStopAnimation)];</div><div class=\"line\">    <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">    [<span class=\"built_in\">UIView</span> commitAnimations];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(<span class=\"keyword\">void</span>)didStopAnimation</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">    <span class=\"comment\">//打印动画块的位置</span></div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行之后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<h4 id=\"UIView封装的动画与CALayer动画的对比\"><a href=\"#UIView封装的动画与CALayer动画的对比\" class=\"headerlink\" title=\"UIView封装的动画与CALayer动画的对比\"></a>UIView封装的动画与CALayer动画的对比</h4><p>使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>\n<p><strong>CALayer核心动画与UIView动画的区别</strong>：<br>UIView封装的动画，改变<code>view</code>或者<code>layer</code>执行完毕之后不会反弹。如果是通过<strong>CALayer核心动画</strong>改变<code>layer</code>的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</p>\n<h3 id=\"block动画\"><a href=\"#block动画\" class=\"headerlink\" title=\"block动画\"></a>block动画</h3><h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li><strong>+(void)animateWithDuration:delay:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionWithView:duration:options:animations:completion:</strong></li>\n<li><strong>+(void)transitionFromView:toView:duration:options:completion:</strong><br>属性简介：</li>\n</ul>\n<ol>\n<li>duration：动画的持续时间</li>\n<li>delay：动画延迟delay秒后开始</li>\n<li>options：动画的节奏控制/转场动画的类型(重复，转场等)</li>\n<li>animations：将改变视图属性的代码放在这个block中</li>\n<li>completion：动画结束后，会自动调用这个block</li>\n</ol>\n<p>前两个方法用起来好像没什么区别。</p>\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//block代码块动画</span></div><div class=\"line\">        [<span class=\"built_in\">UIView</span> transitionWithView:<span class=\"keyword\">self</span>.customView duration:<span class=\"number\">3.0</span> options:<span class=\"number\">0</span> animations:^&#123;</div><div class=\"line\">            <span class=\"comment\">//执行的动画</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画开始执行前的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>(<span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">            <span class=\"keyword\">self</span>.customView.center=<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">200</span>, <span class=\"number\">300</span>);</div><div class=\"line\">        &#125; completion:^(<span class=\"built_in\">BOOL</span> finished) &#123;</div><div class=\"line\">            <span class=\"comment\">//动画执行完毕后的首位操作</span></div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕\"</span>);</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"动画执行完毕后的位置：%@\"</span>,<span class=\"built_in\">NSStringFromCGPoint</span>( <span class=\"keyword\">self</span>.customView.center));</div><div class=\"line\">        &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Demo详见CALayer_Transform</p>\n</blockquote>"},{"title":"使用xib设置view的border的宽度和颜色","date":"2016-08-10T06:07:12.000Z","_content":"\n使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。\n\n<!--more-->\n\n写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。\n可以使用User Defined Runtime Attributes在xib中进行设置。\n\n对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：\n```objc\nlayer.cornerRadius\t\t\t\tNumber\nlayer.borderWidth\t\t\t\tNumber\nlayer.borderColor\t\t\t\tColor\n```\n\n但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。\n\n需要使用category定义一个CALayer的方法\n```objc\n#import \"CALayer+Additions.h\"\n#import <UIKit/UIKit.h>\n@implementation CALayer (Additions)\n- (void)setBorderColorFromUIColor:(UIColor *)color{\n    self.borderColor = color.CGColor;\n}\n@end\n```\n通过这个方法可以把Color设置为borderColor。\nxib中的key需要改成此方法名\n**layer.borderColorFromUIColor**\n\n在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。\n\n设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。\n","source":"_posts/xib设置border.md","raw":"title: 使用xib设置view的border的宽度和颜色\ndate: 2016/8/10 14:07:12  \ncategories: IOS\ntags: \n\t- Runtime\n\t- UI\n\t\n---\n\n使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。\n\n<!--more-->\n\n写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。\n可以使用User Defined Runtime Attributes在xib中进行设置。\n\n对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：\n```objc\nlayer.cornerRadius\t\t\t\tNumber\nlayer.borderWidth\t\t\t\tNumber\nlayer.borderColor\t\t\t\tColor\n```\n\n但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。\n\n需要使用category定义一个CALayer的方法\n```objc\n#import \"CALayer+Additions.h\"\n#import <UIKit/UIKit.h>\n@implementation CALayer (Additions)\n- (void)setBorderColorFromUIColor:(UIColor *)color{\n    self.borderColor = color.CGColor;\n}\n@end\n```\n通过这个方法可以把Color设置为borderColor。\nxib中的key需要改成此方法名\n**layer.borderColorFromUIColor**\n\n在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。\n\n设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。\n","slug":"xib设置border","published":1,"updated":"2016-09-23T05:43:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyr003wrgru7kzov6z7","content":"<p>使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。</p>\n<a id=\"more\"></a>\n<p>写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。<br>可以使用User Defined Runtime Attributes在xib中进行设置。</p>\n<p>对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layer.cornerRadius\t\t\t\tNumber</div><div class=\"line\">layer.borderWidth\t\t\t\tNumber</div><div class=\"line\">layer.borderColor\t\t\t\tColor</div></pre></td></tr></table></figure></p>\n<p>但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。</p>\n<p>需要使用category定义一个CALayer的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CALayer+Additions.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CALayer</span> (<span class=\"title\">Additions</span>)</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setBorderColorFromUIColor:(<span class=\"built_in\">UIColor</span> *)color&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.borderColor = color.CGColor;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>通过这个方法可以把Color设置为borderColor。<br>xib中的key需要改成此方法名<br><strong>layer.borderColorFromUIColor</strong></p>\n<p>在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。</p>\n<p>设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。</p>\n","excerpt":"<p>使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。</p>","more":"<p>写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。<br>可以使用User Defined Runtime Attributes在xib中进行设置。</p>\n<p>对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">layer.cornerRadius\t\t\t\tNumber</div><div class=\"line\">layer.borderWidth\t\t\t\tNumber</div><div class=\"line\">layer.borderColor\t\t\t\tColor</div></pre></td></tr></table></figure></p>\n<p>但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。</p>\n<p>需要使用category定义一个CALayer的方法<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"CALayer+Additions.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">CALayer</span> (<span class=\"title\">Additions</span>)</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)setBorderColorFromUIColor:(<span class=\"built_in\">UIColor</span> *)color&#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.borderColor = color.CGColor;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure></p>\n<p>通过这个方法可以把Color设置为borderColor。<br>xib中的key需要改成此方法名<br><strong>layer.borderColorFromUIColor</strong></p>\n<p>在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。</p>\n<p>设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。</p>"},{"title":"图解TCP-IP学习笔记","date":"2016-07-31T08:07:12.000Z","_content":"\n本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙\n<!--more-->\n## 网络基础知识\n### 协议分层\nISO制定了国际标准OSI，对通信系统进行了标准化。\n- **应用层**：针对特定应用的协议。\n- **表示层**：设备固有数据格式和网络标准设局格式的转换。\n- **会话层**：通信管理，负责建立和断开通信连接。\n- **传输层**：管理两个节点之间的数据传输。\n- **网络层**：地址管理和路由选择。\n- **数据链路层**：互联设备间传送和识别数据帧。\n- **物理层**：01代表高低平的互换\n\n### 电路交换与分组交换\n- **电路交换**：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。\n- **分组交换**：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。\n\n### 地址\n- **MAC地址**：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。\n- **IP地址**：IP地址由网络号和主机号两部分组成。具有层次性。\n\nMAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。\n\n### 网络的构成元素\n- **网卡**：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。\n- **中继器**：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。\n- **网桥**：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。\n- **路由器/3层交换机**：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。\n- **4-7层交换机**：负责处理OSI模型中从传输层到应用层的数据。\n- **网关**：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。\n\n## TCP/IP基础知识\n### TCP/IP模型\n- **硬件(物理层)**\n- **网络接口层(数据链路层)**\n- **互联网层(网络层)**\n + IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。\n + ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的\n + ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。\n- **传输层**\n + TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。\n + UDP：面向无连接的传输层协议。\n- **应用层(会话层以上的分层)**\n + WWW\n + 电子邮件(E-Mail)\n + 文件传输(FTP)\n + 远程登录(TELNET,SSH)\n + 网络管理(SNMP)\n \n## 数据链路\n### 数据链路的作用\n数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。\n\n数据链路的**段**是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。\n\n网络的连接和构成形态成为**网络拓扑**。\n\n### 数据链路相关技术\n**共享介质型网络**：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。\n\n**非共享介质网络**：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。\n\n以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。\n\n### 以太网\n众多数据链路中最著名，使用最广发的是以太网。\n\n## IP协议\n### IP即网络协议\n网络层的下一层——数据链路层主要作用是在互连**同一种数据链路节点**之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。\n\n配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。\n\n**网络层与数据链路层关系**：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。\n\n### IP基础知识\nIP大致分为三大模块，IP寻址，路由，IP分包和组包。\n\n为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。\n\n路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。\n\nIP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。\n\n### IP地址的基础知识\nIP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n\nIP地址的分类：\n1. A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识\n2. B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识\n3. C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识\n4. D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。\n\n**广播地址**用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。\n\n**多播**用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。\n\n网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做\"**子网掩码**\"的识别码通过子网网络地址细分出比ABC更小粒度的网络。  \n子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.\n\n由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于**私有IP**，在此之外的IP称为**全局IP**。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。\n\n对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。\n\n### 路由控制\n仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是**路由控制表**。\n\n路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。\n\n## IP协议相关\n### DNS\nDNS将主机名字符串转换为具体的IP地址。\n\n### ARP\n只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。\n\nARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。\n\n从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过**ARP**从IP地址获得MAC地址，实现链路内的IP通信。\n\n根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/图解TCP_IP.md","raw":"\ntitle: 图解TCP-IP学习笔记\ndate: 2016/7/31 16:07:12  \ncategories: 计算机\ntags:\n\t- 学习笔记\n\n---\n\n本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙\n<!--more-->\n## 网络基础知识\n### 协议分层\nISO制定了国际标准OSI，对通信系统进行了标准化。\n- **应用层**：针对特定应用的协议。\n- **表示层**：设备固有数据格式和网络标准设局格式的转换。\n- **会话层**：通信管理，负责建立和断开通信连接。\n- **传输层**：管理两个节点之间的数据传输。\n- **网络层**：地址管理和路由选择。\n- **数据链路层**：互联设备间传送和识别数据帧。\n- **物理层**：01代表高低平的互换\n\n### 电路交换与分组交换\n- **电路交换**：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。\n- **分组交换**：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。\n\n### 地址\n- **MAC地址**：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。\n- **IP地址**：IP地址由网络号和主机号两部分组成。具有层次性。\n\nMAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。\n\n### 网络的构成元素\n- **网卡**：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。\n- **中继器**：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。\n- **网桥**：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。\n- **路由器/3层交换机**：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。\n- **4-7层交换机**：负责处理OSI模型中从传输层到应用层的数据。\n- **网关**：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。\n\n## TCP/IP基础知识\n### TCP/IP模型\n- **硬件(物理层)**\n- **网络接口层(数据链路层)**\n- **互联网层(网络层)**\n + IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。\n + ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的\n + ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。\n- **传输层**\n + TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。\n + UDP：面向无连接的传输层协议。\n- **应用层(会话层以上的分层)**\n + WWW\n + 电子邮件(E-Mail)\n + 文件传输(FTP)\n + 远程登录(TELNET,SSH)\n + 网络管理(SNMP)\n \n## 数据链路\n### 数据链路的作用\n数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。\n\n数据链路的**段**是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。\n\n网络的连接和构成形态成为**网络拓扑**。\n\n### 数据链路相关技术\n**共享介质型网络**：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。\n\n**非共享介质网络**：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。\n\n以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。\n\n### 以太网\n众多数据链路中最著名，使用最广发的是以太网。\n\n## IP协议\n### IP即网络协议\n网络层的下一层——数据链路层主要作用是在互连**同一种数据链路节点**之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。\n\n配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。\n\n**网络层与数据链路层关系**：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。\n\n### IP基础知识\nIP大致分为三大模块，IP寻址，路由，IP分包和组包。\n\n为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。\n\n路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。\n\nIP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。\n\n### IP地址的基础知识\nIP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n\nIP地址的分类：\n1. A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识\n2. B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识\n3. C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识\n4. D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。\n\n**广播地址**用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。\n\n**多播**用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。\n\n网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做\"**子网掩码**\"的识别码通过子网网络地址细分出比ABC更小粒度的网络。  \n子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.\n\n由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于**私有IP**，在此之外的IP称为**全局IP**。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。\n\n对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。\n\n### 路由控制\n仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是**路由控制表**。\n\n路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。\n\n## IP协议相关\n### DNS\nDNS将主机名字符串转换为具体的IP地址。\n\n### ARP\n只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。\n\nARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。\n\n从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过**ARP**从IP地址获得MAC地址，实现链路内的IP通信。\n\n根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。\n\n\n\n\n\n\n\n\n\n\n","slug":"图解TCP_IP","published":1,"updated":"2016-09-23T05:53:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyu003zrgruqsw9puih","content":"<p>本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙<br><a id=\"more\"></a></p>\n<h2 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h2><h3 id=\"协议分层\"><a href=\"#协议分层\" class=\"headerlink\" title=\"协议分层\"></a>协议分层</h3><p>ISO制定了国际标准OSI，对通信系统进行了标准化。</p>\n<ul>\n<li><strong>应用层</strong>：针对特定应用的协议。</li>\n<li><strong>表示层</strong>：设备固有数据格式和网络标准设局格式的转换。</li>\n<li><strong>会话层</strong>：通信管理，负责建立和断开通信连接。</li>\n<li><strong>传输层</strong>：管理两个节点之间的数据传输。</li>\n<li><strong>网络层</strong>：地址管理和路由选择。</li>\n<li><strong>数据链路层</strong>：互联设备间传送和识别数据帧。</li>\n<li><strong>物理层</strong>：01代表高低平的互换</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><strong>电路交换</strong>：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。</li>\n<li><strong>分组交换</strong>：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。</li>\n</ul>\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><ul>\n<li><strong>MAC地址</strong>：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。</li>\n<li><strong>IP地址</strong>：IP地址由网络号和主机号两部分组成。具有层次性。</li>\n</ul>\n<p>MAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。</p>\n<h3 id=\"网络的构成元素\"><a href=\"#网络的构成元素\" class=\"headerlink\" title=\"网络的构成元素\"></a>网络的构成元素</h3><ul>\n<li><strong>网卡</strong>：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。</li>\n<li><strong>中继器</strong>：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。</li>\n<li><strong>网桥</strong>：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。</li>\n<li><strong>路由器/3层交换机</strong>：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。</li>\n<li><strong>4-7层交换机</strong>：负责处理OSI模型中从传输层到应用层的数据。</li>\n<li><strong>网关</strong>：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。</li>\n</ul>\n<h2 id=\"TCP-IP基础知识\"><a href=\"#TCP-IP基础知识\" class=\"headerlink\" title=\"TCP/IP基础知识\"></a>TCP/IP基础知识</h2><h3 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP/IP模型\"></a>TCP/IP模型</h3><ul>\n<li><strong>硬件(物理层)</strong></li>\n<li><strong>网络接口层(数据链路层)</strong></li>\n<li><strong>互联网层(网络层)</strong><ul>\n<li>IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。</li>\n<li>ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的</li>\n<li>ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。</li>\n</ul>\n</li>\n<li><strong>传输层</strong><ul>\n<li>TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。</li>\n<li>UDP：面向无连接的传输层协议。</li>\n</ul>\n</li>\n<li><strong>应用层(会话层以上的分层)</strong><ul>\n<li>WWW</li>\n<li>电子邮件(E-Mail)</li>\n<li>文件传输(FTP)</li>\n<li>远程登录(TELNET,SSH)</li>\n<li>网络管理(SNMP)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据链路\"><a href=\"#数据链路\" class=\"headerlink\" title=\"数据链路\"></a>数据链路</h2><h3 id=\"数据链路的作用\"><a href=\"#数据链路的作用\" class=\"headerlink\" title=\"数据链路的作用\"></a>数据链路的作用</h3><p>数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。</p>\n<p>数据链路的<strong>段</strong>是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。</p>\n<p>网络的连接和构成形态成为<strong>网络拓扑</strong>。</p>\n<h3 id=\"数据链路相关技术\"><a href=\"#数据链路相关技术\" class=\"headerlink\" title=\"数据链路相关技术\"></a>数据链路相关技术</h3><p><strong>共享介质型网络</strong>：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。</p>\n<p><strong>非共享介质网络</strong>：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。</p>\n<p>以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。</p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>众多数据链路中最著名，使用最广发的是以太网。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><h3 id=\"IP即网络协议\"><a href=\"#IP即网络协议\" class=\"headerlink\" title=\"IP即网络协议\"></a>IP即网络协议</h3><p>网络层的下一层——数据链路层主要作用是在互连<strong>同一种数据链路节点</strong>之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。</p>\n<p>配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。</p>\n<p><strong>网络层与数据链路层关系</strong>：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。</p>\n<h3 id=\"IP基础知识\"><a href=\"#IP基础知识\" class=\"headerlink\" title=\"IP基础知识\"></a>IP基础知识</h3><p>IP大致分为三大模块，IP寻址，路由，IP分包和组包。</p>\n<p>为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。</p>\n<p>路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。</p>\n<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。</p>\n<h3 id=\"IP地址的基础知识\"><a href=\"#IP地址的基础知识\" class=\"headerlink\" title=\"IP地址的基础知识\"></a>IP地址的基础知识</h3><p>IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p>\n<p>IP地址的分类：</p>\n<ol>\n<li>A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识</li>\n<li>B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识</li>\n<li>C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识</li>\n<li>D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。</li>\n</ol>\n<p><strong>广播地址</strong>用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。</p>\n<p><strong>多播</strong>用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。</p>\n<p>网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”<strong>子网掩码</strong>“的识别码通过子网网络地址细分出比ABC更小粒度的网络。<br>子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.</p>\n<p>由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于<strong>私有IP</strong>，在此之外的IP称为<strong>全局IP</strong>。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。</p>\n<p>对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。</p>\n<h3 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h3><p>仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。</p>\n<p>路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p>\n<h2 id=\"IP协议相关\"><a href=\"#IP协议相关\" class=\"headerlink\" title=\"IP协议相关\"></a>IP协议相关</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS将主机名字符串转换为具体的IP地址。</p>\n<h3 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h3><p>只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。</p>\n<p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p>\n<p>从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过<strong>ARP</strong>从IP地址获得MAC地址，实现链路内的IP通信。</p>\n<p>根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>\n","excerpt":"<p>本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙<br>","more":"</p>\n<h2 id=\"网络基础知识\"><a href=\"#网络基础知识\" class=\"headerlink\" title=\"网络基础知识\"></a>网络基础知识</h2><h3 id=\"协议分层\"><a href=\"#协议分层\" class=\"headerlink\" title=\"协议分层\"></a>协议分层</h3><p>ISO制定了国际标准OSI，对通信系统进行了标准化。</p>\n<ul>\n<li><strong>应用层</strong>：针对特定应用的协议。</li>\n<li><strong>表示层</strong>：设备固有数据格式和网络标准设局格式的转换。</li>\n<li><strong>会话层</strong>：通信管理，负责建立和断开通信连接。</li>\n<li><strong>传输层</strong>：管理两个节点之间的数据传输。</li>\n<li><strong>网络层</strong>：地址管理和路由选择。</li>\n<li><strong>数据链路层</strong>：互联设备间传送和识别数据帧。</li>\n<li><strong>物理层</strong>：01代表高低平的互换</li>\n</ul>\n<h3 id=\"电路交换与分组交换\"><a href=\"#电路交换与分组交换\" class=\"headerlink\" title=\"电路交换与分组交换\"></a>电路交换与分组交换</h3><ul>\n<li><strong>电路交换</strong>：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。</li>\n<li><strong>分组交换</strong>：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。</li>\n</ul>\n<h3 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h3><ul>\n<li><strong>MAC地址</strong>：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。</li>\n<li><strong>IP地址</strong>：IP地址由网络号和主机号两部分组成。具有层次性。</li>\n</ul>\n<p>MAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。</p>\n<h3 id=\"网络的构成元素\"><a href=\"#网络的构成元素\" class=\"headerlink\" title=\"网络的构成元素\"></a>网络的构成元素</h3><ul>\n<li><strong>网卡</strong>：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。</li>\n<li><strong>中继器</strong>：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。</li>\n<li><strong>网桥</strong>：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。</li>\n<li><strong>路由器/3层交换机</strong>：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。</li>\n<li><strong>4-7层交换机</strong>：负责处理OSI模型中从传输层到应用层的数据。</li>\n<li><strong>网关</strong>：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。</li>\n</ul>\n<h2 id=\"TCP-IP基础知识\"><a href=\"#TCP-IP基础知识\" class=\"headerlink\" title=\"TCP/IP基础知识\"></a>TCP/IP基础知识</h2><h3 id=\"TCP-IP模型\"><a href=\"#TCP-IP模型\" class=\"headerlink\" title=\"TCP/IP模型\"></a>TCP/IP模型</h3><ul>\n<li><strong>硬件(物理层)</strong></li>\n<li><strong>网络接口层(数据链路层)</strong></li>\n<li><strong>互联网层(网络层)</strong><ul>\n<li>IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。</li>\n<li>ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的</li>\n<li>ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。</li>\n</ul>\n</li>\n<li><strong>传输层</strong><ul>\n<li>TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。</li>\n<li>UDP：面向无连接的传输层协议。</li>\n</ul>\n</li>\n<li><strong>应用层(会话层以上的分层)</strong><ul>\n<li>WWW</li>\n<li>电子邮件(E-Mail)</li>\n<li>文件传输(FTP)</li>\n<li>远程登录(TELNET,SSH)</li>\n<li>网络管理(SNMP)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据链路\"><a href=\"#数据链路\" class=\"headerlink\" title=\"数据链路\"></a>数据链路</h2><h3 id=\"数据链路的作用\"><a href=\"#数据链路的作用\" class=\"headerlink\" title=\"数据链路的作用\"></a>数据链路的作用</h3><p>数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。</p>\n<p>数据链路的<strong>段</strong>是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。</p>\n<p>网络的连接和构成形态成为<strong>网络拓扑</strong>。</p>\n<h3 id=\"数据链路相关技术\"><a href=\"#数据链路相关技术\" class=\"headerlink\" title=\"数据链路相关技术\"></a>数据链路相关技术</h3><p><strong>共享介质型网络</strong>：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。</p>\n<p><strong>非共享介质网络</strong>：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。</p>\n<p>以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。</p>\n<h3 id=\"以太网\"><a href=\"#以太网\" class=\"headerlink\" title=\"以太网\"></a>以太网</h3><p>众多数据链路中最著名，使用最广发的是以太网。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><h3 id=\"IP即网络协议\"><a href=\"#IP即网络协议\" class=\"headerlink\" title=\"IP即网络协议\"></a>IP即网络协议</h3><p>网络层的下一层——数据链路层主要作用是在互连<strong>同一种数据链路节点</strong>之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。</p>\n<p>配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。</p>\n<p><strong>网络层与数据链路层关系</strong>：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。</p>\n<h3 id=\"IP基础知识\"><a href=\"#IP基础知识\" class=\"headerlink\" title=\"IP基础知识\"></a>IP基础知识</h3><p>IP大致分为三大模块，IP寻址，路由，IP分包和组包。</p>\n<p>为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。</p>\n<p>路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。</p>\n<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。</p>\n<h3 id=\"IP地址的基础知识\"><a href=\"#IP地址的基础知识\" class=\"headerlink\" title=\"IP地址的基础知识\"></a>IP地址的基础知识</h3><p>IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p>\n<p>IP地址的分类：</p>\n<ol>\n<li>A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识</li>\n<li>B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识</li>\n<li>C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识</li>\n<li>D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。</li>\n</ol>\n<p><strong>广播地址</strong>用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。</p>\n<p><strong>多播</strong>用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。</p>\n<p>网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”<strong>子网掩码</strong>“的识别码通过子网网络地址细分出比ABC更小粒度的网络。<br>子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.</p>\n<p>由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于<strong>私有IP</strong>，在此之外的IP称为<strong>全局IP</strong>。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。</p>\n<p>对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。</p>\n<h3 id=\"路由控制\"><a href=\"#路由控制\" class=\"headerlink\" title=\"路由控制\"></a>路由控制</h3><p>仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。</p>\n<p>路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p>\n<h2 id=\"IP协议相关\"><a href=\"#IP协议相关\" class=\"headerlink\" title=\"IP协议相关\"></a>IP协议相关</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>DNS将主机名字符串转换为具体的IP地址。</p>\n<h3 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h3><p>只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。</p>\n<p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p>\n<p>从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过<strong>ARP</strong>从IP地址获得MAC地址，实现链路内的IP通信。</p>\n<p>根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>"},{"title":"删除Storyboard","date":"2016-08-11T06:07:12.000Z","_content":"\nxcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。\n<!--more-->\n\nstoryboard的入口在**targets->General->Deployment Info->Main Interface**，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。\n\n删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。\n- 点击placeholders下的File's Owner将Custom Class的Class设置为viewcController的名字。\n- 将File's Owner的view和xib的View进行关联。\n\n使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\tViewController *uv = [[ViewController alloc] initWithNibName:@\"ViewController\" bundle:nil];\n\t[self.window setRootViewController:uv];\n\t[self.window makeKeyAndVisible];\n\treturn YES;\n}\n```\n注意：这里的`ViewController`是你自定义的ViewController。\n\n如果要使用NavigationController需要写成这样:\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n   \tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    ViewController *vc = [[ViewController alloc]initWithNibName:@\"ViewController\" bundle:nil];\n    vc.title = @\"AutoHeightTableView\";\n    UINavigationController *uv = [[UINavigationController alloc] initWithRootViewController:vc];\n    [self.window setRootViewController:uv];\n    [self.window makeKeyAndVisible];\n    return YES;\n}\n```\n\n至此，app就可以显示新建的xib文件的布局了\n","source":"_posts/删除storyboard.md","raw":"title: 删除Storyboard\ndate: 2016/8/11 14:07:12  \ncategories: IOS \ntags: \n\t- UI\n\t- Xcode\n\t\n\n---\n\nxcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。\n<!--more-->\n\nstoryboard的入口在**targets->General->Deployment Info->Main Interface**，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。\n\n删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。\n- 点击placeholders下的File's Owner将Custom Class的Class设置为viewcController的名字。\n- 将File's Owner的view和xib的View进行关联。\n\n使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n\tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\tViewController *uv = [[ViewController alloc] initWithNibName:@\"ViewController\" bundle:nil];\n\t[self.window setRootViewController:uv];\n\t[self.window makeKeyAndVisible];\n\treturn YES;\n}\n```\n注意：这里的`ViewController`是你自定义的ViewController。\n\n如果要使用NavigationController需要写成这样:\n```objc\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n   \tself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n    ViewController *vc = [[ViewController alloc]initWithNibName:@\"ViewController\" bundle:nil];\n    vc.title = @\"AutoHeightTableView\";\n    UINavigationController *uv = [[UINavigationController alloc] initWithRootViewController:vc];\n    [self.window setRootViewController:uv];\n    [self.window makeKeyAndVisible];\n    return YES;\n}\n```\n\n至此，app就可以显示新建的xib文件的布局了\n","slug":"删除storyboard","published":1,"updated":"2016-09-23T05:47:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyy0042rgrugv9lewnf","content":"<p>xcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。<br><a id=\"more\"></a></p>\n<p>storyboard的入口在<strong>targets-&gt;General-&gt;Deployment Info-&gt;Main Interface</strong>，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。</p>\n<p>删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。</p>\n<ul>\n<li>点击placeholders下的File’s Owner将Custom Class的Class设置为viewcController的名字。</li>\n<li>将File’s Owner的view和xib的View进行关联。</li>\n</ul>\n<p>使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">\t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">\tViewController *uv = [[ViewController alloc] initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：这里的<code>ViewController</code>是你自定义的ViewController。</p>\n<p>如果要使用NavigationController需要写成这样:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></div><div class=\"line\">   \t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">    ViewController *vc = [[ViewController alloc]initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    vc.title = <span class=\"string\">@\"AutoHeightTableView\"</span>;</div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *uv = [[<span class=\"built_in\">UINavigationController</span> alloc] initWithRootViewController:vc];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，app就可以显示新建的xib文件的布局了</p>\n","excerpt":"<p>xcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。<br>","more":"</p>\n<p>storyboard的入口在<strong>targets-&gt;General-&gt;Deployment Info-&gt;Main Interface</strong>，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。</p>\n<p>删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。</p>\n<ul>\n<li>点击placeholders下的File’s Owner将Custom Class的Class设置为viewcController的名字。</li>\n<li>将File’s Owner的view和xib的View进行关联。</li>\n</ul>\n<p>使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">\t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">\tViewController *uv = [[ViewController alloc] initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">\t[<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意：这里的<code>ViewController</code>是你自定义的ViewController。</p>\n<p>如果要使用NavigationController需要写成这样:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</div><div class=\"line\">    <span class=\"comment\">// Override point for customization after application launch.</span></div><div class=\"line\">   \t<span class=\"keyword\">self</span>.window = [[<span class=\"built_in\">UIWindow</span> alloc] initWithFrame:[[<span class=\"built_in\">UIScreen</span> mainScreen] bounds]];</div><div class=\"line\">    ViewController *vc = [[ViewController alloc]initWithNibName:<span class=\"string\">@\"ViewController\"</span> bundle:<span class=\"literal\">nil</span>];</div><div class=\"line\">    vc.title = <span class=\"string\">@\"AutoHeightTableView\"</span>;</div><div class=\"line\">    <span class=\"built_in\">UINavigationController</span> *uv = [[<span class=\"built_in\">UINavigationController</span> alloc] initWithRootViewController:vc];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window setRootViewController:uv];</div><div class=\"line\">    [<span class=\"keyword\">self</span>.window makeKeyAndVisible];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此，app就可以显示新建的xib文件的布局了</p>"},{"title":"Git技巧","date":"2016-08-27T06:07:12.000Z","_content":"\n虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。\n\n<!--more-->\n\n## git rm\nios中pod的第三方库经常会被`gitignore`掉，让使用者自己下载。\n\n想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.\n\n\n\n### 使用命令行\n可以使用`git rm --cached file`\nGit 将不再跟踪此文件，尽管它仍然是在您的硬盘上.\n对于文件夹，可以使用`git rm -r --cached file`取消关联整个文件夹。\n\n### 使用sourcetree\n在sourcetree中操作要麻烦一些。在添加完`gitignore`后，将想要ignore的文件移出git目录，然后`commit`该操作，再将文件移回来。这个时候文件就被ignore了。\n\n需要注意的是，一定要先执行`commit`操作。因为，在`.git`中存在了pod的版本控制的文件关联，添加了`gitignore`后，git并不会主动将pod文件关联删掉。\n因此，需要先用`commit`将该文件关联删除，才能正确ignore该文件夹。\n\n### 总结\n这里的移除相当于执行了 `rm 文件`的操作，因而需要使用`commit`,而使用命令行的`git rm 文件`则是通过git指令，直接移除了关联。\n\n## git add\n不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有`.git`的缘故吧。\n\n因此，如果当git不能自动添加文件关联的时候，需要使用`git add 文件`的方式手动添加。\n\n使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的`.git`不会被复制，文件也就能添加进sourcetree了。","source":"_posts/git技巧.md","raw":"title: Git技巧\ndate: 2016/8/27 14:07:12  \ncategories: Git\ntags: [Git]\n\n---\n\n虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。\n\n<!--more-->\n\n## git rm\nios中pod的第三方库经常会被`gitignore`掉，让使用者自己下载。\n\n想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.\n\n\n\n### 使用命令行\n可以使用`git rm --cached file`\nGit 将不再跟踪此文件，尽管它仍然是在您的硬盘上.\n对于文件夹，可以使用`git rm -r --cached file`取消关联整个文件夹。\n\n### 使用sourcetree\n在sourcetree中操作要麻烦一些。在添加完`gitignore`后，将想要ignore的文件移出git目录，然后`commit`该操作，再将文件移回来。这个时候文件就被ignore了。\n\n需要注意的是，一定要先执行`commit`操作。因为，在`.git`中存在了pod的版本控制的文件关联，添加了`gitignore`后，git并不会主动将pod文件关联删掉。\n因此，需要先用`commit`将该文件关联删除，才能正确ignore该文件夹。\n\n### 总结\n这里的移除相当于执行了 `rm 文件`的操作，因而需要使用`commit`,而使用命令行的`git rm 文件`则是通过git指令，直接移除了关联。\n\n## git add\n不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有`.git`的缘故吧。\n\n因此，如果当git不能自动添加文件关联的时候，需要使用`git add 文件`的方式手动添加。\n\n使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的`.git`不会被复制，文件也就能添加进sourcetree了。","slug":"git技巧","published":1,"updated":"2016-09-23T05:45:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzyz0046rgru4803rodi","content":"<p>虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。</p>\n<a id=\"more\"></a>\n<h2 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h2><p>ios中pod的第三方库经常会被<code>gitignore</code>掉，让使用者自己下载。</p>\n<p>想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.</p>\n<h3 id=\"使用命令行\"><a href=\"#使用命令行\" class=\"headerlink\" title=\"使用命令行\"></a>使用命令行</h3><p>可以使用<code>git rm --cached file</code><br>Git 将不再跟踪此文件，尽管它仍然是在您的硬盘上.<br>对于文件夹，可以使用<code>git rm -r --cached file</code>取消关联整个文件夹。</p>\n<h3 id=\"使用sourcetree\"><a href=\"#使用sourcetree\" class=\"headerlink\" title=\"使用sourcetree\"></a>使用sourcetree</h3><p>在sourcetree中操作要麻烦一些。在添加完<code>gitignore</code>后，将想要ignore的文件移出git目录，然后<code>commit</code>该操作，再将文件移回来。这个时候文件就被ignore了。</p>\n<p>需要注意的是，一定要先执行<code>commit</code>操作。因为，在<code>.git</code>中存在了pod的版本控制的文件关联，添加了<code>gitignore</code>后，git并不会主动将pod文件关联删掉。<br>因此，需要先用<code>commit</code>将该文件关联删除，才能正确ignore该文件夹。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里的移除相当于执行了 <code>rm 文件</code>的操作，因而需要使用<code>commit</code>,而使用命令行的<code>git rm 文件</code>则是通过git指令，直接移除了关联。</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有<code>.git</code>的缘故吧。</p>\n<p>因此，如果当git不能自动添加文件关联的时候，需要使用<code>git add 文件</code>的方式手动添加。</p>\n<p>使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的<code>.git</code>不会被复制，文件也就能添加进sourcetree了。</p>\n","excerpt":"<p>虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。</p>","more":"<h2 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h2><p>ios中pod的第三方库经常会被<code>gitignore</code>掉，让使用者自己下载。</p>\n<p>想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.</p>\n<h3 id=\"使用命令行\"><a href=\"#使用命令行\" class=\"headerlink\" title=\"使用命令行\"></a>使用命令行</h3><p>可以使用<code>git rm --cached file</code><br>Git 将不再跟踪此文件，尽管它仍然是在您的硬盘上.<br>对于文件夹，可以使用<code>git rm -r --cached file</code>取消关联整个文件夹。</p>\n<h3 id=\"使用sourcetree\"><a href=\"#使用sourcetree\" class=\"headerlink\" title=\"使用sourcetree\"></a>使用sourcetree</h3><p>在sourcetree中操作要麻烦一些。在添加完<code>gitignore</code>后，将想要ignore的文件移出git目录，然后<code>commit</code>该操作，再将文件移回来。这个时候文件就被ignore了。</p>\n<p>需要注意的是，一定要先执行<code>commit</code>操作。因为，在<code>.git</code>中存在了pod的版本控制的文件关联，添加了<code>gitignore</code>后，git并不会主动将pod文件关联删掉。<br>因此，需要先用<code>commit</code>将该文件关联删除，才能正确ignore该文件夹。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这里的移除相当于执行了 <code>rm 文件</code>的操作，因而需要使用<code>commit</code>,而使用命令行的<code>git rm 文件</code>则是通过git指令，直接移除了关联。</p>\n<h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有<code>.git</code>的缘故吧。</p>\n<p>因此，如果当git不能自动添加文件关联的时候，需要使用<code>git add 文件</code>的方式手动添加。</p>\n<p>使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的<code>.git</code>不会被复制，文件也就能添加进sourcetree了。</p>"},{"title":"重新开始","date":"2016-07-30T06:07:12.000Z","_content":"时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。\n\n<!--more-->\n\n不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。\n\n今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！\n\n\n\n![fighting](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true)","source":"_posts/重新开始.md","raw":"---\ntitle: 重新开始\ndate: 2016/7/30 14:07:12  \ncategories: 无处置放\ntags: 杂谈\n\n---\n时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。\n\n<!--more-->\n\n不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。\n\n今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！\n\n\n\n![fighting](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true)","slug":"重新开始","published":1,"updated":"2016-08-26T01:51:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citfenzz10049rgrudaoag75y","content":"<p>时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。</p>\n<a id=\"more\"></a>\n<p>不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。</p>\n<p>今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true\" alt=\"fighting\"></p>\n","excerpt":"<p>时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。</p>","more":"<p>不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。</p>\n<p>今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！</p>\n<p><img src=\"https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true\" alt=\"fighting\"></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"citfenzv10005rgru7woulu19","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvb000argru2yxagp0e"},{"post_id":"citfenzum0000rgru250mhege","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvg000ergrur4gwuz83"},{"post_id":"citfenzv90009rgruj7uaog0x","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvj000hrgru0qsnzcmj"},{"post_id":"citfenzur0001rgru51dm7z39","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvl000mrgrurcdzt7fs"},{"post_id":"citfenzvh000grgrutiizq5c9","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvm000orgrupvvxk5fx"},{"post_id":"citfenzuz0004rgru61dd4ujo","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvp000srgrunrqdv2ct"},{"post_id":"citfenzvk000jrgruhb5kdaus","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvq000urgruf5ywlsa2"},{"post_id":"citfenzvl000nrgruulcczc66","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvq000xrgrufi1vl82d"},{"post_id":"citfenzv60007rgrugihuszkl","category_id":"citfenzvk000krgrusg8a6l27","_id":"citfenzvr000zrgruznmnx4xo"},{"post_id":"citfenzvn000prgrujvbuncsd","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzvr0011rgrubozlraoo"},{"post_id":"citfenzvb000brgru2ldhy79w","category_id":"citfenzvk000krgrusg8a6l27","_id":"citfenzvr0013rgrubw8cglp5"},{"post_id":"citfenzwn001hrgrutpudkcbx","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzwx001prgrul68d9ezb"},{"post_id":"citfenzwq001jrgru1lh6jr6u","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzwz001srgruu4fxmilx"},{"post_id":"citfenzwt001mrgru60si0yo4","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzx1001vrgruiu5nc45h"},{"post_id":"citfenzwx001qrgruxaabg5p5","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzx4001yrgruooni2jtx"},{"post_id":"citfenzwz001trgru8eukaq72","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzx90023rgrupw3icrdf"},{"post_id":"citfenzx4001zrgrujvidzneu","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzxd0027rgrua3icz1r7"},{"post_id":"citfenzxa0024rgruv76ouxdg","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzxf002brgru93jzuhvp"},{"post_id":"citfenzxb0025rgru9mi2jjzv","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzxi002drgrudtah620o"},{"post_id":"citfenzx2001wrgrutraaoagj","category_id":"citfenzx90022rgru0thg519q","_id":"citfenzxl002grgrugam6tigu"},{"post_id":"citfenzxd0029rgruobw5o3t6","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzxn002krgru8vzgepei"},{"post_id":"citfenzxf002crgruokqadd1g","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzxp002orgru1p3p3eo0"},{"post_id":"citfenzxp002qrgruunjoo5h4","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzxy002xrgrujokrx6yi"},{"post_id":"citfenzxi002ergruzf8k6a63","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzy10031rgruqc1224qf"},{"post_id":"citfenzxt002srgrutan8agw7","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzy40034rgru9ik5qatr"},{"post_id":"citfenzxw002wrgrusb9dvn6v","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzy70037rgrukzln26l8"},{"post_id":"citfenzxl002irgruxp32je2o","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzya003argruj9pivdeb"},{"post_id":"citfenzxy002zrgru7moueni9","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzye003drgru669o3hx7"},{"post_id":"citfenzy20033rgruirfymhbe","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzyg003grgruud3zjryy"},{"post_id":"citfenzxn002mrgrugnhevmf3","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzyi003krgruvsu105mz"},{"post_id":"citfenzy40036rgrurix5k8ly","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzyk003nrgru1hhfyg6p"},{"post_id":"citfenzy80039rgrulzs6a9kb","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzym003rrgru0ymyskis"},{"post_id":"citfenzya003crgru2pzy904h","category_id":"citfenzxn002jrgruun2s47e8","_id":"citfenzyr003urgruajdty045"},{"post_id":"citfenzyf003frgruek30vapr","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzyt003xrgrusk1253x8"},{"post_id":"citfenzyh003irgru41ycfaa6","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzyx0040rgruiexwwrhd"},{"post_id":"citfenzyj003mrgrupcvi5o7e","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzyz0044rgru1nrrm8xp"},{"post_id":"citfenzyl003prgruwp2njx5s","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzz00047rgruh3rsrt58"},{"post_id":"citfenzyo003trgrur7gwfoff","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzz2004brgrujla2u5yf"},{"post_id":"citfenzyr003wrgru7kzov6z7","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzz4004ergruwh17o38b"},{"post_id":"citfenzyy0042rgrugv9lewnf","category_id":"citfenzuz0003rgruhtbt7ui7","_id":"citfenzz5004hrgru33ex5wai"},{"post_id":"citfenzz10049rgrudaoag75y","category_id":"citfenzx90022rgru0thg519q","_id":"citfenzz5004jrgrujcip37yt"},{"post_id":"citfenzyu003zrgruqsw9puih","category_id":"citfenzyz0043rgruy8d8sgsi","_id":"citfenzz5004lrgruvhdio935"},{"post_id":"citfenzyz0046rgru4803rodi","category_id":"citfenzz3004drgruelzyopd9","_id":"citfenzz6004nrgruqa76ph1e"}],"PostTag":[{"post_id":"citfenzum0000rgru250mhege","tag_id":"citfenzuu0002rgruwai4r3y6","_id":"citfenzvh000frgru3hup2ovy"},{"post_id":"citfenzum0000rgru250mhege","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzvj000irgrutgwrow7z"},{"post_id":"citfenzur0001rgru51dm7z39","tag_id":"citfenzuu0002rgruwai4r3y6","_id":"citfenzvq000trgrujflbqmuk"},{"post_id":"citfenzur0001rgru51dm7z39","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzvq000vrgruxu9uook1"},{"post_id":"citfenzuz0004rgru61dd4ujo","tag_id":"citfenzvo000qrgruzd1rroet","_id":"citfenzvq000yrgrurv6siq0u"},{"post_id":"citfenzv10005rgru7woulu19","tag_id":"citfenzvq000wrgruroxdc1ti","_id":"citfenzvr0012rgru5gzbd39o"},{"post_id":"citfenzv60007rgrugihuszkl","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzvt0015rgrujbymdgbx"},{"post_id":"citfenzv90009rgruj7uaog0x","tag_id":"citfenzvs0014rgru71v8sgjo","_id":"citfenzvt0017rgrufso0bfg2"},{"post_id":"citfenzvb000brgru2ldhy79w","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzvt0019rgrufeiaeo38"},{"post_id":"citfenzvh000grgrutiizq5c9","tag_id":"citfenzvt0018rgruwpaqkdrr","_id":"citfenzvu001brgrusgjujw1a"},{"post_id":"citfenzvk000jrgruhb5kdaus","tag_id":"citfenzvu001argrutbkw92ti","_id":"citfenzvv001drgru6lvf3j40"},{"post_id":"citfenzvl000nrgruulcczc66","tag_id":"citfenzvv001crgrum6v70f64","_id":"citfenzvv001frgrucy97h0b3"},{"post_id":"citfenzvn000prgrujvbuncsd","tag_id":"citfenzvu001argrutbkw92ti","_id":"citfenzvw001grgruiizs8oqq"},{"post_id":"citfenzwq001jrgru1lh6jr6u","tag_id":"citfenzvu001argrutbkw92ti","_id":"citfenzww001orgruscbip37n"},{"post_id":"citfenzwt001mrgru60si0yo4","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzwz001rrgrusgjjbxlp"},{"post_id":"citfenzwx001qrgruxaabg5p5","tag_id":"citfenzvq000wrgruroxdc1ti","_id":"citfenzx1001urgrusxzi7tqe"},{"post_id":"citfenzwn001hrgrutpudkcbx","tag_id":"citfenzwt001lrgru57dzqw65","_id":"citfenzx4001xrgrukw4ko5v8"},{"post_id":"citfenzwz001trgru8eukaq72","tag_id":"citfenzvu001argrutbkw92ti","_id":"citfenzx90021rgru6papseks"},{"post_id":"citfenzxa0024rgruv76ouxdg","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzxd0026rgruxd768rk7"},{"post_id":"citfenzx2001wrgrutraaoagj","tag_id":"citfenzx80020rgruwiancyv6","_id":"citfenzxf002argru3lhdd9im"},{"post_id":"citfenzx4001zrgrujvidzneu","tag_id":"citfenzxd0028rgrukqvvuil5","_id":"citfenzxl002hrgru06f7d2lp"},{"post_id":"citfenzxi002ergruzf8k6a63","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzxn002lrgrux7d71p74"},{"post_id":"citfenzxl002irgruxp32je2o","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzxp002prgruk2agd0n3"},{"post_id":"citfenzxb0025rgru9mi2jjzv","tag_id":"citfenzxk002frgruhvzq76ih","_id":"citfenzxt002rrgru9ac7amgv"},{"post_id":"citfenzxn002mrgrugnhevmf3","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzxw002vrgrunfzqgm3i"},{"post_id":"citfenzxp002qrgruunjoo5h4","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzxy002yrgrub2y261t7"},{"post_id":"citfenzxd0029rgruobw5o3t6","tag_id":"citfenzxp002nrgruq7muy7iq","_id":"citfenzy10032rgrunfyv51yl"},{"post_id":"citfenzxd0029rgruobw5o3t6","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzy40035rgruclpj6pux"},{"post_id":"citfenzxt002srgrutan8agw7","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzy70038rgrugyqup4vo"},{"post_id":"citfenzxw002wrgrusb9dvn6v","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzya003brgruammn6lsh"},{"post_id":"citfenzxf002crgruokqadd1g","tag_id":"citfenzxp002nrgruq7muy7iq","_id":"citfenzye003ergrupkvg2rku"},{"post_id":"citfenzxy002zrgru7moueni9","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyg003hrgruygdl8zwe"},{"post_id":"citfenzy20033rgruirfymhbe","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyi003lrgrunft5x9zr"},{"post_id":"citfenzy40036rgrurix5k8ly","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyk003orgrucx7wd6tz"},{"post_id":"citfenzy80039rgrulzs6a9kb","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyn003srgruse9isd95"},{"post_id":"citfenzya003crgru2pzy904h","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyr003vrgrurbi6lohh"},{"post_id":"citfenzyj003mrgrupcvi5o7e","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzyt003yrgrusok9xzlj"},{"post_id":"citfenzyl003prgruwp2njx5s","tag_id":"citfenzvq000wrgruroxdc1ti","_id":"citfenzyx0041rgruvrhqk0mc"},{"post_id":"citfenzyf003frgruek30vapr","tag_id":"citfenzyi003jrgrueolzyspy","_id":"citfenzyz0045rgruhfuttrla"},{"post_id":"citfenzyo003trgrur7gwfoff","tag_id":"citfenzuu0002rgruwai4r3y6","_id":"citfenzz00048rgruvjzdz2fv"},{"post_id":"citfenzyr003wrgru7kzov6z7","tag_id":"citfenzyi003jrgrueolzyspy","_id":"citfenzz3004crgruv8tjjuvl"},{"post_id":"citfenzyr003wrgru7kzov6z7","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzz4004frgru6m5qelrq"},{"post_id":"citfenzyh003irgru41ycfaa6","tag_id":"citfenzyi003jrgrueolzyspy","_id":"citfenzz5004irgrue61vu3k0"},{"post_id":"citfenzyu003zrgruqsw9puih","tag_id":"citfenzvr0010rgrud90fbpt6","_id":"citfenzz5004krgrufejttr7q"},{"post_id":"citfenzyy0042rgrugv9lewnf","tag_id":"citfenzv40006rgrudbctz7cw","_id":"citfenzz5004mrgrulz93ulz5"},{"post_id":"citfenzyy0042rgrugv9lewnf","tag_id":"citfenzvq000wrgruroxdc1ti","_id":"citfenzz6004orgruvmhsw972"},{"post_id":"citfenzyz0046rgru4803rodi","tag_id":"citfenzz2004argruzvaddcwf","_id":"citfenzz7004prgrurxv2qtk4"},{"post_id":"citfenzz10049rgrudaoag75y","tag_id":"citfenzz4004grgruk462kzth","_id":"citfenzz7004qrgru0xbtrwwc"}],"Tag":[{"name":"Animation","_id":"citfenzuu0002rgruwai4r3y6"},{"name":"UI","_id":"citfenzv40006rgrudbctz7cw"},{"name":"Block","_id":"citfenzvo000qrgruzd1rroet"},{"name":"Xcode","_id":"citfenzvq000wrgruroxdc1ti"},{"name":"学习笔记","_id":"citfenzvr0010rgrud90fbpt6"},{"name":"AutoLayout","_id":"citfenzvs0014rgru71v8sgjo"},{"name":"NSNotification","_id":"citfenzvt0018rgruwpaqkdrr"},{"name":"基本控件","_id":"citfenzvu001argrutbkw92ti"},{"name":"GCD","_id":"citfenzvv001crgrum6v70f64"},{"name":"UIGesture","_id":"citfenzwt001lrgru57dzqw65"},{"name":"Hexo","_id":"citfenzx80020rgruwiancyv6"},{"name":"UIResponder","_id":"citfenzxd0028rgrukqvvuil5"},{"name":"Debug","_id":"citfenzxk002frgruhvzq76ih"},{"name":"Objective-C","_id":"citfenzxp002nrgruq7muy7iq"},{"name":"Runtime","_id":"citfenzyi003jrgrueolzyspy"},{"name":"Git","_id":"citfenzz2004argruzvaddcwf"},{"name":"杂谈","_id":"citfenzz4004grgruk462kzth"}]}}