<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS 中的正则表达式的使用]]></title>
    <url>%2F2020%2F03%2F25%2FJS%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[经常会有写脚本做文本替换的需求。一有这种需求就要去差怎么写正则表达式，非常的费时。这里把一些常用的列举一下方便以后回顾。 正则表达式元字符 元字符 说明 $ 匹配字符串的结束 ^ 匹配字符串的开始 . 匹配除换行符以外的任意字符 [a-zA-Z] 匹配所有英文字符 [0-9] 匹配所有数字 [^a-z] 匹配除了小写字母的所有字符 重复 重复 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 分支 分支 说明 竖线 相当于或 分支是指两个完整的正在表达式取或，而不是部分或 |前后用（）包括：(A)|(B) 另外 | 不能有空格，否则会以为要匹配空格 修饰符 修饰符 说明 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 正则表达式和通配符的不同在 sql 的 like 语句中：% 任意多个， _表示 一个 普通的统配符： * 任意多个 ? 一个 JS 中的正则表达式js 中使用 正则表达式.exec(目标字符串) 的形式处理。正则表达式以 // 包裹。 1234567891011var reg = /(.a)t/g;var str ="1at,2at,3at";console.log(reg.exec(str));console.log(reg.exec(str));console.log(reg.exec(str));console.log(reg.exec(str));————————————————[ '1at', '1a', index: 0, input: '1at,2at,3at' ][ '2at', '2a', index: 4, input: '1at,2at,3at' ][ '3at', '3a', index: 8, input: '1at,2at,3at' ]null 上面没有说到修饰符，但是修饰符的作用可能不明确，尤其是这个 g。g 代表的是匹配了之后再次执行不会从头开始。上面的输出中可以看到，每次执行都会找下一个匹配项。而如果不是 g，那么就会从头开始。 1234567891011var reg = /(.a)t/;var str ="1at,2at,3at";console.log(reg.exec(str));console.log(reg.exec(str));console.log(reg.exec(str));console.log(reg.exec(str));————————————————[ '1at', '1a', index: 0, input: '1at,2at,3at' ][ '1at', '1a', index: 0, input: '1at,2at,3at' ][ '1at', '1a', index: 0, input: '1at,2at,3at' ][ '1at', '1a', index: 0, input: '1at,2at,3at' ] 正则表达式.exec(目标字符串) 返回的结果一般是一个长度为1的素组，所以直接打印就行了，但是有时候会返回一个长度非1的数组，原因未知。因此最好返回结果取第一个]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++简略语法]]></title>
    <url>%2F2020%2F01%2F23%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[假期无事，重学C++，简单摘录了一些 C++ 的基本语法，具体还需要再看 C++ Primer。 .cpp 的由来.cpp 意为 c plus plus 用 C 语言的方式去编译使用场景是如果你要使用别人用 c 写的第三方库的时候，由于 C++ 的函数编译方式和 C 不同。C++ 会默认按照 C++ 的方式去查找函数，这样是无法找到 C 的函数实现的，所以必须先声明该函数是 C 的函数1234567891011// .cpp 中的声明extern "C" void test(int a);extern "C" &#123; // 引用 c 头文件 #include "math.h"&#125;// .c 中的实现void test(int a)&#123; cout &lt;&lt; "single";&#125; C++ 由于支持函数重载，会在编译函数的时候把参数类型也添加为函数标识中，而 C 不支持重载，不关心函数参数。因此 C++ 中直接调用 C 的函数是找不到的 .h 文件中 #ifndef #define #endif的作用对于 OC 来说没有多大的作用，OC 编译器不会重复引入同一个头文件。但是对于 C 文件来说，通过多次 #include 会重复包含声明，因此需要通过 #ifndef #define 和 #endif 避免重复声明。 宏 #pragma once 也可以达到相同的效果（较新的特性） 引用引用就相当于变量的别名，引用不可以修改指向：1234567int age = 10;int &amp;rage = age; int age2 = 20;// 相当于给 age 赋值，而不是将 rage 指向 age2rage = age2 // age = 20 &amp;rage = age2 // ❌ 引用相当于别名，可以理解为之后用到引用的部分都替换为原变量 Class 和 Struct 区别C++ 中 Struct 也能定义函数，和 Class 类似。 C++ 中 Struct 和 Class 的唯一区别在于： Class 默认成员权限是 private，而Struct 默认成员权限是 public C++ 函数调用和 OC 的区别我们知道 C++ 函数调用时直接调用，即在编译的时候对于函数的调用直接转为 call 函数地址。因此， 创建的 C++ 类的实例在内存中只有成员变量。 而 OC 函数调用基于消息，所以需要有一个 isa 指针指向 meta class，以此查找调用的方法。因此 OC 类的实例除了成员变量外，还需要一个 isa 指针。 C++ 中的 . 与 -&gt;点语法的左边只能是对象，如果是指针，必须要用 -&gt;：12345Person person;person.age = 3; // √Person *person2 = &amp;person;person2.age = 5; // ×person2-&gt;age = 5; // √ 构造和析构回收在创建对象的时候构造函数会自动调用。构造函数和类同名，可以有参数，可以重载。 回收对象通过 delete 对象 来进行，调用之后对象回收(不是引用计数减一，是直接回收)。 回收时调用析构函数，析构函数不可以重载。析构函数中要释放内部的对象：123456789101112131415161718192021222324struct Car &#123;&#125;;struct Person &#123; int age; Car *car; // 构造函数的相互调用 Person() :Person(12) &#123; cout &lt;&lt; "Person build" &lt;&lt; endl; &#125; Person(int age) &#123; this-&gt;age = age; this-&gt;car = new Car(); cont &lt;&lt; "has age is" &lt;&lt; age &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "destructor" &lt;&lt; endl; delete this-&gt;car; &#125;&#125;;int main() &#123; Person *person = new Person(23); delete person; return 0;&#125; 注意这里的构造函数的相互调用的方式。由于 C 不像 OC，Java 这种构造函数返回自身，而是返回 void，因此，不能在方法中主动调用其他构造函数，而是需要使用如上的语法糖告知编译器 C 语言中的创建与回收通过 malloc 分配的对象不会调用构造函数和析构函数：123Person *person = (Person *)malloc(sizeof(Person));person-&gt;age = 12;free(person); 声明实现分离C++ 中声明文件和实现文件分离：123456789101112131415161718// .h 中#ifndef Person_hpp#define Person_hpp#include &lt;stdio.h&gt;class Car &#123;&#125;;class Person &#123;public: int age; Car *car; void run(); Person(int age); ~Person();&#125;;#endif /* Person_hpp */ 声明之后的实现方式如下：12345678910111213141516// .cpp 中#include "Person.h"#include &lt;iostream&gt;Person::Person(int age) &#123; this-&gt;age = age; this-&gt;car = new Car();&#125;Person::~Person() &#123; std::cout &lt;&lt; “dealloc” &lt;&lt; std::endl; delete this-&gt;car;&#125;void Person::run() &#123; cout &lt;&lt; "run" &lt;&lt; endl;&#125; 编译的时候只会编译 cpp 文件，头文件中放入的声明，在编译的时候会被直接写入 cpp 中。声明对应的具体实现会在链接过程中替换为具体的地址。 因此，我们可以得出一个结论，在 .h 中不能直接写函数实现是因为会被多个文件导入，从而导致 duplicate symbol。而 .h 中定义的 class 中的方法可以写函数实现是因为 class 包裹的关系，不会因为多次导入而变成两份实现。 命名空间使用 namespace 关键字包裹。同名的命名空间会被合并：123456namespace ZAC &#123; class Car &#123;&#125;;&#125;namespace ZAC &#123; class Bike &#123;&#125;;&#125; 使用：12345678// 直接写明命名空间ZAC::Car *car = new ZAC::Car();// 省略命名空间,但是这样会导致全部的命名空间默认都是 ZACusing namespace ZAC;int main() &#123; Car *car = new Car(); return 0;&#125; 对于声明实现分离的类使用命名空间，声明和实现都要包括在 namespace 中 继承C++ 继承和 OC 继承类似:12struct Person &#123;&#125;;struct Student : Person &#123;&#125;; 多态C++ 的函数调用方式是编译时根据指针类型，直接调用函数地址。要实现多态，需要借助虚函数。如果有多态，需要把其析构函数也声明为虚析构函数（如果不设置为虚析构函数，那么就会调用父类的析构函数而不是真正的析构函数）：12345678910111213struct Person &#123; virtual void walk() &#123; cout &lt;&lt; "person walk" &lt;&lt; endl; &#125; virtual ~Person() &#123;&#125;&#125;;struct Student &#123; void walk() &#123; count &lt;&lt; "student walk" &lt;&lt; endl; &#125; ~Student() &#123;&#125;&#125;; 使用虚函数后，对象的前4个字节会存一个虚函数表的地址，其他属性的地址会依次向后移动4个字节。 纯虚函数没有函数体，且函数初始化为0的叫做纯虚函数。含有纯虚函数的类叫做抽象类，不可以被实例化，只能用来定义接口规范：123struct Person &#123; virtual void walk() = 0;&#125;; 虚继承C++ 是多继承的，这样就造成了在菱形继承情况下会同时继承多个基类的同名属性的情况。虚继承则是告知编译器，共用同一个属性：123456789101112131415struct Person &#123; int age;&#125;struct Student : virtual Person &#123; int score;&#125;;struct Worker : virtual Person &#123; int salary;&#125;;struct Me : Student, Worker &#123; int name;&#125;; 静态成员变量C++ 中访问静态成员变量的方式和其他语言不同。它的初始化方式也和其他语言不同：1234567891011class Person &#123;public: static int age;&#125;;// 在类外部初始化。一般放在 .cpp 中int Person::age = 12;int main(int argc, const char * argv[]) &#123; Person::age = 12; return 0;&#125; OC 中由于有 meta class 的存在，静态成员变量和静态方法是存在 meta class 中的。 而 C++ 中的静态成员变量不同，静态成员变量就相当于是个限制了作用域的全局变量。 constC++ 中的 const 有两种场景：修饰值时不能改变对象的属性，修饰指针时不能改变指针的指向。 C++ 中的方法也可以是 const 的，表示该方法不会修改对象的成员变量。在 const 修饰对象的时候，不能调用非 const 的方法：1234567891011121314class Person &#123;public: // 这里必须要有 const void run() const &#123; cout &lt;&lt; "run" &lt;&lt; endl; &#125;&#125;;int main(int argc, const char * argv[]) &#123; const Person *p = new Person(); // const 修饰对象，那么一定只能调用 const 的方法 p-&gt;run(); return 0;&#125; const 的位置标示的结果的不同这是一个老问题，const 位置的不同所代表的意义也不同：1234// 指向的值不能改变，对象的话不能改变属性Person const *person = new Person();// 指针指向不能改变Person * const person = new Person(); const 永远修饰它的👉，右边是 *person 就表示指针指向的值不能变，右边是 person 就表示指针不能改变指向。 模板函数模板C++ 模板写法如下：123456// 写在 .h 文件中template &lt;typename T&gt; T add(T a, T b) &#123; return a + b;&#125;add&lt;double&gt;(1.5, 2); 编译的时候根据类型生成不同的函数 C++ 模板在声明实现分离的时候不能在 .cpp 中实现而要直接在 .h 中实现。这是因为模板实现的 .cpp 文件在单独编译的时候不知道被传入了哪些类型，因此无法创建相应类型的函数实现。而写在 .h 中直接被引入其他 .cpp 中后，在编译的时候就能知道其他 .cpp 文件传入了什么类型，进而创建相应的函数。 类模板类模板写起来非常麻烦，设置了类模板之后，每个方法的实现都要声明一遍模板，否则报错：1234567891011121314151617181920212223242526// .h 中template &lt;class Food&gt;class Person &#123;public: void eat(Food *a); Person(); Person(int age); ~Person();&#125;;template &lt;class Food&gt;void Person&lt;Food&gt;::eat(Food *a) &#123; cout &lt;&lt; "food" &lt;&lt; endl;&#125;// .cpp 中template &lt;class Food&gt;Person&lt;Food&gt;::Person() &#123;&#125;template &lt;class Food&gt;Person&lt;Food&gt;::Person(int age) &#123;&#125;template &lt;class Food&gt;Person&lt;Food&gt;::~Person() &#123; std::cout &lt;&lt; "dealloc" &lt;&lt; std::endl;&#125; 类模板的实现声明分离同样还是写在头文件中 自动类型推断和 dart 类似，可以不用写明变量的类型，通过 auto 声明让编译器自行推断：1auto a = 10; lamda 表达式lamda 表达式的一般形式如下，[] 表示的是捕获的外部的变量，() 内是参数。这种捕获方式是值捕获：1234int a = 10;int (*p)(int) = [a](int param) -&gt; int &#123; return param * a;&#125; 如果要捕获的变量会根据外部的修改而变化，并且内部的变化也会影响外部的值，那么就需要获取变量的地址。这种捕获方式是引用捕获：1234int a = 10;int (*p)(int) = [&amp;a](int param) -&gt; int &#123; return param * a;&#125; 和 OC 中的 __block 类似，都是可以内部修改外部的值以及外部可以修改内部的值。只不过 C++ 中是通过指针传递的方式，而 OC 中则是通过生成一个包裹对象的形式。 另外合 OC 类似的，全局变量不用捕获。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Crash 收集框架 KSCrash 源码解析(中)]]></title>
    <url>%2F2019%2F11%2F01%2Fkscrash2%2F</url>
    <content type="text"><![CDATA[前一篇看了如何捕获各种类型的异常，这一篇将探究如何解析异常。这一篇的理解有一定的难度，你需要提前对 Mach-O 的结构有一个大体上的了解。其中涉及到如何将 crash 的地址 symbolicate 的过程，步骤类似于 fishhook，可以翻阅我之前对 fishhook 的解析。 Crash 回调在接收到各种类型的 Crash 信息之后，会统一回调一个处理函数，它就是 KSCrashC.c 中的 onCrash() 方法： 123456789101112131415161718192021222324252627/// 接收到 crash 信息的处理函数static void onCrash(struct KSCrash_MonitorContext* monitorContext)&#123; if (monitorContext-&gt;currentSnapshotUserReported == false) &#123; KSLOG_DEBUG("Updating application state to note crash."); kscrashstate_notifyAppCrash(); &#125; monitorContext-&gt;consoleLogPath = g_shouldAddConsoleLogToReport ? g_consoleLogPath : NULL; if(monitorContext-&gt;crashedDuringCrashHandling) &#123; kscrashreport_writeRecrashReport(monitorContext, g_lastCrashReportFilePath); &#125; else &#123; char crashReportFilePath[KSFU_MAX_PATH_LENGTH]; int64_t reportID = kscrs_getNextCrashReport(crashReportFilePath); strncpy(g_lastCrashReportFilePath, crashReportFilePath, sizeof(g_lastCrashReportFilePath)); /// 将 context 转为 report 写入路径s中 kscrashreport_writeStandardReport(monitorContext, crashReportFilePath); if(g_reportWrittenCallback) &#123; g_reportWrittenCallback(reportID); &#125; &#125;&#125; 其中重要的就是讲 context 写入文件的 kscrashreport_writeStandardReport() 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/// 将 context 转为 report 写入 pathvoid kscrashreport_writeStandardReport(const KSCrash_MonitorContext* const monitorContext, const char* const path)&#123; KSLOG_INFO("Writing crash report to %s", path); char writeBuffer[1024]; KSBufferedWriter bufferedWriter; if(!ksfu_openBufferedWriter(&amp;bufferedWriter, path, writeBuffer, sizeof(writeBuffer))) &#123; return; &#125; ksccd_freeze(); KSJSONEncodeContext jsonContext; /// jsonContext 的 userData 是 writer writer 的 context 是 jsonContext jsonContext.userData = &amp;bufferedWriter; /// 写入操作的执行者 KSCrashReportWriter concreteWriter; KSCrashReportWriter* writer = &amp;concreteWriter; /// 初始化 writer 的各个方法 prepareReportWriter(writer, &amp;jsonContext); ksjson_beginEncode(getJsonContext(writer), true, addJSONData, &amp;bufferedWriter); /// 将 “&#123;” 写入 buffer writer-&gt;beginObject(writer, KSCrashField_Report); &#123; /// 写入基本信息 writeReportInfo(writer, KSCrashField_Report, KSCrashReportType_Standard, monitorContext-&gt;eventID, monitorContext-&gt;System.processName); /// 将 buffer 保存到磁盘中 ksfu_flushBufferedWriter(&amp;bufferedWriter); /// 把所有 image 信息写入磁盘 writeBinaryImages(writer, KSCrashField_BinaryImages); ksfu_flushBufferedWriter(&amp;bufferedWriter); /// 写入 NSException 出错的信息 writeProcessState(writer, KSCrashField_ProcessState, monitorContext); ksfu_flushBufferedWriter(&amp;bufferedWriter); /// 写入系统信息 writeSystemInfo(writer, KSCrashField_System, monitorContext); ksfu_flushBufferedWriter(&amp;bufferedWriter); writer-&gt;beginObject(writer, KSCrashField_Crash); &#123; writeError(writer, KSCrashField_Error, monitorContext); ksfu_flushBufferedWriter(&amp;bufferedWriter); /// 写入所有的线程信息 writeAllThreads(writer, KSCrashField_Threads, monitorContext, g_introspectionRules.enabled); ksfu_flushBufferedWriter(&amp;bufferedWriter); &#125; writer-&gt;endContainer(writer); if(g_userInfoJSON != NULL) &#123; addJSONElement(writer, KSCrashField_User, g_userInfoJSON, false); ksfu_flushBufferedWriter(&amp;bufferedWriter); &#125; else &#123; writer-&gt;beginObject(writer, KSCrashField_User); &#125; if(g_userSectionWriteCallback != NULL) &#123; ksfu_flushBufferedWriter(&amp;bufferedWriter); if (monitorContext-&gt;currentSnapshotUserReported == false) &#123; g_userSectionWriteCallback(writer); &#125; &#125; writer-&gt;endContainer(writer); ksfu_flushBufferedWriter(&amp;bufferedWriter); writeDebugInfo(writer, KSCrashField_Debug, monitorContext); &#125; writer-&gt;endContainer(writer); ksjson_endEncode(getJsonContext(writer)); ksfu_closeBufferedWriter(&amp;bufferedWriter); ksccd_unfreeze();&#125; 写入方法先来看怎么写入的。不用管那些初始化方法，直接看 beginObject()，它在兜兜转转后调用了如下方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/// 将 data 保存到 buffer 或者文件系统中static int addJSONData(const char* restrict const data, const int length, void* restrict userData)&#123; KSBufferedWriter* writer = (KSBufferedWriter*)userData; const bool success = ksfu_writeBufferedWriter(writer, data, length); return success ? KSJSON_OK : KSJSON_ERROR_CANNOT_ADD_DATA;&#125;/// 将 data 写入 buffer 或者文件系统中bool ksfu_writeBufferedWriter(KSBufferedWriter* writer, const char* restrict const data, const int length)&#123; /// 如果 buffer 中的字符数量超出最大值了，那么 flush buffer 到文件系统中 if(length &gt; writer-&gt;bufferLength - writer-&gt;position) &#123; ksfu_flushBufferedWriter(writer); &#125; if(length &gt; writer-&gt;bufferLength) &#123; return ksfu_writeBytesToFD(writer-&gt;fd, data, length); &#125; /// 否则写入 buffer 中 memcpy(writer-&gt;buffer + writer-&gt;position, data, length); writer-&gt;position += length; return true;&#125;/// 判断是否要将 buffer 写入文件bool ksfu_flushBufferedWriter(KSBufferedWriter* writer)&#123; if(writer-&gt;fd &gt; 0 &amp;&amp; writer-&gt;position &gt; 0) &#123; if(!ksfu_writeBytesToFD(writer-&gt;fd, writer-&gt;buffer, writer-&gt;position)) &#123; return false; &#125; writer-&gt;position = 0; &#125; return true;&#125;bool ksfu_writeBytesToFD(const int fd, const char* const bytes, int length)&#123; const char* pos = bytes; while(length &gt; 0) &#123; int bytesWritten = (int)write(fd, pos, (unsigned)length); if(bytesWritten == -1) &#123; KSLOG_ERROR("Could not write to fd %d: %s", fd, strerror(errno)); return false; &#125; length -= bytesWritten; pos += bytesWritten; &#125; return true;&#125; KSBufferedWriter 打开了一个写入流，同时维护了一个 1024 大小的 buffer。当 buffer 中的数据超出之后，就会将 buffer 写入文件中。 写入 image 信息写入 image 信息通过 writeBinaryImages() 实现： 1234567891011121314151617181920static void writeBinaryImages(const KSCrashReportWriter* const writer, const char* const key)&#123; /// 通过 _dyld_image_count 获取 image 的数量 const int imageCount = ksdl_imageCount(); writer-&gt;beginArray(writer, key); &#123; for(int iImg = 0; iImg &lt; imageCount; iImg++) &#123; /// 通过 _dyld_get_image_header 获取 image 信息 writeBinaryImage(writer, NULL, iImg); &#125; &#125; writer-&gt;endContainer(writer);&#125;int ksdl_imageCount()&#123; return (int)_dyld_image_count();&#125; 通过 dyld 提供的 _dyld_image_count() 方法获取加载的 image 数量。具体的 image 中的信息在 writeBinaryImage() 中获取： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104static void writeBinaryImage(const KSCrashReportWriter* const writer, const char* const key, const int index)&#123; KSBinaryImage image = &#123;0&#125;; /// 通过 _dyld_get_image_header 获取 image 信息 if(!ksdl_getBinaryImage(index, &amp;image)) &#123; return; &#125; writer-&gt;beginObject(writer, key); &#123; writer-&gt;addUIntegerElement(writer, KSCrashField_ImageAddress, image.address); writer-&gt;addUIntegerElement(writer, KSCrashField_ImageVmAddress, image.vmAddress); writer-&gt;addUIntegerElement(writer, KSCrashField_ImageSize, image.size); writer-&gt;addStringElement(writer, KSCrashField_Name, image.name); writer-&gt;addUUIDElement(writer, KSCrashField_UUID, image.uuid); writer-&gt;addIntegerElement(writer, KSCrashField_CPUType, image.cpuType); writer-&gt;addIntegerElement(writer, KSCrashField_CPUSubType, image.cpuSubType); writer-&gt;addUIntegerElement(writer, KSCrashField_ImageMajorVersion, image.majorVersion); writer-&gt;addUIntegerElement(writer, KSCrashField_ImageMinorVersion, image.minorVersion); writer-&gt;addUIntegerElement(writer, KSCrashField_ImageRevisionVersion, image.revisionVersion); &#125; writer-&gt;endContainer(writer);&#125;bool ksdl_getBinaryImage(int index, KSBinaryImage* buffer)&#123; /// 通过 _dyld_get_image_header 获取 image 的 header const struct mach_header* header = _dyld_get_image_header((unsigned)index); if(header == NULL) &#123; return false; &#125; uintptr_t cmdPtr = firstCmdAfterHeader(header); if(cmdPtr == 0) &#123; return false; &#125; // Look for the TEXT segment to get the image size. // Also look for a UUID command. uint64_t imageSize = 0; uint64_t imageVmAddr = 0; uint64_t version = 0; uint8_t* uuid = NULL; for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) &#123; struct load_command* loadCmd = (struct load_command*)cmdPtr; switch(loadCmd-&gt;cmd) &#123; case LC_SEGMENT: &#123; struct segment_command* segCmd = (struct segment_command*)cmdPtr; if(strcmp(segCmd-&gt;segname, SEG_TEXT) == 0) &#123; imageSize = segCmd-&gt;vmsize; imageVmAddr = segCmd-&gt;vmaddr; &#125; break; &#125; case LC_SEGMENT_64: &#123; struct segment_command_64* segCmd = (struct segment_command_64*)cmdPtr; if(strcmp(segCmd-&gt;segname, SEG_TEXT) == 0) &#123; imageSize = segCmd-&gt;vmsize; imageVmAddr = segCmd-&gt;vmaddr; &#125; break; &#125; case LC_UUID: &#123; struct uuid_command* uuidCmd = (struct uuid_command*)cmdPtr; uuid = uuidCmd-&gt;uuid; break; &#125; case LC_ID_DYLIB: &#123; struct dylib_command* dc = (struct dylib_command*)cmdPtr; version = dc-&gt;dylib.current_version; break; &#125; &#125; cmdPtr += loadCmd-&gt;cmdsize; &#125; buffer-&gt;address = (uintptr_t)header; buffer-&gt;vmAddress = imageVmAddr; buffer-&gt;size = imageSize; buffer-&gt;name = _dyld_get_image_name((unsigned)index); buffer-&gt;uuid = uuid; buffer-&gt;cpuType = header-&gt;cputype; buffer-&gt;cpuSubType = header-&gt;cpusubtype; buffer-&gt;majorVersion = version &gt;&gt; 16; buffer-&gt;minorVersion = (version &gt;&gt; 8) &amp; 0xff; buffer-&gt;revisionVersion = version &amp; 0xff; return true;&#125; 总的来说，通过 _dyld_get_image_header 获取 image 的 header 部分。然后通过 header 位置定位到 load command，遍历 load command 的信息 写入线程信息前一篇讲到过，在 crash 的时候，会 suspend 所有的线程，并且获取它们的基本信息。现在就要对获取到的线程进行解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void writeThread(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_MonitorContext* const crash, const struct KSMachineContext* const machineContext, const int threadIndex, const bool shouldWriteNotableAddresses)&#123; bool isCrashedThread = ksmc_isCrashedContext(machineContext); KSThread thread = ksmc_getThreadFromContext(machineContext); KSLOG_DEBUG("Writing thread %x (index %d). is crashed: %d", thread, threadIndex, isCrashedThread); KSStackCursor stackCursor; bool hasBacktrace = getStackCursor(crash, machineContext, &amp;stackCursor); writer-&gt;beginObject(writer, key); &#123; if(hasBacktrace) &#123; /// 写入调用栈 writeBacktrace(writer, KSCrashField_Backtrace, &amp;stackCursor); &#125; if(ksmc_canHaveCPUState(machineContext)) &#123; /// 写入寄存器 writeRegisters(writer, KSCrashField_Registers, machineContext); &#125; /// 写入线程index writer-&gt;addIntegerElement(writer, KSCrashField_Index, threadIndex); const char* name = ksccd_getThreadName(thread); if(name != NULL) &#123; /// 线程有名称就写入线程名称 writer-&gt;addStringElement(writer, KSCrashField_Name, name); &#125; name = ksccd_getQueueName(thread); if(name != NULL) &#123; /// 写入 dispatch_queue 的名称 writer-&gt;addStringElement(writer, KSCrashField_DispatchQueue, name); &#125; /// 是否是崩溃线程 writer-&gt;addBooleanElement(writer, KSCrashField_Crashed, isCrashedThread); writer-&gt;addBooleanElement(writer, KSCrashField_CurrentThread, thread == ksthread_self()); /// 如果是崩溃的线程 if(isCrashedThread) &#123; /// 将 stack pointer 上的部分数据拷贝出来 writeStackContents(writer, KSCrashField_Stack, machineContext, stackCursor.state.hasGivenUp); if(shouldWriteNotableAddresses) &#123; /// 将通过 zombie 记录的地址拷贝出来 writeNotableAddresses(writer, KSCrashField_NotableAddresses, machineContext); &#125; &#125; &#125; writer-&gt;endContainer(writer);&#125; 其中比较重要的是符号化调用堆栈，写入寄存器的值，以及写入 zombie 记录的信息。 符号化调用堆栈符号化的过程其实在 fishhock 中有介绍。就是通过实际的地址找到符号表中相应的符号，再到字符串表中找到对应的字符串： 1234567891011121314151617181920212223242526272829303132333435363738static void writeBacktrace(const KSCrashReportWriter* const writer, const char* const key, KSStackCursor* stackCursor)&#123; writer-&gt;beginObject(writer, key); &#123; writer-&gt;beginArray(writer, KSCrashField_Contents); &#123; /// 对每一层调用栈进行符号化 while(stackCursor-&gt;advanceCursor(stackCursor)) &#123; writer-&gt;beginObject(writer, NULL); &#123; /// 对调用栈符号化 if(stackCursor-&gt;symbolicate(stackCursor)) &#123; /// 把符号化后的 image 名，地址，symbol 名，地址写入 if(stackCursor-&gt;stackEntry.imageName != NULL) &#123; writer-&gt;addStringElement(writer, KSCrashField_ObjectName, ksfu_lastPathEntry(stackCursor-&gt;stackEntry.imageName)); &#125; writer-&gt;addUIntegerElement(writer, KSCrashField_ObjectAddr, stackCursor-&gt;stackEntry.imageAddress); if(stackCursor-&gt;stackEntry.symbolName != NULL) &#123; writer-&gt;addStringElement(writer, KSCrashField_SymbolName, stackCursor-&gt;stackEntry.symbolName); &#125; writer-&gt;addUIntegerElement(writer, KSCrashField_SymbolAddr, stackCursor-&gt;stackEntry.symbolAddress); &#125; writer-&gt;addUIntegerElement(writer, KSCrashField_InstructionAddr, stackCursor-&gt;stackEntry.address); &#125; writer-&gt;endContainer(writer); &#125; &#125; writer-&gt;endContainer(writer); writer-&gt;addIntegerElement(writer, KSCrashField_Skipped, 0); &#125; writer-&gt;endContainer(writer);&#125; 其核心逻辑在以下方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/// 根据 address 获取符号名bool ksdl_dladdr(const uintptr_t address, Dl_info* const info)&#123; info-&gt;dli_fname = NULL; info-&gt;dli_fbase = NULL; info-&gt;dli_sname = NULL; info-&gt;dli_saddr = NULL; /// 判断 address 是在第几个 image 内 const uint32_t idx = imageIndexContainingAddress(address); if(idx == UINT_MAX) &#123; return false; &#125; /// 获得该 image 的 header const struct mach_header* header = _dyld_get_image_header(idx); /// 获得该 image 的基地址 const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx); /// 获取 address 相对于 image 的偏移 const uintptr_t addressWithSlide = address - imageVMAddrSlide; /// 获得 segment 在虚拟内存中的基地址 const uintptr_t segmentBase = segmentBaseOfImageIndex(idx) + imageVMAddrSlide; if(segmentBase == 0) &#123; return false; &#125; /// 获取 image 的名字 info-&gt;dli_fname = _dyld_get_image_name(idx); /// 获取 header 地址 info-&gt;dli_fbase = (void*)header; // Find symbol tables and get whichever symbol is closest to the address. const STRUCT_NLIST* bestMatch = NULL; uintptr_t bestDistance = ULONG_MAX; uintptr_t cmdPtr = firstCmdAfterHeader(header); if(cmdPtr == 0) &#123; return false; &#125; for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) &#123; const struct load_command* loadCmd = (struct load_command*)cmdPtr; if(loadCmd-&gt;cmd == LC_SYMTAB) &#123; /// 找到 symbol table 的 load command const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPtr; /// 通过 load command 中的 offset + segment 的基地址，得到 symbol table 的实际地址 const STRUCT_NLIST* symbolTable = (STRUCT_NLIST*)(segmentBase + symtabCmd-&gt;symoff); /// 找到 string table 的位置 const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff; /// 找到最佳的符号 for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123; // If n_value is 0, the symbol refers to an external object. if(symbolTable[iSym].n_value != 0) &#123; uintptr_t symbolBase = symbolTable[iSym].n_value; /// uintptr_t currentDistance = addressWithSlide - symbolBase; if((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) &#123; bestMatch = symbolTable + iSym; bestDistance = currentDistance; &#125; &#125; &#125; /// 根据符号的位置找到其在 string table 中表示的字符串 if(bestMatch != NULL) &#123; info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddrSlide); if(bestMatch-&gt;n_desc == 16) &#123; // This image has been stripped. The name is meaningless, and // almost certainly resolves to "_mh_execute_header" info-&gt;dli_sname = NULL; &#125; else &#123; info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx); if(*info-&gt;dli_sname == '_') &#123; info-&gt;dli_sname++; &#125; &#125; break; &#125; &#125; cmdPtr += loadCmd-&gt;cmdsize; &#125; return true;&#125; 代码中已经做了详尽的注释，对于原理我就不再做详尽的阐述了。如果对这部分不明白，也可以参考我对于 fishhook 的解析。总之，在这个过程中就完成了从地址到 image 中符号的转化。 写入寄存器在通过 crash 获取的 context 信息中，我们可以拿到寄存器相关的信息： 1234567891011121314151617181920212223static void writeBasicRegisters(const KSCrashReportWriter* const writer, const char* const key, const struct KSMachineContext* const machineContext)&#123; char registerNameBuff[30]; const char* registerName; writer-&gt;beginObject(writer, key); &#123; const int numRegisters = kscpu_numRegisters(); for(int reg = 0; reg &lt; numRegisters; reg++) &#123; registerName = kscpu_registerName(reg); if(registerName == NULL) &#123; snprintf(registerNameBuff, sizeof(registerNameBuff), "r%d", reg); registerName = registerNameBuff; &#125; writer-&gt;addUIntegerElement(writer, registerName, kscpu_registerValue(machineContext, reg)); &#125; &#125; writer-&gt;endContainer(writer);&#125; 获取到的寄存器有以下所示： 123456789static const char* g_registerNames[] =&#123; "rax", "rbx", "rcx", "rdx", "rdi", "rsi", "rbp", "rsp", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15", "rip", "rflags", "cs", "fs", "gs"&#125;; 根据寄存器的序号通过如下方法在 context 中获取寄存器中存储的值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051uint64_t kscpu_registerValue(const KSMachineContext* const context, const int regNumber)&#123; switch(regNumber) &#123; case 0: return context-&gt;machineContext.__ss.__rax; case 1: return context-&gt;machineContext.__ss.__rbx; case 2: return context-&gt;machineContext.__ss.__rcx; case 3: return context-&gt;machineContext.__ss.__rdx; case 4: return context-&gt;machineContext.__ss.__rdi; case 5: return context-&gt;machineContext.__ss.__rsi; case 6: return context-&gt;machineContext.__ss.__rbp; case 7: return context-&gt;machineContext.__ss.__rsp; case 8: return context-&gt;machineContext.__ss.__r8; case 9: return context-&gt;machineContext.__ss.__r9; case 10: return context-&gt;machineContext.__ss.__r10; case 11: return context-&gt;machineContext.__ss.__r11; case 12: return context-&gt;machineContext.__ss.__r12; case 13: return context-&gt;machineContext.__ss.__r13; case 14: return context-&gt;machineContext.__ss.__r14; case 15: return context-&gt;machineContext.__ss.__r15; case 16: return context-&gt;machineContext.__ss.__rip; case 17: return context-&gt;machineContext.__ss.__rflags; case 18: return context-&gt;machineContext.__ss.__cs; case 19: return context-&gt;machineContext.__ss.__fs; case 20: return context-&gt;machineContext.__ss.__gs; &#125; KSLOG_ERROR("Invalid register number: %d", regNumber); return 0;&#125; 记录调用堆栈的部分信息分析 crash 的原因，怎么能少了出错线程堆栈的解析呢？KSCrash 提供了方法将出错线程的堆栈上的部分信息拷贝出来： 1234567891011121314151617181920212223242526272829303132333435363738394041static void writeStackContents(const KSCrashReportWriter* const writer, const char* const key, const struct KSMachineContext* const machineContext, const bool isStackOverflow)&#123; /// 拿到 stack pointer uintptr_t sp = kscpu_stackPointer(machineContext); if((void*)sp == NULL) &#123; return; &#125; uintptr_t lowAddress = sp + (uintptr_t)(kStackContentsPushedDistance * (int)sizeof(sp) * kscpu_stackGrowDirection() * -1); uintptr_t highAddress = sp + (uintptr_t)(kStackContentsPoppedDistance * (int)sizeof(sp) * kscpu_stackGrowDirection()); if(highAddress &lt; lowAddress) &#123; uintptr_t tmp = lowAddress; lowAddress = highAddress; highAddress = tmp; &#125; writer-&gt;beginObject(writer, key); &#123; writer-&gt;addStringElement(writer, KSCrashField_GrowDirection, kscpu_stackGrowDirection() &gt; 0 ? "+" : "-"); writer-&gt;addUIntegerElement(writer, KSCrashField_DumpStart, lowAddress); writer-&gt;addUIntegerElement(writer, KSCrashField_DumpEnd, highAddress); writer-&gt;addUIntegerElement(writer, KSCrashField_StackPtr, sp); writer-&gt;addBooleanElement(writer, KSCrashField_Overflow, isStackOverflow); uint8_t stackBuffer[kStackContentsTotalDistance * sizeof(sp)]; int copyLength = (int)(highAddress - lowAddress); /// 拷贝 lowAddress 上的数据到 buffer 中 if(ksmem_copySafely((void*)lowAddress, stackBuffer, copyLength)) &#123; writer-&gt;addDataElement(writer, KSCrashField_Contents, (void*)stackBuffer, copyLength); &#125; else &#123; writer-&gt;addStringElement(writer, KSCrashField_Error, "Stack contents not accessible"); &#125; &#125; writer-&gt;endContainer(writer);&#125; 拿到 stack pointer 是直接通过 sp 寄存器： 1234uintptr_t kscpu_stackPointer(const KSMachineContext* const context)&#123; return context-&gt;machineContext.__ss.__rsp;&#125; 拷贝栈上的信息的范围是： 123#define kStackContentsPushedDistance 20#define kStackContentsPoppedDistance 10#define kStackContentsTotalDistance (kStackContentsPushedDistance + kStackContentsPoppedDistance) 这个是作者设置的，也就说是，拷贝栈内 20 个对象，以及刚刚出栈的 10 个对象的地址。在拿到 sp 和范围之后，就可以通过 c 的方法获取： 1234567891011121314static inline int copySafely(const void* restrict const src, void* restrict const dst, const int byteCount)&#123; vm_size_t bytesCopied = 0; kern_return_t result = vm_read_overwrite(mach_task_self(), (vm_address_t)src, (vm_size_t)byteCount, (vm_address_t)dst, &amp;bytesCopied); if(result != KERN_SUCCESS) &#123; return 0; &#125; return (int)bytesCopied;&#125; 取出地址上的对象上面无论是寄存器还是堆栈，取出的都是地址。但是我们其实更需要的是对象的信息。因此，我们还需要到地址上去解析对象信息： 12345678910111213141516static void writeNotableAddresses(const KSCrashReportWriter* const writer, const char* const key, const struct KSMachineContext* const machineContext)&#123; writer-&gt;beginObject(writer, key); &#123; /// 获取 register 上的对象 writeNotableRegisters(writer, machineContext); /// 获取 stack 上的对象 writeNotableStackContents(writer, machineContext, kStackNotableSearchBackDistance, kStackNotableSearchForwardDistance); &#125; writer-&gt;endContainer(writer);&#125; 我们以解析寄存器上的对象为例： 123456789101112131415161718192021222324252627282930static void writeMemoryContents(const KSCrashReportWriter* const writer, const char* const key, const uintptr_t address, int* limit)&#123; (*limit)--; const void* object = (const void*)address; writer-&gt;beginObject(writer, key); &#123; writer-&gt;addUIntegerElement(writer, KSCrashField_Address, address); writeZombieIfPresent(writer, KSCrashField_LastDeallocObject, address); if(!writeObjCObject(writer, address, limit)) &#123; if(object == NULL) &#123; writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_NullPointer); &#125; else if(isValidString(object)) &#123; writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_String); writer-&gt;addStringElement(writer, KSCrashField_Value, (const char*)object); &#125; else &#123; writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_Unknown); &#125; &#125; &#125; writer-&gt;endContainer(writer);&#125; writeObjCObject() 将地址转化为对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static bool writeObjCObject(const KSCrashReportWriter* const writer, const uintptr_t address, int* limit)&#123;#if KSCRASH_HAS_OBJC const void* object = (const void*)address; switch(ksobjc_objectType(object)) &#123; case KSObjCTypeClass: writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_Class); writer-&gt;addStringElement(writer, KSCrashField_Class, ksobjc_className(object)); return true; case KSObjCTypeObject: &#123; writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_Object); const char* className = ksobjc_objectClassName(object); writer-&gt;addStringElement(writer, KSCrashField_Class, className); if(!isRestrictedClass(className)) &#123; switch(ksobjc_objectClassType(object)) &#123; case KSObjCClassTypeString: writeNSStringContents(writer, KSCrashField_Value, address, limit); return true; case KSObjCClassTypeURL: writeURLContents(writer, KSCrashField_Value, address, limit); return true; case KSObjCClassTypeDate: writeDateContents(writer, KSCrashField_Value, address, limit); return true; case KSObjCClassTypeArray: if(*limit &gt; 0) &#123; writeArrayContents(writer, KSCrashField_FirstObject, address, limit); &#125; return true; case KSObjCClassTypeNumber: writeNumberContents(writer, KSCrashField_Value, address, limit); return true; case KSObjCClassTypeDictionary: case KSObjCClassTypeException: // TODO: Implement these. if(*limit &gt; 0) &#123; writeUnknownObjectContents(writer, KSCrashField_Ivars, address, limit); &#125; return true; case KSObjCClassTypeUnknown: if(*limit &gt; 0) &#123; writeUnknownObjectContents(writer, KSCrashField_Ivars, address, limit); &#125; return true; &#125; &#125; break; &#125; case KSObjCTypeBlock: writer-&gt;addStringElement(writer, KSCrashField_Type, KSCrashMemType_Block); const char* className = ksobjc_objectClassName(object); writer-&gt;addStringElement(writer, KSCrashField_Class, className); return true; case KSObjCTypeUnknown: break; &#125;#endif return false;&#125; 这一段代码有点长，先把 address 强转为一个 object，然后判断 object 到底是 tagged pointer 还是 block 还是 OC 类型，还是自建的 Class。根据类型写入相应的信息。 野指针的监控上面的获取地址对象方法中，我们要注意到一个方法 writeZombieIfPresent()。这是 KSCrash 提供的 Zombie，用于监控野指针。我们来看一下它的实现： 1234567891011121314151617181920212223242526272829static void writeZombieIfPresent(const KSCrashReportWriter* const writer, const char* const key, const uintptr_t address)&#123;#if KSCRASH_HAS_OBJC const void* object = (const void*)address; const char* zombieClassName = kszombie_className(object); if(zombieClassName != NULL) &#123; writer-&gt;addStringElement(writer, key, zombieClassName); &#125;#endif&#125;const char* kszombie_className(const void* object)&#123; volatile Zombie* cache = g_zombieCache; if(cache == NULL || object == NULL) &#123; return NULL; &#125; Zombie* zombie = (Zombie*)cache + hashIndex(object); if(zombie-&gt;object == object) &#123; return zombie-&gt;className; &#125; return NULL;&#125; 它的方法非常简洁。就是判断当前 address 上的 object 是否是记录过的对象。这是怎么做到的呢？g_zombieCache 又是什么呢？这就需要回到 KSCrashMonitor_Zombie.c 中查看。 前一篇我们说到，每一个 monitor 会被调用其 setEnabled() 方法启动。Zombie 也不例外。它在 setEnabled() 中调用了 install 方法： 123456789101112131415161718192021222324252627282930313233343536373839static void install()&#123; unsigned cacheSize = CACHE_SIZE; g_zombieHashMask = cacheSize - 1; g_zombieCache = calloc(cacheSize, sizeof(*g_zombieCache)); if(g_zombieCache == NULL) &#123; KSLOG_ERROR("Error: Could not allocate %u bytes of memory. KSZombie NOT installed!", cacheSize * sizeof(*g_zombieCache)); return; &#125; g_lastDeallocedException.class = objc_getClass("NSException"); g_lastDeallocedException.address = NULL; g_lastDeallocedException.name[0] = 0; g_lastDeallocedException.reason[0] = 0; installDealloc_NSObject(); installDealloc_NSProxy();&#125;CREATE_ZOMBIE_HANDLER_INSTALLER(NSObject)CREATE_ZOMBIE_HANDLER_INSTALLER(NSProxy) #define CREATE_ZOMBIE_HANDLER_INSTALLER(CLASS) \static IMP g_originalDealloc_ ## CLASS; \static void handleDealloc_ ## CLASS(id self, SEL _cmd) \&#123; \ handleDealloc(self); \ typedef void (*fn)(id,SEL); \ fn f = (fn)g_originalDealloc_ ## CLASS; \ f(self, _cmd); \&#125; \static void installDealloc_ ## CLASS() \&#123; \ Method method = class_getInstanceMethod(objc_getClass(#CLASS), sel_registerName("dealloc")); \ g_originalDealloc_ ## CLASS = method_getImplementation(method); \ method_setImplementation(method, (IMP)handleDealloc_ ## CLASS); \&#125; 根据代码，我们可以知道，它 hook 了 NSObject 以及 NSProxy 的 dealloc 方法。先调用自己的处理方法 handleDealloc() 然后再调用原来的 dealloc 方法。注意这里调用原来 dealloc 方法的实现，这样做的原因我在 JSPatch 中有分析过，这里不做赘述了： 123typedef void (*fn)(id,SEL); \fn f = (fn)g_originalDealloc_ ## CLASS; \f(self, _cmd); \ 再来看 handleDealloc() 方法： 123456789101112131415161718192021static inline void handleDealloc(const void* self)&#123; volatile Zombie* cache = g_zombieCache; likely_if(cache != NULL) &#123; /// 把要销毁的对象保存在 cache 中。 /// hashIndex 就是对要销毁对象求 hash，找到它在 cache 中应该存在的位置 Zombie* zombie = (Zombie*)cache + hashIndex(self); zombie-&gt;object = self; Class class = object_getClass((id)self); zombie-&gt;className = class_getName(class); for(; class != nil; class = class_getSuperclass(class)) &#123; /// 如果要销毁的是 NSException，那么把它保存起来 unlikely_if(class == g_lastDeallocedException.class) &#123; storeException(self); &#125; &#125; &#125;&#125; 在 install 的时候的时候创建了一个空的 Cache： 1g_zombieCache = calloc(cacheSize, sizeof(*g_zombieCache)); 在处理 dealloc 的时候，会把对象的地址放到这个 Zombie 的 cache 中。这样的作用就是对于已经销毁的对象，我们记录了一份它们的地址信息，这样以后出现野指针 crash 的时候，如果发现是 zombie 中指向的对象，那么就可以说明它被提前释放了。当然，这并不是非常准确的，因为 hash 获取 index 的方式总是会产生一定的碰撞导致对象被覆盖。当然不可否认这是一种经济有效的测试野指针的方式。作者自己都在注释中说明这是一种 Poor man’s Zombie tracking XD 123456789101112/* Poor man's zombie tracking. * * Benefits: * - Very low CPU overhead. * - Low memory overhead. * * Limitations: * - Not guaranteed to catch all zombies. * - Can generate false positives or incorrect class names. * - KSZombie itself must be compiled with ARC disabled. You can enable ARC in * your app, but KSZombie must be compiled in a separate library if you do. */ 总结到这里，KSCrash 的中篇结束了。这一篇因为涉及的方法和 API 太多，而且很多都是之前研究 fishhook 的时候解释过的，所以我对这部分内容的解释会显得比较少。当然，对于一般的开发者来说，掌握其中的基本原理就已经足够了，对于其中很多 c 相关的 API 以及写法没有必要纠结太深。 KSCrash 分析的部分应该就是这样了。在 KSCrash 下中，我打算去了解一下腾讯开源的 Matrix 中内存预警相关的原理。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Crash 收集框架 KSCrash 源码解析(上)]]></title>
    <url>%2F2019%2F10%2F25%2Fkscrash%2F</url>
    <content type="text"><![CDATA[KSCrash 是 iOS 上一个知名的 crash 收集框架。包括腾讯刚开源的 APM 框架 Matrix，其中 crash 收集部分也是直接使用的 KSCrash。那么 KSCrash 到底是如何进行 crash 收集的呢？ 总体结构总体结构如下图： 可以看到总共分为三大部分： Crash Recording Crash Reporting Installation 其中 Installation 用来启动 KSCrash，并且指定了 Crash 收集的方式。Crash 收集方式可以包括：邮件发送，向指定服务器发送，向专门的 Crash 收集服务器发送等方式。每种方式对应于一个实现类： Crash Reporting 包含了三个子文件夹，分别是 Filter，Sink 和 Tools，主要用来上报 Crash。本文不会对其做具体的研究。 其中 Filter 包含了将存储在设备上的 Crash 信息的 NSData 转为 NSString，JSON，GZip 等几种方式的实现类。 Sink 则是不同发送方式的真正的处理者，和 Installation 中的几种收集方式一一对应。 Tools 是一些工具类，以及发送请求相关的类的合集。 最最关键的还是要数 Crash Recording，它包含了捕捉各种类型 crash 的方式，将会在下文中做详细介绍。 基本使用以官方 Demo 中的 Simple-Example 为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@implementation AppDelegate- (BOOL) application:(__unused UIApplication *) applicationdidFinishLaunchingWithOptions:(__unused NSDictionary *) launchOptions &#123; [self installCrashHandler]; return YES;&#125;- (void) installCrashHandler &#123; /// 👇是各种 crash 收集方式，选择一种使用// KSCrashInstallation* installation = [self makeStandardInstallation]; KSCrashInstallation* installation = [self makeEmailInstallation];// KSCrashInstallation* installation = [self makeHockeyInstallation];// KSCrashInstallation* installation = [self makeQuincyInstallation];// KSCrashInstallation *installation = [self makeVictoryInstallation]; /// 注册 crash handler [installation install]; /// 发送所有的 crash 日志 [installation sendAllReportsWithCompletion:^(NSArray* reports, BOOL completed, NSError* error) &#123; if(completed) &#123; NSLog(@"Sent %d reports", (int)[reports count]); &#125; else &#123; NSLog(@"Failed to send reports: %@", error); &#125; &#125;];&#125;- (KSCrashInstallation*) makeEmailInstallation &#123; NSString* emailAddress = @"your@email.here"; KSCrashInstallationEmail* email = [KSCrashInstallationEmail sharedInstance]; email.recipients = @[emailAddress]; email.subject = @"Crash Report" email.message = @"This is a crash report"; email.filenameFmt = @"crash-report-%d.txt.gz"; [email addConditionalAlertWithTitle:@"Crash Detected" message:@"The app crashed last time it was launched. Send a crash report?" yesAnswer:@"Sure!" noAnswer:@"No thanks"]; // Uncomment to send Apple style reports instead of JSON. [email setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES]; return email;&#125;@end 如上面代码所示，在 AppDelegate 中注册 KSCrash。在注册 handler 期间，通过工厂模式选择一个上传方式的 installation 进行实例化。不同的 installation 会有不同的处理，比如上面的 email 上传方式，那就需要提供邮箱地址。 不同的 installation 有不同的上床日志的方式，但是它们注册监听的方式都是一样的。它们都继承于基类 KSCrashInstallation，在基类中有统一的 install 方法。 开启 Crash 监控在 install 的过程中，installation 创建了一个单例对象 KSCrash，并且调用它的 install 方法： 12345678910// KSCrash.m/// 开启监控- (BOOL) install &#123; _monitoring = kscrash_install(self.bundleName.UTF8String, self.basePath.UTF8String); if(self.monitoring == 0) &#123; return false; &#125; return true;&#125; 它又调用了 c 方法 kscrash_install，这个方法在 KSCrashC.c 中： 12345678910111213/// 真正开始的方法, 创建一个 monitorKSCrashMonitorType kscrash_install(const char* appName, const char* const installPath) &#123; /// 省略了一些基本设置，包括路径名，文件名等 ... /// 设置状态为已启动 g_installed = 1; /// 给 monitor 设置回调 kscm_setEventCallback(onCrash); /// 设置 monitor KSCrashMonitorType monitors = kscrash_setMonitoring(g_monitoring); return monitors;&#125; 设置回调函数 onCrash 的部分我们也后面再看。先来看设置 monitor 的部分： 12345678910111213/// 设置 monitorKSCrashMonitorType kscrash_setMonitoring(KSCrashMonitorType monitors)&#123; g_monitoring = monitors; if(g_installed) &#123; kscm_setActiveMonitors(monitors); return kscm_getActiveMonitors(); &#125; // Return what we will be monitoring in future. return g_monitoring;&#125; 由于前面设置了 g_installed ，因此，这里就会通过 kscm_setActiveMonitors() 这个方法激活 monitor。这是整个激活步骤的核心方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void kscm_setActiveMonitors(KSCrashMonitorType monitorTypes)&#123; /// 进程是否在调试中，调试中的应用只记录 Mach Signal C++ OC 的 crash if(ksdebug_isBeingTraced() &amp;&amp; (monitorTypes &amp; KSCrashMonitorTypeDebuggerUnsafe)) &#123; static bool hasWarned = false; if(!hasWarned) &#123; hasWarned = true; KSLOGBASIC_WARN(" ************************ Crash Handler Notice ************************"); KSLOGBASIC_WARN(" * App is running in a debugger. Masking out unsafe monitors. *"); KSLOGBASIC_WARN(" * This means that most crashes WILL NOT BE RECORDED while debugging! *"); KSLOGBASIC_WARN(" **********************************************************************"); &#125; monitorTypes &amp;= KSCrashMonitorTypeDebuggerSafe; &#125; /// 是否需要线程安全，只有 Mach 和 Signal 异常是线程安全的 if(g_requiresAsyncSafety &amp;&amp; (monitorTypes &amp; KSCrashMonitorTypeAsyncUnsafe)) &#123; KSLOG_DEBUG("Async-safe environment detected. Masking out unsafe monitors."); monitorTypes &amp;= KSCrashMonitorTypeAsyncSafe; &#125; KSLOG_DEBUG("Changing active monitors from 0x%x tp 0x%x.", g_activeMonitors, monitorTypes); KSCrashMonitorType activeMonitors = KSCrashMonitorTypeNone; for(int i = 0; i &lt; g_monitorsCount; i++) &#123; Monitor* monitor = &amp;g_monitors[i]; bool isEnabled = monitor-&gt;monitorType &amp; monitorTypes; /// 开启相应的 monitor setMonitorEnabled(monitor, isEnabled); if(isMonitorEnabled(monitor)) &#123; activeMonitors |= monitor-&gt;monitorType; &#125; else &#123; activeMonitors &amp;= ~monitor-&gt;monitorType; &#125; &#125; KSLOG_DEBUG("Active monitors are now 0x%x.", activeMonitors); g_activeMonitors = activeMonitors;&#125; 先来看入参，外部传入的 g_monitoring 默认值为 KSCrashMonitorTypeProductionSafeMinimal，它的定义如下： 12#define KSCrashMonitorTypeProductionSafe (KSCrashMonitorTypeAll &amp; (~KSCrashMonitorTypeExperimental))#define KSCrashMonitorTypeProductionSafeMinimal (KSCrashMonitorTypeProductionSafe &amp; (~KSCrashMonitorTypeOptional)) 再来看 KSCrashMonitorTypeAll 的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef enum&#123; /* Captures and reports Mach exceptions. */ KSCrashMonitorTypeMachException = 0x01, /* Captures and reports POSIX signals. */ KSCrashMonitorTypeSignal = 0x02, /* Captures and reports C++ exceptions. * Note: This will slightly slow down exception processing. */ KSCrashMonitorTypeCPPException = 0x04, /* Captures and reports NSExceptions. */ KSCrashMonitorTypeNSException = 0x08, /* Detects and reports a deadlock in the main thread. */ KSCrashMonitorTypeMainThreadDeadlock = 0x10, /* Accepts and reports user-generated exceptions. */ KSCrashMonitorTypeUserReported = 0x20, /* Keeps track of and injects system information. */ KSCrashMonitorTypeSystem = 0x40, /* Keeps track of and injects application state. */ KSCrashMonitorTypeApplicationState = 0x80, /* Keeps track of zombies, and injects the last zombie NSException. */ KSCrashMonitorTypeZombie = 0x100,&#125; KSCrashMonitorType;#define KSCrashMonitorTypeAll \( \ KSCrashMonitorTypeMachException | \ KSCrashMonitorTypeSignal | \ KSCrashMonitorTypeCPPException | \ KSCrashMonitorTypeNSException | \ KSCrashMonitorTypeMainThreadDeadlock | \ KSCrashMonitorTypeUserReported | \ KSCrashMonitorTypeSystem | \ KSCrashMonitorTypeApplicationState | \ KSCrashMonitorTypeZombie \) 可以看到，all 代表的就是所有异常方式： Mach 异常 Signal 异常 C++ 异常 OC 异常 死锁 用户抛出的异常 设置 monitor 的时候，会判断是否在被调试，这是通过 sysctl 获取进程的信息的方式来进行判断的： 123456789101112131415161718/// 是否在被调试bool ksdebug_isBeingTraced(void)&#123; /// 查询进程信息结果的结构体 struct kinfo_proc procInfo; size_t structSize = sizeof(procInfo); int mib[] = &#123;CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()&#125;; /// 通过 sysctl 获取进程信息 if(sysctl(mib, sizeof(mib)/sizeof(*mib), &amp;procInfo, &amp;structSize, NULL, 0) != 0) &#123; KSLOG_ERROR("sysctl: %s", strerror(errno)); return false; &#125; /// 通过进程信息判断是否被调试 return (procInfo.kp_proc.p_flag &amp; P_TRACED) != 0;&#125; 最终通过 for 循环，遍历启动每一个 monitor。启动某个 monitor 的方法如下： 12345678910/// 启动某个 monitorstatic inline void setMonitorEnabled(Monitor* monitor, bool isEnabled)&#123; KSCrashMonitorAPI* api = getAPI(monitor); /// 调用各个 monitor 的 enable 方法，启动 monitor if(api != NULL &amp;&amp; api-&gt;setEnabled != NULL) &#123; api-&gt;setEnabled(isEnabled); &#125;&#125; Monitor 是一个结构体，它保存了 Monitor 的类型以及启动 monitor 的方法： 123456/// monitor 的数据结构typedef struct&#123; KSCrashMonitorType monitorType; KSCrashMonitorAPI* (*getAPI)(void);&#125; Monitor; 也就是说，每一种异常都会有一个自己的 setEnabled() 方法，用于启动自身。 Mach 异常开启捕获Mach 异常在 KSCrashMonitor_MachException.c 中被处理外部调用 setEnabled() 开启 Mach 异常的监听： 1234567891011121314151617181920static void setEnabled(bool isEnabled)&#123; if(isEnabled != g_isEnabled) &#123; g_isEnabled = isEnabled; if(isEnabled) &#123; ksid_generate(g_primaryEventID); ksid_generate(g_secondaryEventID); if(!installExceptionHandler()) &#123; return; &#125; &#125; else &#123; uninstallExceptionHandler(); &#125; &#125;&#125; 其中包含两个 c 函数，installExceptionHandler() 和 uninstallExceptionHandler() 分别用于开启和关闭监听。 在说如何捕捉 Mach 异常前，先说一下什么是 Mach。Mach:[mʌk]，是一种操作系统微内核，是许多新操作系统的设计基础。 Mach微内核中有几个基础概念： Tasks，拥有一组系统资源的对象，允许”thread”在其中执行。每一个BSD 进程都在底层关联了一个Mach 任务对象(BSD 层在 Mach 之上，提供了更高层次的功能，比如 UNIX 进程模型，POSIX 线程模型等) Threads，执行的基本单位，拥有task的上下文，并共享其资源。 Ports，task之间通讯的一组受保护的消息队列；task可对任何port发送/接收数据。 Message，有类型的数据对象集合，只可以发送到port。 关于什么是微内核？微内核把系统服务，比如文件管理、虚拟内存、设备I/O，单独包装为一个个模块。微内核作为底层使用进程间通信收发消息。这一来大量的内核代码可以转移到用户空间，使内核变得更小。这种方式拓展性强，但是通信有效率损耗。宏内核正相反，把所有系统服务放在一起。 UNIX 下，触发到内核态需要通过系统调用触发陷阱。Mach 可以通过申请 port，然后利用IPC机制向这个port发送消息。 陷阱是软中断，是主动触发的，立刻同步处理。异常是当前指令执行出现问题，是被动的，立刻同步处理。中断是外部硬件触发的，是异步的。 回到 Mach 异常的注册方法中，我们要知道，当异常发生时，内核会向当前 task 的某个专门处理异常的 port 发消息，该消息会依次被转为 signal，NSException 抛出。如果我们要在 Mach 层捕获异常，就需要注册自己的 port，来接收这个异常： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/// 创建 mach 捕捉者static bool installExceptionHandler()&#123; KSLOG_DEBUG("Installing mach exception handler."); bool attributes_created = false; pthread_attr_t attr; kern_return_t kr; int error; /// 获取当前进程的 task const task_t thisTask = mach_task_self(); exception_mask_t mask = EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT; KSLOG_DEBUG("Backing up original exception ports."); /// 保存之前的异常处理端口到 g_previousExceptionPorts 中 kr = task_get_exception_ports(thisTask, mask, g_previousExceptionPorts.masks, &amp;g_previousExceptionPorts.count, g_previousExceptionPorts.ports, g_previousExceptionPorts.behaviors, g_previousExceptionPorts.flavors); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR("task_get_exception_ports: %s", mach_error_string(kr)); goto failed; &#125; /// 如果自己的异常处理端口 g_exceptionPort 是空的，那么创建 if(g_exceptionPort == MACH_PORT_NULL) &#123; KSLOG_DEBUG("Allocating new port with receive rights."); /// 创建新的异常处理端口 kr = mach_port_allocate(thisTask, MACH_PORT_RIGHT_RECEIVE, &amp;g_exceptionPort); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR("mach_port_allocate: %s", mach_error_string(kr)); goto failed; &#125; KSLOG_DEBUG("Adding send rights to port."); /// 申请端口权限 kr = mach_port_insert_right(thisTask, g_exceptionPort, g_exceptionPort, MACH_MSG_TYPE_MAKE_SEND); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR("mach_port_insert_right: %s", mach_error_string(kr)); goto failed; &#125; &#125; KSLOG_DEBUG("Installing port as exception handler."); /// 把异常设置为自己的 port kr = task_set_exception_ports(thisTask, mask, g_exceptionPort, (int)(EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES), THREAD_STATE_NONE); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR("task_set_exception_ports: %s", mach_error_string(kr)); goto failed; &#125; KSLOG_DEBUG("Creating secondary exception thread (suspended)."); /// 以下整个部分用来创建读取异常端口数据的线程,设置异常端口的处理函数 pthread_attr_init(&amp;attr); attributes_created = true; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); /// 创建第二条处理crash的线程，以防主z处理crash的线程crash了 error = pthread_create(&amp;g_secondaryPThread, &amp;attr, &amp;handleExceptions, kThreadSecondary); if(error != 0) &#123; KSLOG_ERROR("pthread_create_suspended_np: %s", strerror(error)); goto failed; &#125; g_secondaryMachThread = pthread_mach_thread_np(g_secondaryPThread); ksmc_addReservedThread(g_secondaryMachThread); KSLOG_DEBUG("Creating primary exception thread."); /// 创建主处理crash的线程 error = pthread_create(&amp;g_primaryPThread, &amp;attr, &amp;handleExceptions, kThreadPrimary); if(error != 0) &#123; KSLOG_ERROR("pthread_create: %s", strerror(error)); goto failed; &#125; pthread_attr_destroy(&amp;attr); g_primaryMachThread = pthread_mach_thread_np(g_primaryPThread); ksmc_addReservedThread(g_primaryMachThread); KSLOG_DEBUG("Mach exception handler installed."); return true;failed: KSLOG_DEBUG("Failed to install mach exception handler."); if(attributes_created) &#123; pthread_attr_destroy(&amp;attr); &#125; uninstallExceptionHandler(); return false;&#125; 代码很长，关键地方做了注释： 通过 mach_task_self() 获取当前进程对应的 task。 通过 task_get_exception_ports() 获取原本处理异常的 port，并保存在 g_previousExceptionPorts 中。 通过 mach_port_allocate() 创建新的异常处理端口。 通过 mach_port_insert_right() 给这个新创建的端口申请权限 通过 task_set_exception_ports() 把异常接收的 port 设置为自己新创建的 port 创建好 port 之后，就可以创建自己的线程去一直读取 port 上的消息了。通过 pthread_create() 创建自己的线程，以及设置好执行的方法为 handleExceptions。 处理异常现在就是关键的处理方法 handleExceptions() 了。这也是一个非常长的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/// 处理 Exceptionstatic void* handleExceptions(void* const userData)&#123; MachExceptionMessage exceptionMessage = &#123;&#123;0&#125;&#125;; MachReplyMessage replyMessage = &#123;&#123;0&#125;&#125;; char* eventID = g_primaryEventID; const char* threadName = (const char*) userData; pthread_setname_np(threadName); if(threadName == kThreadSecondary) &#123; KSLOG_DEBUG("This is the secondary thread. Suspending."); thread_suspend((thread_t)ksthread_self()); eventID = g_secondaryEventID; &#125; for(;;) &#123; KSLOG_DEBUG("Waiting for mach exception"); // Wait for a message. /// 不断调用 mach_msg 接收消息，从异常端口中读取信息到 exceptionMessage 中 kern_return_t kr = mach_msg(&amp;exceptionMessage.header, MACH_RCV_MSG, 0, sizeof(exceptionMessage), g_exceptionPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); /// 上面一直循环读取，直到读取成功了，进入后面的处理函数中 if(kr == KERN_SUCCESS) &#123; break; &#125; // Loop and try again on failure. KSLOG_ERROR("mach_msg: %s", mach_error_string(kr)); &#125; KSLOG_DEBUG("Trapped mach exception code 0x%llx, subcode 0x%llx", exceptionMessage.code[0], exceptionMessage.code[1]); if(g_isEnabled) &#123; thread_act_array_t threads = NULL; mach_msg_type_number_t numThreads = 0; /// 暂停所有非当前线程以及白名单线程的线程 ksmc_suspendEnvironment(&amp;threads, &amp;numThreads); g_isHandlingCrash = true; /// 捕捉到异常之后清除所有的 monitor kscm_notifyFatalExceptionCaptured(true); KSLOG_DEBUG("Exception handler is installed. Continuing exception handling."); // Switch to the secondary thread if necessary, or uninstall the handler // to avoid a death loop. /// 捕捉到 exception 后，恢复原来的 port if(ksthread_self() == g_primaryMachThread) &#123; KSLOG_DEBUG("This is the primary exception thread. Activating secondary thread.");// TODO: This was put here to avoid a freeze. Does secondary thread ever fire? restoreExceptionPorts(); if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS) &#123; KSLOG_DEBUG("Could not activate secondary thread. Restoring original exception ports."); &#125; &#125; else &#123; KSLOG_DEBUG("This is the secondary exception thread.");// Restoring original exception ports.");// restoreExceptionPorts(); &#125; // Fill out crash information /// 设置 crash 信息的 context KSLOG_DEBUG("Fetching machine state."); /// 创建一个 machineContext 用来保存异常信息 KSMC_NEW_CONTEXT(machineContext); KSCrash_MonitorContext* crashContext = &amp;g_monitorContext; crashContext-&gt;offendingMachineContext = machineContext; /// 创建一个遍历调用栈的 cursor kssc_initCursor(&amp;g_stackCursor, NULL, NULL); /// 把线程信息附加到 machineContext 上 if(ksmc_getContextForThread(exceptionMessage.thread.name, machineContext, true)) &#123; kssc_initWithMachineContext(&amp;g_stackCursor, 100, machineContext); KSLOG_TRACE("Fault address %p, instruction address %p", kscpu_faultAddress(machineContext), kscpu_instructionAddress(machineContext)); if(exceptionMessage.exception == EXC_BAD_ACCESS) &#123; crashContext-&gt;faultAddress = kscpu_faultAddress(machineContext); &#125; else &#123; crashContext-&gt;faultAddress = kscpu_instructionAddress(machineContext); &#125; &#125; KSLOG_DEBUG("Filling out context."); crashContext-&gt;crashType = KSCrashMonitorTypeMachException; crashContext-&gt;eventID = eventID; crashContext-&gt;registersAreValid = true; crashContext-&gt;mach.type = exceptionMessage.exception; crashContext-&gt;mach.code = exceptionMessage.code[0] &amp; (int64_t)MACH_ERROR_CODE_MASK; crashContext-&gt;mach.subcode = exceptionMessage.code[1] &amp; (int64_t)MACH_ERROR_CODE_MASK; if(crashContext-&gt;mach.code == KERN_PROTECTION_FAILURE &amp;&amp; crashContext-&gt;isStackOverflow) &#123; // A stack overflow should return KERN_INVALID_ADDRESS, but // when a stack blasts through the guard pages at the top of the stack, // it generates KERN_PROTECTION_FAILURE. Correct for this. crashContext-&gt;mach.code = KERN_INVALID_ADDRESS; &#125; /// 将 mach 异常转为对应的 signal crashContext-&gt;signal.signum = signalForMachException(crashContext-&gt;mach.type, crashContext-&gt;mach.code); crashContext-&gt;stackCursor = &amp;g_stackCursor; /// context 交给 kscrashmonitor 处理 kscm_handleException(crashContext); KSLOG_DEBUG("Crash handling complete. Restoring original handlers."); g_isHandlingCrash = false; /// 结束了捕获恢复所有线程 ksmc_resumeEnvironment(threads, numThreads); &#125; KSLOG_DEBUG("Replying to mach exception message."); // Send a reply saying "I didn't handle this exception". replyMessage.header = exceptionMessage.header; replyMessage.NDR = exceptionMessage.NDR; replyMessage.returnCode = KERN_FAILURE; /// 发消息告知没有处理这个异常 mach_msg(&amp;replyMessage.header, MACH_SEND_MSG, sizeof(replyMessage), 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); return NULL;&#125; 整体的处理方式如下： 不停循环通过 mach_msg() 读取 port 中传来的消息。 读取成功后挂起所有线程。 清除所有的 monitor，恢复原来的 port 抓取所有线程的信息保存到 KSMachineContext 结构体中 将各种信息交给 crashContext 把 crashContext 抛出给外部处理方法 恢复所有的线程 通过 mach_msg() 再发出一个消息告知没有处理这个异常 通过方法 task_threads() 获取当前 task 的所有线程，通过 thread_suspend() 方法挂起某个线程： 123456789101112131415161718192021222324252627282930313233/// suspend 当前 task 内非处理 crash 或者白名单内的线程。void ksmc_suspendEnvironment(thread_act_array_t *suspendedThreads, mach_msg_type_number_t *numSuspendedThreads)&#123;#if KSCRASH_HAS_THREADS_API KSLOG_DEBUG("Suspending environment."); kern_return_t kr; const task_t thisTask = mach_task_self(); const thread_t thisThread = (thread_t)ksthread_self(); /// 获取当前task的所有thread if((kr = task_threads(thisTask, suspendedThreads, numSuspendedThreads)) != KERN_SUCCESS) &#123; KSLOG_ERROR("task_threads: %s", mach_error_string(kr)); return; &#125; /// 遍历所有 thread，如果不是当前处理 crash 的 thread，以及要保留的 thread 就直接 suspend 它们 for(mach_msg_type_number_t i = 0; i &lt; *numSuspendedThreads; i++) &#123; thread_t thread = (*suspendedThreads)[i]; if(thread != thisThread &amp;&amp; !isThreadInList(thread, g_reservedThreads, g_reservedThreadsCount)) &#123; if((kr = thread_suspend(thread)) != KERN_SUCCESS) &#123; // Record the error and keep going. KSLOG_ERROR("thread_suspend (%08x): %s", thread, mach_error_string(kr)); &#125; &#125; &#125; KSLOG_DEBUG("Suspend complete.");#endif&#125; 通过 task_threads() 方法获取所有的 thread： 1234567891011121314151617181920212223242526272829303132333435363738/// 获取当前 task 所有的 thread，把它保存到 context 中static inline bool getThreadList(KSMachineContext* context)&#123; const task_t thisTask = mach_task_self(); KSLOG_DEBUG("Getting thread list"); kern_return_t kr; thread_act_array_t threads; mach_msg_type_number_t actualThreadCount; /// task_thread 获取所有的 thread if((kr = task_threads(thisTask, &amp;threads, &amp;actualThreadCount)) != KERN_SUCCESS) &#123; KSLOG_ERROR("task_threads: %s", mach_error_string(kr)); return false; &#125; KSLOG_TRACE("Got %d threads", context-&gt;threadCount); int threadCount = (int)actualThreadCount; int maxThreadCount = sizeof(context-&gt;allThreads) / sizeof(context-&gt;allThreads[0]); if(threadCount &gt; maxThreadCount) &#123; KSLOG_ERROR("Thread count %d is higher than maximum of %d", threadCount, maxThreadCount); threadCount = maxThreadCount; &#125; for(int i = 0; i &lt; threadCount; i++) &#123; /// 把 thread 保存到 context 中 context-&gt;allThreads[i] = threads[i]; &#125; context-&gt;threadCount = threadCount; for(mach_msg_type_number_t i = 0; i &lt; actualThreadCount; i++) &#123; mach_port_deallocate(thisTask, context-&gt;allThreads[i]); &#125; vm_deallocate(thisTask, (vm_address_t)threads, sizeof(thread_t) * actualThreadCount); return true;&#125; 恢复线程的时候，使用相应的 thread_resume() 方法即可： 12345678910111213141516171819202122232425262728293031323334353637/// 恢复所有线程void ksmc_resumeEnvironment(thread_act_array_t threads, mach_msg_type_number_t numThreads)&#123;#if KSCRASH_HAS_THREADS_API KSLOG_DEBUG("Resuming environment."); kern_return_t kr; const task_t thisTask = mach_task_self(); const thread_t thisThread = (thread_t)ksthread_self(); if(threads == NULL || numThreads == 0) &#123; KSLOG_ERROR("we should call ksmc_suspendEnvironment() first"); return; &#125; for(mach_msg_type_number_t i = 0; i &lt; numThreads; i++) &#123; thread_t thread = threads[i]; if(thread != thisThread &amp;&amp; !isThreadInList(thread, g_reservedThreads, g_reservedThreadsCount)) &#123; if((kr = thread_resume(thread)) != KERN_SUCCESS) &#123; // Record the error and keep going. KSLOG_ERROR("thread_resume (%08x): %s", thread, mach_error_string(kr)); &#125; &#125; &#125; for(mach_msg_type_number_t i = 0; i &lt; numThreads; i++) &#123; mach_port_deallocate(thisTask, threads[i]); &#125; vm_deallocate(thisTask, (vm_address_t)threads, sizeof(thread_t) * numThreads); KSLOG_DEBUG("Resume complete.");#endif&#125; 所有 Mach 异常都在 BSD 层被 ux_exception 转换为相应的 Unix 信号，并通过 threadsignal 将信号投递到出错的线程。在 Mach 层，我们可以直接通过 Mach 异常推测出 Signal 类型： 123456789101112131415161718192021222324252627282930313233// 将 mach 转为 signalstatic int signalForMachException(exception_type_t exception, mach_exception_code_t code)&#123; switch(exception) &#123; case EXC_ARITHMETIC: return SIGFPE; case EXC_BAD_ACCESS: return code == KERN_INVALID_ADDRESS ? SIGSEGV : SIGBUS; case EXC_BAD_INSTRUCTION: return SIGILL; case EXC_BREAKPOINT: return SIGTRAP; case EXC_EMULATION: return SIGEMT; case EXC_SOFTWARE: &#123; switch (code) &#123; case EXC_UNIX_BAD_SYSCALL: return SIGSYS; case EXC_UNIX_BAD_PIPE: return SIGPIPE; case EXC_UNIX_ABORT: return SIGABRT; case EXC_SOFT_SIGNAL: return SIGKILL; &#125; break; &#125; &#125; return 0;&#125; 取消监听在捕获到异常后就要取消原本的监听，主要分为两步： 将原本用作监听异常的 port 恢复 结束自己创建的用于处理异常的线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static void uninstallExceptionHandler()&#123; KSLOG_DEBUG("Uninstalling mach exception handler."); // NOTE: Do not deallocate the exception port. If a secondary crash occurs // it will hang the process. /// 恢复原本的mach处理端口 restoreExceptionPorts(); thread_t thread_self = (thread_t)ksthread_self(); /// 当前不是 primary 处理 crash 的线程，那么终止线程 if(g_primaryPThread != 0 &amp;&amp; g_primaryMachThread != thread_self) &#123; KSLOG_DEBUG("Canceling primary exception thread."); if(g_isHandlingCrash) &#123; thread_terminate(g_primaryMachThread); &#125; else &#123; pthread_cancel(g_primaryPThread); &#125; g_primaryMachThread = 0; g_primaryPThread = 0; &#125; /// 当前不是备用处理 crash 的线程，那么终止线程 if(g_secondaryPThread != 0 &amp;&amp; g_secondaryMachThread != thread_self) &#123; KSLOG_DEBUG("Canceling secondary exception thread."); if(g_isHandlingCrash) &#123; thread_terminate(g_secondaryMachThread); &#125; else &#123; pthread_cancel(g_secondaryPThread); &#125; g_secondaryMachThread = 0; g_secondaryPThread = 0; &#125; g_exceptionPort = MACH_PORT_NULL; KSLOG_DEBUG("Mach exception handlers uninstalled.");&#125;/// 恢复原本的 mach 处理端口static void restoreExceptionPorts(void)&#123; KSLOG_DEBUG("Restoring original exception ports."); if(g_previousExceptionPorts.count == 0) &#123; KSLOG_DEBUG("Original exception ports were already restored."); return; &#125; const task_t thisTask = mach_task_self(); kern_return_t kr; // Reinstall old exception ports. for(mach_msg_type_number_t i = 0; i &lt; g_previousExceptionPorts.count; i++) &#123; KSLOG_TRACE("Restoring port index %d", i); /// 将 port 设置为原来的 kr = task_set_exception_ports(thisTask, g_previousExceptionPorts.masks[i], g_previousExceptionPorts.ports[i], g_previousExceptionPorts.behaviors[i], g_previousExceptionPorts.flavors[i]); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR("task_set_exception_ports: %s", mach_error_string(kr)); &#125; &#125; KSLOG_DEBUG("Exception ports restored."); g_previousExceptionPorts.count = 0;&#125; Signal 异常前面说过，Mach 异常会在 BSD 层转化为相应的 UNIX 信号，投递到相应的线程中。我们同样可以捕捉相应的 Signal。 开启捕获同样是调用 setEnabled() 方法，它会执行到 installSignalHandler() 方法中。相关的参数设置比较多，坦白来说确实不太好理解它们的作用，不过其实粗略的看下来也不影响对于主流程的理解。总的来说就是通过 sigaction() 方法记录下某个 siganl 对应的处理方法，并且保存先前的处理方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/// 创建 signal 的捕捉者static bool installSignalHandler()&#123; KSLOG_DEBUG("Installing signal handler.");#if KSCRASH_HAS_SIGNAL_STACK if(g_signalStack.ss_size == 0) &#123; KSLOG_DEBUG("Allocating signal stack area."); g_signalStack.ss_size = SIGSTKSZ; g_signalStack.ss_sp = malloc(g_signalStack.ss_size); &#125; KSLOG_DEBUG("Setting signal stack area."); if(sigaltstack(&amp;g_signalStack, NULL) != 0) &#123; KSLOG_ERROR("signalstack: %s", strerror(errno)); goto failed; &#125;#endif /// 需要监听的 signal 数组 const int* fatalSignals = kssignal_fatalSignals(); /// 需要监听的 signal 数组大小 int fatalSignalsCount = kssignal_numFatalSignals(); if(g_previousSignalHandlers == NULL) &#123; KSLOG_DEBUG("Allocating memory to store previous signal handlers."); g_previousSignalHandlers = malloc(sizeof(*g_previousSignalHandlers) * (unsigned)fatalSignalsCount); &#125; struct sigaction action = &#123;&#123;0&#125;&#125;; action.sa_flags = SA_SIGINFO | SA_ONSTACK;#if KSCRASH_HOST_APPLE &amp;&amp; defined(__LP64__) action.sa_flags |= SA_64REGSET;#endif sigemptyset(&amp;action.sa_mask); action.sa_sigaction = &amp;handleSignal; for(int i = 0; i &lt; fatalSignalsCount; i++) &#123; KSLOG_DEBUG("Assigning handler for signal %d", fatalSignals[i]); /// 设置该 signal 对应的处理方法，并且保存原始的处理方法 if(sigaction(fatalSignals[i], &amp;action, &amp;g_previousSignalHandlers[i]) != 0) &#123; /// 设置失败的时候走下面的方法 char sigNameBuff[30]; const char* sigName = kssignal_signalName(fatalSignals[i]); if(sigName == NULL) &#123; snprintf(sigNameBuff, sizeof(sigNameBuff), "%d", fatalSignals[i]); sigName = sigNameBuff; &#125; KSLOG_ERROR("sigaction (%s): %s", sigName, strerror(errno)); // Try to reverse the damage for(i--;i &gt;= 0; i--) &#123; sigaction(fatalSignals[i], &amp;g_previousSignalHandlers[i], NULL); &#125; goto failed; &#125; &#125; KSLOG_DEBUG("Signal handlers installed."); return true;failed: KSLOG_DEBUG("Failed to install signal handlers."); return false;&#125; fatal_signal 包括如下： 1234567891011static const int g_fatalSignals[] =&#123; SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGPIPE, SIGSEGV, SIGSYS, SIGTRAP,&#125;; 处理异常处理异常的回调方法中会返回 signal 信息，以及一个 context： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void handleSignal(int sigNum, siginfo_t* signalInfo, void* userContext)&#123; KSLOG_DEBUG("Trapped signal %d", sigNum); if(g_isEnabled) &#123; thread_act_array_t threads = NULL; mach_msg_type_number_t numThreads = 0; /// 暂停线程 ksmc_suspendEnvironment(&amp;threads, &amp;numThreads); /// 通知已经捕获到异常了 kscm_notifyFatalExceptionCaptured(false); KSLOG_DEBUG("Filling out context."); KSMC_NEW_CONTEXT(machineContext); /// 保存 context 到 machineContext 中，并且获取 thread 信息 ksmc_getContextForSignal(userContext, machineContext); /// 把 machineContext 放到 g_stackCursor 中 kssc_initWithMachineContext(&amp;g_stackCursor, 100, machineContext); /// 生成真正的 context KSCrash_MonitorContext* crashContext = &amp;g_monitorContext; memset(crashContext, 0, sizeof(*crashContext)); crashContext-&gt;crashType = KSCrashMonitorTypeSignal; crashContext-&gt;eventID = g_eventID; crashContext-&gt;offendingMachineContext = machineContext; crashContext-&gt;registersAreValid = true; crashContext-&gt;faultAddress = (uintptr_t)signalInfo-&gt;si_addr; crashContext-&gt;signal.userContext = userContext; crashContext-&gt;signal.signum = signalInfo-&gt;si_signo; crashContext-&gt;signal.sigcode = signalInfo-&gt;si_code; crashContext-&gt;stackCursor = &amp;g_stackCursor; /// 把 context 传给外部处理函数 kscm_handleException(crashContext); /// 恢复原来的环境 ksmc_resumeEnvironment(threads, numThreads); &#125; KSLOG_DEBUG("Re-raising signal for regular handlers to catch."); // This is technically not allowed, but it works in OSX and iOS. /// 重新抛出 signal raise(sigNum);&#125; 整个流程和 Mach 异常还是非常类似的，先暂停线程，然后读取线程信息，再把 signal 信息线程信息保存到 context 中，传递给外部的处理函数。最后恢复原来的环境。 取消监听12345678910111213141516171819/// 取消捕捉 signalstatic void uninstallSignalHandler(void)&#123; KSLOG_DEBUG("Uninstalling signal handlers."); const int* fatalSignals = kssignal_fatalSignals(); int fatalSignalsCount = kssignal_numFatalSignals(); for(int i = 0; i &lt; fatalSignalsCount; i++) &#123; KSLOG_DEBUG("Restoring original handler for signal %d", fatalSignals[i]); sigaction(fatalSignals[i], &amp;g_previousSignalHandlers[i], NULL); &#125; #if KSCRASH_HAS_SIGNAL_STACK g_signalStack = (stack_t)&#123;0&#125;;#endif KSLOG_DEBUG("Signal handlers uninstalled.");&#125; 取消捕捉的方式和启动捕捉类似，都是通过 sigaction() 方法，不同的是，现在将原本的处理方法传回。 C++ 异常开启捕获通过 set_terminate() 方法设置自己的捕获函数： 123456789101112131415161718192021static void setEnabled(bool isEnabled)&#123; if(isEnabled != g_isEnabled) &#123; g_isEnabled = isEnabled; if(isEnabled) &#123; initialize(); ksid_generate(g_eventID); /// 保存原始的 c++ 处理 handler，设置自己的处理 handler g_originalTerminateHandler = std::set_terminate(CPPExceptionTerminate); &#125; else &#123; /// 恢复原始的 c++ 处理 handler std::set_terminate(g_originalTerminateHandler); &#125; g_captureNextStackTrace = isEnabled; &#125;&#125; 处理异常1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/// c++ 处理函数static void CPPExceptionTerminate(void)&#123; thread_act_array_t threads = NULL; mach_msg_type_number_t numThreads = 0; /// 挂起非处理现场和白名单线程的其他所有线程 ksmc_suspendEnvironment(&amp;threads, &amp;numThreads); KSLOG_DEBUG("Trapped c++ exception"); const char* name = NULL; std::type_info* tinfo = __cxxabiv1::__cxa_current_exception_type(); if(tinfo != NULL) &#123; name = tinfo-&gt;name(); &#125; if(name == NULL || strcmp(name, "NSException") != 0) &#123; /// 捕捉到 crash 后，清空 KSCrash 的所有 monitor kscm_notifyFatalExceptionCaptured(false); KSCrash_MonitorContext* crashContext = &amp;g_monitorContext; memset(crashContext, 0, sizeof(*crashContext)); char descriptionBuff[DESCRIPTION_BUFFER_LENGTH]; const char* description = descriptionBuff; descriptionBuff[0] = 0; KSLOG_DEBUG("Discovering what kind of exception was thrown."); g_captureNextStackTrace = false; try &#123; throw; &#125; catch(std::exception&amp; exc) &#123; strncpy(descriptionBuff, exc.what(), sizeof(descriptionBuff)); &#125;#define CATCH_VALUE(TYPE, PRINTFTYPE) \catch(TYPE value)\&#123; \ snprintf(descriptionBuff, sizeof(descriptionBuff), "%" #PRINTFTYPE, value); \&#125; CATCH_VALUE(char, d) CATCH_VALUE(short, d) CATCH_VALUE(int, d) CATCH_VALUE(long, ld) CATCH_VALUE(long long, lld) CATCH_VALUE(unsigned char, u) CATCH_VALUE(unsigned short, u) CATCH_VALUE(unsigned int, u) CATCH_VALUE(unsigned long, lu) CATCH_VALUE(unsigned long long, llu) CATCH_VALUE(float, f) CATCH_VALUE(double, f) CATCH_VALUE(long double, Lf) CATCH_VALUE(char*, s) catch(...) &#123; description = NULL; &#125; g_captureNextStackTrace = g_isEnabled; // TODO: Should this be done here? Maybe better in the exception handler? KSMC_NEW_CONTEXT(machineContext); ksmc_getContextForThread(ksthread_self(), machineContext, true); KSLOG_DEBUG("Filling out context."); crashContext-&gt;crashType = KSCrashMonitorTypeCPPException; crashContext-&gt;eventID = g_eventID; crashContext-&gt;registersAreValid = false; crashContext-&gt;stackCursor = &amp;g_stackCursor; crashContext-&gt;CPPException.name = name; crashContext-&gt;exceptionName = name; crashContext-&gt;crashReason = description; crashContext-&gt;offendingMachineContext = machineContext; /// 处理异常 kscm_handleException(crashContext); &#125; else &#123; KSLOG_DEBUG("Detected NSException. Letting the current NSException handler deal with it."); &#125; /// 恢复线程 ksmc_resumeEnvironment(threads, numThreads); KSLOG_DEBUG("Calling original terminate handler."); /// 触发原本的 handler g_originalTerminateHandler();&#125; NSException 异常开启捕获到了 NSException 部分，很多文章中也都有提到，先通过 NSGetUncaughtExceptionHandler() 获取原先的异常处理函数，然后再通过 NSSetUncaughtExceptionHandler() 方法设置自己的处理函数。 12345678910111213141516171819202122232425static void setEnabled(bool isEnabled)&#123; if(isEnabled != g_isEnabled) &#123; g_isEnabled = isEnabled; if(isEnabled) &#123; KSLOG_DEBUG(@"Backing up original handler."); /// 拿到原来的 handler g_previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler(); KSLOG_DEBUG(@"Setting new handler."); /// 设置新的 handler NSSetUncaughtExceptionHandler(&amp;handleUncaughtException); KSCrash.sharedInstance.uncaughtExceptionHandler = &amp;handleUncaughtException; KSCrash.sharedInstance.currentSnapshotUserReportedExceptionHandler = &amp;handleCurrentSnapshotUserReportedException; &#125; else &#123; KSLOG_DEBUG(@"Restoring original handler."); /// 设置回原来的 handler NSSetUncaughtExceptionHandler(g_previousUncaughtExceptionHandler); &#125; &#125;&#125; 处理异常关于调用堆栈的获取都不需要通过 task 了，直接从 NSException 就可以获取到： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// 处理方法static void handleException(NSException* exception, BOOL currentSnapshotUserReported) &#123; KSLOG_DEBUG(@"Trapped exception %@", exception); if(g_isEnabled) &#123; thread_act_array_t threads = NULL; mach_msg_type_number_t numThreads = 0; ksmc_suspendEnvironment(&amp;threads, &amp;numThreads); kscm_notifyFatalExceptionCaptured(false); KSLOG_DEBUG(@"Filling out context."); /// 调用堆栈的地址 NSArray* addresses = [exception callStackReturnAddresses]; NSUInteger numFrames = addresses.count; uintptr_t* callstack = malloc(numFrames * sizeof(*callstack)); /// 转为堆栈 for(NSUInteger i = 0; i &lt; numFrames; i++) &#123; callstack[i] = (uintptr_t)[addresses[i] unsignedLongLongValue]; &#125; char eventID[37]; ksid_generate(eventID); KSMC_NEW_CONTEXT(machineContext); ksmc_getContextForThread(ksthread_self(), machineContext, true); KSStackCursor cursor; kssc_initWithBacktrace(&amp;cursor, callstack, (int)numFrames, 0); KSCrash_MonitorContext* crashContext = &amp;g_monitorContext; memset(crashContext, 0, sizeof(*crashContext)); crashContext-&gt;crashType = KSCrashMonitorTypeNSException; crashContext-&gt;eventID = eventID; crashContext-&gt;offendingMachineContext = machineContext; crashContext-&gt;registersAreValid = false; crashContext-&gt;NSException.name = [[exception name] UTF8String]; crashContext-&gt;NSException.userInfo = [[NSString stringWithFormat:@"%@", exception.userInfo] UTF8String]; crashContext-&gt;exceptionName = crashContext-&gt;NSException.name; crashContext-&gt;crashReason = [[exception reason] UTF8String]; crashContext-&gt;stackCursor = &amp;cursor; crashContext-&gt;currentSnapshotUserReported = currentSnapshotUserReported; KSLOG_DEBUG(@"Calling main crash handler."); kscm_handleException(crashContext); free(callstack); if (currentSnapshotUserReported) &#123; ksmc_resumeEnvironment(threads, numThreads); &#125; if (g_previousUncaughtExceptionHandler != NULL) &#123; KSLOG_DEBUG(@"Calling original exception handler."); g_previousUncaughtExceptionHandler(exception); &#125; &#125;&#125; DeadLock死锁部分我就不细说了，原理和在前一篇 “iOS开发高手课” 笔记中有说明，BeeHive 中也有类似的的实现。主要是通过子线程循环往复的判断一个标志位是否在主线程中被修改过。来达到监听的效果。 总结至此，捕获异常相关的几个方法都已经分析完了。其实过程还是非常类似的：替换原来的捕获处理，捕获到异常后保存 context 信息，暂停所有线程获取所有线程信息，恢复原本的捕获处理方法，调用统一的异常处理函数。 下一篇将介绍异常捕获后，如何分析 context 以及线程信息。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《iOS开发高手课阅读笔记》]]></title>
    <url>%2F2019%2F09%2F09%2FiOS%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[很早就买了戴铭老师的专栏，每一篇都是干货。也正是因为干货太多，所以不太愿意零碎的去学，怕知识点看过就忘了。因此，花了几个晚上，把感兴趣的高手课做了整理。 App 启动速度优化与监控冷启动与热启动 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 App 启动三个阶段 main() 函数执行前； main() 函数执行后； 首屏渲染完成后。 main() 函数执行前在 main() 函数执行前，系统主要会做下面几件事情： 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc runtime 的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 因此，我们可以通过相应的一下几种方式优化： 减少动态库。尽量将动态库合并。 减少不用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 替换。 控制 C++ 全局变量的数量 main() 函数执行后main()函数执行后的阶段，指的是从main()函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。 因此，我们应该考虑哪些初始化操作是首屏渲染必须的，哪些是对应功能开始时才需要初始化的。 首屏渲染完成后首屏渲染完成后，就要进行非首屏其他业务模块的初始化，监听的注册，配置文件的读取等。这个阶段就是从渲染完成开始，到 didFinishLaunchingWithOptions 方法作用域结束。 监控方法时长 定时抓取主线程上方法调用堆栈，计算一段时间里各个方法的耗时。 Xcode 中的 Time Profile 就是这么做的。时间间隔一般设置为 0.01s。间隔太长容易监听不到所有方法的执行。 对objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。hook objc_msgSend 方法能够精确获取 OC 方法执行时间。对于 c 和 block，可以使用 libffi 的 ffi_call 完成 hook。 我们可以通过 fishhook hook objc_msgSend。fishhook 的原理可以看我之前的博客。 emmmm。一大段一大段的汇编代码有点难懂。。。暂时先知道通过这种方式可以实现方法调用时间就行了 链接器为什么要有链接器？没有这个绑定过程的话，单个文件生成的 Mach-O 文件是无法正常运行起来的。因为，如果运行时碰到调用在其他文件中实现的函数的情况时，就会找不到这个调用函数的地址，从而无法继续执行。 链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。链接时如果出现相同符号的情况，就会出现“ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误信息。 链接器做了什么？ 去项目文件里查找目标代码文件里没有定义的变量。 扫描项目中的不同文件，将所有符号定义和引用地址收集起来，并放到全局符号表中。 计算合并后长度及位置，生成同类型的段进行合并，建立绑定。 对项目中不同文件里的变量进行地址重定位。 动态库链接Mach-O 文件是编译后的产物，而动态库在运行时才会被链接，并没参与 Mach-O 文件的编译和链接，所以 Mach-O 文件中并没有包含动态库里的符号定义。也就是说，这些符号会显示为“未定义”，但它们的名字和对应的库的路径会被记录下来。运行时通过 dlopen 和 dlsym 导入动态库时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。 dlopen 会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。 加载过程开始会修正地址偏移，iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 Clang Attribute 的 constructor 修饰函数。 dyld 做了什么？ 先执行 Mach-O 文件，根据 Mach-O 文件里 undefined 的符号加载对应的动态库，系统会设置一个共享缓存来解决加载的递归依赖问题； 加载后，将 undefined 的符号绑定到动态库里对应的地址上； 最后再处理 +load 方法，main 函数返回后运行 static terminator。 Crash常见 Crash信号可捕获崩溃： KVO NSNotification 数组越界 野指针 … 信号不可捕获崩溃 后台任务超时 内存溢出 主线程卡顿超阈值 (异常编码 0x8badf00d) … 信号不可捕获的崩溃通常都是系统级的，系统杀掉 App 后会将日志保存在系统目录下。开发者没有权限获取系统目录日志。 如何收集捕获 不到的崩溃？Background Task 可以通过 beginBackgroundTaskWithExpirat: 来延长后台执行时间。后台执行任务最多可以执行3分钟，超过3分钟就会被系统挂起。 12345- (void)applicationDidEnterBackground:(UIApplication *)application &#123; self.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^(void) &#123; [self yourTask]; &#125;];&#125; 对于此类异常可以先设置一个定时器，在接近3分钟时判断后台程序是否还在执行。如果还在执行，那么就可以判断程序即将崩溃，进行上报，记录，以达到监控的效果。 监控内存溢出和主线程卡顿被 watchdog 杀死，同样需要先找到一个阈值，然后在临近阈值时还在执行，判断为即将崩溃。内存溢出可以通过内存映射(mmap)来保存现场；主线程卡顿超过阈值，可以手机当前线程的堆栈信息。具体措施，看后续。 卡顿监控利用 runloop 监控卡顿卡顿的发生可以通过一次 runloop 从开始到结束的时间间隔来间接判断。 注册 observer 记录 runloop 开启的时间，并且在 runloop 结束的时候清空，然后创建一个子线程，每隔一定时间去检测当前时间和 runloop 开启时记录的时间是否大于某一个阈值。 当大于某个阈值的时候表明产生了卡顿，记录下卡顿时候的堆栈 利用 FPS 变化监控卡顿这个实现方式类似 YYFPSLabel，通过创建一个 CADisplayLink，看看一秒钟回调能执行多少次。 这是我看 YYFPSLabel 源码学到的 子线程监控卡顿首先创建一个子线程，然后在这个子线程中将下面的事件循环： 设置一个标志位，默认其表示主线程阻塞状态。然后通过 gcd 给主队列增加一个任务。这个任务用来清除这个标志位，将标志位置为非阻塞。也就是说，如果主线程没有堵塞，那么就会执行这个任务将是否阻塞的标志位置为非阻塞。 然后将子线程阻塞 threshold 秒，在线程醒来之后判断这个标志位是否置为了非阻塞状态。如果置为了非阻塞状态就说明在这 threshold 秒之内，主线程执行了任务，没有堵塞。如果标志位还是阻塞状态，说明主线程被阻塞了，没来得及执行我们的方法。 这是我看 Beehive 中关于 watchdog 部分学到的 OOM 监控获取内存上限JetsamEvent 日志查看 JetsamEvent 开头的日志(设置-&gt;隐私-&gt;分析) 通过日志中的 pageSize 和 rpages 字段的乘积得到内存上限。 XNU 获取在 XNU 中，有专门用于获取内存上限值的函数和宏。可以通过 memorystatus_priority_entry 这个结构体，获进程优先级和内存限制： 1234567typedef struct memorystatus_priority_entry &#123; pid_t pid; int32_t priority; uint64_t user_data; int32_t limit; uint32_t state;&#125; memorystatus_priority_entry_t; priority 是优先级，limit 是内存限制 内存警告获取通过系统回调函数 didReceiveMemoryWarning 回调作为入口获取内存状况。以下代码通过 task_info 函数能够拿到当前内存占用： 123456struct mach_task_basic_info info;mach_msg_type_number_t size = sizeof(info);kern_return_t kl = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);float used_mem = info.resident_size;NSLog(@" 使用了 %f MB 内存 ", used_mem / 1024.0f / 1024.0f) 获取内存信息通过 fishhook Hook malloc_logger 函数 libffi我们可以通过动态链接器提供的api dlsym() 传入函数名获得函数指针。 但是 dlsym() 获取的函数指针需要调用必须要提前声明好参数个数和类型。比如下方，2 就是错的。因为 1 在编译的时候编译器能知道有两个 int 类型的参数，就会在调用的时候将两个 int 参数入栈。而 2 没有声明，编译器就不会申请空间了。 当然也可以把要调用的 c 函数都设置为 id 类型，然后生成 n 个不同参数个数的函数指针，通过 switch 判断参数个数的方式去赋值。JSPatch 也有通过这总方式实现的。 objc_msgSend 通过直接用汇编代码的方式完成函数体，这样就不需要通过编译器生成汇编代码了。通过约定好的方式去取参数是能够取得到的。 我们可以通过 libffi 动态调用任意 c 函数，也是通过汇编直接实现的. 内存泄漏监控 此为最近阅读相关源码的时候的总结。因为也是监控的一种，故放到这里来了。 这里列举两种内存泄漏监控的方式 MLeaksFinder微信读书内存泄漏的检测方法。 hook NavigationController 的 push 和 pop 方法，在 pop 的时候保存为 ViewController 中的每一个 View 以及自身添加定时器，2分钟后，执行内存泄漏方法，如果没有内存泄漏，那么这个对象为 nil，内存泄漏的方法无法执行。这种方式是在销毁的生命周期的时候触发延时检查 PLeakSniffer这是 MrPeak 的检测方法 把 ViewController 设置为其实例对象的弱引用。如果实例对象没有销毁，但是 ViewController 已经置为 nil 了，就说明可能 leak 了。只需要周期性的发送通知，各个实例对象接收到通知的时候执行方法，检查 ViewController 是否为 nil 即可知道是否是可能泄露的这种方式是在创建的时候注册通知，定时轮询 iOS内存泄漏自动检测工具PLeakSniffer]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aspects 源码解析]]></title>
    <url>%2F2019%2F08%2F19%2Faspects%2F</url>
    <content type="text"><![CDATA[Aspects 是一个提供健壮 AOP 能力的库。它的实现原理和 JSPatch 类似。也真是如此，它和 JSPatch 混用时会产生冲突。 使用Aspects 提供了两个方法来实现三种类型的 hook： 12345678910111213@interface NSObject (Aspects)+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end 它能 hook 的类型有： 所有实例对象的特定方法 特定类方法 某个特定实例对象的特定方法 两个方法中，前者处理的是类型 1，2；后者处理的是类型 3。 非常有意思，如果你要 hook 1，比如你有一个类 Test,你要 hook Test 所有实例对象的 -(void)test 方法，你要通过 Test 去调用。 如果你要 hook 2，比如你要 hook Test 的类方法 +(void)test ，你要通过 object_getClass(Test) 去调用。 涉及的类Aspects 在实现的过程中，涉及到一些类的使用，提前了解它们有助于我们之后的流程分析。 AspectsInfo12345678@protocol AspectInfo &lt;NSObject&gt;/// 返回 hook 的对象- (id)instance;/// 保存 hook 的原方法的 Invocation- (NSInvocation *)originalInvocation;/// 调用方法的所有参数- (NSArray *)arguments;@end 这是一个协议，当我们要执行 hook 的方法的时候，需要从实现这个协议的对象中拿到执行必要的信息 AspectIdentifier12345678910111213141516@interface AspectIdentifier : NSObject/// 创建 AspectIdentifier 实例+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;/// 执行 hook 的方法- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;/// hook 的 SEL@property (nonatomic, assign) SEL selector;/// 替换原方法的 block@property (nonatomic, strong) id block;/// block 的签名@property (nonatomic, strong) NSMethodSignature *blockSignature;/// hook 的对象@property (nonatomic, weak) id object;/// hook 的时机@property (nonatomic, assign) AspectOptions options;@end AspectIdentifer 包含了 hook 需要的绝大多数信息，配合 AspectsInfo 就可以实现 hook。 AspectsContainer1234567891011121314@interface AspectsContainer : NSObject/// 保存 hook 的信息- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;/// 移除 hook- (BOOL)removeAspect:(id)aspect;/// 判断是否存在 hook- (BOOL)hasAspects;/// 保存在方法执行前要执行的 hook@property (atomic, copy) NSArray *beforeAspects;/// 保存要替换原方法执行的 hook@property (atomic, copy) NSArray *insteadAspects;/// 保存在方法执行后要执行的 hook@property (atomic, copy) NSArray *afterAspects;@end 每一个被 hook 的方法会对应一个 AspectsContaienr。AspectsContainer 保存了不同时机要执行的 hook 信息 AspectsIdentifier 实例。 之后执行的方法判断要执行 hook 的时候，就会拿到 SEL 对应的 AspectContainer 实例，从中拿出一个个 AspectsIdentifier，再结合通过方法执行时拿到的 NSInvocation 实例创建的 AspectsInfo 实例，达到最终 hook 方法的目的。 AspectTracker1234567891011121314151617181920@interface AspectTracker : NSObject/// 初始化方法- (id)initWithTrackedClass:(Class)trackedClass;/// 对应的 hook 的类@property (nonatomic, strong) Class trackedClass;/// 对应的 hook 的类名@property (nonatomic, readonly) NSString *trackedClassName;/// 类中被 hook 的方法名@property (nonatomic, strong) NSMutableSet *selectorNames;/// 保存某个方法与 hook 该方法的子类的 AspectTracker@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;/// 把 selectorName 和子类的 sAspectTracker 保存在 selectorNamesToSubclassTrackers 字典中- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;/// 把 selectorName 和子类的 sAspectTracker 从 selectorNamesToSubclassTrackers 字典中移除- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;/// 判断该类的子类是否 hook 了 selectorName- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;/// 拿到 hook 该 selectorName 的子类的 AspectTracker 的集合- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;@end AspectTracker 的目的是要保存继承链上对于某个方法的 hook 的情况。这是为了在 hook 的时候校验并保证同一个继承链上只能有一个类被 hook。至于这样的目的，后面再细说。 其实这个原因我疑惑了很久，看了很多文章，但是几乎所有对 Aspects 的源码解析都没有对 AspectTracker 的意义进行解释。只是照本宣科的说明继承链上只能有一个类被 hook，而没有说明为什么要设计成这样。 流程进行 hookhook 过程涉及的两个方法，一个类方法，一个实例方法都是直接调用 aspect_add() 方法： 12345678910111213141516171819202122/// 添加 hookstatic id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) &#123; __block AspectIdentifier *identifier = nil; /// 使用自旋锁包裹hook过程 aspect_performLocked(^&#123; // 是否可以 hook 方法 if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123; /// 每个被 hook 的对象会有一个 AspectContainer 实例。取出当前对象的关联对象 AspectsContainer，如果没有就创建一个返回 AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); /// 创建一个 AspectIdentifier identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) &#123; /// 把 aspectIdentifier 添加到 AspectsContainer 中 [aspectContainer addAspect:identifier withOptions:options]; /// hook 类和方法 aspect_prepareClassAndHookSelector(self, selector, error); &#125; &#125; &#125;); return identifier;&#125; 整个过程分为几步： 判断是否可以 hook 创建 AspectsContainer 实例 创建 AspectsIdentifier 实例 实现 hook 方法 判断是否可以 hookhook 前要判断是否可以 hook。hook 的原则有几点： 已经被 hook 的方法不会被重复 hook 不能 hook 包含 retain，release，autorelease，forwardInvocation 的方法 hook 方法只能在 dealloc 方法前执行，不能替换 dealloc 方法 不能 hook 不存在的 selector 不能 hook 继承链上已经被 hook 过的同名方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/// 检验 aspect 是否可以 hook 该方法。主要规则对于类方法，一个继承链上的同名方法只能被 hook 一次static BOOL aspect_isSelectorAllowedAndTrack(NSObject *self, SEL selector, AspectOptions options, NSError **error) &#123; static NSSet *disallowedSelectorList; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; disallowedSelectorList = [NSSet setWithObjects:@"retain", @"release", @"autorelease", @"forwardInvocation:", nil]; &#125;); // Check against the blacklist. NSString *selectorName = NSStringFromSelector(selector); /// 1.对于包含 retain，release，autorelease，forwardInvocation 的方法是不能被 hook 的 if ([disallowedSelectorList containsObject:selectorName]) &#123; NSString *errorDescription = [NSString stringWithFormat:@"Selector %@ is blacklisted.", selectorName]; AspectError(AspectErrorSelectorBlacklisted, errorDescription); return NO; &#125; // Additional checks. AspectOptions position = options&amp;AspectPositionFilter; /// 2.校验 hook dealloc 方法只能在之前执行 if ([selectorName isEqualToString:@"dealloc"] &amp;&amp; position != AspectPositionBefore) &#123; NSString *errorDesc = @"AspectPositionBefore is the only valid position when hooking dealloc."; AspectError(AspectErrorSelectorDeallocPosition, errorDesc); return NO; &#125; /// 3.如果不存在这个 selector 那么直接报错 if (![self respondsToSelector:selector] &amp;&amp; ![self.class instancesRespondToSelector:selector]) &#123; NSString *errorDesc = [NSString stringWithFormat:@"Unable to find selector -[%@ %@].", NSStringFromClass(self.class), selectorName]; AspectError(AspectErrorDoesNotRespondToSelector, errorDesc); return NO; &#125; // Search for the current class and the class hierarchy IF we are modifying a class object /// 如果是类类型 if (class_isMetaClass(object_getClass(self))) &#123; Class klass = [self class]; NSMutableDictionary *swizzledClassesDict = aspect_getSwizzledClassesDict(); Class currentClass = [self class]; AspectTracker *tracker = swizzledClassesDict[currentClass]; /// 4.子类是否已经 hook 了这个 selector。一个方法如果被子类 hook 过了，父类就不能 hook 了。 if ([tracker subclassHasHookedSelectorName:selectorName]) &#123; NSSet *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName]; NSSet *subclassNames = [subclassTracker valueForKey:@"trackedClassName"]; NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.", selectorName, subclassNames]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO; &#125; /// 5.到父类中找，如果一个方法已经在父类中 hook 过了，那么就不能在子类中 hook 了 do &#123; tracker = swizzledClassesDict[currentClass]; if ([tracker.selectorNames containsObject:selectorName]) &#123; if (klass == currentClass) &#123; // Already modified and topmost! return YES; &#125; NSString *errorDescription = [NSString stringWithFormat:@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.", selectorName, NSStringFromClass(currentClass)]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO; &#125; &#125; while ((currentClass = class_getSuperclass(currentClass))); // Add the selector as being modified. currentClass = klass; AspectTracker *subclassTracker = nil; /// 如果能 hook，那么把当前的 AspectsTracker 实例加入到父类的 AspectTracker 的 selectorNamesToSubclassTrackers 字典 selectorName 对应的集合中。 /// 这样在之后 hook 的时候就可以查看继承链上是否有被 hook 过了 do &#123; /// 如果 swizzledClassesDict 中不存在这个 tracker，那么创建这个 AspectTracker，然后添加进去 tracker = swizzledClassesDict[currentClass]; /// 递归为每一个当前类的父类创建一个 AspectTracker。 if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; &#125; // 递归把当前类的 AspectTracker 添加到父类的 selectorNamesToSubclassTrackers 中 if (subclassTracker) &#123; [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName]; &#125; else &#123; [tracker.selectorNames addObject:selectorName]; &#125; // All superclasses get marked as having a subclass that is modified. subclassTracker = tracker; /// 递归获取当前类的父类 &#125;while ((currentClass = class_getSuperclass(currentClass))); &#125; else &#123; // 实例对象默认是 YES // 实例对象 hook 的方法只针对该实例，因此没有同一个继承链上只能 hook 一次同名方法的限制 return YES; &#125; return YES;&#125; 前四个规则都容易理解。那么为什么要有同一个继承链上只能 hook 一次同名方法？我们来看这样一个例子： 12345678910111213141516171819202122232425262728293031@interface A : NSObject- (void)foo;@end@implementation A- (void)foo &#123; NSLog(@"%s", __PRETTY_FUNCTION__);&#125;@end@interface B : A@end@implementation B- (void)foo &#123; NSLog(@"%s", __PRETTY_FUNCTION__); [super foo];&#125;@endint main(int argc, char *argv[]) &#123; [B aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@"before -[B foo]"); &#125;]; [A aspect_hookSelector:@selector(foo) atPosition:AspectPositionBefore withBlock:^(id object, NSArray *arguments) &#123; NSLog(@"before -[A foo]"); &#125;]; B *b = [[B alloc] init]; [b foo];&#125; 场景很简单，父类 hook 了某一个方法，子类中调用父类的该方法。熟悉 runtime 的都知道，调用父类方法时，调用者是子类本身，方法实现是执行父类的 IMP。这个时候由于父类进行了 hook，IMP 指向 msg_forward，因此会进行消息转发。消息转发时，NSInvocation 只知道调用者是子类，并不知道其实调用的是父类方法。因此，还会执行子类方法。也就是说，变成了子类中该方法又调用了自身，进而形成无限循环。 因此，Aspects 的作者禁止了同一个继承链上的多次 hook。当然这是为了解决这种无限循环的无奈之举。禁用某些操作以达到安全性，当然这也限制了一些实际需求的实现。 JSPatch 在执行到 super 方法的时候会判断 super 方法是否被重写，如果被重写了那么执行重写的 JS 方法。而不是像 Aspects 中非常武断的只是不让一个继承链 hook 一次。 创建 AspectsContainer 实例前面说到，每一个被 hook 的实例或者对象的每一个方法都会有一个 AspectsContainer 以关联对象的方式存储。即方法 aspect_getContainerForObject 123456789101112static AspectsContainer *aspect_getContainerForObject(NSObject *self, SEL selector) &#123; NSCParameterAssert(self); /// 给 SEL 增加 aspects_ 前缀 SEL aliasSelector = aspect_aliasForSelector(selector); /// 从当前类或者对象中通过关联对象取出该 SEL 对应的 AspectsContainer AspectsContainer *aspectContainer = objc_getAssociatedObject(self, aliasSelector); if (!aspectContainer) &#123; aspectContainer = [AspectsContainer new]; objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN); &#125; return aspectContainer;&#125; 方法很简单，就是先查看这个对象上有没有方法名对应的关联对象，有就取出，没有就创建。 这就说明了，类对象和元类对象都是可以设置关联对象的 创建 AspectsIdentifier 实例AspectsIdentifier 将 hook 的信息保存起来，它会做两件事： 获取 block 的签名 比较 block 的签名和 hook 的方法签名是否一致 1234567891011121314151617181920212223/// 创建一个 AspectIdentifier+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error &#123; NSCParameterAssert(block); NSCParameterAssert(selector); /// 拿到block的signature NSMethodSignature *blockSignature = aspect_blockMethodSignature(block, error); // TODO: check signature compatibility, etc. /// 比较 block signature 和 method signature 是否一致 if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) &#123; return nil; &#125; /// 创建一个 AspectIndentifier 设置 selector block signature options object AspectIdentifier *identifier = nil; if (blockSignature) &#123; identifier = [AspectIdentifier new]; identifier.selector = selector; identifier.block = block; identifier.blockSignature = blockSignature; identifier.options = options; identifier.object = object; // weak &#125; return identifier;&#125; 获取 block 签名获取 block 签名的方式在 jspatch 中有类似的操作。通过 block 的地址，参考 block 结构体的内存分布，将指针移动到 signature 的位置。区别在于 JSPatch hook 的 block 全都是全局 block，因此 block 结构中不会存在 copy 和 dispose 两个方法。而 Aspects 中的 block 有可能是堆 block。当是堆 block 的时候，要移动两个方法指针的大小： 12345678910111213141516171819202122232425/// 获取 block 的签名static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) &#123; // 把 block 转为 AspectBlockRef 类型 AspectBlockRef layout = (__bridge void *)block; // 没有签名 if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123; NSString *description = [NSString stringWithFormat:@"The block %@ doesn't contain a type signature.", block]; AspectError(AspectErrorMissingBlockSignature, description); return nil; &#125; void *desc = layout-&gt;descriptor; // 移动两个 int 的位置。 desc += 2 * sizeof(unsigned long int); // 有 copy 和 dispose 函数。那么 要再移动两个指针的位置。堆 block 有 copy 和 dispose 两个函数 if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123; desc += 2 * sizeof(void *); &#125; if (!desc) &#123; NSString *description = [NSString stringWithFormat:@"The block %@ doesn't has a type signature.", block]; AspectError(AspectErrorMissingBlockSignature, description); return nil; &#125; const char *signature = (*(const char **)desc); return [NSMethodSignature signatureWithObjCTypes:signature];&#125; AspectBlockRef 的结构如下： 1234567891011121314151617typedef struct _AspectBlock &#123; __unused Class isa; AspectBlockFlags flags; __unused int reserved; void(__unused *invoke)(struct _AspectBlock *block, ...); struct &#123; unsigned long int reserved; unsigned long int size; // requires AspectBlockFlagsHasCopyDisposeHelpers void (*copy)(void *dst, const void *src); void (*dispose)(const void *); // requires AspectBlockFlagsHasSignature const char *signature; const char *layout; &#125; * descriptor; // imported variables&#125; * AspectBlockRef; 比较 block 的签名和 hook 的方法签名12345678910111213141516171819202122232425262728293031323334353637383940/// 比较 block 参数类型和方法参数类型是否一致static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) &#123; BOOL signaturesMatch = YES; // 获取 selector 的签名 NSMethodSignature *methodSignature = [[object class] instanceMethodSignatureForSelector:selector]; if (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123; // block 参数数量大于方法的参数数量就是不匹配 signaturesMatch = NO; &#125;else &#123; if (blockSignature.numberOfArguments &gt; 1) &#123; // Aspects 规定，如果有参数，第一个必须是 AspectInfo const char *blockType = [blockSignature getArgumentTypeAtIndex:1]; if (blockType[0] != '@') &#123; signaturesMatch = NO; &#125; &#125; // Argument 0 is self/block, argument 1 is SEL or id&lt;AspectInfo&gt;. We start comparing at argument 2. // index 为 0 的参数是 self 或者 block，index 为 1 的参数，是 SEL 或者 Aspects 规定的 AspectInfo 类型，因此从 index 为 2 的参数开始比较 // The block can have less arguments than the method, that's ok. // 一个一个参数对比 if (signaturesMatch) &#123; for (NSUInteger idx = 2; idx &lt; blockSignature.numberOfArguments; idx++) &#123; const char *methodType = [methodSignature getArgumentTypeAtIndex:idx]; const char *blockType = [blockSignature getArgumentTypeAtIndex:idx]; // Only compare parameter, not the optional type data. if (!methodType || !blockType || methodType[0] != blockType[0]) &#123; signaturesMatch = NO; break; &#125; &#125; &#125; &#125; /// 不匹配直接报错 if (!signaturesMatch) &#123; NSString *description = [NSString stringWithFormat:@"Block signature %@ doesn't match %@.", blockSignature, methodSignature]; AspectError(AspectErrorIncompatibleBlockSignature, description); return NO; &#125; return YES;&#125; 比较两者的签名主要是比较入参的类型要一致。block 和普通方法的不同在于 block 的签名中不存在 SEL。普通方法的签名 index 为 0 的参数是调用者，即 @，index 为 1 的参数是 SEL，即 :，而 block 由于不存在 SEL，其 index 为 0 的参数还是调用者，即 @，而 index 为 1 的参数就是真正的参数了。Aspects 为了将 block 签名和普通方法签名一致，所以做了限制，只要有参数，第一个一定是一个无关的 AspectInfo 实例。 在创建好 AspectsIdentifier 后，将实例存放到 AspectContainer 中。 实现 hook 方法hook 方法的真正地方在 aspect_prepareClassAndHookSelector 方法中。分为两步： 替换类的 forwardInvocation 方法为自己的实现 替换方法的实现为 _objc_msgForward 123456789101112131415161718192021222324252627/// hook 方法的地方static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) &#123; NSCParameterAssert(selector); /// 返回 hook 后的类 /// 实例对象就返回一个新类，类对象替换 forwardInvocation 后返回自身 Class klass = aspect_hookClass(self, error); /// 获取该类要 hook 的方法 Method targetMethod = class_getInstanceMethod(klass, selector); IMP targetMethodIMP = method_getImplementation(targetMethod); /// 如果该方法不是指向 _objc_msgForward，说明没有被 hook 过，要 hook 一下 if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123; // Make a method alias for the existing method implementation, it not already copied. /// 获取方法的签名 const char *typeEncoding = method_getTypeEncoding(targetMethod); /// 获取添加了前缀的方法名 SEL aliasSelector = aspect_aliasForSelector(selector); /// 添加方法然后 replace if (![klass instancesRespondToSelector:aliasSelector]) &#123; __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); NSCAssert(addedAlias, @"Original implementation for %@ is already copied to %@ on %@", NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass); &#125; // We use forwardInvocation to hook in. class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding); AspectLog(@"Aspects: Installed hook for -[%@ %@].", klass, NSStringFromSelector(selector)); &#125;&#125; 替换类的 forwardInvocation 实现替换在 aspect_hookClass 中实现。这是一个比较重要也比较有技巧性的方法。如注释上写的，对于 hook 对象主要区分为三种情况： hook 的是类对象(包括元类对象，以下都简称为类对象) hook 的是 kvo 对象 hook 的是实例对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/// hook 对象/// 如果传入的是实例对象，那么就新建一个类，并把实例对象的 isa 指针指向它/// 如果传入的是类对象，那么就直接把类对象的 forwardInvocation 替换掉/// 如果是 KVO 实例对象，也是直接把 KVO 实例对象的 forwardInvocation 替换掉static Class aspect_hookClass(NSObject *self, NSError **error) &#123; NSCParameterAssert(self); /// .class 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身 /// object_getClass 返回 isa 指针的指向 /// 对于实例对象，.class object_getClass 返回的对象是一样的 /// 对于类对象，.class 返回自身，object_getClass 返回 meta class /// 但是实例对象中有一个特殊情况，对于 KVO 对象，.class 返回的如果是 ObjectClass，那么 object_getClass 返回的就是 NSKVONotifing_ObjectClass /// 这是因为，KVO 悄悄创建了一个新类，并且重写了 .class 方法 Class statedClass = self.class; Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // Already subclassed if ([className hasSuffix:AspectsSubclassSuffix]) &#123; /// 如果有 _Aspects_ 前缀，说明已经 hook 过了,直接返回 class return baseClass; // We swizzle a class object, not a single object. &#125;else if (class_isMetaClass(baseClass)) &#123; /// 如果是类方法,替换这个类的 forwardInvocation 方法，然后返回该类 return aspect_swizzleClassInPlace((Class)self); // Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place. &#125;else if (statedClass != baseClass) &#123; /// KVO 对象也要替换 KVO 类的 forwardInvocation 方法，然后返回 KVO 的类 /// KVO 对象要 hook NSKVONotifing_ObjectClass return aspect_swizzleClassInPlace(baseClass); &#125; // Default case. Create dynamic subclass. /// 上面已经把类对象过滤掉了，下面的逻辑都是实例对象的 /// 动态创建当前类的子类，_Aspects_xxx const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) &#123; subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) &#123; NSString *errrorDesc = [NSString stringWithFormat:@"objc_allocateClassPair failed to allocate class %s.", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; /// 替换这个子类的 forwardInvocation 实现 aspect_swizzleForwardInvocation(subclass); /// 替换新创建的子类的 class 方法实现，返回原类要返回的类 aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); /// 创建这个类 objc_registerClassPair(subclass); &#125; /// 设置当前实例的 isa 指向新创建的 class object_setClass(self, subclass); return subclass;&#125; [xxx class] 方法和 object_getClass(xxx) 的区别是要了解的： [xxx class] 当 xxx 是实例对象的时候返回的是类对象，当是类对象的时候，返回的是自身 object_getClass(xxx) 返回的是 isa 指向的对象。 所以 class_isMetaClass(object_getClass(self)) 如果是 true，那就说明 self 是类对象。直接通过 aspect_swizzleClassInPlace 方法替换其 forwardInvocation 实现。 对于类对象来说，一般情况下 [xxx class] 和 object_getClass(xxx) 返回的结果是一致的。但有一种特殊情况就是 KVO 对象，KVO 会动态生成一个类型，但是会重写修改 class 方法返回的结果。因此，[xxx class] !== object_getClass(xxx) 的时候就说明是 KVO 生成的对象。KVO 对象要 hook NSKVONotifing_xxx 的 forwardInvocation 方法。 前面把类对象都排除了，只剩下实例对象 hook 某个方法的情况。那么如何既不影响其他实例，又能 hook 它的一个的方法呢？我们可以拷贝这个类创建一个新类，然后只修改这个新类的这个方法的实现，就和 Linux 中创建新进程一样，也是实现 KVO 的做法。对于新创建的类，我们修改其 forwardInvocation 方法的指向，并通过 object_setClass 将当前实例的 isa 指向新创建的 class。 替换方法的实现为 _objc_msgForward这一段的过程在上面的注释中已经很清楚了。主要就是添加一个有前缀的方法，将原来的 IMP 指向它，然后将 _objc_msgForward 指向原来的 SEL 。 至此，hook 方法全部完成。 执行方法执行时会直接进入消息转发流程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// This is a macro so we get a cleaner stack trace.#define aspect_invoke(aspects, info) \for (AspectIdentifier *aspect in aspects) &#123;\ [aspect invokeWithInfo:info];\ if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \ &#125; \&#125;// This is the swizzled forwardInvocation: method./// msgForward 执行的方法static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; NSCParameterAssert(self); NSCParameterAssert(invocation); SEL originalSelector = invocation.selector; SEL aliasSelector = aspect_aliasForSelector(invocation.selector); /// invocation 的 selector 转为原方法 invocation.selector = aliasSelector; /// 获取这个对象对应的 AspectsContainer AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); /// 获取这个对象的 isa 对应的 AspectContainer，如果没有就一直到父类找 AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. /// 执行 container 相应生命周期的所有 aspect aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; /// 如果替换数组存在，那么替换，否则执行原方法 if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // If no hooks are installed, call original implementation (usually to throw an exception) /// 调用原方法 if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // Remove any hooks that are queued for deregistration. [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125; 整个过程就是从关联对象中取出 AspectContainer 实例，然后执行其中各个时间点的回调。你可能会很疑惑它获取关联对象和执行的语句： 123456// 获取AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);// 执行aspect_invoke(classContainer.afterAspects, info);aspect_invoke(objectContainer.afterAspects, info); 为什么既有从对象中获取关联对象，又有从对象的 isa 指向中获取关联对象的情况呢？对于 hook 类来说，实例的执行都应该是通过后者，从类中获取的。但是对于 hook 实例来说，他们的关联对象是存在实例中的。如果既 hook 了实例的某个方法，又 hook 了实例所在的类的同一个方法，那么两份 hook 都应该执行。 如果 hook 时候传入的 options 为 AspectOptionAutomaticRemoval，那么会在执行完毕后调用 AspectIdentifier 实例的 remove 方法移除 hook。 方法执行过程在 invokeWithInfo 方法中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// 执行这个 NSInvocation- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123; /// 创建一个 blockInvocation NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; /// 拿出原始的 Invocation NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // Be extra paranoid. We already check that on hook registration. /// 在创建的时候已经校验过了，这里再校验一次 if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@"Block has too many arguments. Not calling %@", info); return NO; &#125; /// 设置block中的上下文 if (numberOfArguments &gt; 1) &#123; /// block 比较特殊，设置它的 NSInvocation 时， index 为 0 的 argument 为 self, index 从 1 开始就是正常入参了 /// 普通的 NSInvocation，index 为 0 的 argument 是 self，index 为 1 的 argument 是 SEL /// Aspects 为了让 block 的参数也从 2 开始，默认将参数 1 设置为 AspectInfo [blockInvocation setArgument:&amp;info atIndex:1]; &#125; void *argBuf = NULL; /// 依次从原始的 Invocation 中将参数取出设置到 blockInvocation 中 for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx]; NSUInteger argSize; NSGetSizeAndAlignment(type, &amp;argSize, NULL); if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@"Failed to allocate memory for block invocation."); return NO; &#125; [originalInvocation getArgument:argBuf atIndex:idx]; [blockInvocation setArgument:argBuf atIndex:idx]; &#125; /// 执行这个 block [blockInvocation invokeWithTarget:self.block]; if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 和之前获取参数的时候类似，这里把参数一个个从 NSInvocation 中设置进去。最后通过 invokeWithTarget 执行 block。 总结Aspects 的核心原理和 JSPatch 是一致的。当然，它比 JSPatch 还是简单了许多。如果你理解了 JSPatch 中消息转发的过程，Aspects 理解起来就很简单了。 思考题 如何 hook 类方法？ 如何 hook 实例对象的方法？ block 的方法签名和普通方法的方法签名有什么不同？ 如何拿到 block 的方法签名？ 为什么 Aspects 中一个方法同一个继承链上只能 hook 一次？可以怎么改进？ 怎样判断一个实例对象是否进行过 kvo？ aspect 中怎么判断一个对象的 forwardInvocation 是否已经被 hook 过？ 如何判断一个对象是类对象还是实例对象？ [self class] 和 object_getClass(self) 的区别是什么？ 关联对象能否作用于类和元类？ 参考静下心来读源码之Aspects 从 Aspects 源码中我学到了什么？(写的太简略了)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch 源码解析(三)]]></title>
    <url>%2F2019%2F08%2F11%2Fjspatch3%2F</url>
    <content type="text"><![CDATA[这是 JSPatch 源码解析的第三部分，主要对之前遗漏的方法做一些补充，以及提供一些思考问题 补充js 方法补充将 OC 对象转为 js _formatOCToJS这个方法用于将 js 端接收到的 OC 对象转换为 js 对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243/// 把 oc 转化为 js 对象var _formatOCToJS = function(obj) &#123; // 如果 oc 端返回的直接是 undefined 或者 null，那么直接返回 false if (obj === undefined || obj === null) return false if (typeof obj == "object") &#123; // js 传给 oc 时会把自己包裹在 __obj 中。因此，存在 __obj 就可以直接拿到 js 对象 if (obj.__obj) return obj // 如果是空，那么直接返回 false。因为如果返回 null 的话，就无法调用方法了。 if (obj.__isNil) return false if (obj instanceof Array) &#123; // 如果是数组，要对每一个 oc 转 js 一下 var ret = [] obj.forEach(function(o) &#123; ret.push(_formatOCToJS(o)) &#125;) return ret &#125; if (obj instanceof Function) &#123; return function() &#123; var args = Array.prototype.slice.call(arguments) // 如果 oc 传给 js 的是一个函数，那么 js 端调用的时候就需要先把 js 参数转为 oc 对象，调用。 var formatedArgs = _OC_formatJSToOC(args) for (var i = 0; i &lt; args.length; i++) &#123; if (args[i] === null || args[i] === undefined || args[i] === false) &#123; formatedArgs.splice(i, 1, undefined) &#125; else if (args[i] == nsnull) &#123; formatedArgs.splice(i, 1, null) &#125; &#125; // 在调用完 oc 方法后，又要 oc 对象转为 js 对象回传给 oc return _OC_formatOCToJS(obj.apply(obj, formatedArgs)) &#125; &#125; if (obj instanceof Object) &#123; // 如果是一个 object 并且没有 __obj，那么把所有的 key 都 format 一遍 var ret = &#123;&#125; for (var key in obj) &#123; ret[key] = _formatOCToJS(obj[key]) &#125; return ret &#125; return obj&#125; 具体的过程做了详尽的注释。这里还要提一点，关于空对象的判断。由于 OC 的动态性，OC 中的 nil 发送消息会不响应任何方法。而 js 端的 undefined 或者 null 调用方法时则会直接报错。 因此，为了能让 js 端在接收到 oc 端的 nil 对象时也能调用，而不报错，针对 undefined， null 以及某些 OC 方法在返回空对象时手动返回的 {__isNil: true}， 这个方法都会将其解析为 bollean 值 false。 js 端空对象的调用在不报错后，还要阻止其针对 bollean 值 false 的消息转发。因此，之后在执行 __c() 调用 oc 方法时就会提前判断是否是 bollean 类型。如果是就说明是空对象，直接返回 false，而不进行消息转发。 定义 js 中的类 defineJSClassdefineClass 会在 oc 生成对应的类。而一些不需要继承 OC，和 OC 没有联系，只会在 JS 中使用的类，比如数据层的 dataSource/manager，直接使用 JS原生类就可以。因此添加了一个 defineJSClass 方法，可以减少转化为 OC 类时的性能损耗。 12345678910111213141516171819202122232425262728global.defineJSClass = function(declaration, instMethods, clsMethods) &#123; var o = function() &#123;&#125;, a = declaration.split(':'), clsName = a[0].trim(), superClsName = a[1] ? a[1].trim() : null o.prototype = &#123; init: function() &#123; if (this.super()) this.super().init() return this; &#125;, super: function() &#123; return superClsName ? _jsCls[superClsName].prototype : null &#125; &#125; var cls = &#123; alloc: function() &#123; return new o; &#125; &#125; for (var methodName in instMethods) &#123; o.prototype[methodName] = instMethods[methodName]; &#125; for (var methodName in clsMethods) &#123; cls[methodName] = clsMethods[methodName]; &#125; global[clsName] = cls _jsCls[clsName] = o&#125; 代码实现很简单，还是在全局域下创建一个相应类名的对象。然后把所有类方法和实例方法添加至对象中。由于是通过原型实现的，不了解 js 原型的同学可能稍难理解。 这个 defineJSClass 方法和 defineClass 创建的类对象基本一致。但是有两点不同： 不用 self 代替 this。 没有 property 由于是纯 js 实现，因此不需要用 self 代替 this，也不需要通过关联属性定义 property，直接把属性放在 js 端就可以了。 OC 方法补充将 js 对象转为 OC 对象 formatJSToOC针对几种特殊情况做处理，包括类型为 JPBoxing 类型，包含 __obj,__clsName,__isBlock 字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static id formatJSToOC(JSValue *jsval)&#123; id obj = [jsval toObject]; if (!obj || [obj isKindOfClass:[NSNull class]]) return _nilObj; // 如果是 JPBoxing 类型的，那么解包 if ([obj isKindOfClass:[JPBoxing class]]) return [obj unbox]; // 如果是数组类型的，那么把数组里的所有都 format 一遍 if ([obj isKindOfClass:[NSArray class]]) &#123; NSMutableArray *newArr = [[NSMutableArray alloc] init]; for (int i = 0; i &lt; [(NSArray*)obj count]; i ++) &#123; [newArr addObject:formatJSToOC(jsval[i])]; &#125; return newArr; &#125; // 如果是字典类型的 if ([obj isKindOfClass:[NSDictionary class]]) &#123; // 如果内部有 __obj 字段 if (obj[@"__obj"]) &#123; // 拿到 __obj 对应的对象 id ocObj = [obj objectForKey:@"__obj"]; if ([ocObj isKindOfClass:[JPBoxing class]]) return [ocObj unbox]; return ocObj; &#125; else if (obj[@"__clsName"]) &#123; // 如果存在 __clsName 对象，那么把 clsName 对应的 Class 拿出 return NSClassFromString(obj[@"__clsName"]); &#125; // 如果是 block if (obj[@"__isBlock"]) &#123; Class JPBlockClass = NSClassFromString(@"JPBlock"); if (JPBlockClass &amp;&amp; ![jsval[@"blockObj"] isUndefined]) &#123; return [JPBlockClass performSelector:@selector(blockWithBlockObj:) withObject:[jsval[@"blockObj"] toObject]]; &#125; else &#123; return genCallbackBlock(jsval); &#125; &#125; NSMutableDictionary *newDict = [[NSMutableDictionary alloc] init]; for (NSString *key in [obj allKeys]) &#123; [newDict setObject:formatJSToOC(jsval[key]) forKey:key]; &#125; return newDict; &#125; return obj;&#125; 将 OC 对象转为 js formatOCToJS将 OC 对象转为 JS 对象，为了方便 JS 调用，提前将 OC 对象的类取出，以 {__obj: xxx, __clsName: xxx} 的形式包裹： 12345678910111213141516171819202122// 把 oc 对象转为 js 对象 （增加了 __obj __clsName 等字段）static NSDictionary *_wrapObj(id obj)&#123; if (!obj || obj == _nilObj) &#123; return @&#123;@"__isNil": @(YES)&#125;; &#125; return @&#123;@"__obj": obj, @"__clsName": NSStringFromClass([obj isKindOfClass:[JPBoxing class]] ? [[((JPBoxing *)obj) unbox] class]: [obj class])&#125;;&#125;static id formatOCToJS(id obj)&#123; if ([obj isKindOfClass:[NSString class]] || [obj isKindOfClass:[NSDictionary class]] || [obj isKindOfClass:[NSArray class]] || [obj isKindOfClass:[NSDate class]]) &#123; return _autoConvert ? obj: _wrapObj([JPBoxing boxObj:obj]); &#125; if ([obj isKindOfClass:[NSNumber class]]) &#123; return _convertOCNumberToString ? [(NSNumber*)obj stringValue] : obj; &#125; if ([obj isKindOfClass:NSClassFromString(@"NSBlock")] || [obj isKindOfClass:[JSValue class]]) &#123; return obj; &#125; return _wrapObj(obj);&#125; 这里通过 formatOCToJS 转换后是一个包裹对象，传到 JS 端后还需要通过 _formatOCToJS 拿到 JS 真正想要的东西。 获取 protocol 中的某个方法的签名 methodTypesInProtocol可以说是一个方法模板了，没有特别的技巧： 1234567891011121314151617181920// 获取 protocol 中相应方法的函数签名static char *methodTypesInProtocol(NSString *protocolName, NSString *selectorName, BOOL isInstanceMethod, BOOL isRequired)&#123; // 获取 protocol Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]); unsigned int selCount = 0; // 复制 protocol 的方法列表 struct objc_method_description *methods = protocol_copyMethodDescriptionList(protocol, isRequired, isInstanceMethod, &amp;selCount); // 遍历 protocol 的方法列表，找到和目标方法同名的方法，然后通过 c 方法复制出来返回。否则返回 NULL for (int i = 0; i &lt; selCount; i ++) &#123; if ([selectorName isEqualToString:NSStringFromSelector(methods[i].name)]) &#123; char *types = malloc(strlen(methods[i].types) + 1); strcpy(types, methods[i].types); free(methods); return types; &#125; &#125; free(methods); return NULL;&#125; 新建协议在 JS 端定义协议非常简单，和创建类差不多，传入类名，类方法和实例方法： 1234global.defineProtocol = function(declaration, instProtos , clsProtos) &#123; var ret = _OC_defineProtocol(declaration, instProtos,clsProtos); return ret&#125; 来到 OC 中，调用的是 defineProtocol 方法。动态创建 protocol，向其中添加方法。 12345678910111213// 动态创建一个 protocolstatic void defineProtocol(NSString *protocolDeclaration, JSValue *instProtocol, JSValue *clsProtocol)&#123; const char *protocolName = [protocolDeclaration UTF8String]; // runtime 动态创建一个 protocol Protocol* newprotocol = objc_allocateProtocol(protocolName); if (newprotocol) &#123; // 为创建出来的 protocol 添加方法 addGroupMethodsToProtocol(newprotocol, instProtocol, YES); addGroupMethodsToProtocol(newprotocol, clsProtocol, NO); objc_registerProtocol(newprotocol); &#125;&#125; 从 JS 中传来的 Protocol 是一个字典类型。键是方法名，值是参数返回值的类型，如下： 1234567&#123; someFunctionName: &#123; paramsType: "param1,param2,param3", returnType: "returnType", typeEncode: "v@:" &#125;&#125; 添加方法这一步最重要的就是要获取方法的 typeEncode，如果注册者能够写出正确的 typeEncode 那么就可以直接注册了。但是由于 typeEncode 很多开发者不能正确写出，因此，又提供一套保底方案，通过 paramsType 和 returnType 解析出类型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 为 protocol 添加方法static void addGroupMethodsToProtocol(Protocol* protocol,JSValue *groupMethods,BOOL isInstance)&#123; NSDictionary *groupDic = [groupMethods toDictionary]; for (NSString *jpSelector in groupDic.allKeys) &#123; // 拿到代表每一个方法的字典 NSDictionary *methodDict = groupDic[jpSelector]; // 从字典中取出参数列表 NSString *paraString = methodDict[@"paramsType"]; // 取出返回类型，如果没有就是 void NSString *returnString = methodDict[@"returnType"] &amp;&amp; [methodDict[@"returnType"] length] &gt; 0 ? methodDict[@"returnType"] : @"void"; // 取出方法的typeEncode NSString *typeEncode = methodDict[@"typeEncode"]; // 切割参数列表，参数列表以 ，分割的字符串的形式传递 NSArray *argStrArr = [paraString componentsSeparatedByString:@","]; // 获取真正的方法名 NSString *selectorName = convertJPSelectorString(jpSelector); // 为了js端的写法好看点，末尾的参数可以不用写 `_` if ([selectorName componentsSeparatedByString:@":"].count - 1 &lt; argStrArr.count) &#123; selectorName = [selectorName stringByAppendingString:@":"]; &#125; // 如果有 typeEnable，那么直接添加方法 if (typeEncode) &#123; addMethodToProtocol(protocol, selectorName, typeEncode, isInstance); &#125; else &#123; if (!_protocolTypeEncodeDict) &#123; _protocolTypeEncodeDict = [[NSMutableDictionary alloc] init]; // 利用 # 宏，来将 _type 字符串化，键是 type，值是 type 的 encode #define JP_DEFINE_TYPE_ENCODE_CASE(_type) \ [_protocolTypeEncodeDict setObject:[NSString stringWithUTF8String:@encode(_type)] forKey:@#_type];\ JP_DEFINE_TYPE_ENCODE_CASE(id); JP_DEFINE_TYPE_ENCODE_CASE(BOOL); JP_DEFINE_TYPE_ENCODE_CASE(int); JP_DEFINE_TYPE_ENCODE_CASE(void); JP_DEFINE_TYPE_ENCODE_CASE(char); JP_DEFINE_TYPE_ENCODE_CASE(short); JP_DEFINE_TYPE_ENCODE_CASE(unsigned short); JP_DEFINE_TYPE_ENCODE_CASE(unsigned int); JP_DEFINE_TYPE_ENCODE_CASE(long); JP_DEFINE_TYPE_ENCODE_CASE(unsigned long); JP_DEFINE_TYPE_ENCODE_CASE(long long); JP_DEFINE_TYPE_ENCODE_CASE(float); JP_DEFINE_TYPE_ENCODE_CASE(double); JP_DEFINE_TYPE_ENCODE_CASE(CGFloat); JP_DEFINE_TYPE_ENCODE_CASE(CGSize); JP_DEFINE_TYPE_ENCODE_CASE(CGRect); JP_DEFINE_TYPE_ENCODE_CASE(CGPoint); JP_DEFINE_TYPE_ENCODE_CASE(CGVector); JP_DEFINE_TYPE_ENCODE_CASE(NSRange); JP_DEFINE_TYPE_ENCODE_CASE(NSInteger); JP_DEFINE_TYPE_ENCODE_CASE(Class); JP_DEFINE_TYPE_ENCODE_CASE(SEL); JP_DEFINE_TYPE_ENCODE_CASE(void*);#if TARGET_OS_IPHONE JP_DEFINE_TYPE_ENCODE_CASE(UIEdgeInsets);#else JP_DEFINE_TYPE_ENCODE_CASE(NSEdgeInsets);#endif [_protocolTypeEncodeDict setObject:@"@?" forKey:@"block"]; [_protocolTypeEncodeDict setObject:@"^@" forKey:@"id*"]; &#125; // 设置返回值的 encode NSString *returnEncode = _protocolTypeEncodeDict[returnString]; // 拼接上所有的 encode 成为这个方法的 encode if (returnEncode.length &gt; 0) &#123; NSMutableString *encode = [returnEncode mutableCopy]; [encode appendString:@"@:"]; for (NSInteger i = 0; i &lt; argStrArr.count; i++) &#123; NSString *argStr = trim([argStrArr objectAtIndex:i]); NSString *argEncode = _protocolTypeEncodeDict[argStr]; if (!argEncode) &#123; NSString *argClassName = trim([argStr stringByReplacingOccurrencesOfString:@"*" withString:@""]); if (NSClassFromString(argClassName) != NULL) &#123; argEncode = @"@"; &#125; else &#123; _exceptionBlock([NSString stringWithFormat:@"unreconized type %@", argStr]); return; &#125; &#125; [encode appendString:argEncode]; &#125; // 拼接好方法签名后给 protocol 增加方法 addMethodToProtocol(protocol, selectorName, encode, isInstance); &#125; &#125; &#125;&#125;// 真正的添加 protocol 方法的地方static void addMethodToProtocol(Protocol* protocol, NSString *selectorName, NSString *typeencoding, BOOL isInstance)&#123; SEL sel = NSSelectorFromString(selectorName); const char* type = [typeencoding UTF8String]; protocol_addMethodDescription(protocol, sel, type, YES, isInstance);&#125; 至此，协议就添加完成了。之后就可以给类添加这个协议了。 执行blockblock 本身就是对象，执行 block 也就是执行 block 下的函数指针指向的方法。因此，block 也是可以进行消息转发的。可以通过替换 forwardInvocation: 方法执行 js 部分的方法。 js 端定义 block当 OC 端需要 js 提供一个回调函数的时候。不能简单的只是提供一个 function。对于 OC 来说，它们需要知道函数的 typeEncode。因此，JSPatch 在 JS 端提供了一个 block 方法给使用者，使用者需要提前给出参数的类型： 1234567// Obj-C@implementation JPObject+ (void)request:(void(^)(NSString *content, BOOL success))callback&#123; callback(@"I'm content", YES);&#125;@end 1234// JSrequire('JPObject').request(block("NSString *, BOOL", function(ctn, succ) &#123; if (succ) log(ctn) //output: I'm content&#125;)) block 方法的定义方式如下： 123456789101112131415global.block = function(args, cb) &#123; var that = this var slf = global.self if (args instanceof Function) &#123; cb = args args = '' &#125; var callback = function() &#123; var args = Array.prototype.slice.call(arguments) global.self = slf return cb.apply(that, _formatOCToJS(args)) &#125; var ret = &#123;args: args, cb: callback, argCount: cb.length, __isBlock: 1&#125; return ret&#125; 它最终返回的任然是一个对象。并且在对象中提供了一个标识 __isBlock 。这个标识在之前的源码解析中都有涉及，只不过当时都略过了。下面来看看哪些地方对这个标识做了判断，且进行了处理。 OC 定义 block在将 js 对象转为 OC 对象的时候会调用 OC 的 formatJSToOC 方法，其中会判断传来的是否是 js 的 block。如果是，则要生成回调 block： 1234567891011121314151617// js 转为 oc 的对象static id formatJSToOC(JSValue *jsval)&#123; ... // 如果是 block if (obj[@"__isBlock"]) &#123; Class JPBlockClass = NSClassFromString(@"JPBlock"); if (JPBlockClass &amp;&amp; ![jsval[@"blockObj"] isUndefined]) &#123; // 此处是 JPBlock 拓展 return [JPBlockClass performSelector:@selector(blockWithBlockObj:) withObject:[jsval[@"blockObj"] toObject]]; &#125; else &#123; // 生成 block return genCallbackBlock(jsval); &#125; &#125; ...&#125; 普通的 block 走的是 genCallbackBlock 方法。它主要做了五件事： 创建空的 block 实例 根据参数类型，生成 block 函数的签名，并设置给空 block 通过关联对象将函数实现保存到空的 block 中 替换 NSBlock 的函数指针 invoke 为 msgForwardIMP 替换 NSBlock 的消息转发方法 forwardInvocation: 和获取签名方法 methodSignatureForSelector: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static id genCallbackBlock(JSValue *jsVal)&#123; // 创建空的 block 实例 void (^block)(void) = ^(void)&#123;&#125;; // 拿 p 指向刚刚创建的 block uint8_t *p = (uint8_t *)((__bridge void *)block); // 根据 block 的内存分布，增加了一个 void* 和 2个 int 之后， p 指向的是 invoke 方法 p += sizeof(void *) + sizeof(int32_t) *2; // 新建一个二级指针 invoke 指向 p 的当前位置 void(**invoke)(void) = (void (**)(void))p; // p 在增加一个 void* 和两个 ptr 的大小，p指向的的是 signature // hook 的 block 一定是个不使用外部变量的全局 block，所以没有 copy 和 dispose 函数。因此直接满足下面的公式 p += sizeof(void *) + sizeof(uintptr_t) * 2; // 新建一个二级指针 signature 指向 p 的当前位置 const char **signature = (const char **)p; static NSMutableDictionary *typeSignatureDict; if (!typeSignatureDict) &#123; typeSignatureDict = [NSMutableDictionary new]; // 把各个类型的签名都存放到 typeSignatureDict 字典中 #define JP_DEFINE_TYPE_SIGNATURE(_type) \ [typeSignatureDict setObject:@[[NSString stringWithUTF8String:@encode(_type)], @(sizeof(_type))] forKey:@#_type];\ JP_DEFINE_TYPE_SIGNATURE(id); JP_DEFINE_TYPE_SIGNATURE(BOOL); JP_DEFINE_TYPE_SIGNATURE(int); JP_DEFINE_TYPE_SIGNATURE(void); JP_DEFINE_TYPE_SIGNATURE(char); JP_DEFINE_TYPE_SIGNATURE(short); JP_DEFINE_TYPE_SIGNATURE(unsigned short); JP_DEFINE_TYPE_SIGNATURE(unsigned int); JP_DEFINE_TYPE_SIGNATURE(long); JP_DEFINE_TYPE_SIGNATURE(unsigned long); JP_DEFINE_TYPE_SIGNATURE(long long); JP_DEFINE_TYPE_SIGNATURE(unsigned long long); JP_DEFINE_TYPE_SIGNATURE(float); JP_DEFINE_TYPE_SIGNATURE(double); JP_DEFINE_TYPE_SIGNATURE(bool); JP_DEFINE_TYPE_SIGNATURE(size_t); JP_DEFINE_TYPE_SIGNATURE(CGFloat); JP_DEFINE_TYPE_SIGNATURE(CGSize); JP_DEFINE_TYPE_SIGNATURE(CGRect); JP_DEFINE_TYPE_SIGNATURE(CGPoint); JP_DEFINE_TYPE_SIGNATURE(CGVector); JP_DEFINE_TYPE_SIGNATURE(NSRange); JP_DEFINE_TYPE_SIGNATURE(NSInteger); JP_DEFINE_TYPE_SIGNATURE(Class); JP_DEFINE_TYPE_SIGNATURE(SEL); JP_DEFINE_TYPE_SIGNATURE(void*); JP_DEFINE_TYPE_SIGNATURE(void *); &#125; // 拿到创建 block 时传过来的参数数组 NSString *types = [jsVal[@"args"] toString]; // 传过来的参数数组以 ，分割 NSArray *lt = [types componentsSeparatedByString:@","]; // block 的函数签名不是 @: 而是 @? NSString *funcSignature = @"@?0"; NSInteger size = sizeof(void *); // for 循环，把 args 中的类型对应的签名都拿到，然后设置到 funcSignature 中。 for (NSInteger i = 1; i &lt; lt.count;) &#123; NSString *t = trim(lt[i]); NSString *tpe = typeSignatureDict[typeSignatureDict[t] ? t : @"id"][0]; if (i == 0) &#123; funcSignature =[[NSString stringWithFormat:@"%@%@",tpe, [@(size) stringValue]] stringByAppendingString:funcSignature]; break; &#125; funcSignature = [funcSignature stringByAppendingString:[NSString stringWithFormat:@"%@%@", tpe, [@(size) stringValue]]]; size += [typeSignatureDict[typeSignatureDict[t] ? t : @"id"][1] integerValue]; i = (i != lt.count - 1) ? i + 1 : 0; &#125; IMP msgForwardIMP = _objc_msgForward; // 将当前 block 的方法实现指针指向 _objc_msgForward *invoke = (void *)msgForwardIMP; const char *fs = [funcSignature UTF8String]; char *s = malloc(strlen(fs)); strcpy(s, fs); // 将 block 的签名指向新生成的签名 *signature = s; // 将 js 端传来的函数实现以 _JSValue 的关联属性的方式保存在 block 中 objc_setAssociatedObject(block, "_JSValue", jsVal, OBJC_ASSOCIATION_RETAIN_NONATOMIC); static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 获取 NSBlock 的 class Class cls = NSClassFromString(@"NSBlock"); // 要 hook block 就要替换 NSBlock 的 forwardInvocation 和 methodSignatureForSelector 方法#define JP_HOOK_METHOD(selector, func) &#123;Method method = class_getInstanceMethod([NSObject class], selector); \BOOL success = class_addMethod(cls, selector, (IMP)func, method_getTypeEncoding(method)); \if (!success) &#123; class_replaceMethod(cls, selector, (IMP)func, method_getTypeEncoding(method));&#125;&#125; JP_HOOK_METHOD(@selector(methodSignatureForSelector:), block_methodSignatureForSelector); JP_HOOK_METHOD(@selector(forwardInvocation:), JPForwardInvocation); &#125;); return block;&#125; JSPatch 中的 block 的处理应该是参考了 Aspects 中对于 block 的处理方式。将 block 的 IMP 指向 objc_msgForward，并且替换了 NSBlock 的消息转发方法，所有相关 block 的执行都会走到 JPForwardInvocation 方法中: 12345678static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; ... JSValue *jsFunc = isBlock ? objc_getAssociatedObject(assignSlf, "_JSValue")[@"cb"] : getJSFunctionInObjectHierachy(slf, JPSelectorName); ...&#125; 判断如果是一个 block，就从关联属性中拿到 callback，然后执行。 函数签名的获取方法 methodSignatureForSelector 也被替换为从 NSBlock 中直接获取： 123456NSMethodSignature *block_methodSignatureForSelector(id self, SEL _cmd, SEL aSelector) &#123; uint8_t *p = (uint8_t *)((__bridge void *)self); p += sizeof(void *) * 2 + sizeof(int32_t) *2 + sizeof(uintptr_t) * 2; const char **signature = (const char **)p; return [NSMethodSignature signatureWithObjCTypes:*signature];&#125; 因为 JSPatch 中的 block 都是没有用到外部变量的，所以是全局 block，不会存在 copy 和 dispose 函数，这和 Aspects 中的不同，Aspects 中的 block 时可能引用外部变量的，因此需要多做一步判断，通过 block 的 flag 判断 block 的类型。 总结再来总结一下 JSPatch 的执行流程。 定义方法 创建一个 JSContext 并把各种方法通过 JSContext 提供给 js 将 js 重写的方法方法通过正则表达式改写为 __c() 的形式 预处理提供给 OC 调用的各个方法，hook每一个方法，将方法的第一个参数取出，并赋给 global.self。这就是 OC 调用提供的上下文。OC 将会把这些方法保存在 _JSOverideMethods 字典中 预处理提供给 OC 调用的各个方法，hook每一个方法，将 this 赋给 global.self 。这就是 JS 调用时的上下文。JS 会把这些方法保存在 _ocCls 中 OC 端解析 js 传来的类和方法，将方法实现替换为 _objc_msgForward，替换定义类的消息转发方法为 JPForwardInvocation: 执行方法分为两种情况： js 调用 js 重写的方法。这种情况下，在 _ocCls 字典中找到相应的方法直接执行 oc 调用 js 重写的方法。分为两步： oc 调用方法，主要是创建 NSInvocation，并根据 SEL 的函数函数签名将 js 传来的参数根据类型设置到 NSInvocation 上。然后执行 来到 JPForwardInvocation 实际执行方法，在 _JSOverideMethods 中找到对应的 js 实现，如果没有走原始的消息转发。将结果设置到 NSInvocation 的 returnValue 中 思考题 require(xxx) 做了什么？ JS 中的链式调用时如何实现的？ JS 端和 OC 端如何通信的？ JS 端如何调用 OC 的某个对象的实例方法？ OC 端拿到 JS 传来的对象方法名参数之后要如何调用？ 如何实现方法替换？ 为什么JS端新增方法要在 OC 中 class_addMethod() 再走一遍完整转发流程，而不是直接通过消息转发？ 如何给类添加属性？ self 关键字如何处理？ OC 中无法动态获取 super，那么 super 方法如何调用的？ JSBoxing 的作用是什么？ OC 中的 nil 到 JS 中就变成了 null，就无法链式调用，那么要怎么解决？ JS 如何支持自定义 struct 的？ 可变参数方法如何调用？ dealloc hook 的时候做了哪些特殊处理？ JS 端重写的方法调用另一个 JS 端重写的方法，如何做到不用 JS -&gt; OC -&gt; JS 这样周转？ defineJSClass 作用是什么？实现原理是怎么样的？ 如何 hook 带有 block 的 OC 方法？ JS 方法中如何调用 C 函数？ 参考链接iOS 热更新解读（二）—— JSPatch 源码解析 JSPatch 实现原理详解系列 探究Block之MethodSignature(文章中关于 block 方法签名处有结论性的错误，堆 block 中含有 copy 和 dispose 方法，而全局 block 没有这两个方法，它的验证试验的结论也是错的。)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch 源码解析(二)]]></title>
    <url>%2F2019%2F08%2F08%2Fjspatch2%2F</url>
    <content type="text"><![CDATA[这是 JSPatch 源码解析的第二部分。主要解释 JS 与 OC 的相互调用 执行流程js 端调用前面说过，所有 js 中定义的方法调用都会被预处理替换为 __c() 的形式。这是方法调用的起点。主要逻辑如下： 判断调用者是否是 bool 类型，是的话直接返回 false 如果调用的方法是重写的方法，那么绑定上下文 如果调用的是父类方法，那么将 __clsName 设置为父类方法名，从 __ocCls 数组中取出父类的方法调用。 如果调用的方法不是 js 定义的方法那么走到 oc 调用 第一步判断是否是 bool 类型的原因在下面的注释中有细说，主要是为了能让 js 代码在 oc 返回的对象是 nil 的情况下也能调用，不报错。 123456789101112131415161718192021222324252627282930313233343536373839/// 调用 native 相应的方法__c: function(methodName) &#123; var slf = this // 如果 oc 返回了一个空对象，在 js 端会以 false 的形式接受。当这个空对象再调用方法的时候，就会走到这个分支中，直接返回 false，而不会走 oc 的消息转发 if (slf instanceof Boolean) &#123; return function() &#123; return false &#125; &#125; if (slf[methodName]) &#123; return slf[methodName].bind(slf); &#125; if (!slf.__obj &amp;&amp; !slf.__clsName) &#123; throw new Error(slf + '.' + methodName + ' is undefined') &#125; /// 如果当前调用的父类的方法，那么通过 OC 方法获取该 clsName 的父类的名字 if (slf.__isSuper &amp;&amp; slf.__clsName) &#123; slf.__clsName = _OC_superClsName(slf.__obj.__realClsName ? slf.__obj.__realClsName: slf.__clsName); &#125; var clsName = slf.__clsName if (clsName &amp;&amp; _ocCls[clsName]) &#123; /// 根据 __obj 字段判断是否是实例方法或者类方法 var methodType = slf.__obj ? 'instMethods': 'clsMethods' /// 如果当前方法是提前定义的方法，那么直接走定义方法的调用 if (_ocCls[clsName][methodType][methodName]) &#123; slf.__isSuper = 0; return _ocCls[clsName][methodType][methodName].bind(slf) &#125; &#125; /// 当前方法不是在 js 中定义的，那么直接调用 oc 的方法 return function()&#123; var args = Array.prototype.slice.call(arguments) return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper) &#125;&#125; __realClsName 和 __clsName 一般情况下是相等的，但是如果要调用的是父类的方法，那么 __clsName 会被替换为父类名，而子类名仍然是 __realClsName 调用 oc 方法通过 _methodFunc 执行： 1234567891011121314151617181920/// 执行 js 方法, 返回 js 对象// 把要调用的方法名类名，参数传递给 ocvar _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) &#123; var selectorName = methodName // js 端的方法都是 xxx_xxx 的形式，而 oc 端的方法已经在 defineClass 的时候转为了 xxx:xxx: 的形式。所以一般情况下 js 调用 oc 方法的时候都需要先把方法名转换一下。也就是当 isPerformSelector 为 false 的情况。 // 那么什么时候这个属性为 true 呢？当 js 端调用 performSelector 这个的方法的时候。这个方法默认需要传入 xxx:xxx: 形式的 OC selector 名。 // 一般 performSelector 用于从 oc 端动态传来 selectorName 需要 js 执行的时候。没有太多的使用场景 if (!isPerformSelector) &#123; methodName = methodName.replace(/__/g, "-") selectorName = methodName.replace(/_/g, ":").replace(/-/g, "_") var marchArr = selectorName.match(/:/g) var numOfArgs = marchArr ? marchArr.length : 0 if (args.length &gt; numOfArgs) &#123; selectorName += ":" &#125; &#125; var ret = instance ? _OC_callI(instance, selectorName, args, isSuper): _OC_callC(clsName, selectorName, args) return _formatOCToJS(ret)&#125; 由于 OC 端的参数都在 defineClass 的时候做了处理，从 xxx_xxx 变为了 xxx:xxx:，js 端则没有做任何处理仍然是 xxx_xxx。因此，就需要在调用前将方法名进行修改。最终根据是否是类方法来决定调用 _OC_callI 还是 _OC_callC。 OC 端执行OC 端执行涉及到的几个方法是 JSPatch 最重要的几个方法了。涉及到方法的调用，方法签名的获取，方法的消息转发 OC 执行方法js 端调用 _OC_callI 或者 _OC_callC 之后都会来到 OC 的 callSelector() 方法中。 特殊情况处理 处理调用父类方法 创建 NSInvocation 处理可变参数方法 设置 NSInvocation 参数 执行并返回结果给 js 处理特殊情况这一步主要包含两种特殊情况： 执行方法的是实例对象还是类还是空对象 执行的方法是 toJS 方法 调用 formatJSToOC 方法，把调用者和参数都转为 OC 的对象，这个方法连同后面将OC结果转JS的方法 formatOCToJS 会在后面单独说。 首先判断 JS 传来的调用者的类型。如果 class_isMetaClass 得到的是 true，就表示是一个类对象。如果是 Bool 类型，或者是 _nilObj 那么直接返回 {isNil: true} 这样，JS 端就知道是空对象了。 之后判断调用方法是否是 toJS。这个方法用来将 OC 对象转为形如 {__obj: xxx, clsName: xxx} 的 js 对象返回。 1234567891011121314151617181920212223242526272829static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)&#123; // realClsName 是真正要调用的类，和 clsName 的区别在于如果要调用的方法是父类方法，那么 clsName 会变为父类名，而 realClsName 仍然是子类名 NSString *realClsName = [[instance valueForProperty:@"__realClsName"] toString]; // 校验调用对象是否是类名，是否是空对象 if (instance) &#123; instance = formatJSToOC(instance); if (class_isMetaClass(object_getClass(instance))) &#123; className = NSStringFromClass((Class)instance); instance = nil; &#125; else if (!instance || instance == _nilObj || [instance isKindOfClass:[JPBoxing class]]) &#123; return @&#123;@"__isNil": @(YES)&#125;; &#125; &#125; // 把参数列表从 JS 转到 OC id argumentsObj = formatJSToOC(arguments); /** 如果要执行的方法是"toJS"，即转化为js类型 对于NSString/NSNumber/NSData 等可以直接转为 js 对象的直接转为 js 默认对象 对于普通 oc 对象，转为 &#123;__obj: xxx, __clsName: xxx&#125; 的包裹形式 **/ if (instance &amp;&amp; [selectorName isEqualToString:@"toJS"]) &#123; if ([instance isKindOfClass:[NSString class]] || [instance isKindOfClass:[NSDictionary class]] || [instance isKindOfClass:[NSArray class]] || [instance isKindOfClass:[NSDate class]]) &#123; return _unboxOCObjectToJS(instance); &#125; &#125; ...&#125; toJS 方法的实现： 123456789101112131415161718192021222324252627282930313233// 把 oc 对象转为 js 对象 （增加了 __obj __clsName 等字段）static NSDictionary *_wrapObj(id obj)&#123; if (!obj || obj == _nilObj) &#123; return @&#123;@"__isNil": @(YES)&#125;; &#125; return @&#123;@"__obj": obj, @"__clsName": NSStringFromClass([obj isKindOfClass:[JPBoxing class]] ? [[((JPBoxing *)obj) unbox] class]: [obj class])&#125;;&#125;// 如果是 NSString，NSNumber，NSDate，NSBlock 直接返回，// 如果是 NSArray 或者 NSDictionary 把内部解包// 否则以 &#123;__obj: xxx, __clsName: xxx&#125; 的形式包裹对象static id _unboxOCObjectToJS(id obj)&#123; if ([obj isKindOfClass:[NSArray class]]) &#123; NSMutableArray *newArr = [[NSMutableArray alloc] init]; for (int i = 0; i &lt; [(NSArray*)obj count]; i ++) &#123; [newArr addObject:_unboxOCObjectToJS(obj[i])]; &#125; return newArr; &#125; if ([obj isKindOfClass:[NSDictionary class]]) &#123; NSMutableDictionary *newDict = [[NSMutableDictionary alloc] init]; for (NSString *key in [obj allKeys]) &#123; [newDict setObject:_unboxOCObjectToJS(obj[key]) forKey:key]; &#125; return newDict; &#125; if ([obj isKindOfClass:[NSString class]] ||[obj isKindOfClass:[NSNumber class]] || [obj isKindOfClass:NSClassFromString(@"NSBlock")] || [obj isKindOfClass:[NSDate class]]) &#123; return obj; &#125; return _wrapObj(obj);&#125; 处理调用父类方法如果 js 端调用的是父类的方法，那么模拟 OC 调用父类的过程。OC 中调用父类，调用者还是当前子类，但是调用的 IMP 则是父类方法的 IMP。因此，要模拟 OC 中的方法调用，需要给 OC 添加和父类一样的 IMP 实现。以 SUPER_XXX 表示 SEL。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)&#123; ... // realClsName 是真正要调用的类，和 clsName 的区别在于如果要调用的方法是父类方法，那么 clsName 会变为父类名，而 realClsName 仍然是子类名 NSString *realClsName = [[instance valueForProperty:@"__realClsName"] toString]; Class cls = instance ? [instance class] : NSClassFromString(className); SEL selector = NSSelectorFromString(selectorName); NSString *superClassName = nil; if (isSuper) &#123; // 创建一个 SUPER_$&#123;selectorName&#125; 的 SEL NSString *superSelectorName = [NSString stringWithFormat:@"SUPER_%@", selectorName]; SEL superSelector = NSSelectorFromString(superSelectorName); // 通过 js 传来的 realClsName 拿到 superCls Class superCls; if (realClsName.length) &#123; Class defineClass = NSClassFromString(realClsName); // 如果 realClsName 的父类能找到就用 realClsName 的父类，否则就直接用传过来的 className 转的 cls superCls = defineClass ? [defineClass superclass] : [cls superclass]; &#125; else &#123; superCls = [cls superclass]; &#125; // 获取 superCls 对应的原始方法的函数指针 Method superMethod = class_getInstanceMethod(superCls, selector); IMP superIMP = method_getImplementation(superMethod); // 给当前的 class 添加一个 superSelector, 形式为 SUPER_XXX 的形式，这个方法的指针指向父类方法 // 之所以给子类添加一个指向父类实现的方法是因为 OC 中调用父类方法调用者也是子类，是通过转发调用到父类实现的。 // 这里就是模拟了这个过程，直接给子类添加父类实现的方法 class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod)); // 因为是给子类动态添加的 $&#123;SUPER_XXX&#125; 的方法，它的实现是指向父类相应的原始方法。如果父类的方法被 JS 重写了，那么 $&#123;SUPER_XXX&#125; 也应该被 JS 重写。所以这里要对 $&#123;SUPER_XXX&#125; 的方法进行 JS 的替换 NSString *JPSelectorName = [NSString stringWithFormat:@"_JP%@", selectorName]; JSValue *overideFunction = _JSOverideMethods[superCls][JPSelectorName]; if (overideFunction) &#123; overrideMethod(cls, superSelectorName, overideFunction, NO, NULL); &#125; selector = superSelector; superClassName = NSStringFromClass(superCls); &#125; ...&#125; 创建 NSInvocation这一段比较简单，就是创建 NSInvocation ，并且获取方法签名。其中将缓存存放在 _JSMethodSignatureCache 字典中的操作我认为意义不大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)&#123; ... // 创建 NSInvocation NSInvocation *invocation; NSMethodSignature *methodSignature; // 缓存实例的方法签名,虽然我觉得用处不大 if (!_JSMethodSignatureCache) &#123; _JSMethodSignatureCache = [[NSMutableDictionary alloc]init]; &#125; if (instance) &#123; [_JSMethodSignatureLock lock]; if (!_JSMethodSignatureCache[cls]) &#123; _JSMethodSignatureCache[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc]init]; &#125; methodSignature = _JSMethodSignatureCache[cls][selectorName]; if (!methodSignature) &#123; methodSignature = [cls instanceMethodSignatureForSelector:selector]; _JSMethodSignatureCache[cls][selectorName] = methodSignature; &#125; [_JSMethodSignatureLock unlock]; if (!methodSignature) &#123; _exceptionBlock([NSString stringWithFormat:@"unrecognized selector %@ for instance %@", selectorName, instance]); return nil; &#125; // 创建 NSInvocation invocation = [NSInvocation invocationWithMethodSignature:methodSignature]; [invocation setTarget:instance]; &#125; else &#123; // 如果是类方法，直接获取函数签名 methodSignature = [cls methodSignatureForSelector:selector]; if (!methodSignature) &#123; _exceptionBlock([NSString stringWithFormat:@"unrecognized selector %@ for class %@", selectorName, className]); return nil; &#125; invocation= [NSInvocation invocationWithMethodSignature:methodSignature]; [invocation setTarget:cls]; &#125; // 设置 NSInvocation 的 SEL [invocation setSelector:selector]; ...&#125; 处理可变参数方法方法签名的参数个数小于实际传入的参数就是可变参数方法。重写可变参数方法容易，但是直接调用可变参数方法却比较难。因为，通过 objc_msgSend 需要确定调用固定参数的个数。 因为编译的时候要根据调用的参数个数类型分配参数入栈空间，针对不同 CPU 来生成不同的汇编代码。所以不能再不知道入参个数和类型的情况下动态调用。因此，forwardInvocation 的时候才必须要有方法签名。 c 函数的动态调用也是一样，无法直接通过获取函数指针调用。因此参数的处理肯定是不一致的。如果想要动态调用，必须通过其他手段消除这个问题。可以使用 libffi 库。 既然 objc_msgSend 需要明确知道固定参数的个数，那么我们就把它确定参数个数的方法都实现一遍就好了。比如： 1id (*new_msgSend1)(id, SEL, id,...) = (id (*)(id, SEL, id,...)) objc_msgSend; 上面就声明了一个 new_msgSend1，实现了调用固定参数一个，后续是可变参数的方法。同样的，我们可以声明两个固定参数，乃至 n 个固定参数的方法。但是这样有一个缺陷就是只能调用所有参数都是 id 类型的方法，因为无法提前确定参数类型。 各个固定参数个数的 objc_msgSend 方法定义好后，就可以根据 JS 端传来的参数个数和方法签名的实际参数个数来决定调用哪个 objc_msgSend 了。 1234567891011121314151617static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)&#123; ... // 处理可变参数 NSUInteger numberOfArguments = methodSignature.numberOfArguments; NSInteger inputArguments = [(NSArray *)argumentsObj count]; // 针对可变参数个数的方法。参数个数会大于方法签名的参数的个数就是可变参数方法 if (inputArguments &gt; numberOfArguments - 2) &#123; // 只支持参数o都是 id 类型，并且返回类型也是 id 类型。 id sender = instance != nil ? instance : cls; id result = invokeVariableParameterMethod(argumentsObj, methodSignature, sender, selector); return formatOCToJS(result); &#125; ...&#125; (invokeVariableParameterMethod() 方法就省略了，用了大量的宏来定义和代用 objc_msgSend，有兴趣可以自己查看) 设置 NSInvocation 参数设置 NSInvocation 参数也是一个非常冗长的方法。这个方法的起因是 JS 端传来的 JSValue 类型的参数在最开始 formatJSToOC 的时候都变为了统一类型 id 类型。设置 NSInvocation 参数的时候要恢复其原来的类型。 以下方法做了详尽的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)&#123; ... for (NSUInteger i = 2; i &lt; numberOfArguments; i++) &#123; const char *argumentType = [methodSignature getArgumentTypeAtIndex:i]; id valObj = argumentsObj[i-2]; // 根据 argumentType 表示的类型，设置 NSInvocation 的参数类型 switch (argumentType[0] == 'r' ? argumentType[1] : argumentType[0]) &#123; // 判断是否是当前的 type，如果是，就设置 invocation 的第 i 个元素设置为该类型，值为 valObj #define JP_CALL_ARG_CASE(_typeString, _type, _selector) \ case _typeString: &#123; \ _type value = [valObj _selector]; \ [invocation setArgument:&amp;value atIndex:i];\ break; \ &#125; JP_CALL_ARG_CASE('c', char, charValue) JP_CALL_ARG_CASE('C', unsigned char, unsignedCharValue) JP_CALL_ARG_CASE('s', short, shortValue) JP_CALL_ARG_CASE('S', unsigned short, unsignedShortValue) JP_CALL_ARG_CASE('i', int, intValue) JP_CALL_ARG_CASE('I', unsigned int, unsignedIntValue) JP_CALL_ARG_CASE('l', long, longValue) JP_CALL_ARG_CASE('L', unsigned long, unsignedLongValue) JP_CALL_ARG_CASE('q', long long, longLongValue) JP_CALL_ARG_CASE('Q', unsigned long long, unsignedLongLongValue) JP_CALL_ARG_CASE('f', float, floatValue) JP_CALL_ARG_CASE('d', double, doubleValue) JP_CALL_ARG_CASE('B', BOOL, boolValue) // selector类型 case ':': &#123; SEL value = nil; if (valObj != _nilObj) &#123; value = NSSelectorFromString(valObj); &#125; [invocation setArgument:&amp;value atIndex:i]; break; &#125; // 结构体类型 case '&#123;': &#123; // 获取结构体名 NSString *typeString = extractStructName([NSString stringWithUTF8String:argumentType]); // 去除 js 的参数 JSValue *val = arguments[i-2]; // 如果结构体是给定的类型，那么就把 js 的参数转化为该类型的结构体设置到 invocation 中去 #define JP_CALL_ARG_STRUCT(_type, _methodName) \ if ([typeString rangeOfString:@#_type].location != NSNotFound) &#123; \ _type value = [val _methodName]; \ [invocation setArgument:&amp;value atIndex:i]; \ break; \ &#125; // 校验是否是 Rect，Point，Size，Range 四种结构体 JP_CALL_ARG_STRUCT(CGRect, toRect) JP_CALL_ARG_STRUCT(CGPoint, toPoint) JP_CALL_ARG_STRUCT(CGSize, toSize) JP_CALL_ARG_STRUCT(NSRange, toRange) @synchronized (_context) &#123; // 检查是否是通过 defineStruct 定义的结构体 // 结构体包含的键为 types 结构体的类型，keys 结构体的u键 NSDictionary *structDefine = _registeredStruct[typeString]; if (structDefine) &#123; // 拿到结构体的大小 size_t size = sizeOfStructTypes(structDefine[@"types"]); // 创建相应大小的内存地址 void *ret = malloc(size); // 把 valObj 里的数据复制到 ret 上 getStructDataWithDict(ret, valObj, structDefine); // 设置 ret 为 invocation 的参数 [invocation setArgument:ret atIndex:i]; // chuan free(ret); break; &#125; &#125; break; &#125; // 指针类型 case '*': case '^': &#123; // 如果是 JPBoxing 类型，那么解包,如果不是 JPBoxing 类型，那么继续往下走 if ([valObj isKindOfClass:[JPBoxing class]]) &#123; void *value = [((JPBoxing *)valObj) unboxPointer]; // ^@ 表示一个指向id类型的指针 if (argumentType[1] == '@') &#123; if (!_TMPMemoryPool) &#123; _TMPMemoryPool = [[NSMutableDictionary alloc] init]; &#125; // 把 JPBoxing 放到 markArray 数组中 if (!_markArray) &#123; _markArray = [[NSMutableArray alloc] init]; &#125; memset(value, 0, sizeof(id)); [_markArray addObject:valObj]; &#125; [invocation setArgument:&amp;value atIndex:i]; break; &#125; &#125; // class 类型 case '#': &#123; // 如果是 JPBoxing 类型那么解包，如果不是那么继续往下走 if ([valObj isKindOfClass:[JPBoxing class]]) &#123; Class value = [((JPBoxing *)valObj) unboxClass]; [invocation setArgument:&amp;value atIndex:i]; break; &#125; &#125; default: &#123; // null 类型 if (valObj == _nullObj) &#123; valObj = [NSNull null]; [invocation setArgument:&amp;valObj atIndex:i]; break; &#125; if (valObj == _nilObj || ([valObj isKindOfClass:[NSNumber class]] &amp;&amp; strcmp([valObj objCType], "c") == 0 &amp;&amp; ![valObj boolValue])) &#123; valObj = nil; [invocation setArgument:&amp;valObj atIndex:i]; break; &#125; // block 类型 if ([(JSValue *)arguments[i-2] hasProperty:@"__isBlock"]) &#123; JSValue *blkJSVal = arguments[i-2]; Class JPBlockClass = NSClassFromString(@"JPBlock"); if (JPBlockClass &amp;&amp; ![blkJSVal[@"blockObj"] isUndefined]) &#123; __autoreleasing id cb = [JPBlockClass performSelector:@selector(blockWithBlockObj:) withObject:[blkJSVal[@"blockObj"] toObject]]; [invocation setArgument:&amp;cb atIndex:i]; Block_release((__bridge void *)cb); &#125; else &#123; __autoreleasing id cb = genCallbackBlock(arguments[i-2]); [invocation setArgument:&amp;cb atIndex:i]; &#125; &#125; else &#123; [invocation setArgument:&amp;valObj atIndex:i]; &#125; &#125; &#125; &#125; ...&#125; 注意，如果期待的入参的 typeencoding 是 ^@，即方法需要一个二级指针作为参数的时候。会创建一个 _TMPMemoryPool 字典，以及一个 _markArray 数组，并把参数 push 到数组中。这两个对象会在执行完成是用到，下面再说。 执行并返回结果给 js执行的时候会判断是否是父类方法，如果执行的是父类方法，那么会把它预存在 _currInvokeSuperClsName 字典中。因为前面我们处理父类方法的时候是给子类添加 SUPER_XXX 的 SEL。在后面消息转发时，在 _JSOverideMethods 字典中保存的则是 XXX 的 SEL。因此，保存在 _currInvokeSuperClsName 字典中就是要说明这是调用的父类的方法，要把 SUPER_ 前缀去掉，到父类的重写方法中找。 12345678910111213static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)&#123; ... // 如果执行的是子类，那么在 _currInvokeSuperClsName 中保存 if (superClassName) _currInvokeSuperClsName[selectorName] = superClassName; // 执行方法 [invocation invoke]; // 执行完方法后从 _currInvokeSuperClsName 移除 if (superClassName) [_currInvokeSuperClsName removeObjectForKey:selectorName]; ...&#125; 在方法执行完成后，会对 _TMPMemoryPool 和 _markArray 进行处理。具体场景再补充中说，这里只是添加注释： 1234567891011121314151617181920212223static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)&#123; ... if ([_markArray count] &gt; 0) &#123; for (JPBoxing *box in _markArray) &#123; // pointer 是一个二级指针 // 执行完方法后，二级指针会被指向一个指针 void *pointer = [box unboxPointer]; // 让 obj 指向二级指针pointer指向的指针指向的值 id obj = *((__unsafe_unretained id *)pointer); if (obj) &#123; @synchronized(_TMPMemoryPool) &#123; // 如果二级指针指向的地址确实存在，那么就把 obj 暂时保存起来，防止被回收了。 // 因为上面的 obj 是 unsafe_unretained 的 [_TMPMemoryPool setObject:obj forKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]]; &#125; &#125; &#125; &#125; ...&#125; 最后对 OC 执行返回的结果 JS 化。这里存在一个内存泄漏的问题。即当动态调用的方法是 alloc，new，copy，mutableCopy 时，ARC 不会在尾部插入 release 语句，即多了一次引用计数，需要通过 (__bridge_transfer id) 将 c 对象转为 OC 对象，并自动释放一次引用计数，以此来达到引用计数的平衡： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 char returnType[255]; strcpy(returnType, [methodSignature methodReturnType]); id returnValue; // 不是 void 类型 if (strncmp(returnType, "v", 1) != 0) &#123; // 是 id 类型需要判断是不是创建新对象 if (strncmp(returnType, "@", 1) == 0) &#123; void *result; // 拿到返回值 [invocation getReturnValue:&amp;result]; //For performance, ignore the other methods prefix with alloc/new/copy/mutableCopy if ([selectorName isEqualToString:@"alloc"] || [selectorName isEqualToString:@"new"] || [selectorName isEqualToString:@"copy"] || [selectorName isEqualToString:@"mutableCopy"]) &#123; // 针对 alloc 等方法，需要通过 __bridge_transfer 减去引用计数 returnValue = (__bridge_transfer id)result; &#125; else &#123; returnValue = (__bridge id)result; &#125; // 将 OC 转为 JS 返回 return formatOCToJS(returnValue); &#125; else &#123; // 其他的各种类型 返回 JSValue switch (returnType[0] == 'r' ? returnType[1] : returnType[0]) &#123; #define JP_CALL_RET_CASE(_typeString, _type) \ case _typeString: &#123; \ _type tempResultSet; \ [invocation getReturnValue:&amp;tempResultSet];\ returnValue = @(tempResultSet); \ break; \ &#125; JP_CALL_RET_CASE('c', char) JP_CALL_RET_CASE('C', unsigned char) JP_CALL_RET_CASE('s', short) JP_CALL_RET_CASE('S', unsigned short) JP_CALL_RET_CASE('i', int) JP_CALL_RET_CASE('I', unsigned int) JP_CALL_RET_CASE('l', long) JP_CALL_RET_CASE('L', unsigned long) JP_CALL_RET_CASE('q', long long) JP_CALL_RET_CASE('Q', unsigned long long) JP_CALL_RET_CASE('f', float) JP_CALL_RET_CASE('d', double) JP_CALL_RET_CASE('B', BOOL) case '&#123;': &#123; NSString *typeString = extractStructName([NSString stringWithUTF8String:returnType]); #define JP_CALL_RET_STRUCT(_type, _methodName) \ if ([typeString rangeOfString:@#_type].location != NSNotFound) &#123; \ _type result; \ [invocation getReturnValue:&amp;result]; \ return [JSValue _methodName:result inContext:_context]; \ &#125; JP_CALL_RET_STRUCT(CGRect, valueWithRect) JP_CALL_RET_STRUCT(CGPoint, valueWithPoint) JP_CALL_RET_STRUCT(CGSize, valueWithSize) JP_CALL_RET_STRUCT(NSRange, valueWithRange) @synchronized (_context) &#123; NSDictionary *structDefine = _registeredStruct[typeString]; if (structDefine) &#123; size_t size = sizeOfStructTypes(structDefine[@"types"]); void *ret = malloc(size); [invocation getReturnValue:ret]; NSDictionary *dict = getDictOfStruct(ret, structDefine); free(ret); return dict; &#125; &#125; break; &#125; case '*': case '^': &#123; void *result; [invocation getReturnValue:&amp;result]; returnValue = formatOCToJS([JPBoxing boxPointer:result]); if (strncmp(returnType, "^&#123;CG", 4) == 0) &#123; if (!_pointersToRelease) &#123; _pointersToRelease = [[NSMutableArray alloc] init]; &#125; [_pointersToRelease addObject:[NSValue valueWithPointer:result]]; CFRetain(result); &#125; break; &#125; case '#': &#123; Class result; [invocation getReturnValue:&amp;result]; returnValue = formatOCToJS([JPBoxing boxClass:result]); break; &#125; &#125; return returnValue; &#125; &#125; return nil;&#125; OC 消息转发jspatch 想要 hook 任意的方法，就需要让所有被 hook 的方法走一个统一的入口。这个统一的入口通过让所有被替换的方法走消息转发，并且 hook 消息转发的 forwardInvocation() 方法实现，无论这个方法是 JS 调用的还是 OC 调用的。 主要过程如下： 获取被重写的方法的 JS 实现 如果没有重写的 JS 方法，那么执行原来的方法实现 准备提供给 JS 的参数 执行上下文，方法的实际调用者 self 方法的实际参数 针对调用父类方法的特殊处理 执行 JS 重写方法，并对将返回结果设回 NSInvocation 针对 dealloc 方法的特殊处理 获取被重写方法的 JS 实现JPForwardInvocation 是一个静态方法，它的前两个参数分别是 self 和 selector。主要通过 getJSFunctionInObjectHierachy() 方法获取 JS 替换方法的实现 123456789101112131415161718192021// 自己的替换方法, 可以看到调用方法前两个参数一个是 self，一个是 selecter， 对应于方法签名的 @:static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; BOOL deallocFlag = NO; id slf = assignSlf; BOOL isBlock = [[assignSlf class] isSubclassOfClass : NSClassFromString(@"NSBlock")]; NSMethodSignature *methodSignature = [invocation methodSignature]; NSInteger numberOfArguments = [methodSignature numberOfArguments]; NSString *selectorName = isBlock ? @"" : NSStringFromSelector(invocation.selector); NSString *JPSelectorName = [NSString stringWithFormat:@"_JP%@", selectorName]; // 判断 JSPSEL 是否有对应的 js 函数的实现，如果没有就原始方法的消息转发的流程 // （被 defineClass 过的类会被替换 forwardInvocation 方法。如果有方法没有被实现，且没有被 JS重写。那么就会走原始的 forwardInvocation 要找到的是 ORIGforwardInvocation 方法） JSValue *jsFunc = isBlock ? objc_getAssociatedObject(assignSlf, "_JSValue")[@"cb"] : getJSFunctionInObjectHierachy(slf, JPSelectorName); if (!jsFunc) &#123; JPExecuteORIGForwardInvocation(slf, selector, invocation); return; &#125; ...&#125; getJSFunctionInObjectHierachy() 方法查找当前类是否有 JS 实现，如果没有，就从父类中查找。如果父类中也都没有实现，那么就要走原本的消息转发逻辑了。 123456789101112131415161718192021// 判断这个方法是否有 js 方法的实现。 后续通过这个判断结果走原始转发流程还是走 js 方法的调用// 这是一个递归方法static JSValue *getJSFunctionInObjectHierachy(id slf, NSString *selectorName)&#123; Class cls = object_getClass(slf); // 如果是正在在 js 中调用 oc 一个类中的 super 的方法，那么就通过 _currInvokeSuperClsName 记录下来。因为在调用的过程中由于是 super 方法，selector 会有一个 SUPER_ 的前缀。消息转发到这里的时候需要知道当前调用的其实是一个 super 的方法，需要把 SUPER_ 去除。 if (_currInvokeSuperClsName[selectorName]) &#123; cls = NSClassFromString(_currInvokeSuperClsName[selectorName]); selectorName = [selectorName stringByReplacingOccurrencesOfString:@"_JPSUPER_" withString:@"_JP"]; &#125; JSValue *func = _JSOverideMethods[cls][selectorName]; // 遍历父类找这个方法 while (!func) &#123; cls = class_getSuperclass(cls); if (!cls) &#123; return nil; &#125; func = _JSOverideMethods[cls][selectorName]; &#125; return func;&#125; 原本的 forwardInvocation: 指向了 SEL ORIDforwardInvocation:。拿到它对应的函数指针，并且执行： 12345678910111213141516171819202122232425262728// 方法的原本的 forward 流程static void JPExecuteORIGForwardInvocation(id slf, SEL selector, NSInvocation *invocation)&#123; // 拿到原始的被替换的 forwardInvocation： ORIDforwardInvocation, 然后调用原始的转发方法 SEL origForwardSelector = @selector(ORIGforwardInvocation:); if ([slf respondsToSelector:origForwardSelector]) &#123; NSMethodSignature *methodSignature = [slf methodSignatureForSelector:origForwardSelector]; if (!methodSignature) &#123; _exceptionBlock([NSString stringWithFormat:@"unrecognized selector -ORIGforwardInvocation: for instance %@", slf]); return; &#125; // 调用原始的转换方法 NSInvocation *forwardInv= [NSInvocation invocationWithMethodSignature:methodSignature]; [forwardInv setTarget:slf]; [forwardInv setSelector:origForwardSelector]; [forwardInv setArgument:&amp;invocation atIndex:2]; [forwardInv invoke]; &#125; else &#123; // 如果不存在原始的转发方法，就调用父类的转发方法 // 这里应该是保底逻辑，一般来说，不会出现调用没有 forwardInvocation 方法的情况 Class superCls = [[slf class] superclass]; Method superForwardMethod = class_getInstanceMethod(superCls, @selector(forwardInvocation:)); void (*superForwardIMP)(id, SEL, NSInvocation *); superForwardIMP = (void (*)(id, SEL, NSInvocation *))method_getImplementation(superForwardMethod); superForwardIMP(slf, @selector(forwardInvocation:), invocation); &#125;&#125; 准备传给 JS 的参数先要把 self 取出来，放到参数数组中。类对象就用一个包含 __clsName 的对象表示，实例对象则用 JPBoxing 包裹。另外，对于 dealloc 方法要注意不能使用 weak 修饰。在 dealloc 期间，不能使用 weak： 1234567891011121314151617181920212223242526static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; ... // 从NSInvocation中获取调用的参数，把self与相应的参数都转换成js对象并封装到一个集合中// js端重写的函数，传递过来是JSValue类型，用callWithArgument:调用js方法，参数也要是js对象. NSMutableArray *argList = [[NSMutableArray alloc] init]; if (!isBlock) &#123; if ([slf class] == slf) &#123; // 如果调用的是类方法，那么给入参列表的第一个参数就是一个包含 __clsName 的 object [argList addObject:[JSValue valueWithObject:@&#123;@"__clsName": NSStringFromClass([slf class])&#125; inContext:_context]]; &#125; else if ([selectorName isEqualToString:@"dealloc"]) &#123; // 对于被释放的对象，使用 assign 来保存 self 的指针 // 因为在 dealloc 的时候，系统不让将 self 赋值给一个 weak 对象。（在 dealloc 的时候应该会有一些操作 weak 字典的步骤，所以不能再这个阶段再操作 weak） // assign 和 weak 的区别在于 assign 在指向的对象销毁的时候不会把当前指针置为 nil // 所以这里最终要自己确保不会在 dealloc 后调用 slf 的方法 [argList addObject:[JPBoxing boxAssignObj:slf]]; deallocFlag = YES; &#125; else &#123; // 否则用 weak 包裹 [argList addObject:[JPBoxing boxWeakObj:slf]]; &#125; &#125; ...&#125; 之后就是取出 NSInvocation 中的各个参数了。这个过程是 callSelector 中设置 NSInvocation 的逆过程。基本一致，所以不重复贴代码了。 调用父类方法的特殊处理12345678910111213141516171819202122static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; ... // 如果当前调用的方法是 js 引起的，并且 js 调用了一个 super 的方法。那么会在 _currInvokeSuperClsName 中保存一个调用的方法名。这个方法名被加上了前缀 SUPER_。 因此真正调用的时候要把这个前缀替换为 _JP。这样才能找到保存在 JSOverrideMethods 字典中的相应方法 if (_currInvokeSuperClsName[selectorName]) &#123; Class cls = NSClassFromString(_currInvokeSuperClsName[selectorName]); NSString *tmpSelectorName = [[selectorName stringByReplacingOccurrencesOfString:@"_JPSUPER_" withString:@"_JP"] stringByReplacingOccurrencesOfString:@"SUPER_" withString:@"_JP"]; // 如果父类没有重写相应的方法 if (!_JSOverideMethods[cls][tmpSelectorName]) &#123; NSString *ORIGSelectorName = [selectorName stringByReplacingOccurrencesOfString:@"SUPER_" withString:@"ORIG"]; [argList removeObjectAtIndex:0]; // 如果父类没有重写这个方法那么就是调用 oc 的方法，oc 直接调用父类的相应方法 id retObj = callSelector(_currInvokeSuperClsName[selectorName], ORIGSelectorName, [JSValue valueWithObject:argList inContext:_context], [JSValue valueWithObject:@&#123;@"__obj": slf, @"__realClsName": @""&#125; inContext:_context], NO); id __autoreleasing ret = formatJSToOC([JSValue valueWithObject:retObj inContext:_context]); [invocation setReturnValue:&amp;ret]; return; &#125; &#125; ...&#125; 执行 JS 方法，并将结果设置到 NSInvocation准备好参数后，只要调用 callWithArguments 就可以同步获取到执行结果。由于是消息转发，因此要将得到的结果还要通过 setReturnValue: 设置给 NSInvocation。 123456789101112131415161718192021static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; ... // 转化为 js 的参数形式，将对象包裹为 &#123;__obj: obj, __clsName: xxx&#125; 的形式 NSArray *params = _formatOCToJSList(argList); char returnType[255]; // 获取方法的返回参数的签名 strcpy(returnType, [methodSignature methodReturnType]); // 判断 returnType 的符号签名 switch (returnType[0] == 'r' ? returnType[1] : returnType[0]) &#123; // 先调用 js 重写的方法，得到 返回值 jsval // 如果 jsval 不是空，并且需要 isPerformInOC，那么获取其 callback 方法， // 执行完后拿到数据转为 js 后调用 callback 方法 // 如果 jsval 没有 isPerformInOC，那么就是执行完 js 方法后直接往下走 ... (省略了各种类型判断) &#125;&#125; 针对 dealloc 方法的特殊处理如果是一般的方法，用 JS 替换了原方法执行就完事了。但是 dealloc 方法则有点特殊，它的原始方法必须要执行，不然怎么完成资源回收。因此，在方法执行的最后会判断当前执行的是不是 dealloc 方法，如果是，那么默认调用它的实现： 123456789101112131415static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; ... // 如果这个方法是 dealloc 方法 if (deallocFlag) &#123; slf = nil; Class instClass = object_getClass(assignSlf); // 拿到 dealloc 方法实现 Method deallocMethod = class_getInstanceMethod(instClass, NSSelectorFromString(@"ORIGdealloc")); void (*originalDealloc)(__unsafe_unretained id, SEL) = (__typeof__(originalDealloc))method_getImplementation(deallocMethod); // 调用 originalDealloc(assignSlf, NSSelectorFromString(@"dealloc")); &#125;&#125; 至此，OC 端的消息转发过程结束。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch 源码解析(一)]]></title>
    <url>%2F2019%2F08%2F01%2Fjspatch%2F</url>
    <content type="text"><![CDATA[JSPatch 虽然被禁，但是它的源码是非常值得学习的。可以说，是我看过的各个库中设计的最巧妙也是知识点最多的开源库。非常有学习价值。 这是这个源码解析的第一部分。主要通过一个 Demo 演示如何定义 JS 修复文件。 Demo 演示JSPatch 的主要功能涵盖于三个文件中：JPEngine.h，JPEngine.m，JSPatch.js。由于语法规则比较多，这里就不进行用法的介绍了。下面跟着 JSPatch 附带的 demo 了解 JSPatch 的修复过程。 修复的 js 文件通过 js 进行热修复，demo 中定义了要修复的类为 JPTableViewController，它是一个 UITableViewController。在这个 修复类中，增加了 data 这个 property，并且提供了完整的 UITableView 显示所需要的方法： 123456789101112131415161718192021222324252627282930313233343536defineClass('JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;', ['data'], &#123; dataSource: function() &#123; var data = self.data(); if (data) return data; var data = []; for (var i = 0; i &lt; 20; i ++) &#123; data.push("cell from js " + i); &#125; self.setData(data) return data; &#125;, numberOfSectionsInTableView: function(tableView) &#123; return 1; &#125;, tableView_numberOfRowsInSection: function(tableView, section) &#123; return self.dataSource().length; &#125;, tableView_cellForRowAtIndexPath: function(tableView, indexPath) &#123; var cell = tableView.dequeueReusableCellWithIdentifier("cell") if (!cell) &#123; cell = require('UITableViewCell').alloc().initWithStyle_reuseIdentifier(0, "cell") &#125; cell.textLabel().setText(self.dataSource()[indexPath.row()]) return cell &#125;, tableView_heightForRowAtIndexPath: function(tableView, indexPath) &#123; return 60 &#125;, tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123; var alertView = require('UIAlertView').alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles("Alert",self.dataSource()[indexPath.row()], self, "OK", null); alertView.show() &#125;, alertView_willDismissWithButtonIndex: function(alertView, idx) &#123; console.log('click btn ' + alertView.buttonTitleAtIndex(idx).toJS()) &#125;&#125;) 加载修复的 js 文件加载修复的 js 文件是在应用启动完毕的回调中完成的： 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // JSPatch 初始化 [JPEngine startEngine]; NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; // 执行修复脚本 [JPEngine evaluateScript:script]; ...&#125; 先调用 startEngine 初始化 JSPatch，这一步的作用主要是创建一个 JSContext，并在其中注入提供给 JS 调用的方法。随后加载提供修复的 js 文件。通过刚才创建的 JSContext 执行。 当执行到 JPTableViewController 的时候，修复方法替换了原本的各种 UITableView 回调执行。 执行流程初始化 JSContext初始化 JSPatch 通过 startEngine 方法完成，这个方法为 JSContext 注入了多种方法，并且初始化了 OC 端的各个属性。方法非常长，因此做了非常详尽的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171// SECTION 开始JSPatch+ (void)startEngine&#123; // 创建 JSContext 实例 JSContext *context = [[JSContext alloc] init]; #ifdef DEBUG // 将 lldb 中 po 打印出来的字符串传递给 js context[@"po"] = ^JSValue*(JSValue *obj) &#123; id ocObject = formatJSToOC(obj); return [JSValue valueWithObject:[ocObject description] inContext:_context]; &#125;; // js 中打印调用堆栈，类似于 lldb 中的 bt context[@"bt"] = ^JSValue*() &#123; return [JSValue valueWithObject:_JSLastCallStack inContext:_context]; &#125;;#endif // 在 OC 中定义 Class， 输入类名，实例方法数组 和 类方法数组 context[@"_OC_defineClass"] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) &#123; return defineClass(classDeclaration, instanceMethods, classMethods); &#125;; // 在 OC 中定义协议，输入协议名 context[@"_OC_defineProtocol"] = ^(NSString *protocolDeclaration, JSValue *instProtocol, JSValue *clsProtocol) &#123; return defineProtocol(protocolDeclaration, instProtocol,clsProtocol); &#125;; // 调用 oc 的实例方法 context[@"_OC_callI"] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) &#123; return callSelector(nil, selectorName, arguments, obj, isSuper); &#125;; // 调用 oc 的类方法 context[@"_OC_callC"] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) &#123; return callSelector(className, selectorName, arguments, nil, NO); &#125;; // 将 JS 对象转为 OC 对象 context[@"_OC_formatJSToOC"] = ^id(JSValue *obj) &#123; return formatJSToOC(obj); &#125;; // 将 OC 对象转为 JS对象 context[@"_OC_formatOCToJS"] = ^id(JSValue *obj) &#123; return formatOCToJS([obj toObject]); &#125;; // 获取 js 定义 class 的时候添加的自定义的 props context[@"_OC_getCustomProps"] = ^id(JSValue *obj) &#123; id realObj = formatJSToOC(obj); return objc_getAssociatedObject(realObj, kPropAssociatedObjectKey); &#125;; // 设置 js 定义 class 时候自定义的 props context[@"_OC_setCustomProps"] = ^(JSValue *obj, JSValue *val) &#123; id realObj = formatJSToOC(obj); objc_setAssociatedObject(realObj, kPropAssociatedObjectKey, val, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125;; // js 对象弱引用, 主要用于 js 对象会传递给 OC 的情况 context[@"__weak"] = ^id(JSValue *jsval) &#123; id obj = formatJSToOC(jsval); return [[JSContext currentContext][@"_formatOCToJS"] callWithArguments:@[formatOCToJS([JPBoxing boxWeakObj:obj])]]; &#125;; // js 对象强引用，将 js 弱引用r对象转为强引用 context[@"__strong"] = ^id(JSValue *jsval) &#123; id obj = formatJSToOC(jsval); return [[JSContext currentContext][@"_formatOCToJS"] callWithArguments:@[formatOCToJS(obj)]]; &#125;; // 获取传入类的父类名 context[@"_OC_superClsName"] = ^(NSString *clsName) &#123; Class cls = NSClassFromString(clsName); return NSStringFromClass([cls superclass]); &#125;; // 设置标识位，在 formatOCToJS 的时候是否自动将 NSString NSArray 等对象自动转为 js 中的 string，array 等。 // 如果设置为 false，则会当成一个对象，使用 JPBoxing 包裹 context[@"autoConvertOCType"] = ^(BOOL autoConvert) &#123; _autoConvert = autoConvert; &#125;; // 设置标识位，在 formatOCToJS 的时候是否直接将 OC 的 NSNumber 类型转为 js 的 string 类型 context[@"convertOCNumberToString"] = ^(BOOL convertOCNumberToString) &#123; _convertOCNumberToString = convertOCNumberToString; &#125;; // 在 js 中调用 include 方法，可以在一个 js 文件中加载其他 js 文件 context[@"include"] = ^(NSString *filePath) &#123; NSString *absolutePath = [_scriptRootDir stringByAppendingPathComponent:filePath]; if (!_runnedScript) &#123; _runnedScript = [[NSMutableSet alloc] init]; &#125; if (absolutePath &amp;&amp; ![_runnedScript containsObject:absolutePath]) &#123; [JPEngine _evaluateScriptWithPath:absolutePath]; [_runnedScript addObject:absolutePath]; &#125; &#125;; // 提供一个文件名返回完整的文件路径 context[@"resourcePath"] = ^(NSString *filePath) &#123; return [_scriptRootDir stringByAppendingPathComponent:filePath]; &#125;; // 延时在主线程中执行。 context[@"dispatch_after"] = ^(double time, JSValue *func) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [func callWithArguments:nil]; &#125;); &#125;; // 在主线程中异步执行 context[@"dispatch_async_main"] = ^(JSValue *func) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [func callWithArguments:nil]; &#125;); &#125;; // 在主线程中同步执行 context[@"dispatch_sync_main"] = ^(JSValue *func) &#123; // 先判断是不是主线程，是就直接执行，不是就用 dispatch_sync if ([NSThread currentThread].isMainThread) &#123; [func callWithArguments:nil]; &#125; else &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [func callWithArguments:nil]; &#125;); &#125; &#125;; // 异步执行 context[@"dispatch_async_global_queue"] = ^(JSValue *func) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [func callWithArguments:nil]; &#125;); &#125;; // 释放二级指针指向的对象 context[@"releaseTmpObj"] = ^void(JSValue *jsVal) &#123; if ([[jsVal toObject] isKindOfClass:[NSDictionary class]]) &#123; void *pointer = [(JPBoxing *)([jsVal toObject][@"__obj"]) unboxPointer]; id obj = *((__unsafe_unretained id *)pointer); @synchronized(_TMPMemoryPool) &#123; [_TMPMemoryPool removeObjectForKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]]; &#125; &#125; &#125;; // js 调用 oc 方法，打印 js 对象到 oc 控制台 context[@"_OC_log"] = ^() &#123; NSArray *args = [JSContext currentArguments]; for (JSValue *jsVal in args) &#123; id obj = formatJSToOC(jsVal); NSLog(@"JSPatch.log: %@", obj == _nilObj ? nil : (obj == _nullObj ? [NSNull null]: obj)); &#125; &#125;; // js 捕捉到的 exception 打印在 oc 中 context[@"_OC_catch"] = ^(JSValue *msg, JSValue *stack) &#123; _exceptionBlock([NSString stringWithFormat:@"js exception, \nmsg: %@, \nstack: \n %@", [msg toObject], [stack toObject]]); &#125;; context.exceptionHandler = ^(JSContext *con, JSValue *exception) &#123; NSLog(@"%@", exception); _exceptionBlock([NSString stringWithFormat:@"js exception: %@", exception]); &#125;; // js 中的 nsnull 就是 oc 中的一个普通对象 _nullObj = [[NSObject alloc] init]; context[@"_OC_null"] = formatOCToJS(_nullObj); _context = context; // 各种初始化 _nilObj = [[NSObject alloc] init]; _JSMethodSignatureLock = [[NSLock alloc] init]; _JSMethodForwardCallLock = [[NSRecursiveLock alloc] init]; _registeredStruct = [[NSMutableDictionary alloc] init]; _currInvokeSuperClsName = [[NSMutableDictionary alloc] init]; // 找到 JSPatch.js 的路径 NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"JSPatch" ofType:@"js"]; if (!path) _exceptionBlock(@"can't find JSPatch.js"); // 加载路径上的文件 NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding]; // 执行 JSPatch.js if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) &#123; [_context evaluateScript:jsCore withSourceURL:[NSURL URLWithString:@"JSPatch.js"]]; &#125; else &#123; [_context evaluateScript:jsCore]; &#125;&#125; 注入 JSContext 的方法会在之后用到的时候详细解释。在注入方法完成后，执行了 JSPatch js 端的初始化代码。 初始化 js 部分JSPatch 的 js 端初始化部分主要做了两件事： 为 js 中的 Object 对象增加方法 为 JSContext 的全局对象增加各种属性与方法 123456789101112131415161718// Object 增加的几个方法：function __c (methodName) &#123;...&#125;function super () &#123;...&#125;function performSelectorInOC () &#123;...&#125;function performSelector () &#123;...&#125;// JSContext 全局对象增加的方法：function _formatOCToJS (obj) &#123;...&#125;function require () &#123;...&#125;function defineClass (declaration, properties, instMethods, clsMethods) &#123;...&#125;function defineProtocol (declaration, instProtos, clsProtos) &#123;...&#125;function block (args, cb) &#123;...&#125;function defineJSClass (declaration, instMethods, clsMethods) &#123;...&#125;// JSContext 全局对象增加的属性global.YES = 1global.NO = 0global.nsnull = _OC_null (JSContext 传入，上面有提及) 改写修复文件现在开始执行修复文件，拿到 js 代码后调用了[JPEngine evaluteScript:script]; 方法。这个方法兜兜转转来到了 JPEngine 的 _evaluteScript:withSourceURL: 方法中。方法实现很简单，但是却是实现修复的第一个重点： 123456789101112131415161718192021// 修改 js 修复文件方法的调用方式+ (JSValue *)_evaluateScript:(NSString *)script withSourceURL:(NSURL *)resourceURL&#123; if (!_regex) &#123; _regex = [NSRegularExpression regularExpressionWithPattern:_regexStr options:0 error:nil]; &#125; // 使用正则表达式替换方法调用方式，将 alloc() 这样的函数调用，替换为 __c("alloc")() 形式 NSString *formatedScript = [NSString stringWithFormat:@";(function()&#123;try&#123;\n%@\n&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();", [_regex stringByReplacingMatchesInString:script options:0 range:NSMakeRange(0, script.length) withTemplate:_replaceStr]]; // 执行处理后的修复方法 @try &#123; if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) &#123; return [_context evaluateScript:formatedScript withSourceURL:resourceURL]; &#125; else &#123; return [_context evaluateScript:formatedScript]; &#125; &#125; @catch (NSException *exception) &#123; _exceptionBlock([NSString stringWithFormat:@"%@", exception]); &#125; return nil;&#125; 在 js 中执行形如 UIView.alloc().init() 这样的调用方式需要预先将要执行的方法定义在对象中，否则一定会报错：UIView.alloc is not a function。但是预先定义的方式工作量巨大且初始化的效率很低，不适用于涉及到大量类的修复。 换一种思路，由于 OC 动态性的便利，使得我们只需要从 js 端传递要执行的对象，方法名和参数，就可以通过动态调用的方式执行相应方法。而传递这三个要素，只要一个通用方法就可以实现。 JSPatch 作者考虑到开发者的习惯，仍然保留了 UIView.alloc().init() 这样的链式写法。但是在初始化的时候对实现内容作了正则替换，将匹配到的方法名取出，改为调用一个通用方法 __c()，并将方法名作为参数传入。因此，做了正则替换后的实现变为：UIView.__c(&#39;alloc&#39;)().__c(&#39;init&#39;)()。 定义要重写的类方法与实例方法js 端定义类要修复bug那么肯定要定位到要修复的类的某个方法。js 全局对象下的方法 defineClass 提供了这个入口。方法比较长，总共做了几件事，如下所示： 设置关联属性 hook 定义的方法，并将修改后的方法传给 oc 将该类的方法实现保存到 __ocCls 中 创建全局类对象 接下来我们一个一个看。 设置关联属性1234567891011121314151617181920global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123; ... // 如果存在 properties，在实例方法列表中增加各种 get set 方法 if (properties) &#123; properties.forEach(function(name)&#123; // 设置属性的 get 方法 if (!instMethods[name]) &#123; // 将 get 方法设置到实例方法中 instMethods[name] = _propertiesGetFun(name); &#125; // 设置属性的 set 方法 var nameOfSet = "set"+ name.substr(0,1).toUpperCase() + name.substr(1); if (!instMethods[nameOfSet]) &#123; // 将 set 方法设置到实例方法中 instMethods[nameOfSet] = _propertiesSetFun(name); &#125; &#125;); &#125; ...&#125; oc 的属性都需要提供其 get set 方法。因此，这一段代码主要就是查看实例方法中有没有相应的 get set 方法，没有的话就添加。关联属性的 get set 方法通过 _propertiesGetFun 和 _propertiesSetFun 完成： 123456789101112131415161718192021222324252627282930313233// 返回属性的 get 方法var _propertiesGetFun = function(name)&#123; return function()&#123; var slf = this; if (!slf.__ocProps) &#123; // 获取 oc 的关联属性 var props = _OC_getCustomProps(slf.__obj) if (!props) &#123; props = &#123;&#125; _OC_setCustomProps(slf.__obj, props) &#125; // 将 oc 的关联属性赋给 js 端对象的 __ocProps slf.__ocProps = props; &#125; return slf.__ocProps[name]; &#125;;&#125;// 返回属性的 set 方法var _propertiesSetFun = function(name)&#123; return function(jval)&#123; var slf = this; if (!slf.__ocProps) &#123; var props = _OC_getCustomProps(slf.__obj) if (!props) &#123; props = &#123;&#125; _OC_setCustomProps(slf.__obj, props) &#125; slf.__ocProps = props; &#125; slf.__ocProps[name] = jval; &#125;;&#125; oc 端设置关联对象的方法如下： 12345678context[@"_OC_getCustomProps"] = ^id(JSValue *obj) &#123; id realObj = formatJSToOC(obj); return objc_getAssociatedObject(realObj, kPropAssociatedObjectKey);&#125;;context[@"_OC_setCustomProps"] = ^(JSValue *obj, JSValue *val) &#123; id realObj = formatJSToOC(obj); objc_setAssociatedObject(realObj, kPropAssociatedObjectKey, val, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;; 可以看到，无论 js 端设置了多少 property，在 oc 端，都作为一个属性保存在 key 为 kPropAssociatedObjectKey 的关联属性中。oc 端拿到了这个关联属性后返回给 js 端，js 端的对象则以 _ocProps 属性接收。两者指向的地址相同，因此，之后对于 property 的改变只需直接修改 js 端对象的 _ocProps 属性就行。 hook 方法并传给 ococ 中实现 aop 非常麻烦，而 js 端直接操作函数指针就可以完成。 1234567891011121314global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123; ... // realClsName 是 js 中直接截取的类名 var realClsName = declaration.split(':')[0].trim() // 预处理要定义的方法，对方法进行切片，处理参数 _formatDefineMethods(instMethods, newInstMethods, realClsName) _formatDefineMethods(clsMethods, newClsMethods, realClsName) // 在 OC 中定义这个类，返回的值类型为 &#123;cls: xxx, superCls: xxx&#125; var ret = _OC_defineClass(declaration, newInstMethods, newClsMethods) // className 是从 OC 中截取的 cls 的名字。本质上和 realClsName 是一致的 var className = ret['cls'] var superCls = ret['superCls'] ...&#125; 主要过程在 _formatDefineMethods 中： 12345678910111213141516171819202122232425262728293031// 对 js 端定义的 method 进行预处理，取出方法的参数个数。hook 方法，预处理方法的参数，将其转为 js 对象。var _formatDefineMethods = function(methods, newMethods, realClsName) &#123; for (var methodName in methods) &#123; if (!(methods[methodName] instanceof Function)) return; (function()&#123; var originMethod = methods[methodName] // 把原来的 method 拿出来，新的 method 变成了一个数组，第一个参数是原来方法的调用参数的个数，第二个参数是 // 因为runtime 添加方法的时候需要设置函数签名，因此需要知道方法中参数个数。这里直接在 js 中将参数个数取出 newMethods[methodName] = [originMethod.length, function() &#123; try &#123; // js 端执行的方法，需要先把参数转为 js 的类型 var args = _formatOCToJS(Array.prototype.slice.call(arguments)) // 暂存之前的 self 对象 var lastSelf = global.self // oc 调用 js 方法的时候，默认第一个参数是 self global.self = args[0] if (global.self) global.self.__realClsName = realClsName // oc 调用 js 方法的时候，第一个参数是 self，因此要把它去掉。 args.splice(0,1) // 调用 js 方法 var ret = originMethod.apply(originMethod, args) // 恢复 原始的 self 指向 global.self = lastSelf return ret &#125; catch(e) &#123; _OC_catch(e.message, e.stack) &#125; &#125;] &#125;)() &#125;&#125; 这里存在三个要点： 这个方法是要添加到 oc 端的，oc 端需要知道参数个数，但是 oc 端无法直接获取，只能通过解析方法名。因此就把解析参数个数的工程放在了 js 中进行。js 端在将方法传给 oc 前，先把参数个数拿到，然后以数组形式传递。 oc 调用 js 方法时传递的参数需要预处理，比如调用对象原本是 js 传递过去的，就会被 {__obj: xxx} 包裹，再比如 oc 的空对象的处理。 oc 传来的参数第一个是方法的调用上下文。因此需要把调用上下文设置给全局的 self，以便在方法中使用。在调用方法前，还需要把这个上下文和 Selector 从参数列表中取出，因为 js 调用的时候是不需要这个参数的。 js 方法预处理完成后，就会调用 _OC_defineClass 方法，在 OC 中添加相应方法。这个方法是 JSPatch 中最重要的方法了，在后面会解释，先跳过。 将该类的方法实现保存到 __ocCls 中对于定义好的方法，js 端需要把这些方法保存起来。毕竟真正的实现还是在 js 端进行的。因此定义了一个所有类的方法的暂存地：__ocCls。所有的类的所有方法都会被保存在这个对象中。 123456789101112131415161718192021global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123; ... // 初始化该类的类方法和实例方法到 _ocCls 中 _ocCls[className] = &#123; instMethods: &#123;&#125;, clsMethods: &#123;&#125;, &#125; // 如果父类被 defineClass 过，那么要把父类的方法扔到子类中去。子类调用父类中实现的方法的时候，直接调用 if (superCls.length &amp;&amp; _ocCls[superCls]) &#123; for (var funcName in _ocCls[superCls]['instMethods']) &#123; _ocCls[className]['instMethods'][funcName] = _ocCls[superCls]['instMethods'][funcName] &#125; for (var funcName in _ocCls[superCls]['clsMethods']) &#123; _ocCls[className]['clsMethods'][funcName] = _ocCls[superCls]['clsMethods'][funcName] &#125; &#125; // 把方法存到 _ocCls 对应的类中。和 _formatDefineMethods 的差别在于这个方法不需要把参数个数提取出来 _setupJSMethod(className, instMethods, 1, realClsName) _setupJSMethod(className, clsMethods, 0, realClsName) ...&#125; 如果父类实现了某些方法，那么子类中需要先把这些方法保存起来。这样如果调用了子类没有实现的这些方法的时候就可以直接调用父类相应的实现。 这个想法是对的，但是我认为有点问题在于，这样的话就需要先对父类 defineClass 才能定义子类，否则子类就没法拿到父类实现的方法了。因此，定义类的时候一定要注意，先定义父类的 class，再定义子类的。 _setupJSMethod 其实也是一个很简单的方法，其实就是把上下文名从 this 切换为 self： 1234567891011121314151617181920// 替换 this 为 selfvar _wrapLocalMethod = function(methodName, func, realClsName) &#123; return function() &#123; var lastSelf = global.self global.self = this this.__realClsName = realClsName var ret = func.apply(this, arguments) global.self = lastSelf return ret &#125;&#125;// 保存方法到 _ocCls 中var _setupJSMethod = function(className, methods, isInst, realClsName) &#123; for (var name in methods) &#123; var key = isInst ? 'instMethods': 'clsMethods', func = methods[name] _ocCls[className][key][name] = _wrapLocalMethod(name, func, realClsName) &#125;&#125; OC 中会保存一份方法实现在 _JPOverideMethods 字典中。还会在 js 端保存在 __ocCls 中。保存两份的目的是在 JS 端执行定义的方法并且调用到其他定义方法的时候，可以不用重走一遍 OC 的消息转发，而是直接调用 js 端方法。 这样的好处有两点： 是不用走消息转发，加快执行速度。 区分了调用场景后更容易设置调用上下文。对于 OC，调用的上下文是通过参数传递的，拿第一个参数将其赋给 global.self。对于 js，调用的上下文时 this，把发赋给 global.self 通过 require 方法创建全局类对象defineClass 的最终返回了一个 require() 方法产生的对象： 1234global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123; ... return require(className)&#125; 在 require(xxx) 某一个类后，会在 js 的全局对象上增加该类的对象，比如： 123456789// js 中 require 一个 UIViewControllerrequire('UIViewController')// 会在全局下创建一个 UIViewController 对象global: &#123; UIViewController: &#123; __clsName: 'UIViewController' &#125;&#125; 具体的实现如下： 12345678910111213141516171819var _require = function(clsName) &#123; if (!global[clsName]) &#123; global[clsName] = &#123; __clsName: clsName &#125; &#125; return global[clsName]&#125;// 全局创建对象的方法，直接为 require 的类创建一个它的对象global.require = function() &#123; var lastRequire for (var i = 0; i &lt; arguments.length; i ++) &#123; arguments[i].split(',').forEach(function(clsName) &#123; lastRequire = _require(clsName.trim()) &#125;) &#125; return lastRequire&#125; 至此，js 段定义类结束 OC 端定义类前面 js 预处理过后就会来到 OC 的 defineClass 方法中。这个方法也比较长， 将类名、父类名、协议名取出 创建类以及给类添加协议 添加和重写方法 取出类名协议名1234567891011121314151617181920212223242526272829static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)&#123; // 扫描字符串做匹配 NSScanner *scanner = [NSScanner scannerWithString:classDeclaration]; NSString *className; NSString *superClassName; NSString *protocolNames; // 扫描到 : 了，把之前的放到 className 中 [scanner scanUpToString:@":" intoString:&amp;className]; // 如果没有扫描到底，那么就说明有父类或者协议 if (!scanner.isAtEnd) &#123; scanner.scanLocation = scanner.scanLocation + 1; // 扫描出来父类 [scanner scanUpToString:@"&lt;" intoString:&amp;superClassName]; if (!scanner.isAtEnd) &#123; scanner.scanLocation = scanner.scanLocation + 1; // 扫描协议名 [scanner scanUpToString:@"&gt;" intoString:&amp;protocolNames]; &#125; &#125; // 如果不存在父类，那么父类就是 NSObject if (!superClassName) superClassName = @"NSObject"; // 修改一下类名和父类名，把前后的空白字符去掉 className = trim(className); superClassName = trim(superClassName); // 把 protocol 切开拆分成数组 NSArray *protocols = [protocolNames length] ? [protocolNames componentsSeparatedByString:@","] : nil; ...&#125; 其实就是解析传进来的 NSString *classDeclaration 字符串。其实这个直接在 js 解析就可以了。这种 js 解析一遍，OC 又解析一遍的做法有点累赘。 创建类以及给类添加协议解析好类名和协议名之后就是创建了： 12345678910111213141516171819202122232425262728static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)&#123; ... // 反射为类名 Class cls = NSClassFromString(className); if (!cls) &#123; // 如果子类没有实例化成功，那么实例化父类 Class superCls = NSClassFromString(superClassName); // 如果父类也没有实例化成功 if (!superCls) &#123; // 直接报错 _exceptionBlock([NSString stringWithFormat:@"can't find the super class %@", superClassName]); return @&#123;@"cls": className&#125;; &#125; // 存在父类，不存在子类，那么创建一个子类时 cls = objc_allocateClassPair(superCls, className.UTF8String, 0); objc_registerClassPair(cls); &#125; // 如果有协议，那么拿到所有的协议名，给类增加协议 if (protocols.count &gt; 0) &#123; for (NSString* protocolName in protocols) &#123; Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]); class_addProtocol (cls, protocol); &#125; &#125; ...&#125; 添加和重写方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)&#123; ... // 增加方法 for (int i = 0; i &lt; 2; i ++) &#123; BOOL isInstance = i == 0; JSValue *jsMethods = isInstance ? instanceMethods: classMethods; // 如果是类方法那么要取出 cls 的 metaClass，否则直接拿出 cls Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String); // 把 JSValue 转化成 字典 NSDictionary *methodDict = [jsMethods toDictionary]; for (NSString *jsMethodName in methodDict.allKeys) &#123; // 通过 methodName 拿到 method 实例 // method 实例是一个数组，第一个元素表示 method 有几个入参，第二个c元素表示方法实例 JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName]; int numberOfArg = [jsMethodArr[0] toInt32]; // 把方法中的 _ 都转为 : NSString *selectorName = convertJPSelectorString(jsMethodName); // 如果尾部没有：，那么添加： if ([selectorName componentsSeparatedByString:@":"].count - 1 &lt; numberOfArg) &#123; selectorName = [selectorName stringByAppendingString:@":"]; &#125; JSValue *jsMethod = jsMethodArr[1]; if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) &#123; // TODO: 如果当前类实现了 selectorName 的方法，那么用现在的方法代替原来的方法 overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL); &#125; else &#123; // 如果当前类没有实现 selectorName 方法，那么添加这个方法 BOOL overrided = NO; for (NSString *protocolName in protocols) &#123; char *types = methodTypesInProtocol(protocolName, selectorName, isInstance, YES); if (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, NO); if (types) &#123; overrideMethod(currCls, selectorName, jsMethod, !isInstance, types); free(types); overrided = YES; break; &#125; &#125; if (!overrided) &#123; if (![[jsMethodName substringToIndex:1] isEqualToString:@"_"]) &#123; NSMutableString *typeDescStr = [@"@@:" mutableCopy]; for (int i = 0; i &lt; numberOfArg; i ++) &#123; [typeDescStr appendString:@"@"]; &#125; overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:NSUTF8StringEncoding]); &#125; &#125; &#125; &#125; &#125; ...&#125; 首先是对方法进行预处理，js 端定义的方法都是以下划线为分割的，形如：tableView_didSelectRowAtIndexPath，在 OC 中要转的 tableView:didSelectRowAtIndexPath: 的形式。这个过程在 convertJSSelectorString() 方法中完成： 123456789101112// 获取真正的方法名// 总的来说就是方法中可能存在两种情况，一种是 __ 一种是 _// _ 本地转为了 :，__ 被转为了 _static NSString *convertJPSelectorString(NSString *selectorString)&#123; // 用 - 代替 __ NSString *tmpJSMethodName = [selectorString stringByReplacingOccurrencesOfString:@"__" withString:@"-"]; // 用 ： 代替 _ NSString *selectorName = [tmpJSMethodName stringByReplacingOccurrencesOfString:@"_" withString:@":"]; // 用 _ 代替 - return [selectorName stringByReplacingOccurrencesOfString:@"-" withString:@"_"];&#125; 接下来就要给类添加方法了，规则是： 对于已经存在的方法：直接获取方法签名，然后传入 overrideMethod，修改原来的方法实现的函数指针。 对于不存在的的方法： 是某个协议中的方法：获取协议中该方法的函数签名，并传入 overrideMethod 实现方法。 不是某个协议的方法：即 js 新增的方法，自定义方法签名为 @@:{参数个数个 @} 的形式，表示所有入参和返回值都是 id 类型。传入 overrideMethod，实现方法。 由此可见，最重要的方法是 overrideMethod。 重写方法 overrideMethodoverrideMethod 实现了 js 方法对 oc 方法的实现和替换。它主要做了三件事： 替换目标类的消息转发方法 forwardInvocation: 为自定义方法 JPForwardInvocation: 各个类的方法命名为 _JP${方法名} 保存到 _JSOverideMethods 字典中的对应类中 替换原方法实现为 msgForward， 保存原方法实现为 ORIG${原方法名} 通过替换方法实现为 mgsForward 实现消息转发，通过替换 forwardInvocation: 实现在消息转发时调用自己的方法，完成 hook。 OC 端定义的字典 _JSOverideMethods保存函数指针。消息转发的时候可以找到 js 端方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 将方法替换为 msgForwardIMPstatic void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)&#123; // 通过字符串获取SEL SEL selector = NSSelectorFromString(selectorName); // 没有类型签名的时候获取原来的方法的类型签名 if (!typeDescription) &#123; Method method = class_getInstanceMethod(cls, selector); typeDescription = (char *)method_getTypeEncoding(method); &#125; // 获取原来方法的 IMP IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : NULL; // 获取消息转发处理的系统函数实现 IMP IMP msgForwardIMP = _objc_msgForward; // 将cls中原来 forwardInvocaiton: 的实现替换成 JPForwardInvocation:函数实现. if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) != (IMP)JPForwardInvocation) &#123; IMP originalForwardImp = class_replaceMethod(cls, @selector(forwardInvocation:), (IMP)JPForwardInvocation, "v@:@"); // 为cls添加新的SEL(ORIGforwardInvocation:)，指向原始 forwardInvocation: 的实现IMP. if (originalForwardImp) &#123; class_addMethod(cls, @selector(ORIGforwardInvocation:), originalForwardImp, "v@:@"); &#125; &#125; // 添加一个新的方法 ORIG$&#123;原方法名&#125; if (class_respondsToSelector(cls, selector)) &#123; NSString *originalSelectorName = [NSString stringWithFormat:@"ORIG%@", selectorName]; SEL originalSelector = NSSelectorFromString(originalSelectorName); if(!class_respondsToSelector(cls, originalSelector)) &#123; class_addMethod(cls, originalSelector, originalImp, typeDescription); &#125; &#125; NSString *JPSelectorName = [NSString stringWithFormat:@"_JP%@", selectorName]; // 初始化 _JSOverideMethods 字典 _initJPOverideMethods(cls); // 记录新SEL对应js传过来的待替换目标方法的实现. _JSOverideMethods[cls][JPSelectorName] = function; // 把原来的方法替换为 msgForward 的实现，实现方法转发 class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);&#125; (太长了，编辑器太卡了，转至下一篇。。。)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 typescript 实践]]></title>
    <url>%2F2019%2F07%2F12%2Ftswithmp%2F</url>
    <content type="text"><![CDATA[新的小程序打算用 ts 写，暂时踩了一些坑 实践编译ts的时候小程序控制台报错刚开始实践的时候，小程序控制台一直报错，但是也没有具体的显示： 遇到这个错误非常头疼，虽然显示没有问题，但是每次编译都会报这个错让人很难受。之后进过一阵摸索后，发现对于 ts 的小程序项目，在点击编译后会执行 npm run tsc 进行将 ts 到 js 的转换： 因此，我尝试手动在控制台中执行 npm run tsc，终于得到了错误的定位信息: 小程序hot reloadjs 的小程序项目中 js 的变更会引起小程序的热重载，但是在 ts 的项目中就必须手动点击编译。这样的操作非常不友好。因此，我想自己实现 hot reload。 hot reload 的 node 库可以使用：chokidar 1npm install --save-dev chokidar 然后在根目录创建 hotreload.js 文件，方案是监听到文件变更后触发 npm run tsc： 123456const chokidar = require('chokidar')const shell = require('shelljs')chokidar.watch('./miniprogram', &#123; cwd: '.' &#125;).on('change', (event, path) =&gt; &#123; shell.exec('npm run tsc') console.log('刷新')&#125;) 上面就是 watch 的 miniprogram 目录下的所有文件的变更。但是这样还有问题。当 ts 变更后触发 npm run tsc，而 npm run tsc 更新 js 后又会重新触发 npm run tsc，变成了死循环。因此，要排除 js 文件的跟新： 123456const chokidar = require('chokidar')const shell = require('shelljs')chokidar.watch('./miniprogram', &#123; cwd: '.', ignored: /.js$/ &#125;).on('change', (event, path) =&gt; &#123; shell.exec('npm run tsc') console.log('刷新')&#125;)]]></content>
      <categories>
        <category>MiniProgram</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fishhook 源码解析]]></title>
    <url>%2F2019%2F07%2F07%2Ffishhook%2F</url>
    <content type="text"><![CDATA[提起 iOS 中的 hook 手段，我们最先想到的是 Method Swizzling，这是 hook OC 方法最重要的手段。fishhook 则提供了 hook 系统 c 函数的手段。 动态链接为什么要有动态链接为了减少应用的体积，加速应用的启动速度。苹果系统会将很多系统库设计为动态库。动态库的实际地址在应用编译的时候是未知的。一些符号会在应用启动的时候链接。但是如果这样的符号过多就会拖慢应用的启动速度。因此另一些非必要符号会在第一次使用的时候绑定，也就是 Lazy Binding。 从例子看 lazy Binding我们来通过一个系统方法 NSLog 来验证动态库符号的绑定过程。我们在 main.m 中输入两个打印语句，然后加上断点： 我们来看一下它的汇编执行过程，需要先设置：debug -&gt; debug workflow -&gt; always show disassembly。断点情况下的汇编代码如下： 我们看到第14行，bl 0x10470ebf0； symbol stub for: NSLog 就是执行打印的方法。这个方法对应于可执行文件的哪个段呢？我们通过 MachOView 查看它的可执行文件： 在 __Text,__stubs 中有一个对应于 NSLog 的方法。它的 offset 是 00006BF0。但是我们实际的地址是 0x10 470ebf0，这两个地址显然是不匹配的。这是因为 MachOView 中的 offset 是相对于 __Text 段开始的 offset.(Header 和 Load Commands 也是属于 __Text 段的 )。如果要换算到实际地址，就需要加上 __Text 段的实际地址。以下是地址的换算关系： 虚拟地址 + ASLR = 实际地址 __Text 的虚拟地址 + ASLR = __Text 的实际地址 __Text 的虚拟地址 + 对象的 offset = 对象的虚拟地址 __Text 的实际地址 + 对象的 offset = 对象的实际地址 我们可以通过 lldb 中执行 image list 查看 __Text 段的实际地址： 如上图所示，image list 能列举出当前应用加载的所有动态库。其中第一个就是当前应用的地址，也就是 0x0000000104708000。即 0x00006BF0 + 0x104708000 = 0x10470ebf0 由于 __Text 虚拟地址默认是 0x100000000，因此，我们还能计算得到 ASLR 地址: 0x104708000 - 0x100000000 = 0x4708000 当然，ASLR 地址并不是我们关注的重点，只是略带提及。 如果要直接获取 ASLR 地址，可以使用 image list -o -f 指令，就会默认减去 __Text 段的虚拟地址 那么这个地址上的方法是什么呢？可以在 lldb 中通过 dis 命令反汇编输出： 在 MachOView 中这个地址的数据为 1F2003D5F0A0005800021FD6 。这是一段16进制的机器码。我们可以验证一下它和反汇编的结果是否一致。如果我们自己查表会非常费事，有一个 ARM to Hex 的网站，可以帮助我们将汇编代码转换为 Hex。我们只验证第二句汇编语句的正确性： 通过对比可以发现，MachOView 中相应 offset 的 Data 反汇编后就是 dis 生成的汇编代码。 重新看一下反汇编后的第二三条汇编代码。他们的作用是加载相对于当前地址，偏移量为 0x141c 的内存到寄存器 x16 中，然后执行。实际执行的地址的计算过程如下： 0x141c + 0x6BF4 = 0x8010 第一条汇编代码 offset 为 0x6BF0，那么第二条汇编代码 offset 即为 0x6BF4 在 MachOView 中体现为 __DATA,__la_symbol_ptr： 在 0x8010 的地址上的 data 为 0x0000000100006C2C。前面说到， __Text 虚拟地址默认是 0x100000000，这在 TEXT 段的 Load Commands 中有所体现： 所以实际的偏移地址为 0x6C2C。它的地址在 __Text,__stub_helper 中： __Text,__stub_helper 会调用 dyld_stu_binder 方法计算并绑定 NSLog 函数的真实地址。 让程序走过这个方法，再次通过 dis 查看汇编代码： 此次执行的方法地址不再是 0x10470ec2c，而是 0x2065176e6。也就是说进过了绑定之后， __Text,__stub 的方法指向发生了改变，指向了系统的动态库的方法。至此完成了 lazy binding 的过程。 从例子看非 lazy binding非 lazy binding 的符号会在应用启动的时候就 binding 完成。我们简单验证一下。首先看 __DATA,_nl_symbol_ptr 段在 MachOView 中的符号信息，在 MachOView 中的非 lazy binding 符号指向的地址都是 0x0： 当程序运行并加载成功后，我们再看相应位置的 data： 可以看到相应位置已经不再是 0x0，而是具体的链接完成后的地址了。 fishhook通过上面的两个例子的分析，我们能知道，动态链接的符号不是位于程序的 __Text 段的，而是存在于 __DATA 段中。位于 __Text 段的符号是只读的，而位于 __DATA 段的符号是可读可写的 这种懒绑定的方式其实叫做 PIC(Position Independent Code 地址无关代码)，fishhook 能够帮助我们修改这部分符号的地址 使用fishhook 的使用需要创建一个 rebinding 结构体，结构体中需要包含要 hook 的函数的名称，要替换的方法实现，被 hook 的方法的容器： 12345678910111213141516171819202122232425262728293031323334353637@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 定义rebinding 结构体 struct rebinding rebind = &#123;&#125;; // 需要hook的函数名称 rebind.name = "NSLog"; // 新函数的地址 rebind.replacement = hookNSLog; // 原始函数地址的指针 rebind.replaced = (void *)&amp;sys_NSLog; //将上面的结构体 放入 reb结构体数组中 struct rebinding rebindObj[] = &#123;rebind&#125;; /* * arg1 : 结构体数据组 * arg2 : 数组的长度 */ rebind_symbols(rebindObj, 1);&#125;//定义一个函数指针 用于指向原来的NSLog函数static void (*sys_NSLog)(NSString *format, ...);void hookNSLog(NSString *format, ...)&#123; format = [format stringByAppendingString:@"被勾住了"]; sys_NSLog(format);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@"原有NSLog函数");&#125;@end 源码解析rebind_symbols 方法先从调用方法 rebind_symbols 方法入手： 12345678910111213141516171819202122232425262728293031struct rebindings_entry &#123; struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next;&#125;;static struct rebindings_entry *_rebindings_head;int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123; // 维护一个 rebindings_entry 的结构 // 将 rebinding 的多个实例组织成一个链表 int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel); // 判断是否 malloc 失败，失败会返回 -1 if (retval &lt; 0) &#123; return retval; &#125; // _rebindings_head -&gt; next 是第一次调用的标志符，NULL 则代表第一次调用 if (!_rebindings_head-&gt;next) &#123; // 第一次调用，将 _rebind_symbols_for_image 注册为回调 _dyld_register_func_for_add_image(_rebind_symbols_for_image); &#125; else &#123; // 先获取 dyld 镜像数量 uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i &lt; c; i++) &#123; // 根据下标依次进行重绑定过程 _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); &#125; &#125; // 返回状态值 return retval;&#125; 先看 prepend_rebindings 方法，它会把传入的 rebindings 数组串成一个链表，链表的头部用 _rebindings_head 保存： 123456789101112131415161718192021222324252627282930/** * prepend_rebindings 用于 rebindings_entry 结构的维护 * struct rebindings_entry **rebindings_head - 对应的是 static 的 _rebindings_head * struct rebinding rebindings[] - 传入的方法符号数组 * size_t nel - 数组对应的元素数量 */static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) &#123; // 声明 rebindings_entry 一个指针，并为其分配空间 struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry)); if (!new_entry) &#123; return -1; &#125; // 为链表中元素的 rebindings 实例分配指定空间 new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel); if (!new_entry-&gt;rebindings) &#123; free(new_entry); return -1; &#125; // 将 rebindings 数组中 copy 到 new_entry -&gt; rebingdings 成员中 memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel); // 为 new_entry -&gt; rebindings_nel 赋值 new_entry-&gt;rebindings_nel = nel; // 为 new_entry -&gt; next 赋值，维护链表结构 new_entry-&gt;next = *rebindings_head; // 移动 head 指针，指向表头 *rebindings_head = new_entry; return 0;&#125; 在进行过了可能的多次 prepend_rebindings 方法后，会形成如下链表： 当然由于最开始 rebindgs_header 是 null，所以 next_entry-&gt;next = *rebindings_headr 就是 null，也就是说 *rebinding_head = new_entry 后， *rebinding_head-&gt;next 为 null。在 rebind_symbolds 方法中会执行 _dyld_register_func_for_add_image(_rebind_symbols_for_image); 方法。 _dyld_register_func_for_add_image 方法是 dyld 注册回调函数的方法，当镜像被加载的时候，就会主动触发注册的回调方法。 一个可执行文件会加载非常多的动态库，每个动态库的成功加载都会触发注册的回调方法。每个动态库镜像都会根据设置重绑定符号 此处注册了 _rebind_symbols_for_image 方法： 1234static void _rebind_symbols_for_image(const struct mach_header *header, intptr_t slide) &#123; rebind_symbols_for_image(_rebindings_head, header, slide);&#125; _rebind_symbols_for_image 方法非常的朴实，它会受到 dyld 加载成功时候传入的两个参数 mach_header *header 和 intptr_t slide。这两个参数分别是当前可执行文件的内存地址和 ASLR 偏移量。也就是说 mach_header *header 就是通过 image list 获取到的地址，如下图： 另外可以发现 mach_header *header 和 intptr_t slide 相差就是 0x100000000，也侧面印证了 mach_header *header 就是 __Text 段的实际起始地址 rebind_symbols_for_image 方法进入 rebind_symbols_for_image 方法，这是一个非常重要的方法，我们可以将其分为几个阶段来看。 获取动态静态符号表位置以及 linkedit_segment 的 load command 位置这一部分其实很简单，就是通过遍历 load commands 找到 symtab_command 和 dysymtab_command 以及 linkedit_segment 的位置： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; ... // 声明几个查找量: // linkedit_segment, symtab_command, dysymtab_command segment_command_t *cur_seg_cmd; segment_command_t *linkedit_segment = NULL; struct symtab_command* symtab_cmd = NULL; struct dysymtab_command* dysymtab_cmd = NULL; // 初始化游标 // header = 0x100000000 + ASLR 偏移 // sizeof(mach_header_t) = 默认 0x20 (Mach-O 头部大小) // 首先需要跳过 Mach-O Header uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); // 遍历每一个 Load Command，游标每一次偏移每个命令的 Command Size 大小 // header -&gt; ncmds: Load Command 加载命令数量 // cur_seg_cmd -&gt; cmdsize: Load 大小 for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; // 取出当前的 Load Command cur_seg_cmd = (segment_command_t *)cur; // Load Command 的类型是 LC_SEGMENT if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; // 比对一下 Load Command 的 name 是否为 __LINKEDIT if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; // 检索到 __LINKEDIT linkedit_segment = cur_seg_cmd; &#125; &#125; // 判断当前 Load Command 是否是 LC_SYMTAB 类型 // LC_SEGMENT - 代表当前区域链接器信息 else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; // 检索到 LC_SYMTAB symtab_cmd = (struct symtab_command*)cur_seg_cmd; &#125; // 判断当前 Load Command 是否是 LC_DYSYMTAB 类型 // LC_DYSYMTAB - 代表动态链接器信息区域 else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123; // 检索到 LC_DYSYMTAB dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; &#125; &#125;&#125; 前面提到过，在 Mach-O 加载进内存后，__Text 段的起始位置时 0x100000000，并且所有 offset 都是以 __Text 段为基准的。header 和 load commands 也是属于 __Text 段的一部分。上面的代码正印证了这个观点。 计算静态符号表和动态符号表以及字符串表的位置前面拿到了静态符号表以及动态符号表的 load command，现在就可以根据 load command 中的信息计算得到静态符号表,动态符号表以及字符串表的位置了： 1234567891011121314151617static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; ... // slide: ASLR 偏移量 // vmaddr: SEG_LINKEDIT 的虚拟地址 // fileoff: SEG_LINKEDIT 地址偏移 // 式①：base = SEG_LINKEDIT真实地址 - SEG_LINKEDIT地址偏移 // 式②：SEG_LINKEDIT真实地址 = SEG_LINKEDIT虚拟地址 + ASLR偏移量 // 将②代入①：Base = SEG_LINKEDIT虚拟地址 + ASLR偏移量 - SEG_LINKEDIT地址偏移 uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; // 通过 base + symtab 的偏移量 计算 symtab 表的首地址，并获取 nlist_t 结构体实例 nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); // 通过 base + stroff 字符表偏移量计算字符表中的首地址，获取字符串表 char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // 通过 base + indirectsymoff 偏移量来计算动态符号表的首地址 uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);&#125; 这里通过 linkedit 计算基地址，所有的偏移量都是以基地址为参照的。计算公式上面也有写到。获取到基地址后，就可以通过前面获取到的静态符号表以及动态符号表的 load commands 中保存的偏移量计算得到符号表 symtab，字符串表 strtab 以及动态符号表 indirect_symtab 的位置了。 跳转重绑定之后，重新遍历 load commands，获取 __DATA 段中的 __nl_symbol_ptr 和 __la_symbol_ptr 两个 section 的信息，然后执行真正的重绑定方法 perform_rebinding_with_section： 12345678910111213141516171819202122232425262728293031323334static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; ... // 归零游标 cur = (uintptr_t)header + sizeof(mach_header_t); // 再次遍历 Load Commands for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; // Load Command 的类型是 LC_SEGMENT if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; // 查询 Segment Name。不是 __DATA 或者 __DATA_CONST 的直接 return if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123; continue; &#125; // 遍历 Segment 中的 Section for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123; // 取出 Section section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; // flags &amp; SECTION_TYPE 通过 SECTION_TYPE 掩码获取 flags 记录类型的 8 bit // 如果 section 的类型为 S_LAZY_SYMBOL_POINTERS // 这个类型代表 lazy symbol 指针 Section if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123; // 进行 rebinding 重写操作 perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; // 这个类型代表 non-lazy symbol 指针 Section if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; &#125; &#125; &#125;&#125; 重绑定这是执行方法替换的最关键方法，我们先看一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab) &#123; // 在 Indirect Symbol table 中检索到 __la_symbol_ptr 或者 __nl_symbol_ptr 起始的位置 uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; // 获取 _DATA.__nl_symbol_ptr(或__la_symbol_ptr) Section // 已知其 value 是一个指针类型，整段区域用二阶指针来获取 void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); // 用 size / 一阶指针来计算 _DATA.__nl_symbol_ptr(或__la_symbol_ptr) 中符号的个数，遍历整个 Section for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; // 通过下标来获取每一个 Indirect Address 的 Value // 这个 Value 也是外层寻址时需要的下标 uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) &#123; continue; &#125; // 获取符号名在字符表中的偏移地址 uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; // 获取符号名 char *symbol_name = strtab + strtab_offset; // 取出 rebindings 结构体实例数组，开始遍历链表 struct rebindings_entry *cur = rebindings; while (cur) &#123; // 对于链表中每一个 rebindings 数组的每一个 rebinding 实例 // 依次在 String Table 匹配符号名 for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; // 符号名与方法名匹配 if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; // 如果是第一次对跳转地址进行重写 if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; // 记录原始跳转地址 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; // 重写跳转地址 indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; // 完成后不再对当前 Indirect Symbol 处理 // 继续迭代到下一个 Indirect Symbol goto symbol_loop; &#125; &#125; // 链表遍历 cur = cur-&gt;next; &#125; symbol_loop:; &#125;&#125; 获取 __la_symbol_ptr 或者 __nl_symbol_ptr 的符号在动态符号表的位置1uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; indirect_symtab 是 Dynamic Symbol Table 段： 它汇集了 __Text,__stubs ,__DATA,__nl_symbol_ptr,__DATA,__got， __DATA,__la_symbol_ptr 这几个段的所有动态链接符号的所有信息。 section 就是上面获取到的在 Load Command是中的 __la_symbol_ptr 以及 __nl_symbol_ptr 段的信息，它的 reserved1 就是该段在 Dynamic Symbol Table 中的位置。在 MachOView 中显示为 Indirect Sym Index: 由于 indirect_symtab 是 uint32 类型的指针，所以一个指针占用4个字节。因此偏移 reserved1即偏移 reserved1 * 4 的地址。 获取 __la_symbol_ptr 或者 __nl_symbol_ptr的实际地址1void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); 之前我们说过一个公式： ASLR偏移 + 段的虚拟地址 = 段的实际地址 section-&gt;addr 就是段的虚拟地址，indirect_symbol_bindings 就是指向段的实际地址。由于 __la_symbol_ptr 或者 __nl_symbol_ptr 段内保存的是一个个指向实际方法的指针，因此 indirect_symbol_bindings 就被声明为一个二级指针。 遍历 __la_symbol_ptr 或者 __nl_symbol_ptr替换符号实现方法123456789101112131415161718192021for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; uint32_t symtab_index = indirect_symbol_indices[i]; uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; char *symbol_name = strtab + strtab_offset; struct rebindings_entry *cur = rebindings; while (cur) &#123; for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; goto symbol_loop; &#125; &#125; cur = cur-&gt;next; &#125; symbol_loop:;&#125; 遍历 __la_symbol_ptr 或者 __nl_symbol_ptr 是为了将每一个动态符号和要替换的符号方法匹配，那么通过什么匹配的呢？通过符号名。也就是每个循环中的内容。 根据符号在 Dynamic Symbol Tabel 的位置，拿到它在 Symbol Tabel 的索引位置 symtab_index，然后在 Symbol Tabel 的相应位置拿到他在 String Tabel 的偏移 strtab_offset。获取到偏移后就加上 string table 的基地址，拿到符号的位置，也就获得了符号名 symbol_name。 符号名拿到后，就可以遍历自定义的要替换的符号数组 rebindings，一一匹配符号名和要替换的符号名是否匹配。如果匹配了，并且没有替换过(替没替换过只要判断 rebindings 结构体的 replaced 是否为空即可)，就让 indirect_symbol_bindings 相应的符号指向 rebindings 相应的 replacement 方法的地址。 至此，fishhook 整个替换流程就结束了。 总结到这里你一定被各种跳转和各种偏移绕晕了。下面我来整理一个过程： lazy binding 过程 lazy binding 的符号指向 __TEXT,__stubs ，调用的时候会执行 __TEXT,__stubs 指向的方法。它会调用 __DATA,__la_symbol_ptr 指向的地址上的方法。 未绑定时，__DATA,__la_symbol_ptr 指向的地址为 ___TEXT,stub_helper，它会执行系统函数修改 __DATA,__la_symbol_ptr 的指向。 绑定后， __DATA,__la_symbol_ptr 指向实际的函数的地址 fishhook 替换过程 通过注册系统回调 _dyld_register_func_for_add_image 获取 image 的起始地址和 ASLR 偏移。 通过 image 的起始地址，加上 Header 的大小(Header 固定大小为 0x20)，得出 Load Commands 的起始地址 遍历 Load Commands 拿到 __DATA,__nl_symbol_ptr 和 __DATA,__la_symbol_ptr 的各项信息，包括段的位置，段的大小，段在 Dynamic Symbol Table 的起始索引 reserved1（也就是 MachOView 中的 Indirect Sym Index）。 再次遍历 Load Commands 拿到符号表的 LC： LC_SYMTAB，从中获取 Symbol Table 和 String Table 的起始位置；同时拿到动态符号表的 LC： LC_DYSYMTAB 获取动态符号表 DYSYMTAB的起始位置; 根据第四步获取的动态符号表的起始位置，以及第三步获取的起始索引，在 DYSYMTAB 中遍历 __DATA,__nl_symbol_ptr 或者 __DATA,__la_symbol_ptr 的各个符号，其中保存了它在 Symbol Table 中的的索引。 根据从动态符号表中得到的这个索引，获取该符号在 SYMTAB的信息，可以拿到它在 String Table 的 offset。这个 offset 保存着符号的名字。 拿到这个符号的名字和我们要替换的各个符号名做对比，如果相同，那么把 __DATA,__nl_symbol_ptr 或者 __DATA,__la_symbol_ptr 相应位置的符号指向要替换的方法的地址。至此，fishhook 替换完成 思考题 为什么需要动态链接？ 什么是 Lazy Binding？ 为什么 fishhook 可以重新绑定符号？这和动态链接有什么关系？ 懒绑定的符号存在哪个段中？ 系统的 Lazy Binding 是如何实现的？ 如何拿到 Load Command 的偏移？ 参考深入理解fishhook 巧用符号表 - 探求 fishhook 原理 ios逆向 - mach-o文件分析 深入理解fishhook]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员的自我修养》读书笔记]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%2F</url>
    <content type="text"><![CDATA[最近又重读了《程序员的自我修养》一书。有了许多新的感受。书需要重复的读。最开始的一遍很多都看不懂，也觉得没必要知道。现在很多知识都已经有了印象，看书的过程更像是查漏补缺的过程。以下是这本书的部分笔记。 温故而知新内存虚拟地址物理地址对应于物理内存，是实际存在的。虚拟地址是不存在的地址空间，每个进程有自己独立的虚拟空间，然后通过某些映射方式，将虚拟地址转化为实际的物理地址。 虚拟地址主要为了解决使用物理地址时，地址空间不隔离，内存使用效率低，运行地址不确定等问题。对于程序来说，它永远从 0x00000000 开始的连续地址，不需要考虑重定位。 分段将一个完整的虚拟空间分为若干段，每段都与物理地址上的某个区域对应，叫做分段。虚拟地址中的每个字节都对应于物理空间中的每个字节。 分段的映射过程由操作系统完成，实际的地址转换由硬件完成。 分段解决了地址空间不隔离，运行地址不确定的问题。 分页分段没有解决内存使用效率低的问题。从磁盘到物理内存的数据置换如果以段为单位，仍将进行大量的置换。因此将段更细的拆分为页，一般为 4kb 大小。 虚拟内存到物理内存的映射关系是以页为单位的。 可以看到不同进程的页可能映射到相同的物理内存中。这会造成两种情况： 非活跃进程某页的物理地址上的数据会被置换为活跃进程的某页的数据。 两个进程通过共享这一物理地址上的数据进行 IPC (应用进程间通信) 线程线程的访问权限线程可以访问进程里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址) Linux 多线程Linux 中并不存在真正的线程。它的执行实体(无论线程还是进程)都被称为任务。每个任务相当于一个单线程的进程。 它有三种方式创建任务： fork exec clone 其中，fork 产生新任务的速度最快。因为 fork 不会立即复制任务的内存，而是写时复制。 线程安全线程安全就不得不提锁。iOS 中最常见的有两种锁： NSLock，@synchronize：本质上都是互斥锁 dispatch_semaphone_t：信号量 多元信号量与互斥锁的差别在于：多元信号量可以实现在多个任务完成后的回调，互斥锁显然是无法完成的。 那么二元信号量和互斥锁有什么区别呢？一般情况下我们认为二元信号量和互斥锁相同。其实他们的本质区别是：同一个信号量可以被系统中的一个线程获取，由另一个线程释放。而互斥锁则要求哪个线程获取了互斥锁，哪个线程就要释放，其他线程无法越俎代庖的去释放。如图所示： 由于在主线程中释放二元信号，可以看到第二个任务没有等第一个结束就开始执行了。而如果主线程没有释放信号量，那么第二个任务是要等第一个任务结束，释放信号量，才能执行的。这就是信号量和互斥锁的区别 多线程内部上面我们所说的多线程是指由操作系统调度的内核线程。而用户实际使用的线程并不是内核线程，而是出于用户态的用户线程。用户线程的数量不一定对应于内核线程的数量。一般有三种线程模型： 一对一模型：即一个用户线程对应一个内核线程 多对一模型：即多个用户线程对应一个内核线程 多对多模型：即多个用户线程对应多个内核线程 对于一对一模型，用户的线程切换也就是内核线程的切换，存在线程切换上下文时的开销。对于多对一模型，用户的线程切换不是内核线程的切换，因此也就不存在切换上下文时的开销。但是对于多对一模型，如果一个用户线程阻塞了，那么内核线程阻塞，其他用户线程也就无法继续执行了。 Linux 中的线程模型是一对一模型 编译和连接基本流程当我们 Build 一个项目的时候，一般分为四个步骤：预处理，编译，汇编，链接 预处理主要处理代码中以 # 开头的预编译指令。编译将文件转为汇编代码文件。汇编将汇编代码替换为对应的机器指令。链接将各个汇编后产生的文件链接。 静态链接静态链接主要包含地址空间分配，符号解析，重定位等步骤。 链接不只是把代码堆叠到一起(代码堆叠可以理解为地址空间分配)。在编译的时候，会有一个符号表记录出现的所有类，全局变量，方法等符号。这些符号所指向的是当前文件的偏移位置，而在链接的时候将会被修改为链接后完整文件的偏移。编译的同时，有一些引用的类，方法等的地址是未知的，这些未知的地址就是一个个空洞。 符号表中的符号以及这些位置的空洞都是需要在链接的时候进行地址偏移修正的。因此，编译的时候还会生成一个重定位表需要地址修正的各个符号以及需要链接的空洞。 符号解析就是将每个符号引用和其对应的符号定义联系起来。也就是修正符号表中符号所指向的全局变量、方法的地址。 重定位就是链接器把每个符号定义与一个虚拟地址联系起来。也就是将代码段中原本未链接的符号的地址修改为链接后修正偏移后的符号的地址。 其实可以更朴素的理解： 链接之后有两部分地址发生变化，一部分是符号指向的全局变量、方法的地址的偏移，还有一部分是各个文件的符号表中符号本身的地址发生偏移。 因此就要有两步操作，第一步纠正全局符号表中符号指向的全局变量或方法的位置，第二步纠正代码中使用的未链接时相对于本文件的符号的地址，将其改为全局符号表中修正过的符号的地址。 目标文件可执行文件中的段目标文件即在汇编之后，在链接之前的文件。除了包含编译后的机器指令、数据外，还包含符号表，调试信息等。目标文件将不同属性保存在不同的段（Section）中。 除了 Section，我们再看 Mach-o 文件的时候，经常会碰到 Segment。这两者都可以成为段(虽然 Segment 的意思才是段，Section 的意思是节)。 Section 和 Segment 的区别在于：目标文件是以 Section 为单位分段的，但是加载到内存中是以 Segment 为单位加载。 我们所说的 .text, .data, .bss 指的都是 Section。而代码段，数据段指的都是 Segment。 可执行文件的文件头包含了文件属性，还包含一个段表（Section Table），段表是一个用来描述文件中各个段的数组，包含了文件中各个段的偏移位置及属性。 一个可执行文件一般包含以下的段： .text段：即代码段，保存了编译后的执行语句。 .data段：和 .bss 段统称数据段，保存了已初始化的全局变量和局部静态变量的值。 .bss 段：存放未初始化的全局变量和局部静态变量。由于是未初始化的变量，所以可执行文件中不会分配空间给 bss 段，只会在段头中记录 bss 段的大小。bss 段空间由系统初始化。bss 段 的目的就是减少程序大小。 除了上面所述的三个段，还有很多常见的段如下图： 自定义段处了上述的段，我们还可以自定义段：__attribute__((section(&quot;name&quot;)))。如： 1__attribut__((section("FOO"))) int global = 42; 就是创建了一个叫 FOO 的段，并且把全局变量 global 放了进去。使用的时候再通过相应的 c 方法获取即可。 阿里的模块化框架 BeeHive 就是通过这种方式全局注册模块信息。这样的好处是不需要维护一个数组取保存，使用的时候直接把自定义段中的所有变量拿到即可。自定义段本身就相当于是一个数组。(当然，其实就把模块信息保存在 .data 段中的一个数组中其实也没什么问题) ELF 文件结构ELF 文件结构如下： ELF 文件头ELF 文件头主要包含可执行文件的基本信息。包含 ELF 魔数，版本，运行平台，ABI 版本，程序头入口和长度，段表的位置和长度，段的数量等。 关于什么是 ABI。ABI 涵盖了各种细节：如数据类型、大小和对齐；调用约定（控制着函数的参数如何传送以及如何接受返回值）；系统调用的编码和一个应用如何向操作系统进行系统调用。 关于什么是魔数。魔数用来确定文件的类型，操作系统在加载可执行文件的时候会确定是否正确。 段表段表是一个数组，描述了段的段名，段的长度，文件中的偏移，读写权限等属性。 重定位表每个文件的重定位表都记录了该文件中在链接时需要重定位的符号以及引用的外部符号的信息，以及它们在当前文件的偏移位置。 字符串表可执行文件中的很多字符串，如段名，变量名保存在这里。使用字符串在表中的偏移来引用字符串。 如图所示，就是字符串表的保存方式，每个字符串以 \0 结尾，这样就只需要给出一个数字下标就可以表示一个字符串了。 符号什么是符号表链接就是把变量或函数的地址填到编译后空洞的过程。链接中的变量和函数统称为符号 每一个目标文件都有一个相应的符号表（Symbol Tabel），记录了用到的所有的符号，每个符号有一个对应的值，叫做符号值，对于变量和函数来说，符号值就是它们的地址。 代码中的变量方法最终编译后都替换为了符号表中的偏移，然后在找到对应的符号后，到相应的位置取出对象（可以是 .data 段，字符串表，堆栈等）。 符号表结构符号表结构如下： 其中 st_info 用来标识符号是局部符号，全局符号，还是弱符号；以及符号的类型，是变量还是数组，还是函数。 一般通过 st_shndx 和 st_value 定位符号的所表示的位置。然后通过 st_size 拿出相应大小的值。 强符号和弱符号编译期认为函数和初始化了的全局变量为强符号，没有初始化的全局变量为弱符号。也可以通过 __attribute__((weak)) 声明弱符号： 12345extern int ext;int weak;int strong = 1;__attribute ((weak)) weak2 = 2; 上面 weak 和 weak2 为弱符号，strong 为强符号。ext 即非强符号也非弱符号，它是一个外部变量的引用。 编译期针对强符号和弱符号制定了一些规则： 强符号不可以定义多次。否则报错 如果一个符号在某个目标文件是强符号，其他文件是弱符号，那么它的类型以强符号为准。 如果一个符号在所有文件中都是弱符号，那么选择占用控件最大的一个符号的类型。 由上可见，符号是不带类型的。 静态链接链接过程对于多个输入目标文件，链接器如何将它们合并到一个输出文件的？一般讲一个个文件的相似度段合并： 一般会经历两步： 空间和地址分配 符号解析和重定位 空间和地址分配首先扫描所有的目标文件，获得所有各个段的长度属性和位置，然后将目标文件的所有符号定义和符号引用收集起来，放到一个全局符号表中。这一步中，链接器能获取所有段的长度，并将它们合并，计算出合并后的各个段的长度和位置，并建立映射关系。 这其实就是纠正符号指向的变量、方法的位置偏移 符号解析和重定位ELF 文件中有一个重定位表专门用来保存于重定位相关的信息。重定位表是一个数组，数组的元素非常简单： r_offset 表示符号在当前文件的偏移量，r_info 表示这个符号的信息。 在重定位的时候，会根据 r_info 的信息，在全局符号表中查找相应的符号。然后把符号的地址写到 r_offset 所指向的其在当前文件的位置偏移。 这其实就是将单个文件中原本相对于本文件的偏移，转化为相对于链接后所有文件的位置的偏移。 ABI我们把符号修饰标准，变量内存布局，函数调用方式等跟可执行代码二进制兼容性相关的内容称为 ABI。 ABI 不稳定就是说变量的内存布局，函数调用方式等可能会变，也就是编译规则可能会变。 ABI 稳定就是在不同编译器下，编译出来的可执行文件能够被正确的链接到一起。 影响 ABI 的因素很多，比如： 内置类型（如 int float 等）的大小和在存储器中的放置方式(大端，小端，对其方式) 组合类型(如 struct， union，数组等)的存储方式和内存布局 外部符号与用户定义的符号之间的命名方式和解析方式，如函数名 func 在 C 语言的目标文件中是否被解析成外部符号 _func 函数调用方式，如参数入栈熟悉怒，返回值如何保持 堆栈分布方式，如参数和局部变量在堆栈中的位置，参数传递方式 寄存器使用约定，函数调用时哪些寄存器可以修改哪些需要保存 由此可见 ABI 主要影响着编译和汇编的过程： 编译主要影响函数调用相关的汇编代码的生成 链接主要影响生成的可执行文件的内存分布 可执行文件的装载与进程进程虚拟地址空间程序被运行起来后，将拥有独立的虚拟地址空间(Virtual Address)。这个虚拟地址空间大小由计算机的硬件平台决定，具体地说是由 CPU 位数决定的。硬件决定了地址空间的最大理论上限，即硬件寻址空间的大小。一个32位处理器的最大寻址空间是 4GB。 对于一个 32 位的处理器，他的最大寻址空间是 4GB。一般在 Linux 系统中将会有 1 GB被划分给操作系统。我们的进程最多使用 3GB 的虚拟空间。也就是说，整个进程在执行的时候，所有的代码，数据包包括 C 语言 malloc() 等方法申请的虚拟空间之和不可以超过 3GB。 装载方式很多时候，我们的程序实际需要的内存要大于物理能够同时装载的内存。在这种情况下，需要有一种动态装载的方式可以将最常用的部分驻留内存，而将不常用的数据存放在磁盘中。 页映射是现在最常用的动态装载方法。思想史程序用到哪个模块，九江哪个模块装入内存，如果不用就暂不装入，存放在磁盘中。 页映射将内存和磁盘中的所有数据和指令按照页(page)为单位划分成若干个页，以后所有的装载和操作单位都是页。一般以 4kb 作为一个页。 操作系统角度看可执行文件的装载创建一个进程，操作系统主要需要做以下三件事情： 创建独立的虚拟地址空间。创建一个页目录，用于确定物理内存和虚拟空间的映射关系。 读取可执行文件头，建立虚拟空间和和执行文件的映射关系。 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行 当 CPU 将要执行某个地址的指令，并且该地址是一个空页的时候（即页所指向的物理地址上存放的不是虚拟空间想要的数据和指令），就被认为是一个页错误（Page Fault）。CPU 将控制权交给操作系统。操作系统会在物理内存中分配一个物理页面，或者收回一个已使用的物理页，将虚拟页所需的数据和指令加载进来，然后将进程中的虚拟页和分配的物理页建立映射关系，最后把控制权交还给进程，进程从刚才页错误的位置重新执行。 进程虚拟控件分布section 和 segment前文说过，可执行文件的区域是以 section 为单位区分的，装载进内存中是以 segment 为单位区分的。segment 中包含了多个权限相同的 section。 这是因为 ELF 文件被映射时，是以系统的页长度为单位的，每个段在映射时的长度应该是系统页长度的整数倍。如果不是，那么多余部分也要占用一个页。一个 ELF 文件中往往有十几个段，会造成内存空间的浪费。因此把相同权限的 section 合并到一起当做一个 segment 进行映射。 如图所示，在虚拟内存中占用三个页的 .text段和 .init段，会被合并为一个 segment 载入。在物理内存中就只占两个页： 堆和栈当我们以 Segment 划分的时候，进程可以划分为以下几个区域： 代码段 数据段 堆段 栈段 动态链接动态链接的目的静态链接浪费内存和磁盘，动态链接在磁盘和内存中只会保存一份，因此节约了内存。动态链接把链接的过程推迟到了运行时再进行。 地址无关代码什么是地址无关代码地址无关代码(PIC，Position-independent Code)，简单来说就是把需要用到的外部模块的变量和方法的地址抽离出来，作为变量和其他数据放在一起。这样指令部分就和具体的地址无关了。 对于模块间的全局变量和方法，ELF 在数据段中创建了一个指向这些变量的指针数组，也被称为全局偏移表(Global Offset Table，GOT)。当代码需要引用全局变量时，可以通过 GOT 中相应的项间接引用： 共享模块的全局变量动态库只有一份，那么动态库中的全局变量也是只有一份吗？ 不会。当共享对象呗两个进程加载时，他的数据段部分在每个进程中都有独立的副本。从这个角度看，共享对象中的全局对象实际上和定义在程序内部的全局变量没有什么区别。任何一个进程访问的只是自己的那个副本，不会影响其他进程。 延迟绑定动态链接相对于静态链接性能略差，主要原因有以下两方面： 模块间对于全局数据的访问以及函数调用，需要进行复杂的 GOT 定位。 程序开始执行时，动态链接器会进行链接工作。动态链接会装载所需的未装载的共享对象，并进行符号查找以及重定位。 针对上面的第二个原因，可以使用延迟绑定（Lazy Binding）的方式，基本思想是当函数第一次被用到时才进行绑定（符号查找，重定位等）。 ELF 使用 PLT（Procedure Linkage Table）实现。不直接使用 GOT 跳转，而是先通过 PLT。(具体代码上如何实现的不探究了) ELF 将 GOT 拆分成了两个表 .got 和 .got.plt。前者用来保存全局变量的引用地址，后者用来保存函数的引用地址。 动态链接相关结构.interp 段.interp 段中保存了可执行文件所需的动态链接器的路 .dynamic 段保存了动态链接器所需的基本信息。包括依赖于哪些共享对象，动态链接符号表的位置，动态链接符号表的位置，共享对象初始化代码的地址。 .dynsym 段静态链接中有一个符号表 .symtab(Symbol Table)，保存了目标文件的符号和引用。ELF 有一个专门的动态符号表（Dynamic Symbol Table）。由于在动态链接下，需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表（.hash） 动态链接步骤 动态链接器自举 装载共享对象 重定位和初始化 动态链接具体如何实现的不做深入探究。 内存程序内存布局程序的内存布局如下： 其中 dynamic libraries 为动态链接库映射区，该区域用于映射装载的动态链接库。Linux 下，系统默认从 0x40000000 开始分配相应的控件，用于共享库载入到内存。 图中的箭头表明了堆和栈的增长方向，可以看到，堆向高地址增长，栈向低地址增长，直到预留的控件用完为止。 栈的调用栈相关的五个寄存器栈的调用会用到四个 CPU 寄存器： BP(Base Pointer) ：分割当前调用的方法和上一个调用的方法 SP(Stack Pointer)：保存栈顶的位置 SS(Stack Segment )：保存栈段的位置 IP(Instruction Pointer)：保存下一条指令的地址 AX：保存当前方法的返回值 方法调用与栈的变化关系一个方法调用流程如下 将方法的入参从右至左依次入栈 将该方法执行完后返回的地址入栈 将当前 bp 指向的地址入栈，并将 bp 指向当前 sp 指向的位置 将方法中创建的局部变量压栈(实际是直接给 sp 增加一个固定的值，让局部变量不听的往里 push，而不是 push 一个局部变量，变一次 sp 的指向) 方法执行完毕，将返回值的地址赋给 ax 寄存器 出栈直到 sp 和 bp 指向同一个地址 把保存的返回地址出栈，并赋给 ip 出栈直到将方法的入参都 pop 完 系统调用系统调用原理特权级与中断在操作系统中通常有两种特权级别用户模式（User Mode）和内核模式（Kernel Mode），也被成为用户态和内核态。 系统调用运行在内核态，应用程序运行在用户态。内核态可以运行用户态的代码。但是用户态想要运行内核态的代码必须通过中断（interrupt）。中断是一个硬件或软件发出的请求，要求CPU暂停当前的工作转手去处理更重要的事情。 比如按下键盘，键盘上的芯片发送一个信号给 CPU，CPU 收到信号后知道键盘按下了，再去询问键盘被按下的键。这个信号就是一个中断。 中断一般具有两个属性，一个是中断号(从0开始)，一个是中断处理程序。内核中，存在一个数组叫做中断向量表，这个数组保存着中断号和中断处理程序的映射。 Linux 使用 int 0x80 来用户触发中断。用户将中断号放入 AX 寄存器中，然后使用 int 0x80 触发中断。中断服务程序就可以通过 AX 获取中断号，调用对应的函数。 可以看到 0x80 是中断向量中的一个，代表着用户触发的中断 切换堆栈Linux 中用户态和内核态使用不同的栈，当应用程序调用 0x80 号中断时，程序的执行流程从用户态切换到内核态，程序的当前栈也相应的从用户栈切换到内核栈。中断完成后，程序的当前栈从内核栈切换回用户栈。 当 0x80 号中断发生的时候，过程如下： 保存当前用户栈的 SP 和 SS 的值 找到进程的内核栈(每一个进程都有自己的内核栈) 将 SP 和 SS 设置为内核栈的相应值 在内核栈中依次亚茹用户态的寄存器 SS， SP 等以供恢复调用 ∴切换堆栈就是切换 CPU 的寄存器。 趣谈 Linux 系统(极客时间)系统初始化CPU 的组成CPU 由三部分组成 运算单元：只管算，如做加法或者位移 数据单元：CPU 内部的寄存器组 控制单元：读取执行指令，这个指令会指导运算单元取出数据单元中数据，计算结果，然后放到数据单元的某个地方 x86 的由来早期各家的 CPU 架构各不相同。直到英特尔的 8086 芯片做到了开放统一和兼容。因此被称为 x86 架构。 BIOS计算机主板上有一个 ROM(只读存储器)，在上面固化了初始化程序，也就是 BIOS。 当电脑刚加电的时候，会做一些重置的工作，将 CS 设置为 0xFFFF，将 IP 设置为 0x0000，所以第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react.js 使用]]></title>
    <url>%2F2019%2F05%2F06%2Freact%2F</url>
    <content type="text"><![CDATA[写了一年多的 RN，react 包括 redux 还是很熟练的，但是写起 pc 端顿时有点懵逼。 styled-components当我们在一个 js 文件中引入一个 css 文件的时候，实际上是全局引用的。这样会造成样式混乱。需要引入样式模块。因此可以使用 styled-components 安装1npm install --save styled-components 现在样式不再使用 css 定义，而是使用 js 定义 基本使用在 style.js 中定义组件，定义了一个叫 HeaderWrapper 的 div 标签： 123456import styled from 'styled-components'export const HeaderWrapper = styled.div` height: 54px; background: red;` 现在可以把 HeaderWrapper 当成普通组件一样使用： 123456789101112import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper&#125; from './style'class Header extends Component &#123; render () &#123; return ( &lt;HeaderWrapper&gt;header&lt;/HeaderWrapper&gt; ) &#125;&#125; 设置样式全局样式创建 style.js 文件。引入全局样式模块 injectGlobal: 123456789import &#123; injectGlobal &#125; from 'styled-components'injectGlobal` body &#123; margin: 0; padding: 0; background: green; &#125;` 通过反引号包裹的就是注入全局的样式，然后在根视图中引入： 1import './style.js' 某一个组件的特定样式某一个组件可以根据传入的 className 设置不同的样式： 12345678910111213export const NavItem = styled.div` &amp;.left &#123; float: left; &#125; &amp;.right &#123; float: right; &#125; &amp;.active &#123; background: #fff; &#125; line-height: 56px; padding: 15px;` 使用 &amp; 表示当前组件的 className。使用方式如下： 1234import &#123;NavItem&#125; from './style.js'&lt;NavItem className='left active'&gt;左边样式&lt;/NavItem&gt;&lt;NavItem className='right'&gt;右边样式&lt;/NavItem&gt; 父组件中设置子组件的样式父组件中可以通过子组件的 className 定位子组件。比如有一个子组件的 className 为 iconfont： 1234567export const Parent = styled.div` height: 100px; .iconfont &#123; position: absolute; right: 0; &#125;` 注意，组件设置自己的样式是通过 &amp;.classname，而设置子组件的样式是通过 .classname 完成的。 父组件中设置子标签的样式其实就和 less 一样，可以在父样式中设置子样式： 12345export const Parent = styled.div` div &#123; height: 20px; &#125; ` 设置 Parent 组件内部的 div 默认是 20px 其他使用引入资源比如需要在样式中设置背景图片，直接使用相对路径是无用的，需要引入配合 webpack 使用： 12345import logoPic from '../../assets/logo.png'export const Logo = styled.a` background: url($&#123;logoPic&#125;)` 通过 import 引入的资源文件需要通过 ${} 这样的模板语法使用。 获取 js 中的 props还是使用 ${}，它除了可以传入一个路径，还可以接收一个方法，入参就是该组件的 props： 123export const SomeItem = styled.div` background: url($&#123;(props) =&gt; props.imgUrl&#125;)` 1234567import &#123;SomeItem&#125; from 'style'class App extends Components &#123; render () &#123; &lt;SomeItem imgUrl='http://xxxxx' /&gt; &#125;&#125; 除style外的默认属性定义组件的时候可以给组件设置默认的属性： 123456export const Navsearch = styled.input.attrs(&#123; placeholder: '搜索'&#125;)` width: 90px; height: 32px;` 这是一个输入框组件，通过 attrs 设置默认占位符属性。 路由安装1npm install --save react-router-dom 使用1234567891011121314151617import &#123;BrowserRouter, Router&#125; from 'react-router-dom'import Home from './pages/home'class App extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route exact path='/' render=&#123;Home&#125; /&gt; &lt;Route exact path='/detail' render=&#123;()=&gt;(&lt;div&gt;detail&lt;/div&gt;)&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; ) &#125;&#125; 跳转使用 Link 标签包裹： 1234567891011import &#123;Link&#125; from 'react-router-dom'class Home extends Component &#123; render () &#123; return ( &lt;Link to='/detail'&gt; &lt;SomeImg /&gt; &lt;/Link&gt; ) &#125;&#125; 和 Link 类似的，还有 Redirect 标签，用于重定向： 1234567891011import &#123;Redirect&#125; from 'react-router-dom'class Home extends Component &#123; render () &#123; return ( &lt;Redirect to='/login'&gt; &lt;SomeView /&gt; &lt;/Redirect&gt; ) &#125;&#125; 自动重定向上面演示的是需要点击的跳转和重定向，但是有时候需要自动的重定向比如未登录的时候直接跳转登录页。 为了达到这个效果，我们可以使用一个自闭合的 Redirect 标签： 12345678910111213141516import &#123;Redirect&#125; from 'react-router-dom'class Home extends Component &#123; render () &#123; return ( &#123; this.props.login ? ( &lt;HomeView /&gt; ) : ( &lt;Redirect to='/login' /&gt; ) &#125; ) &#125;&#125; 应该是 Redirect 会在渲染的时候判断是否有子元素，以此作为依据是否直接重定向。 页面传参页面之间传参可以有两种方式，一种是动态路由，一种是直接传参。 动态路由动态路由用于从上个页面传递参数给下个页面。设置总共分为三步： 路由设置动态路由1234567891011121314151617import &#123;BrowserRouter, Router&#125; from 'react-router-dom'import Home from './pages/home'class App extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route exact path='/' render=&#123;Home&#125; /&gt; &lt;Route exact path='/detail/:id' render=&#123;()=&gt;(&lt;div&gt;detail&lt;/div&gt;)&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; ) &#125;&#125; 可以看到，和上面使用唯一的不同在于 path=&#39;/detail/:id&#39;。其中 :id 表示接收端会接收到一个叫 id 的参数 跳转前页面传参1234567891011import &#123;Link&#125; from 'react-router-dom'class Home extends Component &#123; render () &#123; return ( &lt;Link to='/detail/2'&gt; &lt;SomeImg /&gt; &lt;/Link&gt; ) &#125;&#125; 可以看到，和用 Link 跳转唯一的不同在于 to=&#39;/detail/2&#39;，跳转页面多了一个参数，这个参数会在跳转后的页面通过 id 取到。 跳转后的页面获取参数12345class Detail extends Component &#123; componentDidMount () &#123; const id = this.props.match.params.id &#125;&#125; id 就通过 prop 获取到。 直接传参直接传参不需要配置路由，直接在跳转前的页面拼接要传递的参数： 1234567891011import &#123;Link&#125; from 'react-router-dom'class Home extends Component &#123; render () &#123; return ( &lt;Link to='/detail?id=2'&gt; &lt;SomeImg /&gt; &lt;/Link&gt; ) &#125;&#125; 参数需要自己手动解析获取： 12345class Detail extends Component &#123; componentDidMount () &#123; const idString = this.props.location.search // ?id=2 &#125;&#125; 异步组件单页应用会把所有的页面打包到一个 bundle 中，这就会造成 bundle 庞大的问题，需要将页面拆分为异步组件。 1npm install --save react-loadable 123456789101112// detail/loadable.jsimport React from 'react'import Loadable from 'react-loadable'const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./index.js'), loading() &#123; return (&lt;div&gt;我正在加载，这是加载时候的提示&lt;/div&gt;) &#125;&#125;)export default () =&gt; &lt;LoadableComponent /&gt; 之后使用到详情页的地方不再引用原来的组件，而是引用这个异步组件： 1234567891011121314151617import &#123;BrowserRouter, Router&#125; from 'react-router-dom'import Detail from './pages/detail/loadable'class App extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;BrowserRouter&gt; &lt;div&gt; &lt;Route exact path='/detail' render=&#123;Detail&#125; /&gt; &lt;Route exact path='/' render=&#123;()=&gt;(&lt;div&gt;home&lt;/div&gt;)&#125; /&gt; &lt;/div&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; ) &#125;&#125; withRouterwithRouter 和 redux 中 connect 方法将 store 中的相应属性和方法传递给视图的作用一样，当你在路由组件中使用的视图被其他视图嵌套的时候，能够帮助你直接过去到路由相关的参数。 比如上面的 Detail，它是无法从它的 props 中拿到 loacation 或者 match 属性的，因为它被一部组建包裹了。使用 withRouter 就可以将路由相关的属性通过虫洞，直接交给视图： 123456789import &#123;withRouter&#125; from 'react-router-dom'class Detail extends Component &#123; componentDidMount () &#123; const idString = this.props.location.search // ?id=2 &#125;&#125;export default withRouter(Detail) CSS 技巧屏幕居中先把左上角移动到屏幕中间，再把自身向左上角移动一半： 123456.center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; float 的使用float 和 absolute 类似，可以将视图脱离于默认的排布，只不过 absolute 可以设置相对定位的元素，以及上下左右的位置。而 float 只能浮动到上下左右四个边。 设置一个视图的高度为屏幕高度减去一个特定高度vh 单位会把屏幕分为 100 等分。所以整个屏幕的高度为 100vh 。减去一个特定像素的高度后，要使用 calc 方法计算： 123.fullscreen &#123; height: calc(100vh - 80px)&#125; display 为 block inline-block inline 的区别1、display：block将元素显示为块级元素，从而可以更好地操控元素的宽高，以及内外边距，每一个块级元素都是从新的一行开始。 2、display : inline将元素显示为行内元素，高度，行高以及底边距不可改变，高度就是内容文字或者图片的宽度，不可以改变。多个相邻的行内元素排在同一行里，知道页面一行排列不下，才会换新的一行。 3、display：inline-block看上去值名inline-block是一个混合产物，实际上确是如此，将元素显示为行内块状元素，设置该属性后，其他的行内块级元素会排列在同一行。比如我们li元素一个inline-block，使其既有block的宽度高度特性，又有inline的同行特性，在同一行内有不同高度内容的元素时，通常要设置对齐方式如vertical-align: top;来使元素顶部对齐。 构建技巧devDependencied 和 dependencies 区别一般情况下，我们使用 npm install module-name -save 来把模块和版本号添加到 dependency 中，npm install module-name -save-dev 来把模块和版本号添加到 devdependencies 中。 这两个依赖的区别在于，在本地构建代码的时候需要用到 devDependencies 中的代码。比如我们需要使用 babel,eslint,webpeck 来构建代码，这些就会放在 devDependencies 中。这些依赖代码不会存在于构建好的项目代码中。 devdependency 中的文件如果使用 npm publish 发布 npm 包也不会被上传 npx 的使用一般我们安装一些 nodejs 的命令行工具需要先全局安装，比如使用 create-react-app 这种脚手架就需要先: 12&gt; npm install create-react-app -g&gt; create-react-app my-app 事实上，我们没有必要使用全局安装的方式就可以解决，把它安装到某一个项目中，然后使用 npx 执行： 12&gt; npm install --save-dev create-react-app&gt; npx create-react-app my-app 其实就相当于执行了 node-modules 下 bin 目录中的二进制文件： 1&gt; node-modules/.bin/create-react-app my-app 实践技巧请求添加 cookieaxios 默认的请求是不会添加 cookie 的，需要在请求的 option 字段中添加 withCredentials: true 这个选项才行。 这个选项要求请求不能跨域，或者跨域的域名在服务端 access-control-allow-origin 允许的域名中。 设置 cookie要想服务端通过 set-cookie能够成功设置 cookie 的前提是请求不能跨域名。跨域名的请求是无法设置 cookie 的。 之所以说是不能跨域名是因为 cookie 是跨端口共享的，即如果你的主站是 localhost:3000 请求的端口是 localhost:3001，那么 set-cookie 还是能够成功设置的。 简单来说，跨域请求是不能读取 cookie 的。但是跨端口设置 cookie 是能成功的。 协议，域名，端口有一个不同就是跨域 另外要说明一下， 使用 localhost 和本机 ip 这是两个不同的域名，一定是跨域的。所以要设置 cookie 的时候，不要主站用 localhost，请求用 ip，或者主站用 ip，请求用 localhost。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa的基本使用]]></title>
    <url>%2F2019%2F04%2F23%2Fkoa%2F</url>
    <content type="text"><![CDATA[本篇是学习 node.js 基础框架 Koa 的学习总结 koa 基本使用安装 1npm install --save koa 创建 app.js: 12345678910111213const Koa = require('koa')const app = Koa()// express 的老写法// app.use(function (req, res) &#123;// res.send('haha')// &#125;)app.use(async ctx =&gt; &#123; ctx.body = 'hahh'&#125;)app.listen(3000) Koa 中间件中间件就是匹配路由前和匹配路由后做的一系列操作。中间件的功能包括： 修改请求和响应对象 终止请求和响应循环 调用堆栈中的下一个中间件 中间件按照功能可以分为： 应用级中间件 路由中间件 错误处理中间件 第三方中间件 应用级中间件应用级中间件，我觉得可以叫做全局中间件，就是所有请求都要经过的。举例：对于每一个请求，打印它的请求时间： 1234567891011121314151617181920212223const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()// 应用级中间件app.use(async (ctx, next) =&gt; &#123; // 打印时间 console.log(new Date()) // 等待后续中间件的执行 await next()&#125;)router.get('/', async (ctx, next) &#123; ctx.body = 'hello koa' &#125;)// 总的路由的中间件也是应用级中间件app.use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('starting at port 3000')&#125;) 类比 redux 中的中间件，中间件通过 use 注册，内部保存在一个中间件的数组中。可以通过调用 next() 方法执行下一个中间件。如果不调用，那么后面的中间件都不会继续执行。 路由级中间件路由级中间件可以使一个请求匹配多个路由: 12345678910111213141516171819202122const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()router.get('/', async (ctx, next) &#123; console.log('调用 next 匹配下一个路由') // 执行 next 方法，可以匹配下一个路由 await next()&#125;)router.get('/', async (ctx, next) &#123; ctx.body = 'hello koa again' &#125;)app.use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('starting at port 3000')&#125;) 不同于应用级中间件，路由级中间件只针对路由。可以大概猜测出，应用级中间件中的 next 是 koa 提供的，而路由级中间件的 next 方法应该是 koa-router 提供的。 错误处理中间件其实就是一个应用级中间件。错误处理用在没有匹配任何路由，返回一个 404 页面： 1234567891011121314151617181920212223242526const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()// 全局中间件。这个地方用来处理错误app.use(async (ctx, next)) &#123; // 执行普通的路由匹配 await next() // 没有匹配上任何路由，那么状态就是404 if (ctx.status === 404) &#123; ctx.body = '这是一个404页面' &#125;&#125;router.get('/', async (ctx, next) &#123; ctx.body = 'hello koa again' &#125;)app.use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('starting at port 3000')&#125;) 利用这种方式可以做消息转发 koa 路由中间件安装： 1npm install --save koa-router 静态路由示例12345678910111213141516const Koa = require('koa')const Router = require('koa-router')const app = new Koa()const router = new Router()// 配置路由router.get('/', async (ctx) =&gt; &#123; ctx.body = '首页' // 相当于原生里的 res.writeHedr() res.end()&#125;).get('/news', async (ctx) =&gt; &#123; ctx.body = '这是一个新闻页面'&#125;)// app.use(router.routes()) // 启动路由 .use(router.allowedMethods()) // 可配置可不配置，建议配置。会根据 ctx.status 设置 response 响应头app.listen(3000) 获取 get 传值12345678router.get('/news', async (ctx) =&gt; &#123; // 从 ctx 中读取get传值,获取的是对象；等同于 ctx.request.query console.log(ctx.query) // 获取 url; 等同于 ctx.request.url console.log(ctx.url) // 获取整个request console.log(ctx.request)&#125;) 获取 post 传值安装 koa-bodyparser 1npm install --save koa-bodyparser 12345678910111213141516171819202122const Koa = require('koa')const Router = require('koa-router')const BodyParser = require('koa-bodyparser')const app = new Koa()const router = new Router()const bodyParser = new BodyParser()// 使用 bodyParser 中间件app.use(bodyParser)router.post('/', async (ctx, next) // 通过 ctx.request.body 获取表单提交的数据 // 获取的 post 的 body 已经被转为对象 console.log(ctx.request.body) &#125;)app.use(router.routes()) .use(router.allowedMethods())app.listen(3000, () =&gt; &#123; console.log('starting at port 3000')&#125;) get 和 post 都支持如果一个请求，既要支持 get 又要支持 post 也是可以的，可以使用 .all 方法： 12345router.all('/:pid', async (ctx) =&gt; &#123; console.log(ctx.url) const buffer = await fse.readFile('./test.json') ctx.body = buffer.toString()&#125;) 动态路由静态路由要求路径完全匹配，动态路由可以前部匹配，后部可以动态获取。koa 中通过 : 作为动态路由的标识： 12345678// 动态路由匹配 /news/xxxxrouter.get('/news/:aid', async (ctx) =&gt; &#123; // 动态路由的传值 console.log('以下是动态路由路由:' + (ctx.params).toString())&#125;)// 比如输入 localhost:3000/news/haha// =&gt; 以下是动态路由的路由: &#123;aid: 'haha'&#125; 动态路由可以匹配多个值。如 /news/:aid/:cid 设置 Cookie 和 Session设置 cookie设置 cookie123456789101112router.get('/', async (ctx) =&gt; &#123; ctx.cookies.set('userInfo', 'zachary', &#123; // 设置过期时间 maxAge: 60*1000*60, // 配置可以访问的页面 path: '/news', // 当有多个子域名的时候使用，也可以不写，默认是请求的域名 domain: '.baidu.com', // true 表示这个 cookie 只有服务器端可以方位，false 表示客户端也可以访问 httpOnly: true &#125;)&#125;) 获取 cookie123router.get('/', async (ctx) =&gt; &#123; console.log(ctx.cookies.get('userInfo'))&#125;) 如果客户端需要拿到 cookie，那么必须设置 httpOnly 为 false 设置 Sessionsession 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而session 保存在服务器上。 Session 的工作流程当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对， 然后将 key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带 key(cookie)，找到对应的 session(value)。 客户的信息都保存在 session 中。 设置 Session1npm install --save koa-session 使用： 123456789101112131415161718192021222324252627// 引入const session = require('koa-session')// 设置中间件app.keys = ['some secret hurr']const CONFIG = &#123; key: 'koa:sess', //cookie key (default is koa:sess) maxAge: 86400000, // cookie 的过期时间 maxAge in ms (default is 1 days) httpOnly: true, //cookie 是否只有服务器端可以访问 httpOnly or not (default true) signed: true, //签名默认 true rolling: false, //在每次请求时强行设置cookie，这将重置cookie过期时间(默认:false) renew: true, // 快过期的时候重新设置&#125;app.use(session(CONFIG, app))// 设置router.get('/login', async (ctx) =&gt; &#123; // 设置 session ctx.session.userInfo = 'zachary' ctx.body = '登录成功'&#125;)// 获取router.get('/', async (ctx) =&gt; &#123; console.log(ctx.session.userInfo)&#125;) koa-session 的原理就是在内存中生成一个 session 的散列表。每次生成一个随机的字符串，并将其作为 cookie 下发给客户端，key 对应于 config 中的 key。设置的 app.keys 应该就是加密用的秘钥。 当 session 量比较大的时候，就需要考虑通过使用外部存储的方式进行存储。比方说 mysql，redis 等 Session 和 Cookie 的区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 会暴露用户的信息，所以使用 session，只在 cookie 中保存一个 id，每次请求通过这个 id 从 session 散列表中获取相应的信息。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。 访问静态文件如果不想使用模板渲染或者 nuxt.js 这种服务端渲染框架。可以尝试直接访问 vue 生成的 dist 文件。 生成 Vue 的 dist 目录通过 vue-cli 生成 Vue 项目，通过 npm run build 生成 dist 目录，把 dist 目录整个拷贝到 koa 所在目录下： 访问静态文件访问静态文件需要使用相关中间件 koa-static: 1234567891011const Koa = require('koa')const app = new Koa()// 访问当前目录下的 dist 目录中的文件const static = require('koa-static')('./dist')// 配置静态资源文件路径app.use(static)app.listen(3000, () =&gt; &#123; console.log('正在监听3000端口')&#125;) 此时当你访问 localhost:3000 的时候，koa 就会将 dist/index.html 返回显示。 如果同时使用了路由中间件，需要把资源文件的中间件先于路由中间件注册。否则会被路由拦截 路由模块化把所有路由放在一个文件中显然是不好维护的，因此需要针对路由进行子路由拆分。 实现创建子路由首先创建 routes 文件夹，创建子路由文件，比如命名为 admin.js。在其中添加子路由： 1234567891011121314// 在 /routes/admin.js 目录下const Router = require('koa-router')const router = new Router()router.get('/', async (ctx) =&gt; &#123; ctx.body = 'admin 首页' &#125;) router.get('/user', async (ctx) =&gt; &#123; ctx.body = 'admin 用户页' &#125;) module.exports = router.routes() 引入子路由12345678910111213// app.jsconst router = require('koa-router')()const app = require('koa')()// 引入子路由const admin = require('./routes/admin.js')// 用子路由替代了原来的 async 方法// 注意，一定是 use，不是 get 或者 post，我在这里卡了很久router.use('/admin', admin)app.use(router.routes()).use(router.allowedMethods()) 这样以下请求就会映射到相应子路由中： 12http://localhost:3000/adminhttp://localhost:3000/admin/user 实践node 自动重启开发的时候每次修改都要手动重新 run 一次 node 会非常的麻烦。因此需要一个能自动重启的库的帮助。这个库就是 nodemon: 1npm install -g nodemon 全局安装 nodemon，然后启动的时候不要通过 node 了，而是 nodemon： 1nodemon app.js 文件操作使用 node 提供的 fs 操作文件比较复杂，尤其是使用 koa 的时候本生不支持 promise 写法。 fs-extra 是一个比较完善的文件操作封装库： 1npm install --save fs-extra 使用起来也和 fs 无异。下面例子中读取本地的 json 文件并返回： 123456const fse = require('fs-extra')router.get('/', async (ctx) =&gt; &#123; const buffer = await fse.readFile('./test.json') ctx.body = buffer.toString()&#125;) 发送请求我们使用 koa 接收客户端请求。但是很多时候，我们需要对请求做转发。因此，需要使用 nodejs 发送请求。 发送请求可以使用库 request-promise。它是 request 的 promise 版本： 123npm install --save request-promise# request 是 request-promise 的依赖项，需要自己手动安装npm install --save request 请求方式很简单： 1234567891011121314151617app.use(async (ctx, next) =&gt; &#123; // 先让路由响应 await next() // 如果没有一个路由相应 if (ctx.status === 404) &#123; const url = `https://colorlab.lian-shang.cn$&#123;ctx.url&#125;` try &#123; // 尝试请求转发 let obj = await request.get(url) ctx.body = obj &#125; catch (err) &#123; // 转发请求发送失败 console.log('发生了error') console.log(err.statusCode) &#125; &#125;&#125;) 要注意， await 中发生的 error 需要通过 try…catch 捕获。 设置环境变量node 中的环境变量在 process.env 中保存，使用库 cross-env 可以方便设置兼容 windows 的环境变量： 1npm install --save-dev cross-env package.json 中设置环境变量： 12345&#123; "scripts": &#123; "build": "cross-env NODE_ENV=production webpack --config build/webpack.config.js" &#125;&#125; NODE_ENV 环境变量将由 cross-env 设置。打印 process.env.NODE_ENV === &#39;production&#39; 为 true 允许跨域跨域的请求需要借助第三方的库 koa-cors 进行允许跨域设置： 1npm install koa-cors 使用： 123456789101112app.use(cors(&#123; origin: function (ctx) &#123; if (ctx.url === '/cors') &#123; return '*' // 允许来自所有域名请求 &#125; return 'http://localhost:3000' &#125;, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], // 设置允许的HTTP请求类型 allowHeaders: ['Content-Type', 'Authorization', 'Accept']&#125;)) 其中 origin 字段对应于 access-control-allow-origin，通过它设置哪些站点发起哪些请求可以进行跨域。上面🌰表示，请求路径为 /cors 的这个请求可以进行跨域，但是不能获取 cookie 信息，而 http://localhost:3000 这个域名下的所有请求都可以进行跨域，且可以获取 cookie 信息，是受信的站点。 如果设置了 access-control-allow-origin 为 *，那么就是允许跨域了。但是跨域的客户端请求，无法携带该域名下的 cookie 信息给服务端。 必须设置 access-control-allow-origin 为一个特定的域名，而不是 *。这样 Access-Control-Allow-Credentials 才会被默认置位 true，才可以跨域使用 cookie。 所以这是一个三级保证。没有 *，那么无法发出请求，没有特定的域名，没有发送带 cookie 的请求。 连接 MysqlNodejs 连接 Mysql 需要 install 相关的库： 1npm install --save mysql 基本使用： 1234567891011121314151617181920212223242526const mysql = require('mysql')// 创建连接对象const con = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '', port: '3306', database: 'your_database'&#125;)// 开始连接con.connect()// 执行简单的sqlconst sql = 'select * from your_databse'con.query(sql, (err, result) =&gt; &#123; if (err) &#123; console.error(err) return &#125; console.log(result)&#125;)// 关闭连接con.end() 防止 sql 注入sql 如果是通过字符串拼接的方式注入的参数，那么容易引起 sql 注入。Nodejs 中的 mysql 库引入了 escape 方法，会对参数进行转义： 1select id from User where username = $&#123;escape(username)&#125; redisredis 是一种内存存储，可以配合 mysql 进行频繁操作的数据的存储。 安装 redis安装1brew install redis 启动 server1redis-server 启动 client1redis-client 存取值 1234# 设置键值对&gt; set myname zachary# 取值&gt; get myname 使用 redis安装 redis nodejs 模块1npm install redis --save node 中使用123456789101112131415161718192021const redis = require('redis')// 创建客户端// 默认是 6379 端口const redisClient = redis.createClient(6379, '127.0.0.1')redisClient.on('error', err =&gt; &#123; console.log(err)&#125;)// 测试使用redisClient.set('myname', 'zachary', redis.print)redisClient.get('myname', (err, val) =&gt; &#123; if (err) &#123; console.error(err) return &#125; console.log('val', val) // 退出 redis redisClient.quit()&#125;) PM2 进程守护，系统奔溃自动重启 启动多进程，充分利用 CPU 和内存 自带日志记录 下载1npm install pm2 -g 启动开发环境下使用 nodemon，线上环境可以使用 pm2: 1pm2 start app.js 常用命令1234567891011121314# 查看进程列表pm2 list# 重启进程pm2 restart &lt;AppName&gt;/&lt;id&gt;# 停止进程pm2 stop &lt;AppName&gt;/&lt;id&gt;# 删除进程pm2 delete &lt;AppName&gt;/&lt;id&gt;# 查看进程信息pm2 info &lt;AppName&gt;/&lt;id&gt;# 查看日志(console.log/error/warn)pm2 log &lt;AppName&gt;/&lt;id&gt;# 监控pm2 monit &lt;AppName&gt;/&lt;id&gt; 命令行node 写脚本需要配合 shell 语法，shelljs 是一个封装的很晚上的库]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IQKeyboardManager 源码解析]]></title>
    <url>%2F2019%2F04%2F20%2Fiqkeyboardmanager%2F</url>
    <content type="text"><![CDATA[IQKeyboardManager 是一个优秀的零行代码解决键盘遮挡的第三方库。在没有看过源码的时候是我认为的最有魔力的第三方库。现在我们就要揭开它的面纱。 使用方式IQTextViewIQTextView 是一个提供了 placeholder 的 UITextView。可以设置它文字和颜色： 12345#import "IQTextView.h"IQTextView *textView = [[IQTextView alloc] init];textView.placeholder = @"这是一个placeholder";textView.placeholderTextColor = [UIColor redColor]; IQKeyboardReturnKeyHandler这个文件可以帮助我们将键盘上的 return 键变为 next 键，点击进入下一个输入框。当到最后一个输入框的时候，变为 Done，点击收起键盘。 123456789#import "IQKeyboardReturnKeyHandler.h"@property (nonatomic, strong) IQKeyboardReturnKeyHandler *returnKeyHandler;- (void)viewDidLoad:(BOOL)animated&#123; [super viewDidLoad:animated]; self.returnKeyHander = [[IQKeyboardReturnKeyHandler alloc] initWithViewController:self]; self.returnKeyHander.delegate = self;&#125; 使用非常简单。只要传入当前 textfield 所在的控制器即可。可以通过设置 IQKeyboardReturnHandler 的 delegate 设置所有 textfield 的 delegate。也可以自己设置每个 textfield 的 delegate。 IQKeyboardManager在某个页面禁用 IQKeyboardManager12345678910 - (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; //写入这个方法后,这个页面将没有这种效果 [IQKeyboardManager sharedManager].enable = NO;&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; //最后还设置回来,不要影响其他页面的效果 [IQKeyboardManager sharedManager].enable = YES;&#125; 除了上面的直接禁用和启用，IQKeyboardManager 也可以设置在禁用的时候在部分 ViewController 上启用，或者在启动的时候在部分 ViewController 上禁用： 1234// 在整体禁用的时候可以启动 IQKeyboardManager 的类[[IQKeyboardManager sharedManager].enabledDistanceHandlingClasses addObject: yourViewControllerClass];// 在整体启动的时候需要禁用 IQKeyboardManager 的类[[IQKeyboardManager sharedManager].disabledDistanceHandlingClasses addObject: yourViewControllerClass]; 点击空白处可以隐藏键盘1[IQKeyboardManager sharedManager].shouldResignOnTouchOutside = YES; 隐藏键盘上的 toolbar1[IQKeyboardManager sharedManager].enableAutoToolbar = NO; 除了这种一刀切的隐藏或者显示 toolbar 之外，IQKeyboardManager 还提供了两个数组属性，用于标识特例 ViewController： 12@property(nonatomic, strong, nonnull, readwrite) NSMutableSet&lt;Class&gt; *disabledToolbarClasses;@property(nonatomic, strong, nonnull, readwrite) NSMutableSet&lt;Class&gt; *enabledToolbarClasses; 这两个属性分别可以设置在 enableAutoToobar 为 YES 的时候，不显示 toobar 的 ViewController；enableAutoToobar 为 NO 的时候，显示 toobar 的 ViewController。 disableToolbarClasses 默认为： 1[UIAlertController, _UIAlertControllerTextFieldViewController] 源码解析IQTextViewIQTextView 主要就是在 UITextView 的基础上添加了一个 UILabel。实现起来也非常简单。 placeholder 主要关注两件事，一是 placeholder 的位置，二是 placeholder 何时隐藏。 首先看 placeholder 的位置，它通过 sizeThatFits 方法获取到占位符的大小： 12345678910111213141516171819202122// 布局方法-(void)layoutSubviews&#123; [super layoutSubviews]; self.placeholderLabel.frame = [self placeholderExpectedFrame];&#125;// placeholder 的 inset-(UIEdgeInsets)placeholderInsets&#123; return UIEdgeInsetsMake(self.textContainerInset.top, self.textContainerInset.left + self.textContainer.lineFragmentPadding, self.textContainerInset.bottom, self.textContainerInset.right + self.textContainer.lineFragmentPadding);&#125;-(CGRect)placeholderExpectedFrame&#123; UIEdgeInsets placeholderInsets = [self placeholderInsets]; CGFloat maxWidth = CGRectGetWidth(self.frame)-placeholderInsets.left-placeholderInsets.right; CGSize expectedSize = [self.placeholderLabel sizeThatFits:CGSizeMake(maxWidth, CGRectGetHeight(self.frame)-placeholderInsets.top-placeholderInsets.bottom)]; return CGRectMake(placeholderInsets.left, placeholderInsets.top, maxWidth, expectedSize.height);&#125; 再看 placeholder 何时隐藏。何时隐藏？只要当前 textView 的 text 不为空就要隐藏。那么怎么知道不为空呢？注册监听 UITextViewTextDidChangeNotification 的通知 1234567891011121314151617181920-(void)initialize&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(refreshPlaceholder) name:UITextViewTextDidChangeNotification object:self];&#125;-(void)refreshPlaceholder&#123; /// 如果有 text 或者 attributedText 那么就显示否则隐藏 if([[self text] length] || [[self attributedText] length]) &#123; [_placeholderLabel setAlpha:0]; &#125; else &#123; [_placeholderLabel setAlpha:1]; &#125; [self setNeedsLayout]; [self layoutIfNeeded];&#125; 分类文件数组分类数组分类中包含该两个方法，通过 tag 大小或者通过位置对 UIView 排序： 12- (NSArray&lt;UIView*&gt;*)sortedArrayByTag- (NSArray&lt;UIView*&gt;*)sortedArrayByPosition 这个方法中我们可以学习一个排序的方法： 123456789101112131415161718192021- (NSArray&lt;UIView*&gt;*)sortedArrayByPosition&#123; return [self sortedArrayUsingComparator:^NSComparisonResult(UIView *view1, UIView *view2) &#123; CGFloat x1 = CGRectGetMinX(view1.frame); CGFloat y1 = CGRectGetMinY(view1.frame); CGFloat x2 = CGRectGetMinX(view2.frame); CGFloat y2 = CGRectGetMinY(view2.frame); if (y1 &lt; y2) return NSOrderedAscending; else if (y1 &gt; y2) return NSOrderedDescending; //Else both y are same so checking for x positions else if (x1 &lt; x2) return NSOrderedAscending; else if (x1 &gt; x2) return NSOrderedDescending; else return NSOrderedSame; &#125;];&#125; 通过 sortedArrayUsingComparator 传入一个比较大小的 block。先根据 y 轴比较大小，y 轴相等的时候再比较 x 轴大小。这样得到的就是一个根据该方法排序的数组。 UIScrollView 分类UIScrollView 分类中添加了两个分类属性： 1234567// 标识该 UIScrollView 是否可以调整 contentOffset 来达到调整 textfield 位置的目的。// 默认是 NO，表示该 UIScrollView 可以被调整。// 如果设置为 YES，表示当前视图不能移动，就会找上级视图移动@property(nonatomic, assign) BOOL shouldIgnoreScrollingAdjustment;// 是否保存调整位置前的 UIScrollView 的 contentOffset 的值。如果保存，那么恢复后 UIScrollView 将滚回原来的位置。默认是 NO，不保存@property(nonatomic, assign) BOOL shouldRestoreScrollViewContentOffset; UITextField 分类其实是添加在 UIView 上的几个属性： 123456// 设置键盘弹出后，textfield 到键盘的距离@property(nonatomic, assign) CGFloat keyboardDistanceFromTextField;// 如果设置为 YES，那么上一个 textfield 点击 next 之后，就不会跳到这个 textfield 上@property(nonatomic, assign) BOOL ignoreSwitchingByNextPrevious;// 焦点在这个 textfield 上时，是否可以点击外部取消焦点@property(nonatomic, assign) IQEnableMode shouldResignOnTouchOutsideMode; UIView 分类UIView 的分类下的方法分为两类，一类是获取 UIView 所在的 UIViewController，一类是获取当前视图下的 UITextField： 12345678// 获得 UIView 的控制器,通过响应链获取@property (nullable, nonatomic, readonly, strong) UIViewController *viewContainingController;// 获得最上层的视图控制器@property (nullable, nonatomic, readonly, strong) UIViewController *topMostController;// 获取当前视图的所有兄弟 textfield@property (nonnull, nonatomic, readonly, copy) NSArray&lt;__kindof UIView*&gt; *responderSiblings;// 把当前视图下的所有的 textfield 都收集起来，包含视图的子视图@property (nonnull, nonatomic, readonly, copy) NSArray&lt;__kindof UIView*&gt; *deepResponderViews; IQKeyboardReturnKeyHandlerIQKeyboardReturnKeyHandler 主要用来解决多个 textfield 的时候点击 return 跳到下一个 textfield 的问题。没有看过源码的时候觉得是一个非常神奇的功能。其实实现方式简单点说就是获取当前 UIViewController 内的所有 textfield，然后对他们按照位置排序。点击 return 就让下一个 textfield 获取焦点。 初步处理初步处理的过程中，会把 UIViewController 中的所有 textfield 全都拿出来，保存基本信息。目的是当 IQKeyboardReturnKeyHandler 实例销毁的时候，将所有 textfield 恢复如初。 首先看入口方法： 1234567891011121314151617181920212223// 把 controller 中的所有 textfield 添加到这个类中，所有代理由这个类托管。-(instancetype)initWithViewController:(nullable UIViewController*)controller &#123; self = [super init]; if (self) &#123; textFieldInfoCache = [[NSMutableSet alloc] init]; if (controller.view) &#123; [self addResponderFromView:controller.view]; &#125; &#125; return self;&#125;// 获取当前视图的所有子视图中的 textfield 并添加到数组中-(void)addResponderFromView:(UIView*)view &#123; NSArray&lt;UIView*&gt; *textFields = [view deepResponderViews]; for (UIView *textField in textFields) [self addTextFieldView:textField];&#125; 可以看到一个熟悉的方法 deepResponderViews，也就是说，初始化的时候，从 UIViewController 中找到了所有的 textfield，并且通过 addTextFieldView 方法把他们保存起来。addTextFieldView 方法把 textfield 的 originalReturnKeyType delegate 保存了起来，转为了一个 modal，并把它们的 delegate 设置为了自己。这样 textfield 的所有事件都会由 IQKeyboardReturnKeyHandler 实例接管。 123456789101112131415161718192021// 把 TextField 转为 Modal 添加到 cache 中-(void)addTextFieldView:(UIView*)view &#123; IQTextFieldViewInfoModal *modal = [[IQTextFieldViewInfoModal alloc] initWithTextFieldView:view textFieldDelegate:nil textViewDelegate:nil originalReturnKey:UIReturnKeyDefault]; if ([view isKindOfClass:[UITextField class]]) &#123; UITextField *textField = (UITextField*)view; modal.originalReturnKeyType = textField.returnKeyType; modal.textFieldDelegate = textField.delegate; [textField setDelegate:self]; &#125; else if ([view isKindOfClass:[UITextView class]]) &#123; UITextView *textView = (UITextView*)view; modal.originalReturnKeyType = textView.returnKeyType; modal.textViewDelegate = textView.delegate; [textView setDelegate:self]; &#125; [textFieldInfoCache addObject:modal];&#125; 接管 textfield 的 textfieldDidBeginEditing 方法IQKeyboardReturnKeyHandler 实例接管了 textfield 的相关方法。在 textfieldDidBeginEditing 中。它会将除最后一个 textfield 之外的所有 textfield 的 returnkeytype 设置为 next，最后一个设置为 return。 具体看代码： 123456- (void)textFieldDidBeginEditing:(UITextField *)textField&#123; [self updateReturnKeyTypeOnTextField:textField]; // 省略了调用代理方法的代码 ...&#125; 1234567891011121314151617-(void)updateReturnKeyTypeOnTextField:(UIView*)textField &#123; // 省略了关于 UITableView 相关的搜索逻辑 ... textFields = [textField responderSiblings]; switch ([[IQKeyboardManager sharedManager] toolbarManageBehaviour]) &#123; case IQAutoToolbarByTag: textFields = [textFields sortedArrayByTag]; break; case IQAutoToolbarByPosition: textFields = [textFields sortedArrayByPosition]; break; default: break; [(UITextField*)textField setReturnKeyType:(([textFields lastObject] == textField) ? self.lastTextFieldReturnKeyType : UIReturnKeyNext)];&#125; updateReturnKeyTypeOnTextField 方法中将被编辑的 textfield 的兄弟 textfield 全都拿到，然后按照所处位置排序，得到一个排序好的 textFields 兄弟数组，把他们最后一个设置为 Return 类型，其他的都设置为 Next 类型。 其中省略了一部分关于 UITableView 的处理逻辑。设想一下，如果一个 textfield 处于 UITableView 的一个 cell 中，那么应该这个 UITableView 的其他 cell 也会有 textfield。这些 textfield 虽然不是在一个视图中，但应该也是同级的兄弟 textfield。因此，IQKeyboardManager 针对这种情况会对 UITableView 进行深搜，拿到所有的 textfield。 这里省略 UITableView 相关逻辑是因为我们只需要知道设置 textfield 的 returnkeytype 的关键点在于在开始编辑的时候找到所有 textfield 的兄弟 textfield 即可。UITableView 相关逻辑只是对这个目的的补充。 接管 textfield 的 textFieldShouldReturn 方法和 textfieldDidBeginEditing 相对应的，当点击 next 键的时候，会将焦点置于下一个 textfield： 1234567891011121314151617181920-(BOOL)textFieldShouldReturn:(UITextField *)textField&#123; id&lt;UITextFieldDelegate&gt; delegate = self.delegate; if ([delegate respondsToSelector:@selector(textFieldShouldReturn:)]) &#123; BOOL shouldReturn = [delegate textFieldShouldReturn:textField]; if (shouldReturn) &#123; shouldReturn = [self goToNextResponderOrResign:textField]; &#125; return shouldReturn; &#125; else &#123; return [self goToNextResponderOrResign:textField]; &#125;&#125; 12345678910111213141516171819202122232425262728-(BOOL)goToNextResponderOrResign:(UIView*)textField &#123; // 省略 UITableView 相关逻辑 ... textFields = [textField responderSiblings]; switch ([[IQKeyboardManager sharedManager] toolbarManageBehaviour]) &#123; case IQAutoToolbarByTag: textFields = [textFields sortedArrayByTag]; break; case IQAutoToolbarByPosition: textFields = [textFields sortedArrayByPosition]; break; default: break; &#125; NSUInteger index = [textFields indexOfObject:textField]; if (index != NSNotFound &amp;&amp; index &lt; textFields.count-1) &#123; [textFields[index+1] becomeFirstResponder]; return NO; &#125; else &#123; [textField resignFirstResponder]; return YES; &#125;&#125; 其实理解了设置 returnkeytype 的逻辑，这里设置下一个响应者的逻辑也就明了了。还是获得排序后的 textfield 数组，只要把下一个 textfield 设置为第一响应者就可以了。 IQKeyboardManager注册IQKeyboardManager 通过 +(void)load 方法自动创建自身： 12345+(void)load&#123; //Enabling IQKeyboardManager. Loading asynchronous on main thread [self performSelectorOnMainThread:@selector(sharedManager) withObject:nil waitUntilDone:NO];&#125; 我们常说不要在 load 方法中做太多耗时操作，会影响应用的启动速度。所以，我们可以把要做的初始化操作异步去执行。下面来看初始化方法 注册通知注册的通知主要包含两部分。一部分是键盘的弹出与隐藏，另一部分是 UITextField 和 UITextView 的编辑的回调。具体通知的处理方法后文解析。 123456789101112131415161718192021222324252627-(void)registerAllNotifications&#123; // 注册键盘相关通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidShow:) name:UIKeyboardDidShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil]; // 注册 UITextField 的编辑通知 [self registerTextFieldViewClass:[UITextField class] didBeginEditingNotificationName:UITextFieldTextDidBeginEditingNotification didEndEditingNotificationName:UITextFieldTextDidEndEditingNotification]; // 注册 UITextView 的编辑通知 [self registerTextFieldViewClass:[UITextView class] didBeginEditingNotificationName:UITextViewTextDidBeginEditingNotification didEndEditingNotificationName:UITextViewTextDidEndEditingNotification];&#125;// 注册开始编辑和结束编辑的通知-(void)registerTextFieldViewClass:(nonnull Class)aClass didBeginEditingNotificationName:(nonnull NSString *)didBeginEditingNotificationName didEndEditingNotificationName:(nonnull NSString *)didEndEditingNotificationName&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidBeginEditing:) name:didBeginEditingNotificationName object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldViewDidEndEditing:) name:didEndEditingNotificationName object:nil];&#125; 注册之外的所有逻辑都在这些通知方法内 创建一个 UITapGestureRecognizer这个手势用来在点击 UITextField 以外的区域的时候收起键盘 12345678910111213141516171819// 为点击屏幕取消第一响应者这个功能创建一个手势strongSelf.resignFirstResponderGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapRecognized:)];// 设置该手势不取消事件传递strongSelf.resignFirstResponderGesture.cancelsTouchesInView = NO;// 设置手势代理为自身[strongSelf.resignFirstResponderGesture setDelegate:self];// 将手势默认设为不启用strongSelf.resignFirstResponderGesture.enabled = strongSelf.shouldResignOnTouchOutside;// 点击外部区域是否取消第一响应者[self setShouldResignOnTouchOutside:NO];- (void)tapRecognized:(UITapGestureRecognizer*)gesture // (Enhancement ID: #14)&#123; if (gesture.state == UIGestureRecognizerStateEnded) &#123; //Resigning currently responder textField. [self resignFirstResponder]; &#125;&#125; 配置键盘遮挡相关的一些类下面的这些配置用于设置 Textfield 在哪些类中 IQKeyboardManager 能够启用，或者关闭。一般使用场景不多。见名思意。 1234567891011strongSelf.disabledDistanceHandlingClasses = [[NSMutableSet alloc] initWithObjects:[UITableViewController class],[UIAlertController class], nil];strongSelf.enabledDistanceHandlingClasses = [[NSMutableSet alloc] init];strongSelf.disabledToolbarClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];strongSelf.enabledToolbarClasses = [[NSMutableSet alloc] init];strongSelf.toolbarPreviousNextAllowedClasses = [[NSMutableSet alloc] initWithObjects:[UITableView class],[UICollectionView class],[IQPreviousNextView class], nil];strongSelf.disabledTouchResignedClasses = [[NSMutableSet alloc] initWithObjects:[UIAlertController class], nil];strongSelf.enabledTouchResignedClasses = [[NSMutableSet alloc] init];strongSelf.touchResignedGestureIgnoreClasses = [[NSMutableSet alloc] initWithObjects:[UIControl class],[UINavigationBar class], nil]; textFieldViewDidBeginEditing在这个开始编辑的方法中，主要就是根据需要添加或移除 toolbar： 判断是否允许添加首先会调用 privateIsEnableAutoToobar 方法，判断是否需要显示 toobar。这个判断逻辑就是根据外部设置的 enable 变量的值，然后还有前面提到的当前 textfield 所在的 ViewController 是否是 enable 的特例。伪代码如下： 1234567891011- (Bool) privateIsEnableAutoToobar &#123; if (开启IQKeyboardManager) &#123; if (textfield 在禁止的 ViewController 中) &#123; return NO; &#125;&#125; else &#123; if (textfield 在允许的 ViewController 中，并且不是 UIAlertController 和 TextFieldViewController ) &#123; return YES; &#125; &#125;&#125; 在 IQToolbar 上添加按钮如果允许添加。那么就会调用 addToolbarIfRequired 方法。主要是在 toolbar 中添加各种 button。伪代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)addToolbarIfRequired &#123; if (textfield 能够添加 inputAccessoryView &amp;&amp; textfield 的 inputAccessoryView 为 nil) &#123; if (有自定义的图片 toolbarDoneBarButtonItemImage) &#123; 用这个 toolbarDoneBarButtonItemImage 初始化一个 toolbar 右边的 done 按钮 &#125; else if (有自定义的文字 toolbarDoneBarButtonItemText) &#123; 用这个 toolbarDoneBarButtonItemText 初始化一个 toobar 右边的 done 按钮 &#125; else &#123; 初始化默认的右边的 toolbar 的 done 按钮 &#125; if (当前 textfield 没有兄弟 textfield) &#123; // 只有一个就不用添加左边的前一个后一个的按钮了，就直接返回 return &#125; else &#123; if (有自定义的图片) &#123; 初始化带图片的 prev 的按钮以及 next 按钮 &#125; else if (有自定义的文字) &#123; 初始化带文字的 prev 按钮以及 next 按钮 &#125; else &#123; 初始化默认的 prev 按钮以及 next 按钮 &#125; &#125; if (textfield 实现了 keyboardAppearance 方法) &#123; 根据 keyboard 的模式设置 toolbar 的样式 &#125; if (shouldShowToolbarPlaceholder 属性为 YES) &#123; 将 textfield 的 placeholder 的样式复制给 toolbar 的 titleBarButton &#125; else &#123; 隐藏 toolbar 的 titleBarButton &#125; if (当前 textfield 是第一个) &#123; 设置 prev 按钮 enabled 为 NO &#125; else if (当前 textfield 是最后一个) &#123; 设置 next 按钮 enabled 为 NO &#125; else &#123; 设置 prev 和 next 按钮 enabled 为 YES &#125; // 最后通过设置好的 prev 和 next 和 placeholder 和 done 创建 IQToolbar。并将 toolbar 设置为 textfield 的 inputAccessview [textfield setInputAccessView: toolbar]; &#125;&#125; 代码很简单，就是很繁琐，伪代码都写了这么多。可以看到，IQKeyboardManager 很人性化的为 toobar 上左右的按钮都设置了自定义的图片和文字(虽然一般不会有人去改) 按钮点击事件完成按钮的点击事件可以理解为就是取消 textfield 的第一响应者。prev 按钮和 next 按钮实现上稍微复杂一点，但是思想上是非常简单的。以 prev 按钮为例： 123456-(void)previousAction:(IQBarButtonItem*)barButton &#123; if ([self canGoPrevious]) &#123; [self goPrevious]; &#125; ....省略以一部分 firstResponder 转移成功后自定义的处理逻辑(一般不会使用就省略不看了)&#125; 逻辑就是能跳到前面一个就跳到前面一个： 1234567891011121314151617181920212223242526272829303132-(BOOL)canGoPrevious &#123; // 获取当前视图的所有兄弟 textfield NSArray&lt;UIView*&gt; *textFields = [self responderViews] // 获取当前 textfield 在这些 textfield 的 index NSUInteger index = [textFields indexOfObject:_textFieldView]; // 如果 textfield 的 index 不是第一个 if (index != NSNotFound &amp;&amp; index &gt; 0) &#123; return YES; &#125; else &#123; return NO; &#125;&#125;-(BOOL)goPrevious &#123; // 获取当前视图的所有兄弟 textfield NSArray&lt;__kindof UIView*&gt; *textFields = [self responderViews]; // 获取当前 textfield 在这些 textfield 的 index NSUInteger index = [textFields indexOfObject:_textFieldView]; // 如果 textfield 的 index 不是第一个 if (index != NSNotFound &amp;&amp; index &gt; 0) &#123; UITextField *nextTextField = textFields[index-1]; UIView *textFieldRetain = _textFieldView; // 上一个 textfield 获取焦点 BOOL isAcceptAsFirstResponder = [nextTextField becomeFirstResponder]; if (isAcceptAsFirstResponder == NO) &#123; [textFieldRetain becomeFirstResponder]; &#125; return isAcceptAsFirstResponder; &#125; else &#123; return NO; &#125;&#125; 有没有很熟悉？和处理 return 键的逻辑类似。拿到所有兄弟 textfield，然后判断当前 textfield 是否是第一个。不是的话就让上一个获取焦点。 移除 IQToolbar说完了添加 IQToolbar，现在再来快速看一下如果 privateIsEnableAutoToolbar 为 NO 情况下移除 toolbar 1234567891011-(void)removeToolbarIfRequired &#123; NSArray&lt;UIView*&gt; *siblings = [self responderViews]; for (UITextField *textField in siblings) &#123; UIView *toolbar = [textField inputAccessoryView]; if ([textField respondsToSelector:@selector(setInputAccessoryView:)] &amp;&amp; ([toolbar isKindOfClass:[IQToolbar class]] &amp;&amp; (toolbar.tag == kIQDoneButtonToolbarTag || toolbar.tag == kIQPreviousNextButtonToolbarTag))) &#123; textField.inputAccessoryView = nil; [textField reloadInputViews]; &#125; &#125;&#125; 移除的方法更简单。直接找到所有兄弟 textfield，如果它们的 inputAccessoryView 是 IQToolbar 类型，那么就清空。 keyboardWillShow键盘弹出的通知中，就要调整视图偏移了。这个方法中保证了键盘弹出后，我们的键盘不会阻挡 UITextField 拿到键盘弹出的各种参数主要拿到键盘弹出的动画类型，动画时间以及键盘的大小 12345678910111213141516171819-(void)keyboardWillShow:(NSNotification*)aNotification&#123; _kbShowNotification = aNotification; // Getting keyboard animation. NSInteger curve = [[aNotification userInfo][UIKeyboardAnimationCurveUserInfoKey] integerValue]; _animationCurve = curve&lt;&lt;16; // Getting keyboard animation duration CGFloat duration = [[aNotification userInfo][UIKeyboardAnimationDurationUserInfoKey] floatValue]; //Saving animation duration if (duration != 0.0) _animationDuration = duration; // Getting UIKeyboardSize. _kbSize = [[aNotification userInfo][UIKeyboardFrameEndUserInfoKey] CGRectValue]; ...&#125; 这里我稍微修了下代码中的逻辑。因为原来的逻辑中针对多种情况以及 bug 增加了很多对我们了解主流程不必要的代码。 保存 frame 的位置在键盘弹出调整位置前，把 frame 的原始位置保存起来，这样就可以在键盘收起后，将 frame 移回原来的位置： 1_topViewBeginOrigin = rootController.view.frame.origin; 调整视图偏移随后来到调整偏移的方法 optimizedAdjustPosition 中，它在主线程中调用。因为届时将会对 UI 进行调整： 1234567-(void)optimizedAdjustPosition&#123; __weak typeof(self) weakSelf = self; // 添加到主线程中z异步执行 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; [self adjustPosition]; &#125;];&#125; 整个 adjustPosition 的方法非常长，还是以伪代码的方式了解一下过程： 12345678910111213141516171819202122- (void)adjustPosition &#123; // 实际的键盘大小 CGSize kbSize = keyboardWillShow 中拿到的键盘的大小 + textfield 距离键盘的高度 // 移动的距离 CGFloat move = MIN(textfield的y + textfield的高度 + 键盘的高度 + 底部因为tabbar或者 iphoneX 留下的间隙 - 屏幕的高度, textfield的y - 顶部navigationBar 的高度 - statusBar 的高度) // 找到能直接滚动的 UIScrollView UIScrollView *superView = (UIScrollView*)[textFieldView superviewOfClassType:[UIScrollView class]]; while (superView) &#123; superView 可滚动结束，不可滚动，继续往上找 &#125; // 省略 lastScrollView 相关内容，该内容用于修复相关 bug ... if (textfield 存在可以滚动的 scrollView，并且能够滚动的距离超过需要滚动的距离) &#123; 动画方式设置 contentOffset &#125; if (textfield 不存在于 scrollView 上，或者不能滚动) &#123; 动画设置 rootViewController 的 origin.y 向上移动。即整个 rootViewController 向上移动 &#125;&#125; move 的计算有讲究，移动的范围要既不能被 keyboard 挡住，又不能被顶出屏幕显示的范围。所以要比较底下需要往上顶的高度，以及最高能往上多少，取其中较小的。 关于设置 textfield 所在的 scrollView 的 contentOffset。如果你写过类似微信的聊天界面可能有出现过一个问题就是当输入弹出键盘的时候，navigationBar 也移动了上去。这是因为你要输入的瞬间，底部的输入框被 IQKeyboardManager 认为要向上移，但是底部的输入框没有可以滚动的 scrollView，因此就把 rootViewController 的 y 向上移动了，在我们看来就是整个界面都顶了上去。 keyboardWillHide在 keyboardWillHide 方法中进行扫尾工作，包括将 scrollView 滚回到原来的位置。 12345678- (void)keyboardWillHide:(NSNotification*)aNotification &#123; if (存在滚动的 scrollView) &#123; 动画方式将 scrollView 滚回原处 &#125; 动画方式将 rootViewController 滚回原处 将 show 时候设置的各种变量设置回原始值&#125; 实际上在结束输入的时候，还有其他的事件通知触发，同样也是进行一些扫尾工作，就不做更多的介绍了。 小技巧到最后了总结一下看 IQKeyboardManager 源码学到的一些技巧。 对一个数组排序：123456789101112131415161718[SomeViewArray sortedArrayUsingComparator:^NSComparisonResult(UIView *view1, UIView *view2) &#123; CGFloat x1 = CGRectGetMinX(view1.frame); CGFloat y1 = CGRectGetMinY(view1.frame); CGFloat x2 = CGRectGetMinX(view2.frame); CGFloat y2 = CGRectGetMinY(view2.frame); if (y1 &lt; y2) return NSOrderedAscending; else if (y1 &gt; y2) return NSOrderedDescending; //Else both y are same so checking for x positions else if (x1 &lt; x2) return NSOrderedAscending; else if (x1 &gt; x2) return NSOrderedDescending; else return NSOrderedSame;&#125;]; 通过响应链获得当前视图的 ViewController123456789101112131415-(UIViewController*)viewContainingController&#123; UIResponder *nextResponder = self; do &#123; nextResponder = [nextResponder nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) return (UIViewController*)nextResponder; &#125; while (nextResponder); return nil;&#125; 在 load 方法中异步执行初始化操作1234+(void)load&#123; [self performSelectorOnMainThread:@selector(sharedManager) withObject:nil waitUntilDone:NO];&#125; 计算方法的执行时间方法的执行时间可以通过分别获取方法开始执行和执行完毕的时间，然后相减： 12CFTimeInterval startTime = CACurrentMediaTime();CFTimeInterval elapsedTime = CACurrentMediaTime() - startTime; iOS 发出输入键盘的声音iOS 提供了一个方法提供播放键盘声音： 1[[UIDevice currentDevice] playInputClick] 比如通讯录选择了首字母可以使用这个方法播放声音。 设置随键盘弹出的视图在没看代码前，你可能会认为 IQKeyboardManager 是通过动画的方式将 IQToolbar 展示在 keyboard 上的。其实 iOS 提供了相关的属性。可以直接将自定义视图设置为 textfield 的 inputAccessoryView 就可以实现效果： 1[textfield setInputAccessView: yourView]; 总结看完了 IQKeyboardManager 源码，解决了我一直以来的疑惑。另外，IQKeyboardManager 不愧为一个经久不衰的第三方库。其中为了解决特定情况下的 bug，增加了很多解决 bug 的逻辑和变量，为阅读源码增加了许多难度。不过，这些针对 bug 的逻辑其实不是探寻原理的必要之路，没有必要把一整个工程的代码都理解透彻，跳过它们，可以更快速的定位到库的核心。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YYModel 源码解析]]></title>
    <url>%2F2019%2F04%2F09%2Fyymodel%2F</url>
    <content type="text"><![CDATA[YYModel 是一个高性能的 json model 解析库。 使用Model 与 JSON 转换12345678910111213141516171819202122// JSON:&#123; "uid":123456, "name":"Harry", "created":"1965-07-31T00:00:00+0000"&#125;// Model:@interface User : NSObject@property UInt64 uid;@property NSString *name;@property NSDate *created;@end@implementation User@end // 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:User *user = [User yy_modelWithJSON:json]; // 将 Model 转换为 JSON 对象:NSDictionary *json = [user yy_modelToJSONObject]; Model 属性名和 JSON 中 key 不相同 model 属性对应于 JSON 中较深的 keypath model 属性对应多个 JSON 中的 key 实现 JSON 转 Model 映射方法 modelCustomPropertyMapper 1234567891011121314151617181920212223242526// JSON:&#123; "n":"Harry Pottery", "p": 256, "ext" : &#123; "desc" : "A book written by J.K.Rowing." &#125;, "ID" : 100010&#125;// Model:@interface Book : NSObject@property NSString *name;@property NSInteger page;@property NSString *desc;@property NSString *bookID;@end@implementation Book//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"name" : @"n", @"page" : @"p", @"desc" : @"ext.desc", @"bookID" : @[@"id",@"ID",@"book_id"]&#125;;&#125;@end Model 中包含其他 Model直接使用自定义的类： 12345678910111213141516171819202122232425// JSON&#123; "author":&#123; "name":"J.K.Rowling", "birthday":"1965-07-31T00:00:00+0000" &#125;, "name":"Harry Potter", "pages":256&#125;// Model: 什么都不用做，转换会自动完成@interface Author : NSObject@property NSString *name;@property NSDate *birthday;@end@implementation Author@end @interface Book : NSObject@property NSString *name;@property NSUInteger pages;@property Author *author; //Book 包含 Author 属性@end@implementation Book@end 容器类属性数组和字典中存放的数据可以通过 modelContainerPropertyGenericClass 指定： 1234567891011121314151617@class Shadow, Border, Attachment;@interface Attributes@property NSString *name;@property NSArray *shadows; //Array&lt;Shadow&gt;@property NSSet *borders; //Set&lt;Border&gt;@property NSMutableDictionary *attachments; //Dict&lt;NSString,Attachment&gt;@end@implementation Attributes// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"shadows" : [Shadow class], @"borders" : Border.class, @"attachments" : @"Attachment" &#125;;&#125;@end JSON 转 Model 完成后的操作在 class 中实现相应方法，通过 dic 可以拿到 JSON 的字典，self 就是转换好的 Model： 1234- (id)modelCustomTransformFromDictionary:(NSDictionary *)dic &#123; // 操作 self return self&#125; 官方文档上没有提及这个方法，只是在我看源码的时候发现的。我觉得这个方法还是比较有用的，相当于在获取数据后在 Model 内执行类似于 watch 方法，可以把一些简单的数据处理放在 model 层。 额外功能：Coding/Copying/hash/equal/description 方法的实现1234567891011121314@interface YYShadow :NSObject &lt;NSCoding, NSCopying&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) CGSize size;@end@implementation YYShadow// 直接添加以下代码即可自动完成- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder]; &#125;- (id)copyWithZone:(NSZone *)zone &#123; return [self yy_modelCopy]; &#125;- (NSUInteger)hash &#123; return [self yy_modelHash]; &#125;- (BOOL)isEqual:(id)object &#123; return [self yy_modelIsEqual:object]; &#125;- (NSString *)description &#123; return [self yy_modelDescription]; &#125;@end 源码解析文件结构YYModel 的核心是以下两个文件： YYClassInfo 主要是对 OC 中成员变量、属性、方法和类的一层封装。将一些需要通过 Runtime 方法获取到的属性保存在对象中，有助于减少相关方法调用此时，提高效率。 NSObject+YYModel 提供了方法实现 model json 转换。 YYClassInfoYYClassInfo 中包含四个类，分别是对类及类中的成员标量、属性和方法的封装。 YYClassIvarInfoYYClassIvarInfo 的属性及初始化方法如下： 12345678910111213141516171819202122232425262728293031@interface YYClassIvarInfo : NSObject// 成员变量@property (nonatomic, assign, readonly) Ivar ivar;// 变量名称@property (nonatomic, strong, readonly) NSString *name;// 变量偏移量@property (nonatomic, assign, readonly) ptrdiff_t offset;// 变量类型编码@property (nonatomic, strong, readonly) NSString *typeEncoding;// 根据变量类型编码解析出来的相对应于自己的枚举@property (nonatomic, assign, readonly) YYEncodingType type;@end@implementation YYClassIvarInfo- (instancetype)initWithIvar:(Ivar)ivar &#123; if (!ivar) return nil; self = [super init]; _ivar = ivar; const char *name = ivar_getName(ivar); if (name) &#123; _name = [NSString stringWithUTF8String:name]; &#125; _offset = ivar_getOffset(ivar); const char *typeEncoding = ivar_getTypeEncoding(ivar); if (typeEncoding) &#123; _typeEncoding = [NSString stringWithUTF8String:typeEncoding]; _type = YYEncodingGetType(typeEncoding); &#125; return self;&#125;@end 可以看到初始化方法就是把 ivar 的几个成员变量通过 Runtime 方法取出来，赋值给 YYClassIvarInfo 的相应属性中。 YYClassMethodInfo123456789@interface YYClassMethodInfo : NSObject@property (nonatomic, assign, readonly) Method method;@property (nonatomic, strong, readonly) NSString *name;@property (nonatomic, assign, readonly) SEL sel;@property (nonatomic, assign, readonly) IMP imp;@property (nonatomic, strong, readonly) NSString *typeEncoding;@property (nonatomic, strong, readonly) NSString *returnTypeEncoding;@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *argumentTypeEncodings;@end 这里就不再列举它的初始化方法了，总之就是把方法的相关信息提取到对象中。 YYClassPropertyInfo属性中多了几个字段，包含属性的类，属性类遵守的协议以及属性的 get set 方法 12345678910@interface YYClassPropertyInfo : NSObject@property (nonatomic, assign, readonly) objc_property_t property;@property (nonatomic, strong, readonly) NSString *name;@property (nonatomic, assign, readonly) YYEncodingType type;@property (nonatomic, strong, readonly) NSString *typeEncoding;@property (nonatomic, strong, readonly) NSString *ivarName;@property (nullable, nonatomic, assign, readonly) Class cls;@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols;@property (nonatomic, assign, readonly) SEL getter;@property (nonatomic, assign, readonly) SEL setter; YYClassInfo1234567891011@interface YYClassInfo : NSObject@property (nonatomic, assign, readonly) Class cls;@property (nullable, nonatomic, assign, readonly) Class superCls;@property (nullable, nonatomic, assign, readonly) Class metaCls;@property (nonatomic, readonly) BOOL isMeta;@property (nonatomic, strong, readonly) NSString *name;@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo;@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos;@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos;@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos;@end 类封装中属性多了一些，包含了父类的 YYClassInfo 对象，以及属性、方法及成员变量的数组。 当然 YYClassInfo 中还有一些其他的细节，不是很重要就不在这里详述了。只要知道以上四个封装类即可。 NSObject+YYModel这个文件中实现了 Model和 JSON 的相互转换。不过这里先不直接开始转换方法的分析，而是先从与其相关的两个类 _YYModelPropertyMeta 以及 _YYModelMeta 开始。 _YYModelPropertyMeta_YYModelPropertyMeta 是 YYClassPropertyInfo 的再上一层的封装。如果说 YYClassPropertyInfo 只是 property_t 的简单封装，那么 _YYModelPropertyMeta 就包含了 JSON 转 Model 所需的一些自定义配置。 12345678910111213141516171819202122232425@interface _YYModelPropertyMeta : NSObject &#123; @package NSString *_name; YYEncodingType _type; YYEncodingNSType _nsType; YYClassPropertyInfo *_info; BOOL _isCNumber; Class _cls; SEL _getter; SEL _setter; BOOL _isKVCCompatible; BOOL _isStructAvailableForKeyedArchiver; // 属性是否有自定义的类型。一般情况下不会出现要自定义类型的情况，因为这样的方式自定义类型不如直接创建新的类型直接。文档上也没有相关说明。因此后面这部分相关的代码直接略过。 BOOL _hasCustomClassFromDictionary; // 一般用于字典数组等容器类中。表示容器的泛型类型 Class _genericCls; // 当前属性对应于 JSON 中的 key 或者 keyPath NSString *_mappedToKey; NSArray *_mappedToKeyPath; NSArray *_mappedToKeyArray; // 如果 JSON 中一个 key 对应于 model 多个键的情况下，通过这个指针保存 _YYModelPropertyMeta *_next;&#125;@end _YYModelMeta_YYModelMeta 的属性_YYModelMeta 是 YYClassInfo 的上层封装。属性如下： 123456789101112131415161718192021@interface _YYModelMeta : NSObject &#123; @package YYClassInfo *_classInfo; // 键是属性名，值是属性的一个封装 YYModelPropertyMeta NSDictionary *_mapper; // 所有的 YYModelPropertyMeta 的集合 NSArray *_allPropertyMetas; // 如果 class 实现了 modelCustomPropertyMapper 方法，其中有 JSON 的 keypaths 对应于一个 model 的键的情况，那么会被加入到这个数组中 NSArray *_keyPathPropertyMetas; // 如果 class 实现了 modelCustomPropertyMapper 方法，其中可能 JSON 中多个字段对应于一个 model 的键的情况，那么就会加入到这个数组中 NSArray *_multiKeysPropertyMetas; NSUInteger _keyMappedCount; YYEncodingNSType _nsType; // 如果实现了相应的方法，则在 JSON 转换 Model 后可以做一些自定义的操作 BOOL _hasCustomWillTransformFromDictionary; BOOL _hasCustomTransformFromDictionary; BOOL _hasCustomTransformToDictionary; BOOL _hasCustomClassFromDictionary;&#125;@end 获取 _YYModelMeta 的方法通过下面的方法获取 _YYModelMeta。_YYModelMeta 是类级的对象，一个类型可以共享一个实例。因此，_YYModelMeta 实例被保存在一个单例的 cache 字典中，只有该类型未被初始化的时候才会通过 initWithClass 方法创建： 12345678910111213141516171819202122232425+ (instancetype)metaWithClass:(Class)cls &#123; if (!cls) return nil; static CFMutableDictionaryRef cache; static dispatch_once_t onceToken; static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; // _YYModelMeta 的缓存字典 cache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); lock = dispatch_semaphore_create(1); &#125;); dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); // 通过外部传进来的 class 来获取相应的 _YYModelMeta 实例。 _YYModelMeta *meta = CFDictionaryGetValue(cache, (__bridge const void *)(cls)); dispatch_semaphore_signal(lock); if (!meta || meta-&gt;_classInfo.needUpdate) &#123; // meta = [[_YYModelMeta alloc] initWithClass:cls]; if (meta) &#123; dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); CFDictionarySetValue(cache, (__bridge const void *)(cls), (__bridge const void *)(meta)); dispatch_semaphore_signal(lock); &#125; &#125; return meta;&#125; 创建 _YYModelMeta_YYModelMeta 的初始化方法比较长，这里截取一段段代码分别分析。 容器类型的设置 1234567891011121314151617181920212223// 将 modelContainerPropertyGenericClass 方法返回的泛型NSDictionary *genericMapper = nil;if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123; genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass]; if (genericMapper) &#123; NSMutableDictionary *tmp = [NSMutableDictionary new]; [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (![key isKindOfClass:[NSString class]]) return; Class meta = object_getClass(obj); if (!meta) return; if (class_isMetaClass(meta)) &#123; tmp[key] = obj; &#125; else if ([obj isKindOfClass:[NSString class]]) &#123; // 如果是字符串类型，那么转为 class 类型 Class cls = NSClassFromString(obj); if (cls) &#123; tmp[key] = cls; &#125; &#125; &#125;]; genericMapper = tmp; &#125;&#125; 这个方法用来处理容器类属性。当 Model 实现了 modelContainerPropertyGenericClass 方法的时候(如果不知道，可以看上面的使用介绍)，就将结果暂时保存在 genericMapper 中，待到后面实例化 _YYModelPropertyMeta 对象的时候设置到 class genericCls 中。 Model 对应 JSON keyPaths 的设置 相关实现是通过在 Model 中实现 modelCustomPropertyMapper 实现的。如果 modelCustomPropertyMapper 返回的字典中值是一个带有 . 的字符串，那么就说明 Model 对应 JSON 中的 keyPaths： 123456789101112131415161718192021222324252627282930313233343536373839// 在 model 中实现了 modelCustomPropertyMapper 的情况if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123; NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper]; [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123; // 从 allPropertyMetas 中找到方法返回值相关的属性 _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName]; if (!propertyMeta) return; // 由于要自定义设置，所以先删除这个属性相关的 _YYModelPropertyMeta 实例 [allPropertyMetas removeObjectForKey:propertyName]; // 如果是字符串就表示是要将 JSON 中的 keypath 映射到 Modal 中 if ([mappedToKey isKindOfClass:[NSString class]]) &#123; if (mappedToKey.length == 0) return; propertyMeta-&gt;_mappedToKey = mappedToKey; // 以 '.' 作为分割取出数组 NSArray *keyPath = [mappedToKey componentsSeparatedByString:@"."]; for (NSString *onePath in keyPath) &#123; if (onePath.length == 0) &#123; NSMutableArray *tmp = keyPath.mutableCopy; [tmp removeObject:@""]; keyPath = tmp; break; &#125; &#125; if (keyPath.count &gt; 1) &#123; // 将 keyPath 赋值给 _YYModelPropertyMeta 的 _mappedToKeyPath 属性 propertyMeta-&gt;_mappedToKeyPath = keyPath; [keyPathPropertyMetas addObject:propertyMeta]; &#125; // 如果 mapper 中已经存在该 mappedToKey 这个键值对，那么说明 mappedToKey 这个 keypath 将对应多个 model 中的键。通过 _next 标识(写的比较拗口，如果不明白也没关系，这个不是重点) propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; &#125;&#125;// 保存到 _YYModelMeta 的 _keyPathPropertyMetas 中if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas; Model 对应 JSON 中多个可能的字段的设置 还是 modelCustomPropertyMapper 中实现的。如果返回的字典中的值是一个数组，那么说明 Model 中的属性可能对应 JSON 中多个可能的字段： 1234567891011121314151617181920212223242526272829303132333435363738394041if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123; NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper]; [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123; _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName]; if (!propertyMeta) return; [allPropertyMetas removeObjectForKey:propertyName]; // 判断 modelCustomPropertyMapper 返回的字典中的每一个值是不是一个数组 if ([mappedToKey isKindOfClass:[NSArray class]]) &#123; NSMutableArray *mappedToKeyArray = [NSMutableArray new]; // 如果是数组，遍历数组中的每一项 for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123; if (![oneKey isKindOfClass:[NSString class]]) continue; if (oneKey.length == 0) continue; // 如果其中包含 '.'，那么和之前一样，表明 Model 中的这个键对应于 JSON 中的 keyPaths NSArray *keyPath = [oneKey componentsSeparatedByString:@"."]; if (keyPath.count &gt; 1) &#123; [mappedToKeyArray addObject:keyPath]; &#125; else &#123; [mappedToKeyArray addObject:oneKey]; &#125; if (!propertyMeta-&gt;_mappedToKey) &#123; propertyMeta-&gt;_mappedToKey = oneKey; propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil; &#125; &#125; if (!propertyMeta-&gt;_mappedToKey) return; propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; // NSArray 中解析好的每一项添加到 mutiKeysPropertyMetas 中 [multiKeysPropertyMetas addObject:propertyMeta]; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; &#125; &#125;];&#125;// 保存到 _YYModelMeta 中的 _multiKeysPropertyMetas 中if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas; JSON → Model 的实现外部调用方法上面把用到的数据结构都介绍了一遍，现在开始正真的 JSON → Model 的转换。这里省略了 JSON → NSDictionary 的转换(通过 NSJSONSerialization 实现)。直接看 NSDictionary → Model 的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123; if (!dictionary || dictionary == (id)kCFNull) return nil; if (![dictionary isKindOfClass:[NSDictionary class]]) return nil; Class cls = [self class]; // 创建一个实例 one，然后通过 yy_modelSetWithDictionary 方法真正的将字典中的键值对填充到对象中 NSObject *one = [cls new]; if ([one yy_modelSetWithDictionary:dictionary]) return one; return nil;&#125;- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123; ... _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)]; // 上下文对象，将 Model 和 Dictionary 都保存在这个对象中，这样处理方法就可以直接通过这个 context 拿到 Model 和 Dictionary ModelSetContext context = &#123;0&#125;; context.modelMeta = (__bridge void *)(modelMeta); context.model = (__bridge void *)(self); context.dictionary = (__bridge void *)(dic); // 一般情况下，Model 中的属性和字典中的字段是一一对应的，但是如果 Model 中的属性多余字典中的字段，那么说明 Model 中的属性可能映射了字典中某个值中的某个字段，即对应的是一个 keyPaths if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123; // Dictionary 转 Model。CFDictionaryApplyFunction 就是对 Dictionary 中的每个键都执行传入的方法 CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context); // 如果 Model 可能存在 keypaths 的映射，那么执行，将 keypaths 对应的值 if (modelMeta-&gt;_keyPathPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; if (modelMeta-&gt;_multiKeysPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; &#125; else &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas, CFRangeMake(0, modelMeta-&gt;_keyMappedCount), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; /// JSON 转 model 转换完成后，自定义的转换部分 if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123; return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic]; &#125; return YES;&#125; 可以看到，上面的设置过程主要涉及了两个方法。其中第一个是 JSON 转 Modal 的核心： ModelSetWithDictionaryFunction ModelSetWithPropertyMetaArrayFunction ModelSetWithDictionaryFunction这个方法传入的三个参数分别为，JSON 转成的 Dictionary 的每个键值对和传入的上下文。 1234567891011121314151617static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123; ModelSetContext *context = _context; // 通过上下文拿到 Class 的封装 _YYModelMeta __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta); // 从 _YYModelMeta 中取出 key 对应的 _YYModelPropertyMeta __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)]; // 从上下文中拿到 model 实例 __unsafe_unretained id model = (__bridge id)(context-&gt;model); /// 看看 key 对应的属性有没有 setter 方法，如果没有，那么就通过 next 找 while (propertyMeta) &#123; if (propertyMeta-&gt;_setter) &#123; // 核心方法，将 value 设置到 model 中 ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta); &#125; propertyMeta = propertyMeta-&gt;_next; &#125;;&#125; 最核心的方法就是 ModelSetValueForProperty，真正将值赋值给 model 就是在这个方法中。它的处理代码非常长，因为针对不同类型的属性要做不同的处理。一般情况下，可以将处理代码分为三类： c 中的数字类型。如 int 等 oc 中的对象类型。如 NSString，NSNumber 等 除以上两种的其他类型。如 block 类型，SEL 类型 C 类型设置C 类型值设置方法如下： 123456if (meta-&gt;_isCNumber) &#123; // 把 Value 转为 NSNumber 类型 NSNumber *num = YYNSNumberCreateFromID(value); ModelSetNumberToProperty(model, num, meta); if (num != nil) [num class]; // hold the number&#125; 先把 Value 转为 NSNumber 类型，然后调用 ModelSetNumberToProperty 方法。摘取一部分代码如下： 1234567891011static force_inline void ModelSetNumberToProperty(__unsafe_unretained id model, __unsafe_unretained NSNumber *num, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; case YYEncodingTypeBool: &#123; ((void (*)(id, SEL, bool))(void *) objc_msgSend)((id)model, meta-&gt;_setter, num.boolValue); &#125; break; ... default: break; &#125;&#125; 可以看到，最终是直接调用了 objc_msgSend 执行 model 相应属性的 setter 方法。 OC 类型设置12345678910111213141516171819202122232425262728293031323334353637383940if (meta-&gt;_nsType) &#123; if (value == (id)kCFNull) &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)nil); &#125; else &#123; switch (meta-&gt;_nsType) &#123; case YYEncodingTypeNSString: case YYEncodingTypeNSMutableString: &#123; if ([value isKindOfClass:[NSString class]]) &#123; if (meta-&gt;_nsType == YYEncodingTypeNSString) &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, value); &#125; else &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, ((NSString *)value).mutableCopy); &#125; &#125; else if ([value isKindOfClass:[NSNumber class]]) &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (meta-&gt;_nsType == YYEncodingTypeNSString) ? ((NSNumber *)value).stringValue : ((NSNumber *)value).stringValue.mutableCopy); &#125; else if ([value isKindOfClass:[NSData class]]) &#123; NSMutableString *string = [[NSMutableString alloc] initWithData:value encoding:NSUTF8StringEncoding]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, string); &#125; else if ([value isKindOfClass:[NSURL class]]) &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (meta-&gt;_nsType == YYEncodingTypeNSString) ? ((NSURL *)value).absoluteString : ((NSURL *)value).absoluteString.mutableCopy); &#125; else if ([value isKindOfClass:[NSAttributedString class]]) &#123; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (meta-&gt;_nsType == YYEncodingTypeNSString) ? ((NSAttributedString *)value).string : ((NSAttributedString *)value).string.mutableCopy); &#125; &#125; break; ... &#125; &#125;&#125; 这里截取的代码有点长。不过已经是精简了很多的状态了。总体而言还是判断属性的类型，然后调用相应的 objc_msgSend 方法。 Model → JSONObject 的实现Model 到 JSONObject 的转换也就是 Model 到数组或者字典这种模型的转换，核心方法在递归方法 ModelToJSONObjectRecursive 。 12345678- (id)yy_modelToJSONObject &#123; // 递归转换模型到 JSON id jsonObject = ModelToJSONObjectRecursive(self); if ([jsonObject isKindOfClass:[NSArray class]]) return jsonObject; if ([jsonObject isKindOfClass:[NSDictionary class]]) return jsonObject; return nil;&#125; 具体的转换代码非常长。做了注释后还是贴上来了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// 递归转换模型到 JSON，如果转换异常则返回 nilstatic id ModelToJSONObjectRecursive(NSObject *model) &#123; // 判空或者可以直接返回的对象，则直接返回 if (!model || model == (id)kCFNull) return model; if ([model isKindOfClass:[NSString class]]) return model; if ([model isKindOfClass:[NSNumber class]]) return model; // 如果 model 从属于 NSDictionary if ([model isKindOfClass:[NSDictionary class]]) &#123; // 如果可以直接转换为 JSON 数据，则返回 if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableDictionary *newDic = [NSMutableDictionary new]; // 遍历 model 的 key 和 value [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123; NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description; if (!stringKey) return; // 递归解析 value id jsonObj = ModelToJSONObjectRecursive(obj); if (!jsonObj) jsonObj = (id)kCFNull; newDic[stringKey] = jsonObj; &#125;]; return newDic; &#125; // 如果 model 从属于 NSSet if ([model isKindOfClass:[NSSet class]]) &#123; // 如果能够直接转换 JSON 对象，则直接返回 // 否则遍历，按需要递归解析 ... &#125; if ([model isKindOfClass:[NSArray class]]) &#123; // 如果能够直接转换 JSON 对象，则直接返回 // 否则遍历，按需要递归解析 ... &#125; // 对 NSURL, NSAttributedString, NSDate, NSData 做相应处理 if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString; if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string; if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter() stringFromDate:(id)model]; if ([model isKindOfClass:[NSData class]]) return nil; // 用 [model class] 初始化一个模型元 _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]]; // 如果映射表为空，则不做解析直接返回 nil if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil; // 性能优化细节，使用 __unsafe_unretained 来避免在下面遍历 block 中直接使用 result 指针造成的不必要 retain 与 release 开销 NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64]; __unsafe_unretained NSMutableDictionary *dic = result; // 遍历模型元属性映射字典 [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123; // 如果遍历当前属性元没有 getter 方法，跳过 if (!propertyMeta-&gt;_getter) return; id value = nil; // 如果属性元属于 CNumber，即其 type 是 int、float、double 之类的 if (propertyMeta-&gt;_isCNumber) &#123; // 从属性中利用 getter 方法得到对应的值 value = ModelCreateNumberFromProperty(model, propertyMeta); &#125; else if (propertyMeta-&gt;_nsType) &#123; // 属性元属于 nsType，即 NSString 之类 // 利用 getter 方法拿到 value id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); // 对拿到的 value 递归解析 value = ModelToJSONObjectRecursive(v); &#125; else &#123; // 根据属性元的 type 做相应处理 switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123; // id，需要递归解析，如果解析失败则返回 nil case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); if (value == (id)kCFNull) value = nil; &#125; break; // Class，转 NSString，返回 Class 名称 case YYEncodingTypeClass: &#123; Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromClass(v) : nil; &#125; break; // SEL，转 NSString，返回给定 SEL 的字符串表现形式 case YYEncodingTypeSEL: &#123; SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromSelector(v) : nil; &#125; break; default: break; &#125; &#125; // 如果 value 还是没能解析，则跳过 if (!value) return; // 当前属性元是 KeyPath 映射，即 a.b.c 之类 if (propertyMeta-&gt;_mappedToKeyPath) &#123; NSMutableDictionary *superDic = dic; NSMutableDictionary *subDic = nil; // _mappedToKeyPath 是 a.b.c 根据 '.' 拆分成的字符串数组，遍历 _mappedToKeyPath for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123; NSString *key = propertyMeta-&gt;_mappedToKeyPath[i]; // 遍历到结尾 if (i + 1 == max) &#123; // 如果结尾的 key 为 nil，则使用 value 赋值 if (!superDic[key]) superDic[key] = value; break; &#125; // 用 subDic 拿到当前 key 对应的值 subDic = superDic[key]; // 如果 subDic 存在 if (subDic) &#123; // 如果 subDic 从属于 NSDictionary if ([subDic isKindOfClass:[NSDictionary class]]) &#123; // 将 subDic 的 mutable 版本赋值给 superDic[key] subDic = subDic.mutableCopy; superDic[key] = subDic; &#125; else &#123; break; &#125; &#125; else &#123; // 将 NSMutableDictionary 赋值给 superDic[key] // 注意这里使用 subDic 间接赋值是有原因的，原因就在下面 subDic = [NSMutableDictionary new]; superDic[key] = subDic; &#125; // superDic 指向 subDic，这样在遍历 _mappedToKeyPath 时即可逐层解析 // 这就是上面先把 subDic 转为 NSMutableDictionary 的原因 superDic = subDic; subDic = nil; &#125; &#125; else &#123; // 如果不是 KeyPath 则检测 dic[propertyMeta-&gt;_mappedToKey]，如果为 nil 则赋值 value if (!dic[propertyMeta-&gt;_mappedToKey]) &#123; dic[propertyMeta-&gt;_mappedToKey] = value; &#125; &#125; &#125;]; // 忽略，对应 modelCustomTransformToDictionary 接口 if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123; // 用于在默认的 Model 转 JSON 过程不适合当前 Model 类型时提供自定义额外过程 // 也可以用这个方法来验证转换结果 BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic]; if (!suc) return nil; &#125; return result;&#125; 总的来说，还是判断传入的 Model 的类型，如果是 NSString 这种基本类型，那么就直接返回了。如果是 class 类型，那么就生成 class 对应的 _YYModelMeta 对象，然后遍历其中的所有属性，将其赋值给 result 这个字典中。 一些点设值一般情况下，我们都会认为字典模型转换都是使用 KVC 的方式。然鹅 YYModel 并不是使用 KVC，而是通过 objc_msgSend 调用 Model 中 property 的 setter 方法。这样速度上更快。 内存优化__unsafe_unretained 在作用上和 __weak 类似，但是 __unsafe_unretained 会更易造成野指针。 访问具有 __weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以如果你能确定在该变量的使用过程中，不会被回收，就可以使用 __unsafe_unretained 替代 __weak 。 使用 c 函数YYModel 中使用了大量的 c 函数。使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。 使用内联函数内联函数用 inline 标记。编译时，类似宏替换，使用函数体替换调用处的函数名。 优势是内联减少了函数调用的开销，在调用时不发生控制转移。劣势是如果调用次数很多时，一般会增加了代码量。 内联函数和宏定义相比差别在于： 编译阶段：宏定义使用预处理器preprocessor实现，只是预处理符号表的简单替换。内联函数则在编译阶段进行替换，会有类型检查和参数有效性的检测。 安全性：内联函数具有类型检查与参数有效性的验证，而宏没有； 总结总的来说，YYModel 为了效率使用了很多 c 函数，其实在日常的编程中是不太能用到的(或者说，你要这么写是会被骂的)，但正是这些更底层不常用的函数使 YYModel 成为了一个高效的 JSON Model 转换库。 参考揭秘 YYModel 的魔法 解码YYModel（一）基础 YYModel]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YYAsyncLayer 源码解析]]></title>
    <url>%2F2019%2F02%2F15%2Fyyasynclayer%2F</url>
    <content type="text"><![CDATA[这篇是继 YYCache 后的 YYKit 源码解析。YYAsyncLayer 又是一个短小却质量奇高的轮子。非常适合学习和借鉴。 使用YYAsyncLayer 可以提供一个绘制自定义 CALayer 的自定义 UIView 组件。使用方式在其 Github上有完整的体现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface YYLabel : UIView@property NSString *text;@property UIFont *font;@end@implementation YYLabel- (void)setText:(NSString *)text &#123; _text = text.copy; [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];&#125;- (void)setFont:(UIFont *)font &#123; _font = font; [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];&#125;- (void)contentsNeedUpdated &#123; // do update [self.layer setNeedsDisplay];&#125;#pragma mark - YYAsyncLayer+ (Class)layerClass &#123; return YYAsyncLayer.class;&#125;- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123; // capture current state to display task NSString *text = _text; UIFont *font = _font; YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new]; task.willDisplay = ^(CALayer *layer) &#123; //... &#125;; task.display = ^(CGContextRef context, CGSize size, BOOL(^isCancelled)(void)) &#123; if (isCancelled()) return; NSArray *lines = CreateCTLines(text, font, size.width); if (isCancelled()) return; for (int i = 0; i &lt; lines.count; i++) &#123; CTLineRef line = line[i]; CGContextSetTextPosition(context, 0, i * font.pointSize * 1.5); CTLineDraw(line, context); if (isCancelled()) return; &#125; &#125;; task.didDisplay = ^(CALayer *layer, BOOL finished) &#123; if (finished) &#123; // finished &#125; else &#123; // cancelled &#125; &#125;; return task;&#125;@end 总的来说需要以下几点： 自定义的 UIView 实现 YYAsyncLayerDelegate 协议。 重写自定义 UIView 会引起视图更新的方法，在其中手动调用 YYTransaction 的方法，手动设置 layer setNeedsDisplay。 重写 UIView 的 layerClass 方法，返回 YYAsyncLayer 类型。 实现 YYAsyncLayerDelegate 协议 require 的方法 newAsyncDisplayTask，在其中创建一个 YYAsyncLayerDisplayTask 实例。提供三个 block：willDisplay，display，didDisplay。在 display 中通过 Core Graphic 绘图。 如何实现界面流畅为何产生卡顿计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。 因此，要解决卡顿问题，就要从 CPU 和 GPU 两个角度完成。 CPU 资源消耗原因对象的创建与销毁对象的创建于销毁会消耗 CPU 资源。我们可以： 推迟创建，以及异步创建和销毁对象 复用对象 使用 CALayer 代替 UIView 关于对象的异步销毁，ibireme 提供了一种方式，把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁： 12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 布局计算与 AutoLayout频繁的手动布局计算也会占用 CPU 的资源。因此，比如 tableview，就鼓励缓存 cell 的高度。 AutoLayout 在 iOS12 前效率比较低，不过在 iOS 12后已经进行了算法的优化，和直接设置 frame 差距不大。 文本渲染常用控件的文本渲染都是通过 CoreText 在主线程绘制 Bitmap 进行的。因此， 可以通过自定义控件，使用 TextKit 或者 CoreText 异步渲染 图片解码图片在提交到 GPU 之前才会被解码，并且是主线程中。因此，可以后台线程把图片绘制到 CGBitmapContext 中，然后通过 Bitmap 创建图片。 图像的绘制由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。 1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 有一篇 《内存恶鬼drawRect》 的文章，讲述了 drawRect 会在重复创建 Bitmap 并且没有及时释放的时候会消耗大量的内存。 不过这是针对大范围的绘图的情况，通过 CAShapLayer 矢量图的方式而不是 Bitmap 有助于缓解内存压力 GPU 资源消耗原因视图混合多个视图重叠在一起的时候需要 GPU 把他们混合在一起。可以适当减少视图数量以及层级。并且避免使用存在透明度的视图。同时可以预先将多个视图渲染为一个图片显示。 图像的合成避免离屏渲染 实现结构YYAsyncLayer 的结构非常简单。只有三个类文件： YYAsyncLayer YYSentinel YYTransaction YYAsyncLayer 继承于 CALayer，在内部重写了 display 方法，用来异步绘制。 YYSentinel 是一个自增的计数类。每次即将渲染的时候都会递增，并记录下来。当开始异步渲染的时候判断是否变化，来决定是否取消上次的渲染。 YYTransaction 给主线程 runloop 添加 observer 回调。用于在 runloop 空闲的时候进行渲染。 YYTransaction创建我们来看它的创建方法： 12345678/// 创建 YYTransaction 实例，需要传入 target 和 selector+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector&#123; if (!target || !selector) return nil; YYTransaction *t = [YYTransaction new]; t.target = target; t.selector = selector; return t;&#125; 创建方法很普通，在生成的 YYTransaction 实例中存入 target 和 selector，也就是之后要执行的对象和方法。 提交提交方法中添加了主线程 runloop 的 kCFRunLoopBeforeWaiting | kCFRunLoopExit 时刻的监听： 1234567891011121314151617181920212223242526272829303132333435363738- (void)commit &#123; if (!_target || !_selector) return; /// YYTransactionSetup(); /// 将 YYTransaction 实例保存到 Set 中 [transactionSet addObject:self];&#125;/// 在主线程 waiting 或者 exit 的时候，执行 transactionSet 中的方法static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; if (transactionSet.count == 0) return; NSSet *currentSet = transactionSet; transactionSet = [NSMutableSet new]; [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [transaction.target performSelector:transaction.selector];#pragma clang diagnostic pop &#125;];&#125;/// 添加 observer 监听主线程 runloop 进入 waiting 和 exitstatic void YYTransactionSetup() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; transactionSet = [NSMutableSet new]; CFRunLoopRef runloop = CFRunLoopGetMain(); CFRunLoopObserverRef observer; observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit, true, // repeat 0xFFFFFF, // after CATransaction(2000000) YYRunLoopObserverCallBack, NULL); CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes); CFRelease(observer); &#125;);&#125; 创建一个 Set，保存所有要执行的方法，然后将任务添加到主线程的 runloop 空闲时候执行。这是一个非常好的优化思想。非常值得学习。 YYSentinel这是一个自增的计数器。通过 OSAtomicIncrement32 方法实现递增： 1234567891011121314@implementation YYSentinel &#123; int32_t _value;&#125;- (int32_t)value &#123; return _value;&#125;/// 自动累加- (int32_t)increase &#123; return OSAtomicIncrement32(&amp;_value);&#125;@end OSAtomicIncrement32()是原子自增方法，线程安全。在日常开发中，若需要保证整形数值变量的线程安全，可以使用 OSAtomic 框架下的方法，它往往性能比使用各种“锁”更为优越，并且代码优雅。 YYAsyncLayer初始化YYAsyncLayer 继承于 CALayer。前面在设置 UIView 子类的时候需要设置 layerClass 方法返回 YYAsyncLayer.class 就是为了在创建 UIView 的时候，使用 YYAsyncLayer 作为其 CALayer。创建的时候会调用 YYAsyncLayer 的初始化方法： 123456789101112131415- (instancetype)init &#123; self = [super init]; static CGFloat scale; //global static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; /// 物理像素 / 逻辑像素 scale = [UIScreen mainScreen].scale; &#125;); /// UIView 和 UIImageView 默认处理了内部 CALayer 的 contentsScale。如果是直接使用 CALayer 及其衍生类，就需要显示的配置 contentScale self.contentsScale = scale; _sentinel = [YYSentinel new]; /// 异步加载的标识 _displaysAsynchronously = YES; return self;&#125; 它会根据屏幕的像素比设置 contentsScale。 渲染方法UIView 是持有 CALayer，并且作为 CALayer 的 delegate 的存在。当 UIView 即将渲染的时候，会调用 CALayer 的 display 方法。代码比较长，不过已经做了详尽的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/// CALayer 的显示方法- (void)display &#123; super.contents = super.contents; [self _displayAsync:_displaysAsynchronously];&#125;#pragma mark - Private- (void)_displayAsync:(BOOL)async &#123; /// CALayer 的 delegate 一般是 UIView 及其子类 /// 自己创建的 UIView 需要实现 YYAsyncLayerDelegate 协议 __strong id&lt;YYAsyncLayerDelegate&gt; delegate = (id)self.delegate; /// 获取绘制任务管理类。这个管理类由 CALayer 的 delegate 提供，需要设置 willDIsplay，display，didDisplay 这几个回调 YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask]; /// 如果没有 display 方法，那么把 contents 设置为 nil if (!task.display) &#123; if (task.willDisplay) task.willDisplay(self); self.contents = nil; if (task.didDisplay) task.didDisplay(self, YES); return; &#125; /// 是否是异步渲染 if (async) &#123; if (task.willDisplay) task.willDisplay(self); YYSentinel *sentinel = _sentinel; int32_t value = sentinel.value; BOOL (^isCancelled)(void) = ^BOOL() &#123; return value != sentinel.value; &#125;; CGSize size = self.bounds.size; BOOL opaque = self.opaque; CGFloat scale = self.contentsScale; CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL; /// 如果宽高等于0，那么释放 CALayer 的 contents if (size.width &lt; 1 || size.height &lt; 1) &#123; CGImageRef image = (__bridge_retained CGImageRef)(self.contents); self.contents = nil; if (image) &#123; dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123; CFRelease(image); &#125;); &#125; if (task.didDisplay) task.didDisplay(self, YES); CGColorRelease(backgroundColor); return; &#125; /// 异步执行绘制，根据当前的自增值，获取串行队列 dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123; /// 异步执行的时候，保存一个自增的值。如果异步执行的时候发现自增的值变化了，那么就说明之前的渲染已经被取消了 /// 这个时候释放 backgroundColor 返回 if (isCancelled()) &#123; CGColorRelease(backgroundColor); return; &#125; /// 绘制 UIGraphicsBeginImageContextWithOptions(size, opaque, scale); CGContextRef context = UIGraphicsGetCurrentContext(); // 处理有透明度的情况 if (opaque) &#123; CGContextSaveGState(context); &#123; if (!backgroundColor || CGColorGetAlpha(backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; if (backgroundColor) &#123; CGContextSetFillColorWithColor(context, backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); CGColorRelease(backgroundColor); &#125; // 执行 UIView 中提供的 block task.display(context, size, isCancelled); /// 如果渲染完成后发现取消了。那么直接 return if (isCancelled()) &#123; UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; /// 渲染完成，拿出渲染的视图 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); /// 如果获取完 image 后返现取消了，那么直接 return if (isCancelled()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; /// 到主线程中设置 contents dispatch_async(dispatch_get_main_queue(), ^&#123; /// 发现到主线程中的时候取消了，那么直接 return if (isCancelled()) &#123; if (task.didDisplay) task.didDisplay(self, NO); &#125; else &#123; /// 没有取消设置 CALayer 的 contents self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125; &#125;); &#125;); &#125; else &#123; /// 同步执行直接自增 [_sentinel increase]; /// 之后就是正常的渲染逻辑 if (task.willDisplay) task.willDisplay(self); UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale); CGContextRef context = UIGraphicsGetCurrentContext(); if (self.opaque) &#123; CGSize size = self.bounds.size; size.width *= self.contentsScale; size.height *= self.contentsScale; CGContextSaveGState(context); &#123; if (!self.backgroundColor || CGColorGetAlpha(self.backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; if (self.backgroundColor) &#123; CGContextSetFillColorWithColor(context, self.backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); &#125; task.display(context, self.bounds.size, ^&#123;return NO;&#125;); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125;&#125; 主要做了以下几点： 取出自定义 UIView 中实现的 newAsyncDisplayTask 方法返回的实例。从中取出 display 以及前后的回调。 判断要渲染的宽或者高为 0，那么直接清空 contents 如果是异步，那么创建异步队列，并通过 CoreGraphic 渲染。 如果是同步，直接同步渲染。 可以看到这里作者使用了大量的 if (isCancelled()) {...} 判断，只要失败，立刻返回。这样能够尽可能多的节省 CPU 资源。 来看一下 isCancelled 这个 block 的实现方式： 123BOOL (^isCancelled)(void) = ^BOOL() &#123; return value != sentinel.value;&#125;; 通过 block 捕获当前渲染周期内的变量值。其他线程改变了全局变量_sentinel的值也不会影响当前的value。若当前value不等于最新的_sentinel .value时，说明绘制任务已经更新，当前绘制任务已经被放弃，就需要及时的做返回逻辑。 那么什么时候这个计数会改变呢？在提交重绘的时候。 1234567- (void)setNeedsDisplay &#123; [self _cancelAsyncDisplay]; [super setNeedsDisplay];&#125;- (void)_cancelAsyncDisplay &#123; [_sentinel increase];&#125; 异步线程的管理每次异步渲染获取的队列并不是一个并行队列。而是多个串行队列： 12345678910111213141516171819202122232425262728293031323334static dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;/// 如果使用了 YYDispatchQueuePool，用 YYDispatchQueuePool#ifdef YYDispatchQueuePool_h return YYDispatchQueueGetForQOS(NSQualityOfServiceUserInitiated);#else#define MAX_QUEUE_COUNT 16 static int queueCount; static dispatch_queue_t queues[MAX_QUEUE_COUNT]; static dispatch_once_t onceToken; static int32_t counter = 0; dispatch_once(&amp;onceToken, ^&#123; /// 串行队列数量和处理器数量相同 queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount; queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount; /// 循环创建串行队列，bing并设置优先级 if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123; for (NSUInteger i = 0; i &lt; queueCount; i++) &#123; dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0); queues[i] = dispatch_queue_create("com.ibireme.yykit.render", attr); &#125; &#125; else &#123; for (NSUInteger i = 0; i &lt; queueCount; i++) &#123; queues[i] = dispatch_queue_create("com.ibireme.yykit.render", DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)); &#125; &#125; &#125;); /// 根据自增的值返回某个串行队列 int32_t cur = OSAtomicIncrement32(&amp;counter); if (cur &lt; 0) cur = -cur; return queues[(cur) % queueCount];#undef MAX_QUEUE_COUNT#endif&#125; 为什么不用并行队列呢？因为并行和并发是有区别的。在单核设备上，CPU通过频繁的切换上下文来运行不同的线程，速度足够快以至于我们看起来它是‘并行’处理的，然而我们只能说这种情况是并发而非并行。 并行队列并不能完全体现出多核处理器的优势。实际上一个 n 核设备同一时刻最多能 并行 执行 n 个任务，也就是最多有 n 个线程是相互不竞争 CPU 资源的。 而串行队列中只有一个线程，该框架中，作者使用和处理器核心相同数量的串行队列来轮询处理异步任务，有效的减少了线程调度操作。 ASDKASDK 的渲染部分也是通过异步的方式进行渲染。不过 ASDK 还在其他方面进行了优化，包括，Layout，Rendering 和 UIKit Objects。 总结YYAsyncLayer 的代码也就几百行，非常的精简，但是蕴含着精华： 通过 Core Graphic 异步预渲染视图，在主线程中设置 layer 的 contents 属性。 给 runloop 增加 observer，在 runloop 即将结束的时候运行耗时逻辑，以防止阻塞主线程 创建处理器数量个串行队列作为 GCD 的执行队列，最大程度上利用多核 CPU 的优势。 思考题 为什么会产生卡顿？ CPU 和 GPU 的职责有哪些？ CPU 方面如何优化？ GPU 如何优化？ YYAsyncLayer 为什么可以异步渲染？ YYAsyncLayer 在何时执行渲染？ YYAsyncLayer 如何通过串行队列实现异步的？ 参考iOS 保持界面流畅的技巧啥也不说了，经典中的经典 YYAsyncLayer 源码剖析：异步绘制 使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能 不得不说，indulge_in 和 Draveness 是我见过的唯二文章写的深刻又易懂的人了。佩服]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking 源码解析 - 网络状态与安全策略]]></title>
    <url>%2F2019%2F01%2F05%2FAFNetworking1%2F</url>
    <content type="text"><![CDATA[到了 AFNetworking 的最后一篇了。网络状态变更和安全策略是比较独立的两块东西。因此把他们放在最后看完。 网络状态AFNetworkReachabilityManager类提供了对于网络状态变化的监听。AF 预定义了四种网络状态： 12345678910typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123; /// 未知 AFNetworkReachabilityStatusUnknown = -1, /// 无网络 AFNetworkReachabilityStatusNotReachable = 0, /// WWAN 手机自带网络 AFNetworkReachabilityStatusReachableViaWWAN = 1, /// Wifi AFNetworkReachabilityStatusReachableViaWiFi = 2,&#125;; 设置监听网络状态的监听是一个逻辑很清晰的过程。对于网络状态的改变，我们必须要通过系统的 API 进行。那么在 AFNetworkReachabilityStatusForFlags 中就提供了这样的一个方法实施监听： 1234567891011121314151617181920212223242526272829303132- (void)startMonitoring &#123; [self stopMonitoring]; /// 没有创建 networkReachability 实例，直接返回 if (!self.networkReachability) &#123; return; &#125; /// 网络监听的回调 __weak __typeof(self)weakSelf = self; AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) &#123; strongSelf.networkReachabilityStatusBlock(status); &#125; &#125;; /// 网络监听上下文，注册网络改变的回调 SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;; SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context); SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123; SCNetworkReachabilityFlags flags; if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123; AFPostReachabilityStatusChange(flags, callback); &#125; &#125;);&#125; 可以看到，通过系统 API 创建了一个上下文 SCNetworkReachabilityContext 实例，一个监听回调的 AFNetworkReachabilityStatusBlock 实例，以及一个句柄 networkReachability。既然是句柄，那么就可以通过它来结束监听： 1234567- (void)stopMonitoring &#123; if (!self.networkReachability) &#123; return; &#125; SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);&#125; networkReachability 在初始化监听类对象的时候创建： 123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (instancetype)sharedManager &#123; static AFNetworkReachabilityManager *_sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _sharedManager = [self manager]; &#125;); return _sharedManager;&#125;+ (instancetype)managerForDomain:(NSString *)domain &#123; /// 创建 SCNetworkReachabilityRef 对象 SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]); AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability]; CFRelease(reachability); return manager;&#125;+ (instancetype)managerForAddress:(const void *)address &#123; SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address); AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability]; CFRelease(reachability); return manager;&#125;+ (instancetype)manager&#123;#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100) struct sockaddr_in6 address; bzero(&amp;address, sizeof(address)); address.sin6_len = sizeof(address); address.sin6_family = AF_INET6;#else struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_len = sizeof(address); address.sin_family = AF_INET;#endif return [self managerForAddress:&amp;address];&#125; 初始化方法比较长，主要分为了两种方式监听，一种是监听域名，一种是监听 socket。同时通过系统 API 创建 networkReachability。 监听回调设置好监听那么就设置监听回调以处理网络状态变化信息咯。我们来查看上文中注册的 AFNetworkReachabilityCallback 回调是怎样的： 1234567891011121314151617static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) &#123; AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);&#125;static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123; AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags); dispatch_async(dispatch_get_main_queue(), ^&#123; /// 有回调函数调用回调函数 if (block) &#123; block(status); &#125; /// 发送通知 NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter]; NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;; [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo]; &#125;);&#125; 当网络状态变更的时候，通过 AFNetworkReachabilityStatusForFlags() 方法进行基本状况的处理： 1234567891011121314151617181920212223242526272829#pragma mark - 根据SCNetworkReachabilityFlags这个网络标记来转换成我们在开发中经常使用的网络状态static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123; /// 能否到达 BOOL isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != 0); /// 联网之前需要建立连接 BOOL needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != 0); /// 是否可以自动连接 BOOL canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0)); /// 是否可以在不需要用户手动设置的前提下连接 BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == 0); /// 是否可以联网：1.能够到达 2.不需要建立连接或者不需要用户手动设置连接就能连接到网络 BOOL isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction)); /// 设置网络状态 AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown; if (isNetworkReachable == NO) &#123; status = AFNetworkReachabilityStatusNotReachable; &#125;#if TARGET_OS_IPHONE else if ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != 0) &#123; status = AFNetworkReachabilityStatusReachableViaWWAN; &#125;#endif else &#123; status = AFNetworkReachabilityStatusReachableViaWiFi; &#125; return status;&#125; 处理完成后的结果，可以通过两种方式拿到。一种是通过回调函数，这个回调函数就是上文中在 startMonitoring() 中创建 SCNetworkReachabilityContext 传入的 callback，可以自己将 block 设置给监听类的单例对象。还有一种就是通过通知，提前注册以下两种通知，可以获取到改变时间以及改变的情况： 12345#pragma mark - 通知的字符串/// 网络环境改变时候接收通知NSString * const AFNetworkingReachabilityDidChangeNotification = @"com.alamofire.networking.reachability.change";/// 改变后接收通知，携带一个信息NSString * const AFNetworkingReachabilityNotificationStatusItem = @"AFNetworkingReachabilityNotificationStatusItem"; 以上就是网络监听相关的方法。 安全策略AFSecurityPolicy 类提供了对于 HTTPS 通信过程中证书的校验，可以有效防止中间人攻击。它的校验模式分一下三种： 123456789#pragma mark - 安全级别typedef NS_ENUM(NSUInteger, AFSSLPinningMode) &#123; /// 信任所有证书 AFSSLPinningModeNone, /// 校验证书的公钥 AFSSLPinningModePublicKey, /// 校验整个证书 AFSSLPinningModeCertificate,&#125;; 创建 AFSecurityPolicy初始化AFSecurityPolicy 并不是一个单例对象，每个 AFEscurityPolicy 实例都可以保存自己的验证模式，校验证书集合，以及一些配置属性。它的初始化方法如下： 1234567891011121314151617181920212223+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123; return [self policyWithPinningMode:pinningMode withPinnedCertificates:[self defaultPinnedCertificates]];&#125;+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates &#123; AFSecurityPolicy *securityPolicy = [[self alloc] init]; securityPolicy.SSLPinningMode = pinningMode; [securityPolicy setPinnedCertificates:pinnedCertificates]; return securityPolicy;&#125;- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.validatesDomainName = YES; return self;&#125; 设置校验证书上面的代码中，通过 [self defaultPinnedCertificates] 拿到证书列表，并且再 set 给 AFSecurityPolicy 的过程如下： 12345678910111213141516171819202122232425#pragma mark - 取出 bundler 中的证书+ (NSSet *)certificatesInBundle:(NSBundle *)bundle &#123; /// bundle 中以 .cer 结尾的所有路径 NSArray *paths = [bundle pathsForResourcesOfType:@"cer" inDirectory:@"."]; NSMutableSet *certificates = [NSMutableSet setWithCapacity:[paths count]]; for (NSString *path in paths) &#123; NSData *certificateData = [NSData dataWithContentsOfFile:path]; [certificates addObject:certificateData]; &#125; return [NSSet setWithSet:certificates];&#125;#pragma mark - 获取当前 bundle 下的证书+ (NSSet *)defaultPinnedCertificates &#123; static NSSet *_defaultPinnedCertificates = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSBundle *bundle = [NSBundle bundleForClass:[self class]]; _defaultPinnedCertificates = [self certificatesInBundle:bundle]; &#125;); return _defaultPinnedCertificates;&#125; 获取证书的过程就是从 bundle 中加载 .cer 文件的过程。设置证书给实例的时候做了一个操作，会到证书中获取到公钥信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma mark - 在证书中获取公钥static id AFPublicKeyForCertificate(NSData *certificate) &#123; id allowedPublicKey = nil; SecCertificateRef allowedCertificate; SecPolicyRef policy = nil; SecTrustRef allowedTrust = nil; SecTrustResultType result; /// 根据二进制的certificate生成SecCertificateRef类型的证书 allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate); __Require_Quiet(allowedCertificate != NULL, _out); /// 新建 policy 为 x.509 policy = SecPolicyCreateBasicX509(); /// 设置信任的证书 __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out); __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out); /// 在SecTrustRef对象中取出公钥 allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);_out: if (allowedTrust) &#123; CFRelease(allowedTrust); &#125; if (policy) &#123; CFRelease(policy); &#125; if (allowedCertificate) &#123; CFRelease(allowedCertificate); &#125; return allowedPublicKey;&#125;- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123; _pinnedCertificates = pinnedCertificates; if (self.pinnedCertificates) &#123; NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]]; /// 从证书中取出公钥 for (NSData *certificate in self.pinnedCertificates) &#123; id publicKey = AFPublicKeyForCertificate(certificate); if (!publicKey) &#123; continue; &#125; [mutablePinnedPublicKeys addObject:publicKey]; &#125; self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys]; &#125; else &#123; self.pinnedPublicKeys = nil; &#125;&#125; 执行校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain&#123; /// 自签名证书需要通过验证 if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123; NSLog(@"In order to validate a domain name for self signed certificates, you MUST use pinning."); return NO; &#125; NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)]; &#125; else &#123; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; &#125; /// 设置要校验的域名 SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); /// 在安全级别为不校验的情况，只要通过了CA的校验或者用户允许自签名证书，那么就是成功的 if (self.SSLPinningMode == AFSSLPinningModeNone) &#123; return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); /// 如果安全级别是校验证书并且没有通过CA的校验且不允许自签名证书，那么直接返回 NO &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123; return NO; &#125; /// 有安全校验，且证书也是合法的情况下 switch (self.SSLPinningMode) &#123; case AFSSLPinningModeNone: default: return NO; /// 如果是校验证书的级别 case AFSSLPinningModeCertificate: &#123; NSMutableArray *pinnedCertificates = [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; /// 将本地读取的证书设置为serverTrust的锚点证书 /// 锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），具体就是调用SecTrustEvaluate来验证。 SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); if (!AFServerTrustIsValid(serverTrust)) &#123; return NO; &#125; // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA) /// 验证整个证书链 NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); /// 比较服务端证书是否包含在本地证书内 for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123; if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123; return YES; &#125; &#125; return NO; &#125; /// 如果只校验公钥，那么只需要比较公钥即可。 case AFSSLPinningModePublicKey: &#123; NSUInteger trustedPublicKeyCount = 0; NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust); for (id trustChainPublicKey in publicKeys) &#123; for (id pinnedPublicKey in self.pinnedPublicKeys) &#123; if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123; trustedPublicKeyCount += 1; &#125; &#125; &#125; return trustedPublicKeyCount &gt; 0; &#125; &#125; return NO;&#125; 以上是校验的逻辑，其中涉及到好几个方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma mark - 返回服务器是否可信static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123; BOOL isValid = NO; SecTrustResultType result; /// 校验是否是可信的证书 __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); // kSecTrustResultUnspecified 证书验证成功，但是用户没有明确指出信任此证书。这是最常见的返回值。 // kSecTrustResultProceed 用户选择信任此证书。 isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);_out: return isValid;&#125;#pragma mark - 取出服务器证书的信任链static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123; CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)]; &#125; return [NSArray arrayWithArray:trustChain];&#125;#pragma mark - 取出服务器返回证书的信任链上的所有公钥放到数组中static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123; SecPolicyRef policy = SecPolicyCreateBasicX509(); CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust); NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount]; for (CFIndex i = 0; i &lt; certificateCount; i++) &#123; SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i); SecCertificateRef someCertificates[] = &#123;certificate&#125;; CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL); SecTrustRef trust; __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out); SecTrustResultType result; __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out); [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)]; _out: if (trust) &#123; CFRelease(trust); &#125; if (certificates) &#123; CFRelease(certificates); &#125; continue; &#125; CFRelease(policy); return [NSArray arrayWithArray:trustChain];&#125; 总的概括一下就是： 如果只验证证书的合法性的话，就直接通过苹果预置的根证书校验。 如果要校验证书是否是特定的证书，就要 把服务端返回的证书的签发证书放在 native 中 把 native 中的证书设置为服务端返回证书的锚点证书 取出服务端的证书的信任链上的所有证书并和 native 中的证书做比较。如果相等就说明可以用 native 中保存的证书对服务端的证书解密，即是要信任的证书。如果没有，就说明收到的证书不是服务端签发的，不可信 如果要校验证书中的公钥，则是在上一步的基础上，取出证书中的公钥信息，进行比较。 为什么AF3.0不需要常驻子线程了？首先，请求最好不要在主线程中做，因为这样可能会影响主线程效率。并且子线程需要保活，使其能够在后续的 NSURLConnection 的 delegate 中接收回调。因此， AF2.0 需要创建一个常驻子线程，在子线程中执行网络请求即可。 AF3.0 使用 NSURLSession，不再需要在当前线程进行 delegate 回调]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking 源码解析 - 响应序列化]]></title>
    <url>%2F2018%2F12%2F27%2FAFNetworking3%2F</url>
    <content type="text"><![CDATA[本篇是 AFNetworking 源码解读的第三篇了。主要讲解接收到响应后的处理。 AFURLResponseSerialization 协议AFURLResponseSerialization 协议只有一个方法需要实现： 123- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response data:(nullable NSData *)data error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW; 这个协议会拿到响应对象 NSURLResponse ，响应数据 NSData。可以根据 NSURLResponse 返回数据类型标识 content-type 选取相应的解析器，来解析 data. AFHTTPResponseSerializer 基类 AFHTTPResponseSerializer 是一个基类，提供最基本的属性和方法，针对不同 content-type 的响应报文，需要实例化不同的子类进行解析。 AFHTTPResponseSerializer 有两个重要的属性： 1234/// 设置接收的状态码，不在此内的状态码返回错误@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;/// 设置接受的content-type@property (nonatomic, copy, nullable) NSSet &lt;NSString *&gt; *acceptableContentTypes; 它们会在初始化方法中赋值： 12345678910111213- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; /// 设置i接受的返回code 接收范围是 200-299 self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)]; /// 设置接受的返回content-type 为任何 type self.acceptableContentTypes = nil; return self;&#125; 因为 AFHTTPResponseSerializer 不做任何类型校验，因此其 acceptableContentTypes 为 nil，表示所有类型皆可，这个属性会在不同子类中设置为不同类型。 acceptableStatusCodes 是一个 NSIndexSet 实例，是一个有序的，唯一的，无符号整数的集合。比如： 123456NSMutableIndexSet *indexSetM = [NSMutableIndexSet indexSet];[indexSetM addIndex:6];[indexSetM addIndex:8];[indexSetM addIndexesInRange:NSMakeRange(20, 5)];=&gt; [6,8,20,21,22,23,24] addIndexesInRange: 方法可以设定一个范围。因此上面的代码中 acceptableStatusCodes 代表的是只接受 200-299 的状态码。 根据上面的有效状态码和有效 content-type，基类中还有一个验证方法。如果验证无效，会抛出 NSError： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/// 验证服务器返回的数据，是否符合接收的状态码和 content-type- (BOOL)validateResponse:(NSHTTPURLResponse *)response data:(NSData *)data error:(NSError * __autoreleasing *)error&#123; /// 默认响应都是有效的 BOOL responseIsValid = YES; NSError *validationError = nil; if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123; /// 如果设置了接受的 content-type 并且响应的 content-type 不在其之内，并且 response 的 MIMEType 和 data 都不为空 if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp; !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123; /// 生成错误信息 if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123; NSMutableDictionary *mutableUserInfo = [@&#123; NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]], NSURLErrorFailingURLErrorKey:[response URL], AFNetworkingOperationFailingURLResponseErrorKey: response, &#125; mutableCopy]; if (data) &#123; mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data; &#125; validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError); &#125; responseIsValid = NO; &#125; /// 校验响应状态码 if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123; NSMutableDictionary *mutableUserInfo = [@&#123; NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode], NSURLErrorFailingURLErrorKey:[response URL], AFNetworkingOperationFailingURLResponseErrorKey: response, &#125; mutableCopy]; if (data) &#123; mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data; &#125; validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError); responseIsValid = NO; &#125; &#125; if (error &amp;&amp; !responseIsValid) &#123; *error = validationError; &#125; return responseIsValid;&#125; AFJSONResponseSerializer解析 JSON 的序列化类。它的 content-type 为 @&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot; 1234567891011- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; /// 接受的 content-type 为 @"application/json", @"text/json", @"text/javascript" self.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript", nil]; return self;&#125; 序列化方法通过 NSJSONSerialization 将 NSData 转为 json 对象，一般是一个字典或者数组： 1234567891011121314151617181920212223242526272829303132333435- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; /// 验证 response if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]]; if (data.length == 0 || isSpace) &#123; return nil; &#125; NSError *serializationError = nil; id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError]; if (!responseObject) &#123; if (error) &#123; *error = AFErrorWithUnderlyingError(serializationError, *error); &#125; return nil; &#125; /// 移除空的 key if (self.removesKeysWithNullValues) &#123; return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions); &#125; return responseObject;&#125; 最后还会删除数据中值为 NSNull 的 key： 123456789101112131415161718192021222324252627282930313233/// 移除空的 keystatic id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) &#123; /// 如果是数组 if ([JSONObject isKindOfClass:[NSArray class]]) &#123; NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]]; for (id value in (NSArray *)JSONObject) &#123; /// 递归调用 [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)]; &#125; return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray]; /// 如果字典 &#125; else if ([JSONObject isKindOfClass:[NSDictionary class]]) &#123; NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject]; /// 循环字典中所有的 key for (id &lt;NSCopying&gt; key in [(NSDictionary *)JSONObject allKeys]) &#123; id value = (NSDictionary *)JSONObject[key]; /// 如果 value 是 NSNull if (!value || [value isEqual:[NSNull null]]) &#123; /// removeObjectForKey [mutableDictionary removeObjectForKey:key]; /// 如果 value 还是数组或者字典类型 &#125; else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) &#123; /// 递归调用 mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions); &#125; &#125; return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary]; &#125; return JSONObject;&#125; 注意，数组中的空对象是不会被删除的，只会删除字典中的值为 nil 的键 AFXMLParserResponseSerializer解析 xml 的序列化类。它的 content-type 为 @&quot;application/xml&quot;, @&quot;text/xml&quot;: 12345678910- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/xml", @"text/xml", nil]; return self;&#125; 通过系统类 NSXMLParser 解析： 123456789101112- (id)responseObjectForResponse:(NSHTTPURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; return [[NSXMLParser alloc] initWithData:data];&#125; AFPropertyListResponseSerializer解析 plist 的序列化类。它的 content-type 为 @&quot;application/x-plist&quot; 12345678910- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/x-plist", nil]; return self;&#125; 通过 NSPropertyListSerialization 解析： 12345678910111213141516171819202122232425262728- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; if (!data) &#123; return nil; &#125; NSError *serializationError = nil; id responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&amp;serializationError]; if (!responseObject) &#123; if (error) &#123; *error = AFErrorWithUnderlyingError(serializationError, *error); &#125; return nil; &#125; return responseObject;&#125; AFImageResponseSerializer解析 image 的序列化类。它的 content-type 为 @&quot;image/tiff&quot;, @&quot;image/jpeg&quot;, @&quot;image/gif&quot;, @&quot;image/png&quot;, @&quot;image/ico&quot;, @&quot;image/x-icon&quot;, @&quot;image/bmp&quot;, @&quot;image/x-bmp&quot;, @&quot;image/x-xbitmap&quot;, @&quot;image/x-win-bitmap&quot;。 它还有一个属性 automaticallyInflatesResponseImage 用来设置是否自动解码： 12345678910111213- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap", nil]; self.imageScale = [[UIScreen mainScreen] scale]; self.automaticallyInflatesResponseImage = YES; return self;&#125; 它的解析方式如下： 1234567891011121314151617- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123; if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123; return nil; &#125; &#125; if (self.automaticallyInflatesResponseImage) &#123; return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale); &#125; else &#123; return AFImageWithDataAtScale(data, self.imageScale); &#125; return nil;&#125; 其中涉及到两个方法 AFInflatedImageFromResponseWithDataAtScale 和 AFImageWithDataAtScale。先来看后者，它通过 NSData 创建 image： 12345678910111213141516171819202122232425/// 创建 image+ (UIImage *)af_safeImageWithData:(NSData *)data &#123; UIImage* image = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; imageLock = [[NSLock alloc] init]; &#125;); [imageLock lock]; image = [UIImage imageWithData:data]; [imageLock unlock]; return image;&#125;@end/// data scale 创建 imagestatic UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) &#123; UIImage *image = [UIImage af_safeImageWithData:data]; if (image.images) &#123; return image; &#125; return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];&#125; 上面创建图片的方式比较普通，不太能理解为什么要加锁。然后是 AFInflatedImageFromResponseWithDataAtScale ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/// 将png和jpeg图片解码static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) &#123; if (!data || [data length] == 0) &#123; return nil; &#125; CGImageRef imageRef = NULL; CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data); if ([response.MIMEType isEqualToString:@"image/png"]) &#123; imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault); &#125; else if ([response.MIMEType isEqualToString:@"image/jpeg"]) &#123; imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault); if (imageRef) &#123; CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef); CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace); // CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123; CGImageRelease(imageRef); imageRef = NULL; &#125; &#125; &#125; CGDataProviderRelease(dataProvider); UIImage *image = AFImageWithDataAtScale(data, scale); if (!imageRef) &#123; if (image.images || !image) &#123; return image; &#125; imageRef = CGImageCreateCopy([image CGImage]); if (!imageRef) &#123; return nil; &#125; &#125; size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef); /// 如果图片太大就不解码了。因为解码的图片很占内存 if (width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8) &#123; CGImageRelease(imageRef); return image; &#125; // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate /// 解码相关方法 size_t bytesPerRow = 0; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace); CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef); if (colorSpaceModel == kCGColorSpaceModelRGB) &#123; uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wassign-enum" if (alpha == kCGImageAlphaNone) &#123; bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask; bitmapInfo |= kCGImageAlphaNoneSkipFirst; &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123; bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask; bitmapInfo |= kCGImageAlphaPremultipliedFirst; &#125;#pragma clang diagnostic pop &#125; CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo); CGColorSpaceRelease(colorSpace); if (!context) &#123; CGImageRelease(imageRef); return image; &#125; CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef); CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context); CGContextRelease(context); UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation]; CGImageRelease(inflatedImageRef); CGImageRelease(imageRef); return inflatedImage;&#125; 这个方法能解析 png 和 jpeg 图片，会将图片解码，这样能加速图片的显示速度。 AFCompoundResponseSerializer复合类型的序列化器。在创建的时候需要传入上面的各种序列化方式的实例： 123456+ (instancetype)compoundSerializerWithResponseSerializers:(NSArray *)responseSerializers &#123; AFCompoundResponseSerializer *serializer = [[self alloc] init]; serializer.responseSerializers = responseSerializers; return serializer;&#125; 在获取到响应信息的时候会调用内部的各种序列化器尝试转换： 12345678910111213141516171819202122- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error&#123; for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) &#123; if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123; continue; &#125; NSError *serializerError = nil; id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError]; if (responseObject) &#123; if (error) &#123; *error = AFErrorWithUnderlyingError(serializerError, *error); &#125; return responseObject; &#125; &#125; return [super responseObjectForResponse:response data:data error:error];&#125; 总结总体来说，响应的序列化类不像请求那样涉及到输入流，因此还是比较清晰简单的。只要针对不同的 content-type 选取不同的系统类进行解析即可。 针对图片格式，AFNetworking 做了一部分图片解码转换的功能，但是和 SDWebImage 相比还是简单了很多。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking 源码解析 - 请求序列化]]></title>
    <url>%2F2018%2F12%2F25%2FAFNetworking2%2F</url>
    <content type="text"><![CDATA[本篇是 AFNetworking 源码解析的第二批，主要讲解如何生成请求 request。请求的序列化过程是非常重要的一个过程，涉及到多种处理和数据结构。自顶向下分析难度较大，因此本篇将先分析最底层的类。 涉及到的类AFQueryStringPair该类用于保存请求要发送的参数，从他的头文件中的属性可以看出： 1234@interface AFQueryStringPair : NSObject@property (readwrite, nonatomic, strong) id field;@property (readwrite, nonatomic, strong) id value;@end field 和 value 就代表着请求参数的键值对。它有一个方法，用于将参数转化为发送请求时的字符串样式以等号连接。它可以在 get 请求时被拼接到 url 中也可以在 post 请求时作为请求体放到 body 中： 12345678/// field value 用 = 连接- (NSString *)URLEncodedStringValue &#123; if (!self.value || [self.value isEqual:[NSNull null]]) &#123; return AFPercentEscapedStringFromString([self.field description]); &#125; else &#123; return [NSString stringWithFormat:@"%@=%@", AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])]; &#125;&#125; 其中涉及到了一个方法 AFPercentEscapedStringFromString()，它被用来将字符串编码。在 url 中，只能存在数字字母以及 -_.~ 四个特殊符号，其他的符号都需要通过百分号转码，比如 ! 要被转码为 %21，= 要被转码为 %3D。 AFPercentEscapedStringFromString() 会将字符串分割成数个小端，每个小端分别进行编码。编码的工作主要使用的是 NSString 的 stringByAddingPercentEncodingWithAllowedCharacters: 方法。还需要注意的是，对于 emoji 表情，一个 emoji 表情将占用两个字符的大小。因此，在分割字符串的时候，还需要对 emoji 在边界的情况做一个处理，防止劈开 emoji 表情： 123456789101112131415161718192021222324252627282930313233#pragma mark - 将字符串编码NSString * AFPercentEscapedStringFromString(NSString *string) &#123; static NSString * const kAFCharactersGeneralDelimitersToEncode = @":#[]@"; // does not include "?" or "/" due to RFC 3986 - Section 3.4 static NSString * const kAFCharactersSubDelimitersToEncode = @"!$&amp;'()*+,;="; NSMutableCharacterSet * allowedCharacterSet = [[NSCharacterSet URLQueryAllowedCharacterSet] mutableCopy]; /// 从允许的不要编码的字符中移除👆的那些字符 [allowedCharacterSet removeCharactersInString:[kAFCharactersGeneralDelimitersToEncode stringByAppendingString:kAFCharactersSubDelimitersToEncode]]; static NSUInteger const batchSize = 50; NSUInteger index = 0; NSMutableString *escaped = @"".mutableCopy; /// 循环每50个字符进行一次编码 while (index &lt; string.length) &#123; NSUInteger length = MIN(string.length - index, batchSize); NSRange range = NSMakeRange(index, length); // To avoid breaking up character sequences such as 👴🏻👮🏽 /// 一个 emoji 代表多个字符，因此要通过这个方法纠正，防止劈开 emoji 表情 range = [string rangeOfComposedCharacterSequencesForRange:range]; NSString *substring = [string substringWithRange:range]; /// 将字符串编码 NSString *encoded = [substring stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacterSet]; [escaped appendString:encoded]; index += range.length; &#125; return escaped;&#125; AFHTTPBodyPart一般请求不会用到这个类，当请求类型为 multipart/form-data 的时候，会创建多个 AFHTTPBodyPart 对象，每一个对象会有一个 NSInputStream 输入流，在生成请求的时候导入到 request 中。 头文件AFHTTPBodyPart 保存了 HTTP body的全部的信息。来看它的头部信息： 1234567891011121314151617181920212223@interface AFHTTPBodyPart : NSObject/// 编码方式@property (nonatomic, assign) NSStringEncoding stringEncoding;/// 头@property (nonatomic, strong) NSDictionary *headers;/// 边界字符串@property (nonatomic, copy) NSString *boundary;/// 主体内容@property (nonatomic, strong) id body;/// 主体大小@property (nonatomic, assign) unsigned long long bodyContentLength;/// 输入流@property (nonatomic, strong) NSInputStream *inputStream;/// 是否有初始边界@property (nonatomic, assign) BOOL hasInitialBoundary;@property (nonatomic, assign) BOOL hasFinalBoundary;/// 是否还能从输入流中读取data@property (readonly, nonatomic, assign, getter = hasBytesAvailable) BOOL bytesAvailable;/// 总体的长度@property (readonly, nonatomic, assign) unsigned long long contentLength;@end 它的类拓展中还提供了几个属性作用于读取数据阶段： 12345678@interface AFHTTPBodyPart () &lt;NSCopying&gt; &#123; /// body 中四大部分的枚举 AFHTTPBodyPartReadPhase _phase; /// 输入流 NSInputStream *_inputStream; /// 读取的当前位置 unsigned long long _phaseReadOffset;&#125; 其中枚举类型为。将在下面讲解方法的时候看到： 12345678910typedef enum &#123; /// 前边界阶段 AFEncapsulationBoundaryPhase = 1, /// 头部阶段 AFHeaderPhase = 2, /// body阶段 AFBodyPhase = 3, /// 后边界阶段 AFFinalBoundaryPhase = 4,&#125; AFHTTPBodyPartReadPhase; 方法inputStream接着依次看 AFHTTPBodyPart 的方法。首先是 inputStream 的 get 方法： 1234567891011121314151617/// inputStream 的 get 方法- (NSInputStream *)inputStream &#123; if (!_inputStream) &#123; /// body 有 NSData NSURL NSInputStream 三种类型 if ([self.body isKindOfClass:[NSData class]]) &#123; _inputStream = [NSInputStream inputStreamWithData:self.body]; &#125; else if ([self.body isKindOfClass:[NSURL class]]) &#123; _inputStream = [NSInputStream inputStreamWithURL:self.body]; &#125; else if ([self.body isKindOfClass:[NSInputStream class]]) &#123; _inputStream = self.body; &#125; else &#123; _inputStream = [NSInputStream inputStreamWithData:[NSData data]]; &#125; &#125; return _inputStream;&#125; 它会把 body 转化为 NSInputStream ，无论 body 原本是 NSData 类型，NSURL 类型还是 NSInputStream 类型。 stringForHeadersstringForHeaders 方法将 headers 字典转化为字符串： 123456789101112/// 根据 self 的 header 字典属性来拼接 header 字符串- (NSString *)stringForHeaders &#123; NSMutableString *headerString = [NSMutableString string]; for (NSString *field in [self.headers allKeys]) &#123; /// 每个头部参数的键值对结束后插入换行 CRLF [headerString appendString:[NSString stringWithFormat:@"%@: %@%@", field, [self.headers valueForKey:field], kAFMultipartFormCRLF]]; &#125; /// 所有头部参数结束后，再插入一个换行符 CRLF [headerString appendString:kAFMultipartFormCRLF]; return [NSString stringWithString:headerString];&#125; 这里的 header 不是 request header，而是 request body 中的 header。下面会有举例 contentLengthcontentLength 用于计算 HTTP body 的整体长度。body 包含四个部分，分别对应于上面的 AFHTTPBodyPartReadPhase 枚举： 12345678910111213141516171819202122/// 总体的长度- (unsigned long long)contentLength &#123; unsigned long long length = 0; /// 前边界读取 /// 如果数据体是第一个数据体，那么则插入首分隔字符串，否则，就插入中间分隔字符串，后者比前者多了一个回车换行符 \r\n NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; length += [encapsulationBoundaryData length]; /// 头部读取 NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; length += [headersData length]; /// 加上 body 的长度 length += _bodyContentLength; /// 尾边界读取 NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); length += [closingBoundaryData length]; return length;&#125; 这里涉及到以下四个方法： 12345678910111213141516171819202122/// 生成随机 boundary 字符串static NSString * AFCreateMultipartFormBoundary() &#123; return [NSString stringWithFormat:@"Boundary+%08X%08X", arc4random(), arc4random()];&#125;/// 分行符static NSString * const kAFMultipartFormCRLF = @"\r\n";/// 生成初始边界字符串static inline NSString * AFMultipartFormInitialBoundary(NSString *boundary) &#123; return [NSString stringWithFormat:@"--%@%@", boundary, kAFMultipartFormCRLF];&#125;/// 生成中间边界字符串 和初始字符串相比多了前部的 \r\nstatic inline NSString * AFMultipartFormEncapsulationBoundary(NSString *boundary) &#123; return [NSString stringWithFormat:@"%@--%@%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];&#125;/// 生成结束边界字符串static inline NSString * AFMultipartFormFinalBoundary(NSString *boundary) &#123; return [NSString stringWithFormat:@"%@--%@--%@", kAFMultipartFormCRLF, boundary, kAFMultipartFormCRLF];&#125; 用来生成不同情况下的 boundary。具体作用将在 read:maxLength: 讲解。 hasBytesAvailableAFHTTPBodyPart 中有一个输入流 NSInputStream 实例，这个方法就是用来查看输入流中是否还有可用数据的。根据输入流的状态判断： 123456789101112131415161718192021/// 是否还有数据可读- (BOOL)hasBytesAvailable &#123; // Allows `read:maxLength:` to be called again if `AFMultipartFormFinalBoundary` doesn't fit into the available buffer if (_phase == AFFinalBoundaryPhase) &#123; return YES; &#125; switch (self.inputStream.streamStatus) &#123; case NSStreamStatusNotOpen: case NSStreamStatusOpening: case NSStreamStatusOpen: case NSStreamStatusReading: case NSStreamStatusWriting: return YES; case NSStreamStatusAtEnd: case NSStreamStatusClosed: case NSStreamStatusError: default: return NO; &#125;&#125; transitionToNextPhase这里用到了上面的枚举对象。根据当前所处阶段，将阶段设置为下一阶段： 1234567891011121314151617181920212223242526272829303132333435/// 转移到下一阶段- (BOOL)transitionToNextPhase &#123; /// 保证代码在主线程 if (![[NSThread currentThread] isMainThread]) &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [self transitionToNextPhase]; &#125;); return YES; &#125; switch (_phase) &#123; case AFEncapsulationBoundaryPhase: _phase = AFHeaderPhase; break; case AFHeaderPhase: /// 打开了一个输入流 [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; [self.inputStream open]; _phase = AFBodyPhase; break; case AFBodyPhase: /// 将输入流关闭 [self.inputStream close]; _phase = AFFinalBoundaryPhase; break; case AFFinalBoundaryPhase: default: _phase = AFEncapsulationBoundaryPhase; break; &#125; /// 重置 offset _phaseReadOffset = 0; return YES;&#125; read:maxLength:这是 AFHTTPBodyPart 的核心方法。AFHTTPBodyPart 封装了 multipart/form-data 情况下 body 中的部分数据。那么在发送的时候一定要把它读出来吧。read:maxLength: 的目的就是如此，将数据放入 buffer 中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/// 读取 buffer- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; /// 已经读取的字节数 NSInteger totalNumberOfBytesRead = 0; /// 前边界读取 /// 如果数据体是第一个数据体，那么则插入首分隔字符串，否则，就插入中间分隔字符串，后者比前者多了一个回车换行符 \r\n if (_phase == AFEncapsulationBoundaryPhase) &#123; NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; /// 头部信息读取 if (_phase == AFHeaderPhase) &#123; NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; /// 数据体读取 /// 调用输入流进行数据读取 if (_phase == AFBodyPhase) &#123; NSInteger numberOfBytesRead = 0; numberOfBytesRead = [self.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; if (numberOfBytesRead == -1) &#123; return -1; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; /// 如果读到了流的末尾，那么进入下一个读取阶段 if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123; [self transitionToNextPhase]; &#125; &#125; &#125; /// 后边界读取 /// 如果数据体是最后一个数据，那么插入后边界字符串，否则，插入空值 if (_phase == AFFinalBoundaryPhase) &#123; NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; /// 最后返回读取到的所有数据的字节数 return totalNumberOfBytesRead;&#125;/// 读取 data 到 buffer 中- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length)); [data getBytes:buffer range:range]; _phaseReadOffset += range.length; ///如果偏移量大于等于数据的长度，说明数据读取完毕，可以进入下一个阶段 if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123; [self transitionToNextPhase]; &#125; return (NSInteger)range.length;&#125; 这个方法中有涉及到了边界相关的几个方法。当 http 请求 type 为 multipart/form-data 时，它会将表单中的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型：content-disposition，用来说明字段的一些信息。如： 1234567891011121314151617--boundary+004563210AB32145Content-Disposition: form-data; name="field1"value1--boundary+004563210AB32145Content-Disposition: form-data; name="field2"value2--boundary+004563210AB32145Content-Disposition: form-data; name="text"; filename="file.txt"data1--boundary+004563210AB32145Content-Disposition: form-data; name="pic"; filename="icon.png"data2--boundary+004563210AB32145-- 每两个 boundary 之间的数据就是一个 AFHTTPBodyPart 实例。也就是 read:maxLength: 读取生成的 buffer 的数据 --boundary+004563210AB32145 就是由上面的四个方法生成的。针对 boundary 所处的不同位置，会有不同的添加换行符的规则。 AFMultipartBodyStream之前 AFHTTPBodyPart 是 form-data 下 body 中的各个部分。现在的 AFMutipartBodyStream 则是 AFHTTPBodyPart 的集合。 头文件12345678910111213141516@interface AFMultipartBodyStream : NSInputStream &lt;NSStreamDelegate&gt;@property (nonatomic, assign) NSUInteger numberOfBytesInPacket;@property (nonatomic, assign) NSTimeInterval delay;@property (nonatomic, strong) NSInputStream *inputStream;@property (readonly, nonatomic, assign) unsigned long long contentLength;@property (readonly, nonatomic, assign, getter = isEmpty) BOOL empty;@end @interface AFMultipartBodyStream () &lt;NSCopying&gt;@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;@property (readwrite, nonatomic, strong) NSMutableArray *HTTPBodyParts;@property (readwrite, nonatomic, strong) NSEnumerator *HTTPBodyPartEnumerator;@property (readwrite, nonatomic, strong) AFHTTPBodyPart *currentHTTPBodyPart;@property (readwrite, nonatomic, strong) NSOutputStream *outputStream;@property (readwrite, nonatomic, strong) NSMutableData *buffer;@end 可以发现 AFMutipartBodyStream 是继承于 NSInputStream 的。我们需要清楚的是，HTTPBodyParts 是以一个数组的形式存在于它的属性中。 方法setInitialAndFinalBoundaries由于它内内存存在一个 AFHTTPBodyPart 的数组，这个方法就是将数组中第一个设置为存在初始边界，最后一个存在末尾边界，中间的则是普通边界的情况： 123456789101112/// 一个 AFMultipartBodyStream 中有多个 HTTPBodyParts，最前面的设置 initialBoundary 最后面的设置 finalBoundary- (void)setInitialAndFinalBoundaries &#123; if ([self.HTTPBodyParts count] &gt; 0) &#123; for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) &#123; bodyPart.hasInitialBoundary = NO; bodyPart.hasFinalBoundary = NO; &#125; [[self.HTTPBodyParts firstObject] setHasInitialBoundary:YES]; [[self.HTTPBodyParts lastObject] setHasFinalBoundary:YES]; &#125;&#125; appendHTTPBodyPart:既然有一个数组，那么数组元素当然要一个个添加进来啦。这个方法就是用来添加元素的： 1234/// 增加HTTPBodyPart实例到数组中- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart &#123; [self.HTTPBodyParts addObject:bodyPart];&#125; read:maxLength:这个方法在 AFHTTPBodyPart 中也有，其实他是 NSInputStream 的方法，在 AFMultipartBodyStream 中被重写了： 1234567891011121314151617181920212223242526272829303132333435363738394041/// 读取 HTTPBodyPart 中的数据到 buffer 中- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length&#123; if ([self streamStatus] == NSStreamStatusClosed) &#123; return 0; &#125; /// 已读数据 NSInteger totalNumberOfBytesRead = 0; /// 遍历读取数据 while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123; /// 如果当前读取的body不存在或者body没有可读字节 if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123; ///把下一个body赋值给当前的body 如果下一个为nil 就退出循环 if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) &#123; break; &#125; /// 当前body存在 &#125; else &#123; // 剩余可读文件的大小 NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead; /// 把当前的body的数据读入到buffer中 NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; if (numberOfBytesRead == -1) &#123; self.streamError = self.currentHTTPBodyPart.inputStream.streamError; break; &#125; else &#123; /// 读完之后增加已读长度 totalNumberOfBytesRead += numberOfBytesRead; /// 读完之后是否需要有 delay if (self.delay &gt; 0.0f) &#123; [NSThread sleepForTimeInterval:self.delay]; &#125; &#125; &#125; &#125; return totalNumberOfBytesRead;&#125; 简而言之，就是调用每一个 AFHTTPBodyPart 实例的相应方法，把他们的所有 buffer 汇集在一起。 buffer 读完之后有什么用，后面再说 contentLength将所有 AFHTTPBodyPart 的长度都累加起来成为最终的 content-length 12345678- (unsigned long long)contentLength &#123; unsigned long long length = 0; for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) &#123; length += [bodyPart contentLength]; &#125; return length;&#125; 开闭 NSInputStream这也是 NSInputStream中的方法，在读取 buffer 前后要分别 open 以及 close 123456789101112131415/// 重写 NSInputStream 的方法- (void)open &#123; if (self.streamStatus == NSStreamStatusOpen) &#123; return; &#125; self.streamStatus = NSStreamStatusOpen; [self setInitialAndFinalBoundaries]; self.HTTPBodyPartEnumerator = [self.HTTPBodyParts objectEnumerator];&#125;- (void)close &#123; self.streamStatus = NSStreamStatusClosed;&#125; AFStreamingMultipartFormData前面 AFMultipartBodyStream 包含了多个 AFHTTPBodyPart 实例，且可以获取到所有的 buffer，他们准确的说就是model类，没有更多的操作。而此处的 AFStreamingMultipartFormData 则更像是一种 manager，可以管理 AFMultipartBodyStream。 头文件12345678@interface AFStreamingMultipartFormData ()/// NSMutableURLRequest@property (readwrite, nonatomic, copy) NSMutableURLRequest *request;@property (readwrite, nonatomic, assign) NSStringEncoding stringEncoding;@property (readwrite, nonatomic, copy) NSString *boundary;/// AFMultipartBodyStream 实例@property (readwrite, nonatomic, strong) AFMultipartBodyStream *bodyStream;@end 头文件中主需要关注两个属性，一个是 NSMutableURLRequest 实例，还有一个是 SFMultipartBodyStream 实例。它将请求和输入流封装了起来。 方法初始化初始化方法很简单，就是对头文件中属性的设置。它要传入一个 NSMutableURLRequest 实例。 123456789101112131415- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest stringEncoding:(NSStringEncoding)encoding&#123; self = [super init]; if (!self) &#123; return nil; &#125; self.request = urlRequest; self.stringEncoding = encoding; self.boundary = AFCreateMultipartFormBoundary(); self.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding]; return self;&#125; 通过文件路径增加 AFHTTPBodyPart如果要上传一个本地文件，那么就把本地文件的路径设置给新创建的 SFHTTPBodyPart 实例中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSString *fileName = [fileURL lastPathComponent]; NSString *mimeType = AFContentTypeForPathExtension([fileURL pathExtension]); return [self appendPartWithFileURL:fileURL name:name fileName:fileName mimeType:mimeType error:error];&#125;/// 将 fileURL 下的文件包装为 AFHTTPBodyPart 实例，保存下来- (BOOL)appendPartWithFileURL:(NSURL *)fileURL name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType error:(NSError * __autoreleasing *)error&#123; NSParameterAssert(fileURL); NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); if (![fileURL isFileURL]) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@"Expected URL to be a file URL", @"AFNetworking", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; /// 检查 url 下的文件是否存在 &#125; else if ([fileURL checkResourceIsReachableAndReturnError:error] == NO) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@"File URL not reachable.", @"AFNetworking", nil)&#125;; if (error) &#123; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorBadURL userInfo:userInfo]; &#125; return NO; &#125; /// 通过 NSFileManager 提取 fileURL 所示文件的信息 NSDictionary *fileAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:[fileURL path] error:error]; if (!fileAttributes) &#123; return NO; &#125; NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; /// 设置 header [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"]; [mutableHeaders setValue:mimeType forKey:@"Content-Type"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = fileURL; /// 获取文件的大小 bodyPart.bodyContentLength = [fileAttributes[NSFileSize] unsignedLongLongValue]; /// 把创建的 AFHTTPBodyPart 放到 AFMultipartBodyStream 属性中 [self.bodyStream appendHTTPBodyPart:bodyPart]; return YES;&#125; 通过输入流增加 AFHTTPBodyPart把传入的输入流作为 AFHTTPBodyPart 的 body 保存 12345678910111213141516171819202122232425/// 把 inputStream 封装为 AFHTTPBodyPart，保存- (void)appendPartWithInputStream:(NSInputStream *)inputStream name:(NSString *)name fileName:(NSString *)fileName length:(int64_t)length mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"]; [mutableHeaders setValue:mimeType forKey:@"Content-Type"]; AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = mutableHeaders; bodyPart.boundary = self.boundary; bodyPart.body = inputStream; bodyPart.bodyContentLength = (unsigned long long)length; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125; 通过 NSData 增加 AFHTTPBodyPart如果直接传入了 NSData，那么直接把他保存到 AFHTTPBodyPart 的 body 中： 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType&#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"; filename=\"%@\"", name, fileName] forKey:@"Content-Disposition"]; [mutableHeaders setValue:mimeType forKey:@"Content-Type"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name&#123; NSParameterAssert(name); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@"form-data; name=\"%@\"", name] forKey:@"Content-Disposition"]; [self appendPartWithHeaders:mutableHeaders body:data];&#125;/// 把 NSData 封装为 AFHTTPBodyPart 保存- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body&#123; NSParameterAssert(body); AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125; 返回 NSMutableURLRequest 实例前面提到过，读取的 buffer 有什么用呢？答案就在这个方法中： 12345678910111213141516- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; /// 把 bodyStream 设置给 request [self.request setHTTPBodyStream:self.bodyStream]; /// 设置 content-type 和 content-length [self.request setValue:[NSString stringWithFormat:@"multipart/form-data; boundary=%@", self.boundary] forHTTPHeaderField:@"Content-Type"]; [self.request setValue:[NSString stringWithFormat:@"%llu", [self.bodyStream contentLength]] forHTTPHeaderField:@"Content-Length"]; return self.request;&#125; NSMutableURLRequest 有一个属性是 HTTPBodyStream，它是 NSInputStream 类型，在生成请求的时候会自动调用其 HTTPBodyStream 实例的 read:maxLength: 方法。获取 buffer 数据写入请求体中。 NSMutableURLRequest 有两个属性用来设置请求体： NSInputStream 类型的 HTTPBodyStream ，也就是上面说的，是以数据流的形式生成请求体，需要实现 NSInputStream 的 read:maxLength: 方法，返回 buffer。主要使用在 content-type 为 multipart/form-data 的情况。 NSData 类型的 HTTPBody，直接将 NSData 放入请求中。主要用在非 multipart/form-data 的情况，包括 application/json，application/x-www-form-urlencoded 等 AFHTTPRequestSerializer初始化初始化方法比较长。做了以下几件事： 创建了一个并行队列，用于实现读写锁 设置请求头，包裹 UA 和 Accept-Language 给部分属性添加 KVO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (instancetype)init &#123; self = [super init]; if (!self) &#123; return nil; &#125; self.stringEncoding = NSUTF8StringEncoding; self.mutableHTTPRequestHeaders = [NSMutableDictionary dictionary]; /// 请求头读写队列，以此并行队列实现读写锁 self.requestHeaderModificationQueue = dispatch_queue_create("requestHeaderModificationQueue", DISPATCH_QUEUE_CONCURRENT); // Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4 NSMutableArray *acceptLanguagesComponents = [NSMutableArray array]; /// 设置 Accept-Language [[NSLocale preferredLanguages] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; float q = 1.0f - (idx * 0.1f); [acceptLanguagesComponents addObject:[NSString stringWithFormat:@"%@;q=%0.1g", obj, q]]; *stop = q &lt;= 0.5f; &#125;]; [self setValue:[acceptLanguagesComponents componentsJoinedByString:@", "] forHTTPHeaderField:@"Accept-Language"]; /// 设置 useragent NSString *userAgent = nil; // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@"%@/%@ (%@; iOS %@; Scale/%0.2f)", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]]; if (userAgent) &#123; if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123; NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove", false)) &#123; userAgent = mutableUserAgent; &#125; &#125; [self setValue:userAgent forHTTPHeaderField:@"User-Agent"]; &#125; // HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html /// 以下三种请求会把 param 放在 uri 中 self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@"GET", @"HEAD", @"DELETE", nil]; /// 用来记录哪些 keyPaths 改变了 self.mutableObservedChangedKeyPaths = [NSMutableSet set]; /// 给 AFHTTPRequestSerializerObservedKeyPaths 中的属性添加 KVO for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123; [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext]; &#125; &#125; return self;&#125; 添加 KVO添加 KVO 的属性由以下方法提供： 12345678910#pragma mark - AFHTTPRequestSeri 通过KVO监听以下的几个属性static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123; static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))]; &#125;); return _AFHTTPRequestSerializerObservedKeyPaths;&#125; 包括 是否允许使用蜂窝网络，缓存策略，是否使用 cookies，是否使用管线连接，网络服务类型，超时时间。当他们被重新设置后，会触发 KVO 方法： 12345678910111213- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(__unused id)object change:(NSDictionary *)change context:(void *)context&#123; if (context == AFHTTPRequestSerializerObserverContext) &#123; if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123; [self.mutableObservedChangedKeyPaths removeObject:keyPath]; &#125; else &#123; [self.mutableObservedChangedKeyPaths addObject:keyPath]; &#125; &#125;&#125; 也就是说，如果改变了就会被加入到 mutableObservedChangedKeyPaths 数组中。这样，在创建 request 的时候就可以通过这个数组获取到变化的信息。 设置头部信息设置 header 本来就是简单的两个 get set 方法，但是还是要拿出来说一下是因为它通过一个并行队列以及 dispatch_barrier_async 实现了一个读写锁： 123456789101112131415- (void)setValue:(NSString *)valueforHTTPHeaderField:(NSString *)field&#123; dispatch_barrier_async(self.requestHeaderModificationQueue, ^&#123; [self.mutableHTTPRequestHeaders setValue:value forKey:field]; &#125;);&#125;- (NSString *)valueForHTTPHeaderField:(NSString *)field &#123; NSString __block *value; dispatch_sync(self.requestHeaderModificationQueue, ^&#123; value = [self.mutableHTTPRequestHeaders valueForKey:field]; &#125;); return value;&#125; 各种创建 NSMutableURLRequest 的方式application/x-www-form-urlencodedapplication/x-www-form-urlencoded 的 request 将参数拼接到 url 上或者放在 body 中： 123456789101112131415161718192021222324252627282930/// 生成普通 urlrequest，param 设置到body或者uri上- (NSMutableURLRequest *)requestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(URLString); NSURL *url = [NSURL URLWithString:URLString]; NSParameterAssert(url); NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url]; mutableRequest.HTTPMethod = method; ///将request的各种属性循环遍历 for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123; /// 如果观察到的属性改变了 if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123; /// 将属性设置给 request [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath]; &#125; &#125; /// 将 param 拼到 uri 或者放到 body 中 mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy]; return mutableRequest;&#125; 调用 requestBySerializingRequest:withparameters:error: 处理参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// 将 param 拼到 uri 或放在 body- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); NSMutableURLRequest *mutableRequest = [request mutableCopy]; /// 设置header给 request [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; NSString *query = nil; if (parameters) &#123; /// 如果有自定义的序列化方法，直接调用 if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125; &#125; else &#123; /// 没有自定义的序列化方法调用默认序列化方法 switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; &#125; &#125; &#125; /// 是否是 get delete header 三种请求中第一个 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; if (query &amp;&amp; query.length &gt; 0) &#123; /// 如果是的话，直接把 query信息拼到 uri 后面 mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @"&amp;%@" : @"?%@", query]]; &#125; &#125; else &#123; // #2864: an empty string is a valid x-www-form-urlencoded payload if (!query) &#123; query = @""; &#125; if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) &#123; [mutableRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"]; &#125; /// 如果不是上述几种，把 query 信息放到 http body 里 [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; &#125; return mutableRequest;&#125; 如果是 get，delete，header 中的一个，那么就会直接把 query 信息拼到 uri 上，其他的都会塞到 body 中。 如果有自定义序列化方法会调用自定义的方法将 param 序列化成字符串。一般情况下我们可能不需要自定义的序列化方法，不过有些时候，比如说想通过 get 请求传递一个数组，服务端有自己的解析逻辑，那么数组如何展开就要通过自定义的序列化方式进行了： 123- (void)setQueryStringSerializationWithBlock:(NSString *(^)(NSURLRequest *, id, NSError *__autoreleasing *))block &#123; self.queryStringSerialization = block;&#125; 没有就通过默认的方式，即 AFQueryStringFromParametors() 方法： 123456789101112131415161718192021222324252627282930313233343536/// 将传入的 parameters 字典转为数组，数组中的保存的是包含 key value 的 AFQueryStringPair 对象。/// 注意如果字典中包含字典，那么 key 的形式是 “a[b]” 的方式保存；如果字典中包含数组，那么 key 的形式是 “a[]” 的方式保存NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123; return AFQueryStringPairsFromKeyAndValue(nil, dictionary);&#125;NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123; NSMutableArray *mutableQueryStringComponents = [NSMutableArray array]; NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"description" ascending:YES selector:@selector(compare:)]; if ([value isKindOfClass:[NSDictionary class]]) &#123; NSDictionary *dictionary = value; // Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; id nestedValue = dictionary[nestedKey]; if (nestedValue) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@"%@[%@]", key, nestedKey] : nestedKey), nestedValue)]; &#125; &#125; &#125; else if ([value isKindOfClass:[NSArray class]]) &#123; NSArray *array = value; for (id nestedValue in array) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@"%@[]", key], nestedValue)]; &#125; &#125; else if ([value isKindOfClass:[NSSet class]]) &#123; NSSet *set = value; for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123; [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)]; &#125; &#125; else &#123; [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]]; &#125; return mutableQueryStringComponents;&#125; 这种序列化方式是最常见的方式数组以 a[]=xxx&amp;a[]=yyy&amp;a[]=zzz 的形式提交，字典以a[b]=xxx&amp;a[c]=yyy&amp;a[d]=zzz 的方式提交。 不过这种一般以 json 的方式提交会更方便。 multipart/form-data这种类型的请求上面已经讲了很多了，需要一个 NSInputStream: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(method); NSParameterAssert(![method isEqualToString:@"GET"] &amp;&amp; ![method isEqualToString:@"HEAD"]); /// 生成普通的 urlrequest NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error]; __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; if (parameters) &#123; /// 循环拿到参数，判断 value 是否是 NSData，然后创建 AFHTTPBodyPart 实例，把NSData转为NSInputStream for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) &#123; data = pair.value; &#125; else if ([pair.value isEqual:[NSNull null]]) &#123; data = [NSData data]; &#125; else &#123; data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[pair.field description]]; &#125; &#125; &#125; if (block) &#123; block(formData); &#125; return [formData requestByFinalizingMultipartFormData];&#125;- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; /// 把 bodyStream 设置给 request [self.request setHTTPBodyStream:self.bodyStream]; /// 设置 content-type 和 content-length [self.request setValue:[NSString stringWithFormat:@"multipart/form-data; boundary=%@", self.boundary] forHTTPHeaderField:@"Content-Type"]; [self.request setValue:[NSString stringWithFormat:@"%llu", [self.bodyStream contentLength]] forHTTPHeaderField:@"Content-Length"]; return self.request;&#125; 它会把所有的参数都转为 NSData 的形式，然后转为 NSInputStream，设置给 request。 特殊的 request1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- (NSMutableURLRequest *)requestWithMultipartFormRequest:(NSURLRequest *)request writingStreamContentsToFile:(NSURL *)fileURL completionHandler:(void (^)(NSError *error))handler&#123; NSParameterAssert(request.HTTPBodyStream); NSParameterAssert([fileURL isFileURL]); NSInputStream *inputStream = request.HTTPBodyStream; NSOutputStream *outputStream = [[NSOutputStream alloc] initWithURL:fileURL append:NO]; __block NSError *error = nil; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [inputStream open]; [outputStream open]; while ([inputStream hasBytesAvailable] &amp;&amp; [outputStream hasSpaceAvailable]) &#123; uint8_t buffer[1024]; NSInteger bytesRead = [inputStream read:buffer maxLength:1024]; if (inputStream.streamError || bytesRead &lt; 0) &#123; error = inputStream.streamError; break; &#125; NSInteger bytesWritten = [outputStream write:buffer maxLength:(NSUInteger)bytesRead]; if (outputStream.streamError || bytesWritten &lt; 0) &#123; error = outputStream.streamError; break; &#125; if (bytesRead == 0 &amp;&amp; bytesWritten == 0) &#123; break; &#125; &#125; [outputStream close]; [inputStream close]; if (handler) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; handler(error); &#125;); &#125; &#125;); NSMutableURLRequest *mutableRequest = [request mutableCopy]; mutableRequest.HTTPBodyStream = nil; return mutableRequest;&#125; 这个方法有点特殊，它把 request 的输入流直接连向了本地的输出流。将输入流里的数据，直接写到了本地的 fileURL 中。不太明白其中的用意，以及使用场景。 AFHTTPRequestSerializer 的两个子类AFJSONRequestSerializer该类用于发送 application/json 请求。它仅重写了 AFHTTPRequestSerializer 的一个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) &#123; [mutableRequest setValue:@"application/json" forHTTPHeaderField:@"Content-Type"]; &#125; if (![NSJSONSerialization isValidJSONObject:parameters]) &#123; if (error) &#123; NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey: NSLocalizedStringFromTable(@"The `parameters` argument is not valid JSON.", @"AFNetworking", nil)&#125;; *error = [[NSError alloc] initWithDomain:AFURLRequestSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo]; &#125; return nil; &#125; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]; if (!jsonData) &#123; return nil; &#125; [mutableRequest setHTTPBody:jsonData]; &#125; return mutableRequest;&#125; 将传入的参数转为了 JSON 的形式，设置为 request 的 HTTPBody AFPropertyListRequestSerializer它和上面的类似，也是重写了同样的方法，用于发送 application/x-plist 请求： 12345678910111213141516171819202122232425262728293031323334- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error&#123; NSParameterAssert(request); if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123; return [super requestBySerializingRequest:request withParameters:parameters error:error]; &#125; NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123; if (![request valueForHTTPHeaderField:field]) &#123; [mutableRequest setValue:value forHTTPHeaderField:field]; &#125; &#125;]; if (parameters) &#123; if (![mutableRequest valueForHTTPHeaderField:@"Content-Type"]) &#123; [mutableRequest setValue:@"application/x-plist" forHTTPHeaderField:@"Content-Type"]; &#125; NSData *plistData = [NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]; if (!plistData) &#123; return nil; &#125; [mutableRequest setHTTPBody:plistData]; &#125; return mutableRequest;&#125; 它通过 NSPropertyListSerialization 将参数转为了 plist 的形式。 总结本篇讲了创建 NSMutableURLRequest 的过程。request 的 content-type 分为四种形式： application/x-www-form-urlencoded application/json application/x-plist multipart/form-data 前三种都是将参数以 NSData 的形式设置给 request 的 HTTPBody，最后一种则是通过 NSInputStream 设置给 request 的 HTTPBodyStream 。 第一种将参数以 a=x&amp;b=y&amp;c=z 的形式连接，需要对生成的字符串转码。 第二种将参数转为 json 再转为 NSData，直接设置给 request 就可以了。 第三种将参数通过 NSPropertyListSerialization 直接转为 NSData，设置给 request 第四种将参数以符合特定规则的 boundary 分割，可以传递文件。用 AFHTTPBodyPart 作为每一个参数的模型，AFMultipartBodyStream 作为输入流，包含所有参数，重写 read:maxLength: 方法，提供 buffer 给 request。AFStreamingMultipartFormData 作为 AFMultipartBodyStream 的管理者，将 AFHTTPBodyPart 设置给它，并且是它和 request 的桥梁。 其中只有第四种方式需要自己手动计算 content-Length，其他都由框架通过 NSData 自己获取。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking 源码解析 - 发送请求]]></title>
    <url>%2F2018%2F12%2F23%2FAFNetworking4%2F</url>
    <content type="text"><![CDATA[本篇是 AFNetworking 源码解读的第一篇。主要来了解如何通过 AFNetworking 发送网络请求 AFHTTPSessionManager我们在写需求的时候很少碰到直接使用 NSURLSession 的情况，都是使用 AFHTTPSessionManager 的封装(虽然我们一般还要再封装一层)。 AFHTTPSessionManager 是 AFURLSessionManager 的子类，属于对外调用的接口，承担了小部分的功能，主要实现还是在 AFURLSessionManager 中 初始化AFHTTPSessionManager 的初始化方法最终来到这里： 123456789101112131415161718192021- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration&#123; self = [super initWithSessionConfiguration:configuration]; if (!self) &#123; return nil; &#125; // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@"/"]) &#123; url = [url URLByAppendingPathComponent:@""]; &#125; self.baseURL = url; /// 设置请求和返回的序列化对象 self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self;&#125; 参数接收一个 NSURLSessionConfiguration 实例，它是创建 NSURLSession 需要的配置项。同时它保存了 baseURL，并且创建了请求和响应序列化对象 requestSerializer 和 responseSerializer。 几个 set 方法初始化的时候，创建了默认的 AFHTTPRequestSerializer 和 AFJSONResponseSerializer。如果有特殊的 content-type 的请求或者相应，那么就需要定义序列化对象，因此提供了两个 set 方法，分别设置请求和响应序列化对象。 还有一个关于安全策略的 set 方法，用来设置 HTTPS 下，证书的校验策略。 1234567891011121314151617181920212223242526272829303132#pragma mark - 设置请求返回序列化对象- (void)setRequestSerializer:(AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; *)requestSerializer &#123; NSParameterAssert(requestSerializer); _requestSerializer = requestSerializer;&#125;- (void)setResponseSerializer:(AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; *)responseSerializer &#123; NSParameterAssert(responseSerializer); [super setResponseSerializer:responseSerializer];&#125;@dynamic securityPolicy;#pragma mark - 设置安全策略- (void)setSecurityPolicy:(AFSecurityPolicy *)securityPolicy &#123; /// 如果SSLPinningMode是有安全策略的，但是请求的 scheme 不是 https 的，那么就要报错。因为安全策略必须要在 https 模式下 if (securityPolicy.SSLPinningMode != AFSSLPinningModeNone &amp;&amp; ![self.baseURL.scheme isEqualToString:@"https"]) &#123; NSString *pinningMode = @"Unknown Pinning Mode"; switch (securityPolicy.SSLPinningMode) &#123; case AFSSLPinningModeNone: pinningMode = @"AFSSLPinningModeNone"; break; case AFSSLPinningModeCertificate: pinningMode = @"AFSSLPinningModeCertificate"; break; case AFSSLPinningModePublicKey: pinningMode = @"AFSSLPinningModePublicKey"; break; &#125; NSString *reason = [NSString stringWithFormat:@"A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)", pinningMode]; @throw [NSException exceptionWithName:@"Invalid Security Policy" reason:reason userInfo:nil]; &#125; /// 给 URL 设置安全策略 [super setSecurityPolicy:securityPolicy];&#125; 语义化请求方法AFN 提供了进行不同方式请求的方法封装，这里进列举 get 和 post 两个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243/// get 的正真方法带有 progress 参数- (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))downloadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure&#123; /// 创建 NSURLSessionDataTask NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET" URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; [dataTask resume]; return dataTask;&#125;- (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure&#123; return [self POST:URLString parameters:parameters progress:nil success:success failure:failure];&#125;/// post 方法 带 progress 参数的- (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure&#123; NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"POST" URLString:URLString parameters:parameters uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure]; [dataTask resume]; return dataTask;&#125; 他们调用了另一个方法后，就生成了一个 NSURLSessionDataTask 实例对象，并且通过 resume 方法开启网络请求。 那么创建 NSURLSessionDataTask 的方法做了什么呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041/// 不带 constructingBodyWithBlock 创建 NSURLSessionDataTask- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure&#123; NSError *serializationError = nil; /// 通过 requestSerializer 创建 NSMutableURLRequest NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; if (serializationError) &#123; if (failure) &#123; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123; failure(nil, serializationError); &#125;); &#125; return nil; &#125; __block NSURLSessionDataTask *dataTask = nil; /// 通过 request 创建 dataTask. 这是 AFURLSessionManager 中的方法 dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123; if (error) &#123; if (failure) &#123; failure(dataTask, error); &#125; &#125; else &#123; if (success) &#123; success(dataTask, responseObject); &#125; &#125; &#125;]; return dataTask;&#125; 首先通过前面的请求序列化类创建一个 NSMutableURLRequest 然后使用它创建 NSURLSessionDataTask，不过创建方法不在本类中，而是在它的父类中。这个将稍后再看。 可以看到，在经过一系列的封装之后，发送一个网络请求需要的 NSMutableURLRequest，NSURLSession，NSURLSessionDataTask 都通过 AFN 创建了，而自己只需要负责传入请求，参数和回调即可。 发送 form-data 请求上面的 get，post 方法无法发送文件，因此，AFN 提供了一个方法用来发送 form-data 类型的请求： 123456789101112131415161718192021222324252627282930313233343536373839/// post 方法带 constructingBodyWithBlock 的/// constructingBodyWithBlock 参数 formData 会被添加到 http body 中- (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure&#123; NSError *serializationError = nil; /// 初始化一个 request，包含了参数以及生成 http body 中的 constructingBodyWithBlock NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; /// 序列化错误 if (serializationError) &#123; if (failure) &#123; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123; failure(nil, serializationError); &#125;); &#125; return nil; &#125; __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123; if (error) &#123; if (failure) &#123; failure(task, error); &#125; &#125; else &#123; if (success) &#123; success(task, responseObject); &#125; &#125; &#125;]; [task resume]; return task;&#125; 该方法会发起一个 form-data 类型的请求。你可以将 NSData 放入 param 中，由 AFN 进行序列化。也可以拿到 constructingBodyWithBlock 中的 block，通过 AFMultipartFormData 协议的方法，向其中添加 fileURL，来告诉 AFN 去序列化该地址下的文件。 AFURLSessionManagerAFURLSessionManager 是 AFN 请求的核心。它遵循了下面几个协议： NSURLSessionTaskDelegate NSURLSessionDataDelegate NSURLSessionDownloadDelegate NSURLSessionDelegate AFURLSessionManager 的属性AFURLSessionManager 中包含了非常多的实现协议时自定义的 block： 123456789101112131415161718192021222324252627282930313233343536373839404142@interface AFURLSessionManager ()/// 执行响应的队列@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;/// task &lt;=&gt; 代理@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;/// session 的 taskDescription 都是相同的@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;// NSURLSessionDelegate/// 由于系统原因导致会话失效时的回调@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;/// 连接服务器，接收到认证请求时，可以返回指定的认证选项@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;/// 当应用进入后台时创建的后台会话的相关任务均执行完毕时，该回调在主队列中被执行@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;// NSURLSessionTaskDelegate/// 接收到重定向反馈时，该代码块可以指定重定向的链接@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;///当数据任务被要求进行证书加密时，该代码块可以指定相关选择项，如使用证书、默认处理、取消请求@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;/// 任务需要流传递数据给服务端时，该代码块可以返回一个输入流@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;/// 当数据上传时，该代码回调可以用来获取本次上传的字节数、已经上传的字节数、该任务需要上传的总字节数@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;/// 当任务结束时，该代码回调会被执行，可以获取错误信息，如果有的话@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;// NSURLSessionDataDelegate/// 当数据任务接收到服务器响应时，该回调可以选择取消或允许等选项@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;/// 当数据任务将转变为数据下载任务时，该回调可以进行一些处理，回调参数中包含了原任务，和将要转变为的目标任务@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;/// 当接收到服务端数据时，该回调被执行@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;/// 将要缓存响应报文时，可以对返回的响应报文进行一些处理，回调参数中包含了 NSCachedURLResponse 的实例对象，也是即将返回的实例@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;// NSURLSessionDownloadDelegate/// 当下载任务结束时，该回调代码块可以指定下载的缓存数据移动到的目标地址@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;/// 在数据下载的过程中，该回调会被调用，其参数包含有本次下载的数据字节数、已经下载的字节数、该任务需要下载的总字节数@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;/// 当下载任务再次启动时，该回调执行，回调参数包含有文件的字节偏移量和整个文件的字节长度@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;@end AFURLSessionManager 的方法初始化方法初始化方法中创建了请求需要使用的各种基本属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma mark - 初始化方法- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; /// 创建 NSURLSession self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; self.responseSerializer = [AFJSONResponseSerializer serializer]; self.securityPolicy = [AFSecurityPolicy defaultPolicy]; self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; /// 为session的所有task设置 delegate /// 做清空处理，有一种后台session，当从后台回来的时候，根据 configuration 中的一个 ID，就可以重新恢复这个session，这时候其中就会有之前未完成的task了。这里这么做的目的就是防止一些之前的后台请求任务，导致程序的crash。 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125; 创建 Task创建的 Task 分为三种，普通的 dataTask，上传的 uploadTask 和下载的 downloadTask。 dataTask在 AFHTTPSessionManager 中已经创建好了 NSURLRequest 对象，调用以下方法创建 NSURLSessionDataTask 对象实例： 1234567891011121314151617181920212223- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; return [self dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:completionHandler];&#125;/// c通过 request 创建 dataTask- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; __block NSURLSessionDataTask *dataTask = nil; /// iOS8下可能会创建多个 task url_session_manager_create_task_safely(^&#123; dataTask = [self.session dataTaskWithRequest:request]; &#125;); /// 给 dataTask 创建 delegate [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125; 除了简单调用 NSURLSession 的 API 生成实例外，AFURLSessionManager 还需要给生成的 dataTask 创建一个代理对象。这个下面就会说到。 uploadTaskuploadTask 在 AFHTTPSessionManager 中没有使用，AFHTTPSessionManger 提供的方法中要想实现上传功能，需要自己把文件转为 NSData 后通过参数上传。而 uploadTask 是自己通过输入流的方式将数据写入到了 request 中。使用 uploadTask 则能更加方便的交由 NSURLSession 完成相应的任务。只需要传入文件路径，data，或者输入流即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - 生成 uploadTask/// 通过文件路径上传- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;/// 通过data上传- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125;/// 通过流上传- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125; 同样的，每一个 dataTask 都会设置一个 delegate。 downloadTaskdownloadTask 分为两个部分，一个是创建，一个是断线续传： 123456789101112131415161718192021222324252627282930313233#pragma mark - 生成 downloadTask/// 创建下载任务- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithRequest:request]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125;/// 继续下载- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; __block NSURLSessionDownloadTask *downloadTask = nil; url_session_manager_create_task_safely(^&#123; downloadTask = [self.session downloadTaskWithResumeData:resumeData]; &#125;); [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler]; return downloadTask;&#125; 如果你不熟悉 NSURLSessionDownloadTask 那么你一定会很疑惑下面这个继续下载为什么只要传一个 resumeData 就可以知道下载的所有信息的。其实这个 resumeData 并不是下载的数据，而是下载数据的信息的 plist 生成的 NSData，其中包含了下载所需要的各种信息，包括本地缓存的路径名，下载的地址，当前下载了多少等。 为 task 创建代理task 请求过程中的请求中请求完成的回调都是通过 delegate 完成的。delegate 是一个 AFURLSessionManagerTaskDelegate 实例。添加代理的过程就是创建实例并设置回调方法的过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// 设置 task 的代理； 代理包含了 task 的各种回调。- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task&#123; NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock];&#125;/// 给 datatask 增加代理对象- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; /// 创建一个 dataTask 的代理 AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; delegate.manager = self; delegate.completionHandler = completionHandler; /// 设置 taskDescription 有助于区别是否是 AFN 创建的 task dataTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:dataTask]; delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125;- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:uploadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; uploadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:uploadTask]; delegate.uploadProgressBlock = uploadProgressBlock;&#125;- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler&#123; AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:downloadTask]; delegate.manager = self; delegate.completionHandler = completionHandler; if (destination) &#123; delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123; return destination(location, task.response); &#125;; &#125; downloadTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:downloadTask]; delegate.downloadProgressBlock = downloadProgressBlock;&#125; 每一个生成的 task 和它的代理都会保存在 manager 的 mutableTaskDelegatesKeyedByTaskIdentifier 中。当然其实也可以通过给 task 添加关联对象的方式保存 delegate。 协议方法上面说到了 AFURLSessionManager 实现了 NSURLSession 相关的四个代理。下面来分别看看： NSURLSessionDelegate如果有相关的 block 那么就执行相关的 block，没有 block 也可以通过监听相应的 notification ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/// 因为异常终止请求- (void)URLSession:(NSURLSession *)sessiondidBecomeInvalidWithError:(NSError *)error&#123; if (self.sessionDidBecomeInvalid) &#123; self.sessionDidBecomeInvalid(session, error); &#125; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];&#125;/// 证书校验- (void)URLSession:(NSURLSession *)sessiondidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; /// 默认的处理方式 NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.sessionDidReceiveAuthenticationChallenge) &#123; /// 自己的处理方式 disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); &#125; else &#123; /// 需要验证证书 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; /// serverTrust 是服务端的证书链 if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; /// 验证通过 credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; /// 验证不通过取消请求 disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; /// 返回验证解果 completionHandler(disposition, credential); &#125;&#125;/// 后台任务完成后的回调- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; if (self.didFinishEventsForBackgroundURLSession) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.didFinishEventsForBackgroundURLSession(session); &#125;); &#125;&#125; NSURLSessionTaskDelegate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/// 重定向操作- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; NSURLRequest *redirectRequest = request; if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;/// 使用方法和 session 的那个一致- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;/// 请求需要一个全新的，未打开的数据时调用。特别是请求一个body失败时，可以通过这个方法给一个新的body- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;/// 上传数据那一刻调用- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; /// 数据的总长度 int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@"Content-Length"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; /// 获取 task 对应的 delegate AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; if (delegate) &#123; /// 调用 delegate 的回调方法，设置已经上传了的长度和总共需要上传的长度 [delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend]; &#125; if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;/// 上传完成时- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125; 在发送请求的时候，将请求的总数据和已发送的数据通过 delegate 的相应方法保存下来： 123456789/// AFURLSessionManagerTaskDelegate 中- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend; self.uploadProgress.completedUnitCount = task.countOfBytesSent;&#125; 在请求完成时，又调用了 delegate 的相应方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// AFURLSessionManagerTaskDelegate 中- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; if (error) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; /// 请求成功，异步处理返回的数据 dispatch_async(url_session_manager_processing_queue(), ^&#123; NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;&#125; 这里 AFN 除了调用回调以及发送通知外，我们还可以发现使用了 dispatch_group_async。它可以帮助我们做一些多个请求同步的操作。url_session_manager_completion_group() 方法提供了一个 group： 123456789static dispatch_group_t url_session_manager_completion_group() &#123; static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; af_url_session_manager_completion_group = dispatch_group_create(); &#125;); return af_url_session_manager_completion_group;&#125; 我们可以在外部通过 AFN 发起多个请求，然后通过 url_session_manager_completion_group() 方法提供的 group，在请求完成后统一执行。当然其实我们亦可以在各个请求的完成回调中通过信号量的方式执行。不过那样就有点不是那么优雅了。 NSURLSessionDataDelegate12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma mark - NSURLSessionDataDelegate/// 收到响应时调用，可以选择取消或者允许响应- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;/// 当NSURLSessionDataTask变为NSURLSessionDownloadTask调用，之后NSURLSessionDataTask将不再接受消息- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; /// 移除 dataTask [self removeDelegateForTask:dataTask]; /// 设置 downloadTask [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;/// 收到数据后调用- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; /// 调用 delegate 把 data 收集起来 [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;/// 缓存报文时调用- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125; 主要关系受到数据后的回调方法，它把接收到的 data 传给了 delegate： 12345678910/// AFURLSessionManagerTaskDelegate 中- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive; self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived; [self.mutableData appendData:data];&#125; 前面请求完成时传给 responseSerializer 的就是这里 mutableData 拼接好的数据。它把每次收到的数据都拼接起来，等待请求完成。 NSURLSessionDownloadDelegate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#pragma mark - NSURLSessionDownloadDelegate/// 下载完成调用- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (self.downloadTaskDidFinishDownloading) &#123; /// 获取下载数据要保存的地址 NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; /// 移动下载的数据到指定地址 if (![[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125;/// 下载中调用- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite]; &#125; if (self.downloadTaskDidWriteData) &#123; self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); &#125;&#125;/// 恢复下载调用- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes]; &#125; if (self.downloadTaskDidResume) &#123; self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes); &#125;&#125; NSURLSession 中的下载由系统自动做了边下边存的过程。因此，我们要在下载完成之后把缓存的路径上的文件保存到实际的路径上。所以下载的时候要给 manager 传入一个 downloadTaskDidFinishDownloading 的 block，告知下载完成时候安放的路径。 总结AFHTTPSessionManager 和 AFURLSessionManager 是我们使用 AFN 的入口。AFHTTPSessionManager 作为子类，封装了简单 dataTask 请求。它还负责将请求参数拼接以及转码。 对于上传文件的操作，仍然可以使用 AFHTTPSessionManager 创建 content-type 为 form-data 的请求，但是这就需要自己把文件转为 NSData 或者 NSInputStream 类型，设置给 request。如果想要更方便的方式完成，可以使用 AFURLSessionManager 提供的 upload 方法创建的 uploadTask，只需要给出 fileURL 即可。 AFURLSessionManager 负责创建 NSURLSession，并承担了发送请求需要实现的所有协议。针对每一个 task，为其增加一个代理对象。当 AFURLSessionManager 接收到NSURLSessionDataDelegate 的接收 data 的回调的时候，就会把 data 交给 task 对应的 delegate 保存。当接收到 NSURLSessionTaskDelegate 的完成回调的时候，就会告知 task 对应 delegate，让其执行回调方法。 同时 AFURLSessionManager 实现的 NSURLSessionDelegate 还包含了 HTTPS 证书校验的策略，通过它验证证书信息。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YYCache 源码解析]]></title>
    <url>%2F2018%2F11%2F30%2Fyycache%2F</url>
    <content type="text"><![CDATA[YYCache 的源码解析 基本使用创建创建 Cache 实例，之后的所有操作都是通过它。 1YYCache *cache = [YYCache cacheWithName:@"cacheName"]; 使用方法一览之前创建的 YYCache *cache 的实例方法。包含了读取、写入，移除的所有相关方法 123456789101112131415161718192021222324252627//是否包含某缓存，无回调- (BOOL)containsObjectForKey:(NSString *)key;//是否包含某缓存，有回调- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;c//获取缓存对象，无回调- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;//获取缓存对象，有回调- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;//写入缓存对象，无回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;//写入缓存对象，有回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;//移除某缓存，无回调- (void)removeObjectForKey:(NSString *)key;//移除某缓存，有回调- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;//移除所有缓存，无回调- (void)removeAllObjects;//移除所有缓存，有回调- (void)removeAllObjectsWithBlock:(void(^)(void))block;//移除所有缓存，有进度和完成的回调- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end; 结构 YYCache：最外层接口，调用了YYMemoryCache与YYDiskCache的相关方法。 YYMemoryCache：负责内存缓存 _YYLinkedMap：内存缓存进行 LRU 所使用的双向链表类 _YYLinkedMapNode：是 _YYLinkedMap 使用的节点类。 YYDiskCache：负责磁盘缓存 YYKVStorage：YYDiskCache 的实现类，用于管理磁盘缓存。 YYKVStorageItem：YYKVStorage 内部用于封装某个缓存的类。 源码分析YYCache初始化123456789101112131415161718192021222324- (instancetype)initWithName:(NSString *)name &#123; if (name.length == 0) return nil; // 根据传入的 cache 名字创建对应路径 NSString *cacheFolder = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; NSString *path = [cacheFolder stringByAppendingPathComponent:name]; return [self initWithPath:path];&#125;- (instancetype)initWithPath:(NSString *)path &#123; if (path.length == 0) return nil; // 根据路径创建磁盘缓存 YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path]; if (!diskCache) return nil; NSString *name = [path lastPathComponent]; // 新建一个内存缓存 YYMemoryCache *memoryCache = [YYMemoryCache new]; memoryCache.name = name; self = [super init]; _name = name; _diskCache = diskCache; _memoryCache = memoryCache; return self;&#125; 是否存在1234- (BOOL)containsObjectForKey:(NSString *)key &#123; // 先判断是否在内存缓存中，如果不在那么判断是否在磁盘缓存中 return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];&#125; 获取缓存12345678910111213- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; // 先从内存缓存获取 id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; if (!object) &#123; // 不在内存缓存中，那么从磁盘缓存中获取 object = [_diskCache objectForKey:key]; if (object) &#123; // 如果存在于磁盘缓存中，那么存入内存缓存中 [_memoryCache setObject:object forKey:key]; &#125; &#125; return object;&#125; 设置缓存123456- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; // 存入内存缓存 [_memoryCache setObject:object forKey:key]; // 存入磁盘缓存 [_diskCache setObject:object forKey:key];&#125; 移除缓存12345678910// 先移除内存缓存，再移除磁盘缓存- (void)removeObjectForKey:(NSString *)key &#123; [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key];&#125;- (void)removeAllObjects &#123; [_memoryCache removeAllObjects]; [_diskCache removeAllObjects];&#125; YYMemoryCache概览初始化1234567891011121314151617181920212223242526272829303132@implementation YYMemoryCache &#123; // 🔐实例 pthread_mutex_t _lock; // 内存缓存存放处 _YYLinkedMap *_lru; // 自己创建的队列 dispatch_queue_t _queue;&#125;- (instancetype)init &#123; self = super.init; // 创建锁 pthread_mutex_init(&amp;_lock, NULL); // 创建双向链表保存内存缓存数据 _lru = [_YYLinkedMap new]; // 自己创建的串行队列，主要用在 trim 的时候，保证在后台的操作按顺序执行 _queue = dispatch_queue_create("com.ibireme.cache.memory", DISPATCH_QUEUE_SERIAL); ... (省略清除数据的策略配置) // 开启定时清理 [self _trimRecursively]; return self;&#125;- (void)dealloc &#123; ... // 由于内部缓存内部是双向链表，所以需要手动清空，以防内存泄漏 [_lru removeAll]; // 回收锁 pthread_mutex_destroy(&amp;_lock);&#125; 方法YYMemoryCache 包含两类方法，一类是操作内存缓存的方法，一类是缓存自动清理的方法： 123456789101112131415161718192021222324252627282930#pragma mark - Access Methods// =========== 操作缓存数据接口 =========== //是否包含某个缓存- (BOOL)containsObjectForKey:(id)key;//获取缓存对象- (nullable id)objectForKey:(id)key;//写入缓存对象- (void)setObject:(nullable id)object forKey:(id)key;//写入缓存对象，并添加对应的开销- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;//移除某缓存- (void)removeObjectForKey:(id)key;//移除所有缓存- (void)removeAllObjects;#pragma mark - Trim// =========== 缓存清理接口 =========== //清理缓存到指定个数- (void)trimToCount:(NSUInteger)count;//清理缓存到指定开销- (void)trimToCost:(NSUInteger)cost;//清理缓存时间小于指定时间的缓存- (void)trimToAge:(NSTimeInterval)age; _YYLinkedMap概览_YYLinkedMap 是保存内存缓存的实例。内置了一个字典和一个双向链表用于保存数据，两者分工不同。字典是用来快速存取节点的，双向链表则是用来进行缓存淘汰的，双向链表有助于快速移动节点。 123456789101112131415161718192021222324252627@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 用于存放节点 NSUInteger _totalCost; //总开销 NSUInteger _totalCount; //节点总数 _YYLinkedMapNode *_head; // 链表的头部结点 _YYLinkedMapNode *_tail; // 链表的尾部节点 BOOL _releaseOnMainThread; //是否在主线程释放，默认为NO BOOL _releaseAsynchronously; //是否在子线程释放，默认为YES&#125;//在链表头部插入某节点- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;//将链表内部的某个节点移到链表头部- (void)bringNodeToHead:(_YYLinkedMapNode *)node;//移除某个节点- (void)removeNode:(_YYLinkedMapNode *)node;//移除链表的尾部节点并返回它- (_YYLinkedMapNode *)removeTailNode;//移除所有节点（默认在子线程操作）- (void)removeAll;@end 方法实现_YYLinkedMap 中的方法都是用来操作节点的，稍微熟悉数据结构的人都能看懂。这里不详细分析，只举两个例子。 插入节点 插入节点需要先把键值对存到字典中，然后将节点插入链表的头部，是一个操作链表的基本操作。 1234567891011121314- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; // 插入节点需要先把键值对保存到字典中 CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); //增加开销和总缓存数量 _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; node-&gt;_next = _head; _head-&gt;_prev = node; _head = node; &#125; else &#123; _head = _tail = node; &#125;&#125; 移除节点 移除节点要先把保存的键值对移除，然后减少缓存中的总开销。 1234567891011- (void)removeNode:(_YYLinkedMapNode *)node &#123; // 将节点的键值对移除 CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); // 减少开销 _totalCost -= node-&gt;_cost; _totalCount--; if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; if (_head == node) _head = node-&gt;_next; if (_tail == node) _tail = node-&gt;_prev;&#125; 缓存策略YYMemoryCache 的操作类似于 NSCache，它们的不同之处在于： YYMemoryCache 使用 LRU(least-recently-used) 算法来清理使用频率较低的缓存；NSCache 的淘汰方式不确定 YYMemoryCache 使用三个维度 count（缓存数量），cost（开销），age（距上一次的访问时间）控制缓存清除；NSCache 不确定 YYMemoryCache 可以配置收到内存警告或者进入后台时自动清除缓存。 LRU 算法的思想就是优先保存最近用过的数据。将最近使用的节点放到链表的头部，并且优先淘汰链表尾部的数据。 方法实现缓存相关方法缓存相关方法比较类似，我们这里只举两个例子 获取缓存对象 123456789101112- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); // 获取到了缓存的对象就需要把节点移动到最前面，并且更新时间 if (node) &#123; node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125; 获取对象以及对链表进行操作的时候注意要加锁 设置缓存对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; if (!key) return; // 没有传 object，就直接移除 if (!object) &#123; [self removeObjectForKey:key]; return; &#125; // 加锁 pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; // 存在 node 就更新 node，并且把 node 移到链表最前面 _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; [_lru bringNodeToHead:node]; &#125; else &#123; // 不存在 node 就新建一个 node，然后存储 node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; [_lru insertNodeAtHead:node]; &#125; // 如果缓存总消耗超过了限制，那么异步淘汰末端缓存 if (_lru-&gt;_totalCost &gt; _costLimit) &#123; dispatch_async(_queue, ^&#123; [self trimToCost:_costLimit]; &#125;); &#125; // 如果缓存总量超过了限制，那么清楚最后一个 if (_lru-&gt;_totalCount &gt; _countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; // 在主线程或者子线程释放 if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125; 这里有一个关于淘汰的缓存再哪里释放的技巧，即最后在哪个线程调用，就在哪个线程释放。 缓存清理相关方法缓存清理包含两种情况。一种是主动添加缓存之后的主动触发，还有一种是周期性的后台触发。创建 YYCache 时调用的 _trimRecursively 方法就会触发周期性的后台触发： 12345678910111213141516171819202122232425262728293031//YYMemoryCache.m- (instancetype)init&#123; ... //开始定期清理 [self _trimRecursively]; ...&#125;//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行- (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; //在后台进行清理操作 [self _trimInBackground]; //调用自己，递归操作 [self _trimRecursively]; &#125;);&#125;//清理所有不符合限制的缓存，顺序为：cost，count，age- (void)_trimInBackground &#123; dispatch_async(_queue, ^&#123; [self _trimToCost:self-&gt;_costLimit]; [self _trimToCount:self-&gt;_countLimit]; [self _trimToAge:self-&gt;_ageLimit]; &#125;);&#125; 缓存清理有三个维度包括 age, count, cost。它们的实现也非常相似，这里只列举其中一个说明： cost 清理 123456789101112131415161718192021222324252627282930313233343536- (void)_trimToCost:(NSUInteger)costLimit &#123; BOOL finish = NO; // 无需清理的时候 pthread_mutex_lock(&amp;_lock); if (costLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCost &lt;= costLimit) &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; // 暂存需要清除的缓存对象数组 NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; // 尝试加锁，如果锁被占用，那么就空转 10ms，达到自旋锁的效果 if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCost &gt; costLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125; 优于 OSSpinLock 的优先级反转问题，不建议使用。因此，作者使用 tryLock 的方式尝试获得锁。 YYDiscCacheYYDiscCache 和 YYMemoryCache 的操作非常相似。不同之处在于，YYMemoryCache 将结果保存在内存中的字典中，用双向链表体现操作时间的远近。而 YYDiscCache 将结果保存在数据库中，通过表中最近更新时间体现操作时间的远近。 初始化123456789101112131415161718192021222324252627282930313233343536373839404142- (instancetype)initWithPath:(NSString *)path &#123; // 默认保存在数据库中文件大小阈值为 1024*20 return [self initWithPath:path inlineThreshold:1024 * 20]; // 20KB&#125;- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; self = [super init]; if (!self) return nil; // 保存到全局的 DiscCache 中 YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path); if (globalCache) return globalCache; YYKVStorageType type; // 根据阈值来设置存储的类型 if (threshold == 0) &#123; type = YYKVStorageTypeFile; &#125; else if (threshold == NSUIntegerMax) &#123; type = YYKVStorageTypeSQLite; &#125; else &#123; type = YYKVStorageTypeMixed; &#125; // 操作数据库的实际对象实例 YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; _kv = kv // 初始化 semaphore 锁 _lock = dispatch_semaphore_create(1); // _queue = dispatch_queue_create("com.ibireme.cache.disk", DISPATCH_QUEUE_CONCURRENT); ... [self _trimRecursively]; _YYDiskCacheSetGlobal(self); ... return self;&#125; 初始化方法。根据阈值来设置存储的 type。分为三种 type： YYKVStorageTypeFile: 阈值为0的时候，纯文件形式的存储。 YYKVStorageTypeSQLite: 阈值为无穷大的时候，纯数据库的存储 YYKVStorageTypeMixed: 阈值为特定值的时候，混合存储。大于阈值的时候用文件存储，小于阈值的时候使用数据库存储。一般情况下，都是数据库存储。 初始化的过程中，在初始化 YYKVStorage 的时候，开启了数据库。同时还创建了 dispatch_semaphore 形式的锁，以及全局处理队列。 方法缓存策略和内存缓存相似。同样的，各个磁盘缓存的方法与内存缓存的方法类似。所以这里还是只分析一个存储的方法。 YYDiskCache 中的方法，在传入要保存的键值对后，先将值归档为 NSData，然后判断其和阈值的大小，如果超过了阈值并且 type 不是只能使用数据库存储，那么生成一个文件名，之后就会以这个文件名存储。 12345678910111213141516171819202122232425262728293031323334// YYDiskCache.m- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; if (!key) return; if (!object) &#123; [self removeObjectForKey:key]; return; &#125; NSData *extendedData = [YYDiskCache getExtendedDataFromObject:object]; NSData *value = nil; if (_customArchiveBlock) &#123; value = _customArchiveBlock(object); &#125; else &#123; @try &#123; // 通过归档方法，将要保存的对象转为 NSData 对象 value = [NSKeyedArchiver archivedDataWithRootObject:object]; &#125; @catch (NSException *exception) &#123; // nothing to do... &#125; &#125; if (!value) return; NSString *filename = nil; if (_kv.type != YYKVStorageTypeSQLite) &#123; // 要保存的 value 大于阈值的之后，要创建一个 fileName，如果有 fileName，那么就文件保存，如果没有，就 sql 保存 if (value.length &gt; _inlineThreshold) &#123; filename = [self _filenameForKey:key]; &#125; &#125; Lock(); [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData]; Unlock();&#125; 生成文件名的方式是通过把 key 通过 MD5 转为 16 位的 hash 值。 123456789101112131415161718192021- (NSString *)_filenameForKey:(NSString *)key &#123; NSString *filename = nil; if (_customFileNameBlock) filename = _customFileNameBlock(key); if (!filename) filename = _YYNSStringMD5(key); return filename;&#125;/// String's md5 hash.static NSString *_YYNSStringMD5(NSString *string) &#123; if (!string) return nil; NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(data.bytes, (CC_LONG)data.length, result); return [NSString stringWithFormat: @"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7], result[8], result[9], result[10], result[11], result[12], result[13], result[14], result[15] ];&#125; 真正存储的方法是在 YYStorage 中。如果有文件名，那么优先存文件，如果不成功再尝试存入数据库。 1234567891011121314151617181920212223242526272829// YYStorage.m// 保存键值对到数据库或者本地文件的实际方法- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123; if (key.length == 0 || value.length == 0) return NO; // 如果 type 为文件存储，但是确没有 filename，那么返回失败 if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) &#123; return NO; &#125; if (filename.length) &#123; // 如果文件名不为空，那么把 data 存入文件中 if (![self _fileWriteWithName:filename data:value]) &#123; return NO; &#125; if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123; [self _fileDeleteWithName:filename]; return NO; &#125; return YES; &#125; else &#123; if (_type != YYKVStorageTypeSQLite) &#123; NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; &#125; return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData]; &#125;&#125; 12345// 将data写到文件- (BOOL)_fileWriteWithName:(NSString *)filename data:(NSData *)data &#123; NSString *path = [_dataPath stringByAppendingPathComponent:filename]; return [data writeToFile:path atomically:NO];&#125; 存入数据库中调用的方法中，先在缓存中查找 sqlite3_stmt。然后绑定参数，执行 sql。 1234567891011121314151617181920212223242526272829303132333435363738394041- (BOOL)_dbSaveWithKey:(NSString *)key value:(NSData *)value fileName:(NSString *)fileName extendedData:(NSData *)extendedData &#123; NSString *sql = @"insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);"; sqlite3_stmt *stmt = [self _dbPrepareStmt:sql]; if (!stmt) return NO; int timestamp = (int)time(NULL); sqlite3_bind_text(stmt, 1, key.UTF8String, -1, NULL); sqlite3_bind_text(stmt, 2, fileName.UTF8String, -1, NULL); sqlite3_bind_int(stmt, 3, (int)value.length); if (fileName.length == 0) &#123; sqlite3_bind_blob(stmt, 4, value.bytes, (int)value.length, 0); &#125; else &#123; sqlite3_bind_blob(stmt, 4, NULL, 0, 0); &#125; sqlite3_bind_int(stmt, 5, timestamp); sqlite3_bind_int(stmt, 6, timestamp); sqlite3_bind_blob(stmt, 7, extendedData.bytes, (int)extendedData.length, 0); int result = sqlite3_step(stmt); if (result != SQLITE_DONE) &#123; if (_errorLogsEnabled) NSLog(@"%s line:%d sqlite insert error (%d): %s", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); return NO; &#125; return YES;&#125;- (sqlite3_stmt *)_dbPrepareStmt:(NSString *)sql &#123; if (![self _dbCheck] || sql.length == 0 || !_dbStmtCache) return NULL; sqlite3_stmt *stmt = (sqlite3_stmt *)CFDictionaryGetValue(_dbStmtCache, (__bridge const void *)(sql)); if (!stmt) &#123; int result = sqlite3_prepare_v2(_db, sql.UTF8String, -1, &amp;stmt, NULL); if (result != SQLITE_OK) &#123; if (_errorLogsEnabled) NSLog(@"%s line:%d sqlite stmt prepare error (%d): %s", __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); return NULL; &#125; CFDictionarySetValue(_dbStmtCache, (__bridge const void *)(sql), stmt); &#125; else &#123; sqlite3_reset(stmt); &#125; return stmt;&#125; 几个问题为什么 YYMemoryCache 使用互斥锁 pthread_mutex，而 YYDiskCache 使用信号量 dispatch_semaphore作者通过 pthread_mutex 的 pthread_mutex_trylock() 和忙等 usleep() 来替代 OSSpinLock，这是因为使用互斥锁，没有拿到锁的线程会被挂起。当释放锁激活其他线程的时候，就唤醒挂起的线程。需要上下文切换，信号发送等开销，效率低于自旋锁。所以使用这种方式替代自旋锁。 因为 YYDiskCache 在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore 在这个时候是不消耗CPU资源的，所以比较适合。 为什么 YYMemoryCache 使用双向链表双向链表的优势在于在头尾插入或者删除的时候时间复杂度最低。而缓存的存入和清理需要频繁的头部插入，尾部删除。所以使用双向链表最为合适。 YYMemoryCache 内容使用什么数据结构保存数据的通过一个双向链表和一个字典保存。字典的作用是 O(1) 的时间内找到数据，链表的作用是为了进行 LRU 的缓存清理。 如何执行定时任务来定时清理缓存作者使用的是 dispatch_after 的延时 + 递归的方式进行定时执行操作，而不是使用 NSTimer 的 repeat 子线程释放一个对象最后在哪个线程中使用，那么最终就会在哪个线程的 runloop 中销毁。 1234567891011_YYLinkedMapNode *node = [_lru removeTailNode];if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;);&#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;);&#125; 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tips：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 思考题 YYMemoryCache 是如何实现的？ YYMemoryCache 从哪些维度维护？ YYMemoryCache 和 NSCache 有什么区别？ 如何使用互斥锁实现一个自旋锁？ 为什么 Memory 使用自旋锁，Disk 使用信号量？ Disk 的缓存策略是怎样的？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《iOS 应用逆向与安全》笔记]]></title>
    <url>%2F2018%2F10%2F31%2FiOS%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[很早就买了《iOS应用逆向与安全》这本书，现在把学到的内容总结一下。 越狱设备Cydia添加 雷锋源（apt.abcdia.com） SSHcydia 中搜索并安装 dropbear 提供 SSH 功能。连接，默认密码为 alpine 1ssh root@192.168.2.202 修改密码输入如下修改密码： 1passwd 公钥登录在目标设备的 $HOME/.ssh 目录下找 authorized_keys 文件，如果没有则自己创建。将本机的公钥复制到该文件中。 iOS系统结构文件目录要访问越狱设备的文件系统，要通过 Cydia 安装 Apple File Conduit 2. Mac 上安装 iFunBox 文件权限通过 ll 可以查看文件的权限，一般权限包括三类： 所有者权限：文件所有者进行的操作 组权限：属于该组的成员对他能进行的操作 其他人权限：其他人能进行的操作 可以通过 chmod 改变权限 Cydia SubstrateCydia Substrate 是一个框架，允许第三方开发者在越狱系统上打一些运行时的补丁和拓展一些方法，是开发越狱插件的基石。Cydia 自动安装了 Cydia Substrate，包含三个模块： MobileHooker：用于替换系统和应用的方法。提供 MSHookMessageEx 和 MSHookFunction hook OC 和 C 函数， MobileLoader：用于将第三方动态库加载到运行的目标应用里（注入 Reaveal 就是通过它）。首先通过环境变量 DYLD_INSERT_LIBRARIES 把自己加载到目标应用里，然后查找 /Library/Mobile Substrate/DynamicLibraries/ 目录下所有的 plist 文件，如果 plist 文件的配置信息符合当前的应用，则通过 dlopen 函数打开对应的 dylib 文件 Safe mode：如果插件导致 SpringBoard 崩溃，将会让设备进入安全模式，禁用所有的三方插件 调试界面的 Reveal 就是通过 MobileLoader 动态加载的 越狱必备通过 Cydia 安装一下插件： adv-cmds：提供指令 ps -A 获取全部进程的进程ID和可执行文件路径（dumpdecrypted 砸壳时候用到） appsync：修改应用的文件会导致签名验证错误，该插件会绕过系统的签名验证 ps -A 获取完整的可执行文件路径 逆向工具详解应用解密dumpdecrypteddumpdecrypted 会注入可执行文件，然后动态地从内存总 dump 出解密后的内容 github上下载，包含一个 makefile 和一个 .c 文件 $make 编译生成一个 dumpdecrypted.dylib 动态库 远程登录到手机，将生成的动态库放到 /var/root 下 在 /var/root 目录下使用环境变量 DYLD_INSERT_LIBRARIES 将 dylib 注入到要脱壳的可执行文件中 ps -A 拿到正在运行的要注入的应用的完整路径（/var/mobile/Containers/…/{应用的名字}） 终端输入 $DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib {完整路径} 进行注入 最终在 /var/root 目录下，得到的 {应用名}.decrypted 就是脱壳后的 mach-o。 可以选择使用命令 $otool -l {引用名}.decrypted | grep crypt 查看加密标识，如果有输出 cryptid 0 标识该架构已经被解密了 otool 可以用来查看 mach-o 的段信息，一样作用的还有 MachOView，是一个图形化的界面。 ClutchCluch 会生成一个新的进程，然后暂停进程，dump 内存 github上下载源码 使用 Xcode 编译，会在 build 目录下生成一个二进制文件 Clutch 远程登录到手机，将 Clutch 放到 /usr/bin 目录下，并为其添加执行权限 Clutch -i 列出所有可以脱壳的应用，以及其 BundleId Clutch -b {BundleId} 砸壳 砸完壳的 ipa 的路径会在屏幕上输出 Clutch 砸壳得到的是一个包含各种资源文件的完整的 .app Clutch -i 获取所有 BundleId class-dumpclas-dump 可以导出已砸壳应用的头文件。（未砸壳应用被加密无法获取，需要先砸壳） 官网下载 class-dump，把下载的二进制文件放到 /usr/bin 目录下。1$class-dump -H &#123;二级制文件&#125; -o &#123;文件路径&#125; class-dump 原理class-dump 主要是分析 mach-o 文件，进行加载符号，解析协议列表，解析类列表，解析分类列表 现在我们创建一个空的工程，build 之后通过 MachOView 对其进行分析。 解析协议首先通过 MachOView 找到 data 段中的 protolist。除了各种 name 和代码之外，其他信息都是在 data 段中： 可以看到 _objc_protolist 段中包含两个协议信息。字段 offset 表示可执行文件加载到内存中后的相对偏移，这个偏移是相对于 __Text 段的。 再看字段 Data 的内容，它表示加载到内存中时候的虚拟地址。先简单罗列一下虚拟地址，实际地址，offset 这三者的关系： 虚拟地址 + ALSR = 实际地址 __Text 的虚拟地址 + ALSR = __Text 的实际地址 __Text 的虚拟地址 + 对象的 offset = 对象的虚拟地址 __Text 的实际地址 + 对象的 offset = 对象的实际地址 因此，如果我们知道 __Text 的虚拟地址，就能知道 data 所表示的位置的 offset 了。__Text 段的虚拟地址的起始位置在 __Text 段中可以找到： 因为在 __Text 段之前还有一个 _PAGEZERO 段，它的大小固定为 0x100000000 因此可以计算出 data 的相对偏移为 8D30。我们来到了 __data 段： 响应位置展示了一个协议完整的信息。8D30 保存的是 ISA 的信息，偏移8个字节的 8D38 保存的是协议名的信息，它指向的位置是 76B4: 如此就可以到代码段中找到协议名的信息。 在 __data 段中查找的时候可以看到 MachOView 已经分析出了该协议的名词。整个从段信息到名词的过程就是上述的分析过程。 类解析类解析就不一步步分析了，直接看截图： Reveal Mac 端下载 Reveal 打开，在 help 里找到 Show Reveal Library in Finder -&gt; iOS Library ，打开要嵌入 iOS 应用的 framework 打开该目录后，有一个 RevealServer.framework，将其中的 mach-o 文件 RevealServer 重命名为 libReveal.dylib。 新建一个 libReveal.plist 文件，用 vim 写入要注入的 App 的 BundleId，如下所示： 1234567&#123; Filter = &#123; Bundles = ( "tv.douyu.live" ); &#125;;&#125; 将两个文件复制到手机的 /Library/MobileSubstrate/DynamicLibraries 目录下。 重启应用，就会通过 Cydia 的 MobileLoader 加载该库了。 Cycript如何用 Cycript 调试一个进程 $ps -A 获取所有运行的进程（一般在 /var/mobile/Containers 文件夹下，所以可以使用 $ps -A | grep /var/mobile/Containers 筛选更准确） cycript -p 进程名 进入调试 cmd+R 清屏，ctrl+D 退出 Cycript 语法123456789101112131415// 获取 UIApplicationcy# UIApp // 等价于 [UIApplication sharedApplication]// 定义一个变量cy# var rootViewController = UIApp.keyWindow.rootViewControllercy# var myView = [[UIView alloc] init]// 找到内存中的该类型的对象cy# choose(UIViewController)// 通过 #+内存地址 获取对象cy# #0x1234567.rootViewController// 通过 *+对象 查看所有成员变量cy# *UIApp Cycript 主要用于查看控制器的层级、对象的成员变量以及动态调试界面 编写 Cycript 库编写 Cycript 库文件 test.cy:12345678910111213(function(exports) &#123; // 递归打印 VC 层级 ChildVcs = function(vc) &#123; if (![vc isKindOfClass:[UIViewController class]]) throw new Error(invalidParamStr); return [vc _printHierarchy].toString(); &#125;; // 递归打印view的层级结构 Subviews = function(view) &#123; if (![view isKindOfClass:[UIView class]]) throw new Error(invalidParamStr); return view.recursiveDescription().toString(); &#125;;&#125;)(exports); 然后将文件放入 usr/lib/cycript0.9 文件夹下。12cy# @import testcy# ChildVcs(#0x12345678) TODO： 增加获取属性和方法的相关库方法 Apple Configurator 2获取 ipa 包我们可以通过 Apple Configurator 2 获取应用的 ipa 包。 手机连接上 Mac 之后，Apple Configurator 2 中会显示出手机的信息。这个时候点击添加应用，在 app store 中搜索你想要获取资源的引用： 搜索到之后点击下载。如果手机中没有目标应用，第一次就直接安装了，安装成功后再次搜索该应用下载。这个时候就会提示已经有该应用了，是否要替换： 这个时候不要做任何的点击。在终端中进入到 Apple Configurator 2 的缓存目录下：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 你会发现目标应用的 ipa 包。 原因在于，Apple Configurator 2 下载的文件会临时保存在该临时目录下。如果安装完毕，就会立刻删除该 ipa 包。由于之前已经下载了该应用，Apple Configurator 2 弹窗提示是否需要替换，此时的 ipa 包还没来得及删除，可以复制出来。 获取 Assets.car 中的资源文件把 ipa 包复制出来后，使用解压工具对其进行解压。在 payload 文件夹下有资源包。 这个包里已经可以看到很多资源文件了，但是我们需要找到的是 Assets.car 这个压缩文件，这里面才是真正的我们需要的图片资源。这个Assets.car文件的解压需要用到https://github.com/pcjbird/AssetsExtractor使用起来非常方便。把 Assets.car 拖进该工具，指定输出目录就可以得到最终的全部资源文件 分析与调试静态分析hopper 使用Mach-o 可以反编译为汇编代码，但是汇编代码无法完全反编译为 oc 代码。因为汇编操作的是寄存器，不同的类型以及不同的变量名的 oc 代码可能得到相同的汇编代码。 Hopper 和可以将 Mach-o 代码反编译为汇编代码、OC或者Swift伪代码。下载好之后，直接把 Mach-o 文件拖入 Hopper，即可开始分析。 动态调试LLDB 调试LLDB 通过 debugserver 和 app 通信。当 Xcode 调试手机时，Xcode 会将 debugserver 文件复制到手机中，以便在手机上启动一个服务，等待 Xcode 进行远程调试。只有设备连接到计算机真机调试时，debugserver 文件才会安装到设备的 /Developer/user/bin 目录下。 但是默认情况下，/Developer/usr/bin/debugserver 缺少权限，只能使用 xcode 调试。因此，我们需要对 debugserver 重签名，获得两个权限： get-task-allow 和 task_for_pid-allow 如何给 debugserver 添加权限: 将 debugserver 从目录拷贝到 mac。目录就是上述的 /Developer/usr/bin/debugserver 使用 ldid 导出 debugserver 的权限到 debugserver.entilements 文件 ldid 是帮助修改 iPhone 上二进制授权文件的工具。通过 homebrew 安装： 1brew install ldid 安装完后，导出 debugserver 的权限： 1$ldid -e debugserver &gt; debugserver.entilements debugserver.entilements 文件是个配置文件，打开并添加这两个权限： 使用 ldid 重签名：1$ldid -S debugserver.entilements debugserver （上面的 ldid 的重签名也可以使用 codesign 代替）1234# 查看 （在终端中显示，可以复制保存为 debugserver.entitlements）$codesign -d --entitlements -debugserver# 签名$codesign -f -s - --entitlements debugserver.entitlements debugserver 将重签名后的 debugserver 拖到手机 device/usr/bin 目录下，这样可以直接使用该命令 手机端开启 server。开启调试后，进程会进入断电，被暂停： 1$debugserver *:&#123;任意端口，如10010&#125; -a &#123;进程名&#125; Mac 端启动 lldb 123456# 进入lldb 模式$lldb# 连接，连接需要一段时间(lldb) process connect connect://&#123;手机IP&#125;:&#123;前面启动时的端口号&#125;# 连接成功自动进入断点，需要继续运行app(lldb) c debug 获取进程加载基地址由于 ALSR 的原因，进程的虚拟地址不是从 0x0 开始的，会有一个随机偏移量。因此，当我们要读取运行的程序的内存的时候就需要知道这个 ALSR 的偏移量。 可以在 lldb 中通过 image list -o -f 拿到正在 debug 的进程的所有动态库的信息。其中第一项的第一列一般就是当前进程的基地址（不是ALSR地址）。 lldb 使用 打印相关： p {指令}：执行指令 bt：打印调用堆栈 backtrace frame variable：打印当前栈帧的变量 调试相关： c：继续执行 n：单步运行 step：step-in finish：step-over 代码断点相关 breakpoint set -n {方法名}：为某个方法设置断点。 12# 更高级的，设置某一个类的某一个方法的断点，需要使用引号包裹breakpoint set -n "-[ViewController touchesBegan:withEvent:]" breakpoint list：列出所有断点，包含编号 breakpoint enable/disable/delete {断点编号}：断点操作 内存断点相关 watchpoint set variable {变量名}：变量值变化的时候触发 watchpoint list：列出所有内存断点 watchpoint enable/disable/delete {断点编号}：内存断点操作 1watch set variable self-&gt;age theos下载 theos 安装签名工具 brew install ldid 修改 .zshrc 1234# 这样可以用 $THEOS 代替 ~/theosexport THEOS=~/theos# 修改环境变量,这样就可以在任意位置执行 `~/theos/bin` 路径下命令了export PATH=~/theos/bin:$PATH 执行 source ~/.zshrc 重置 zshrc 配置。 递归下载 theos git clone --recursive https://github.com/theos/theos.git $THEOS 使用 theos 创建 tweak 执行下载下来的命令 $nic.pl 根据提示选择要创建 iphone/tweak，然后设置自己的项目名，bundleID，还有目标应用的 bundle identifier（用 cycript 获取，[NSBundle mainBundle].bundleIdentifier)，生成一系列文件。 编辑生成的 Makefile 文件，在文件最上方添加配置： 123456# 设置IP和端口号，表示要通过 SSH 的方式安装这个 theos# 切记一定要放在最上面export THEOS_DEVICE_IP=&#123;你的手机的IP&#125;export THEOS_DEVICE_PORT=22# ... 省略了自动生成的配置部分 编写代码，编辑 Tewak.xm 文件： 123%hook &#123;要hook的类名&#125;&#123;根据 class-dump 找到感兴趣的要hook的方法&#125;%end 命令行执行： 123456# 编译$make# 打包$make package# 安装 会重启 SpringBoard$make install 相当于给原来的应用注入了一个动态库。可以在 /Library/MobileSubstrate/DynamicLibraries 中查看新安装的 dylib 和 plist 文件。 tweak 实现注意点 hook 的方法中的参数以及 self 一般都是 id 类型，所以不能用点语法，而要使用 get 方法： 123- (id)tableView:(id)tableView cellForRowAtIndexPath:(id)indexPath &#123; int num = [indexPath section];&#125; 可以使用宏，在文件顶部定义： 1#define SomeMethod [NSUserDefaults standardUserDefaults] hook 方法默认是 hook 已有方法，如果增加的方法是原来没有的需要加上 %new: 123%new -(void)someFunc:(UIButton *)button &#123; ...&#125; hook 方法要调用原来的实现方法，使用 %orig 替代： 123- (long long)numberOfSectionsInTableView:(id)tableView &#123; return %orig + 2&#125; 资源文件放在新建的 tweak 生成的 layout 文件夹下，该目录对应的就是手机的根目录，可以自己在 layout 下创建文件夹层级，代码中引用： 1UIImage *myImage = [UIImage imageWithCOntentOfFile:@"/&#123;自己创建的文件夹层级&#125;/&#123;文件名&#125;"] 有时候调用原有方法或者 %new 的方法，有时会报 instance method not found 的错误，这需要我们再在实现的 xm 文件顶部声明一下该方法。类名任意，只要表示该方法声明过即可： 123@interface &#123;任意类名&#125;-(id)&#123;你的方法名&#125;；@end 有时候使用某个类的时候还会报类不存在的错误。如果是使用自己创建的类直接 #import &quot;{类名}&quot; 即可。如果是被 hook 文件已经 import 的类，需要使用 @class 提前声明一下。 可以通过关联对象的方式给实例添加属性 如果要分多个文件编写，需要在 makefile 中配置相应文件，以空格分隔。针对文件量过多的情况，可以使用通配符表示一个文件夹内的文件。使用的时候直接直接 import，但是要把路径写完整，路径以 Tweak.xm 为基准。 12TWEAK_NAME = $&#123;your tweak name&#125;$&#123;your project name&#125;_FILES = $&#123;以当前文件夹为基准的文件路径+文件名&#125; $&#123;以当前文件夹为基准的文件路径+文件名&#125; $&#123;以当前文件夹为基准的文件路径+文件名&#125; Tweak 实现原理 生成的插件会被安装在 /Library/MobileSubstrate/DynamicLibraries 中。生成的文件包括 .dylib 包含编译后的 tweak 代码，和 .plist 存放着 hook 的目标 APPID 打开 App 时，Cydia Substrate 会去加载对应的 dylib，修改内存中的代码逻辑， 执行 dylib 中的函数 tweak 不会修改可执行文件，仅仅只是修改了内存的逻辑。所以 tweak 可以对未砸壳 App 修改，但是必须要使用越狱手机。 Logos 语法 %hook %end hook一个类的开始和结束 %log; 打印方法调用详情，在 Xcode 的日志输出中查看 %c({类名}) 获取类对象，相当于 [xxx class]，直接调用可能有错 %orig 函数原来的代码逻辑 %new 添加一个新的方法 logify.pl可以将头文件快速转换成已经包含打印信息的 xm 文件（自动添加 %log 语句）：1$logify.pl xxx.h &gt; &#123;你想取的任意名字&#125;.xm 通过修改 makefile 中的配置，将生成的 .xm 文件加入到编译文件中。直接添加到原来的 Tweak.xm 之后即可： 1&#123;your project name&#125;_FILES = Tweak.xm &#123;你取的名字&#125;.xm 但是经常会编译不过，需要手动修改： 未定义头文件：报错 unknown type name ‘XXX’，在头部声明 @class XXX;,或者将 class 类型改为 id 未声明协议：报错no type or protocol named &#39;XXX&#39;，在头部声明 @protocol XXX 不能存在 weak：报错 cannot create __weak reference，替换掉所有的 __weak 为空字符串 不能存在非 oc 方法：报错 expected selector for Objective-C method ，删除以点开头的非 OC 的方法 带协议的参数报错：报错 cast from pointer to smaller type &#39;unsigned int&#39; loses information。如果有一个参数类型遵循某个协议，那么 %log 就无法通过，需要把协议删除。 HBLogDebug 类型错误：报错 cast from pointer to smaller type &#39;unsigned int&#39; loses information，HBLogDebug 本身是用来打印方法返回值的，有一些地方返回值 id 类型，会被转化为 unsigned int 类型，因此报错。需要替换：1234// 原始语句HBLogDebug(@"=0x%x", (unsigned int)r);// 批量替换为HBLogDebug(@"=0x%@", r); MonkeyDevMonkeyDev 的具体使用可以到 MonkeyDev Wiki 中查看 逆向进阶ASLRAddress space layout randomization 地址空间布局随机化 可以通过 lldb 的 image list -o -f 获得这个偏移地址: image list -o -f 拿到的是减去 __Text 段基地址的偏移，即 ASLR image list 拿到的则是 __Text 的实际地址偏移，即基地址 + ASLR 地址 获得了偏移地址后，在通过 hopper 获得未使用 ALSR 的方法的地址，两者相加，就是该方法实际在内存中的地址了，可以为其设置断点： 1breakpoint set -o &#123;函数地址&#125;+&#123;偏移地址&#125; 通用二进制文件包含了多种架构的二进制文件叫做通用二进制文件，又叫 fat binary 胖二进制文件。123456789// 查看信息：$file &#123;文件名&#125;$lipo -info &#123;文件名&#125;// 瘦身$lipo &#123;文件名&#125; -thin armv7 -o &#123;输出文件名&#125;// 合并$lipo -create &#123;文件名1&#125; &#123;文件名2&#125; -o &#123;输出文件名&#125; Xcode 中生成架构配置如图： Architecture： Xcode 支持的架构，不同 Xcode 版本不同 Valid Architecture： 想要生成的架构 最终生成的架构就是支持的和想要的的交集。 程序加载在编写一个程序时，看到的入口函数都是 main.m。实际上在 main 函数执行前已经执行了 +load 和 constructor 构造函数。现在要探讨在 main 函数执行前做了什么 dyld 简介系统内核在做好启动程序的准备工作之后就会从内核态切换到用户态，将工作交给 dyld。 系统动态库会通过动态库加载器 dyld 被加载到内存中。为了优化程序启动速度，iOS 采用了共享缓存技术。在系统启动后被加载到内存中。当有新的程序加载时会先到共享缓存里寻找。找到就直接将共享缓存中的地址映射到目标进程的内存空间。 dyld 加载流程dyld 的时间线： 1Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjCruntime -&gt; Initializers dyld 从主执行文件的 header 获取到需要加载的所依赖动态库列表，并递归的将他们加载，为每一个动态库生成一个 ImageLoader 对象 检查共享缓存是否映射到了共享区域 加载所有通过 DYLD_INSERT_LIBRARIES 插入的库 在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups Rebasing：在 imageLoader 内部调整指针的指向，即修改 ASLR 带来的偏差 Binding：dylib 通过指针绑定会使用的外部的实例方法等符号的地址 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中。 执行初始化方法，+load 和 constructor 就是在这里执行的 通过 Load Command 找到 LC_MAIN 即 main 函数位置，执行 Mach-O 文件MachO 文件基本构成Mach-O 是苹果的可执行文件，结构由三部分组成： Header：文件类型，目标架构类型 Load Commands：描述载入内存的有哪些段，段有多大，从哪里开始 Data：段的数据 使用 MachOView 查看，我们可以看到有各种各样的段。class-dump 就是通过这种方式获取到头文件信息的。 具体看一下 Macho 的 Load Command，它包含了 Macho 中各个段的基本信息： 一般可执行文件会分为许多个 section，section 又会根据权限的不同整合为多个 fragment ，一般分为四个 fragment： __PAGEZERO 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用 __TEXT 代码段，只读，包括函数，和只读的字符串(如 __TEXT,__text 保存所有代码，又如 __TEXT.__objc_classname 保存 Objective-C 类名称)__ __DATA 数据段，读写，包括可读写的全局变量等(如 __DATA,__data 保存初始化过的可变数据，又如 __DATA.__objc_classlist 保存所有类实体的指针，指向 __data 中保存的 objc_class 实例） __LINKEDIT动态链接器需要使用的信息，包括重定位信息，绑定信息，懒加载信息等。 代码段和数据段的具体组成__TEXT 包含以下 section： __text：程序可执行代码区域 __stubs：简介符号存根，跳转到懒加载指针表 __stub_helper：帮助解决懒加载符号加载的辅助函数 __objc_methname：方法名 __objc_classname：类名 __objc_methtype：方法签名 __cstring：c风格字符串 __DATA 包含以下 section： __nl_symbol_ptr：非懒加载指针表，在 dyld 加载时会立即绑定 __la_symbol_ptr：懒加载指针表，第一次调用才绑定值 __got：非懒加载全局指针表 __mod_init_func：constructor 函数 __mod_term_func： destructor 函数 __cfstring：OC 字符串 __objc_classlist：程序中类的列表 __objc_nlclslist：程序中实现了 +load 方法的类 __objc_protolist：协议的列表 __objc_classrefs：被应用的类列表 懒加载和非懒加载在之前说的dyld执行流程中有一环叫做 binding，即绑定符号的地址。iOS 系统为了加快系统启动速度，将符号分成了懒加载符号和非懒加载符号。 非懒加载符号在 dyld 加载时就会绑定真实的值。懒加载符号不会，只有第一次去调用它时才会绑定真实的地址，第二次调用直接使用真实地址。 如系统方法 print 的绑定过程如下图所示： ARM 汇编ARM寄存器X0-X30 是 31 个通用寄存器，低 32 位用 W0-W30 表示。X30 是一个特殊寄存器，用于保存函数调用完成时的返回地址。 SP 为堆栈指针寄存器，通过 X31 寄存器访问 PC 为保存当前指令地址的程序计数器 LR 指向返回地址，对应于 X30 FP 指向栈帧的底部，对应于 X29（即 Base Pointer） 常见指令ldr Xn, addr: 从 addr 读取内容存到 Xn 中 str Xn, addr: 将 Xn 写入 addr 指向的内存 cbz Xn, label : 如果 Xn 为 0，则跳转到 label cbnz Xn, label: 如果 Xn 不为 0，跳转到 label bl label: 无条件跳转，会将下一条指令地址写到 X30 处 堆栈调用堆栈调用过程如下： 函数调用前： 开辟堆栈控件 保存 FP 和 LR 寄存器，以便找到上一个栈帧和返回地址 设置新的 FP 寄存器 保存子函数会用到的寄存器 保存局部变量或参数 函数调用结束： 还原 FP 和 LR 寄存器 释放栈帧空间 跳到 LR 继续执行 参数一般通过 X0-X7传递，当参数小于 8 个时候，默认是直接存到寄存器中的。但是如果超过 8 个，那么会在方法调用前，将多出的那个存入堆栈中，子方法需要到堆栈中取值。 返回结果一般通过 X0 传递 一个方法的汇编的例子： 12345678910void fooFp() &#123; int a = 4; int b = 5; fooFp2();&#125;void fooFp2() &#123; int a = 2; int b = 3;&#125; 1234567891011121314ArmAssembly`fooFp: 0x100dbe76c &lt;+0&gt;: sub sp, sp, #0x20 ; 申请栈空间 0x100dbe770 &lt;+4&gt;: stp x29, x30, [sp, #0x10] ; 保护寄存器的值 0x100dbe774 &lt;+8&gt;: add x29, sp, #0x10 ; 改变fp寄存器的值，用于执行栈底 0x100dbe778 &lt;+12&gt;: mov w8, #0x5 0x100dbe77c &lt;+16&gt;: orr w9, wzr, #0x4 0x100dbe780 &lt;+20&gt;: stur w9, [x29, #-0x4] 0x100dbe784 &lt;+24&gt;: str w8, [sp, #0x8] 0x100dbe788 &lt;+28&gt;: bl 0x100dbe798 ; fooFp2 at ViewController.m:154 0x100dbe78c &lt;+32&gt;: ldp x29, x30, [sp, #0x10] ; 恢复之前保存的fp和lr的值 0x100dbe790 &lt;+36&gt;: add sp, sp, #0x20 ; 恢复sp指针 0x100dbe794 &lt;+40&gt;: ret hookfishhook苹果为了能在 Mach-O 文件中访问外部函数，采用了一个技术，叫做PIC（位置代码独立）技术。当你的应用程序想要调用 Mach-O 文件外部的函数的时候，或者说如果 Mach-O 内部需要调用系统的库函数时，Mach-O 文件会： 先在 Mach-O 文件的 _DATA 段中建立一个指针ptr（8字节的数据，放的全是0），这个指针变量指向外部函数。 DYLD 会动态的进行绑定！将 Mach-O 中的 _DATA 段中的指针，指向外部函数。 上图中可以看到，其他部分都是实实在在的代码信息，没有好的修改办法。只有红色框框中的 nl_symbol_ptr 和 la_symbol_ptr是指针段，由于指针都是长度固定的，所以方便修改指针地址，进而达到 hook 的目的。 所以说，C的底层也有动态的表现。C在内部函数的时候是静态的，在编译后，函数的内存地址就确定了。但是，外部的函数是不能确定的，也就是说C的底层也有动态的。fishhook 之所以能 hook C函数，是利用了 Mach-O 文件的 PIC 技术特点。也就造就了静态语言C也有动态的部分，通过 DYLD 进行动态绑定的时候做了手脚。 我们经常说符号，其实 _DATA 段中建立的指针就是符号。fishhook的原理其实就是，将指向系统方法（外部函数）的符号重新进行绑定指向内部的函数。这样就把系统方法与自己定义的方法进行了交换。这也就是为什么C的内部函数修改不了，自定义的函数修改不了，只能修改 Mach-O 外部的函数。 iOS 签名签名过程如图： 当我们修改了别人的 APP 之后，我们就需要将修改过的 ipa 重签名，才能安装到手机上。重签名了的应用可以安装到未越狱手机。 IPAPatch 免越狱调试 APPIPAPatch 就是通过从签名达到免越狱注入代码的目的。使用起来非常简单。 使用 PP 助手下载一个已越狱的应用的 ipa 下载 IPAPatch 的工程 使用已越狱的 ipa 替换工程中 Assets 文件夹下的 app.ipa 文件。注意，名字要改为 app.ipa 将 RevealServer.framework 放置在 Assets/Frameworks/RevealServer.framework 修改 bundleId Run Xcode 安装到手机 安全保护静态混淆宏定义使用宏将方法属性名修改为其他无意义的字符串 动态保护反调试ptrace UNIX 早期版本提供的一种对运行中的进程进行跟踪和控制的手段，就是系统调用 ptrace。通过 ptrace 实现对另一个进程的调试跟踪 可以通过参数 PT_DENY_ATTACH 禁用调试。这个参数告诉系统阻止调试器依附。所以，最常用的反调试方法就是通过调用 ptrace 来实现反调试。 sysctl 当一个进程被调试时，该进程中的一个标志位用来标记正在被调试。可以定时通过 sysctl 查看这个标志位 反反调试hook函数 -&gt; 判断参数 -&gt; 返回结果 越狱设备直接可以hook以上说到的反调试函数。非越狱设备可以通过 fishhook，hook 反调试函数。 反注入可以定期调用 _dyld_get_image_name() 方法，获取正在加载的动态库名，比较是否是白名单内的动态库名来实现注入检测。 hook 检测hook 包括 Method Swizzle，符号表替换，inline hook 等。不同的 hook 方式，需要制定不同的检测方案 Method Swizzle Method Swizzle 的原理是替换 imp，通过 dladdr 得到 imp 所在的模块，判断模块是不是主二进制模块，如果不是就是被 hook 了。 符号表替换 fishhook 是基于懒加载符号表和非懒加载符号表进行替换的，所以遍历符号表中的指针就能判断程序是否被恶意 hook 了。 非懒加载的指针指向真实地址，懒加载的指针在没有解析到真正的地址钱指向 __stub_helper，所以遍历符号表，判断是否指向了系统模块或者 __stub_helper 即可。 完整性校验逆向过程设计到对文件 load command 的修改，对文件进行重签名，修改 BundleId。可以从上述几个方面校验 load command 直接读取 Mach-O load command 中的 LC_LOAD_DYLIB ，判断是否有非白名单动态库 代码校验 获取内存中代码的 MD5 值，如果代码修改了，就会不一样 重签名校验 判断 bundle ID 是否被修改 8086简介8086 是 x86系列处理器的开端，所以后面用 x86 代替 32位处理器。 CPU 的组成CPU 的三大组成： 运算单元 数据单元 控制单元 运算单元做加法或者位移的操作。 数据单元包含CPU内部的缓存和寄存器组。 控制单元可以获得下一条指令，然后执行。这个指令会指导运算单元取出数据单元中的某几个数据，计算出结果，然后放到数据单元的某个地方。 8086 的寻址方式8086 的总线是有16根，但是可以寻址的范围为 2^20 byte。 20位的物理地址 = 16位的段地址 * 16 + 4位的偏移地址 CPU 中的数据单元8086 CPU 中的数据单元如下： 其中： AX，BX，CX，DX 为数据寄存器，存放操作的数据 CS 代表代码段的起始地址。IP 表示偏移地址。每读取一条指令，IP=IP + 所读取指令的长度。 SS 表示栈的起始位置。SP 表示栈的偏移地址。BP 是入参和临时变量的分界，通过 BP 及偏移量拿到入参和临时变量。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView 使用（三）—— WebViewJavaScriptBridge 源码解析]]></title>
    <url>%2F2018%2F10%2F01%2FWKWebView3%2F</url>
    <content type="text"><![CDATA[记录一下 WKWebView 相关使用 WebViewJavaScriptBridge 源码解析基本用法 导入头文件，声明一个 WebViewJavascriptBridge 属性： 123#import "WebViewJavascriptBridge.h"...@property WebViewJavascriptBridge* bridge; 将 wkwebview 设置给 bridge 1self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView]; 在 Objective-C 中注册 handler 和调用 JavaScript 中的 handler： 1234[self.bridge registerHandler:@"ObjC Echo" handler:^(id data, WVJBResponseCallback responseCallback) &#123; NSLog(@"ObjC Echo called with: %@", data); responseCallback(data);&#125;]; 设置 bridge 的代理为任意你操作的控制器。这样，所有 webView 相关的方法在经过 bridge 的预处理后，都将操作权转移给了使用者： 1[self.bridge setWebViewDelegate:self]; 复制下面的 setupWebViewJavascriptBridge 函数到你的 JavaScript 代码中。该方法用来初始化 js 端的 bridge： 12345678910function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'https://__bridge_loaded__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 调用 loadRequest，在执行 JS 代码的时候会调用 setupWebViewJavascriptBridge 函数。使用 bridge 来注册 handler 和调用 Objective-C 中的 handler： 123456789setupWebViewJavascriptBridge(function(bridge) &#123; bridge.registerHandler('JS Echo', function(data, responseCallback) &#123; console.log("JS Echo called with:", data) responseCallback(data) &#125;) bridge.callHandler('ObjC Echo', &#123;'key':'value'&#125;, function responseCallback(responseData) &#123; console.log("JS received response:", responseData) &#125;)&#125;) 至此，native 端和 js 端都有了一个 bridge，可以相互调用。 JS 端主动调用 Native: 123bridge.callHandler('ObjC Echo', &#123;'key':'value'&#125;, function responseCallback(responseData) &#123; console.log("JS received response:", responseData)&#125;) Native 主动调用 JS： 123[self.bridge callHandler:@"JS Echo" data:nil responseCallback:^(id responseData) &#123; NSLog(@"ObjC received response: %@", responseData);&#125;]; 结构代码分为三个部分： 外层调用接口：WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 具体实现： WebViewJavascriptBridgeBase JS 层： WebViewJavascriptBridge_JS 可以看得出来，对于一个给别人使用的类库的实现。给外部使用的，只要暴露出寥寥几个方法即可。而具体的实现应该放到另外的具体实现的文件中去，以此区分职责。 源码解析初始化12345678910111213141516171819202122232425262728293031// WKWebViewJavaScriptBridge.m+ (instancetype)bridgeForWebView:(WKWebView*)webView &#123; WKWebViewJavascriptBridge* bridge = [[self alloc] init]; [bridge _setupInstance:webView]; [bridge._base reset]; return bridge;&#125;- (void) _setupInstance:(WKWebView*)webView &#123; _webView = webView; _webView.navigationDelegate = self; _base = [[WebViewJavascriptBridgeBase alloc] init]; _base.delegate = self;&#125;// WebViewJavascriptBridgeBase.m- (id)init &#123; if (self = [super init]) &#123; self.messageHandlers = [NSMutableDictionary dictionary]; self.startupMessageQueue = [NSMutableArray array]; self.responseCallbacks = [NSMutableDictionary dictionary]; _uniqueId = 0; &#125; return self;&#125;- (void)reset &#123; self.startupMessageQueue = [NSMutableArray array]; self.responseCallbacks = [NSMutableDictionary dictionary]; _uniqueId = 0;&#125; 初始化做的事情不是很多，主要就是生成了一个具体的处理逻辑的实例 WebViewJavascriptBridgeBase ，然后 WKWebViewJavascriptScriptBridge 将 WKWebView 的代理设置为了自己，虽然后面还是会转发给 _base 的相应处理方法处理。 messageHandlers,startupMessageQueue 和 responseCallbacks 后面会讲到。 注册与移除提供给 JS 的 OC 方法12345678910typedef void (^WVJBResponseCallback)(id responseData);typedef void (^WVJBHandler)(id data, WVJBResponseCallback responseCallback);- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123; _base.messageHandlers[handlerName] = [handler copy];&#125;- (void)removeHandler:(NSString *)handlerName &#123; [_base.messageHandlers removeObjectForKey:handlerName];&#125; 代码非常简单，其实就是把提供给 JS 调用的方法的方法名和处理 block 保存在了 _base 中的 messageHandlers 字典中。 处理 block 的第一个参数为 JS 传递给 OC 的参数，第二个参数为 OC 处理完 JS 的调用后对 JS 的回调。 JS 注册注册好提供给 JS 的方法后，OC 会执行 loadRequest 真正的执行 js 代码。我们在 js 中注入的初始化方法 setupWebViewJavascriptBridge 就会被执行: 12345678910111213141516171819202122function setupWebViewJavascriptBridge (callback) &#123; // 第一次调用的时候 window.WebViewJavascriptBridge 和 WVJBCallbacks 还没有初始化好，所以不会调用 if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge) &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback) &#125; window.WVJBCallbacks = [callback] // 开启一个 iframe，加载这段 URL 'wvjbscheme://__BRIDGE_LOADED__' // 其目的是为了触发 WebViewJavascriptBridge_JS.m 文件内容的加载 var WVJBIframe = document.createElement('iframe') WVJBIframe.style.display = 'none' WVJBIframe.src = 'https://__bridge_loaded__' document.documentElement.appendChild(WVJBIframe) setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;setupWebViewJavascriptBridge(function (bridge) &#123; var uniqueId = 1 bridge.registerHandler('testJavascriptHandler', function (data, responseCallback) &#123; var responseData = &#123; 'Javascript Says': 'Right back atcha!' &#125; responseCallback(responseData) &#125;)&#125;) 这里主要做了两件事： 将传进来的 js 初始化成功后需要执行的方法，保存到 window.WVJBCallbacks 中，等到后面 JS 端的 bridge 初始化成功后，再取出来调用 通过添加一个 iframe 加载初始化链接 https://__bridge_loaded__，调起原生，然后再移除这个 iframe native 拦截 iframe 的 requestjs 端为了初始化 bridge，通过 iframe 发起了一个 https://__bridge_loaded__ 的请求。native 端会受到相应的跳转回调： 123456789101112131415161718192021222324- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if (webView != _webView) &#123; return; &#125; NSURL *url = navigationAction.request.URL; __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate; if ([_base isWebViewJavascriptBridgeURL:url]) &#123; if ([_base isBridgeLoadedURL:url]) &#123; // 初始化 bridge [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; [self WKFlushMessageQueue]; &#125; else &#123; [_base logUnkownMessage:url]; &#125; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) &#123; [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler]; &#125; else &#123; decisionHandler(WKNavigationActionPolicyAllow); &#125;&#125; 在这个方法中，通过 [_base isBridgeLoadedURL: url] 判断是否是制定的加载 bridge 专用的 URL，来决定是否注入 JS 代码。https://__bridge_loaded__ 这个 URL 就是用来注入 JS 的，会执行 [_base injectJavascriptFile] 方法。 注入 JS 文件，初始化 JS 端 bridgenative 调用 JS 初始化12345678910111213- (void)injectJavascriptFile &#123; NSString *js = WebViewJavascriptBridge_js(); // 执行初始化 JS 端 bridge 的 js 代码 [self _evaluateJavascript:js]; // 如果当前已有消息队列则遍历并分发消息，之后清空消息队列 if (self.startupMessageQueue) &#123; NSArray* queue = self.startupMessageQueue; self.startupMessageQueue = nil; for (id queuedMessage in queue) &#123; [self _dispatchMessage:queuedMessage]; &#125; &#125;&#125; 这个方法中，主要就是执行 WebViewJavascriptBridge_js 中准备好的 JS。 初始化 JSBridge 中的各个变量WebViewJavascriptBridge_js` 中保存了几个变量： 123456789101112131415// 用来像 native 发送请求的 iframe 实例var messagingIframe;// 要发送的各个消息的数组，每个对象的结构为 &#123;handlerName: 'xxx', data: &#123;&#125;, responseId: 1&#125;var sendMessageQueue = [];// 保存 handlerName 以及对应的实现方法var messageHandlers = &#123;&#125;;// native 和 js 端统一的事件 scheme 和 hostvar CUSTOM_PROTOCOL_SCHEME = 'https';var QUEUE_HAS_MESSAGE = '__wvjb_queue_message__';// 保存具体的 js 端调用 oc 之后，需要的回调方法var responseCallbacks = &#123;&#125;;// 每个回调都需要的独一无二的 idvar uniqueId = 1; window.WebViewJavascriptBridgeWebViewJavascriptBridge_js 还为 window 创建了一个 WebViewJavascriptBridge 对象。其中包含了几个方法： 1234567window.WebViewJavascriptBridge = &#123; registerHandler: registerHandler, callHandler: callHandler, disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout, _fetchQueue: _fetchQueue, _handleMessageFromObjC: _handleMessageFromObjC&#125;; registerHandlerregisterHandler(handlerName, handler) 用来提供给 JS 注册 hander，以供 OC 调用，注册的方法都会保存在 messageHandlers 字典中： 123function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler;&#125; callHandlercallHandler(handlerName, data, responseCallback)：JS 主动调用 OC 提供的 handler 的方法。 12345678910111213function callHandler(handlerName, data, responseCallback) &#123; _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);&#125;function _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = 'cb_'+(uniqueId++)+'_'+new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message['callbackId'] = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;&#125; 把方法名和参数生成一个消息对象，放到 sendMessageQueue 数组中，同时加载 URL 调起原生。如果有回调的 block，那么通过 uniqueId 生成一个 callbackId，也保存到消息对象中。 disableJavscriptAlertBoxSafetyTimeout123function disableJavscriptAlertBoxSafetyTimeout() &#123; dispatchMessagesWithTimeoutSafety = false;&#125; 是否禁用异步调用。如果设置为 false。那么native 端调用 js 的话将是同步的。我们可以在下面的 _handleMessageFromObjC 方法中看到相关逻辑。 _fetchQueue获取所有的消息队列，转为字符串返回，然后清空消息队列 12345function _fetchQueue() &#123; var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; return messageQueueString;&#125; _handleMessageFromObjC这个方法会被 native 调用，用来处理 native 传递过来的事件 1234567891011121314151617181920212223242526272829303132333435363738394041function _handleMessageFromObjC(messageJSON) &#123; _dispatchMessageFromObjC(messageJSON);&#125;function _dispatchMessageFromObjC(messageJSON) &#123; // 判断是否是异步调用。如果是异步调用则通过 setTimeout 将方法延后调用。否则直接执行。由于 javascript 是单线程的原因，会阻塞原有 js 代码的执行。 if (dispatchMessagesWithTimeoutSafety) &#123; setTimeout(_doDispatchMessageFromObjC); &#125; else &#123; _doDispatchMessageFromObjC(); &#125; function _doDispatchMessageFromObjC() &#123; var message = JSON.parse(messageJSON); var messageHandler; var responseCallback; if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;); &#125;; &#125; var handler = messageHandlers[message.handlerName]; if (!handler) &#123; console.log("WebViewJavascriptBridge: WARNING: no handler for message from ObjC:", message); &#125; else &#123; handler(message.data, responseCallback); &#125; &#125; &#125;&#125; 解析从 native 传来的 messageJSON，如果存在 responseId 这个字段，说明是之前 js 调用 native 后的回调，那么就需要在自己的 responseCallbacks 找对应的回调方法，然后执行。执行完毕后通过 delete 删除。 如果存在 callbackId 字段，说明 JS 在处理好 native 的调用后，还需要回调 native 的方法。所以就先创建一个 callback 的闭包，把必要的信息都存到这个闭包中。然后在 messageHandlers 中找对应的处理方法，把调用的数据和回调闭包传入执行。 创建发送消息的 iframe12345// 创建 iframe，用来加载 URL 发送消息给 NativemessagingIframe = document.createElement('iframe');messagingIframe.style.display = 'none';messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE; // https://__wvjb_queue_message__document.documentElement.appendChild(messagingIframe); 执行 bridge 创建完成的回调到这一步，js 端的 bridge 基本创建完毕了，现在就可以使用这个 bridge 注册提供给 oc 的方法了。执行 windows.WVJSCallbacks 数组中保存的各个回调。 12345678setTimeout(_callWVJBCallbacks, 0);function _callWVJBCallbacks() &#123; var callbacks = window.WVJBCallbacks; delete window.WVJBCallbacks; for (var i=0; i&lt;callbacks.length; i++) &#123; callbacks[i](WebViewJavascriptBridge); &#125;&#125; 这里可以看到，业务端要执行的回调方法 WVJSCallbacks 无法直接传给 WebViewJavaScriptBridge_JS ，所以就通过挂载到 window 下的方式，让后者取到。 JS 调用原生JS 调用原生的方法上面已经分析过了，就是 window.WebViewJavascriptBridge的callHandler 方法，会来到 decidePolicyForNavigationAction 方法，并且进入 WKFlushMessageQueue 方法中： 123456789101112131415161718- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if (webView != _webView) &#123; return; &#125; NSURL *url = navigationAction.request.URL; __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate; if ([_base isWebViewJavascriptBridgeURL:url]) &#123; if ([_base isBridgeLoadedURL:url]) &#123; [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; [self WKFlushMessageQueue]; &#125; else &#123; [_base logUnkownMessage:url]; &#125; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; ...&#125; WKFlushMessageQueue 会先去 js 端获取 js 端要执行的 native 的所有方法名和参数，然后执行 _base 中的 flushMessageQueue 方法： 12345678- (void)WKFlushMessageQueue &#123; [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(NSString* result, NSError* error) &#123; if (error != nil) &#123; NSLog(@"WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@", error); &#125; [_base flushMessageQueue:result]; &#125;];&#125; flushMessageQueue 方法会先把从 JS 端传来的字符串转为对象数组，然后在自身注册的 messageHandlers 中找对应的处理方法执行。 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)flushMessageQueue:(NSString *)messageQueueString&#123; // 把 js 端传来的 String 转为数组对象 id messages = [self _deserializeMessageJSON:messageQueueString]; for (WVJBMessage* message in messages) &#123; ... NSString* responseId = message[@"responseId"]; if (responseId) &#123; // 存在 responseId，表明是原本 OC 调用需要的 callback。在 oc 的 responseCallback WVJBResponseCallback responseCallback = _responseCallbacks[responseId]; responseCallback(message[@"responseData"]); [self.responseCallbacks removeObjectForKey:responseId]; &#125; else &#123; WVJBResponseCallback responseCallback = NULL; NSString* callbackId = message[@"callbackId"]; // 如果有 callbackId 说明 js 端需要回调 if (callbackId) &#123; // 创建一个 callback 的 block，传入 responseData，然后找到 JS 端响应的处理方法 responseCallback = ^(id responseData) &#123; if (responseData == nil) &#123; responseData = [NSNull null]; &#125; // 把需要回调的 callbackId 作为 responseId 存入 WVJBMessage* msg = @&#123; @"responseId":callbackId, @"responseData":responseData &#125;; [self _queueMessage:msg]; &#125;; &#125; else &#123; responseCallback = ^(id ignoreResponseData) &#123; // Do nothing &#125;; &#125; WVJBHandler handler = self.messageHandlers[message[@"handlerName"]]; if (!handler) &#123; NSLog(@"WVJBNoHandlerException, No handler for message from JS: %@", message); continue; &#125; // 执行 handler 方法 handler(message[@"data"], responseCallback); &#125; &#125;&#125; _queueMessage 方法将在下面的原生调用 JS 中分析 原生调用 JS原生调用 JS，bridge 先调用 _base 中的相关处理方法: 1234// WKWebViewJavascriptBridge.m- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123; [_base sendData:data responseCallback:responseCallback handlerName:handlerName];&#125; _base 中把 data callbackId handlerName 这几个参数封装为字典，再转为 JSON字符串。随后在主线程中通过 evaluteJavascript 传递给JS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 参数转为字典- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName &#123; NSMutableDictionary* message = [NSMutableDictionary dictionary]; if (data) &#123; message[@"data"] = data; &#125; if (responseCallback) &#123; NSString* callbackId = [NSString stringWithFormat:@"objc_cb_%ld", ++_uniqueId]; self.responseCallbacks[callbackId] = [responseCallback copy]; message[@"callbackId"] = callbackId; &#125; if (handlerName) &#123; message[@"handlerName"] = handlerName; &#125; [self _queueMessage:message];&#125;- (void)_queueMessage:(WVJBMessage*)message &#123; if (self.startupMessageQueue) &#123; [self.startupMessageQueue addObject:message]; &#125; else &#123; [self _dispatchMessage:message]; &#125;&#125;// 字典转为 JSON 并执行- (void)_dispatchMessage:(WVJBMessage*)message &#123; NSString *messageJSON = [self _serializeMessage:message pretty:NO]; [self _log:@"SEND" json:messageJSON]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\'" withString:@"\\\'"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\f" withString:@"\\f"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\u2028" withString:@"\\u2028"]; messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\u2029" withString:@"\\u2029"]; NSString* javascriptCommand = [NSString stringWithFormat:@"WebViewJavascriptBridge._handleMessageFromObjC('%@');", messageJSON]; if ([[NSThread currentThread] isMainThread]) &#123; [self _evaluateJavascript:javascriptCommand]; &#125; else &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [self _evaluateJavascript:javascriptCommand]; &#125;); &#125;&#125; 可以发现，转化后的 JSON 作为 WebViewJavascriptBridge._handleMessageFromObjC(&#39;%@&#39;) 的参数传入 JS。至此，原生调用 JS 的过程也结束了。 几个问题 js 端还没有初始化完成，native 就发送的消息如何处理？ WebViewJavaScriptBridge 提供了一个 startupMessageQueue 用于保存在 JS 还没有初始化完成时候的 Native 消息队列。在 JS 初始化的代码执行完后，会立即执行 startupMessageQueue 中保存的消息，然后把 startupMessageQueue 队列置位 nil，之后的消息就不会保存到 startupMessageQueue 中了。 js 和 native 相互通信的方式是怎样？ js 端存在一个 sendMessageQueue 队列，用于存放 js 需要执行的消息队列，然后通知 native 到这个消息队列中拿消息。native 端需要发送消息的时候，则是直接执行 evaluateJavascript。这是因为执行 js 端的消息时异步的，执行期间可能有其他消息发生，而 native 的 evalutejavascript 是同步的，只有执行完这个方法， native 才会继续执行。 为什么WebViewJavascriptBridge 中 JS 调用原生时，把要传给原生的数据放到 messageQueue 中，再让原生调 JS 去取，而不是直接拼在 URL 后面？ URL 太长会丢数据。尤其是对参数进行 base64 编码，以保证 url 中不会出现一些非法的字符的时候。如果参数是一个很复杂的对象，那么这个 url 的编解码将会很复杂。 WebViewJavascriptBridge 中加载 URL 调起原生时，为什么不是用 window.location=&quot;https://xxx&quot; 这种形式，而是新添加一个 iframe 来加载这个 URL？ 如果我们连续 2 个 js 调 native，连续 2 次改 window.location 的话，在 native 的 delegate 方法中，只能截获后面那次请求，前一次请求由于很快被替换掉，所以被忽略掉了。 把 native 提供给 js 的方法都注册到 handler 中，当方法多的时候，不易于代码管理。该如何调整使不同类型的方法的职责分工更加明确？ 不直接注册所有的方法，而是只注册一个方法，所有 js 调用都经过这个而方法。这个方法内部使用 runtime 动态转发实现。因此，js 端调用 native 方法的时候，需要传递类名和方法名。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView 使用（二）—— 常见问题]]></title>
    <url>%2F2018%2F08%2F31%2FWKWebView2%2F</url>
    <content type="text"><![CDATA[记录一下 WKWebView 相关使用 Cookie 管理loadRequest 无 CookieWKWebView 不会在请求的时候自动到 NSHTTPCookieStorage 中获取 cookie(UIWebView 可以)。所以需要我们在 loadRequest 前，手动从 NSHTTPCookieStorage 中拿到 Cookie，并将处理好的 Cookie String在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题： 1234567891011121314151617181920212223242526272829303132333435NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]];// 根据 Request 的 URL，获取相应的 cookieNSArray *availableCookie = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:request.URL];// 重新创建一个可变数组NSMutableArray *cookieMarr = [NSMutableArray arrayWithArray:availableCookie];//删除过期的cookiefor (int i = 0; i &lt; cookieMarr.count; i++) &#123; NSHTTPCookie *cookie = [cookieMarr objectAtIndex:i]; if (!cookie.expiresDate) &#123; continue; &#125; /// cookie 有 expiresDate，超过的就 remove 掉 if ([cookie.expiresDate compare:self.currentTime]) &#123; [cookieMarr removeObject:cookie]; i--; &#125;&#125;// 把 cookie 的 array 转为 string 类型for (NSHTTPCookie *cookie in cookieArr) &#123; if ([cookie.name rangeOfString:@"'"].location != NSNotFound) &#123; continue; &#125; if (![validDomain hasSuffix:cookie.domain] &amp;&amp; ![cookie.domain hasSuffix:validDomain]) &#123; continue; &#125; NSString *value = [NSString stringWithFormat:@"%@=%@", cookie.name, cookie.value]; [marr addObject:value];&#125;NSString *cookie = [marr componentsJoinedByString:@";"];// 设置 request 的 cookie[request setValue:cookie forHTTPHeaderField:@"Cookie"];[self.webView loadRequest:request]; 重定向相关： 当服务器发生重定向的时候，此时第一次在 RequestHeader 中写入的 Cookie 会丢失，还需要重新对重定向的 NSURLRequest 进行 RequestHeader 的 Cookie 处理 ，简单的说就是在 webView:decidePolicyForNavigationAction:decisionHandler: 的时候，判断此时 Request 是否有你要的 Cookie 没有就Cancel掉，修改Request 重新发起。 iOS 11 中包含 WKHTTPCookieStore 相关的 API，可以解决 WKWebView Cookie 的问题。 JS 在执行的时候使用 document.cookie 读取不到 cookie当生成 Request 后，页面加载之前，给 WKWebView 注入脚本，使js 端的 cookie 和 NSHTTPCookieStorage 同步： 1234567891011121314151617181920212223242526272829-(void)syncClientCookieScripts:(NSMutableURLRequest *)request&#123; if (!request.URL) &#123; return; &#125; NSArray *availableCookie = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:request.URL]; NSMutableArray *filterCookie = [[NSMutableArray alloc]init]; for (NSHTTPCookie * cookie in availableCookie) &#123; if (self.syncCookieMode) &#123; //httponly需求不得写入js cookie if (!cookie.HTTPOnly) &#123; [filterCookie addObject:cookie]; &#125; &#125; &#125; // 拼接 JS 代码 对 Client Side 注入Cookie NSDictionary *reqheader = [NSHTTPCookie requestHeaderFieldsWithCookies:filterCookie]; NSString *cookieStr = [reqheader objectForKey:@"Cookie"]; if (filterCookie.count &gt; 0) &#123; for (NSHTTPCookie *cookie in filterCookie) &#123; NSTimeInterval expiretime = [cookie.expiresDate timeIntervalSince1970]; NSString *js = [NSString stringWithFormat:@"document.cookie ='%@=%@;expires=%f';",cookie.name,cookie.value,expiretime]; WKUserScript *jsscript = [[WKUserScript alloc]initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [self.userContentController addUserScript:jsscript]; &#125; &#125; return;&#125; User-Agent设置 UA 有两种方式，一种是全局的设置 UA，还有一种是设置局部的 UA。 全局 UA设置全局 UA 是通过把包含 UserAgent 的字典存入 NSUserDefaults 中去： 12 NSDictionary *dictionary = [[NSDictionary alloc] initWithObjectsAndKeys:appUserAgent, @"UserAgent", nil];[[NSUserDefaults standardUserDefaults] registerDefaults:dictionary]; 自定义 UAiOS 9 以上提供了自定义 UA 的方式，更加简单，直接成为了 WKWebView 的一个属性： 1self.webView.customUserAgent = @&quot;WebViewDemo/1.0.0&quot;; 获取系统默认 UA有时候，我们需要自定义 UA 的同时还想要有系统的 UA，即在系统 UA 后添加自己的 UA。这就需要获取到系统的 UA 了。可以通过 UIWebView 获取 UA 字符串： 123UIWebView *webView = [[UIWebView alloc] init];NSString *originalUserAgent = [webView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];NSString *appUserAgent = [NSString stringWithFormat:@"%@-%@", originalUserAgent, customUserAgent]; 获取到 UA，再通过上面两种方式设置全局或者自定义 UA 即可。 NSURLProtocol介绍一下 NSURLProtocol 的使用方式。 注册 NSURLProtocol首先要创建一个 NSURLProtocol 的子类： 12@interface MYProtocol : NSURLProtocol@end 然后在任意时候注册： 123- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [NSURLProtocol registerClass:[YXNSURLProtocol class]];&#125; 重写 NSURLProtocol 中的几个方法这里模拟一个真实的业务场景，就是 WKWebView 在首次通过 loadRequest 发起 post 的 body 丢失。具体原因见下面的一些问题 解决方案就是将请求的 scheme 设置为一个特殊的协议字段，如本例中的 post，然后通过 NSURLProtocol 拦截。 是否拦截 Request123456789101112+ (BOOL)canInitWithRequest:(NSURLRequest *)request&#123; /// 如果 scheme 是 post 那么拦截 if ([request.URL.scheme isEqualToString:@"post"]) &#123; return YES; &#125; /// 如果是已经拦截过的就放行 if ([NSURLProtocol propertyForKey:@"HasIntercepted" inRequest:request]) &#123; return NO; &#125; return NO;&#125; 未被拦截的 Request 直接放行，拦截的 Request 进入下一个方法 重设 NSURLRequest被拦截的 post 协议来到下面的方法中。这里从 request.allHTTPHeaderFields，即 request 的所有头信息中，拿到原本的 scheme 以及原本的 bodyParam。然后生成一个新的 Request，把 body 和 cookie 塞进去，返回这个 Request： 12345678910111213141516171819202122232425262728293031323334+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; /// 由于 WKWebView 通过 loadRequest 发起的 post 请求 body 会丢失，所以这里通过 NSURLProtocol 拦截，然后自己发出 request if ([request.URL.scheme isEqualToString:@"post"]) &#123; //获取oldScheme NSString *originScheme = request.allHTTPHeaderFields[@"oldScheme"]; NSMutableString *urlString = [NSMutableString stringWithString:request.URL.absoluteString]; NSRange schemeRange = [urlString rangeOfString:request.URL.scheme]; [urlString replaceCharactersInRange:schemeRange withString:originScheme]; //根据新的urlString生成新的request NSMutableURLRequest *newRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]]; //获取bodyParam NSString *bodyParam = request.allHTTPHeaderFields[@"bodyParam"]; NSData *bodyData =[bodyParam dataUsingEncoding:NSUTF8StringEncoding]; newRequest.HTTPMethod = @"POST"; newRequest.HTTPBody = bodyData; //获取cookie NSString *cookie = request.allHTTPHeaderFields[@"Cookie"]; [newRequest addValue:cookie forHTTPHeaderField:@"Cookie"]; [NSURLProtocol setProperty:@YES forKey:@"HasIntercepted" inRequest:newRequest]; return newRequest; &#125; return request;&#125; 这里还要注意一点，我们将新生成的 Request 添加一个 HasIntercepted 的标记。这样再重新进入 canInitWithRequest 的时候就会被直接放行了，防止无限循环。 加载 Request来到了最后一步，自行创建一个 NSURLSession 来实现网络请求： 12345678910111213141516171819- (void)startLoading &#123; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:self.request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; // 请求成功了，把 response 和 data 都返回回去 [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed]; [self.client URLProtocol:self didLoadData:data]; [[self client] URLProtocolDidFinishLoading:self]; &#125;else&#123; [self.client URLProtocol:self didFailWithError:error]; &#125; &#125;]; [task resume]; self.dataTask = task;&#125;- (void)stopLoading &#123; [self.dataTask cancel];&#125; self.client 就是操作最后拦截结果的实例，self.request 就是上面创建的新的 Request。整个拦截过程就完成了。 拦截 WKWebView 的请求WKWebView 默认是无法被 NSURLProtocol 拦截的，但是我们可以通过私有 Api 实现： 1234567891011//注册[NSURLProtocol registerClass:[MyCustomURLProtocol class]];//实现拦截功能Class cls = NSClassFromString(@"WKBrowsingContextController");SEL sel = NSSelectorFromString(@"registerSchemeForCustomProtocol:");if ([(id)cls respondsToSelector:sel]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [(id)cls performSelector:sel withObject:@"myapp"];#pragma clang diagnostic pop&#125; 上面是为 WKWebView 注册了一个 scheme 为 myapp 的 NSURLProtocol，对于要拦截 http 或者 https 请求，换成相应 scheme 就可以了。 针对这个问题，iOS11 推出了新的 API WKURLSchemeHandler，能够提供拦截 WKWebView 的功能。 NSURLProtocol 的应用场景通过自定义的NSURLProtocol，我们拿到用户请求的request之后，我们可以做很多事情。比如： 自定义请求和响应 网络的缓存处理（H5离线包 和 网络图片缓存） 重定向网络请求 过滤掉一些非法请求 等等… 一些问题白屏问题当WKWebView加载的网页占用内存过大时，会出现白屏现象。解决方案： 1234// 当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView &#123; [webView reload]; //刷新就好了&#125; WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失这是因为 WKWebView 有自己单独的一条进程。loadRequest 其实是将请求信息从应用进程传递给 WKWebView 所在进程，使其展示的过程。然而，苹果出于进程间通信加快速度的考虑，丢弃了 post 请求的 body 信息。 解决方案是通过 NSURLProtocol 拦截 Request，这样 WKWebView 又把 post 请求回传给了 native。发送请求前，把原本 body 中的信息放到 header 中。然后由 NSURLProtocol 拦截，生成新的请求，完成数据加载，最后将请求得到的数据返回。 详见上面的 NSURLProtocol 使用介绍，有详细步骤讲解 WKWebView NSURLProtocol 的 post 请求的 body 为空上面 loadRequest 是从 app 将 post 请求传给 WKWebView，而此例是由于 NSURLProtocol 拦截，需要把 WKWebView 的 post 请求传递给 app 处理。因此，post 请求的 body 还是会丢失。 所以，解决方式还是同上面 loadRequest 一样。 性能优化优化主要集中在优化 WebView 初始化和减少不必要的请求。 全局 WebView 与 WebViewPoolwebview 从不存在到存在的过程，系统需要进行一系列初始化。所有后续过程在这段时间完全阻塞。 可以创建一个 WebViewPool 的单例对象，在 load 方法中监听应用启动成功的通知： UIApplicationDidFinishLaunchingNotification，初始化 Pool 对象，并且初始化任意个供复用的 WebView 实例，之后的复用很像 TableView Cell 的复用。 之后业务上的所有的 WebView 实例都从 WebViewPool 中拿。WebView 需要增加一个 holder 的弱引用属性指向当前 VC。每次要从 WebViewPool 中取新的 WebView 实例的时候，就要查看一遍哪些 WebView 的 holder 为 nil，表示 WebView 所在的 VC 已经被回收，此时就要把 WebView 状态清空，然后放入复用池中。 当 WebView 需要放回复用池的时候需要做两件事，以达到和浏览器相同的效果 添加一个空白的页面 把该页面之前的浏览记录清空 123456789101112131415161718// 继承于 WKWebView 的类中//被回收- (void)webViewEndReuse&#123; // 加载空白页面，空字符串会自动加一个空白页面 [self loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@""]]]; // 使用的私有API，所以通过字符串拼接的方式获取方法名 // 这个方法会把除了最上面的页面都清空掉。因此，会清空除了刚添加的空白页面的之前所有的页面，使页面恢复到最开始打开时候的模样。 SEL sel = NSSelectorFromString([NSString stringWithFormat:@"%@%@%@%@", @"_re", @"moveA",@"llIte", @"ms"]); if([self.backForwardList respondsToSelector:sel])&#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" [self.backForwardList performSelector:sel];#pragma clang diagnostic pop &#125; &#125; webView 数据预请求在客户端初始化WebView的同时，直接由native开始网络请求数据。当页面初始化完成后，向native获取其代理请求的数据。如果此时 native 还没有拿到数据，那么 js 端做一个短暂的轮询。 减少不必要的请求分为前端优化和客户端优化 前端优化 降低请求量：合并资源，减少 HTTP 请求数，使用 lazyLoad，使用 gzip 压缩，使用 webP 格式 加快请求速度：预解析 DNS，减少域名数，使用与 Native 一样的域名 缓存：使用 localStorage，询问是否更新 渲染：服务端渲染 客户端优化NSURLProtocol 拦截资源请求 对于一些图片资源文件，可以通过 NSURLProtocol 拦截请求，然后查找 native 是否存在缓存，有的话直接返回 NSData，没有的话，通过 native 发起一个请求，缓存并返回 NSData 基于 LocalWebServer 实现的离线资源加载 通过 NSURLProtocol 可以实现资源的本地拦截加载。还有一种通过本地起一个 localserver 的方式，直接加载本地的资源。 可以选用如 CocoaHttpServer 这样的第三方库，在离线资源所在的目录启动本地服务。这样，网页中的资源，可以直接通过 http://localhost:[端口号]/someResource.js 的方式加载。 但是这样会引起 ATS 相关问题，即在 Safari 及 Apple WebKit 中：在https页面内，不允许http请求存在，否则一概会被block。因此，需要自签名 localhost，使其支持 https://localhost:[端口号]/someResource.js ，具体使用可在需要的时候搜索到。 离线包 离线包可以预下载，native 根据配置，在某个 节点下载离线包。下载好的离线包后，就可以拦截网络请求，对于离线包已经有的文件，直接读取离线包数据返回，否则走 HTTP 协议缓存逻辑。 12345678910111213141516171819202122232425262728293031//下载离线包html+css- (void)requestOfflinePkg &#123; NSString *zipName = @"offline_pkg"; NSString *zipUrl = [NSString stringWithFormat:@"http://localhost:9090/source/%@.zip", zipName]; NSURL *url = [NSURL URLWithString:zipUrl]; NSString *md5 = [self md5:zipUrl]; NSArray *pathes = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES); NSString *path = [pathes objectAtIndex:0]; NSString *zipPath = [NSString stringWithFormat:@"%@/zipDownload/%@",path,md5]; NSString *unzipPath = [NSString stringWithFormat:@"%@/%@.zip",path,md5]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if(!error) &#123; [data writeToFile:unzipPath options:0 error:nil]; BOOL result = [SSZipArchive unzipFileAtPath:unzipPath toDestination:zipPath]; //解压缩成功 if (result) &#123; //删除zip NSFileManager *fileManager = [NSFileManager defaultManager]; [fileManager removeItemAtPath:unzipPath error:nil]; &#125; &#125; &#125;]; [task resume];&#125; 参考移动 H5 首屏秒开优化方案探讨 从零收拾一个hybrid框架（二）– WebView容器基础功能设计思路 WebView性能、体验分析与优化 基于 LocalWebServer 实现 WKWebView 离线资源加载]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建私有npm]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89npm%2F</url>
    <content type="text"><![CDATA[当需要使用npm管理包，并且这些包不适合放到公网上时，就需要搭建私有npm了。搭建私有npm的方式很多。一般来说，比较推荐使用 verdaccio。这是sinopia 的 fork。sinopia 已经很久没有更新了。 准备工作安装使用命令行安装： 1sudo npm install -g verdaccio --unsafe-perm 安装完毕后，会在用户目录下的 .config 目录下生成一个 verdaccio 文件夹，配置文件 config.yaml 就在这个文件夹内。 启动直接在命令行键入 verdaccio 启动。控制台会答应几行warn： 1234warn --- config file - /Users/zachary/.config/verdaccio/config.yamlwarn --- Plugin successfully loaded: htpasswdwarn --- Plugin successfully loaded: auditwarn --- http address - http://localhost:4873/ - verdaccio/3.5.1 这其实是提示信息，告诉你 verdaccio 已经在 localhost:4873 端口启动。你可以打开查看： ip 访问上面启动后，我们会发现可以使用 localhost:4873 访问，但是不能使用本机 ip 访问。这样肯定是不行的。我们需要配置 config.yaml。 在 config.yaml 文件内添加监听端口： 1listen: 0.0.0.0:4873 # listen on all addresses 这样其它机器就可以通过 ip 访问了。 添加用户在 verdaccio 启动的情况下，我们通过 npm 注册用户： 1npm adduser --registry http://10.26.5.252:4873 npm adduser 是 npm login 的别名 之后会让你输入用户名密码以及邮箱。完成注册： 添加用户后，会在 verdaccio 文件夹内生成一个 htpasswd 文件，其中包含了所有注册的用户: 添加用户之后，默认就会在 .npmrc 中添加一个 token，如果后面要 publish 就得靠它： 上面 registry= 表示的是下载源； 两个注释的带有 authToken 的表示的是注册用户的token。 npm adducer 是用来注册的，如果已经注册了用户无法再次注册。可以直接在网页端登录生成 token，然后手动设置到 .npmrc 中。 切换下载源一般情况下我们切换npm下载源的方式如下： 1npm set registry http://localhost：4873 我们可以通过 nrm 更快的操作。nrm是 npm registry 管理工具, 能够查看和切换当前使用的registry。不安装也可以，安装会更高效。 安装 nrm1npm install -g nrm 添加私服地址到nrm我们需要给私服添加别名 mynpm 以供切换： 1nrm add mynpm http://localhost:4873 通过 nrm ls 可以查看我们可以使用的镜像源，可以看到 mynpm 已经添加进去了： 切换私服地址如下命令切换私服： 1nrm use mynpm 切换的其实是 .npmrc 中的配置: 发布包初始化一个测试包创建一个文件夹，并且新建一个 index.js 文件。使用 npm init 方法可以帮助我们快速创建一个 package.json 发布包使用 npm publish 发布包: 12npm publish #已经切换到我们私服地址的情况下npm publish --registry http://localhost:4873 #未切换到我们的私服时，直接加后缀可以发布到私服上。 登录到之前的网页可以看到发布成功的包，也可以在 .config/storage 找到相应文件： 下载只要切换了下载源，下载就和普通的 npm 一样,使用 npm install xxx 其他修改配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647listen: 0.0.0.0:4873 #监听所有地址storage: ./storage #npm包保存位置plugins: ./plugins #插件保存位置# 网页端的样式web: # WebUI is enabled as default, if you want disable it, just uncomment this line #enable: false title: Verdaccioauth: htpasswd: #用户列表保存的位置 file: ./htpasswd #可注册的用户数 #max_users: 1000#配置上游的npm服务器，主要用于请求的仓库不存在时到上游服务器去拉取。uplinks: npmjs: url: https://registry.npmjs.org/ taobao: url: https://registry.npm.taobao.org/packages: '@*/*': #@/ 表示某下属的某项目 #所有人都可以拉取，只有授权的用户可以publish，上游服务器为uplinks中的淘宝 access: $all publish: $authenticated proxy: taobao '**': #匹配项目名称 access: $all publish: $authenticated proxy: taobao# To use `npm audit` uncomment the following sectionmiddlewares: audit: enabled: true# log settingslogs: - &#123;type: stdout, format: pretty, level: http&#125; #- &#123;type: file, path: verdaccio.log, level: info&#125; 永久运行可以通过 forever 这个库将 verdaccio 永久运行。 1234#全局运行sudo npm install -g forever#使用forever启动verdaccioforever start `which verdaccio` 不过使用的时候最好还是看看官方文档 npm 后续使用创建与运行 npm script通过 npm init 命令创建 package.json。 在 package.json 的 scripts 字段中新增命令，如 eslint： 123456&#123; "scripts": &#123; "eslint": "eslint *.js", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;,&#125; 对于一些内置的 npm 命令，直接执行 npm+脚本名，如上面的 npm test 或者 npm start。自己定义的脚本需要使用 npm run +脚本名，如 npm run eslint。 npm script 钩子npm script 在执行之前会检查是否有pre 和 post 的钩子脚本。即如果运行 npm run test 脚本。会先检查是否有 pretest 脚本，如果有则执行，然后执行 test 最后执行 posttest: 1234567&#123; "scripts": &#123; "pretest": "npm run lint", "test": "mocha tests/", "posttest": "echo \"complete\"" &#125;,&#125; git hook 中执行 npm script我们使用 npm 库 husky。使用 npm install husky --save-dev 保存为 dev-denpendancy 中。然后我们的代码仓库的 .git/hooks 目录，会发现里面的钩子都被 husky 替换掉了: –save-dev 表示只保存为开发环境下使用的模块。在生产和发布的过程中不会将这部分模块打入包中。 接下来需要在 scripts 对象中增加 husky 能识别的 Git Hooks 脚本 precommit 和 prepush： 1234"scripts": &#123; "precommit": "npm run lint", "prepush": "npm run test",&#125; @scope有时候，我们看别人的 package.json 的时候，会看到 dependency 中有类似这样的东西： 12345&#123; "dependencies": &#123; "@somescope/someprojectname": "^1.0.0", &#125;,&#125; 所有的私有模块都是 scoped package 的，所以上面表示的是一个私有仓库。只有当你获得相应权限的时候才可以拉取使用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WKWebView 使用（一）—— 基本用法]]></title>
    <url>%2F2018%2F07%2F31%2Fwkwebview%2F</url>
    <content type="text"><![CDATA[WKWebView 的简单用法 基本用法创建1- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration; 比UIWebView多了个configuration，这个配置可以设置很多东西。具体查看WKWebViewConfiguration.h，可以配置js是否支持，画中画是否开启等，这里主要讲两个比较常用的属性: websiteDataStoreWKWebView 拥有自己的私有存储，它的一些缓存等数据都存在websiteDataStore中。 1@property (nonatomic, strong) WKWebsiteDataStore *websiteDataStore; 具体增删改查就可以通过WKWebsiteDataStore.h中提供的方法，这里不多说，一般用的时候比较少，真的要清除缓存，简单粗暴的方法是删除沙盒目录中的Cache文件夹。 userContentController这个属性很重要，js与oc交互，以及注入js都会用到。 1@property (nonatomic, strong) WKUserContentController *userContentController; 查看WKUserContentController的头文件，你会发现它有如下几个方法： 123456789101112@interface WKUserContentController : NSObject &lt;NSCoding&gt;//读取添加过的脚本@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts;//添加脚本- (void)addUserScript:(WKUserScript *)userScript;//删除所有添加的脚本- (void)removeAllUserScripts;//通过window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 来实现js-&gt;oc传递消息，并添加handler- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;//删除handler- (void)removeScriptMessageHandlerForName:(NSString *)name;@end 基本创建12345678910WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];WKUserContentController *controller = [[WKUserContentController alloc] init];configuration.userContentController = controller;self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];self.webView.allowsBackForwardNavigationGestures = YES; //允许右滑返回上个链接，左滑前进self.webView.allowsLinkPreview = YES; //允许链接3D Touchself.webView.customUserAgent = @"WebViewDemo/1.0.0"; //自定义UA，UIWebView就没有此功能，后面会讲到通过其他方式实现self.webView.UIDelegate = self;self.webView.navigationDelegate = self;[self.view addSubview:self.webView]; 动态注入js通过给userContentController添加WKUserScript，可以实现动态注入js。比如我先注入一个脚本，给每个页面添加一个Cookie 123//注入一个CookieWKUserScript *newCookieScript = [[WKUserScript alloc] initWithSource:@"document.cookie = 'DarkAngelCookie=DarkAngel;'" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];[controller addUserScript:newCookieScript]; 然后再注入一个脚本，每当页面加载，就会alert当前页面cookie: 1234//创建脚本WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:@"alert(document.cookie);" injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];//添加脚本[controller addUserScript:script]; 注入的js source可以是任何js字符串，也可以js文件。比如你本地可能就会有一个native_functions.js，你可以通过以下的方式添加： 1234NSString *jsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"native_functions" ofType:@"js"] encoding:NSUTF8StringEncoding error:nil];//添加自定义的脚本WKUserScript *js = [[WKUserScript alloc] initWithSource:jsSource injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];[self.configuration.userContentController addUserScript:js]; 加载123- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL - (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL; 比如加载主 bundle 中的一个html需要使用loadRequest:方法。loadReqest 这种方式会把当前load的这个html文件的路径作为baseURL，以此寻找其他资源。 1[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"test" ofType:@"html"]]]]; loadHTMLString:baseURL: 直接加载 html 字符串。baseURL 是 html 中资源的路径： 123NSString *html = @"....";// 加载 mainBundle 下的资源 `[[NSBundle mainBundle] resourcePath]` 获取 mainBundle 的路径字符串[self.wkWebView loadHTMLString:html baseURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] resourcePath]]]; 代理UIWebView的代理协议拆成了一个跳转的协议和一个关于UI的协议： 12@protocol WKNavigationDelegate; //类似于UIWebView的加载成功、失败、是否允许跳转等@protocol WKUIDelegate; //主要是一些alert、打开新窗口之类的 WKNavigationDelegate常用方法： 1234567891011121314//下面这2个方法共同对应了UIWebView的 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;//发送请求前：针对一次action来决定是否允许跳转，action中可以获取request，允许与否都需要调用decisionHandler，比如decisionHandler(WKNavigationActionPolicyCancel);- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler；//获取返回后：根据response来决定，是否允许跳转，允许与否都需要调用decisionHandler，如decisionHandler(WKNavigationResponsePolicyAllow);- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;//开始加载，对应UIWebView的- (void)webViewDidStartLoad:(UIWebView *)webView;- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;//加载成功，对应UIWebView的- (void)webViewDidFinishLoad:(UIWebView *)webView;- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;//加载失败，对应UIWebView的- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error; 示例：控制哪些站点可以被访问123456789func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) &#123; if let host = navigationAction.request.url?.host &#123; if host == "www.apple.com" &#123; decisionHandler(.allow) return &#125; &#125; decisionHandler(.cancel)&#125; WKUIDelegate当 JS 中调用 alert 等方法的时候，会来到这几个代理方法中，进行自定义操作。可以使用这个方式来进行 JS 向 Native 传递参数执行方法。 123456789101112131415161718192021222324252627282930313233/* 警告 */- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:message ? message : @"" preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123; completionHandler(); &#125;]]; [vc presentViewController:alert animated:YES completion:NULL];&#125;///** 确认框 */- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:message ? message : @"" preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(YES); &#125;]]; [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(NO); &#125;]]; [vc presentViewController:alert animated:YES completion:NULL];&#125;/** 输入框 */- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler&#123; [alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.textColor = [UIColor blackColor]; textField.placeholder = defaultText ? defaultText : @""; &#125;]; [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler([[alert.textFields lastObject] text]); &#125;]]; [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(nil); &#125;]]; [vc presentViewController:alert animated:YES completion:NULL];&#125; 新属性123456@property (nullable, nonatomic, readonly, copy) NSString *title; //页面的title，终于可以直接获取了@property (nullable, nonatomic, readonly, copy) NSURL *URL; //当前webView的URL@property (nonatomic, readonly, getter=isLoading) BOOL loading; //是否正在加载@property (nonatomic, readonly) double estimatedProgress; //加载的进度@property (nonatomic, readonly) BOOL canGoBack; //是否可以后退，跟UIWebView相同@property (nonatomic, readonly) BOOL canGoForward; //是否可以前进，跟UIWebView相同 这些属性都很有用，而且支持KVO，所以我们可以通过KVO观察这些值的变化，以便于我们做出最友好的交互。 OC JS 交互OC -&gt; JS12//执行一段js，并将结果返回，如果出错，error则不为空- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id result, NSError * _Nullable error))completionHandler; 示例，比如我想获取页面中的title，除了直接self.webView.title外，还可以通过这个方法： 123[self.webView evaluateJavaScript:@"document.title" completionHandler:^(id _Nullable title, NSError * _Nullable error) &#123; NSLog(@"调用evaluateJavaScript异步获取title：%@", title);&#125;]; JS -&gt; OCURL 拦截通过自定义Scheme，在链接激活时，拦截该URL，拿到参数，调用OC方法： 1234567891011121314151617181920212223// 在HTML中写上A标签直接填写假请求地址&lt;a href="myScheme://login?username=12323123&amp;code=892845"&gt;短信验证登录&lt;/a&gt;// 在JS中用location.href跳转location.href = 'wakaka://wahahalalala/action?param=paramobj'// 在JS中创建一个iframe，然后插入dom之中进行跳转$('body').append('&lt;iframe src="' + 'wakaka://wahahalalala/action?param=paramobj' + '" style="display:none"&gt;&lt;/iframe&gt;');- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; //可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等 NSURL *URL = navigationAction.request.URL; //判断URL是否符合自定义的URL Scheme if ([URL.scheme isEqualToString:@"myScheme"]) &#123; //根据不同的业务，来执行对应的操作，且获取参数 if ([URL.host isEqualToString:@"login"]) &#123; NSString *param = URL.query; NSLog(@"短信验证码登录, 参数为%@", param); decisionHandler(WKNavigationActionPolicyCancel); return; &#125; &#125; decisionHandler(WKNavigationActionPolicyAllow); NSLog(@"%@", NSStringFromSelector(_cmd));&#125; WKWebView 拦截：12345678910111213- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; //1 根据url，判断是否是所需要的拦截的调用 判断协议/域名 if (是)&#123; //2 取出路径，确认要发起的native调用的指令是什么 //3 取出参数，拿到JS传过来的数据 //4 根据指令调用对应的native方法，传递数据 //确认拦截，拒绝WebView继续发起请求 decisionHandler(WKNavigationActionPolicyCancel); &#125;else&#123; decisionHandler(WKNavigationActionPolicyAllow); &#125; return YES;&#125; 假跳转的缺点： 丢失消息。在同一个运行逻辑内快速的连续发送两个通信请求，那么后面的消息将收不到。 URL长度限制。 scriptMessageHandler在OC中添加一个scriptMessageHandler，则会在all frames中添加一个js的function： window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 。那么当我在OC中通过如下的方法添加了一个handler，如 12//配置对象注入[self.webView.configuration.userContentController addScriptMessageHandler:self name:@"nativeObject"]; 这里不能直接传入 self，会被 WKUserContentController 强引用，而不能销毁。所以需要创建一个代理类对象，类似于处理 NSTimer。 当我在js中调用下面的方法时: 12345678//准备要传给native的数据，包括指令，数据，回调等var data = &#123; action:'xxxx', params:'xxxx', callback:'xxxx',&#125;;//传递给客户端window.webkit.messageHandlers.nativeObject.postMessage(data); 注意，postMessage 方法要求必须要有一个参数，即使是一个空对象，也要写成 postMessage({})，否则 native 无法收到消息。 在OC中将会收到WKScriptMessageHandler的回调 1234567-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; //1 解读JS传过来的JSValue data数据 NSDictionary *msgBody = message.body; //2 取出指令参数，确认要发起的native调用的指令是什么 //3 取出数据参数，拿到JS传过来的数据 //4 根据指令调用对应的native方法，传递数据&#125; 我们可以把js的function转换为字符串，再传递给OC。再让 OC 通过 evaluateJavaScript:completionHandler: 调用，将结果传出。就实现了 js-&gt;oc-&gt;js-&gt;oc 的回调 记得在适当的地方调用 removeScriptMessageHandler: 1234- (void)dealloc &#123; //移除对象注入 [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"nativeObject"]; &#125; WKUIDelegate前面说到，WKUIDelegate 协议中的几个弹窗方法，可以用来实现 JS2OC 的通信。前面几种 JS2OC 的通信的 callback 都需要 OC自己调用 OC2JS 的异步方法返回。而使用 WKUIDelegate 可以同步返回结果。 JS 端调用 12345678var data = &#123; action:'xxxx', params:'xxxx', callback:'xxxx',&#125;;var jsonData = JSON.stringify([data]);//发起弹框prompt(jsonData); 客户端拦截： 12345678910111213- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler&#123; //1 根据传来的字符串反解出数据，判断是否是所需要的拦截而非常规H5弹框 if (是)&#123; //2 取出指令参数，确认要发起的native调用的指令是什么 //3 取出数据参数，拿到JS传过来的数据 //4 根据指令调用对应的native方法，传递数据 //直接返回JS空字符串 completionHandler(@""); &#125;else&#123; //直接返回JS空字符串 completionHandler(@""); &#125;&#125; 这里 prompt 和 defaultText 就是 JS 端传来的数据。通过 completionHandler() 就可以同步将值返回了。js 端调用接收： 1let result = window.prompt(somePrompt, someDefaultText) JavaScriptCoreJavaScriptCore是苹果Safari浏览器的JavaScript引擎 OC 调用 JSOC 调用 JS 可以直接使用 evaluteScript 方法： 1234567#import &lt;JavaScriptCore/JavaScriptCore.h&gt;int main() &#123; JSContext *context = [[JSContext alloc] init]; JSValue *value = [context evaluateScript:@"2 + 2"]; NSLog(@"2 + 2 = %d", [value toInt32]); return 0&#125; JSContext JSContext 是JS代码的执行环境。JSContext 为JS代码的执行提供了上下文环境，通过jSCore执行的JS代码都得通过JSContext来执行。 JSContext对应于一个 JS 中的全局对象。JSContext对应着一个全局对象，相当于浏览器中的window对象，JSContext中有一个GlobalObject属性，实际上JS代码都是在这个GlobalObject上执行的，但是为了容易理解，可以把JSContext等价于全局对象。我们甚至可以直接在 JSContext 上拿 GlobalObject 的属性。 123456789101112JSValue *value = [context evaluateScript:@"var a = 1+2*3;"];NSLog(@"a = %@", [context objectForKeyedSubscript:@"a"]);NSLog(@"a = %@", [context.globalObject objectForKeyedSubscript:@"a"]);NSLog(@"a = %@", context[@"a"]);/Output:a = 7a = 7a = 7 JSValue JSValue 是对 JS 值的包装。JS中的值拿到OC中是不能直接用的，需要包装一下 JSValue存在于JSContext中。JSValue是不能独立存在的，它必须存在于某一个JSContext中。 JSValue对其对应的JS值和其所属的JSContext对象都是强引用的关系。因为jSValue需要这两个东西来执行JS代码，所以JSValue会一直持有着它们。 示例： js 代码： 123456// 计算阶乘var factorial = function (n) &#123; if (n &lt; 0) return if (n === 0) return 1 return n * factortial(n-1)&#125; oc 调用： 123456NSString *factorialScript = [self loadJSFromBundle];JSContext *context = [[JSContext alloc] init];[context evaluteScript: factorialScript];JSValue *function = context[@"factorial"];JSValue *result = [function callWithArguments:@[@5]];NSLog(@"factorial(5) = %d", [result toInt32]); 从 Bundle 中拿到 js 代码执行，从 context 中拿到方法，然后通过 callWithArguments 执行，执行后得到 JSValue 的值。 JS 调用 OC两种方式可以让 OC 暴露方法给 JS： Block：可以将 OC 中的单个方法暴露给 JS 调用。 JSExport协议：可以将OC的中某个对象直接暴露给JS使用 BlockJSCore会自动将这个Block包装成一个JS方法： 123456context[@"makeNSColor"] = ^(NSDictorary * colors)&#123; float r = [colors[@"red"] floatValue]; float g = [colors[@"green"] floatValue]; float b = [colors[@"blue"] floatValue]; return [NSColor colorWithRed:(r / 255.0) green:(g / 255.0) blue:(b / 255) alpha:1.0];&#125; js 端就可以直接调用这个 makeNSColor 方法了。运行得到一个 NSColor 对象，在 js 中表现为一个 object。 如果我们在 js 端再对这个方法封装一下： 123var colorForWord = function (word) &#123; return makeNSColor(word)&#125; 在 oc 端调用的示意图如下： OC Caller去调用这个colorForWrod函数，因为colorForWrod函数接收的是一个String类型那个参数word，OC Caller传过去的是一个NSString类型的参数，JSCore转换成对应的String类型。然后colorForWrod函数继续向下调用，就像上面说的，知道其拿到返回的wrapper Object，它将wrapper Object返回给调用它的OC Caller，JSCore又会在这时候把wrapper Object转成JSValue类型，最后再OC中通过对JSValue调用对应的转换方法，即可拿到里面包装的值，这里我们调用- toObject方法，最后会得到一个NSColor对象，即从最开始那个暴露给JS的Block中返回的对象。 注意点 不要在Block中直接使用JSValue。 不要在Block中直接使用JSContext。 Block会强引用它里面用到的外部变量，如果直接在Block中使用JSValue的话，那么这个JSvalue就会被这个Block强引用，而每个JSValue都是强引用着它所属的那个JSContext的，这是前面说过的，而这个Block又是注入到这个Context中，所以这个Block会被context强引用，这样会造成循环引用，导致内存泄露。不能直接使用JSContext的原因同理。所以建议把JSValue当做参数传到Block中，而不是直接在Block内部使用，这样Block就不会强引用JSValue了。 针对第二点，可以使用[JSContext currentContext]方法来获取当前的Context。 JSExport 协议通过JSExport 协议可以很方便的将OC中的对象暴露给JS使用，且在JS中用起来就和JS对象一样。 声明一个自定义的协议并继承自JSExport协议。然后当你把实现这个自定义协议的对象暴露给JS时，JS就能像使用原生对象一样使用OC对象了： 参考WKWebView 那些坑 iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够 从零收拾一个hybrid框架（二）– WebView容器基础功能设计思路 自己动手打造基于 WKWebView 的混合开发框架 WebViewJavascriptBridge 源码中 Get 到的“桥梁美学”]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux 基础]]></title>
    <url>%2F2018%2F06%2F05%2FRedux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[记录一下 redux 文档的一些要点。以及学习 redux 中的一些经验。 介绍动机因为单页应用变得复杂，JavaScript 要管理比任何时候都要多的 state。state 在什么时候，由于什么原因，如何变化变得不受控制。这里产生了矛盾：组件之间需要共享数据，和数据可能被任意修改导致不可预料的结果之间的矛盾。Redux 试图让 state 的变化变得可预测。 三大原则单一数据源整个应用的 state 被存储在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。确保视图和网络请求不能直接修改 state。 使用纯函数来执行修改为描述 action 如何改变 state tree，需要编写 reducers。Reducer 只是一些纯函数，它接收先前的 state 和 action，返回新的 state。你可以把 reducer 拆分为多个小的 reducer，独立地操作 state tree 的不同部分。 基础ActionAction 是把数据从应用传到 store 的有效载荷。一般你会通过 store.dispatch() 将 action 传到 store。 Action 本质上是 JS 普通对象。约定 action内必须使用一个字符串类型的 type 字段来表示将要执行的动作。 最简单的 Action 如： 12345const ADD_TODO = 'ADD_TODO'&#123; type: ADD_TODO, text: 'build my first redux app'&#125; Action 创建函数在 Redux 中的 action 创建函数只是简单的返回一个 action。这样做将使 action 创建函数更容易被移植和测试，如： 123456function addTodo (text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Action 创建函数也可以是异步非纯函数。后面会讨论到。 ReducerAction 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。Reducer 则是用来更新 state Action 的处理reducer 就是一个纯函数，接受旧的 state 和 action，返回新的 state： 1(previousState, action) =&gt; newState 永远不要再 reducer 中执行这些操作： 修改传入的参数 执行有副作用的操作，如 API 请求或路由跳转 调用非纯函数，如 Date.now() reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。 12345678910function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) default: return state &#125;&#125; 需要注意： 强烈不推荐直接修改 state。所以这里用 Object.assign() 新建了一个副本(Object.assign() 会把后面的 set 到第一个参数里，所以这里要放一个空对象)。 default 的情况下，返回旧的 state。遇到未知的 action 时，也要返回旧的 state。 拆分 ReducerReducer 合成是 Redux 应用最基础的模式，可以把一个复杂的 reducer 逻辑拆分到一个个单独的函数里。每个 reducer 只负责管理全局 state 中它负责的那一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。 其实就是本来有很多 switch…case，判断不同的 action.type 来对 state 的某个部分做不同的操作。每个 state 的部分，可能会在多个 action.type 中都会被修改。 现在就把处理相同的 state 的部分的操作都拿出来，单独作为一个 reducer。所有会操作这个 state 部分的 action.type 都会调用这个 reducer。然后在这个小的 reducer 中判断到底是那个 action.type 对应怎么处理这部分 state。 Redux 提供了 combineReducers() 工具类来完成各个小 reducer 的调用，需要传入各个子 reducer 所组成的对象。 1234567891011121314151617181920212223import &#123; combineReducers &#125; from 'redux'// 注意，拆分出来的 reducer 中的 state 不是完整的 state，而是 state 中的属性，和方法名相同，此处就是 visibilityFilter。返回的也不是完整的 state，而只是 visibilityFilterfunction visibilityFilter(state = '', action) &#123; switch (action.type) &#123; case VISIBILITY_FILTER: return action.filter default: return state &#125;&#125;const todoApp = combineReducers(&#123; visibilityFilter, // visibilityFilter 是 state 中的一个属性 todos // todos 是 state 中的一个属性&#125;)export default todoApp// 调用todoApp(state = initialState, action) &#123; ...&#125; combineReducers() 所做的只是生成一个函数，这个函数来调用你的一系列的 reducer。每个 reducer 会根据它们的 key（reducer 名） 来筛选出 state 中的一部分数据并处理。然后这个生成的函数再将所有的 reducer 的结果合并为一个大的对象。(每个小 reducer 拿到的不是整个的 state，而是这个 reducer 对应的 state 中的部分属性。一个 action 的 type 可以影响多个 reducer，最后每个 reducer 生成的 state 中的属性会被合并到 state 中。) 没有拆分前是横向的，以 action.type 为基准的。一次 reducer 处理中，能处理多个 state 中的属性。 拆分之后是纵向的，是以 state 中属性为基准的。一次 reducer 处理只能处理 state 中的一个属性。多次处理后，合成一个完整的 state。 StoreStore 是把 action 和 reducer 联系到一起的对象。Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 提供 subscribe(listener) 注册监听器； 提供 subscribe(listener) 返回的函数注销监听器； 切记，redux 应用只有一个单一的 store。当需要拆分数据处理逻辑的时候，应该使用 reducer 组合而不是创建多个 store。 前面使用 combineReducers() 将多个 reducer 合并成一个。现在要将其传递给 createStore() 即可完成 Store 的创建。createStore() 的第二个参数是可选的，用于设置 state 的初始状态。 数据流严格的单项数据流是 redux 架构的设计核心。这意味着应用中所有的数据都遵循相同的生命周期，可以让应用变得可以预测和容易理解。 redux 的生命周期遵循下面四步： 调用 store.dispatch(action) Redux store 调用传入的 reducer 函数。将当前的 state 树和 action 传入 reducer。 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。 Redux store 保存了根 reducer 返回的完整 state 树。 搭配 react通过 react-redux 将 react 和 redux 融合。组件将被分为展示组件和容器组件。展示组件仅仅是用来展示，它的所有数据都是从 props 中获得。而容器组件则是展示组件的外层封装，用来和 redux 打交道，把 state 传入展示组件。 展示组件展示组件值定义外观并不涉及数据从哪里来，如何改变它。传入什么就渲染什么。如果把代码从 redux 迁移到其他架构，这些组件可以直接使用。他们并不依赖于 redux。 容器组件容器组件将展示组件连接到 redux（相当于一个适配器）。例如，展示型的 TodoList 组件需要一个类似 VisibleTodoList 的容器组件来监听 Redux store 变化并处理如何过滤出要显示的数据。 技术上讲，容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。可以手工开发容器组件，但是建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免许多不必要的重复渲染（这样就不用手动实现 React 性能优化建议中的 shouldComponentUpdate 方法了）。 因为容器组件是 state 和展示组件的中间件，所以可以在这里按需先处理一下 state，然后再把处理过的 state 传给展示组件。所以可以定义 mapStateToProps 函数来指定如何把当前 Redux store state 映射到展示组件中的 props 中。 例如，VisibleTodiList 需要计算传到 Todolist 中的 todos ，所以定义了根据 state.visibilityFilter 来过滤 state.todos 的方法，并在 mapStateToProps 中使用： 12345678910111213141516const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos,state.visibilityFilter) &#125;&#125; 这个在 return 中的 todos 就直接成为了该显示组件的 this.props 的一员，可以直接通过 const {todos} = this.props 获取。 除了显示的数据作为 props 传入，显示组件还需要外部容器组件传入一些事件处理方法。类似的，可以定义 mapDispatchToProps() 方法接收 dispatch 方法并返回希望被注入到展示组件的 props 中的回调方法。例如，我们希望 VisibleTodoList 向 TodoList 组件中注入一个叫 onTodoClick 的方法到 props 中，这个 onTodoClick 能 dispatch 一个 action: 1234567const mapDispathToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125; 也就是说，不仅可以把 state 修改好了传进去，也可以把响应事件设置好，再传进去。同样，可以直接通过 const {onTodoClick} = this.props 获取这个响应事件。 最后，使用 connect() 创建 VisibleTodoList,将两个参数传入： 12345678import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 然后外部就可以直接使用 VisibileTodoList 组件了。 容器组件实例： 传入 Store所有容器组件都可以访问 Redux Store，可以手动监听 store（虽然直接访问会多很多重复代码），但是推荐使用 React Redux 组件 &lt;Provider&gt; 来让所有容器组件都可以访问 store，而不必显示的传递它。只需要在渲染根组件时使用即可。 1234567891011121314import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store=&#123;store&#125;&gt; &lt;APP /&gt; &lt;/Provider&gt;) 关于 react-reduxreact 中的每个属性都要通过 props 一层层传递。如果层级很多，会比较麻烦。所以 react 引入了 context。某个组件只要往自己的 context 里面放了某些状态，这个组件之下的所有子组件都直接访问这个状态而不需要通过中间组件的传递。 也就是说父组件中设置了 context，子组件就可以通过 this.context.xxx 拿到相应属性使用并修改。这就导致了第一个问题，使用 context 是非常危险的，子组件可以随意修改。还有另一个问题是，如果每个子组件都是用 context，那么组件复用将变得非常困难。 针对问题一， context 和 store 结合的就非常的完美。context 会担心其中数据被随意修改。而 store 中的数据只能通过 dispatch 修改。所以可以把 store 方到 context 中去。 针对问题二，便有了上面的 connect 方法，通过显示组件生成容器组件的过程。显示组件只负责根据传入的 props 显示，和纯函数一样，便于复用。connect 方法生成的容器组件要做的就是获取 this.context 中的 store 进而 store.getState() ,把 map 过的 state 传给显示组件。 这样展示组件中获取 context 都的操作都消失了。但是在最外层组件里还有设置 context 的操作。为了将这部分脏代码消除。就 react-redux 提供了一个 Provider 组件。你只要传入一个 store，它就会把它放到 context 中去。 高级异步 Action如何把之前定义的同步 action 创建函数和网络请求结合起来？标准做法是使用 Redux Thunk middleware。要引入 redux-thunk 这个专门的库才能使用。 通过使用指定的 middleware，action 创建函数除了返回 action 对象外，还可以返回函数。这时，这个 action 创建函数就成为了 thunk。 当 action 创建函数返回函数时，这个函数会被 Redux Thunk middleware 执行。 其实就是本来要 dispatch 一个 js 对象的 action 的，现在 dispatch 一个函数，这个函数用来获取网络数据，然后在这个函数里 dispatch 请求得到的数据。最开始调用的 dispatch 在判断对象是函数后，就没有其他作用了。 中间件就是在传入 action 后和在真正 dispatch 前插入一些逻辑。thunk 中间件就是插入了判断 dispatch 传入的是不是函数的逻辑，是函数就调用，不是函数，就和普通方式一样直接 dispatch 我们要如何在 dispatch 机制中引入 Redux Thunk middleware 呢？使用 applyMiddleware: 123456789impoort thunkMiddleware from 'redux-thunk'const store = createStore( rootReducer, applyMiddleware( thunkMiddleware ))store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState())) // fetchPosts 函数是一个自定义的函数，在里面会进行网络请求 并不是说 thunk 是唯一解决方式，还可以使用 redux-promise，redux-promise-middleware。 需要了解的是这种处理异步的方式。 Middleware我们知道，我们 store.dispatch(action) 后，dispatch 方法中会调用 reducer 。但是我们很多时候希望在执行 reducer 之前或者之后做一些其他的操作，比如记录日志等，这个时候就需要使用 middleware。 middleware 所做的就是替换 redux 提供的 dispatch 方法: 1234567let next = store.dispatchstore.dispatch = function dispatchAndLog(action) &#123; console.log(action) let result = next(action) console.log(store.getState()) return result&#125; 可以看到，现在 store.dispatch 一个 action 的前后都会执行 log。并且现在的 dispatch 还会返回原本的 dispatch 的返回值(虽然这里原本的 dispatch 是 redux 的 dispatch ，不反回任何，但是如果 middleware 修改过的 dispatch 可能会返回 result，所以还是需要 return 的) 现在我们考虑有多个 middleware 需要应用。我们需要把上一个 middleware 修改过的 dispatch 传入 下一个 middleware。那么考虑这个中间件方法需要几个参数：store，上一个中间件修改过的 dispatch，action。所以我们可以采用函数式： 123456789101112const logger = store =&gt; next =&gt; action =&gt; &#123; console.log(action) let result = next(action) console.log(store.getState()) return result&#125;const thunk = store =&gt; next =&gt; action =&gt; &#123; typeof action === 'function' ? action(store.dispatch, store.getState) : next(action)&#125; 这样，在 createStore() 的时候，不只是传入一个 reducer，还包括一个中间件参数： 1234567let store = createStore( todoApp, applyMiddleware( logger, thunk, )) applyMiddleware 应该做的是这样一个操作： 123store.dispatch = middlewares.reduce((middleware, preDispatch) =&gt; &#123; return middleware(store)(preDispatch)&#125;, store.dispatch) 所以最终的 dispatch 会是一个多层 middleware 嵌套的结构，每一个 middleware 中的 next(action) 都是执行指向下一个 middleware，而执行 store.dispatch(action) 就是重新执行一遍 middleware 链。如图： 组织 reducer对于单个的 reducer，项目复杂后，reducer 可能会变得非常的长： 1234567891011121314151617181920function appReducer(state = &#123;&#125;, action) &#123; switch(action.type) &#123; case 'ADD_TODO' : &#123; return Object.assign(&#123;&#125;, state, &#123; todos: state.todos + action.add &#125;) &#125; case 'TOGGLE_TODO' : &#123; return Object.assgin(&#123;&#125;, state, &#123; todos: state.todos + action.toggle &#125;) &#125; case 'SET_VISIBILITY_FILTER' : &#123; return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) &#125; ... &#125;&#125; 可以看到，这样的代码含有两个问题： 多个字段的处理逻辑都放在一个方法里，不够清晰 会包含非常多的 switch…case… 方法，很多冗余代码 分离字段针对第一个问题我们可以为每个字段都实现一个子 reducer，然后把各部分返回的结果组合： 123456789101112131415161718192021222324252627282930313233function setVisibilityFilter(visibilityState, action) &#123; return action.filter&#125;function addTodo(todoState, action) &#123; return todoState + action.add&#125;function toggleTodo(todoState, action) &#123; return todoState + action.toggle&#125;function visibilityReducer(visibilityState = 'SHOW_ALL', action) &#123; switch(action.type) &#123; case 'SET_VISIBILITY_FILTER' : return setVisibilityFilter(visibilityState, action) default : return visibilityState &#125;&#125;function todosReducer(todoState, action) &#123; switch(action.type) &#123; case 'ADD_TODO' : return addTodo(todoState, action) case 'TOGGLE_TODO': return toggleTodo(todoState, action) default : return todosState &#125;&#125;function appReducer (state = &#123;&#125;, action) &#123; return &#123; todos: todosReducer(state.todos, action) visibilityFilter: visibilityReducer(state.visibilityFilter, action) &#125;&#125; 这样的写法把各个字段分别处理，逻辑就清晰了很多。combineReducers 其实做的就是同样的事。 减少样板代码针对问题二提到的 switch...case… 产生的样板代码，js 的语言特性可以很好地消除： 123456789101112131415161718192021222324252627282930function addTodo(todoState, action) &#123; return todoState + action.add&#125;function toggleTodo(todoState, action) &#123; return todoState + action.toggle&#125;// 消除样板代码的主要方法function createReducer(initialState, handlers) &#123; return function reducer(state = initialState, action) &#123; if (handlers.hasOwnProperty(action.type)) &#123; return handlers[action.type](state, action) &#125; else &#123; return state &#125; &#125;&#125;const todoReducer = createReducer(&#123;&#125;, &#123; addTodo, toggleTodo,&#125;)function appReducer (state = &#123;&#125;, action) &#123; return &#123; todos: todosReducer(state.todos, action) visibilityFilter: visibilityReducer(state.visibilityFilter, action) &#125;&#125; 用方法名来替代 case，也就是替代 action.type。然后把这些方法合在一起生成一个 reducer。这种方式就是类似 redux-actions 中 handleActions 的实现方式。 这一小节其实是非常重要的。介绍了两个 reducer 的处理方式 将一个 reducer 拆分成多个小 reducer，每一个 reducer 只负责 state 中相对应的一部分。这样的拆分可以是多层级的，即小 reducer 可以拆分成很多很多小小 reducer。具体见下图 在每一个最小粒度的 reducer 中，又根据不同的 action.type 拆分出许多与之对应的方法。这些方法组合成 reducer。redux 会遍历所有的 reducer 找出对应 action.type 的处理方法，所以不同模块一般要在这些方法前加上 namespace 的前缀，否则容易一个 action 触发多个同名(action.type 相同)方法。 常见问题Redux 只能搭配 React？Redux 可以作为任何 UI 层的 store。但是一般在结合 UI 随 state 变化时，Redux 能发挥最大的作用。 Reducer如何在 reducer 间共享 state？combineReducers 是必须的吗？redux store 推荐结构是将 state 分成”层”，并提供独立的 reducer 方法管理各自的数据层。 许多用户想要在 reducer 之间共享数据，但是 combineReducers不允许此种行为。如果一定要这样做，你需要： 重构 state 层，让单独的 reducer 处理更多的数据。 自定义方法处理这些 action，用自定义的顶层 reducer 方法替换 combineReducers 。使用 combineReducers 处理尽可能多的 action，同时为存在 state 交叉部分的 action 执行更专用的 reducer。 类似于 redux-thunk 的异步 action 创建函数可以通过 getState() 方法获取所有的 state。action 创建函数能从 state 中检索到额外的数据并传入 action。所以 reducer 有足够的信息去更新 state 层。 处理 action 必须使用 switch 语句嘛？不必要，但是 switch 是最常用的方式。也可以用 if 或者上面组织 reducer 中使用的方式。 State是否所有 state 都维护在 redux 中？一般来说业务数据放在 redux 中，页面数据则不必要。 Store可以创建多个 store 嘛？最好不要创建多个 store，而是尝试组合 reducer。 能在组建里直接使用 store 并使用吗？最好不要直接获取 store 实例。借助 react-redux，由 connect() 将 &lt;Provider store={store}&gt; 传入的 store 通过 mapStateToProps 传入子组件。 性能每个 action 都调用所有的 reducer 会不会很慢？不会 reducer 中必须对 state 进行深拷贝么？你需要创建一个 state 的副本，但是 state 中的没有变化的数据，还是使用浅拷贝，变化的才会创建新的引用。 react redux为何组件没有被重新渲染，或者 mapStateToProps 没有运行？action 分发后没有重新渲染，最主要的原因是对 state 进行了直接修改。React Redux 会在 shouldComponentUpdate 中对新的 props 进行浅层的判等检查。如果所有的引用都是相同的，那么返回 false 从而跳过此次组价你的更新。 所以，要注意，不管何时更新了一个嵌套值，都必须返回上层的数据的副本给 state 树。即如果数据是 state.a.b.c.d 中的 d 变化，你也必须返回 c,b,a,state 的拷贝。 为何组件频繁重新渲染？react redux 做了优化，会对 mapStateToProps 传入的 props 判等。但是如果每次 mapStateToProps 都生成新的对象实例的话，这种判等就没有用处了。比如： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; objects: state.objectIds.map(id =&gt; state.objects[id]) &#125;&#125; 通过 map 会生成新的实例。所以判等也就不可能成功了。 这种可以使用 Reselect，在 mapStateToProps 前就进行判断是否需要 map state。 redux 应该只连接到顶层组件嘛？并不是。当你感觉到你是在父组件里通过复制代码为某些子组件提供数据时，就可以抽出一个容器组件了。只要你认为父组件过多了解子组件的数据或者 action，就可以抽取容器。 Genji4rnGenji4rn.js 是一个借鉴了 Dva.js 的框架。集成了 router 以及 redux。这里主要讨论 redux 相关部分的 RN 中的实现。 需求分析在分析一个框架的时候，我们需要思考，这个框架需要帮助使用者完成那些步骤，以及需要使用者提供哪些东西。 通过前面 redux 的学习，我们可以发现，用户没有必要知道 Store 是如何创建的（createStore），没有必要知道 reducer 是如何合成的(combineReducer)，没有必要知道 redux 分发事件 dispatch,没有必要知道根视图 Provider，没有必要知道 state 树如何形成的，没有必要知道 reducer 和 state 中属性一一对应，没有必要知道 mapStateToProps 以及 mapDispatchToProps，没必要知道 applyMiddleware，没必要知道 action.type 判断的 switch…case…。 需要使用者提供的是，哪些方法以及哪些属性是需要作为 props 传入模块的， props 中的方法需要执行什么异步操作(action)，以及如何影响 props 中的属性的(state)。 带着上面的想法，我们可以大概推测一下 Genji4rn 做了什么。 为每一个模块设置一个 reducer。这个 reducer 应该和 state 中相应属性同名。每个 reducer 中应该包含很多的方法，这些方法代表着不同的 action.type 的处理方法。为了和其他模块的 action.type 的处理方法不重名，还需要为这些方法添加模块特有的前缀。在 dispatch(action) 的时候，type 就要是包含前缀的方法名。 隐藏任何关于 redux 的东西。state 不需要从 store 中取。设置 state 的时候，也不要出现 dispatch 方法。 使用首先在 RN 的入口 index.ios.js 中： 1234567891011121314151617181920import Genji4rn from 'Genji4rnjs/mobile'import React, &#123; Component &#125; from 'react'const App = new Genji4rn()App.registerModule(require('./modules/properties'))App.registerModule(require('./modules/todoApp'))const AppComponent = App.start()class CRM extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;AppComponent /&gt; &#125;&#125; React.AppRegistry.registerComponent('reactNativeCrm', () =&gt; CRM); 通过 Genji4rn 实例的 registerModule 方法可以注册模块。模块示例如下： 12345678910111213141516171819202122import &#123; connect &#125; from 'Genji4rnjs'import model from './model'module.exports = &#123; models: model, views: &#123; TodoApp: connect((state) =&gt; &#123; return &#123; ...state.todoApp, todos: state.todoApp.todos.filter(todo =&gt; &#123; if (state.todoApp.filter === VisibilityFilters.ALL) &#123; return true; &#125; else if (state.todoApp.filter === VisibilityFilters.COMPLETED) &#123; return todo.completed; &#125; else if (state.todoApp.filter === VisibilityFilters.INCOMPLETE) &#123; return !todo.completed; &#125; &#125;) &#125; &#125;, model)(require('./views/index.js')) &#125;&#125; 引入了和方法相关的 model 以及和视图相关的 view。导出 models 主要是为了导出模块的 state 以及 reducer，以此创建 store。导出 view 的时候，使用了 Genji4rn 提供的 connect 把两者组合，其实就是相当于设置里 mapStateToProps 和 mapDispatchToProps。 一个标准的 model 写法如下： 1234567891011module.exports = &#123; namespace: '', state: &#123; &#125;, handlers: [ ], publicHandlers: [ ], reducers: &#123; &#125;,&#125; 其中，namespace 就是当前模块名，对于多层级的 namespace，Genji4rn 会将其转为多层级的对象结构。namespace 会被作为当前模块的在全局的 state 树的名字，以及相对应的 reducer 的名字。 state 为当前模块的初始状态，也就是在 state 树中属性的具体值。 handlers 为当前模块能调用的方法，会以 mapDispatchToProps 的形式传入 view。publicHandlers 为全局都能调用的方法，所以会加入到每一个模块的 mapDispatchToProps 中去。 reducers 会被 Genji4rn 做进一步处理。先将数组中的各个方法组合成该模块的 reducer，然后将这些 reducer combineReducer 为一个大的 reducer。这里 reducers 里的各个方法分别对应 action 的不同 type。 注册完模块，通过 Genji4rn 实例的 start 方法，返回一个视图，作为 RN 的根视图。 另外还有一块关于 middlerware 的方面。使用 Genji4rn 实例的 use 方法注册中间件： 原理注册相关（主要是设置 reducer）通过 Genji4rn 提供的初始化方法，可以创建一个包含所有信息的实例，相当于是之后所有视图以及逻辑的根： 123456789101112131415161718192021const app = &#123; // properties _models: [], _reducers: &#123;&#125;, _views: &#123;&#125;, _router: null, _routerProps: &#123;&#125;, _routes: null, _store: null, _history: null, _isomorphic: hooks.isomorphic || false, // server-render options // methods use, // add redux-middlewares, extra-reducers, etc registerModule, // register a module router, // config router start, // start Genji4rn instance getStore, // get redux store getRoutes, // get router config getModule, // get the register module&#125;; 随后我们会调用 registerModule 方法注册模块。注册模块的主要逻辑如下： 123456789101112131415161718192021222324252627282930313233343536if (isPlainObject(module.models)) &#123; let Actions = &#123;&#125; let namespace = module.models.namespace.replace(/\/$/g, ''); // events should be have the namespace prefix Object.keys(module.models.reducers).map((key) =&gt; &#123; if (key.startsWith('/')) &#123; // starts with '/' means global events // 如果reducer 以 '/' 开头，那么就不会添加命名空间，表示用户明确知道需要哪个 type 触发。 Actions[key.substr(1)] = module.models.reducers[key]; &#125; else &#123; Actions[namespace + '/' + key] = module.models.reducers[key]; &#125; &#125;) let _temp = handleActions(Actions, module.models.state) let _arr = namespace.split('/') _mergeReducers(this._reducers, _arr, _temp)&#125;if (module.publicHandlers &amp;&amp; Array.isArray(module.publicHandlers)) &#123; module.publicHandlers.map((item) =&gt; &#123; GlobalContext.registerHandler(namespace.replace(/\//g, '.') + '.' + item.name, item.action) &#125;)&#125;/** * private method * merge reducers by hierachy * user/login, user/info -&gt; user:&#123; login, info &#125; */function _mergeReducers(obj, arr, res) &#123; if(arr.length &gt; 1) &#123; let hierachy = arr.splice(0,1)[0] obj[hierachy] = obj[hierachy] || &#123;&#125; _mergeReducers(obj[hierachy], arr, res) &#125; else &#123; obj[arr[0]] = res || &#123;&#125; &#125;&#125; 前面说过 reducers 数组中的方法对应的是不同的 action.type。为了区分不同模块的 action.type，需要为其中的每个方法都添加上 namespace。但是还有一些方法就不需要添加 namespace，因为这些方法表示的 action.type 是为了响应其他模块发出的 dispatch 而创建的。如下图： 随后将处理好的 reducers 通过 redux-actions 的 handleActions 方法，将其转化为一个 reducer。相当于把一个个独立的方法转化为 switch…case… 了。 创建 reducer 的时候，其实就已经把 defaultState 传进去了。所以后面创建 store 的时候就不需要总的 initialState 了 之后通过 _mergeReducers 方法把上面生成的各个 reducer 放到 Genji4rn 实例的 _reducers 的各个命名空间下。比如 namespace 为 order/newOrder 的模块，它的 reducer 就放在 Genji4rn 实例对象的 _reducers.order.newOrder 下，等待最后的 combineReducer。 最后，把 publicHandlers 中的所有方法保存到 GlobalContext 中去。publicHandlers 中的方法所有模块都能通过 GlobalContext 获取并使用： 这里是一个非常重要的注释，用来探讨 publicHandlers 和全局的 reducer 的适用场景 publicHandlers 的适用场景是，其他人的变动要通知我做出相应变动的情况。即多对一。 全局 reducer 的适用场景是，我的变动要通知其他人的变动的情况。即一对多。 注册模块的逻辑就是这样。现在需要把各个部分糅合到一起。Genji4rn 提供了 start 方法： 1234567891011121314151617181920212223242526272829/** * start the whole Genji4rn instance * return React.Component */function start(container) &#123; const me = this const AppNavigator = me._router; // react-navigation let store = getStore.call(me) const isomorphic = me._isomorphic const App = (&#123; dispatch, nav &#125;) =&gt; ( &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123; dispatch, state: nav &#125;)&#125; /&gt; ); const mapStateToProps = state =&gt; (&#123; nav: state.nav, &#125;); const AppWithNavigationState = connect(mapStateToProps)(App); return class extends Component &#123; render() &#123; isomorphic ? store = getStore.call(me) : null return ( &lt;Provider store=&#123;store&#125;&gt; &lt;AppWithNavigationState /&gt; &lt;/Provider&gt; ) &#125; &#125; &#125; start 整合了 redux-react 的功能。主要创建了 store 以及提供了 Provider。 这里有一部分 navigation 相关功能。App 是一个显示组件，至于这种写法，其实就相当于router 组件需要 store 的 dispatch 方法以及 state 的 nav 属性作为 props 传入。然后的 connect 方法也确实是这样做的。connect 方法创建了一个容器组件 AppWithNavigationState ，然后将其作为 Provider 的子组件。 再回到创建 store 的过程： 12345678910111213141516171819202122/** * create the redux-store */function getStore() &#123; let middlewares = plugin.get('onAction'); let enhancer = applyMiddleware(...middlewares) if (typeof __DEV__ !== 'undefined' &amp;&amp; __DEV__) &#123; // dev mode const devTools = plugin.get('dev') || ((noop) =&gt; noop) if(devTools.apply) &#123; enhancer = compose( applyMiddleware(...middlewares), devTools ) &#125; &#125; const createAppStore = enhancer(createStore); this._store = Object.assign(this._store || &#123;&#125;, createAppStore(getReducer.call(this), initialState)); return this._store&#125; 可以看到，先用 applyMiddleware 生成了中间件，中间件可以通过 Genji4rn 的 use 方法注册，一般会注册的中间件有： redux-thunk：用来处理异步 action redux-promise-middleware：为异步请求的 action.type 加上后缀。例如：Loading,Success,Error 等。 这里 initialState 需要在创建 Genji4rn 实例的时候传入，一般是 {}。前面已经说了，创建 reducer 的时候，就已经把默认值传给每个 reducer 了。这里就不需要再为 initialState 创建值了。 不过这段的重点应该是 getReducer 方法： 1234567891011121314151617181920212223242526272829function getReducer() &#123; // extra reducers const extraReducers = plugin.get('extraReducers'); const mergeReducers = deepmerge.all([this._reducers, extraReducers]) for(let k in mergeReducers) &#123; if(typeof mergeReducers[k] === 'object') &#123; mergeReducers[k] = combineReducers(mergeReducers[k]) &#125; &#125; const navInitialState = this._router.router.getStateForAction( this._router.router.getActionForPathAndParams(this._router.initialRouteName) ); const navReducer = (state = navInitialState, action) =&gt; &#123; const nextState = this._router.router.getStateForAction(action, state); // Simply return the original `state` if `nextState` is null or undefined. return nextState || state; &#125;; const appReducer = combineReducers(&#123; nav: navReducer, ...initialReducer, ...mergeReducers, &#125;); return appReducer&#125; 最终返回的 appReducer 中，包含了 router 的 reducer navReducer 还有用户的 mergeReducers 。 这里 mergeReducers 的生成非常有意思。之前我们保存在 Genji4rn 实例的 _reducer里的 reducer 结构是两层的：_reducers.order.newOrder. 但是 combineReducer 只能把一层的 reducer 转化为一个大的 reducer。因此，这里使用了两次 combineReducer。比如刚才的例子，第一次将 order 下的各个 reducer combineReducer 后得到一个 order 的 mergeReducers[&#39;order&#39;]。然后再把 order 同一层级的 reducer combineReducer 到 appReducer 下。 这样 reducer 的层次结构就和 state 一致了。 多层级的 state，可以多次使用 combineReducer 来达到将多层级 reducer 合并的目的。 connect 相关(主要是设置 action)前面已经成功隐藏了 createStore,combineReducer,Provider,applymiddleware 等方法，不过这还不够。对于用户来说，dispatch(action) 也没有必要让用户知道。使用者应该只需要提供一个方法，返回数据 action.payload 就行了，连 action.type 是什么用户都可以不必知道，由框架通过获取方法名推断得到。 所以需要使用 Genji4rn 提供的 connect 方法： 1234567891011121314151617181920212223242526272829303132333435363738module.exports.connect = function(state, model) &#123; const actionCreators = &#123;&#125; let _handlers = [] if(model) &#123; if(model.handlers &amp;&amp; Array.isArray(model.handlers)) &#123; _handlers = _handlers.concat(model.handlers) &#125; if(model.publicHandlers &amp;&amp; Array.isArray(model.publicHandlers)) &#123; _handlers = _handlers.concat(model.publicHandlers) &#125; &#125; if(_handlers.length &gt; 0) &#123; _handlers.map((key) =&gt; &#123; if(key.action) &#123; if(key.validate) &#123; actionCreators[key.name] = createAction(model.namespace + '/' + key.name, key.action, key.validate) &#125; else &#123; actionCreators[key.name] = createAction(model.namespace + '/' + key.name, key.action) &#125; &#125; else if(key.handler) &#123; let globalHandler = GlobalContext.getHandler(key.handler) if(globalHandler) &#123; if(key.validate) &#123; actionCreators[key.name] = createAction(model.namespace + '/' + key.name, globalHandler, key.validate) &#125; else &#123; actionCreators[key.name] = createAction(model.namespace + '/' + key.name, globalHandler) &#125; &#125; &#125; else &#123; actionCreators[key] = createAction(model.namespace + '/' + key) &#125; &#125;) const mapDispatchToProps = (dispatch) =&gt; bindActionCreators(actionCreators, dispatch) return connect(state, mapDispatchToProps) &#125; else &#123; return connect(state) &#125;&#125; 关于 mapStateToProps 的部分我就不说了，主要看看 handler 如何变为 mapDispatchToProps 的过程。 hanlder 有三种用法： 12345handlers: [ 'justAString', &#123; name: 'handlerName', action: 'handlerActionFromActionJS' &#125;, &#123; name: 'handlerName2', handler: 'handlerFromAnotherModule' &#125;] 第一种对应上面的 else: 1actionCreators[key] = createAction(model.namespace + '/' + key) 通过 redux-action 的 createAction 生成一个 action 创建方法 createAction，直接在方法名前加上 namespace 作为 action.type 传入。这样 action.type 就和前面处理 reducers 时添加 namespace 的做法一致了。调用这个 action 创建方法的话只需要传入一个 payload 就可以生成一个 action： 1let action = createAction(model.namspace + '/someaction')('payload') 第二种对应 if(key.action) 的情况： 1actionCreators[key.name] = createAction(model.namespace + '/' + key.name, key.action) 还是通过 createAction，不过这里此时生成的 createAction 方法会在执行的时候接受参数，然后将其作为入参立刻执行 action 方法，并将 action 方法的返回值作为 payload 保存。 虽然之前说了关于 redux-thunk 的 action 为 function 的情况。但是其实通过 redux-actions 创建的 action 其实不会是一个 action。这时候就要配合 redux-promise-middleware 了 redux-promise-middleware 就做了这样一个事情。它会检查 action.payload 调用后返回的是不是一个 promise。如果是一个 promise，它会在 .then() 方法中，替代使用者执行 dispatch 方法。它还能检查网络请求是成功还是失败，为原本的 action.type 添加相应的成功或者失败的后缀。 第三种对应 else if(key.handler) 的情况： 12let globalHandler = GlobalContext.getHandler(key.handler)actionCreators[key.name] = createAction(model.namespace + '/' + key.name, globalHandler) 其实和第二种差不多，只是它不是从模块的 action 中获取方法，而是从 globalHandler 中找到对应的方法。 通过以上方法得到 actionCreators 之后，就要创建 mapDispatchToProps 了。由于使用者不需要知道 dispatch，所以这里使用 redux 提供的 bindActionCreators 方法，其实也没什么魔法，就是生成一个调用 dispatch 方法的方法： 123function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args)) &#125; Vuex 使用Vue 提供了 Vuex 作为 redux 的解决方式。来看一下它的使用方式。 基本使用store123456789101112131415161718192021222324252627282930import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default store = new Vuex.Store(&#123; state: &#123; count: 0, todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125; getter: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;,&#125;) 需要使用 Vue.use(Vuex) 像 Vue 注册插件 Vuex。在 Vue 中，由于没有 react-redux 将属性传入展示组件，所以要在需要使用的地方 import 这个 store。 state通过 store 获取 state ： 1store.state.count // -&gt; 0 一般将 state 用在计算属性上： 123456789// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; gettergetter 用于简化 store 中 state 的计算： 12345getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;&#125; 可以通过 store.getters.xxx 获取相关属性值。比如： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] mutation根据 redux 所倡导的，改变 store 的唯一方式还是通过 dispatch 一个 action，而不是直接修改 store。Redux 中，reducer 是一个纯函数，用于修改 state。Vuex 也提供了相应方式 mutation 。 mutation 的写法非常类似 Genji4rn 中 reducers 的写法。mutation 中包含了很多的方法。方法接收 initialState 和一个值，即 action.payload。为什么不需要 action.type 了呢？因为方法名就是 type。比如下面的 increment 方法，就代表着这个 reducer 的 action.type 12345mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125; 不同的是，Genji4rn 中每个方法不能直接修改 state 值，要返回一个新的 state。而 mutation 的方法中直接修改 state。这种差异是由于 react 和 vue 响应式机制的不同而产生的。react 要通过比较 state 变化前后的不同，来找出需要重新渲染的组件。Vue 则是 state 的 set 方法通知页面中计算属性的改变。 触发方式上，Redux 中通过 store.dispatch(action) 依次触发所有 reducer。Vuex 中通过 commit 方法依次触发所有模块的 mutation，相当于把 action 拆成了 action.type 和 action.payload 分别传入： 1store.commit('increment', 10) 这里与 Genji4rn 不同的是，Genji4rn 把与 commit 相对应的 dispatch 封装在 handler 中的相关方法里。而 Vuex 还需要自己调用。如果模块存在命名空间，那么写起来会比较冗长，而 Genji4rn 会自动为方法添加命名空间的前缀： 1store.commit('order/newOrder/increment', 10) action关于异步操作。Vuex 提供了action。 1234567actions: &#123; incrementAsync (context, product) &#123; setTimeout(() =&gt; &#123; context.commit('increment', product.amount) &#125;, 1000) &#125;&#125; 其实还是相当于是在异步操作完了之后，触发一个 mutation。这里的 context 相当于当前模块的 store。即,只能拿到当前模块的 commit 方法和 state。 action 的触发使用 dispatch 方法。同样的，也是把 action.type 单独拿了出来： 123store.dispatch('incrementAsync', &#123; amount: 10&#125;) vue 里通过 dispatch 和 commit 手动替代了 redux-thunk 的功能。 模块化基本使用当工程变大后，所有状态和方法都写在 store 中是不明智的。所以 react 中才有了 Genji4rn 之类的框架。Vuex 提供了专门的模块化方式： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 只创建一个 Store，把不同的模块以 module 的形式传入。通过 store.state 拿到去全局的 state，store.state.a 拿到相应模块的 state。 模块的局部状态模块化后模块内部的 mutation 和 getter。接收的第一个参数是模块的局部状态对象： 123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 对于模块内部的 action，局部状态通过 context.state 暴露，根节点状态为 context.rootState: 12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit('increment') &#125; &#125; &#125;&#125; 命名空间默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： 12345678910111213141516171819const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, &#125; &#125;&#125;) 总结Vuex 在 reducer 部分的处理和 Genji4rn 非常相似，都是将 action.type 转化为一个个方法，都可以为每一个 action.type 的方法添加命名空间。都可以在每一个模块的 reducer 中获取到当前模块的 state。 但是在 dispatch 方法的几乎没有做太多的处理，还是需要使用者根据实际情况，去获取 store 调用 store.dispatch 或者 store.commit 方法，可以做进一步的封装，尤其是使用命名空间的情况下。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序技巧]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[好久没有写新的博客了。最近在联系小程序。所以记录一下小程序的坑与技巧。由于用 mpvue 和原生都撸过小程序，所以记录一些都会面临的情况。 页面相关最外层占用整个屏幕1234567.container &#123; position: fixed; height: 100%; width: 100%; display:flex; flex-direction:column;&#125; scroll-view 占满整个屏幕 此方法在 6s 等机型上存在不能滑动的问题，必须要手动设置 scroll-view 的高度才可以解决。所以需要在 scroll-view 外再包裹一个 view，然后通过 wx.createSelectorQuery() 拿到 view 的高度，再设置给 scroll-view。注意拿到的高度是 px 不是 rpx scroll-view 如果设置 flex: 1 可以让 scroll-view 撑满屏幕。但是你会发现，scroll-view 无法滚动了。我们可以再设置一个样式： 1234.scroll-view &#123; flex: 1; overflow: hidden;&#125; 设置超出部分隐藏。这样控件就自动拥有 scroll-view 的滚动功能了。 wxs 使用的坑虽然我很抗拒 wxs，但是由于小程序不支持 computed，由于代码的美观，少在 data 中放几个字段，就需要借助 wxs 在 wxml 中生成计算后的数据。 但是其中有一个坑就是，定义变量的时候，不能使用 es6 的 let 和 const 只能使用 var，否则也不报错，但就是无法显示。 绝对定位的居中绝对定位的左右两边没有占位，所以 align-items 是无效的 align-self 可能无效。这种居中分为两种情况： 设置了控件宽度 不设置控件宽度 设置了 width 的情况下。我们只要使用 left 设置控件的位置即可。设置 left: 50% 可以让控件向右移动父视图的 50% 宽度。这样会移动过头，还需要设置 margin-left: -{50%的控件宽度} 修正控件的位置。 如果没有设置 width 的情况下。可以同时设置 left和 right，让视图撑满剩余的空间。 在外部修改组件库的样式项目中引入了有赞的组件库。但是使用的时候有些样式不太符合要求。这个时候不要放弃使用，我们可以在外部修改内部的样式。 通过调试工具，找到不符合要求的视图的样式，在外部直接修改其样式： 123.van-popup--bottom &#123; background: transparent !important;&#125; 这里我们修改了 van-popup--bottom 的背景颜色。同时在后面加上了 !important，这样是为了将我们的样式的权重提升，就不会被组件内部的样式覆盖了。 wx:key 取值我们知道，无论是 react 还是 vue，在类表渲染的时候都提供了 key 这个关键字。key 相等的时候用来移动和改变状态，key 不等的则会进行销毁和重新创建。 React: 12345const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); vue: 1&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt; 可以看到，这两种都是拿到 item，然后设置 item 的属性为 key。 小程序则默认key就是 item 中的属性了： 1&lt;block wx:for="&#123;&#123;itemList&#125;&#125;" wx:key="id"/&gt; 这样就是直接设置 item 中的 id 为 key。这样和 React 和 Vue 不统一的写法，让我有点难受。 scroll-view 横向排布排布scroll-view 横向排布有一些坑，如果按照常规的方式，你会发现 scroll-view 中的视图还是纵向排布的。我们需要做一些设置： 123456789.scroll-view &#123; white-space: nowrap; display: flex; flex-direction: row;&#125;.scroll-item &#123; display: inline-block;&#125; 外部的 scroll-view 要设置 white-space，否则会换行。内部的 item 要把显示设置为 inline-block，否则还是纵向排布了。 如何只显示3行，超出显示省略号要对 text 设置样式，一个也不能少： 123456789.text &#123; line-height: 36rpx; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 3; height: 108rpx; -webkit-box-orient: vertical; display: -webkit-box;&#125; 要注意一定要设置 line-height 和 height ，并且要显示几行 height 就是 line-height 的几倍。 如果是单行的省略号改为： 123456.text &#123; text-overflow: ellipsis; overflow: hidden; width: 123rpx; white-space: nowrap;&#125; 注意，宽度一定要有。 滚动监听小程序中滚动有两种方式。一种是直接视图的平铺，还有一种配合 scroll-view。 获取视图平铺时的滚动 offset在平铺时候的滚动回调中每次都通过 selectViewport().scrollOffset() 拿到 1234567onPageScroll: function () &#123; let query = wx.createSelectorQuery() query.selectViewport().scrollOffset(function (res) &#123; console.log(res.scrollTop) // 竖直的滚动位置 &#125;) query.exec()&#125; 获取 scrollView 的 offset1234567// scroll-view 中绑定方法&lt;scroll-view bindscroll="onScroll"/&gt; // js 中滚动方法onScroll (e) &#123; console.log(e.detail.scrollTop) &#125; 平铺滚动到某一个位置1wx.pageScrollTo(&#123;scrollTop: 一个offset&#125;) scroll-view 滚动到某一个 view 或者某一个位置12345678910// wxml 中&lt;scroll-view scroll-top="&#123;&#123;offset&#125;&#125;" scroll-into-view="&#123;&#123;id&#125;&#125;"/&gt; // js 中this.setData(&#123; offset: 1000,&#125;)this.setData(&#123; id: '一个view的id'&#125;) 获取平铺或者 scroll-view 中距离顶部的 offset1234567let query = wx.createSelectorQuery()query.select('#select').boundingClientRect(res =&gt; &#123; this.setData(&#123; top: res.top &#125;)&#125;)query.exec() #select 表示当前视图的 id &lt;view id=&quot;select /&gt;&quot; 绝对定位设置 padding-right 不符合预期padding 的宽度不在 width 的范围内。所以如果你绝对定位设置宽度为 100% 时，如果设置了 padding-left ，那么视图整体会向右移，即实际宽度大于 720rpx。 这种情况下，只能把视图的宽度设置为 720-2*padding 值，才能让视图正常显示。 CSS 中设置高度为屏幕大小有时候我们要设置高度或者宽度为屏幕大小，但是使用 100% 不好用。这个时候，我们可以使用 vh 和 vw 这是 CSS3 涌入的属性，分别表示高度/宽度基于窗口的大小,vh = view height,vw = view width: 1234.window &#123; height: 100vh; width: 100vw;&#125; 设置多行子元素为了让子元素能够自动换行，可以使用样式 flex-wrap: wrap。当然这是第一步，这么做后你会发现，换行后的子元素贴在了一起。如图所示： 你需要设置元素间间隔。你会设置元素的 margin-bottom: 20rpx。 但是这样的话父元素的 bottom 也会向下移动 20rpx。所以，你可以把父元素的 margin-bottom: -20rpx。 这样，正负抵消，就是理想的间隔了。 小程序的button的边框小程序默认的button是有一个边框的，需要设置一个样式： 123button::after &#123; border: none;&#125; 这样，所有的 button 标签都没有 border了 小程序捕捉事件小程序默认的事件是冒泡的，也就是说点击了子控件触发方法后，父控件的点击事件还是会触发的，如果要阻止事件冒泡，可以把子控件的 bind:tap 改为 catch:tap 组件中的 class 选择很多时候我们需要根据组件传入的值，来设置组件使用不同的 class。我们可以使用或或者三元选择符，但是需要使用双括号包裹，只要返回一个 class 的名字即可： 123&lt;button class="someclass &#123;&#123; item.disabled || item.loading ? 'some-class-disabled' : '' &#125;&#125; &#123;&#123; item.className || '' &#125;&#125;"&gt; 组件中的 style很多时候，我们需要传入值来控制 style，传入的值需要使用双括号包裹： 1style="width: 100%; height: &#123;&#123; itemHeight * visibleItemCount + 'px' &#125;&#125;" 引入 iconfont首先把 iconfont 下载下来，打开其中的 iconfont.css 文件，应该是下面的样子，把它复制到 app.wxss 中作为全局样式。 123456789101112131415@font-face &#123;font-family: "ChameIconfont"; ... 省略了其中很多的 src 和 url&#125;.ChameIconfont &#123; font-family:"ChameIconfont" !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-ickehu:before &#123; content: "\e60a"; &#125;.icon-icshouye:before &#123; content: "\e610"; &#125; 由于小程序不会把 ttf 文件打包，所以需要修改 @font-face 中的 src 和 url 为网络路径。我们还是到 iconfont 的网站上，生成一个线上的文件地址，用它替换上面的 @font-face 这样项目中就可以使用了： 1&lt;view class='ChameIconfont icon-ickehu'/&gt; 发布 npm 包小程序用 npm 包需要把代码放在一个文件夹下，然后在 package.json 中增加一个 miniprogram 字段，标识代码所在目录： 123&#123; "miniprogram": "dist"&#125; 当小程序开发工具 工具-&gt;构建npm 的时候，将该目录下的文件从 node_modules 移动到主目录下。 在 工具-&gt;构建npm 后，项目最外层目录生成 miniprogram_npm 文件夹，文件夹内包含所有 node_modules 中的模块。 在 app.json 中注册要使用的组件：12345&#123; "usingComponents": &#123; "van-button": "/miniprogram_npm/vant-weapp/button/index" &#125;&#125; 或者直接 import 隐藏 scroll-view 滚动条直接在相应的 wxss 中写入样式： 12345::-webkit-scrollbar &#123; width: 0; height: 0; color: transparent;&#125; 组件相关外部全局样式影响组件内样式在注册组建的时候添加一个选项，addGlobalClass 为 true： 12345Component(&#123; options: &#123; addGlobalClass: true, &#125;&#125;) 监听组件内数据改变类似于 watch，组件内通过 observers 字段定义： 12345678910111213141516Component(&#123; attached: function() &#123; this.setData(&#123; numberA: 1, numberB: 2, &#125;) &#125;, observers: &#123; 'numberA, numberB': function(numberA, numberB) &#123; // 在 numberA 或者 numberB 被设置时，执行这个函数 this.setData(&#123; sum: numberA + numberB &#125;) &#125; &#125;&#125;) 父子组件的通信小程序的父子组件提供了双向通信的方式。子组件可以通过 link 的回调，以及 getRelationNodes 两种方式获取父组件。父组件可以通过 link 回调获取子组件。 123456789101112131415161718192021222324// 子组件 path/to/custom-li.jsComponent(&#123; relations: &#123; '&#123;相对路径&#125;/custom-ul-component': &#123; type: 'parent', // 关联的目标节点应为父节点 linked: function(target) &#123; // 保存父节点 this.parent = target &#125;, unlinked: function(target) &#123; // 移除子节点 this.parent = null &#125; &#125; &#125;, methods: &#123; someFunc: function () &#123; // 获取页面上与子组件相关的组件的节点数组，取其中第一个节点，就是它的父节点 let group = this.getRelationNodes('&#123;相对路径&#125;/custom-ul-component')[0] // 调用父节点方法 group.doSomeFunc() &#125; &#125;&#125;) 123456789101112131415161718192021222324// 父组件Component(&#123; relations: &#123; '&#123;相对路径&#125;/custom-ul': &#123; type: 'child', // 关联的目标节点应为子节点 linked: function(target) &#123; // 保存子节点 this.childs.push(target) &#125;, unlinked: function(target) &#123; // 移除子节点 this.childs = this.childs.filter(function(item) &#123; return item !== target &#125;) &#125; &#125; &#125;, methods: &#123; someFunc: function () &#123; // 调用子节点方法 this.childs.doSomeFunc() &#125; &#125;&#125;) 页面与组件的通信组件调用页面提供的方法 页面将方法绑定给组件： 1234567&lt;component-tag-name bind:myevent="onMyEvent" /&gt; Page(&#123; onMyEvent: function(e)&#123; e.detail // 自定义组件触发事件时提供的detail对象 &#125;&#125;) 组件内部触发事件： 123456789101112&lt;!-- 在自定义组件中 --&gt;&lt;button bindtap="onTap"&gt;点击这个按钮将触发“myevent”事件&lt;/button&gt;Component(&#123; properties: &#123;&#125;, methods: &#123; onTap: function()&#123; var param = &#123;&#125; // 提供给页面的 e.detail 的参数 this.triggerEvent('myevent', param) &#125; &#125;&#125;) 页面调用组件提供的方法页面调用组件方法需要获取组件实例，可以通过 page 的 selectComponent 方法获取： 123456789&lt;some-component id="custom-selector" /&gt; const pages = getCurrentPages()const currentPage = pages[pages.length - 1]let component = currentPage.selectComponent('custom-selector')// 调用组件方法component.customFunction()]]></content>
      <categories>
        <category>MiniProgram</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry 源码解析]]></title>
    <url>%2F2018%2F04%2F19%2FMasonry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Masonry 是 iOS 中的一套布局框架，先占个坑学习下源码。 使用添加约束1234567UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(superview.mas_top).with.offset(padding.top); //with is an optional semantic filler make.left.equalTo(superview.mas_left).with.offset(padding.left); make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom); make.right.equalTo(superview.mas_right).with.offset(-padding.right);&#125;]; 添加约束必须先把视图添加到父视图上，否则会crash 约束添加几倍于1make.width.equalTo(superview.mas_width).multiplieBy(0.5); 约束不超过或者不小于1234// 不小于make.left.greaterThanOrEqualTo(label.mas_left);// 不大于make.left.lessThanOrEqualTo(label.mas_left); 优先级可以设置三种优先级 .priorityHigh，.priorityMedium，.priorityLow。也可以自己设置优先级的大小。默认的优先级为 1000 12make.left.greaterThanOrEqualTo(label.mas_left).with.priorityLow();make.top.equalTo(label.mas_top).with.priority(600); 设置边距大小和中心点edgs123456// make top, left, bottom, right equal view2make.edges.equalTo(view2);// make top = superview.top + 5, left = superview.left + 10,// bottom = superview.bottom - 15, right = superview.right - 20make.edges.equalTo(superview).insets(UIEdgeInsetsMake(5, 10, 15, 20)) size12345// make width and height greater than or equal to titleLabelmake.size.greaterThanOrEqualTo(titleLabel)// make width = superview.width + 100, height = superview.height - 50make.size.equalTo(superview).sizeOffset(CGSizeMake(100, -50)) center12345// make centerX and centerY = button1make.center.equalTo(button1)// make centerX = superview.centerX - 5, centerY = superview.centerY + 10make.center.equalTo(superview).centerOffset(CGPointMake(-5, 10)) 更新约束使用 mas_updateConstraints 更新约束 1234567[self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); make.width.equalTo(@(self.buttonSize.width)).priorityLow(); make.height.equalTo(@(self.buttonSize.height)).priorityLow(); make.width.lessThanOrEqualTo(self); make.height.lessThanOrEqualTo(self);&#125;]; 重新设置约束使用 mas_remakeConstraints 重新设置约束 123456789[self.button mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.size.equalTo(self.buttonSize); if (topLeft) &#123; make.top.and.left.offset(10); &#125; else &#123; make.bottom.and.right.offset(-10); &#125;&#125;]; 多个控件等距、等宽排列Masonry 提供了两个方法，可以提供等距排列或者等宽排列： 12345678910111213141516171819/** * 等距排列 * * @param axisType 横排还是竖排 * @param fixedSpacing 两个控件间隔 * @param leadSpacing 第一个控件与边缘的间隔 * @param tailSpacing 最后一个控件与边缘的间隔 */- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedSpacing:(CGFloat)fixedSpacing leadSpacing:(CGFloat)leadSpacing tailSpacing:(CGFloat)tailSpacing;/** * 等宽排列 * * @param axisType 横排还是竖排 * @param fixedItemLength 控件的宽或高 * @param leadSpacing 第一个控件与边缘的间隔 * @param tailSpacing 最后一个控件与边缘的间隔 */- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedItemLength:(CGFloat)fixedItemLength leadSpacing:(CGFloat)leadSpacing tailSpacing:(CGFloat)tailSpacing; 要注意的是，如果是横排，那么还是需要自己设置高度约束；如果是竖排，还是需要设置宽度约束。例： 12345678910111213141516171819202122232425262728// 导入 NSArray 的分类#import "NSArray+MASAdditions.h"// 把视图添加到数组中- (NSMutableArray *)masonryViewArray &#123; if (!_masonryViewArray) &#123; _masonryViewArray = [NSMutableArray array]; for (int i = 0; i &lt; 4; i ++) &#123; UIView *view = [[UIView alloc] init]; view.backgroundColor = [UIColor redColor]; [self.view addSubview:view]; [_masonryViewArray addObject:view]; &#125; &#125; return _masonryViewArray;&#125;// 设置约束- (void)test_masonry_horizontal_fixSpace &#123; // 实现masonry水平固定间隔方法 [self.masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:30 leadSpacing:10 tailSpacing:10]; // 设置array的垂直方向的约束 [self.masonryViewArray mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(150); make.height.equalTo(80); &#125;];&#125; 这个方法在官方的 README 中没有看到，只是在阅读源码的时候才注意到 源码解析文件结构 使用 Masonry 设置约束的时候，主要的几个类如上图所示。最上面的三个是调用者，分别在 UIView，UIViewController 和 NSArray 中添加分类方法。下面的 MASConstraintMaker 是约束的创建者，我们在 block 中使用的 make 就是这个类的实例。后面的 MASContraint 和 MASViewAdditions 不对使用者暴露，前者是约束实例的封装，后者是所约束对象的封装。 我们使用的时候主要调用 View+MASAdditions中的方法，直接在某个 View 上添加约束。 NSArray+MASAdditions 可以将多个视图放在一个数组中，然后对其中的每一个视图加上约束，用的很少。ViewController+MASAdditions 主要操作的是topLayoutGuide 和 bottomLayoutGuide。这两个 View 的属性在 iOS11 中已经被废弃，建议使用 View 中的 mas_safeAreaLayoutGuide 替代。因此，几乎不使用 View+MASAdditions这个 UIView 的分类提供了三个方法分别用来创建、更新、重设约束。先来看创建约束的方法： 123456- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; block(constraintMaker); return [constraintMaker install];&#125; 这个方法中首先把 translatesAutoresizingMaskIntoConstraints 设置为 NO，表示要自己添加约束。然后初始化 MASConstraintMaker。接着把 MASConstraintMaker 作为参数传入 block 执行，配置约束。最后调用install 方法，把配置好的越是添加到视图上。 这里外部传来的 block 不会被保存，而是直接执行。这就保证了 block 中直接强引用 self 也不会产生循环引用。 再看更新和重设方法： 123456789101112131415- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; constraintMaker.updateExisting = YES; block(constraintMaker); return [constraintMaker install];&#125;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block &#123; self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; constraintMaker.removeExisting = YES; block(constraintMaker); return [constraintMaker install];&#125; 和创建方法类似，只是多加了两个标记 updateExisting，removeExisting，用来和创建区别开。 MASConstraintMaker我们在设置约束的时候一般是这么写的： 123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(superview.mas_top).with.offset(20); //with is an optional semantic filler&#125;]; 我们来看看这个 top 方法如何实现的： 123456789101112131415161718- (MASConstraint *)top &#123; return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];&#125;- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];&#125;- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; ... if (!constraint) &#123; newConstraint.delegate = self; [self.constraints addObject:newConstraint]; &#125; return newConstraint;&#125; 中间省略了一些暂时不涉及的代码。这里先是初始化了 MASViewAttribute 对象。由于 MASViewAttribute 只是简单的约束作用的视图以及一个枚举属性 NSLayoutAttribute (NSLayoutAttribut 就是在创建约束的时候标识约束的类型的，比如宽度，高度，上下左右等)的封装，比较简单，这里就直接看一些它的初始化方法： 123456789101112131415- (id)initWithView:(MAS_VIEW *)view layoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; self = [self initWithView:view item:view layoutAttribute:layoutAttribute]; return self;&#125;- (id)initWithView:(MAS_VIEW *)view item:(id)item layoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; self = [super init]; if (!self) return nil; _view = view; _item = item; _layoutAttribute = layoutAttribute; return self;&#125; 除了保存 NSLayoutAttribute 就是对 view 做了一个弱引用的保存。可以看到，除了 view 外，还有一个成员变量 item。一般情况下，view 和 item 是同一个东西。只有当添加的约束是 ViewController 的 topLayoutGuide 和 bottomLayoutGuide 时才会不同： 123- (MASViewAttribute *)mas_topLayoutGuide &#123; return [[MASViewAttribute alloc] initWithView:self.view item:self.topLayoutGuide layoutAttribute:NSLayoutAttributeBottom];&#125; MASViewAttribute 的初始化方法之后，又初始化了 MASViewConstraint 对象，并把它加入到 MASConstraintMaker 的 constraints 约束数组中，并最终返回。 MASViewConstraint1make.top.equalTo(superview.mas_top).with.offset(20); make.top 返回的是 MASViewConstraint 对象实例，所以后面的 equalTo 方法就是 MASViewConstraint 的方法。 先来看它的初始化方法： 12345678910- (id)initWithFirstViewAttribute:(MASViewAttribute *)firstViewAttribute &#123; self = [super init]; if (!self) return nil; _firstViewAttribute = firstViewAttribute; self.layoutPriority = MASLayoutPriorityRequired; self.layoutMultiplier = 1; return self;&#125; 从名字就可以看出，初始化的时候必须传入一个 MASViewAttribute 实例。从名字也可以看得出来，这个属性是作为约束中的 FirstView 的。 再来看看 equalTo 的实现，这也就是这个库的精髓所在: 12345678910111213- (MASConstraint * (^)(id))equalTo &#123; return ^id(id attribute) &#123; return self.equalToWithRelation(attribute, NSLayoutRelationEqual); &#125;;&#125;- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation &#123; return ^id(id attribute, NSLayoutRelation relation) &#123; self.layoutRelation = relation; self.secondViewAttribute = attribute; return self; &#125;;&#125; 链式编程的核心在于每次调用的时候都返回自身。OC 的点语法相当于调用属性的 get 方法，因此是无法传参的。make.top.equalTo(superview.mas_top) 相当于通过 equalTo 的 get 方法，返回了一个 block 实例，然后再执行这个 block，返回自身的实例。 链式编程的一般使用场景在于设置一个对象的多个属性。 比如你要设置一个 button，你要设置它的多个属性就需要在多行里分别设置。但是如果 button 的每个属性的设置都返回 button 自身，那么就可以在一行中链式的调用。 同样的，offset 方法也是一样的道理。 设置约束一条链式调用会创建一个 MASViewConstraint 对象。每一个约束都会保存到 MASConstraintMaker 的数组中。在设置完约束后，就来到了 [constraintMaker install] 添加约束： 12345678910111213141516// MASConstraintMaker- (NSArray *)install &#123; if (self.removeExisting) &#123; NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view]; for (MASConstraint *constraint in installedConstraints) &#123; [constraint uninstall]; &#125; &#125; NSArray *constraints = self.constraints.copy; for (MASConstraint *constraint in constraints) &#123; constraint.updateExisting = self.updateExisting; [constraint install]; &#125; [self.constraints removeAllObjects]; return constraints;&#125; 这里之前的两个标记就派上用场了，如果要重设就会先移除约束再重新添加，而如果是更新，就会把标记传入每一个约束中。MASViewConstraint 中添加约束： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// MASViewConstraint- (void)install &#123; /// 如果该约束已经被 install 过，那么直接 return。 if (self.hasBeenInstalled) &#123; return; &#125; if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) &#123; self.layoutConstraint.active = YES; /// 把约束保存到 view 上，这样再 uninstall 的时候就可以找到并移除了。 [self.firstViewAttribute.view.mas_installedConstraints addObject:self]; return; &#125; /// 拿到施加约束的第一个视图 MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item; NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute; /// 拿到施加约束的第二个视图 MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item; NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute; /// 不存在第二个Attribute的时候设置为第一个属性的父级元素 if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123; secondLayoutItem = self.firstViewAttribute.view.superview; secondLayoutAttribute = firstLayoutAttribute; &#125; /// 创建真正的约束对象，他是 NSLayoutConstraint 的子类 MASLayoutConstraint *layoutConstraint = [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; layoutConstraint.priority = self.layoutPriority; layoutConstraint.mas_key = self.mas_key; if (self.secondViewAttribute.view) &#123; /// 如果存在第二个 View，那么约束要加在这两个 View 的公共祖先视图上。因此要查找公共祖先 MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view]; NSAssert(closestCommonSuperview, @"couldn't find a common superview for %@ and %@", self.firstViewAttribute.view, self.secondViewAttribute.view); /// installedVi表示约束要添加到的视图 self.installedView = closestCommonSuperview; &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123; /// 如果没有第二个视图，并且是操作第一个视图的 size，那么就直接把约束加在这个视图上 self.installedView = self.firstViewAttribute.view; &#125; else &#123; /// 如果没有第二个视图，并且不是操作第一个视图的 size，那么就表示添加的约束是第一个视图的位置的，那么需要把约束加在第一个视图的父视图上 self.installedView = self.firstViewAttribute.view.superview; &#125; MASLayoutConstraint *existingConstraint = nil; /// 如果外部标识是要更新约束 if (self.updateExisting) &#123; /// 判断这个约束是否存在，判断方式是拿这个约束的每一个属性和 view 保存的所有约束的每一个属性对比，如果完全相等就表示存在 existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint]; &#125; if (existingConstraint) &#123; /// 如果这个约束存在 更新约束 existingConstraint.constant = layoutConstraint.constant; self.layoutConstraint = existingConstraint; &#125; else &#123; /// 如果约束不存在，给视图增加约束 [self.installedView addConstraint:layoutConstraint]; self.layoutConstraint = layoutConstraint; [firstLayoutItem.mas_installedConstraints addObject:self]; &#125;&#125; 源码比较长，但是思想还是很明确的，就是调用 iOS 提供的 NSLayoutConstraint 方法生成约束，然后找到两个视图的公共父节点，将约束添加到公共父节点上。 MASCompositeConstraint最后，来瞧一下 MASViewConstraint 的子类 MASCompositeConstraint。之前我们省略的代码都是针对它的。简单的说，MASCompositeConstraint 就是 MASViewConstraint 的集合。 我们看一下这样设置约束的场景： 1make.height.and.width.equaltTo(@20) 我们在 make.height 的时候，已经创建了一个 MASViewConstraint 实例。所以执行到 .width 的时候，调用的是 MASViewConstraint 的 width 方法。我们来对比一下两者的不同： 123456789// MASConstraintMaker- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];&#125;// MASViewConstraint- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute];&#125; 两者的不同在于，用 MASConstraintMaker 创建的约束传入的是 nil，而通过 MASViewConstraint 创建的约束传入的是自身。接着来看下面的处理方法： 12345678910111213- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; ....&#125; 当 constraint 不为 nil 的时候，就会把原来的约束和现在的约束作为一个数组，创建一个 MASCompositeConstraint 实例。随后替换 MASConstraintMaker 中相应的值。 相应的，install 的时候，需要对 MASCompositeConstraint 中的所有约束调用 install 方法： 1234567// MASCompositeConstraint- (void)install &#123; for (MASConstraint *constraint in self.childConstraints) &#123; constraint.updateExisting = self.updateExisting; [constraint install]; &#125;&#125; 总结约束的创建本身涉及到很多的属性设置，Masonry 使用链式语法的方式精简了大量的代码。整体而言，Masonry 并不是一个太难理解的库。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 简单使用]]></title>
    <url>%2F2018%2F03%2F29%2Fwebpack%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[努力成为一名webpack配置工程师~~~ 安装使用 npm 安装，一般安装为 devdependency： 1npm install webpack --save-dev 然后再 package.json 中添加一个 script ： 1234567"scripts": &#123; "build": "webpack --mode production"&#125;,"devDependencies": &#123; "webpack": "^4.1.1", "webpack-cli": "^2.0.12", &#125; 执行了 npm run bulid 的时候，就会在目录下寻找 webpack.config.js 配置文件并执行。 入口入口表示打包的依赖的开始。使用 entry 字段表示： 123456789101112131415161718// 或者配置多个入口module.exports = &#123; entry: &#123; foo: './src/page-foo.js', bar: './src/page-bar.js', // ... &#125;&#125;// 使用数组来对多个文件进行打包module.exports = &#123; entry: &#123; main: [ './src/foo.js', './src/bar.js' ] &#125;&#125; loaderloader 是一种转换器，将某种类型的文件格式转为 webpack 可以支持的打包的模块。比如可以通过 vue-loader 解析 .vue 文件，将其转换为 js 代码。 使用 module.rules 表示： 123456789101112module: &#123; // ... rules: [ &#123; test: /\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀 include: [ path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理 ], use: 'babel-loader', // 指定使用的 loader &#125;, ],&#125; plugin模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。 比如使用 uglifyjs-webpack-plugin 压缩 JS 代码 1234567const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; plugins: [ new UglifyPlugin() ],&#125; DefinePlugin 是 webpack 内置的插件，可以使用 webpack.DefinePlugin 直接获取。这个插件用于创建一些在编译时可以配置的全局常量： 1234567891011121314module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true), // const PRODUCTION = true VERSION: JSON.stringify('5fa3b9'), // const VERSION = '5fa3b9' BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = 'true' TWO: '1+1', // const TWO = 1 + 1, CONSTANTS: &#123; APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125; &#125; &#125;), ],&#125; 有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如: 1console.log("Running App version " + VERSION); copy-webpack-plugin 用来把资源文件移动到指定目录下： 123456789101112const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; // ... plugins: [ new CopyWebpackPlugin([ &#123; from: 'src/file.txt', to: 'build/file.txt', &#125;, // 顾名思义，from 配置来源，to 配置目标路径 &#123; from: 'src/*.ico', to: 'build/*.ico' &#125;, // 配置项可以使用 glob // 可以配置很多项复制规则 ]), ],&#125; 输出输出即指 webpack 最终构建出来的静态文件，使用 output 字段： 12345678910111213141516171819module.exports = &#123; // ... output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;,&#125;// 或者多个入口生成不同文件module.exports = &#123; entry: &#123; foo: './src/foo.js', bar: './src/bar.js', &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist', &#125;,&#125; 解析resolve 表示如何解析。 使用 resolve.alias 来创建别名： 123456789module.exports = &#123; //... resolve: &#123; alias: &#123; Utilities: path.resolve(__dirname, 'src/utilities/'), Templates: path.resolve(__dirname, 'src/templates/') &#125; &#125;&#125;; 如果原来使用相对路径： 1import Utility from '../../utilities/utility'; 现在就可以使用绝对路径了： 1import Utility from 'Utilities/utility'; 使用 resolve.extensions 解析相应类型： 123456module.exports = &#123; //... resolve: &#123; extensions: ['.js', '.vue', '.json'], &#125;&#125;; 使用 resolve.modules 配置模块的搜索路径： 123resolve: &#123; modules: ['node_modules'],&#125;,]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码解析—解码策略]]></title>
    <url>%2F2018%2F03%2F07%2Fsdwebimage4%2F</url>
    <content type="text"><![CDATA[上一篇讲到了如何下载。这篇将探究下载后是如何解码的。 外部调动外部会在 disk 中获取到缓存 data 后调用解码方法，也会在 download 到 data 后调用解码方法。两者的解码操作基本一致，但是前者调用的 SDImageCacheDefine.m 中的方法，而后者调用的是 SDImageLoader.m 中的方法 Cache 中的解码在从 disk 中拿到 NSData 之后，就会调用 SDImageCacheDefine.m 中的 SDImageCacheDecodeImageData() 方法，进行解码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162UIImage * _Nullable SDImageCacheDecodeImageData(NSData * _Nonnull imageData, NSString * _Nonnull cacheKey, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123; UIImage *image; /// 判断是否只要解码第一帧 BOOL decodeFirstFrame = SD_OPTIONS_CONTAINS(options, SDWebImageDecodeFirstFrameOnly); NSNumber *scaleValue = context[SDWebImageContextImageScaleFactor]; /// 获取解码的 scale CGFloat scale = scaleValue.doubleValue &gt;= 1 ? scaleValue.doubleValue : SDImageScaleFactorForKey(cacheKey); SDImageCoderOptions *coderOptions = @&#123;SDImageCoderDecodeFirstFrameOnly : @(decodeFirstFrame), SDImageCoderDecodeScaleFactor : @(scale)&#125;; if (context) &#123; SDImageCoderMutableOptions *mutableCoderOptions = [coderOptions mutableCopy]; [mutableCoderOptions setValue:context forKey:SDImageCoderWebImageContext]; coderOptions = [mutableCoderOptions copy]; &#125; /// 如果不仅仅解码第一帧，则从 context 中取出 AnimatedImageClass，默认使用的是 SDAnimatedImage，然后进行图片数据的解码，根据需要还可以预解码所有帧 if (!decodeFirstFrame) &#123; Class animatedImageClass = context[SDWebImageContextAnimatedImageClass]; // check whether we should use `SDAnimatedImage` if ([animatedImageClass isSubclassOfClass:[UIImage class]] &amp;&amp; [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)]) &#123; image = [[animatedImageClass alloc] initWithData:imageData scale:scale options:coderOptions]; if (image) &#123; // Preload frames if supported if (options &amp; SDWebImagePreloadAllFrames &amp;&amp; [image respondsToSelector:@selector(preloadAllFrames)]) &#123; [((id&lt;SDAnimatedImage&gt;)image) preloadAllFrames]; &#125; &#125; else &#123; // Check image class matching if (options &amp; SDWebImageMatchAnimatedImageClass) &#123; return nil; &#125; &#125; &#125; &#125; if (!image) &#123; /// 从 data 转为 image image = [[SDImageCodersManager sharedManager] decodedImageWithData:imageData options:coderOptions]; &#125; if (image) &#123; /// 查看是否需要解码 BOOL shouldDecode = !SD_OPTIONS_CONTAINS(options, SDWebImageAvoidDecodeImage); if ([image.class conformsToProtocol:@protocol(SDAnimatedImage)]) &#123; // `SDAnimatedImage` do not decode /// 动图不需要解码 shouldDecode = NO; &#125; else if (image.sd_isAnimated) &#123; // animated image do not decode shouldDecode = NO; &#125; /// 需要解码就开始解码，把 image 加载到内存中 if (shouldDecode) &#123; /// 是否需要缩放 BOOL shouldScaleDown = SD_OPTIONS_CONTAINS(options, SDWebImageScaleDownLargeImages); if (shouldScaleDown) &#123; image = [SDImageCoderHelper decodedAndScaledDownImageWithImage:image limitBytes:0]; &#125; else &#123; image = [SDImageCoderHelper decodedImageWithImage:image]; &#125; &#125; &#125; return image;&#125; 如果是一个动图，并且不只解码第一帧，那么就会调用 SDAnimatedImage 的初始化方法把所有帧都解码出来。 如果不是动图，那么就会通过 SDImageCodersManager 先用 NSData 创建 UIImage，再对 UIImage 解码。整个过程会在下文详解。 Download 中的解码download 方式下的解码方法在 SDImageLoader.m 中。有两个方法 SDImageLoaderDecodeImageData() 和 SDImageLoaderDecodeProgressiveImageData()。 前者和 Cache 中的方法是一样的，都是将下载或者内存加载的 NSData 转为 UIImage，再解码。后者则提供了一种渐进式加载图片的方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980UIImage * _Nullable SDImageLoaderDecodeProgressiveImageData(NSData * _Nonnull imageData, NSURL * _Nonnull imageURL, BOOL finished, id&lt;SDWebImageOperation&gt; _Nonnull operation, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123; NSCParameterAssert(imageData); NSCParameterAssert(imageURL); NSCParameterAssert(operation); UIImage *image; id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *cacheKey; if (cacheKeyFilter) &#123; cacheKey = [cacheKeyFilter cacheKeyForURL:imageURL]; &#125; else &#123; cacheKey = imageURL.absoluteString; &#125; BOOL decodeFirstFrame = SD_OPTIONS_CONTAINS(options, SDWebImageDecodeFirstFrameOnly); NSNumber *scaleValue = context[SDWebImageContextImageScaleFactor]; CGFloat scale = scaleValue.doubleValue &gt;= 1 ? scaleValue.doubleValue : SDImageScaleFactorForKey(cacheKey); SDImageCoderOptions *coderOptions = @&#123;SDImageCoderDecodeFirstFrameOnly : @(decodeFirstFrame), SDImageCoderDecodeScaleFactor : @(scale)&#125;; if (context) &#123; SDImageCoderMutableOptions *mutableCoderOptions = [coderOptions mutableCopy]; [mutableCoderOptions setValue:context forKey:SDImageCoderWebImageContext]; coderOptions = [mutableCoderOptions copy]; &#125; id&lt;SDProgressiveImageCoder&gt; progressiveCoder = objc_getAssociatedObject(operation, SDImageLoaderProgressiveCoderKey); if (!progressiveCoder) &#123; /// 从 SDImageCodersManager 中找能解码该图片的并把它保存在 operation 中 for (id&lt;SDImageCoder&gt;coder in [SDImageCodersManager sharedManager].coders.reverseObjectEnumerator) &#123; if ([coder conformsToProtocol:@protocol(SDProgressiveImageCoder)] &amp;&amp; [((id&lt;SDProgressiveImageCoder&gt;)coder) canIncrementalDecodeFromData:imageData]) &#123; progressiveCoder = [[[coder class] alloc] initIncrementalWithOptions:coderOptions]; break; &#125; &#125; objc_setAssociatedObject(operation, SDImageLoaderProgressiveCoderKey, progressiveCoder, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; /// 没有能解码该图片的，直接返回nil if (!progressiveCoder) &#123; return nil; &#125; /// 渐进式加载 data [progressiveCoder updateIncrementalData:imageData finished:finished]; /// 不是只decode第一帧 if (!decodeFirstFrame) &#123; // check whether we should use `SDAnimatedImage` Class animatedImageClass = context[SDWebImageContextAnimatedImageClass]; if ([animatedImageClass isSubclassOfClass:[UIImage class]] &amp;&amp; [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)] &amp;&amp; [progressiveCoder conformsToProtocol:@protocol(SDAnimatedImageCoder)]) &#123; image = [[animatedImageClass alloc] initWithAnimatedCoder:(id&lt;SDAnimatedImageCoder&gt;)progressiveCoder scale:scale]; if (image) &#123; // Progressive decoding does not preload frames &#125; else &#123; // Check image class matching if (options &amp; SDWebImageMatchAnimatedImageClass) &#123; return nil; &#125; &#125; &#125; &#125; /// 一般情况下生成 image if (!image) &#123; image = [progressiveCoder incrementalDecodedImageWithOptions:coderOptions]; &#125; if (image) &#123; BOOL shouldDecode = !SD_OPTIONS_CONTAINS(options, SDWebImageAvoidDecodeImage); if ([image.class conformsToProtocol:@protocol(SDAnimatedImage)]) &#123; // `SDAnimatedImage` do not decode shouldDecode = NO; &#125; else if (image.sd_isAnimated) &#123; // animated image do not decode shouldDecode = NO; &#125; if (shouldDecode) &#123; image = [SDImageCoderHelper decodedImageWithImage:image]; &#125; // mark the image as progressive (completionBlock one are not mark as progressive) image.sd_isIncremental = YES; &#125; return image;&#125; 和 cache 中做法相同的 SDImageLoaderDecodeImageData() 方法会在下载图片完成回调时进行；而渐进式解码 SDImageLoaderDecodeProgressiveImageData() 方法则会在下载过程中接收到一边接收数据一边进行。 编解码SDImageCodersManager：解码器的管理者SDImageCodersManager 是一个单例类，内部在初始化的时候增加了多个实际的编解码类，用于将 NSData 转化为 UIImage。每次在使用到的时候都会循环每一个实际的编解码类，来对图片进行 data → image 的转换 你可能会有疑问，NDData 到 UIImage 不是系统内置的方法就可以解决嘛？一般情况下是的，对于 png， jpeg 等格式，系统自带了转换方法。但是对于苹果不是默认支持的格式，比如 webp，就需要自己通过解码器将 NSData → UIImage。 由此可见，NSData → UIImage 的过程也是一个解码的过程 初始化方法初始化方法如下所示。在单例的初始化过程中，默认增加了 SDImageIOCode，SDImageGIFCoder和 SDImageAPNGCoder 三个实际的编解码类。 1234567891011121314151617+ (nonnull instancetype)sharedManager &#123; static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; &#125;); return instance;&#125;- (instancetype)init &#123; if (self = [super init]) &#123; // initialize with default coders _imageCoders = [NSMutableArray arrayWithArray:@[[SDImageIOCoder sharedCoder], [SDImageGIFCoder sharedCoder], [SDImageAPNGCoder sharedCoder]]]; _codersLock = dispatch_semaphore_create(1); &#125; return self;&#125; 除了这三个内置的编解码类，我们还可以通过它提供的方法动态的添加和移除编解码器相关的类。 能否支持编解码解码要通过 NSData 进行解码。编码则是把 UIImage 根据 SDImageFormat 表示的图片类型转变为 NSData。和上面所说的一样，SDImageCodersManager 会调用内部的所有编解码类分别判断： 123456789101112131415161718192021/// 遍历所有 coder 看是否能解码- (BOOL)canDecodeFromData:(NSData *)data &#123; NSArray&lt;id&lt;SDImageCoder&gt;&gt; *coders = self.coders; for (id&lt;SDImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123; if ([coder canDecodeFromData:data]) &#123; return YES; &#125; &#125; return NO;&#125;/// 遍历所有 coder 看是否能编码- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123; NSArray&lt;id&lt;SDImageCoder&gt;&gt; *coders = self.coders; for (id&lt;SDImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123; if ([coder canEncodeToFormat:format]) &#123; return YES; &#125; &#125; return NO;&#125; 解码：从 NSData → UIImage在判断能否进行编解码之后，就会调用实际的编解码的类的相关方法： 1234567891011121314151617181920212223242526272829#pragma mark - 通过内部 coder 编解码- (UIImage *)decodedImageWithData:(NSData *)data options:(nullable SDImageCoderOptions *)options &#123; if (!data) &#123; return nil; &#125; UIImage *image; NSArray&lt;id&lt;SDImageCoder&gt;&gt; *coders = self.coders; for (id&lt;SDImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123; if ([coder canDecodeFromData:data]) &#123; image = [coder decodedImageWithData:data options:options]; break; &#125; &#125; return image;&#125;- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format options:(nullable SDImageCoderOptions *)options &#123; if (!image) &#123; return nil; &#125; NSArray&lt;id&lt;SDImageCoder&gt;&gt; *coders = self.coders; for (id&lt;SDImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123; if ([coder canEncodeToFormat:format]) &#123; return [coder encodedDataWithImage:image format:format options:options]; &#125; &#125; return nil;&#125; 以上就是 SDImageCodersManager 的全部内容了。本生作为一个 Manager，并没有太多的任务，所有的操作都是遍历内部的编解码类的列表，让它们来完成的。 SDImageCoderHelper：UIImage 到 bitmap 的转换者上面 manager 中管理的是从 data 到 image 的解码，这个 helper 则是要把 UIImage 提前转化为 bitmap 以贡显示。 SDImageFrame 和 UIImage 的互相转化SDImageFrame 是 GIF 或者 APNG 的每一帧的模型化。每一个 SDImageFrame 实例包括一个 UIImage 实例和一个时间间隔 duration: 12345678@interface SDImageFrame : NSObject@property (nonatomic, strong, readonly, nonnull) UIImage *image;@property (nonatomic, readonly, assign) NSTimeInterval duration;+ (instancetype _Nonnull)frameWithImage:(UIImage * _Nonnull)image duration:(NSTimeInterval)duration;@end GIF 和 APNG 不能直接转为 UIImage 的 animatedImages 的原因是后者的两帧之间的时间间隔是固定的，而前者则是不同的。因此两者相互转化的时候就要找到 GIF 和 APNG 两帧之间时间的最大公约数，以此作为 UIImage 的时间间隔。如果 GIF 和 APNG 的间隔较长则需要往其中插帧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma mark - 从 SDImageFrame 转为 UIImage+ (UIImage *)animatedImageWithFrames:(NSArray&lt;SDImageFrame *&gt; *)frames &#123; NSUInteger frameCount = frames.count; if (frameCount == 0) &#123; return nil; &#125; UIImage *animatedImage; /// 每一帧的持续时间都保存在 durations 中 NSUInteger durations[frameCount]; for (size_t i = 0; i &lt; frameCount; i++) &#123; durations[i] = frames[i].duration * 1000; &#125; /// 获取各帧间隔时间的最大公约数作为 duration。间隔长的加帧 NSUInteger const gcd = gcdArray(frameCount, durations); __block NSUInteger totalDuration = 0; NSMutableArray&lt;UIImage *&gt; *animatedImages = [NSMutableArray arrayWithCapacity:frameCount]; [frames enumerateObjectsUsingBlock:^(SDImageFrame * _Nonnull frame, NSUInteger idx, BOOL * _Nonnull stop) &#123; UIImage *image = frame.image; NSUInteger duration = frame.duration * 1000; totalDuration += duration; NSUInteger repeatCount; if (gcd) &#123; /// 要重复 repeatCount 次 repeatCount = duration / gcd; &#125; else &#123; repeatCount = 1; &#125; for (size_t i = 0; i &lt; repeatCount; ++i) &#123; [animatedImages addObject:image]; &#125; &#125;]; animatedImage = [UIImage animatedImageWithImages:animatedImages duration:totalDuration / 1000.f]; return animatedImage;&#125;#pragma mark - UIImage 转 SDImageFrame+ (NSArray&lt;SDImageFrame *&gt; *)framesFromAnimatedImage:(UIImage *)animatedImage &#123; if (!animatedImage) &#123; return nil; &#125; NSMutableArray&lt;SDImageFrame *&gt; *frames = [NSMutableArray array]; NSUInteger frameCount = 0; NSArray&lt;UIImage *&gt; *animatedImages = animatedImage.images; frameCount = animatedImages.count; if (frameCount == 0) &#123; return nil; &#125; NSTimeInterval avgDuration = animatedImage.duration / frameCount; if (avgDuration == 0) &#123; avgDuration = 0.1; // if it's a animated image but no duration, set it to default 100ms (this do not have that 10ms limit like GIF or WebP to allow custom coder provide the limit) &#125; __block NSUInteger index = 0; __block NSUInteger repeatCount = 1; __block UIImage *previousImage = animatedImages.firstObject; [animatedImages enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123; // ignore first if (idx == 0) &#123; return; &#125; if ([image isEqual:previousImage]) &#123; /// 如果是重复的帧，只保存一次 SDImageFrame，加间隔 repeatCount++; &#125; else &#123; SDImageFrame *frame = [SDImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount]; [frames addObject:frame]; repeatCount = 1; index++; &#125; previousImage = image; // last one if (idx == frameCount - 1) &#123; SDImageFrame *frame = [SDImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount]; [frames addObject:frame]; &#125; &#125;]; return frames;&#125; 获取最大公约数的过程通过辗转相除的方式完成： 123456789101112131415161718192021static NSUInteger gcd(NSUInteger a, NSUInteger b) &#123; NSUInteger c; while (a != 0) &#123; c = a; a = b % a; b = c; &#125; return b;&#125;/// 获取各帧时间间隔的最大公约数static NSUInteger gcdArray(size_t const count, NSUInteger const * const values) &#123; if (count == 0) &#123; return 0; &#125; NSUInteger result = values[0]; for (size_t i = 1; i &lt; count; ++i) &#123; result = gcd(values[i], result); &#125; return result;&#125; 获取设备的 rgb空间这个方法没什么特别的地方，就是 Core Graphic api的调用。它会在创建 Bitmap 的时候使用 12345678910111213#pragma mark - 获取设备的rgb颜色空间，创建bitmap时候需要+ (CGColorSpaceRef)colorSpaceGetDeviceRGB &#123; static CGColorSpaceRef colorSpace; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (@available(iOS 9.0, tvOS 9.0, *)) &#123; colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB); &#125; else &#123; colorSpace = CGColorSpaceCreateDeviceRGB(); &#125; &#125;); return colorSpace;&#125; 是否具有alpha通道判断是否含有 alpha 通道，在创建爱你 bitmap 的时候需要传入的属性： 1234567891011#pragma mark - 是否含有 alpha 通道+ (BOOL)CGImageContainsAlpha:(CGImageRef)cgImage &#123; if (!cgImage) &#123; return NO; &#125; CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage); BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone || alphaInfo == kCGImageAlphaNoneSkipFirst || alphaInfo == kCGImageAlphaNoneSkipLast); return hasAlpha;&#125; 在UI渲染的时候，实际上是把多个图层按像素叠加计算的过程，需要对每一个像素进行 RGBA 的叠加计算。当某个 layer 的是不透明的，也就是 opaque 为 YES 时，GPU 可以直接忽略掉其下方的图层，这就减少了很多工作量。这也是调用 CGBitmapContextCreate 时 bitmapInfo 参数设置为忽略掉 alpha 通道的原因。 解码：从 image 到 bitmapimage 要显示在屏幕上需要转化为 bitmap，这个操作往往是显示的时候在主线程中做的。为了提高效率，可以通过 decodedImageWithImage 方法把 image 提前转化为 bitmap，这样这张新图片就不再需要重复渲染了，提高了渲染效率： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071+ (UIImage *)decodedImageWithImage:(UIImage *)image &#123; if (![self shouldDecodeImage:image]) &#123; return image; &#125; /// 新建一个 imageRef CGImageRef imageRef = [self CGImageCreateDecoded:image.CGImage]; if (!imageRef) &#123; return image; &#125; /// 重新生成一个 image UIImage *decodedImage = [[UIImage alloc] initWithCGImage:imageRef scale:image.scale orientation:image.imageOrientation]; CGImageRelease(imageRef); decodedImage.sd_isDecoded = YES; decodedImage.sd_imageFormat = image.sd_imageFormat; return decodedImage;&#125;#pragma mark - 相当于复制一个 CGImageRef+ (CGImageRef)CGImageCreateDecoded:(CGImageRef)cgImage &#123; return [self CGImageCreateDecoded:cgImage orientation:kCGImagePropertyOrientationUp];&#125;#pragma mark - 把 CGImageRef 转个向+ (CGImageRef)CGImageCreateDecoded:(CGImageRef)cgImage orientation:(CGImagePropertyOrientation)orientation &#123; if (!cgImage) &#123; return NULL; &#125; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); if (width == 0 || height == 0) return NULL; size_t newWidth; size_t newHeight; switch (orientation) &#123; case kCGImagePropertyOrientationLeft: case kCGImagePropertyOrientationLeftMirrored: case kCGImagePropertyOrientationRight: case kCGImagePropertyOrientationRightMirrored: &#123; // These orientation should swap width &amp; height newWidth = height; newHeight = width; &#125; break; default: &#123; newWidth = width; newHeight = height; &#125; break; &#125; BOOL hasAlpha = [self CGImageContainsAlpha:cgImage]; // iOS prefer BGRA8888 (premultiplied) or BGRX8888 bitmapInfo for screen rendering, which is same as `UIGraphicsBeginImageContext()` or `- [CALayer drawInContext:]` // Though you can use any supported bitmapInfo (see: https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB ) and let Core Graphics reorder it when you call `CGContextDrawImage` // But since our build-in coders use this bitmapInfo, this can have a little performance benefit CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; /// 在UI渲染的时候，实际上是把多个图层按像素叠加计算的过程，需要对每一个像素进行 RGBA 的叠加计算。当某个 layer 的是不透明的，也就是 opaque 为 YES 时，GPU 可以直接忽略掉其下方的图层，这就减少了很多工作量。这也是调用 CGBitmapContextCreate 时 bitmapInfo 参数设置为忽略掉 alpha 通道的原因。 bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; /// 创建 CGContextRef CGContextRef context = CGBitmapContextCreate(NULL, newWidth, newHeight, 8, 0, [self colorSpaceGetDeviceRGB], bitmapInfo); if (!context) &#123; return NULL; &#125; // Apply transform CGAffineTransform transform = SDCGContextTransformFromOrientation(orientation, CGSizeMake(newWidth, newHeight)); CGContextConcatCTM(context, transform); CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // The rect is bounding box of CGImage, don't swap width &amp; height CGImageRef newImageRef = CGBitmapContextCreateImage(context); CGContextRelease(context); return newImageRef;&#125; 将 UIImage 按比例减小到 bytes 内每一个像素点由于有 RGBA 四个通道，每个通道占用 1 个字节，整个像素点需要占用 4 个字节。对于一个高分辨率的图片来说，会占用大量内存资源，甚至产生 OOM。 SDWebImage 的做法是，使用分块绘制的方式，读取一部分图片的data绘制成图，再把图绘制到缩放过的 context 中，然后释放掉之前读取的 data。循环往复，将整张图都绘制出来。这样能够解决内存爆炸问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#pragma mark - 将 UIImage 按比例缩小到 bytes 内/// 加载大图可能会出现 OOM，使用分块绘制的方式，读取一部分图片的data，然后绘制到缩放过的 context 中，然后释放掉之前读取的 data。这样能够解决内存爆炸问题。+ (UIImage *)decodedAndScaledDownImageWithImage:(UIImage *)image limitBytes:(NSUInteger)bytes &#123; if (![self shouldDecodeImage:image]) &#123; return image; &#125; /// 如果不需要按比例缩小，那么直接解码 if (![self shouldScaleDownImage:image limitBytes:bytes]) &#123; return [self decodedImageWithImage:image]; &#125; CGFloat destTotalPixels; CGFloat tileTotalPixels; if (bytes &gt; 0) &#123; destTotalPixels = bytes / kBytesPerPixel; /// 这里 3 可以是任意的值，只是想获取一个较小的分块像素总量 tileTotalPixels = destTotalPixels / 3; &#125; else &#123; destTotalPixels = kDestTotalPixels; tileTotalPixels = kTileTotalPixels; &#125; CGContextRef destContext; @autoreleasepool &#123; CGImageRef sourceImageRef = image.CGImage; CGSize sourceResolution = CGSizeZero; sourceResolution.width = CGImageGetWidth(sourceImageRef); sourceResolution.height = CGImageGetHeight(sourceImageRef); CGFloat sourceTotalPixels = sourceResolution.width * sourceResolution.height; // Determine the scale ratio to apply to the input image // that results in an output image of the defined size. // see kDestImageSizeMB, and how it relates to destTotalPixels. /// 面积之比开平方，就是边长之比 CGFloat imageScale = sqrt(destTotalPixels / sourceTotalPixels); CGSize destResolution = CGSizeZero; /// 目标图像的宽高 destResolution.width = (int)(sourceResolution.width * imageScale); destResolution.height = (int)(sourceResolution.height * imageScale); // device color space CGColorSpaceRef colorspaceRef = [self colorSpaceGetDeviceRGB]; BOOL hasAlpha = [self CGImageContainsAlpha:sourceImageRef]; // iOS display alpha info (BGRA8888/BGRX8888) CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; /// 创建一个目标大小的 context destContext = CGBitmapContextCreate(NULL, destResolution.width, destResolution.height, kBitsPerComponent, 0, colorspaceRef, bitmapInfo); if (destContext == NULL) &#123; return image; &#125; /// 设置插值质量为高质量 CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh); // Now define the size of the rectangle to be used for the // incremental blits from the input image to the output image. // we use a source tile width equal to the width of the source // image due to the way that iOS retrieves image data from disk. // iOS must decode an image from disk in full width 'bands', even // if current graphics context is clipped to a subrect within that // band. Therefore we fully utilize all of the pixel data that results // from a decoding opertion by achnoring our tile size to the full // width of the input image. CGRect sourceTile = CGRectZero; /// sourcetile 的宽度是原图片的宽度 sourceTile.size.width = sourceResolution.width; // The source tile height is dynamic. Since we specified the size // of the source tile in MB, see how many rows of pixels high it // can be given the input image width. /// sourceTile 的宽高乘积是 tileTotalPixels sourceTile.size.height = (int)(tileTotalPixels / sourceTile.size.width ); sourceTile.origin.x = 0.0f; // The output tile is the same proportions as the input tile, but // scaled to image scale. CGRect destTile; destTile.size.width = destResolution.width; /// sourceTile 的高度 * 缩放比例就是 destTile 的高度 destTile.size.height = sourceTile.size.height * imageScale; destTile.origin.x = 0.0f; // The source seem overlap is proportionate to the destination seem overlap. // this is the amount of pixels to overlap each tile as we assemble the ouput image. /// 目标tile 有 2像素的 overlap。换算为 sourceTile 的overlap float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height); CGImageRef sourceTileImageRef; // calculate the number of read/write operations required to assemble the // output image. /// 要迭代的z次数等于源图片高度/原tile的高度 int iterations = (int)( sourceResolution.height / sourceTile.size.height ); // If tile height doesn't divide the image height evenly, add another iteration // to account for the remaining pixels. /// 如果不能整除，那么迭代次数要+1 int remainder = (int)sourceResolution.height % (int)sourceTile.size.height; if(remainder) &#123; iterations++; &#125; // Add seem overlaps to the tiles, but save the original tile height for y coordinate calculations. float sourceTileHeightMinusOverlap = sourceTile.size.height; sourceTile.size.height += sourceSeemOverlap; destTile.size.height += kDestSeemOverlap; /// 分块绘制 for( int y = 0; y &lt; iterations; ++y ) &#123; @autoreleasepool &#123; sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap; destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap); sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile ); if( y == iterations - 1 &amp;&amp; remainder ) &#123; float dify = destTile.size.height; destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale; dify -= destTile.size.height; destTile.origin.y += dify; &#125; CGContextDrawImage( destContext, destTile, sourceTileImageRef ); CGImageRelease( sourceTileImageRef ); &#125; &#125; /// 通过 destContext 创建 CGImageRef CGImageRef destImageRef = CGBitmapContextCreateImage(destContext); CGContextRelease(destContext); if (destImageRef == NULL) &#123; return image; &#125; /// 通过destImageRef创建image UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation]; CGImageRelease(destImageRef); if (destImage == nil) &#123; return image; &#125; destImage.sd_isDecoded = YES; destImage.sd_imageFormat = image.sd_imageFormat; return destImage; &#125;&#125;#pragma mark - 是否需要按比例缩小+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image limitBytes:(NSUInteger)bytes &#123; BOOL shouldScaleDown = YES; CGImageRef sourceImageRef = image.CGImage; CGSize sourceResolution = CGSizeZero; sourceResolution.width = CGImageGetWidth(sourceImageRef); sourceResolution.height = CGImageGetHeight(sourceImageRef); float sourceTotalPixels = sourceResolution.width * sourceResolution.height; if (sourceTotalPixels &lt;= 0) &#123; return NO; &#125; CGFloat destTotalPixels; if (bytes &gt; 0) &#123; /// bytes / 每一个像素几个 bytes = 像素数 destTotalPixels = bytes / kBytesPerPixel; &#125; else &#123; destTotalPixels = kDestTotalPixels; &#125; /// 小于1M不需要按比例缩小 if (destTotalPixels &lt;= kPixelsPerMB) &#123; // Too small to scale down return NO; &#125; /// 比例 = 目标像素/现在的image的像素 float imageScale = destTotalPixels / sourceTotalPixels; if (imageScale &lt; 1) &#123; shouldScaleDown = YES; &#125; else &#123; shouldScaleDown = NO; &#125; return shouldScaleDown;&#125; SDImageIOCoder：内置图片类型的解码器SDImageIOCoder 支持 png，jpeg ，以及部分机型支持 HEIC HEIF 的解码以及渐进式加载。 能否解码123456789101112131415- (BOOL)canDecodeFromData:(nullable NSData *)data &#123; switch ([NSData sd_imageFormatForImageData:data]) &#123; case SDImageFormatWebP: // Do not support WebP decoding return NO; case SDImageFormatHEIC: // Check HEIC decoding compatibility return [[self class] canDecodeFromHEICFormat]; case SDImageFormatHEIF: // Check HEIF decoding compatibility return [[self class] canDecodeFromHEIFFormat]; default: return YES; &#125;&#125; 能否解码主要依据与图片的类型是否是支持的类型。获取图片数据格式的方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123; if (!data) &#123; return SDImageFormatUndefined; &#125; // File signatures table: http://www.garykessler.net/library/file_sigs.html uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return SDImageFormatJPEG; case 0x89: return SDImageFormatPNG; case 0x47: return SDImageFormatGIF; case 0x49: case 0x4D: return SDImageFormatTIFF; case 0x52: &#123; if (data.length &gt;= 12) &#123; //RIFF....WEBP NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@"RIFF"] &amp;&amp; [testString hasSuffix:@"WEBP"]) &#123; return SDImageFormatWebP; &#125; &#125; break; &#125; case 0x00: &#123; if (data.length &gt;= 12) &#123; //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding]; if ([testString isEqualToString:@"ftypheic"] || [testString isEqualToString:@"ftypheix"] || [testString isEqualToString:@"ftyphevc"] || [testString isEqualToString:@"ftyphevx"]) &#123; return SDImageFormatHEIC; &#125; //....ftypmif1 ....ftypmsf1 if ([testString isEqualToString:@"ftypmif1"] || [testString isEqualToString:@"ftypmsf1"]) &#123; return SDImageFormatHEIF; &#125; &#125; break; &#125; &#125; return SDImageFormatUndefined;&#125; 通过读取 data 的第一个字节就能知道图片的类型。 判断判断是否支持某一个格式的编码，通过看是否能生成 CGImageDestination 来判断： 123456789101112131415+ (BOOL)canEncodeToFormat:(SDImageFormat)format &#123; // 判断是否支持某一个格式的编码，通过看是否能生成 CGImageDestination 来判断 NSMutableData *imageData = [NSMutableData data]; CFStringRef imageUTType = [NSData sd_UTTypeFromImageFormat:format]; // Create an image destination. CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL); if (!imageDestination) &#123; // Can't encode to HEIC return NO; &#125; else &#123; // Can encode to HEIC CFRelease(imageDestination); return YES; &#125;&#125; 直接解码：完整的 NSData → UIImage直接解码的方式非常简单粗暴，直接通过 UIImage 的方法： 1234567891011121314- (UIImage *)decodedImageWithData:(NSData *)data options:(nullable SDImageCoderOptions *)options &#123; if (!data) &#123; return nil; &#125; CGFloat scale = 1; NSNumber *scaleFactor = options[SDImageCoderDecodeScaleFactor]; if (scaleFactor != nil) &#123; scale = MAX([scaleFactor doubleValue], 1) ; &#125; UIImage *image = [[UIImage alloc] initWithData:data scale:scale]; image.sd_imageFormat = [NSData sd_imageFormatForImageData:data]; return image;&#125; 渐进式解码：部分 NSData → UIImage渐进式解码提供了边下载边解码的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma mark - 渐进式更新- (void)updateIncrementalData:(NSData *)data finished:(BOOL)finished &#123; if (_finished) &#123; return; &#125; _finished = finished; /// 要把刚获得的 data 加入到 imageSource 中 CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished); if (_width + _height == 0) &#123; CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL); if (properties) &#123; NSInteger orientationValue = 1; CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height); val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth); if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width); val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation); if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue); CFRelease(properties); // When we draw to Core Graphics, we lose orientation information, // which means the image below born of initWithCGIImage will be // oriented incorrectly sometimes. (Unlike the image born of initWithData // in didCompleteWithError.) So save it here and pass it on later. _orientation = (CGImagePropertyOrientation)orientationValue; &#125; &#125;&#125;#pragma mark - 渐进式更新后生成image- (UIImage *)incrementalDecodedImageWithOptions:(SDImageCoderOptions *)options &#123; UIImage *image; if (_width + _height &gt; 0) &#123; // Create the image CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL); if (partialImageRef) &#123; CGFloat scale = _scale; NSNumber *scaleFactor = options[SDImageCoderDecodeScaleFactor]; if (scaleFactor != nil) &#123; scale = MAX([scaleFactor doubleValue], 1); &#125; UIImageOrientation imageOrientation = [SDImageCoderHelper imageOrientationFromEXIFOrientation:_orientation]; image = [[UIImage alloc] initWithCGImage:partialImageRef scale:scale orientation:imageOrientation]; CGImageRelease(partialImageRef); CFStringRef uttype = CGImageSourceGetType(_imageSource); image.sd_imageFormat = [NSData sd_imageFormatFromUTType:uttype]; &#125; &#125; return image;&#125; 主要还是使用 Core Graphic 的 API。前一个方法通过 CGImageSourceUpdateData() 往 CGImageSourceRef 中增加 data，后一个方法把 CGImageSourceRef 生成为 UIImage 编码编码是从 UIImage 到 NSData 的转换： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format options:(nullable SDImageCoderOptions *)options &#123; if (!image) &#123; return nil; &#125; if (format == SDImageFormatUndefined) &#123; BOOL hasAlpha = [SDImageCoderHelper CGImageContainsAlpha:image.CGImage]; /// 含有 alpha 通道就是 PNG 没有就是 JPEG if (hasAlpha) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; &#125; NSMutableData *imageData = [NSMutableData data]; CFStringRef imageUTType = [NSData sd_UTTypeFromImageFormat:format]; // Create an image destination. CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL); if (!imageDestination) &#123; // Handle failure. return nil; &#125; NSMutableDictionary *properties = [NSMutableDictionary dictionary]; CGImagePropertyOrientation exifOrientation = [SDImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation]; properties[(__bridge NSString *)kCGImagePropertyOrientation] = @(exifOrientation); double compressionQuality = 1; if (options[SDImageCoderEncodeCompressionQuality]) &#123; compressionQuality = [options[SDImageCoderEncodeCompressionQuality] doubleValue]; &#125; properties[(__bridge NSString *)kCGImageDestinationLossyCompressionQuality] = @(compressionQuality); // Add your image to the destination. CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties); // Finalize the destination. if (CGImageDestinationFinalize(imageDestination) == NO) &#123; // Handle failure. imageData = nil; &#125; CFRelease(imageDestination); return [imageData copy];&#125; UIImageJPEGRepresentation() 类似的 API 也可以将 UIImage 转为 NSData，但是上面这种通过 imageIO api 的方式生成的 NSData 无论是从内存使用还是物理内存的占用上都有更好的表现。 总结从本篇的解码过程中我们可以知道，不论是从 cache 还是 download，都需要通过 data 转化为通过 bitmap 展示的 image。其中解码过程会分为两步： 从 data → image 从 image → bitmap 形式的 image 第一步由 SDImageCodersManager 管理，它通过内置的多个编解码器完成；第二部由 SDImageCoderHelper 完成，它会创建一个 bitmap，并把前面的 image 画到上面去生成一个新的 image。 在编解码阶段我们能获取到的知识点有如下： 获取图片的类型可以读取其 data 的第一个字节判断 GIF 的 duration 是不固定的，转为 iOS 中显示时要插帧 如果图片没有 alpha 通道，创建 bitmap 的时候就不要创建有 alpha 通道的。没有 alpha 通道能增快渲染效率 UIImage 只有在显示的时候才会在主线程中解码，浪费时间。可以通过在子线程中创建 bitmap 的方式提前将图片加载到内存中。 对于超大的 UIImage，为了降低内存消耗，可以按比例缩放。生成缩放图片的时候可以通过分片渲染的方式，每加载一部分，渲染一部分到缩放图片上。 渐进式解码主要使用 Core Graphic API，获取一部分数据就往 CGImageSourceRef 中丢一部分，然后生成 UIImage 使用 UIImageJPEGRepresentation() 类似 API 将 UIImage → NSData 不如使用 ImageIO 的 API 效率高，占用内存小。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码解析—下载策略]]></title>
    <url>%2F2018%2F03%2F05%2FSDWebImage3%2F</url>
    <content type="text"><![CDATA[上一篇的缓存策略主要说到二级缓存。这一部分将谈及下载。 SDWebImageManager 调用首先看 SDWebImageManager 中的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma mark - 下载图片- (void)callDownloadProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context cachedImage:(nullable UIImage *)cachedImage cachedData:(nullable NSData *)cachedData cacheType:(SDImageCacheType)cacheType progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should download image from network /// 能否下载 /// options 不是只能从 cache 中加载 BOOL shouldDownload = !SD_OPTIONS_CONTAINS(options, SDWebImageFromCacheOnly); /// 并且不存在缓存的 image 或者 options 必须要刷新缓存的 image shouldDownload &amp;= (!cachedImage || options &amp; SDWebImageRefreshCached); /// 并且 delegate 没有 imageManager:shouldDownloadImageForURL: 方法或者返回的是 true shouldDownload &amp;= (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]); /// SDWebImageDownloader 中实现，对所有费控 url 都是 true shouldDownload &amp;= [self.imageLoader canRequestImageForURL:url]; /// 如果必须要下载 if (shouldDownload) &#123; /// 如果 option 的目的是 refreshCached。那么要重新从服务器下载，让 NSURLCache 记录下新的缓存 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; // Pass the cached image to the image loader. The image loader should check whether the remote image is equal to the cached image. SDWebImageMutableContext *mutableContext; if (context) &#123; mutableContext = [context mutableCopy]; &#125; else &#123; mutableContext = [NSMutableDictionary dictionary]; &#125; mutableContext[SDWebImageContextLoaderCachedImage] = cachedImage; context = [mutableContext copy]; &#125; // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle @weakify(operation); /// 下载的 operation operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; /// 如果 operation 已经销毁或者已经取消,抛出error [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil] url:url]; &#125; else if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached &amp;&amp; [error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCacheNotModified) &#123; /// 如果下载的目的是刷新缓存，但是缓存没有变化，那么什么也不做 &#125; else if ([error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCancelled) &#123; /// 过早的被取消 [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; &#125; else if (error) &#123; /// 各种其他错误 [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; /// 判断是否要 block 错误的 url BOOL shouldBlockFailedURL = [self shouldBlockFailedURLWithURL:url error:error]; if (shouldBlockFailedURL) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; /// 其他成功的情况 if ((options &amp; SDWebImageRetryFailed)) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; /// 进行图片存储 [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; /// 如果不让下载，但是有缓存的图片，b把缓存图片t返回 &#125; else if (cachedImage) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; /// 没有缓存的图片并且也不能下载，直接调用complete 回调把空返回 &#125; else &#123; // Image not in cache and download disallowed by delegate [self callCompletionBlockForOperation:operation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125;&#125; 它会通过其属性 imageLoader 去创建一个下载用的 operation。这个 imageLoader 属性的定义如下，它会满足 SDImageLoader 协议： 1@property (strong, nonatomic, readonly, nonnull) id&lt;SDImageLoader&gt; imageLoader; 在初始化 SDWebImageManager 的时候对其进行了设置，它默认是 SDWebImageDownloader 的实例。 SDWebImageDownloader初始化方法SDWebImageDownloader 也是一个单例对象，它的初始化方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (instancetype)initWithConfig:(SDWebImageDownloaderConfig *)config &#123; self = [super init]; if (self) &#123; if (!config) &#123; config = SDWebImageDownloaderConfig.defaultDownloaderConfig; &#125; _config = [config copy]; /// 监听 config 中设置的最大并发数 [_config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxConcurrentDownloads)) options:0 context:SDWebImageDownloaderContext]; /// 创建一个用于下载的 NSOperationQueue _downloadQueue = [NSOperationQueue new]; /// NSOperationQueue 的最大并发数 _downloadQueue.maxConcurrentOperationCount = _config.maxConcurrentDownloads; _downloadQueue.name = @"com.hackemist.SDWebImageDownloader"; _URLOperations = [NSMutableDictionary new]; NSMutableDictionary&lt;NSString *, NSString *&gt; *headerDictionary = [NSMutableDictionary dictionary]; NSString *userAgent = nil; // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 /// 设置 UA userAgent = [NSString stringWithFormat:@"%@/%@ (%@; iOS %@; Scale/%0.2f)", [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]]; if (userAgent) &#123; if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) &#123; NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@"Any-Latin; Latin-ASCII; [:^ASCII:] Remove", false)) &#123; userAgent = mutableUserAgent; &#125; &#125; headerDictionary[@"User-Agent"] = userAgent; &#125; headerDictionary[@"Accept"] = @"image/*,*/*;q=0.8"; _HTTPHeaders = headerDictionary; _HTTPHeadersLock = dispatch_semaphore_create(1); _operationsLock = dispatch_semaphore_create(1); NSURLSessionConfiguration *sessionConfiguration = _config.sessionConfiguration; if (!sessionConfiguration) &#123; sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ /// 创建 NSURLSession _session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:nil]; &#125; return self;&#125; 初始化了一个 NSURLSession，并且设置了部分 header。 外部调用方法外部调用的方法如下，它先对 options 做了一个简单的处理： 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 外部调用- (id&lt;SDWebImageOperation&gt;)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock &#123; UIImage *cachedImage = context[SDWebImageContextLoaderCachedImage]; SDWebImageDownloaderOptions downloaderOptions = 0; /// 低优先级 if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; /// image 会一点一点加载出来 if (options &amp; SDWebImageProgressiveLoad) downloaderOptions |= SDWebImageDownloaderProgressiveLoad; /// 使用 NSURLCache 缓存 if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; /// 允许后台下载 if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; /// cookies 相关 if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; /// 允许非法 SSL if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; /// 高优先级 if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; /// 降低图片的 scale if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; /// 禁止解码图片 if (options &amp; SDWebImageAvoidDecodeImage) downloaderOptions |= SDWebImageDownloaderAvoidDecodeImage; /// 值解码第一帧 if (options &amp; SDWebImageDecodeFirstFrameOnly) downloaderOptions |= SDWebImageDownloaderDecodeFirstFrameOnly; /// 预加载所有帧 if (options &amp; SDWebImagePreloadAllFrames) downloaderOptions |= SDWebImageDownloaderPreloadAllFrames; /// 有图但是要刷新缓存 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; // force progressive off if image already cached but forced refreshing downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveLoad; // ignore image read from NSURLCache if image if cached but force refreshing downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock];&#125; 创建 SDWebImageDownloadToken SDWebImageDownloadToken 类型的实例就是保存在 SDWebImageCombinedOperation 中的 loaderOperation。先看一下它的实例对象： 1234567891011@interface SDWebImageDownloadToken ()@property (nonatomic, strong, nullable, readwrite) NSURL *url;@property (nonatomic, strong, nullable, readwrite) NSURLRequest *request;@property (nonatomic, strong, nullable, readwrite) NSURLResponse *response;@property (nonatomic, strong, nullable, readwrite) id downloadOperationCancelToken;@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperation&gt; *downloadOperation;@property (nonatomic, weak, nullable) SDWebImageDownloader *downloader;@property (nonatomic, assign, getter=isCancelled) BOOL cancelled;@end 可以看到它的内部包含一个 NSOperation 和 cancelled 实例。可以看出，他是 NSOperation 的包装类。来看一下它的创建过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; if (url == nil) &#123; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;NSLocalizedDescriptionKey : @"Image url is nil"&#125;]; completedBlock(nil, nil, error, YES); &#125; return nil; &#125; SD_LOCK(self.operationsLock); id downloadOperationCancelToken; /// 从单例的 URLOperations 池中取出该 url 对应的 operation NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url]; if (!operation || operation.isFinished || operation.isCancelled) &#123; /// 如果 opertion 不存在或者已经结束了，那么就创建一个新的 operation operation = [self createDownloaderOperationWithUrl:url options:options context:context]; /// 没创建成功就报错 if (!operation) &#123; SD_UNLOCK(self.operationsLock); if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadOperation userInfo:@&#123;NSLocalizedDescriptionKey : @"Downloader operation is nil"&#125;]; completedBlock(nil, nil, error, YES); &#125; return nil; &#125; @weakify(self); /// opeartion 完成之后要移除单例中对应的 operation operation.completionBlock = ^&#123; @strongify(self); if (!self) &#123; return; &#125; SD_LOCK(self.operationsLock); [self.URLOperations removeObjectForKey:url]; SD_UNLOCK(self.operationsLock); &#125;; /// 把创建的 operation 加入到单例的字典中 self.URLOperations[url] = operation; // Add operation to operation queue only after all configuration done according to Apple's doc. // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock. /// 开启异步任务 [self.downloadQueue addOperation:operation]; /// 把 progressBlock 和 completedBlock 放到 Operation 的数组中。 downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; &#125; else &#123; /// 如果单例中已经存在了这个 opeartion，那么说明对于这个下载任务会有多个监听。因此通过 addHandlersForProgress 将完成回调加入 operation 的数组中 @synchronized (operation) &#123; downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; &#125; /// 存在 operation 并且不是在执行中 if (!operation.isExecuting) &#123; /// 根据 options 设置优先级 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; else &#123; operation.queuePriority = NSOperationQueuePriorityNormal; &#125; &#125; &#125; SD_UNLOCK(self.operationsLock); /// SDWebImageDownloadToken 是 operation 的包装类 SDWebImageDownloadToken *token = [[SDWebImageDownloadToken alloc] initWithDownloadOperation:operation]; token.url = url; token.request = operation.request; /// 通过downloadOperationCancelToken作为标识可以取消某一个opeartion的回调 token.downloadOperationCancelToken = downloadOperationCancelToken; token.downloader = self; return token;&#125; SDWebImageDownloader 是一个单例对象，它的内部包含了一个 URLOpeartion 的字典，保存着 url → NSOpeartion 的映射。当重复请求同一个正在请求的 url 的时候，就可以将回调方法保存在 NSOperation 的特定数组中，可以通过创建的 downloadOperationCancelToken 找到它，在特定的时候销毁或取消。 先不谈 NSOperation 是如何创建的，当它被创建之后，会被包裹在 SDWebImageDownloadToken 实例中，同样还包括 downloadOperationCancelToken。通过 downloadOperationCancelToken 可以取消某一个回调。 SDWebImageDownloaderOperationSDWebImageDownloaderOperation 是 NSOperation 的子类，负责异步下载。 创建 NSOperation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - 创建下载 Operation- (nullable NSOperation&lt;SDWebImageDownloaderOperation&gt; *)createDownloaderOperationWithUrl:(nonnull NSURL *)url options:(SDWebImageDownloaderOptions)options context:(nullable SDWebImageContext *)context &#123; /// 请求超时时间 NSTimeInterval timeoutInterval = self.config.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise /// 是否使用 NSURLCache NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; /// 创建一个 request NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval]; mutableRequest.HTTPShouldHandleCookies = SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies); mutableRequest.HTTPShouldUsePipelining = YES; SD_LOCK(self.HTTPHeadersLock); /// 设置 request 的 http 头 mutableRequest.allHTTPHeaderFields = self.HTTPHeaders; SD_UNLOCK(self.HTTPHeadersLock); /// 自定义对于请求做一些修改 id&lt;SDWebImageDownloaderRequestModifier&gt; requestModifier; if ([context valueForKey:SDWebImageContextDownloadRequestModifier]) &#123; requestModifier = [context valueForKey:SDWebImageContextDownloadRequestModifier]; &#125; else &#123; requestModifier = self.requestModifier; &#125; NSURLRequest *request; if (requestModifier) &#123; NSURLRequest *modifiedRequest = [requestModifier modifiedRequestWithRequest:[mutableRequest copy]]; // If modified request is nil, early return if (!modifiedRequest) &#123; return nil; &#125; else &#123; request = [modifiedRequest copy]; &#125; &#125; else &#123; request = [mutableRequest copy]; &#125; /// 有自定义 operationClass 用 operationClass，没有就用默认的 SDWebImageDownloaderOperation Class operationClass = self.config.operationClass; if (operationClass &amp;&amp; [operationClass isSubclassOfClass:[NSOperation class]] &amp;&amp; [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperation)]) &#123; // Custom operation class &#125; else &#123; operationClass = [SDWebImageDownloaderOperation class]; &#125; NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [[operationClass alloc] initWithRequest:request inSession:self.session options:options context:context]; /// 有鉴权执行鉴权 if ([operation respondsToSelector:@selector(setCredential:)]) &#123; if (self.config.urlCredential) &#123; operation.credential = self.config.urlCredential; &#125; else if (self.config.username &amp;&amp; self.config.password) &#123; operation.credential = [NSURLCredential credentialWithUser:self.config.username password:self.config.password persistence:NSURLCredentialPersistenceForSession]; &#125; &#125; /// 最小回调进度 if ([operation respondsToSelector:@selector(setMinimumProgressInterval:)]) &#123; operation.minimumProgressInterval = MIN(MAX(self.config.minimumProgressInterval, 0), 1); &#125; /// 下载优先级 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; /// 如果是后进先出的，那么通过dependency确定执行顺序 if (self.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation's dependency [self.lastAddedOperation addDependency:operation]; self.lastAddedOperation = operation; &#125; return operation;&#125; SDWebImage 中充分利用了协议代替继承。这里需要创建的是一个实现了 SDWebImageDownloaderOperation 协议的 NSOperation: 12345678910111213141516171819202122232425262728@protocol SDWebImageDownloaderOperation &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;@required/// 初始化方法，保存 NSURLRequest 和 NSURLSession 实例对象- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options;- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request inSession:(nullable NSURLSession *)session options:(SDWebImageDownloaderOptions)options context:(nullable SDWebImageContext *)context;/// 保存进度回调以及完成回调- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;/// 根据 token 取消 NSOperation 中的某个进度及完成回调- (BOOL)cancel:(nullable id)token;@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;@property (strong, nonatomic, readonly, nullable) NSURLResponse *response;@optional@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;@property (strong, nonatomic, nullable) NSURLCredential *credential;@property (assign, nonatomic) double minimumProgressInterval;@end 在 SDWebImage 中，默认的实现类是 SDWebImageDownloaderOperation。 开始执行当 NSOperation 通过 addOpeartion 被添加到 NSOperationQueue 的时候，就会触发 NSOperation 的 start 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma mark - 开启下载/// 通过 addOperation 开始的- (void)start &#123; @synchronized (self) &#123; /// 如果已经被取消了 if (self.isCancelled) &#123; self.finished = YES; // Operation cancelled by user before sending the request [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil]]; [self reset]; return; &#125; Class UIApplicationClass = NSClassFromString(@"UIApplication"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; /// 如果 options 要求在后台仍需要执行任务的话 if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak typeof(self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; /// 取消所有的下载任务 [wself cancel]; &#125;]; &#125; NSURLSession *session = self.unownedSession; if (!session) &#123; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ /// 如果不存在 session 那么创建一个 session session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; self.ownedSession = session; &#125; /// 如果要无视 NSURLCache 的缓存 if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123; // Grab the cached data for later check NSURLCache *URLCache = session.configuration.URLCache; if (!URLCache) &#123; URLCache = [NSURLCache sharedURLCache]; &#125; NSCachedURLResponse *cachedResponse; // NSURLCache's `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483 @synchronized (URLCache) &#123; cachedResponse = [URLCache cachedResponseForRequest:self.request]; &#125; if (cachedResponse) &#123; self.cachedData = cachedResponse.data; &#125; &#125; /// 通过 session 创建 dataTask self.dataTask = [session dataTaskWithRequest:self.request]; self.executing = YES; &#125; /// 如果创建了 dataTask if (self.dataTask) &#123; /// 根据 options 设置优先级 if (self.options &amp; SDWebImageDownloaderHighPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityHigh; &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityLow; &#125; /// 开启 dataTask [self.dataTask resume]; /// 执行 progressBlock for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(0, NSURLResponseUnknownLength, self.request.URL); &#125; __block typeof(self) strongSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:strongSelf]; &#125;); &#125; else &#123; /// 没有创建玩报错 [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadOperation userInfo:@&#123;NSLocalizedDescriptionKey : @"Task can't be initialized"&#125;]]; [self done]; &#125;&#125; 在 start 方法中，创建并保存了 NSURLSession 实例，然后通过它创建并开启了 NSURLSessionTask。 beginBackgroundTaskWithExpirationHandler 不是意味着立即执行后台任务，它相当于注册了一个后台任务，而之后的 handler 表示 App 在直到后台运行的时机到来后在运行其中的 block 代码逻辑。 NSURLSessionDataDelegateSDWebImageDownloaderOperation 是 NSURLSession 的 NSURLSessionDataDelegate。首先看第一次收到数据后的回调方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243/// 收到数据后第一次回调- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123; NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; /// 拿到预计的图片的大小 NSInteger expected = (NSInteger)response.expectedContentLength; expected = expected &gt; 0 ? expected : 0; self.expectedSize = expected; self.response = response; /// 拿到返回的状态码 NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200; /// 200 - 400 之间的是有效的 BOOL valid = statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400; /// 无效的状态码直接报错 if (!valid) &#123; self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;]; &#125; //'304 Not Modified' is an exceptional one //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check if (statusCode == 304 &amp;&amp; !self.cachedData) &#123; valid = NO; self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCacheNotModified userInfo:nil]; &#125; if (valid) &#123; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(0, expected, self.request.URL); &#125; &#125; else &#123; /// 如果是 invalid ，那么取消这次请求 disposition = NSURLSessionResponseCancel; &#125; __block typeof(self) strongSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf]; &#125;); if (completionHandler) &#123; completionHandler(disposition); &#125;&#125; 首先是获取期望的数据大小 expectedContentLength，随后通过 statusCode 判断是否可以接收 data。调用了 completionHander 之后，进入下一个代码方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 收到数据- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; if (!self.imageData) &#123; /// 创建一个 expectedSize 大小的 NSMutableData self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize]; &#125; /// 把 data append 到 imageData 中 [self.imageData appendData:data]; /// 计算已接收数据大小 self.receivedSize = self.imageData.length; if (self.expectedSize == 0) &#123; // Unknown expectedSize, immediately call progressBlock and return for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; /// 回调 progressBlock progressBlock(self.receivedSize, self.expectedSize, self.request.URL); &#125; return; &#125; /// 如果收到的 data 大于期望的 data，那么直接表示完成 BOOL finished = (self.receivedSize &gt;= self.expectedSize); double currentProgress = (double)self.receivedSize / (double)self.expectedSize; double previousProgress = self.previousProgress; double progressInterval = currentProgress - previousProgress; /// 本次接收到的数据的大小小于最小的回调间隔，那么取消回调 if (!finished &amp;&amp; (progressInterval &lt; self.minimumProgressInterval)) &#123; return; &#125; self.previousProgress = currentProgress; /// 如果是渐进式的加载方式 if (self.options &amp; SDWebImageDownloaderProgressiveLoad) &#123; NSData *imageData = [self.imageData copy]; /// 在 coderQueue 队列中，渐进式的 decode dispatch_async(self.coderQueue, ^&#123; @autoreleasepool &#123; UIImage *image = SDImageLoaderDecodeProgressiveImageData(imageData, self.request.URL, finished, self, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context); if (image) &#123; // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding. [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO]; &#125; &#125; &#125;); &#125; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(self.receivedSize, self.expectedSize, self.request.URL); &#125;&#125; 不断的接收 data，并且将 data append 到 imageData 之后。如果是渐进式的加载方式，还需要变下载边解码。 下载好之后，会有一个回调判断是否要通过 NSURLCache 缓存数据： 12345678910111213141516/// 判断是否可以缓存 response 的回调- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (!(self.options &amp; SDWebImageDownloaderUseNSURLCache)) &#123; // Prevents caching of responses cachedResponse = nil; &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125; NSURLSessionTaskDelegate在下载完成后会回调 NSURLSessionTaskDelegate 的完成方法。在这里可以将获取的 data 通过回调函数回传给 Manager： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// 完成回调- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123; // If we already cancel the operation or anything mark the operation finished, don't callback twice if (self.isFinished) return; @synchronized(self) &#123; self.dataTask = nil; __block typeof(self) strongSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:strongSelf]; if (!error) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:strongSelf]; &#125; &#125;); &#125; if (error) &#123; /// 存在 error 回调抛出异常 if (self.responseError) &#123; error = self.responseError; &#125; [self callCompletionBlocksWithError:error]; [self done]; &#125; else &#123; /// 调用成功回调 if ([self callbacksForKey:kCompletedCallbackKey].count &gt; 0) &#123; NSData *imageData = [self.imageData copy]; self.imageData = nil; if (imageData) &#123; /// 如果 options 是无视缓存的 response 的，并且下载下来的 image 和 URLCache 一致 if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [self.cachedData isEqualToData:imageData]) &#123; /// 抛出异常，表示没有改变或 self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCacheNotModified userInfo:nil]; // call completion block with not modified error [self callCompletionBlocksWithError:self.responseError]; [self done]; &#125; else &#123; dispatch_async(self.coderQueue, ^&#123; @autoreleasepool &#123; /// 在 coderQueue 中解码 UIImage *image = SDImageLoaderDecodeImageData(imageData, self.request.URL, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context); CGSize imageSize = image.size; if (imageSize.width == 0 || imageSize.height == 0) &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorBadImageData userInfo:@&#123;NSLocalizedDescriptionKey : @"Downloaded image has 0 pixels"&#125;]]; &#125; else &#123; [self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES]; &#125; [self done]; &#125; &#125;); &#125; &#125; else &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorBadImageData userInfo:@&#123;NSLocalizedDescriptionKey : @"Image data is nil"&#125;]]; [self done]; &#125; &#125; else &#123; [self done]; &#125; &#125;&#125; 至此，下载部分就结束了 总结总的来说就是通过 SDWebImageDownloader 这个单例对象为每个请求创建一个 SDWebImageDownloadToken 实例来管理下载。同时 SDWebImageDownloader 也会保存每一个下载任务以供取消。SDWebImageDownloadToken 中又包含 SWDweImageDownloaderOperation 这个 NSOperation 的子类，用于真正的下载。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码解析—缓存策略]]></title>
    <url>%2F2018%2F03%2F03%2FSDWebImage2%2F</url>
    <content type="text"><![CDATA[上一篇说了整体的 Manager 所做的事情。现在来有针对性的看看缓存策略是怎样的 SDImageCache说到缓存，一般都会想到两级缓存：内存缓存和磁盘缓存。SDWebImage 也不例外，我们先开看一下初始化方法： 初始化方法SDImageCache 是一个单例对象。它的初始化方法中会创建磁盘缓存对象 _diskCache，和内存缓存对象 _memoryCache： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758+ (nonnull instancetype)sharedImageCache &#123; static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; &#125;); return instance;&#125;- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nullable NSString *)directory config:(nullable SDImageCacheConfig *)config &#123; if ((self = [super init])) &#123; NSAssert(ns, @"Cache namespace should not be nil"); // Create IO serial queue _ioQueue = dispatch_queue_create("com.hackemist.SDImageCache", DISPATCH_QUEUE_SERIAL); if (!config) &#123; config = SDImageCacheConfig.defaultCacheConfig; &#125; _config = [config copy]; // Init the memory cache NSAssert([config.memoryCacheClass conformsToProtocol:@protocol(SDMemoryCache)], @"Custom memory cache class must conform to `SDMemoryCache` protocol"); /// 创建 memoryCache _memoryCache = [[config.memoryCacheClass alloc] initWithConfig:_config]; // Init the disk cache /// 设置缓存目录 if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:ns]; &#125; else &#123; NSString *path = [[[self userCacheDirectory] stringByAppendingPathComponent:@"com.hackemist.SDImageCache"] stringByAppendingPathComponent:ns]; _diskCachePath = path; &#125; NSAssert([config.diskCacheClass conformsToProtocol:@protocol(SDDiskCache)], @"Custom disk cache class must conform to `SDDiskCache` protocol"); /// 创建 diskCache 实例 _diskCache = [[config.diskCacheClass alloc] initWithCachePath:_diskCachePath config:_config]; // Check and migrate disk cache directory if need [self migrateDiskCacheDirectory]; // Subscribe to app events [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:UIApplicationWillTerminateNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; &#125; return self;&#125; 可以看到，两个缓存的类型都是通过 config 获取的。config 默认的类型为 SDMemoryCache 和 SDDiskCache。 SDMemoryCache 初始化SDMemoryCache 初始化方法如下： 1234567891011121314151617181920- (void)commonInit &#123; SDImageCacheConfig *config = self.config; /// 缓存内存缓存的最大值 self.totalCostLimit = config.maxMemoryCost; /// 内存缓存数量上的最大值 self.countLimit = config.maxMemoryCount; /// 对 config 的 maxMemoryCost 和 maxMenoryCount 做监听如果变化了，立刻变化内存缓存的相应值 [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCost)) options:0 context:SDMemoryCacheContext]; [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCount)) options:0 context:SDMemoryCacheContext]; /// 新建一个弱引用字典 self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; self.weakCacheLock = dispatch_semaphore_create(1); [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didReceiveMemoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];&#125; 主要设置了缓存的最大值和最大数量。另外 weakCache 是一个令人注意的地方。它是一个 NSMapTable，它的作用会在后续使用的时候揭晓。 另外，totalCostLimit 和 countLimit 是 NSCache 的两个属性。SDMemoryCache 是 NSCache 的子类。 SDDiskCache 初始化SDDiskCache 的初始化方法就简单了很多。就是获取一个 NSFileManager 1234567- (void)commonInit &#123; if (self.config.fileManager) &#123; self.fileManager = self.config.fileManager; &#125; else &#123; self.fileManager = [NSFileManager new]; &#125;&#125; 入口方法前篇说到，Manager 会通过 SDImageCache 实例，创建一个缓存的 operation： 12345678910111213/// 进行缓存相关操作，把返回的 Operation 设置给 CacheOperationoperation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); /// 如果执行过程中操作取消，安全移除操作 if (!operation || operation.isCancelled) &#123; // Image combined operation cancelled by user [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil] url:url]; [self safelyRemoveOperationFromRunning:operation]; return; &#125; /// 前面拿好了缓存，现在就要开始下载 [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];&#125;]; 现在来到具体方法中： 12345678910111213141516171819- (id&lt;SDWebImageOperation&gt;)queryImageForKey:(NSString *)key options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context completion:(nullable SDImageCacheQueryCompletionBlock)completionBlock &#123; SDImageCacheOptions cacheOptions = 0; /// 设置 options 选项 if (options &amp; SDWebImageQueryMemoryData) cacheOptions |= SDImageCacheQueryMemoryData; /// 从内存中同步查找 if (options &amp; SDWebImageQueryMemoryDataSync) cacheOptions |= SDImageCacheQueryMemoryDataSync; /// 内存不存在时，从磁盘同步查找 if (options &amp; SDWebImageQueryDiskDataSync) cacheOptions |= SDImageCacheQueryDiskDataSync; /// 将大图压缩到适当大小 if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; /// 禁止下载完就将图片解码（立即解码可能会导致内存使用变大） if (options &amp; SDWebImageAvoidDecodeImage) cacheOptions |= SDImageCacheAvoidDecodeImage; /// 动图只解码第一帧（否则会全部解码） if (options &amp; SDWebImageDecodeFirstFrameOnly) cacheOptions |= SDImageCacheDecodeFirstFrameOnly; /// 动图提前准备好所有帧（降低多处使用同一动图的 CPU 加载消耗） if (options &amp; SDWebImagePreloadAllFrames) cacheOptions |= SDImageCachePreloadAllFrames; return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];&#125; 这里对于外部传来的 options 做了一些处理。然后传入内部的处理方法。 内部方法内部方法分为两部分，从 Memory 中查找缓存以及从 Disk 中查找缓存。方法很长： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options context:(nullable SDWebImageContext *)context done:(nullable SDImageCacheQueryCompletionBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; /// 获取自定义的 transformer id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; if (transformer) &#123; /// 将自定义的 transformer 的 key 拼接到原来的 key 上 NSString *transformerKey = [transformer transformerKey]; key = SDTransformedKeyForKey(key, transformerKey); &#125; // First check the in-memory cache... /// 从内存获取image UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; /// 只解码第一帧 if (options &amp; SDImageCacheDecodeFirstFrameOnly) &#123; // Ensure static image Class animatedImageClass = image.class; if (image.sd_isAnimated || ([animatedImageClass isSubclassOfClass:[UIImage class]] &amp;&amp; [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)])) &#123; image = [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation]; &#125; &#125; else if (options &amp; SDImageCacheMatchAnimatedImageClass) &#123; // Check image class matching Class animatedImageClass = image.class; Class desiredImageClass = context[SDWebImageContextAnimatedImageClass]; if (desiredImageClass &amp;&amp; ![animatedImageClass isSubclassOfClass:desiredImageClass]) &#123; image = nil; &#125; &#125; &#125; /// 只能从 Memory 中读取 BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData)); if (shouldQueryMemoryOnly) &#123; if (doneBlock) &#123; doneBlock(image, nil, SDImageCacheTypeMemory); &#125; return nil; &#125; NSOperation *operation = [NSOperation new]; /// 如果内存中存在图片，并且需要同步获取，或者内存中不存在图片，并且需要同步从磁盘获取 BOOL shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) || (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync)); /// 查找缓存的 block void(^queryDiskBlock)(void) = ^&#123; /// 如果是已经取消了，那么直接执行完成回调 if (operation.isCancelled) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return; &#125; @autoreleasepool &#123; /// 从磁盘读取data NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage; SDImageCacheType cacheType = SDImageCacheTypeNone; if (image) &#123; /// 如果有 image，说明从 Memory 中q读取的。设置它的类型 diskImage = image; cacheType = SDImageCacheTypeMemory; &#125; else if (diskData) &#123; /// 如果有 diskData，说明是从 disk 中读取的。设置它的类型为磁盘类型 cacheType = SDImageCacheTypeDisk; /// 还需要将data转为image diskImage = [self diskImageForKey:key data:diskData options:options context:context]; /// 如果配置为需要缓存到内存中。那么就将磁盘中读取的 Image 存到内存中 if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = diskImage.sd_memoryCost; [self.memoryCache setObject:diskImage forKey:key cost:cost]; &#125; &#125; if (doneBlock) &#123; /// 是否是同步方法 if (shouldQueryDiskSync) &#123; doneBlock(diskImage, diskData, cacheType); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, cacheType); &#125;); &#125; &#125; &#125; &#125;; /// isQueue 是一个串行队列。根据 shouldQueryDiskSync 判断是否同步执行 if (shouldQueryDiskSync) &#123; dispatch_sync(self.ioQueue, queryDiskBlock); &#125; else &#123; dispatch_async(self.ioQueue, queryDiskBlock); &#125; return operation;&#125; 内存查找 image内存查找方法直接从前面创建的 SDMemoryCache 对象 memoryCache 对象中获取： 123- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123; return [self.memoryCache objectForKey:key];&#125; SDMemoryCache 本身继承于 NSCache，它有一套系统的缓存方式，会自动在某个时刻进行内存的释放。不过 SDWebImage 重写了 objectForKey 方法： 123456789101112131415161718192021222324252627- (id)objectForKey:(id)key &#123; /// NSCache 的 objectforkey 方法 id obj = [super objectForKey:key]; /// 如果 config 设置不能自己缓存则直接返回 NSCache 的缓存对象 if (!self.config.shouldUseWeakMemoryCache) &#123; return obj; &#125; /// 如果 NSCache 中没有找到缓存 if (key &amp;&amp; !obj) &#123; // Check weak cache SD_LOCK(self.weakCacheLock); /// 从自己的NSMapTable 中搜索 obj = [self.weakCache objectForKey:key]; SD_UNLOCK(self.weakCacheLock); /// 如果从 NSMapTable 中找到了 if (obj) &#123; /// 设置缓存大小 NSUInteger cost = 0; if ([obj isKindOfClass:[UIImage class]]) &#123; cost = [(UIImage *)obj sd_memoryCost]; &#125; /// 把从 NSMapTable 中找到的对象再设置回 NSCache [super setObject:obj forKey:key cost:cost]; &#125; &#125; return obj;&#125; 这里就用到了上面 SDMemoryCache 初始化的 NSMapTable 了。那么它的作用是什么呢？由于 NSCache 是系统维护回收状态的缓存，可能在任何时候回收。那么就可能出现 image 还存在，但是已经被 NSCache 回收的情况，容易产生因为内存紧张频繁释放内存导致频繁从磁盘加载图片的情况。 因此，在 NSCache 本身的缓存回收机制下，再设置一个弱引用的字典。它并不影响缓存的引用计数。但是如果 image 没有被回收，那么也不会像 NSCache 一样可能被回收。 类似的，在把 image 丢到 SDMemoryCache 中的时候需要设置到 NSMapTable 中： 12345678910111213- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g &#123; [super setObject:obj forKey:key cost:g]; if (!self.config.shouldUseWeakMemoryCache) &#123; return; &#125; /// 两套方案，一套 NSCache 的缓存，y再通过弱引用一套。 if (key &amp;&amp; obj) &#123; // Store weak cache SD_LOCK(self.weakCacheLock); [self.weakCache setObject:obj forKey:key]; SD_UNLOCK(self.weakCacheLock); &#125;&#125; Disk 中查找 image123456789101112131415161718192021- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; if (!key) &#123; return nil; &#125; /// 从磁盘中读取 Data NSData *data = [self.diskCache dataForKey:key]; if (data) &#123; return data; &#125; /// 从自定义的 key → path block 中获取文件路径读取路径 if (self.additionalCachePathBlock) &#123; NSString *filePath = self.additionalCachePathBlock(key); if (filePath) &#123; data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; &#125; &#125; return data;&#125; SDDiskCache 中的查找方法。这是一个比较简单明确的方法： 123456789101112131415161718- (NSData *)dataForKey:(NSString *)key &#123; NSParameterAssert(key); /// 拿到 disk 缓存的路径 NSString *filePath = [self cachePathForKey:key]; /// 到这个路径上找相应的 data NSData *data = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; /// 获取到了 data 说明存才 cache，直接返回 if (data) &#123; return data; &#125; data = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil]; if (data) &#123; return data; &#125; return nil;&#125; Disk 中的 NSData 转 UIImage从 Disk 中拿到的是 NSData 对象。我们需要把它转为 UIImage： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options context:(SDWebImageContext *)context &#123; if (data) &#123; /// NSData 转 UIImage UIImage *image = SDImageCacheDecodeImageData(data, key, [[self class] imageOptionsFromCacheOptions:options], context); return image; &#125; else &#123; return nil; &#125;&#125;UIImage * _Nullable SDImageCacheDecodeImageData(NSData * _Nonnull imageData, NSString * _Nonnull cacheKey, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123; UIImage *image; /// 判断是否只要解码第一帧 BOOL decodeFirstFrame = SD_OPTIONS_CONTAINS(options, SDWebImageDecodeFirstFrameOnly); NSNumber *scaleValue = context[SDWebImageContextImageScaleFactor]; /// 获取解码的 scale CGFloat scale = scaleValue.doubleValue &gt;= 1 ? scaleValue.doubleValue : SDImageScaleFactorForKey(cacheKey); SDImageCoderOptions *coderOptions = @&#123;SDImageCoderDecodeFirstFrameOnly : @(decodeFirstFrame), SDImageCoderDecodeScaleFactor : @(scale)&#125;; if (context) &#123; SDImageCoderMutableOptions *mutableCoderOptions = [coderOptions mutableCopy]; [mutableCoderOptions setValue:context forKey:SDImageCoderWebImageContext]; coderOptions = [mutableCoderOptions copy]; &#125; /// 如果不仅仅解码第一帧，则从 context 中取出 AnimatedImageClass，默认使用的是 SDAnimatedImage，然后进行图片数据的解码，根据需要还可以预解码所有帧 if (!decodeFirstFrame) &#123; Class animatedImageClass = context[SDWebImageContextAnimatedImageClass]; // check whether we should use `SDAnimatedImage` if ([animatedImageClass isSubclassOfClass:[UIImage class]] &amp;&amp; [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)]) &#123; image = [[animatedImageClass alloc] initWithData:imageData scale:scale options:coderOptions]; if (image) &#123; // Preload frames if supported if (options &amp; SDWebImagePreloadAllFrames &amp;&amp; [image respondsToSelector:@selector(preloadAllFrames)]) &#123; [((id&lt;SDAnimatedImage&gt;)image) preloadAllFrames]; &#125; &#125; else &#123; // Check image class matching if (options &amp; SDWebImageMatchAnimatedImageClass) &#123; return nil; &#125; &#125; &#125; &#125; if (!image) &#123; /// 解码出 UIImage image = [[SDImageCodersManager sharedManager] decodedImageWithData:imageData options:coderOptions]; &#125; if (image) &#123; /// 查看是否需要解码 BOOL shouldDecode = !SD_OPTIONS_CONTAINS(options, SDWebImageAvoidDecodeImage); if ([image.class conformsToProtocol:@protocol(SDAnimatedImage)]) &#123; // `SDAnimatedImage` do not decode /// 动图不需要解码 shouldDecode = NO; &#125; else if (image.sd_isAnimated) &#123; // animated image do not decode shouldDecode = NO; &#125; /// 需要解码就开始解码 if (shouldDecode) &#123; BOOL shouldScaleDown = SD_OPTIONS_CONTAINS(options, SDWebImageScaleDownLargeImages); if (shouldScaleDown) &#123; image = [SDImageCoderHelper decodedAndScaledDownImageWithImage:image limitBytes:0]; &#125; else &#123; image = [SDImageCoderHelper decodedImageWithImage:image]; &#125; &#125; &#125; return image;&#125; 具体解码相关键后续文章。 返回 NSOperation我们可以看到内部方法中通过 NSOperation *operation = [NSOperation new]; 创建了一个 NSOperation 实例，然后就直接返回了。没有对这个 NSOperation 做任何其他的处理。唯一使用到的地方就是在 Disk 查询的时候判断是否已经取消。那么为什么要这样做呢？ 因为获取缓存的方法中要根据 config 的不同，对缓存进行同步，或者异步的读取。即要进行 dispatch_sync 和 dispatch_async 的切换。这用一个 NSOperation 不方便完成。但是对于外部来说，外部希望有一个和 download 统一的获取缓存的 NSOperation 实例用于取消。因此，就在内部的 GCD 中加入了 NSOperation 的 cancel，来动态取消执行。 保存相关方法按理说，保存应该放在下载模块，不过 SDWebImage 中将保存放在了 Cache 模块中。因此，也一起说完。 外部调用方法下面就是 Manager 中会调用的缓存方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma mark - 图片存储- (void)callStoreCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context downloadedImage:(nullable UIImage *)downloadedImage downloadedData:(nullable NSData *)downloadedData finished:(BOOL)finished progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; /// 获取存储类型,默认是既存在 Memory 中又存在 disk 中 SDImageCacheType storeCacheType = SDImageCacheTypeAll; if (context[SDWebImageContextStoreCacheType]) &#123; storeCacheType = [context[SDWebImageContextStoreCacheType] integerValue]; &#125; /// 如果图片被 transform 过了，那么这个设置时用来针对原始图像的 SDImageCacheType originalStoreCacheType = SDImageCacheTypeNone; if (context[SDWebImageContextOriginalStoreCacheType]) &#123; originalStoreCacheType = [context[SDWebImageContextOriginalStoreCacheType] integerValue]; &#125; /// 获取自定义的 url → string 的转换器 id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; /// 获取自定义的 transformer id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; id&lt;SDWebImageCacheSerializer&gt; cacheSerializer = context[SDWebImageContextCacheSerializer]; /// 是否要转换 image 取决于 1. 是否下载好了图片 2. 是否有转化器 3. 动图默认不会 transform，但是如果设置了 SDWebImageTransformAnimatedImage 标识位，那么就会转换 BOOL shouldTransformImage = downloadedImage &amp;&amp; (!downloadedImage.sd_isAnimated || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; transformer; /// 是否需要缓存原图 BOOL shouldCacheOriginal = downloadedImage &amp;&amp; finished; /// 如果需要缓存原图 if (shouldCacheOriginal) &#123; /// 获取转换原图的 type SDImageCacheType targetStoreCacheType = shouldTransformImage ? originalStoreCacheType : storeCacheType; /// 如果有自定义的NSData序列化方式 if (cacheSerializer &amp;&amp; (targetStoreCacheType == SDImageCacheTypeDisk || targetStoreCacheType == SDImageCacheTypeAll)) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; NSData *cacheData = [cacheSerializer cacheDataWithImage:downloadedImage originalData:downloadedData imageURL:url]; /// 具体的缓存方式 [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:targetStoreCacheType completion:nil]; &#125; &#125;); /// 没有自定义的序列化方法，直接存储图片 &#125; else &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key cacheType:targetStoreCacheType completion:nil]; &#125; &#125; /// 如果需要对原图进行 transform if (shouldTransformImage) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; /// transform 原图 UIImage *transformedImage = [transformer transformedImageWithImage:downloadedImage forKey:key]; if (transformedImage &amp;&amp; finished) &#123; NSString *transformerKey = [transformer transformerKey]; NSString *cacheKey = SDTransformedKeyForKey(key, transformerKey); BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; NSData *cacheData; // pass nil if the image was transformed, so we can recalculate the data from the image if (cacheSerializer &amp;&amp; (storeCacheType == SDImageCacheTypeDisk || storeCacheType == SDImageCacheTypeAll)) &#123; cacheData = [cacheSerializer cacheDataWithImage:transformedImage originalData:(imageWasTransformed ? nil : downloadedData) imageURL:url]; &#125; else &#123; cacheData = (imageWasTransformed ? nil : downloadedData); &#125; /// 具体的缓存方式 [self.imageCache storeImage:transformedImage imageData:cacheData forKey:cacheKey cacheType:storeCacheType completion:nil]; &#125; [self callCompletionBlockForOperation:operation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125;); &#125; else &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;&#125; 代码有点长，不过注释很清楚。这里的逻辑主要用于处理是否需要缓存原图以及是否需要对原图进行 transform 上。 内部存储方法内部存储方法在 SDImageCache 中： 1234567891011121314151617181920212223242526- (void)storeImage:(UIImage *)image imageData:(NSData *)imageData forKey:(nullable NSString *)key cacheType:(SDImageCacheType)cacheType completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; switch (cacheType) &#123; case SDImageCacheTypeNone: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeMemory: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:NO completion:completionBlock]; &#125; break; case SDImageCacheTypeDisk: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:NO toDisk:YES completion:completionBlock]; &#125; break; case SDImageCacheTypeAll: &#123; [self storeImage:image imageData:imageData forKey:key toMemory:YES toDisk:YES completion:completionBlock]; &#125; break; default: &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125; break; &#125;&#125; Manager 会把下载下来的 image 或者 data 传入。然后根据缓存策略进行内存或者磁盘缓存： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toMemory:(BOOL)toMemory toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled /// 可以保存就保存到 memory 中 if (toMemory &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = image.sd_memoryCost; [self.memoryCache setObject:image forKey:key cost:cost]; &#125; /// 如果可以保存到 disk 中 if (toDisk) &#123; dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if ([SDImageCoderHelper CGImageContainsAlpha:image.CGImage]) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil]; &#125; [self _storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125; 写入磁盘的时候一直使用的是一个串行队列 ，这样防止了多线程情况下可能会产生的 crash： 1_ioQueue = dispatch_queue_create("com.hackemist.SDImageCache", DISPATCH_QUEUE_SERIAL); 总结总的来说，就是通过 SDImageCache 去管理内存缓存 SDMemoryCache 和磁盘缓存 SDDiskCache 缓存部分到此为止。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 源码解析--总览]]></title>
    <url>%2F2018%2F03%2F01%2Fsdwebimage1%2F</url>
    <content type="text"><![CDATA[SDWebImage 是我们最常用的框架之一。它是一个比较庞大的库，但是整体逻辑却非常清晰。套用官方 github 中的一张整体的流程图可以看到： 从图中可以看出我们通过 UIImageView+WebCache 分类提供的方法调用了 UIView+WebCache 中的方法，进而 SDWebImageManager 接管了加载的整个流程。根据不同的策略决定是否从 Cache 中查找，以及是从 Memory Cache 中查找还是从 Disk Cache 中查找。最终走到 SDWebImageDownloader 中下载图片。下载完成还需要对图片进行缓存。这篇我们先简单看一下 SDWebImageManager 之前的调用过程。 UIView+WebCacheUIImageView+WebCache 的入口方法UIImageView+WebCache 是我们最常使用的分类，它提供了 SDWebImage 使用的入口方法。一般我们会使用这个方法： 123- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder &#123; [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];&#125; 这个方法省略了配置参数以及进度和完成回调。它会调用 UIView+WebCache 的相应方法： 123456789101112131415161718- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock &#123; [self sd_internalSetImageWithURL:url placeholderImage:placeholder options:options context:context setImageBlock:nil progress:progressBlock completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, cacheType, imageURL); &#125; &#125;];&#125; UIView+WebCache 入口方法这一段代码有点长，它会创建一个 SDWebImageManager 实例，用来执行下载和缓存操作。代码中有详尽的注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; /// context 其实是一个字典 context = [context copy]; // copy to avoid mutable object /// 获取 Operation 对应的 key NSString *validOperationKey = context[SDWebImageContextSetImageOperationKey]; if (!validOperationKey) &#123; /// 如果 context 中没有指定 Operation 对应的 key，那么就指定为当前的类名 validOperationKey = NSStringFromClass([self class]); &#125; /// 记录下最近的 Opeartion 的 key。为了方便取消最近一次的 Operation self.sd_latestOperationKey = validOperationKey; /// 取消之前 validOperationKey 的下载队列 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; self.sd_imageURL = url; /// 如果没有设置延迟加载占位图，就会先加载占位图 if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; /// 直接设置展位图 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url]; &#125;); &#125; if (url) &#123; // reset the progress NSProgress *imageProgress = objc_getAssociatedObject(self, @selector(sd_imageProgress)); if (imageProgress) &#123; imageProgress.totalUnitCount = 0; imageProgress.completedUnitCount = 0; &#125; /// 开启加载指示器 [self sd_startImageIndicator]; id&lt;SDWebImageIndicator&gt; imageIndicator = self.sd_imageIndicator; /// 下载和缓存的真正执行者 SDWebImageManager *manager = context[SDWebImageContextCustomManager]; if (!manager) &#123; manager = [SDWebImageManager sharedManager]; &#125; /// 更新进度条的回调 block SDImageLoaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123; if (imageProgress) &#123; imageProgress.totalUnitCount = expectedSize; imageProgress.completedUnitCount = receivedSize; &#125;#if SD_UIKIT || SD_MAC if ([imageIndicator respondsToSelector:@selector(updateIndicatorProgress:)]) &#123; double progress = 0; if (expectedSize != 0) &#123; progress = (double)receivedSize / expectedSize; &#125; progress = MAX(MIN(progress, 1), 0); // 0.0 - 1.0 dispatch_async(dispatch_get_main_queue(), ^&#123; [imageIndicator updateIndicatorProgress:progress]; &#125;); &#125;#endif if (progressBlock) &#123; progressBlock(receivedSize, expectedSize, targetURL); &#125; &#125;; @weakify(self); /// manager 执行下载和缓存 id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; @strongify(self); /// operation 执行完成的回调 if (!self) &#123; return; &#125; /// 加载完成停止加载指示 if (finished) &#123; [self sd_stopImageIndicator]; &#125;/// 如果完成了，或者 options 不允许自动将下载好的图片设置进去（需要手动设置），那么就需要调用外部传进来的 completeBlock BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage); /// 有 image，但是不让自动设置，或者没有 image 并且已经加载过占位图了 BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) || (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder))); SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123; if (!self) &#123; return; &#125; /// 可以设置图片的时候 if (!shouldNotSetImage) &#123; [self sd_setNeedsLayout]; &#125; /// 能够调用完成回调 if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123; completedBlock(image, data, error, cacheType, finished, url); &#125; &#125;; /// 无法设置图片，直接调用完成回调 if (shouldNotSetImage) &#123; dispatch_main_async_safe(callCompletedBlockClojure); return; &#125; UIImage *targetImage = nil; NSData *targetData = nil; /// 加载完了，有图片显示图片，没图片看看是否是 SDWebImageDelayPlaceholder。是就表示之前没有显示占位图，那么现在显示展位图 if (image) &#123; // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set targetImage = image; targetData = data; &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123; // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set targetImage = placeholder; targetData = nil; &#125;#if SD_UIKIT || SD_MAC // check whether we should use the image transition SDWebImageTransition *transition = nil; if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123; transition = self.sd_imageTransition; &#125;#endif dispatch_main_async_safe(^&#123;#if SD_UIKIT || SD_MAC [self sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];#endif callCompletedBlockClojure(); &#125;); &#125;]; /// 设置 key 对应的 operation [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; /// URL为空，那么直接报错 [self sd_stopImageIndicator]; dispatch_main_async_safe(^&#123; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;NSLocalizedDescriptionKey : @"Image url is nil"&#125;]; completedBlock(nil, nil, error, SDImageCacheTypeNone, YES, url); &#125; &#125;); &#125;&#125; 代码注释非常详尽，主要做了以下几件事： 准备加载中与加载完成的回调 block 创建 SDWebImageManager 实例，并通过它创建满足 SDWebImageOperation 协议的 operation 将上一步创建的 operation 作为值，默认是当前类名，可通过 options 自定义的字符串作为 key，保存到 SDOperationsDictionary 字典中。 现在还要补充以下几点： SDOperationsDictionary 的作用1typedef NSMapTable&lt;NSString *, id&lt;SDWebImageOperation&gt;&gt; SDOperationsDictionary; 我们看到上面的方法会生成一个 validOperationKey，并且会将 Manager 生成的 Operation 放入通过关联对象保存在每个视图对象中的 SDOperationsDictionary 字典中。那么这个字典存在的意义是什么呢？ 绝大多数情况下，我们不需要这个字典。因为一个 UIView 只会下载并展示一张图。但是还是有特殊情况，比如 UIButton，可以设置不同状态下的图片。那么我们就需要一个字典保存不同状态的 Operation 了。 SDWebImageContext 的作用1typedef NSDictionary&lt;SDWebImageContextOption, id&gt; SDWebImageContext; 一般情况下，我们不会对 SDWebImageContext 做任何操作，直接传入 nil。在上面的方法中： 123456/// 获取 Operation 对应的 keyNSString *validOperationKey = context[SDWebImageContextSetImageOperationKey];if (!validOperationKey) &#123; /// 如果 context 中没有指定 Operation 对应的 key，那么就指定为当前的类名 validOperationKey = NSStringFromClass([self class]);&#125; 拿到字典中的 SDWebImageContextSetImageOperationKey 对应的字符串，作为 SDOperationsDictionary 中 Operation 的键。用来针对同一 UIView 内的多个图片下载的 Operation 做区分。 设置图片的操作在设置图片前我们看下两个状态量的设置： 12345/// 如果完成了，或者 options 不允许自动将下载好的图片设置进去（需要手动设置），那么就需要调用外部传进来的 completeBlockBOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);/// 有 image，但是不让自动设置，或者没有 image 并且已经加载过占位图了BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) || (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder))); 看了注释你可能还是很懵。这是在 Operation 执行完成的回调中进行的。其中 finished 和 image 都是 Operation 的回调返回的。 shouldCallCompletedBlock 通过判断是否是 finished 之后，或者传入的 SDWebImageOptions 是否是禁止自动设置图片。如果是，那么就会调用使用者传入的完成回调。 shouldNotSetImage 分为两种情况，一种是下载好了图片，但是 SDWebImageOptions 不让自动设置图片 SDWebImageAvoidAutoSetImage；或者没有把图片下载下来，并且 SDWebImageOptions 设置为需要延迟加载占位图 SDWebImageDelayPlaceholder。这两种情况会直接调用完成回调，并且直接就返回了。 如果没有问题，那么就走到了设置图片的方法中： 12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)sd_setImage:(UIImage *)image imageData:(NSData *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(NSURL *)imageURL &#123; UIView *view = self; SDSetImageBlock finalSetImageBlock; if (setImageBlock) &#123; /// 如果有自己的设置图片的 block finalSetImageBlock = setImageBlock; &#125; else if ([view isKindOfClass:[UIImageView class]]) &#123; /// 针对 UIImageView 的设置图片的 block UIImageView *imageView = (UIImageView *)view; finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData, SDImageCacheType setCacheType, NSURL *setImageURL) &#123; imageView.image = setImage; &#125;; &#125; else if ([view isKindOfClass:[UIButton class]]) &#123; /// 针对 UIButton 的设置图片的 block UIButton *button = (UIButton *)view; finalSetImageBlock = ^(UIImage *setImage, NSData *setImageData, SDImageCacheType setCacheType, NSURL *setImageURL) &#123; [button setImage:setImage forState:UIControlStateNormal]; &#125;; &#125; /// 如果有自定义的展示动画 if (transition) &#123; [UIView transitionWithView:view duration:0 options:0 animations:^&#123; // 0 duration to let UIKit render placeholder and prepares block if (transition.prepares) &#123; transition.prepares(view, image, imageData, cacheType, imageURL); &#125; &#125; completion:^(BOOL finished) &#123; [UIView transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123; if (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123; finalSetImageBlock(image, imageData, cacheType, imageURL); &#125; if (transition.animations) &#123; transition.animations(view, image); &#125; &#125; completion:transition.completion]; &#125;]; &#125; else &#123; if (finalSetImageBlock) &#123; finalSetImageBlock(image, imageData, cacheType, imageURL); &#125; &#125;&#125; SDWebImageManager入口方法SDWebImageManager 是一个单例的对象。外部调用的方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (SDWebImageCombinedOperation *)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nonnull SDInternalCompletionBlock)completedBlock &#123; if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; // Prevents app crashing on argument type error like sending NSNull instead of NSURL if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; /// 创建一个 Operation 对象，用来保存 Cache Operation 和 Download Operation SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; operation.manager = self; /// 是否是已知的失败的URL BOOL isFailedUrl = NO; if (url) &#123; SD_LOCK(self.failedURLsLock); isFailedUrl = [self.failedURLs containsObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; /// 没有url，或者失败了并且没有让重新下载的情况，直接抛出错误 if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;NSLocalizedDescriptionKey : @"Image url is nil"&#125;] url:url]; return operation; &#125; SD_LOCK(self.runningOperationsLock); /// 把当前下载的 operation 加入到 runingOperations 中 [self.runningOperations addObject:operation]; SD_UNLOCK(self.runningOperationsLock); // Preprocess the options and context arg to decide the final the result for manager /// 存放 options 和 context 的实例。这里可以传入自己的处理对象，来自定义 options SDWebImageOptionsResult *result = [self processedResultForURL:url options:options context:context]; /// 调用缓存方法 [self callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock]; return operation;&#125; 入口方法可说的不多。主要就是判断一下是不是失败的 url，如果不是就走缓存方法。 SDWebImageCombinedOperation从命名上也可以看出来，这是一个复合的 Operation。包含了一个缓存用的 cacheOperation 和一个下载用的 loaderOperation： 123456789101112131415161718@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;/** Cancel the current operation, including cache and loader process */- (void)cancel;/** The cache operation from the image cache query */@property (strong, nonatomic, nullable, readonly) id&lt;SDWebImageOperation&gt; cacheOperation;/** The loader operation from the image loader (such as download operation) */@property (strong, nonatomic, nullable, readonly) id&lt;SDWebImageOperation&gt; loaderOperation;@end 它的 cancel 方法会取消内部的两种 Operation： 1234567891011121314151617- (void)cancel &#123; @synchronized(self) &#123; if (self.isCancelled) &#123; return; &#125; self.cancelled = YES; if (self.cacheOperation) &#123; [self.cacheOperation cancel]; self.cacheOperation = nil; &#125; if (self.loaderOperation) &#123; [self.loaderOperation cancel]; self.loaderOperation = nil; &#125; [self.manager safelyRemoveOperationFromRunning:self]; &#125;&#125; 前面的代码中我们可以看到，最终方法返回的就是 SDWebImageCombinedOperation 的实例。也就是说，前面各个视图实例中通过关联对象方式保存的 SDOpeartionsDictionary 字典中保存的就是 SDWebImageCombinedOperation 实例对象。 不仅如此，SDWebImageCombinedOperation 实例，还被保存在了 SDWebImageManager 的 runningOperations 属性中。它会强引用 operation 实例。当 cancel 时，从 runningOperations 数组中移除的时候，由于 SDOpeartionsDictionary 是弱引用的方式保存的 operation，它就会被自动移除。 也就是说，UIView 实例和 Manager 都会将 Operation 保存起来。UIView 实例是弱引用，在 Manager 中移除的时候会自动清空其对应 Operation SDWebImageOptionsResultSDWebImageOptionResult 将 options 和 context 进行了整合统一。之后的使用过程中就不会出现 options 和 context 了，而是使用 SDWebImageOptionResult 实例： 123456789101112@implementation SDWebImageOptionsResult- (instancetype)initWithOptions:(SDWebImageOptions)options context:(SDWebImageContext *)context &#123; self = [super init]; if (self) &#123; self.options = options; self.context = context; &#125; return self;&#125;@end 执行缓存方法1234567891011121314151617181920212223242526272829303132- (void)callCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(nullable SDWebImageContext *)context progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; /// 校验是否每次只能重新下载，不使用缓存 BOOL shouldQueryCache = !SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly); if (shouldQueryCache) &#123; /// 取出自定义的缓存过滤器，用来通过 url 找到 url 对应的 key 字符串 id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; /// 通过缓存过滤器，根据 url 返回本地用来缓存的 key。如果没有传入缓存过滤器，那么默认为 url 的 absoluteString NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; @weakify(operation); /// 进行缓存相关操作，把返回的 Operation 设置给 CacheOperation operation.cacheOperation = [self.imageCache queryImageForKey:key options:options context:context completion:^(UIImage * _Nullable cachedImage, NSData * _Nullable cachedData, SDImageCacheType cacheType) &#123; @strongify(operation); /// 如果执行过程中操作取消，安全移除操作 if (!operation || operation.isCancelled) &#123; // Image combined operation cancelled by user [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil] url:url]; [self safelyRemoveOperationFromRunning:operation]; return; &#125; /// 前面拿好了缓存，现在就要开始下载 [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock]; &#125;]; &#125; else &#123; /// 不允许缓存直接下载 [self callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:nil cachedData:nil cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock]; &#125;&#125; 透过名字我们就能知道它是执行缓存的方法。能走缓存走缓存，不能走缓存直接走下载。关于缓存的具体实现请看后篇。 执行下载方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879- (void)callDownloadProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context cachedImage:(nullable UIImage *)cachedImage cachedData:(nullable NSData *)cachedData cacheType:(SDImageCacheType)cacheType progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; // Check whether we should download image from network /// 能否下载 BOOL shouldDownload = !SD_OPTIONS_CONTAINS(options, SDWebImageFromCacheOnly); shouldDownload &amp;= (!cachedImage || options &amp; SDWebImageRefreshCached); shouldDownload &amp;= (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]); shouldDownload &amp;= [self.imageLoader canRequestImageForURL:url]; /// 如果必须要下载 if (shouldDownload) &#123; /// 如果 option 的目的是 refreshCached。那么要重新从服务器下载，让 NSURLCache 记录下新的缓存 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; // Pass the cached image to the image loader. The image loader should check whether the remote image is equal to the cached image. SDWebImageMutableContext *mutableContext; if (context) &#123; mutableContext = [context mutableCopy]; &#125; else &#123; mutableContext = [NSMutableDictionary dictionary]; &#125; mutableContext[SDWebImageContextLoaderCachedImage] = cachedImage; context = [mutableContext copy]; &#125; // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle @weakify(operation); /// 下载的 operation operation.loaderOperation = [self.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; @strongify(operation); if (!operation || operation.isCancelled) &#123; // Image combined operation cancelled by user [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:nil] url:url]; &#125; else if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached &amp;&amp; [error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCacheNotModified) &#123; /// 如果只是要刷新缓存，那么不调用回调方法。下载之后就会刷新 NSURLCache 了 &#125; else if ([error.domain isEqualToString:SDWebImageErrorDomain] &amp;&amp; error.code == SDWebImageErrorCancelled) &#123; // Download operation cancelled by user before sending the request, don't block failed URL [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; &#125; else if (error) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock error:error url:url]; BOOL shouldBlockFailedURL = [self shouldBlockFailedURLWithURL:url error:error]; if (shouldBlockFailedURL) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs addObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; SD_LOCK(self.failedURLsLock); [self.failedURLs removeObject:url]; SD_UNLOCK(self.failedURLsLock); &#125; /// 进行图片存储 [self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; /// 如果有缓存的图片 &#125; else if (cachedImage) &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; /// 没有缓存的图片并且也不能下载，直接调用complete 回调 &#125; else &#123; // Image not in cache and download disallowed by delegate [self callCompletionBlockForOperation:operation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125;&#125; 从方法名中也能直观理解他是下载相关方法。在下载成功的回调中，会进行图片的存储。 执行存储方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677- (void)callStoreCacheProcessForOperation:(nonnull SDWebImageCombinedOperation *)operation url:(nonnull NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context downloadedImage:(nullable UIImage *)downloadedImage downloadedData:(nullable NSData *)downloadedData finished:(BOOL)finished progress:(nullable SDImageLoaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; /// 获取存储类型,默认是既存在 Memory 中又存在 disk 中 SDImageCacheType storeCacheType = SDImageCacheTypeAll; if (context[SDWebImageContextStoreCacheType]) &#123; storeCacheType = [context[SDWebImageContextStoreCacheType] integerValue]; &#125; /// 如果图片被 transform 过了，那么这个设置时用来针对原始图像的 SDImageCacheType originalStoreCacheType = SDImageCacheTypeNone; if (context[SDWebImageContextOriginalStoreCacheType]) &#123; originalStoreCacheType = [context[SDWebImageContextOriginalStoreCacheType] integerValue]; &#125; /// 获取自定义的 url → string 的转换器 id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter]; NSString *key = [self cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter]; /// 获取自定义的 transformer id&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer]; id&lt;SDWebImageCacheSerializer&gt; cacheSerializer = context[SDWebImageContextCacheSerializer]; /// 是否要转换 image 取决于 1. 是否下载好了图片 2. 是否有转化器 3. 动图默认不会 transform，但是如果设置了 SDWebImageTransformAnimatedImage 标识位，那么就会转换 BOOL shouldTransformImage = downloadedImage &amp;&amp; (!downloadedImage.sd_isAnimated || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; transformer; /// 是否需要缓存原图 BOOL shouldCacheOriginal = downloadedImage &amp;&amp; finished; /// 如果需要缓存原图 if (shouldCacheOriginal) &#123; /// 获取转换原图的 type SDImageCacheType targetStoreCacheType = shouldTransformImage ? originalStoreCacheType : storeCacheType; /// 如果有自定义的NSData序列化方式 if (cacheSerializer &amp;&amp; (targetStoreCacheType == SDImageCacheTypeDisk || targetStoreCacheType == SDImageCacheTypeAll)) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; NSData *cacheData = [cacheSerializer cacheDataWithImage:downloadedImage originalData:downloadedData imageURL:url]; /// 具体的缓存方式 [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:targetStoreCacheType completion:nil]; &#125; &#125;); /// 没有自定义的序列化方法，直接存储图片 &#125; else &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key cacheType:targetStoreCacheType completion:nil]; &#125; &#125; /// 如果需要对原图进行 transform if (shouldTransformImage) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; /// transform 原图 UIImage *transformedImage = [transformer transformedImageWithImage:downloadedImage forKey:key]; if (transformedImage &amp;&amp; finished) &#123; NSString *transformerKey = [transformer transformerKey]; NSString *cacheKey = SDTransformedKeyForKey(key, transformerKey); BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; NSData *cacheData; // pass nil if the image was transformed, so we can recalculate the data from the image if (cacheSerializer &amp;&amp; (storeCacheType == SDImageCacheTypeDisk || storeCacheType == SDImageCacheTypeAll)) &#123; cacheData = [cacheSerializer cacheDataWithImage:transformedImage originalData:(imageWasTransformed ? nil : downloadedData) imageURL:url]; &#125; else &#123; cacheData = (imageWasTransformed ? nil : downloadedData); &#125; /// 具体的缓存方式 [self.imageCache storeImage:transformedImage imageData:cacheData forKey:cacheKey cacheType:storeCacheType completion:nil]; &#125; [self callCompletionBlockForOperation:operation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125;); &#125; else &#123; [self callCompletionBlockForOperation:operation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;&#125; 存储的方法主要围绕着是否要对图片进行 transform 展开的。在下载好图片之后，可以自定义的将图片进行一些转化，比如我们下载的头像数据，可能会直接切成圆角存储。避免以后每次使用图片都要设置带来的困扰。它是通过 SDImageTransformer 实现的。SDImageTransformer 本身是一个协议。SDWebImage 本身实现了一些，可以通过 context 传入。比如 SDImagePipelineTransformer，SDImageRoundTransformer 等。要注意，transform 之后的图片并不是以原命名保存的，会加上 transformer 提供的后缀，在获取缓存的时候也会在有自定义 transformer 的时候在 key 上加上 transformer 提供的后缀查询。transformer 的种类如下，实际实用过程中是很实用的： SDImageTransformer类型 作用 SDImagePipelineTransformer 可以传入一个NSArray按顺序做转换 SDImageRoundCornerTransformer 添加圆角 SDImageResizingTransformer 调整大小 SDImageCroppingTransformer 剪裁 SDImageFlippingTransformer 翻转 SDImageRotationTransformer 旋转 SDImageTintTransformer 添加色彩 SDImageBlurTransformer 添加模糊 SDImageFilterTransformer 添加滤镜 至此，SDWebImageManager 的 manager 部分就分析完了。后续会有缓存，下载和解码部分。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化的简短总结及 BeeHive 源码解析]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[iOS 模块化组件化是前两年比较流行的话题。当时懒得写相关的东西。现在趁比较有空。对几种方式做一个最最简单的总结。 其实在谈及组件化之前应该先搞清楚一个概念。什么是组件？我认为组件应该可以即插即拔的同类功能集合。它可以在各个项目中使用，并且和业务是不相关或者若相关的。比如网络库、本地存储、基本控件，这些都可以叫做组件。相对的，和业务强相关的功能合集，较难在各个项目中复用的，我更愿意将其归类为模块。 因此，对于我们一般所说的组件化，其实更应该叫模块化。 组件化方式一般来说，组件化的方式有三种： key-block protocol-class target-action key-blockkey-block 是最简单最容易想到的组件化方式。在模块加载的时候以键值对的形式将 key 和 block 注册在一个全局的注册表中。其中 key 通常是一个 URL： 123456789101112// 注册+ (void)load &#123; [[Mediator sharedInstance] registerUrl:@"myapp://gotoregister" withHandler:^(NSDictionary *dic) &#123; RegisterViewController *registerVC = [[RegisterViewController alloc] initWithSomeParam:dic["someParam"]]; [[UIApplication sharedApplication].keyWindow.rootViewController.navigationController pushViewController:registerVC animated:YES]; &#125;];&#125; // 调用+ (void)gotoRegister &#123; [[Mediator sharedInstance] openUrl:@"myapp://gotoregister" withparam:@&#123;@"someParam": 123&#125;];&#125; 主要存在三个问题： 注册的 key 和调用的 key 需要输入多遍，可能出现输入错误或者修改错误，在编译的时候不易察觉。可以使用 define 定义字符串。不过这样虽然可以减少写错的风险，但还是会产生硬编码。 每一个模块间调用的方法都会保存一个 block 实例。当模块很多，或者模块中提供的调用方法很多的时候，会保存大量 block 对象实例。 调用注册方法的时候使用的是 NSDictionary，参数及其类型对于调用者来说是未知的。需要一套文档记录每个方法的参数和类型。 protocol-classprotocol-class 的方式可以说是上面 key-block 的改进，代表框架有阿里出品的 BeeHive。 针对上面的问题1编译的时候无法校验 key 是否写错的问题，可以通过校验 protocol 是否存在，在编译期抛出问题；针对上面的问题2，保存大量 block 实例的问题，使用保存 class 的的形式代替，可以减少大量 block 实例的保存；针对上面的问题3，调用者不知道调用参数和类型的问题，可以在 protocol 中定义方法，让 class 实现，调用者知道 protocol 就可以获取模块间通信的方法，进而知道调用的参数和类型。 1234567891011121314151617181920212223// 协议@protocol RegisterProtocol+ (void)navigateToRegisterVCWithString:(NSString *)str;@end // 实现类@interface RegisterViewController : UIViewController&lt;RegisterProtocl&gt;@end @implementation RegisterViewController+ (void)navigateToRegisterVC &#123; ...具体的实现 &#125;@end// 注册+ (void)load &#123; [[Mediator sharedInstance] registerProtocol:@protocol(RegisterProocol) forInstance:[[self alloc] init]];&#125;// 调用id&lt;RegisterProtocol&gt; registerVC = [[Mediator sharedInstance] instanceForProtocol:@protocol(RegisterProtocol)];[registerVC navigateToRegisterVCWithString:@"someParam"]; 这在 key-block 的基础上已经做了很大的改进。但是仍有改进的空间： 比如调用者直接通过 Mediator 拿到 Class 的实例，再通过实例调用方法。这样相当于调用者和被调用者直接接触，没有办法做统一处理，比如组件不存在时的统一处理。 仍然需要提前注册 针对问题1，可以尝试用一个 wrapper 把 class 再包裹一层做统一处理。不过这样就更麻烦了。没有太大必要。 target -actiontarget-action 通过 runtime 调用被调用的方法，这样可以免去提前注册的问题；同时，将调用的统一处理逻辑放在了 Mediator 中，这样可以解决没法统一处理的问题。 但是所有的处理方法都写在 Mediator 中那 Mediator 就会显得太臃肿了。因此，可以将不同模块的方法写在 Mediator 不同的分类中。 12345678// Mediator@implementation Mediator (RegisterModule)- (void)navigateToRegisterVCWithId:(NSString *)id &#123; Class cls = NSClassFromString(@"RegisterViewController"); UIViewController *registerVC = [cls performSelector:NSSelectorFromString(@"createVCWithId:") withObject:@&#123;@"id":id&#125;]; [self.navigationController pushViewController:registerVC];&#125;@end 这样调用者只需要引入 Mediator+RegisterModule.h 并且执行 [Mediator sharedInstance] navigateToRegisterVCWithId:@&quot;xxx&quot;] 即可完成调用。对于调用者来说，引入了方法头文件后，同样不需要关注参数和类型，也不需要提前注册。同时还可以通过 Mediator 进行统一处理。 但是它在调用被调用者的时候仍然会产生硬编码。不过由于该模块的 Mediator 分类是由被调用者维护的。因此，在被调用方法变化时，被调用者需要维护 Mediator 分类。 BeeHive 源码解析Beehive 是阿里开源的一款基于 protocol-class 方式的组件化方案。它具体的思想已经在上面说明了，这里我们可以对它进行简单的解析。 BeeHive 分为两部分： Module：负责模块的注册以及事件分发 Service：负责模块间的通信以及调用 模块注册Beehive 中的模块是一个实现了 BHModuleProtocol 协议的类，用于管理模块的各个生命周期事件处理。Beehive 中模块注册有三种方式： 加载 plist 中配置静态注册 +load 方法中动态注册 使用注解动态注册 plist 静态注册plist 注册在 AppDelegate 的 application:didFinishLaunchingWithOptions: 方法中进行。模块的注册通过 BHModuleManager 完成。 plist 中 module 的形式如下，包含了 ModuleClass，ModuleLevel,ModulePriority： BHModuleManager 会将 plist 中的各个 ModuleClass 读取保存到 ModuleInfos 数组中，并在其中按照 level 和 priority 排序。随后实例化每一个 module，添加到 BHModules 模块示例数组中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/// 加载本地的 Modules 列表- (void)loadLocalModules&#123; NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@"plist"]; if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123; return; &#125; NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath]; NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey]; NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy; [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]]; &#125;]; [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123; [self.BHModuleInfos addObject:obj]; &#125; &#125;];&#125;// 实例化模块并添加到 BHModules 数组中- (void)registedAllModules&#123; /// 按照优先级对模块列表中的模块排序 [self.BHModuleInfos sortUsingComparator:^NSComparisonResult(NSDictionary *module1, NSDictionary *module2) &#123; NSNumber *module1Level = (NSNumber *)[module1 objectForKey:kModuleInfoLevelKey]; NSNumber *module2Level = (NSNumber *)[module2 objectForKey:kModuleInfoLevelKey]; if (module1Level.integerValue != module2Level.integerValue) &#123; return module1Level.integerValue &gt; module2Level.integerValue; &#125; else &#123; NSNumber *module1Priority = (NSNumber *)[module1 objectForKey:kModuleInfoPriorityKey]; NSNumber *module2Priority = (NSNumber *)[module2 objectForKey:kModuleInfoPriorityKey]; return module1Priority.integerValue &lt; module2Priority.integerValue; &#125; &#125;]; NSMutableArray *tmpArray = [NSMutableArray array]; //module init [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary *module, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSString *classStr = [module objectForKey:kModuleInfoNameKey]; Class moduleClass = NSClassFromString(classStr); BOOL hasInstantiated = ((NSNumber *)[module objectForKey:kModuleInfoHasInstantiatedKey]).boolValue; if (NSStringFromClass(moduleClass) &amp;&amp; !hasInstantiated) &#123; id&lt;BHModuleProtocol&gt; moduleInstance = [[moduleClass alloc] init]; [tmpArray addObject:moduleInstance]; &#125; &#125;]; [self.BHModules removeAllObjects]; /// 把class添加到 BHModules 中 [self.BHModules addObjectsFromArray:tmpArray]; [self registerAllSystemEvents];&#125; +load 方法注册Beehive 为 +load 方法注册添加了一个宏定义。只需要把这个宏定义插入到实现文件中的任意位置即可： 123#define BH_EXPORT_MODULE(isAsync) \+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125; 先不用管这个异步的定义方法。在 +load 方法中直接调用了 registerDynamicModule: 方法注册自己，兜兜转转来到了下面的方法。代码还是非常直接易懂的，和 plist 一样是一个实例化的过程，并且添加到 BHModules 数组中，再按照优先级和 level 排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162- (void)addModuleFromObject:(id)object shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent&#123; Class class; NSString *moduleName = nil; if (object) &#123; class = object; moduleName = NSStringFromClass(class); &#125; else &#123; return ; &#125; ... if ([class conformsToProtocol:@protocol(BHModuleProtocol)]) &#123; NSMutableDictionary *moduleInfo = [NSMutableDictionary dictionary]; BOOL responseBasicLevel = [class instancesRespondToSelector:@selector(basicModuleLevel)]; int levelInt = 1; if (responseBasicLevel) &#123; levelInt = 0; &#125; [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey]; if (moduleName) &#123; [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey]; &#125; [self.BHModuleInfos addObject:moduleInfo]; id&lt;BHModuleProtocol&gt; moduleInstance = [[class alloc] init]; [self.BHModules addObject:moduleInstance]; [moduleInfo setObject:@(YES) forKey:kModuleInfoHasInstantiatedKey]; [self.BHModules sortUsingComparator:^NSComparisonResult(id&lt;BHModuleProtocol&gt; moduleInstance1, id&lt;BHModuleProtocol&gt; moduleInstance2) &#123; NSNumber *module1Level = @(BHModuleNormal); NSNumber *module2Level = @(BHModuleNormal); if ([moduleInstance1 respondsToSelector:@selector(basicModuleLevel)]) &#123; module1Level = @(BHModuleBasic); &#125; if ([moduleInstance2 respondsToSelector:@selector(basicModuleLevel)]) &#123; module2Level = @(BHModuleBasic); &#125; if (module1Level.integerValue != module2Level.integerValue) &#123; return module1Level.integerValue &gt; module2Level.integerValue; &#125; else &#123; NSInteger module1Priority = 0; NSInteger module2Priority = 0; if ([moduleInstance1 respondsToSelector:@selector(modulePriority)]) &#123; module1Priority = [moduleInstance1 modulePriority]; &#125; if ([moduleInstance2 respondsToSelector:@selector(modulePriority)]) &#123; module2Priority = [moduleInstance2 modulePriority]; &#125; return module1Priority &lt; module2Priority; &#125; &#125;]; ... &#125;&#125; 注解注册注解注册是一个比较新奇的东西。它的使用方式如下，在类拓展前通过 @BeehiveMod() 进行注册： 123@BeeHiveMod(ShopModule)@interface ShopModule() &lt;BHModuleProtocol&gt;@end 那么它是如何进行的呢？看宏代码： 1234#define BeeHiveDATA(sectname) __attribute((used, section("__DATA,"#sectname" ")))#define BeeHiveMod(name) \class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = ""#name""; 可以发现，上面的 @BeeHiveMod(ShopModule) 展开后就会变为： 1@class BeeHive; char * kShopModule_mod __attribute((used, section("__DATA,"BeehiveMods"))) = ""ShopModule"" 其中 @class 的提前声明 BeeHive 其实没什么用处，应该只是为了写起来更像注解才这么做的。宏的主要作用是声明了一个全局变量 kShopModule_mod，并且把这个全局变量存到了 Mach-o 的自己创建的 BeehiveMods 段中。 为什么要存到特定的段呢？因为存到特定的段中就能在程序加载的时候找到这个段，然后自行加载注册。具体逻辑在 BHAnnotation 中： 12345/// dyld 加载 lib 后的回调__attribute__((constructor))void initProphet() &#123; _dyld_register_func_for_add_image(dyld_callback);&#125; 上面代码给 dyld 添加回调，在加载完镜像后会执行 dyld_callback 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)&#123; /// 拿到所有的 BeehiveMods 中的 module 名 NSArray *mods = BHReadConfiguration(BeehiveModSectName, mhp); /// 将 module 名注册 for (NSString *modName in mods) &#123; Class cls; if (modName) &#123; cls = NSClassFromString(modName); if (cls) &#123; [[BHModuleManager sharedManager] registerDynamicModule:cls]; &#125; &#125; &#125; ... &#125;NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)&#123; NSMutableArray *configs = [NSMutableArray array]; unsigned long size = 0;#ifndef __LP64__ uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);#else const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp; uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);#endif unsigned long counter = size/sizeof(void*); for(int idx = 0; idx &lt; counter; ++idx)&#123; char *string = (char*)memory[idx]; NSString *str = [NSString stringWithUTF8String:string]; if(!str)continue; BHLog(@"config = %@", str); if(str) [configs addObject:str]; &#125; return configs;&#125; dyld 的回调会把段信息传入，就可以在回调函数中解析得到所有的模块信息，并且动态注册了。 注册事件对于 protocol-class 来说，最重要的是 protocol 和 class 的映射，也就是 Beehive 中 service 的部分。那么为什么还要专门弄出来一个 Module 类呢？为了让模块更抽象，可以监听到外部传来的事件做相应的处理。 因此，在每个模块注册成功的时候还会为每个模块注册事件通知。它的实现方式其实就是一个观察者模式。预先设定了各种可能触发的 event。在注册模块的时候，会遍历所有的 event，在模块中找是否实现了该 event 的方法。对于有 module 实现的 sel，会把 sel 存到 BHSelectorByEvent 中去。再把 module 存到 BHModuleByEvent 字典中 sel 对应的数组中，并把 modules 按照优先级排序。 这样，就可以在任意地方调用方法 [[BHModuleManager sharedManager] triggerEvent:xxxEvent];，触发 event。 给每个模块注册事件，可以很好地减少 AppDelegate 中的代码量，AppDelegate 中的代码被分散到了各个模块中。 为什么要有优先级呢？因为可能存在模块 A，B，A 依赖于 B，但是如果 A 先初始化，那么就会产生问题。 Service 注册与使用Service 负责模块之间的通信。Service 必须要满足 BHServiceProtocol 协议。一般我们会将 ViewController 注册为 Service，当然使用专门的一个 Service 类也是可以的。 Service 的注册和 Module 的注册是类似的。都可以通过 plist 静态注册，动态注册，以及注解注册。这里就不详细说明了。 使用方式如下： 1id&lt;HomeServiceProtocol&gt; homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)]; 通过 createService: 传入 protocol 就可以拿到 service 的实例。调用 HomeServiceProtocol 中声明的方法了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中 va_list 的使用]]></title>
    <url>%2F2017%2F12%2F22%2Fva_list%2F</url>
    <content type="text"><![CDATA[看 FMDB 源码的时候看到了 va_list 的使用。这个东西的主要用途就是不确定个数的入参。一般我们的入参不确定的时候，我们会使用一个 dic 来保存数据，当然简单的方式就是使用本篇要说的这个。FMDB 提供了不确定参数个数的 sql 语句的调用方法。这个功能其实很类似于系统的 NSLog。 使用方式先来看一下 FMDB 的使用场景(略有修改)： 123456789101112131415161718- (BOOL)executeUpdate:(NSString*)sql, ... &#123; va_list args; va_start(args, sql); ... [self getStringWithVAList:(va_list)args]; ... va_end(args); return result;&#125;- (void)getStringWithVAList:(va_list)args &#123; while (index &lt; queryCount) &#123; queryString = va_arg(args, NSString*); index+=1; &#125;&#125; 解释简而言之，va_list 的原理就是：函数的参数是存储在栈中的，因此我们可以通过不停的移动指针，来获取栈中的所有元素。 上面是 FMDB 更新 sql 的执行方法。这个方法先接受一个 sql 字符串，之后是可变的参数。可变参数会在方法中填入 sql 里。 va_list args 其实相当于声明了一个类型为 va_list 名为 args 的变量。 va_start(args, sql) 表示的是取到 sql 后一个参数的地址交给 args。通过这一步后，你就可以将把 args 当做一个变量任意传递了。 va_arg(args, NSString*) 可以获得当前指向的参数，并且将指针移动到后一个参数。指针并不知道要移动多少个字节，所以第二个参数传入一个类型，交代指针的偏移量。所以这里要注意的是，不同的类型偏移量是不同的，所以你必须事先知道每一个可变参数的类型，然后为不同类型设置不同偏移。比如说 FMDB，甚至 NSLog，都需要在第一个参数中为不同类型设置不同的占位符，如 %d,%@。在处理的时候就会从前往后扫描字符串，解析这些占位符，以此获得可变参数的类型。还要注意的是，我们需要自己精确控制循环次数，无限制的 va_arg() 的调用会产生越界。所以综上，va_list 不会知道我们参数的数据类型和个数，这就是为什么我们需要占位符的原因。 va_end(args) 表示清空 args。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB 及其封装框架的实现过程]]></title>
    <url>%2F2017%2F11%2F30%2FFMDB%2F</url>
    <content type="text"><![CDATA[iOS 上的数据库用的不多，看一看主流的 FMDB 以及其封装框架是怎么实现的。 简单SQL检索检索数据检索单个列1select prod_name from products; 检索多个列1select prod_id, prod_name, prod_price from products; 检索所有列1select * from produces 检索的列去重1select distinct prod_name from products; 限制展示个数1select prod_name from products limit 5; 排序检索简单排序1select prod_name from products order by prod_name; 多列排序1select prod_id, prod_name, prod_price from products order by prod_name, prod_id; 指定排序方向1select prod_id, prod_name, prod_price from products order by prod_name desc, prod_id limit 6; 过滤过滤数据where 过滤1select prod_name from products where prod_price = 123; 范围值1select prod_name from products where prod_id between 1 and 100; 空值123select price_id from products where prod_name is null;// 非空值select price_id from products where prod_name is not null; and or 操作符1select prod_price from products where (vend_id = 1003 or vend_id = 1004) and prod_price &gt;= 100; 指定范围1select prod_name from products where vend_id in (1003, 1004); 正则过滤字符包含匹配1select prod_name from products where prod_name regexp '1000'; .匹配任意一个字符： 1select prod_name from products where prod_name regexp '.000'; OR 匹配任意一个条件1select prod_name from products where prod_name regexp '1000|2000|3000'; 匹配几个字符串之一1select prod_name from products where prod_name regexp '[123] Ton'; 1select prod_name from products where prod_name regexp '[1-5a-z] Ton'; ^ 表示否定： 1select prod_name from products where prod_name regexp '[^123] Ton'; 匹配多个实例 元字符 说明 + 1个或多个 ? 0个或一个 * 0个或多个 {n} 指定数目匹配 {n,} 不少于指定数目匹配 {n,m} 匹配数目范围 直接跟在要匹配的字符后面，如果要匹配的是字符串，需要给字符串加上括号 定位符 元字符 说明 ^ 文本开始 $ 文本结束 函数数据聚合对一个列的所有行进行操作，返回一个聚合的值 sum() 求和avg() 求平均值12select sum(prod_price) as sum_price from products;select avg(prod_price) as avg_price from products; count() 求数量1234 // 排除 prod_price 为 null 的select count(prod_price) as num_price from products;// count(*) 表示所有行数select count(*) as all_row from products; min() max()求最小最大12select min(prod_price) as min_price from products;select max(prod_price) as max_price from products; 分组分组的作用是对执行分组，并对结果进行聚合 创建分组获取不同值的 vend_id 并将每个值的数量以 num_prods 字段展示 1select vend_id, count(*) as num_prods from products group by vend_id; 过滤分组having 在数据分组后进行过滤，where 在数据分组前进行过滤 1select vend_id, count(*) as num_prods from products where prod_price &gt;= 10 group by vend_id having count(*) &gt;= 2; 分组和排序在上面的基础上再对某一列排序： 1select vend_id, count(*) as num_prods from products where prod_price &gt;= 10 group by vend_id having count(*) &gt;= 2 order by num_prods; 联结表联结定义检索数据的时候对多张表进行操作。 譬如一个商品表，要记录这个商品的供应商的信息。如果供应商的信息存在这个商品表中，就会存在诸多重复数据。因此，应该讲供应商信息也单独创建一个表。供应商的 ID 为供应商表的主键。商品表只保存这个供应商的 ID，这个供应商的 ID 叫做商品表的外键，供应商表和商品表通过这个外键进行的关联。 创建联结1select vend_name, prod_name, prod_price from vendors, products where vendors.vend_id = products.vend_id order by vend_name, prod_name; 上面从供应商(vendors) 和商品(products)两张表中取 vend_name,prod_name,prod_price 这三列的数据。通过 vend_id 进行关联。 相当于在运行时把两张表通过主键和外键关联，结合成了一张表。 外连接要查询表A中所有满足条件的行，并顺便把表B中的相应行取出来： 1SELECT * FROM player LEFT JOIN team on player.team_id = team.team_id where player.age &lt; 30 从 player 表中把年纪小于 30 的都取出来，并且把 player 对应的 team 的相关信息从 team 表中取出。 on 关键字用于配合 left join，找到 player 相关的 team 增删改插入插入一行123456789insert into customers( cust_name, cust_city, cust_address) values ( 'zachary', 'shanghai', 'minhang'); 插入多个行12345678910111213insert into customers( cust_name, cust_city, cust_address) values ( 'zachary', 'shanghai', 'minhang'), ( 'zachary2', 'shanghai2', 'minhang2'); 插入检索的数据123456789insert into customers( cust_name, cust_city, cust_address) select cust_name, cust_city, cust_address from custnew; 把从 custnew 表中检索出的这几列插入到 customers 中 更新数据1234update customersset cust_name = 'zhang', cust_address = NULLwhere cust_id = 10004; 删除数据12delete from customerswhere cust_id = 1004; 操作表创建表1234567create table customer ( cust_id int not null auto_increment, cust_name char(50) not null, cust_address char(50) default 'shanghai', cust_email char(50), primary key (cust_id)) engine=innodb; 创建表的时候要指定字段，类型； 非空的字段要手动通过 not null 标识； 可以通过 default 指定默认值； 表的主键通过创建表的时候用 primary key 指定，并且主键是必须唯一的，所以可以通过 auto_increment 标识其自增。 最后 engine=innodb 指定引擎。 更新表结构添加列和删除列分别使用 add 和 drop 123alter table vendorsadd vend_phone char(20),drop column vend_num; 删除表1drop table customer2; 数据库基础事务什么是事务？事务就有四大特性：ACID A：原子性 C：一致性 I：隔离性 D：持久性 并发存在异常 脏读：读到了其他事务还没有提交的数据。 不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。 幻读：事务A根据条件查询得到了N条数据，但此时事务B更改或者增加了M条符合事务A查询条件的数据，这样当事务A再次进行查询的时候发现会有N+M条数据，产生了幻读。 数据库设计范式设计数据库模型的时候，需要对内部属性之间的联系的合理化程度进行定义。这种规范叫做范式(NF)。 1NF 指的是数据库表中的任何属性都是原子性的，不可再分。 2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。比如: 123456一张表中的字段如下(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)需要拆分为两行表=&gt;(球员编号) → (姓名，年龄)(比赛编号) → (比赛时间, 比赛场地) 3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。比如： 1234(球员编号) → (姓名，年龄，球队名称，球队教练)=&gt;(球员编号) → (姓名，年龄)(球队名称) → (球队教练) 超键：能唯一标识元组的属性集叫做超键。 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。 FMDB基本结构FMDB 是 sqlite 的简单封装，主要用来执行 sql 语句，并取出数据。主要有三个类： FMDatabase : FMDB 最重要的类，用来保存 database 的实例，并对这个 db 执行 sql 语句。 FMResultSet：保存了 sql 语句的执行结果。 FMDatabaseQueue：在多线程环境下执行 sql。 基本使用建立开启数据库和关闭12345678910111213// 创建数据库NSString* dir = [NSSearchPathForDirectoriesInDomains( NSLibraryDirectory, NSUserDomainMask, YES) lastObject];NSString* dbPath = [dir stringByAppendingPathComponent:@"student.sqlite"];FMDatabase* db = [FMDatabase databaseWithPath:dbPath];//2.获取数据库if ([db open]) &#123; NSLog(@"打开数据库成功");&#125; else &#123; NSLog(@"打开数据库失败");&#125; 当文件不存在时，fmdb 会自己创建一个。 12// 关闭数据库[db close]; 创建删除表123456789101112//3.创建表BOOL result = [db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_student ( id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);"];if (result) &#123; NSLog(@"创建表成功");&#125; else &#123; NSLog(@"创建表失败");&#125; 1234567// 如果表格存在 则销毁BOOL result = [_db executeUpdate:@"drop table if exists t_student"];if (result) &#123; NSLog(@"删除表成功");&#125; else &#123; NSLog(@"删除表失败");&#125; 增删改查增123456789101112131415161718for (int i = 0; i &lt; 4; i++) &#123; //插入数据 NSString * name = [NSString stringWithFormat: @ "测试名字%@", @(mark_student)]; int age = mark_student; NSString * sex = @ "男"; mark_student++; //1.executeUpdate:不确定的参数用？来占位（后面参数必须是oc对象，；代表语句结束） BOOL result = [db executeUpdate: @ "INSERT INTO t_student (name, age, sex) VALUES (?,?,?)", name, @(age), sex]; //2.executeUpdateWithForamat：不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写） // BOOL result = [_db executeUpdateWithFormat:@"insert into t_student (name,age, sex) values (%@,%i,%@)",name,age,sex]; //3.参数是数组的使用方式 // BOOL result = [_db executeUpdate:@"INSERT INTO t_student(name,age,sex) VALUES (?,?,?);" withArgumentsInArray:@[name,@(age),sex]]; if (result) &#123; NSLog(@ "插入成功"); &#125; else &#123; NSLog(@ "插入失败"); &#125;&#125; 通过 executeUpdate 来执行非 select 的增删改语句。另外，有三种方式给 sql 传参： 使用 ? 做占位符，那么传参就必须是 oc 对象。 使用 %@ 等做占位符，传参可以是任意相依类型。 使用数组传参，占位符还是使用 ?，数组中保存的也是 oc 对象。 删改这两个和增加数据没什么不同，因此就放在一起了： 12345678910//1.不确定的参数用？来占位 （后面参数必须是oc对象,需要将int包装成OC对象）int idNum = 11;BOOL result1 = [_db executeUpdate: @ "delete from t_student where id = ?", @(idNum)];//2.不确定的参数用%@，%d等来占位//BOOL result = [_db executeUpdateWithFormat:@"delete from t_student where name = %@",@"王子涵"];if (result1) &#123; NSLog(@ "删除成功");&#125; else &#123; NSLog(@ "删除失败");&#125; 123456789//修改学生的名字NSString * newName = @ "新名字";NSString * oldName = @ "测试名字2";BOOL result2 = [_db executeUpdate: @ "update t_student set name = ? where name = ?", newName, oldName];if (result2) &#123; NSLog(@ "修改成功");&#125; else &#123; NSLog(@ "修改失败");&#125; 查表的查询要通过 executeQuery 执行： 123456789101112//查询整个表FMResultSet * resultSet = [_db executeQuery: @ "select * from t_student"];//根据条件查询//FMResultSet * resultSet = [_db executeQuery:@"select * from t_student where id &lt; ?", @(4)];//遍历结果集合while ([resultSet next]) &#123; int idNum = [resultSet intForColumn: @ "id"]; NSString * name = [resultSet objectForColumn: @ "name"]; int age = [resultSet intForColumn: @ "age"]; NSString * sex = [resultSet objectForColumn: @ "sex"]; NSLog(@ "学号：%@ 姓名：%@ 年龄：%@ 性别：%@", @(idNum), name, @(age), sex);&#125; 查询结果会保存在 FMResultSet 类的实例中。即使操作结果只有一行，也需要先调用 FMResultSet 的next 方法。 FMDB 提供如下多个方法来获取不同类型的数据： 12345678intForColumn:longForColumn:longLongIntForColumn:boolForColumn:doubleForColumn:stringForColumn:dateForColumn:dataForColumn: 当然，一个一个自己获取列名也太麻烦了，可以使用 FMResultSet 提供的 resultDictionary 方法，获取整个字典： 123while ([resultSet next]) &#123; NSDictionary *result = [resultSet resultDictionary];&#125; 在使用 while 循环的时候，不需要手动关闭 FMResultSet，因为 [FMResultSet next] 遍历到最后会调用 [FMResultSet close] 线程安全FMDatabase 本身不是线程安全的，所以不要在多线程中使用。需要使用 FMDatabaseQueue 来帮助保证线程安全： 123456789101112// 创建，最好放在一个单例的类中FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];// 使用[queue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]]; [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]]; [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]]; FMResultSet *rs = [db executeQuery:@"select * from foo"]; while ([rs next]) &#123; // … &#125;&#125;]; 事务在数据库中，事务可以保证数据操作的完整性： 123456789101112131415[_dataBaseQueue inDatabase:^(FMDatabase * _Nonnull db) &#123; [db open]; // 开启事物 [db beginTransaction]; BOOL isDeleteGroupSuccess = [db executeUpdate:@"DELETE FROM grouptable WHERE gcid = ?", groupID]; BOOL isDeleteMembershipSuccess = [db executeUpdate:@"DELETE FROM groupshiptable WHERE gcid = ?", groupID]; if (!isDeleteGroupSuccess || !isDeleteMembershipSuccess) &#123; // 当对两个表的操作中，其中一个失败，数据回滚 [db rollback]; return; &#125; // 提交事物 [db commit]; [db close];&#125;]; 通过beginTransaction 开启一个事务。任意情况下发生错误的时候可以通过 rollback 回退，否则通过 commit 提交事务。 本地调试本地调试可以使用免费的数据库查看工具 ，比如： 源码解析初始化 FMDatabase初始化使用的是 + [FMDatabase databaseWithPath:@&quot;path&quot;] 方法，它会在内部调用 initWithPath: 方法。它其实就是创建了一个 FMDatabase 的实例。 12345678910- (instancetype)initWithPath:(NSString*)aPath &#123; ... self = [super init]; if (self) &#123; _databasePath = [aPath copy]; _openResultSets = [[NSMutableSet alloc] init]; _db = nil; &#125; return self;&#125; 要求输入一个数据库的路径，并保存在 _databasePath 中。这一步里还没有打开 db，所以 _db 还是 nil。 打开 db- [FMDatabase open] 方法打开了 db。 12345678910- (BOOL)open &#123; ... int err = sqlite3_open([self sqlitePath], (sqlite3**)&amp;_db ); if(err != SQLITE_OK) &#123; NSLog(@"error opening!: %d", err); return NO; &#125; ... return YES;&#125; 如果已经打开了就直接返回。否则调用 sqlite 提供的的 sqlite3_open() 方法，打开的数据库。 创建 select sql这一节主要讲如何创建 select 的 sql，select 会从数据库中获取数据，所以需要创建一个专门的类用来拿数据，也就是下面的的 FMResultSet 创建 sqlite3_stmt所有 sql 语句都会被转化为 sqlite3_stmt 类型。由于这一过程比较耗时，所以一般将转化好的 sqlite3_stmt 保存到 _cachedStatements 字典中，以便相同 sql 反复使用： 12345678910111213141516- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123; ... int rc = 0x00; sqlite3_stmt *pStmt = 0x00; FMStatement *statement = 0x00; FMResultSet *rs = 0x00; if (_shouldCacheStatements) &#123; statement = [self cachedStatementForQuery:sql]; pStmt = statement ? [statement statement] : 0x00; [statement reset]; &#125; ...&#125; cachedStatementForQuery: 就是在字典中查找 sql 对应的 sqlite3_stmt 的方法，它返回的 FMStatement 是 sqlite3_stmt 的封装。 绑定参数参数随着方法一起传了进来，一般参数有两种，一种是字典类型的，根据 sql 中的参数名插入，还有一种是数组型的，依次替换 sql 中的占位符。(代码很长，就不贴了) 首先通过 sqlite3_bind_parameter_count() 获得 sql 的参数个数。然后检查传入的是字典还是数组。如果是字典，遍历字典，通过 sqlite3_bind_parameter_index() 拿到键对应的参数索引，然后绑定；如果是数组就依次绑定到对应的列中。绑定也是使用的 sqlite 提供的针对不同类型的一系列绑定方法。 绑定完了后，将这个 sqlite3_stmt 暂存。由于是已经绑定了参数，所以可见前面 sqlite3_reset() 做的就是将参数清空。 SQLite 支持使用占位符 ?，并且在必要的时候绑定参数。所以你不需要把实际的值放入字符串中去。这是一个安全上的考量，它可以守护程序避免 SQL 注入。它也可以帮助你减少必须 escape 值（sql 提供的转义用的命令）这样的不必要的麻烦。 创建 FMResultSet 保存结果现在 sql 已经创建完成，只欠执行了。FMDB 并没有立即执行，而是创建了一个 FMResultSet 对象，用来保存每次 sql 的结果。因为一个 db 可以执行多个 sql，所以就要创建多个 FMResultSet 。所以在创建 sql 的最后，还要创建一个 FMResultSet: 123456789- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray*)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args &#123; ... // the statement gets closed in rs's dealloc or [rs close]; rs = [FMResultSet resultSetWithStatement:statement usingParentDatabase:self]; [rs setQuery:sql]; ...&#125; 执行 sql执行 sql 在 FMResultSet 中进行： 12345- (BOOL)nextWithError:(NSError **)outErr &#123; int rc = sqlite3_step([_statement statement]); ... return (rc == SQLITE_ROW);&#125; 其实上面的关键就是调用 sqlite 的 sqlite3_step() 方法。 获取数据前面执行完 sql 之后，你就可以拿到数据了，FMResultSet 中提供了方法将当前行转化为一个字典： 12345678910111213141516171819202122232425- (NSDictionary*)resultDictionary &#123; NSUInteger num_cols = (NSUInteger)sqlite3_data_count([_statement statement]); if (num_cols &gt; 0) &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithCapacity:num_cols]; int columnCount = sqlite3_column_count([_statement statement]); int columnIdx = 0; for (columnIdx = 0; columnIdx &lt; columnCount; columnIdx++) &#123; NSString *columnName = [NSString stringWithUTF8String:sqlite3_column_name([_statement statement], columnIdx)]; id objectValue = [self objectForColumnIndex:columnIdx]; [dict setObject:objectValue forKey:columnName]; &#125; return dict; &#125; else &#123; NSLog(@"Warning: There seem to be no columns in this set."); &#125; return nil;&#125; 过程就是通过循环，拿出每一列的数据，加入到字典中。当然我们也可以自己获取列数据及列名。 创建 update sqlselect sql 需要配合 FMResultSet，更新数据库内容则比较简单。直接使用 FMDatabase 更新即可。update sql 的代码几乎和 select sql 一模一样，不同的是，更新操作在创建好 sql 后，直接执行 sqlite3_step()，执行完后根据是否要缓存选择性执行重置 sqlite3_reset() 或者关闭 sqlite3_finalize()。代码太长且重复，就不贴了。 加解密FMDB 封装了为 db 加解密的方法。解密使用如下方法，在打开 db 前使用，否则报错： 1234567891011121314151617181920- (BOOL)setKey:(NSString*)key &#123; NSData *keyData = [NSData dataWithBytes:[key UTF8String] length:(NSUInteger)strlen([key UTF8String])]; return [self setKeyWithData:keyData];&#125;- (BOOL)setKeyWithData:(NSData *)keyData &#123;#ifdef SQLITE_HAS_CODEC if (!keyData) &#123; return NO; &#125; int rc = sqlite3_key(_db, [keyData bytes], (int)[keyData length]); return (rc == SQLITE_OK);#else#pragma unused(keyData) return NO;#endif&#125; 其实是一个非常简单的封装，就是将 String 转化为 Data，然后使用 sqlite3_key 进行解密。 有解密必然是要现有加密的，使用 sqlite3_rekey() 方法，可以完成没有密码的时候创建密码，有密码的时候修改密码或者清除密码的操作。代码和解密类似，也不贴了。 关闭数据库关闭数据库，需要做两方面处理，一方面是清除 fmdb 创建的缓存，一方面是释放 sqlite 资源： 123456789101112131415161718192021222324252627282930313233343536- (BOOL)close &#123; [self clearCachedStatements]; [self closeOpenResultSets]; if (!_db) &#123; return YES; &#125; int rc; BOOL retry; BOOL triedFinalizingOpenStatements = NO; do &#123; retry = NO; rc = sqlite3_close(_db); if (SQLITE_BUSY == rc || SQLITE_LOCKED == rc) &#123; if (!triedFinalizingOpenStatements) &#123; triedFinalizingOpenStatements = YES; sqlite3_stmt *pStmt; while ((pStmt = sqlite3_next_stmt(_db, nil)) !=0) &#123; NSLog(@"Closing leaked statement"); sqlite3_finalize(pStmt); retry = YES; &#125; &#125; &#125; else if (SQLITE_OK != rc) &#123; NSLog(@"error closing!: %d", rc); &#125; &#125; while (retry); _db = nil; return YES;&#125; 这里先尝试用 sqlite3_close() 关闭，如果不行，那么再 sqlite3_next_stmt() 来获取每个 stmt，然后将他们 sqlite3_finalize()。整个过程在一个大的 while 循环中，直到数据库关闭为止。 多线程有些费时的更新操作我们不希望在主线程中进行。FMDB 提供了 FMDatabaseQueue 这个类帮助我们创建了后台线程。其实就是封装了子线程的操作，其实你也可以自己创建子线程，然后进行 sql，两者没什么区别。 初始化创建队列创建队列的代码如下： 12345678910111213141516171819202122static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags vfs:(NSString *)vfsName &#123; self = [super init]; if (self != nil) &#123; _db = [[[self class] databaseClass] databaseWithPath:aPath]; FMDBRetain(_db); ... _path = FMDBReturnRetained(aPath); _queue = dispatch_queue_create([[NSString stringWithFormat:@"fmdb.%@", self] UTF8String], NULL); dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL); _openFlags = openFlags; &#125; return self;&#125; 主要分为两步，第一步是创建 db。第二步是创建队列。之后还用 dispatch_queue_set_specific 绑定了 FMDatabaseQueue 对象以及 queue，这个的用处下面再说。 执行 sqlFMDB 为 FMDatabaseQueue 提供了一个方法批量处理某一个 db 的 sql。它接收一个 sql 的 block： 123456789101112131415161718- (void)inDatabase:(void (^)(FMDatabase *db))block &#123; /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue * and then check it against self to make sure we're not about to deadlock. */ FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); assert(currentSyncQueue != self &amp;&amp; "inDatabase: was called reentrantly on the same queue, which would lead to a deadlock"); FMDBRetain(self); dispatch_sync(_queue, ^() &#123; FMDatabase *db = [self database]; block(db); ... &#125;); FMDBRelease(self);&#125; 可以看到，主要就是在之前创建的 queue 中同步执行 sql。那么 dispatch_get_specific 有何用意呢？简单的说就是如果当前队列为 _queue，下面的同步操作就会产生死锁。所以这里 dispatch_get_specific 就是为了验证一下，现在是不是在 _queue 队列中。如果是，那么 currentSyncQueue 就不为空，那么直接通过断言触发异常。 其实这个判断，就是要求使用者不要用在刚刚创建的 _queue 中调用执行 sql 的方法，而是直接在主队列中调用，方法执行的时候会自动将 sql 执行在 _queue 中。 事务处理事务处理的方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block &#123; [self beginTransaction:NO withBlock:block];&#125;- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &#123; FMDBRetain(self); dispatch_sync(_queue, ^() &#123; BOOL shouldRollback = NO; if (useDeferred) &#123; [[self database] beginDeferredTransaction]; &#125; else &#123; [[self database] beginTransaction]; &#125; block([self database], &amp;shouldRollback); if (shouldRollback) &#123; [[self database] rollback]; &#125;else &#123; [[self database] commit]; &#125; &#125;); FMDBRelease(self);&#125;- (BOOL)rollback &#123; BOOL b = [self executeUpdate:@"rollback transaction"]; if (b) &#123; _inTransaction = NO; &#125; return b;&#125;- (BOOL)commit &#123; BOOL b = [self executeUpdate:@"commit transaction"]; if (b) &#123; _inTransaction = NO; &#125; return b;&#125;- (BOOL)beginDeferredTransaction &#123; BOOL b = [self executeUpdate:@"begin deferred transaction"]; if (b) &#123; _inTransaction = YES; &#125; return b;&#125;- (BOOL)beginTransaction &#123; BOOL b = [self executeUpdate:@"begin exclusive transaction"]; if (b) &#123; _inTransaction = YES; &#125; return b;&#125; 事务处理主要还是调用事务的相关 sql 语句，使用者可以通过 sql 是否执行成功，来决定是否需要回滚。 这里 block 的入参使用的是 BOOL *roolback，然后传入一个 BOOL 的地址 &amp;shouldRoolBack，可以实现不用返回值传递数据。注意，这种取地址的写法在使用的时候要用 *shouldRoolBack 来取地址上的值，因为是基本类型的指针： 1234BOOL roolback = YES;BOOL *r = &amp;roolback;*r = NO;NSLog(@"%d，roolback 从1变为了0",roolback); 非基本类型的指针的赋值直接就是 p = Person() 这种地址的赋值就行了，不存在 *p 的情况。基本类型的指针必须通过 *r 拿到堆上的值 *r = No 总结FMDB 的整个过程相对简单，简单来说就是先初始化控制类 FMDatabase，然后通过这个类打开 db，执行 sql，关闭数据库等操作。执行的 sql 需要转化为 sqlite 使用的 sqlite3_stmt 类型，并缓存。对于有结果的 sql，或创建一个 FMResultSet 来保存 sql 已经其相应结果。多线程通过 FMDatabaseQueue 实现，它可以为 sql 开启后台线程执行，并且封装了 sqlite 的原子性操作的语句来实现事务。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift 的一些原理解析]]></title>
    <url>%2F2017%2F11%2F14%2FRxSwift%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前面两篇讲了 RxSwift 以及 RxCocoa 的使用，这篇探究下 RxSwift 的实现原理。 这篇将从四个方面探究 RxSwift 的实现原理。包括 ： rx 的命名空间如何产生的 如何创建 Observable 以及订阅 Subject 是如何实现的 如何实现调用 delegate 方法的 rx 的命名空间如何产生我们都知道，RxCocoa 为我们的基本控件添加了 rx 的命名空间，然后定义了 rx 相关的属性。那么这是怎么做到的呢？ 我们点进 rx 的定义： 1234567891011/// A type that has reactive extensions.public protocol ReactiveCompatible &#123; /// Extended type associatedtype CompatibleType /// Reactive extensions. static var rx: Reactive&lt;CompatibleType&gt;.Type &#123; get set &#125; /// Reactive extensions. var rx: Reactive&lt;CompatibleType&gt; &#123; get set &#125;&#125; 可以看到，rx 是定义在这个叫 ReactiveCompatible 的协议中的。rx 是 Reactive 类型。在协议拓展中，实现了这个协议的默认实现，即返回 Reactive 类型，或者返回该类型实例。其中，它将上面的关联类型 associatedtype，设置为调用者自身： 123456789101112131415161718192021extension ReactiveCompatible &#123; /// Reactive extensions. public static var rx: Reactive&lt;Self&gt;.Type &#123; get &#123; return Reactive&lt;Self&gt;.self &#125; set &#123; // this enables using Reactive to "mutate" base type &#125; &#125; /// Reactive extensions. public var rx: Reactive&lt;Self&gt; &#123; get &#123; return Reactive(self) &#125; set &#123; // this enables using Reactive to "mutate" base object &#125; &#125;&#125; 接着看 Reactive 的定义，它是一个结构体，接受一个泛型参数。这个结构体很简单，只有一个泛型类型的属性 base。上面方法在创建 Reactive 实例的时候，将调用者设置为其 base 属性，比如调用 button.rx，那么就会将 button 实例设置为其 base： 1234567891011public struct Reactive&lt;Base&gt; &#123; /// Base object to extend. public let base: Base /// Creates extensions with base object. /// /// - parameter base: Base object. public init(_ base: Base) &#123; self.base = base &#125;&#125; 因为所有的控件都是继承于 NSObject，所以要让所有控件都拥有 rx 这个属性，只需要让 NSObject 实现 ReactiveCompatible 即可： 12/// Extend NSObject with `rx` proxy.extension NSObject: ReactiveCompatible &#123; &#125; 这样，rx 就和基本控件关联了起来。但是 Reactive 这个结构体这么简单，它是怎么拓展出这么多 rx 属性的呢？我们以 UIButton 为例。打开 RxCocoa 中的 UIButton+Rx.swift，这是一个对于 button 的 rx 拓展： 1234567extension Reactive where Base: UIButton &#123; /// Reactive wrapper for `TouchUpInside` control event. public var tap: ControlEvent&lt;Void&gt; &#123; return controlEvent(.touchUpInside) &#125;&#125; 这里通过模式匹配 where 将泛型 Base 限制为 UIButton，为 UIButton 添加特定的属性。这里只列举一个 tap 属性，其实还有一个 title 方法。我们先不管这个 ControlEvent 是啥，这个后面会讲。至此，控件就获得了 rx 相关的属性了。 总之，整个过程就是，通过让 NSObject 实现一个协议，使控件获得 rx 属性，然后在 rx 类型的 extension 中，以模式匹配的方式为不同控件的 rx 添加相应的属性。过程如图所示： 如何创建 Observable 以及订阅概述我们知道通过 create，just，of 等方法可以创建一个 Observable。那么这是如何做到的呢？我们以 create 创建的订阅为例。这一创建及订阅过程还是比较复杂的，涉及的类以及相互关系很多。所以我先把所有相关类的关系图展示出来： 整个过程涉及四个部分：Observable，Observer，Sink，Disposer。 Observable 主要就是保存了事件队列；Observer 主要保存了事件队列的处理方法；Sink 连接前两者，由它来让 Observer 响应 Observable 的事件；Disposer 保存了 Sink 的实例，以便回收。 创建首先我们来看 step 1，调用的 create 方法存在于 Observable 的一个拓展中，包含了各种 Observable 的创建方法。create 方法创建了一个匿名的 Observable AnonymousObservable，并将包含各种事件的闭包传入： 12345extension Observable &#123; public static func create(_ subscribe: @escaping (AnyObserver&lt;E&gt;) -&gt; Disposable) -&gt; Observable&lt;E&gt; &#123; return AnonymousObservable(subscribe) &#125;&#125; 来到 step 2， AnonymousObservable 初始化的过程很简单，就是将传入的包含事件的闭包保存起来。另外该类还提供了一个重写的 run 方法： 123456789101112131415final class AnonymousObservable&lt;Element&gt; : Producer&lt;Element&gt; &#123; typealias SubscribeHandler = (AnyObserver&lt;Element&gt;) -&gt; Disposable let _subscribeHandler: SubscribeHandler init(_ subscribeHandler: @escaping SubscribeHandler) &#123; _subscribeHandler = subscribeHandler &#125; override func run&lt;O : ObserverType&gt;(_ observer: O, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) where O.E == Element &#123; let sink = AnonymousObservableSink(observer: observer, cancel: cancel) let subscription = sink.run(self) return (sink: sink, subscription: subscription) &#125;&#125; 到这里，创建 Observable 的过程就结束了。简单来说就是内部创建了一个匿名的 Observable，然后将事件闭包保存。下面是订阅过程。 订阅来到 step 3，订阅的时候，我们调用的是 ObservableType 提供的订阅方法。ObservableType 是一个协议，由 Observable 实现。这个方法中创建了一个匿名的 Observer AnonymousObserver，也就是 step 4，把事件处理方法的闭包传入。然后就是观察者订阅事件队列，即 step 5： 12345678910111213extension ObservableType &#123; public func subscribe(_ on: @escaping (Event&lt;E&gt;) -&gt; Void) -&gt; Disposable &#123; let observer = AnonymousObserver &#123; e in on(e) &#125; return self.subscribeSafe(observer) &#125; fileprivate func subscribeSafe&lt;O: ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E &#123; return self.asObservable().subscribe(observer) &#125;&#125; step 5 的方法中，调用的是入参为 Observer 的 subscribe 方法。在 Observable 类中定义了该方法。不过这个方法并没有具体实现，它要求其子类实现。否则就会抛出异常： 1234567891011public class Observable&lt;Element&gt; : ObservableType &#123; /// Type of elements in sequence. public typealias E = Element ... public func subscribe&lt;O: ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E &#123; abstractMethod() &#125; ... &#125; Observable 在本例的子类是 AnonymousObservable，不过不是直接子类，这两个类中还夹着一个 Producer 类。所以订阅的过程 step 6 在 Producer 中： 12345678910111213141516171819202122232425class Producer&lt;Element&gt; : Observable&lt;Element&gt; &#123; override func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == Element &#123; if !CurrentThreadScheduler.isScheduleRequired &#123; // The returned disposable needs to release all references once it was disposed. let disposer = SinkDisposer() let sinkAndSubscription = run(observer, cancel: disposer) disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription) return disposer &#125; else &#123; return CurrentThreadScheduler.instance.schedule(()) &#123; _ in let disposer = SinkDisposer() let sinkAndSubscription = self.run(observer, cancel: disposer) disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription) return disposer &#125; &#125; &#125; func run&lt;O : ObserverType&gt;(_ observer: O, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) where O.E == Element &#123; abstractMethod() &#125;&#125; step 6 的方法先创建了一个 SinkDisposer，即 step 7。要留意这个 SinkDisposer，因为最后我们加入 disposebag 的，就是这个 disposer 实例。 下一步调用 run 方法。我们看到上面的代码中，run 方法也是一个类似的抽象方法。那么 step 8 中，我们就要到它的子类 AnonymousObservable 中找，这个上面也提到过。 执行来看一下这个 run 方法的实现。它接受刚才创建的匿名 Observer AnonymousObserver，以及 SinkDisposer： 12345678final class AnonymousObservable&lt;Element&gt; : Producer&lt;Element&gt; &#123; ... override func run&lt;O : ObserverType&gt;(_ observer: O, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) where O.E == Element &#123; let sink = AnonymousObservableSink(observer: observer, cancel: cancel) let subscription = sink.run(self) return (sink: sink, subscription: subscription) &#125;&#125; 第一步 step 9，创建了一个 AnonymousObservableSink 实例。这个 AnonymousObservableSink 即实现了 ObserverType 协议，又实现了 Disposable 协议，所以它既是一个 Observer，又是一个 Disposer。在它的初始化方法中，调用了父类 Sink 的初始化方法，也就是 step 10： 1234567891011class Sink&lt;O : ObserverType&gt; : Disposable &#123; fileprivate let _observer: O fileprivate let _cancel: Cancelable fileprivate var _disposed: Bool init(observer: O, cancel: Cancelable) &#123; _observer = observer _cancel = cancel _disposed = false &#125;&#125; 无关代码删除后，可以看到，Sink 中包含了 Observer，也包含了最终的 Disposer 实例。 回到 step 8，在创建完 AnonymousSink 后，调用其 run 方法，并将返回值赋给 subscription。我们来看一下 step 11，这个 run 方法做了什么： 1234567891011121314151617181920212223final class AnonymousObservableSink&lt;O: ObserverType&gt; : Sink&lt;O&gt;, ObserverType &#123; typealias E = O.E typealias Parent = AnonymousObservable&lt;E&gt; func on(_ event: Event&lt;E&gt;) &#123; switch event &#123; case .next: if _isStopped == 1 &#123; return &#125; forwardOn(event) case .error, .completed: if AtomicCompareAndSwap(0, 1, &amp;_isStopped) &#123; forwardOn(event) dispose() &#125; &#125; &#125; func run(_ parent: Parent) -&gt; Disposable &#123; return parent._subscribeHandler(AnyObserver(self)) &#125;&#125; 这个方法中总算执行了之前保存在 AnonymousObservable 对象中的事件闭包。我们可以会奇怪为什么它要用 AnyObserver(self) 来代替之前创建的 AnonymousObserver，这是为了擦除类型，反正现在需要的就是一个有事件响应方法的 Observer。 执行事件闭包发出事件，也就是调用 Observer 相应的响应方法。AnyObserver 稍微做了个转换，响应方法调用的是上面 AnonymousObservableSink 的 on 方法。这一步是 step 12。 在 on 方法中，将事件进行转发，来到 step 13， sink 中的 forwardOn 中： 123456789class Sink&lt;O : ObserverType&gt; : Disposable &#123; ... final func forwardOn(_ event: Event&lt;O.E&gt;) &#123; if _disposed &#123; return &#125; _observer.on(event) &#125;&#125; 这里的 _observer 应该很熟悉，就是刚才保存的 AnonymousObserver。不过 AnonymousObserver 这个类很简陋，并没有 on 方法啊： 123456789101112131415161718192021222324final class AnonymousObserver&lt;ElementType&gt; : ObserverBase&lt;ElementType&gt; &#123; typealias Element = ElementType typealias EventHandler = (Event&lt;Element&gt;) -&gt; Void private let _eventHandler : EventHandler init(_ eventHandler: @escaping EventHandler) &#123;#if TRACE_RESOURCES let _ = Resources.incrementTotal()#endif _eventHandler = eventHandler &#125; override func onCore(_ event: Event&lt;Element&gt;) &#123; return _eventHandler(event) &#125; #if TRACE_RESOURCES deinit &#123; let _ = Resources.decrementTotal() &#125;#endif&#125; 到父类 ObserverBase 中查看： 12345678910111213141516171819202122232425class ObserverBase&lt;ElementType&gt; : Disposable, ObserverType &#123; typealias E = ElementType private var _isStopped: AtomicInt = 0 func on(_ event: Event&lt;E&gt;) &#123; switch event &#123; case .next: if _isStopped == 0 &#123; onCore(event) &#125; case .error, .completed: if !AtomicCompareAndSwap(0, 1, &amp;_isStopped) &#123; return &#125; onCore(event) &#125; &#125; func onCore(_ event: Event&lt;E&gt;) &#123; abstractMethod() &#125;&#125; ObserverBase 的 on 中，最终还是走了子类的 onCore。我的天，这一通折腾。处理完事件，最终返回给前面的 subscription 的就是在事件队列中创建的 Disposer。 回收现在事件都已经处理完了，回到 step 6，继续往下走，执行 step 16： 12345678910111213141516171819202122fileprivate final class SinkDisposer: Cancelable &#123; private var _state: AtomicInt = 0 private var _sink: Disposable? = nil private var _subscription: Disposable? = nil func setSinkAndSubscription(sink: Disposable, subscription: Disposable) &#123; _sink = sink _subscription = subscription let previousState = AtomicOr(DisposeState.sinkAndSubscriptionSet.rawValue, &amp;_state) if (previousState &amp; DisposeStateInt32.sinkAndSubscriptionSet.rawValue) != 0 &#123; rxFatalError("Sink and subscription were already set") &#125; if (previousState &amp; DisposeStateInt32.disposed.rawValue) != 0 &#123; sink.dispose() subscription.dispose() _sink = nil _subscription = nil &#125; &#125;&#125; 它把 AnonymousObservableSink 以及 subscription 保存了起来。也就是说最终返回的 SinkDisposer 中会包含两个 Disposer。如果执行了 dispose()，那么这两个 Disposer 都会执行各自的 dispose()，并且释放。这样就是为什么我们在 subscribeHandle 中随便创建的一个 Disposer，也能起作用的原因。 SinkDisposer 引用了 AnonymousObservableSink 以及 subscription。AnonymousObservableSink 引用了 SinkDisposer 以及 AnonymousObserver。这是一个引用循环，为的是各自调用各自的 dispose() 的时候，都能触发对方的 dispose() ，将对方也回收。 其实在没看源码前大概的想法也是，在 Observable 内部创建保存一个不被外界知道的 Observer，进行事件处理。实际上呢是添加了一个 Sink 类转梦用来保存 Observer，并且进行处理。 明白了 Disposer 的引用关系，也就明白了如何将订阅回收的了。另外，将 Sink 设计成 Disposable 也使得回收更加方便 Subject 的创建与订阅Subject 是 hot observable，和上面的区别在于，可以自己定义事件触发的时机。那么这个不同是如何体现出来的呢？下面来瞧瞧 Variable 的原理。 VariableVariable 是 BehaviorSubject 的封装。来看一下 Variable 中的属性： 12345678910111213public final class Variable&lt;Element&gt; &#123; public typealias E = Element private let _subject: BehaviorSubject&lt;Element&gt; private var _lock = SpinLock() // state private var _value: E ...&#125; 可以看到，很简单，一个 BehaviorSubject，一个同步锁，以及一个 value 属性。Variable 和 BehaviorSubject 相比，唯一的不同就是 Variable 有一个 value 属性， 并在其 set 方法中，自动触发了 next 事件。 现在看一下初始化方法，以及 value 的 get set 方法： 1234567891011121314151617181920212223242526272829303132public final class Variable&lt;Element&gt; &#123; ... /// Gets or sets current value of variable. /// /// Whenever a new value is set, all the observers are notified of the change. /// /// Even if the newly set value is same as the old value, observers are still notified for change. public var value: E &#123; get &#123; _lock.lock(); defer &#123; _lock.unlock() &#125; return _value &#125; set(newValue) &#123; _lock.lock() _value = newValue _lock.unlock() _subject.on(.next(newValue)) &#125; &#125; /// Initializes variable with initial value. /// /// - parameter value: Initial variable value. public init(_ value: Element) &#123; _value = value _subject = BehaviorSubject(value: value) &#125; ...&#125; init 方法就是初始化了一个 BehaviorSubject 以及设置了 value 的初始值。value 的 setter 方法就是更新了 value 值，然后触发了 BehaviorSubject 的事件。 这里学习一个加锁解锁的方法，在 getter 方法中通过 defer 在 return 之后执行解锁操作。 好了这就是 Variable 的全部了。由于 Variable 并不是继承于 Observable，所以你甚至都不能订阅，只能通过 asObservable 方法，返回其中的 BehaviorSubject 属性。下面来看下 BehaviorSubject 是如何实现的。 BehaviorSubject我们使用 BehaviorSubject 进行订阅的时候，一开始的步骤还是一样的：Observable 先创建一个 AnonymousObserver，将事件处理方法设置给它的 eventHandler 属性。所有的 Observable 订阅，都会进行这样的方法，我们可以将这部分成为订阅的公共部分。 然后到上面的 step 5 开始有区别了。在 create 中，由于继承关系调用的是 Producer 的 subscribe；而 BehaviorSubject 中也实现了自己的 subscribe 方法，我们可以称这部分为订阅的私有部分(这两个名字都是我随便起的)。 在 Producer 的订阅私有部分，进行的是 step7 以及 step 8，也就是创建一个 SinkDisposer 和执行 run 方法(执行事件闭包中的事件)，这也就是 create 能够自己发出事件的原因。BehaviorSubject 的订阅私有部分做的是将刚创建的 AnonymousObserver 保存起来，然后以当前 value 值作为事件值，发出一个事件，这就是 BehaviorSubject 订阅就会触发事件的原因。 下面来看代码，首先看看 BehaviorSubject 的属性: 123456789101112131415161718192021222324252627282930public final class BehaviorSubject&lt;Element&gt; : Observable&lt;Element&gt; , SubjectType , ObserverType , SynchronizedUnsubscribeType , Disposable &#123; public typealias SubjectObserverType = BehaviorSubject&lt;Element&gt; typealias DisposeKey = Bag&lt;AnyObserver&lt;Element&gt;&gt;.KeyType /// Indicates whether the subject has any observers public var hasObservers: Bool &#123; _lock.lock() let value = _observers.count &gt; 0 _lock.unlock() return value &#125; let _lock = RecursiveLock() // state private var _isDisposed = false private var _value: Element private var _observers = Bag&lt;(Event&lt;Element&gt;) -&gt; ()&gt;() private var _stoppedEvent: Event&lt;Element&gt;? /// Indicates whether the subject has been disposed. public var isDisposed: Bool &#123; return _isDisposed &#125;&#125; BehaviorSubject 的属性就这么多，基本上看到都是能一眼看明白的。_observers 就是创建的 AnonymousObserver，它的类型 Bag 是一个字典的封装，它可以为不同的 AnonymousObserver 提供不同的键，这样能在取消订阅的时候便于回收响应 AnonymousObserver。另外，_stoppedEvent 也是需要解释一下的，就是在 completed 以及 error 事件发生后，保存这个 event，以后当有其他事件触发的时候，发出的是这个 event 的事件。 接下来看一下订阅的私有部分的相关代码： 123456789101112131415161718192021222324252627/// Subscribes an observer to the subject.////// - parameter observer: Observer to subscribe to the subject./// - returns: Disposable object that can be used to unsubscribe the observer from the subject.public override func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == Element &#123; _lock.lock() let subscription = _synchronized_subscribe(observer) _lock.unlock() return subscription&#125;func _synchronized_subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E == E &#123; if _isDisposed &#123; observer.on(.error(RxError.disposed(object: self))) return Disposables.create() &#125; if let stoppedEvent = _stoppedEvent &#123; observer.on(stoppedEvent) return Disposables.create() &#125; let key = _observers.insert(observer.on) observer.on(.next(_value)) return SubscriptionDisposable(owner: self, key: key)&#125; 需要把这部分加上锁，防止在将 Observer 加入字典的时候，产生错误。然后就像上面讲的一样，先看看有没有 stoppedEvent，有的话执行该 event，没有的话，将 Observer 加入字典，然后触发这个 Observer 的事件。 最后，返回了一个 SubscriptionDisposable，它是一个非常简单的结构体。保存了 self，防止 BehaviorSubject 回收，保存了key，用于回收对应的 Observer。 on 方法是因为 BehaviorSubject 也实现了 ObserverType 协议，再看一下 on 做了什么： 1234567891011121314151617181920212223/// Notifies all subscribed observers about next event.////// - parameter event: Event to send to the observers.public func on(_ event: Event&lt;E&gt;) &#123; _lock.lock() dispatch(_synchronized_on(event), event) _lock.unlock()&#125;func _synchronized_on(_ event: Event&lt;E&gt;) -&gt; Bag&lt;(Event&lt;Element&gt;) -&gt; ()&gt; &#123; if _stoppedEvent != nil || _isDisposed &#123; return Bag() &#125; switch event &#123; case .next(let value): _value = value case .error, .completed: _stoppedEvent = event &#125; return _observers&#125; 同样的也是将这个过程锁上，避免在执行的时候，新的 Observer 被加入字典中，导致新的 Observer 也响应事件。这里的 dispatch 方法主要就是通过一个 for 循环，将 _observers 中的每个 Observer 都触发 event 事件。下面同步的 on 方法也就不多解释了。 这就是 BehaviorSubject 的大致实现过程。 其实 Subject 就是典型的观察者模式。create 把类大概分成了四个部分。Subject 则结合了 Observable 和 Sink 做的事情。它在内部为每个观察者创建了匿名的 Observer 并保存，然后可以自行调用 onNext 调用这些 Observer 的事件处理方法。将创建事件队列和执行事件队列放在了一起。 代理转发前面的文章说到，会详细叙述一下代理转发的流程，那么现在来看一看这方面的源码。我们在 RxCocoa 中找一个需要实现代理的控件类，看一下它的解决方式。比如 UITabBarController。 控件的 rx 拓展关于代理转发需要我们创建的只有两个类，一个是 UITabBarController 的 rx 拓展类，一个是 UITabBarControllerDelegate 的实现类 DelegateProxy。先来看一下 UITabBarController 的 rx 拓展类： 123456789101112131415161718extension Reactive where Base: UITabBarController &#123; /// Reactive wrapper for `delegate`. /// /// For more information take a look at `DelegateProxyType` protocol documentation. public var delegate: DelegateProxy &#123; return RxTabBarControllerDelegateProxy.proxyForObject(base) &#125; /// Reactive wrapper for `delegate` message `tabBarController:didSelect:`. public var didSelect: ControlEvent&lt;UIViewController&gt; &#123; let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didSelect:))) .map &#123; a in return try castOrThrow(UIViewController.self, a[1]) &#125; return ControlEvent(events: source) &#125;&#125; 我们可以看到，这个类中先定义了一个 DelegateProxy 类型的 delegate，这就是上面所说的 UITabBarControllerDelegate 的实现类。另外定义了一个 didSelect 属性，它的类型是 ControlEvent，其实就是一个 Observable。我们知道 UITabBarControllerDelegate 中有一个代理方法就是 didSelect，所以这里定义的 Observable 其实就是用来替代传统的代理方法的。 delegate 是一个只读属性，它只是调用了 DelegateProxy 的 proxyForObject 方法。DelegateProxy 的继承关系比较复杂，我们先看一下关系图： 强调一下，delegate 是 rx 命名空间下的，不会影响到控件本生的 delegate 属性。 替换代理类可以看到 proxyForObject 是 DelegateProxyType 协议中的方法，它在协议的拓展中提供了默认的实现： 123456789101112131415161718192021222324252627public static func proxyForObject(_ object: AnyObject) -&gt; Self &#123; MainScheduler.ensureExecutingOnScheduler() let maybeProxy = Self.assignedProxyFor(object) as? Self let proxy: Self if let existingProxy = maybeProxy &#123; proxy = existingProxy &#125; else &#123; proxy = Self.createProxyForObject(object) as! Self Self.assignProxy(proxy, toObject: object) assert(Self.assignedProxyFor(object) === proxy) &#125; let currentDelegate: AnyObject? = Self.currentDelegateFor(object) if currentDelegate !== proxy &#123; proxy.setForwardToDelegate(currentDelegate, retainDelegate: false) assert(proxy.forwardToDelegate() === currentDelegate) Self.setCurrentDelegate(proxy, toObject: object) assert(Self.currentDelegateFor(object) === proxy) assert(proxy.forwardToDelegate() === currentDelegate) &#125; return proxy&#125; 创建 proxy首先通过 assignedPorxyFor 这个类方法方法，获取指定控件(object)的 DelegateProxy 的实例。这个方法在 DelegateProxyType 协议中定义，在 DelegateType 中实现： 1234open class func assignedProxyFor(_ object: AnyObject) -&gt; AnyObject? &#123; let maybeDelegate = objc_getAssociatedObject(object, self.delegateAssociatedObjectTag()) return castOptionalOrFatalError(maybeDelegate.map &#123; $0 as AnyObject &#125;)&#125; 它通过关联对象的方式，从指定控件中取出。如果这个 proxy 存在，就说明之前已经设置过了，如果没有，那么通过 createProxyForObject 方法创建。这个创建方法同样是在 DelegateProxyType 中定义，在 DelegateProxy 中实现。它做的很简单，就是实例化自身： 123open class func createProxyForObject(_ object: AnyObject) -&gt; AnyObject &#123; return self.init(parentObject: object)&#125; 然后就是将自身与控件关联。总的来说，上面就是要创建一个 DelegateProxy，然后保存为相应控件的属性的一个属性。 获取当前代理对象接下来通过 currentDelegateFor 获取当前控件的实际代理类。这个方法是需要自己在 DelegtateProxy 子类中实现的，因为虽然用做代理，但是可能叫法不同，比如 tableView 的数据源代理就叫做 dataSource。TabBarController 的 DelegateProxy 中仅有的两个方法就是取出和设置自身的代理： 1234567891011121314151617public class RxTabBarControllerDelegateProxy : DelegateProxy , UITabBarControllerDelegate , DelegateProxyType &#123; /// For more information take a look at `DelegateProxyType`. public class func currentDelegateFor(_ object: AnyObject) -&gt; AnyObject? &#123; let tabBarController: UITabBarController = castOrFatalError(object) return tabBarController.delegate &#125; /// For more information take a look at `DelegateProxyType`. public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) &#123; let tabBarController: UITabBarController = castOrFatalError(object) tabBarController.delegate = castOptionalOrFatalError(delegate) &#125;&#125; 就是说，上面代码中的 delegate 在一些情况下，可能不叫 delegate，所以没法写成一个公共的方法，必须要每个 DelegateProxy 都自己根据情况实现。 用 proxy 替换代理对象拿到当前的代理对象后，通过一个 if 判断当前代理对象是否是上面得到的 proxy。如果是，说明之前已经设置过了，直接将 proxy 返回即可；如果不是，那就要用 proxy 将代理对象替换掉。这个过程由 setForwardToDelegate 方法完成，实现还是在 DelegateProxy 中： 123open func setForwardToDelegate(_ delegate: AnyObject?, retainDelegate: Bool) &#123; self._setForward(toDelegate: delegate, retainDelegate: retainDelegate)&#125; 看到这个带下划线的方法，应该能猜到，这就是调用的 OC 的方法了。在 _RXDelegateProxy 这个 OC 类中，定义了一个 __forwardToDelegate 属性。这个属性是弱引用的，它用来保存正真的代理对象： 123456789-(void)_setForwardToDelegate:(id __nullable)forwardToDelegate retainDelegate:(BOOL)retainDelegate &#123; __forwardToDelegate = forwardToDelegate; if (retainDelegate) &#123; self.strongForwardDelegate = forwardToDelegate; &#125; else &#123; self.strongForwardDelegate = nil; &#125;&#125; 我们可以看到有一个 Bool 类型的 retainDelegate 入参。它来决定是否将弱引用变成强引用，不过一般情况，我们并不需要强引用。总之，将原本的代理对象安顿好了之后，就通过 setCurrentDelegate 将 proxy 设置为代理对象，并且返回了。 获取方法的 Observable回到我们看过的控件的 rx 拓展中，前面说到 didSelect 这个计算属性，返回一个 Observable，拦截代理方法的工作也是由它自己完成的： 12345678public var didSelect: ControlEvent&lt;UIViewController&gt; &#123; let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didSelect:))) .map &#123; a in return try castOrThrow(UIViewController.self, a[1]) &#125; return ControlEvent(events: source)&#125; 这里的主要方法就是这个 methodInvoked，它在 DelegateProxy 中。（另外插一句，这里的 a 代表的是代理方法的各个入参，a[0] 表示该 tabBarController，a[1] 表示的就是 didSelect: 对应的入参。）我们继续看下去： 1234567891011121314open func methodInvoked(_ selector: Selector) -&gt; Observable&lt;[Any]&gt; &#123; checkSelectorIsObservable(selector) let subject = methodInvokedForSelector[selector] if let subject = subject &#123; return subject &#125; else &#123; let subject = PublishSubject&lt;[Any]&gt;() methodInvokedForSelector[selector] = subject return subject &#125;&#125; 首先通过 checkSelectorIsObservable 检查方法是否已通过非 rx 的代理方式实现了。这个方法不是太重要。之后从 methodInvokedForSelector 中取出 selector 对应的 subject 对象。这个属性是一个字典，以 selector 为键，以 subject 为值。如果存在 subject 就说明，已经创建了 selector 对应的 Observable 对象了，直接返回即可；如果没有，那么就创建一个 PublishSubject，并且将其存入 methodInvokedForSelecotr 字典中去，最后返回这个 subject。我们就可以使用这个 subject 来进行订阅了。 所以获取方法的 Observable 的过程就是从一个字典中取出方法对应 Observable 的过程。 拦截方法那么调用代理方法的过程是如何转变为触发事件的呢？这里就要用到 OC runtime 中的消息转发。在 _RXDelegateProxy 中实现了消息转发的方法 forwardInvocation。我们将 DelegateProxy 设置为代理类，但是我们一直没有实现代理方法。所以系统企图调用代理方法的时候发现没有代理方法，就执行消息转发的方法： 12345678910111213141516-(void)forwardInvocation:(NSInvocation *)anInvocation &#123; BOOL isVoid = RX_is_method_signature_void(anInvocation.methodSignature); NSArray *arguments = nil; if (isVoid) &#123; arguments = RX_extract_arguments(anInvocation); [self _sentMessage:anInvocation.selector withArguments:arguments]; &#125; if (self._forwardToDelegate &amp;&amp; [self._forwardToDelegate respondsToSelector:anInvocation.selector]) &#123; [anInvocation invokeWithTarget:self._forwardToDelegate]; &#125; if (isVoid) &#123; [self _methodInvoked:anInvocation.selector withArguments:arguments]; &#125;&#125; 首先检查一下代理方法是不是有返回值。为什么要检查这个呢？因为我们订阅 Observable 的处理方法是不会有返回值的，但是一般的代理方法不同，代理方法有一些是要返回处理完的数据的。对于有返回值的代理方法，我们是无法以 Observable 的方式订阅的，只能老老实实的写回调方法。 下面是三个 if 判断。中间的 if 我们看到了熟悉的 _forwardToDelegate 属性。我们也说过了，这个属性是用来临时保存原本正真的代理对象的。这个 if 的作用就是，检查一下正真的代理对象有没有实现这个 selector，如果有，那么执行。这样的好处就是既不影响原本代理方法的执行，又能给我们提供用 Observable 处理的余地。 上下两个 if 判断就都是用来触发事件的。一上一下分别在正真的代理方法执行前后触发。前文中，我们有通过 methodInvoked 方法获取 selector 对应的 Observable，其实还有一个 sendMessage 方法也起着一样的作用，原理也是相同的。是不是很像 AOP。 _methodInvoked 方法将代理方法的参数作为事件值触发事件： 123open override func _methodInvoked(_ selector: Selector, withArguments arguments: [Any]) &#123; methodInvokedForSelector[selector]?.on(.next(arguments))&#125; 如何获得触发事件的入口？答案就是通过消息转发。所有没有实现的代理方法走消息转发，达到统一触发事件的目的。 另一种替换代理类的方式前面替换代理类的方式是 proxyForObject方法，它会把该 Object 的 delegate 替换为 DelegateProxy，把原本的 delegate 对象设置为 DelegateProxy 的 forwardDelegate 属性。 除此之外，还有一个替换代理的方法： 123456789101112131415161718192021222324252627282930public static func installForwardDelegate(_ forwardDelegate: AnyObject, retainDelegate: Bool, onProxyForObject object: AnyObject) -&gt; Disposable &#123; weak var weakForwardDelegate: AnyObject? = forwardDelegate let proxy = Self.proxyForObject(object) assert(proxy.forwardToDelegate() === nil, "This is a feature to warn you that there is already a delegate (or data source) set somewhere previously. The action you are trying to perform will clear that delegate (data source) and that means that some of your features that depend on that delegate (data source) being set will likely stop working.\n" + "If you are ok with this, try to set delegate (data source) to `nil` in front of this operation.\n" + " This is the source object value: \(object)\n" + " This this the original delegate (data source) value: \(proxy.forwardToDelegate()!)\n" + "Hint: Maybe delegate was already set in xib or storyboard and now it's being overwritten in code.\n") proxy.setForwardToDelegate(forwardDelegate, retainDelegate: retainDelegate) // refresh properties after delegate is set // some views like UITableView cache `respondsToSelector` Self.setCurrentDelegate(nil, toObject: object) Self.setCurrentDelegate(proxy, toObject: object) assert(proxy.forwardToDelegate() === forwardDelegate, "Setting of delegate failed:\ncurrent:\n\(String(describing: proxy.forwardToDelegate()))\nexpected:\n\(forwardDelegate)") return Disposables.create &#123; MainScheduler.ensureExecutingOnScheduler() let delegate: AnyObject? = weakForwardDelegate assert(delegate == nil || proxy.forwardToDelegate() === delegate, "Delegate was changed from time it was first set. Current \(String(describing: proxy.forwardToDelegate())), and it should have been \(proxy)") proxy.setForwardToDelegate(nil, retainDelegate: retainDelegate) &#125;&#125; 这个方法会直接让你传入 forwardDelegate，并且你要是之前设置过 delegate，它还不高兴了。所以这个方法最好在你没有设置代理的时候用。该方法中也调用了 proxyForObject。除此之外，这个方法返回一个 Disposer，并在 dispose 的时候，将 forwardDelegate 正式设置为 delegate。因此，用这种方式的话，你需要将其放入 disposableBag 中。这样的功效就是如果 DelegateProxy 回收了，那么 forwardDelegate 就顺势升值了。 其实这也就是 Disposer 给我们带来的便利。我们不需要再 dealloc 的时候做设置了，直接全部扔到 disposableBag 中去。 整个过程就是，我们通过 proxyForObject 将 delegate 设置为 DelegateProxy。DelegateProxy 为每一个无返回值的代理方法都创建了 subject。我们通过 DelegateProxy 提供的 methodInvoked 获取这些 subject，并订阅。不在 DelegateProxy 中实现这些代理方法，使其触发消息转发。消息转发中统一执行方法，获取 selector 的 subject，并触发事件。 我们需要做的是： 在 rx 拓展中，添加一个只读的代理属性(不一定叫做 delegate)。读取方法中调用相应 DelegateProxy 的 proxyForObject 并返回。 在 rx 拓展中，添加只读的属性。读取方法中调用 DelegateProxy 的 methodInvoked 获取相应 selector 的 subject 在相应 DelegateProxy 中添加 currentDelegateFor 和 setCurrentDelegate 方法，返回，设置类的原始代理属性(不一定是 delegate)。 在相应 DelegateProxy 中添加返回值非空的代理方法的实现。 不想在写了，累的兔血，暂时就这样吧。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxCocoa 的应用]]></title>
    <url>%2F2017%2F11%2F03%2FRxCocoa%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[继续 RxSwift 的学习。这章的难度明显大了许多，很多东西，你知道要这么用没有用，你得知道为什么要这么用，这就需要阅读源码了。本文还是按照书中的章节进行。知其所以然会在后面的文章中补全。 使用 RxCocoa 的应用开始使用 RxCocoa这一章节主要是一个例子。讲的是如何通过 Rx 将天气信息展示出来。 初印象打开 UITextField+Rx.swift，其中只有一个类型为 ControlProperty&lt;String?&gt; 的 text 属性： ControlProperty 是一个特殊的 subject，前面也提到过了，和 UI 控件交互的属性都是 subject 类型的。更具体一点，Rxcocoa 中，和 UI 交互的属性都是 ControlProperty 类型。 再打开 UILabel+Rx.swift，它的两个属性都是 UIBindingObserver 类型： UIBindingObserver 是一个 Observer。它就是在 Subject 与 Observer 一节中提到的特殊的 Observer。它有一个 binding 属性，用来保存默认的事件处理方法，在初始化的时候设置。 前面也提到过，这种 Observer，没有自定义的事件处理方法，所以只能做诸如设置 UILabel 的 text 等无须 UI 交互的事。 使用 RxCocoa 的 UIKitApiController.swift 用来提供数据，在其中定义了一个方法 currentWeather(city:)，用来提供默认的天气数据： 12345678func currentWeather(city: String) -&gt; Observable&lt;Weather&gt; &#123; return Observable.just( Weather( cityName: city, temperature: 20, humidity: 90) )&#125; 这个方法接受一个参数：城市city，返回一个只有一个元素的 Observable，事件值类型为天气Weather类型。 接下来就可以在 ViewController 中订阅了。在 viewDidLoad 中设置: 1234567ApiController.shared.currentWeather(city: "Shanghai") .observeOn(MainScheduler.instance) .subscribe( onNext: &#123; data in self.tempLabel.text = "\(data.temperature)°C" self.cityNameLabel.text = data.cityName self.humidityLabel.text = "\(data.humidity)%" &#125;).addDisposableTo(bag) 其中 shared 用来获取单例，observeOn(MainScheduler.instance) 用来将操作限制在主线程中，因为这是在操作 UI。 那么如何获取到 city 的呢？我们可以有一个 textfield searchCityName 用来接受用户的输入。RxCocoa 通过协议拓展的方式为大多数 UIKit 的成员都添加了 rx 的相关属性。比如 textfield，我们可以输入 searchCityName.rx. 就可以查看到很多可以使用的 Rx 相关的属性和方法。这里我们要使用的是 textfield 的 text 属性： 12345678910let search = searchCityName.rx.text .filter &#123; ($0 ?? "").characters.count &gt; 0&#125; .flatMapLatest &#123; text in return ApiController.shared.currentWeather(city: text ?? "Error") .catchErrorJustReturn(ApiController.Weather.empty) &#125;.observeOn(MainScheduler.instance)// 订阅search.subscribe( ... ).addDisposableTo(bag) 这段代码做了什么，这段代码将 textfield 的输入框和处理逻辑绑定了起来，输入框一有输入，那么就触发事件。先将空输入过滤掉，然后将 textfield 中输入的值通过 flatMapLatest 再转换为新的 Observable，即 city 转 Weather 的过程。其中如果 currentWeather 的转换产生了错误，就通过 catchErrorJustReturn 使用默认的事件值，空 Weather。 通过这个例子，可以再复习一下 flatMapLatest 和 flatMap 的区别。这个例子中 flatMapLatest 和 flatMap 是一样的，因为 currentWeather 返回的 Observable 只有一个元素，所以只订阅最后的 Observable 和 订阅每一个 Observable 没有区别，因为 Observable 不会再有事件发生了。但是，如果这里 currentWeather 是一个异步的操作，比如去网上拉取数据，那就必须使用 flatMapLatest 了。试想一下，在上一个网络请求还没有完成的时候，输入变化，这样又触发了一次网络请求。使用 flatMap 就会在每一次网络请求结束时都做响应，但这个并不符合逻辑，应该只响应最后一次网络请求，否则会产生请求覆盖。所以一定要用 flatMapLatest。 以上的数据流程如图所示： 绑定 Observable绑定是一种单向的数据流。RxCocoa 中的绑定通过 bindTo(_:) 实现。被绑定的对象的类型必须是 ObserverType，也就是 Observer 对象。 书上这个地方我认为是有问题的，书上的原话是： The fundamental function of binding is bindTo(_:). To bind an observable to another entity, the receiver must conform to ObserverType. This entity has been explained in previous chapters: it’s a Subject which can process values, but can also be written to manually. 书上说 ObserverType 就是一种 Subject，这样说是没有道理的。Subject 的范围要比 ObserverType 大，Subject 可以被订阅，提供自定义事件处理方法，但是 bindTo() 并不需要，它只需要有一个默认的事件处理方法即可。所以我认为书上这么说至少是不严谨的。 bindTo(_:) 是一种特殊的 subscribe，也是在 Observable 触发事件的时候，调用 Observer 的事件处理方法。但是原本需要在 subscribe 的时候传入的事件处理方法现在要求被绑定的 Observer 自己提供。所以像 UIBindingObserver 这样有默认事件处理方法的 Observer 或者一个已经被订阅过的 Subject 都是可以作为绑定对象的。 12345678910let search = searchCityName.rx.text .filter &#123; ($0 ?? "").characters.count &gt; 0&#125; .flatMapLatest &#123; text in return ApiController.shared.currentWeather(city: text ?? "Error") .catchErrorJustReturn(ApiController.Weather.empty) &#125;.observeOn(MainScheduler.instance)// 绑定search.map &#123;"\($0.temperature)°C"&#125; .bindTo(tempLabel.rx.text) .addDisposableTo(bag) 看到上面的代码，通过一个 map 将整个 Weather 对象剥离出来，只要其中的 temperature 属性。然后将其绑定给 tempLabel.rx.text 这个 Observer（这种通过 map 取出部分属性再进行绑定是一个很好的方式）。这就是前面说到的 UIBindingObserver 类型，它提供了一个默认的事件处理方法，将外部传来的字符串，设置为自己的 text 属性。 使用 UnitsUnits 是一类专门用来使 UI 绑定更简单的 Observables。它不会产生异常，并且默认在主线程中。它有以下两大类： ControlProperty 和 ControlEvent Driver ControlProperty 前面已经看到过了，是一种 Subject，用来将 UI 组件和数据绑定，例子中的 searchCityName.rx.text 就是一个 ControlProperty。ControlEvent 从命名上也能推测出，它用来监听 UIControlEvents。Drivers就是刚才说的不会产生异常，并且一定在主线程中的 Observable。如果不使用 Units，你可能会忘记调用 .observeOn(MainScheduler.instance)，最终在其他线程中更新 UI 导致崩溃。 123456789let search = searchCityName.rx.text .filter &#123; ($0 ?? "").characters.count &gt; 0&#125; .flatMapLatest &#123; text in return ApiController.shared.currentWeather(city: text ?? "Error") &#125;.asDriver(onErrorJustReturn: ApiController.Weather.empty)search.map &#123; "\($0/temerature)°C" &#125; .drive(tempLabel.rx.text) .addDisposableTo(bag) 可以看到，使用 asDriver(onErrorJustReturn:) 代替了 observeOn(MainSchedule.instance)。另外，用 drive 代替了 bindTo。 我们现在绑定了一个 textfield，在每次其输入的时候都做了响应，这样其实是没有必要的。一般可以使用 throttle 操作符，这个是用来控制每隔多久发送一次事件的。还有更好的方法是监听用户点击返回按钮，当点击的时候获取搜索框中的输入。需要对上面的代码做一些变化： 123456let search = searchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable() .map &#123; self.searchCityName.text &#125; .filter &#123; ($0 ?? "").characters.count &gt; 0&#125; .flatMapLatest &#123; text in return ApiController.shared.currentWeather(city: text ?? "Error") &#125;.asDriver(onErrorJustReturn: ApiController.Weather.empty) 所以现在的数据流图变成了： 进一步拓展上一章中，完成了一个输入城市，然后显示城市天气的功能。这一章将对其进行拓展。 加载等待状态首先是给加载天气这个过程中加载一个等待的菊花图。这个菊花图的展示与否有两个条件：用户点击搜索时加载，获取到搜索结果后隐藏。点击搜索和获取搜索结果的 Observable 分别定义为如下： 123456789let searchInput = searchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable() .map &#123; self.searchCityName.text &#125; .filter &#123; ($0 ?? "").characters.count &gt; 0&#125;let search = searchInput.flatMapLatest &#123; text in return ApiController.shared.currentWeather(city: text ?? "Error") .catchErrorJustReturn(ApiController.Weather.dummy)&#125;.asDriver(onErrorJustReturn: ApiController.Weather.dummy) 什么时候满足这两个条件？当 searchInput 事件发生的时候显示，当 search 事件发生的时候隐藏。所以我们的等待状态需要分别订阅这两个 Observable。但是这样的做法并不优雅，上一篇我们学过如何合并两个 Observable 的事件了，就是用 merge: 12345678910111213let running = Observable.from([ searchInput.map &#123; _ in true&#125;.asObservable(), search.map &#123; _ in false&#125;.asObservable()]).merge().startWith(true).asDriver(onErrorJustReturn: false)running.skip(1) .drive(activityIndicator.rx.isAnimating) .addDisposableTo(bag)running.drive(tempLabel.rx.isHidden) .addDisposableTo(bag) 上面的代码可以看到，每当 searchInput 触发的时候，发出一个事件值为 true 的事件，当 search 触发的时候，发出一个事件值为 false 的事件。但是为什么要设置第一个事件为 true，又略过第一个事件呢？因为展示的 label 的 isHidden 属性和等待状态的 isAnumating 是相反的，即展示 label 的时候隐藏等待状态，展示等待状态的时候隐藏 label。但是最开始的时候既要 label 隐藏，又要等待状态隐藏，所以要略过第一个事件值。 获取当前位置这一章主要讲的是如何用 RxSwift 实现一个代理方法，要理解起来挺有难度的，这里先只是讲步骤，后面会转门写一篇代理转发的源码解析。 获取位置使用的是 CCLocationManager 类，这个类有一个代理 CLLocationManagerDelegate。我们需要做的就是在 CCLocationManager 回调代理方法的时候触发事件，将回调的参数作为事件值。 怎么做到的呢？这里不做详细展开，只介绍一下大概思路。简单来说，就是首先将我们创建的基于 Rx 的代理设置为 CCLocationManager 的 delegate。其次，由于我们不是没有写真实的响应方法嘛，当 CCLocationManager 要调用代理方法的时候一般是会产生异常的。但是我们可以通过消息转发，将所有调用代理方法的行为转化为发出特定事件。我们只需要通过方法名获取到相应的 Observable 并且订阅，即可达到响应式的效果。 因此，我们创建一个基于 rx 的代理类 RxCLLocationManagerDelegateProxy。这个 Delegate 要继承于 DelegateProxy，并且实现 CLLocationManagerDelegate 和 DelegateProxyType 协议。实现 CLLocationManagerDelegate 协议很好理解，因为我们要把自己设为 CLLocationManager 的代理。另外两个就是实现响应式的关键了： 12class RxCLLocationManagerDelegateProxy: DelegateProxy, CLLocationManager, DelegateProxyType &#123;&#125; 我们要提供两个方法用来设置和获取当前 Delegate。这是 DelegateProxyType中要求的，有了它，订阅回调方法的时候，就可以由 Rx 自动把当前类设置为 Delegate 了，而不需要我们显示的设置： 1234567891011class RxCLLocationManagerDelegateProxy: DelegateProxy, CLLocationManager, DelegateProxyType &#123; class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) &#123; let locationManager: CLLocationManager = object as! CLLocationManager locationManager.delegate = delegate as? CLLocationManagerDelegate &#125; class func currentDelegateFor(_ object: AnyObject) -&gt; AnyObject? &#123; let locationManager: CLLocationManager = object as! CLLocationManager return locationManager.delegate &#125;&#125; 现在我们要 CLLocationManager 添加一个 rx 的 delegate 属性。关于 rx 的属性都是添加在 Reactive 类的拓展中，具体为什么会在以后的文章中解释。这是一个计算属性，每次都会调用 proxyForObject 方法。这个方法是在 DelegateProxy 中实现的，作用就是创建 RxCLLocationManagerDelegateProxy 实例，并且将其设置为 CLLocationManager 的代理 12345extension Reactive where Base: CLLocationManager &#123; var delegate: DelegateProxy &#123; return RxCLLocationManagerDelegateProxy.proxyForObject(base) &#125;&#125; 现在设置到代理就可以添加监听代理方法调用的 Observable 了： 123456789101112extension Reactive where Base: CLLocationManager &#123; var delegate: DelegateProxy &#123; return RxCLLocationManagerDelegateProxy.proxyForObject(base) &#125; var didUpdateLocations: Observable&lt;[CLLocation]&gt; &#123; return delegate.methodInvoked(#selector(CLLocationManagerDelegate.locationManager(_:didUpdateLocations:))) .map &#123; paramters in return parameters[1] as! [CLLocation] &#125; &#125;&#125; methodInvoked 方法同样是 DelegateProxy 中实现的方法。它获取相应 selector 所对应的 Observable。这个 selector 和 Observable 的关系是以字典的方式保存在 DelegateProxy 中的。当调用代理方法的时候，就会变为触发相应 selector 的 Observable。Observable 的事件值就是代理方法的参数，上面的 parameters[1] 就表示 didUpdateLocations: 的参数。 到此，rx 实现的代理方法就完成了。 最后如何监听按钮开始定位我就不再赘述了。 中级 RxSwift/RxCocoa错误处理错误处理部分比较简单，一般有两种方式：捕获或者重试。 捕获捕获有两种，一种是直接传递一个默认值，也就是前面常见的: 1func catchErrorJustReturn(_ element:) -&gt; RxSwift.Observable&lt;Self.E&gt; 它会自动将这个默认值作为事件值发出一个新的事件。另外还有一种，接受一个闭包，然后返回一个新的 Observable： 1func catchError(_ handler:) -&gt; RxSwift.Observable&lt;Self.E&gt; 示例： 1234567.catchError &#123; error in if let text = text, let cachedData = self.cache[text] &#123; return Observable.just(cachedData) &#125; else &#123; return Observable.just(ApiController.Weather.empty) &#125;&#125; 重试重试就是在 Observable 触发 error 的时候，重新尝试发出事件。使用方式很简单，在捕获错误前即可，参数为做大尝试次数： 12345678910111213return ApiController.shared.currentWeather(city: text ?? "Error") .do(onNext: &#123; data in if let text = text &#123; self.cache[text] = data &#125; &#125;).retry(3) .catchError &#123; error in if let text = text, let cachedData = self.cache[text] &#123; return Observable.just(cachedData) &#125; else &#123; return Observable.just(ApiController.Weather.empty) &#125; &#125; 还有一种 retryWhen() 方法： 12345678.retryWhen &#123; e in return e.flatMapWithIndex &#123; (error, attempt) -&gt; Observable&lt;Int&gt; in if attempt &gt;= maxAttempts - 1 &#123; return Observable.error(error) &#125; return Observable&lt;Int&gt;.timer(Double(attempt + 1), scheduler: MainScheduler.instance).take(1) &#125; &#125; 这个方法中，在未达到最多尝试次数前都不报错。每隔一秒钟重试一次。 单元测试RxSwift 的官方提供了 RxTest 和 RxBlocking 两个库帮助我们进行单元测试。下面来学习一下。 RxTestRxSwift 的单元测试的主要过程就是：自建一个 Observable，然后给定几个默认的值，以检测订阅方法的正确性。 Observable 主要分为 Cold Observable 和 Hot Observable。Rx 认为，这两者都是 Observable，所以并不怎么做区分。但是单元测试的时候还是需要了解一下的。简单的说，通过 create 等创建的普通的 Observable 就是 Cold Observable，特点就是当订阅发生的时候立刻发出事件；各种 Subject 就是 Hot Observable，特点就是无论是否订阅都会发出事件，订阅之后才能收到事件。 我们来看一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546override func setUp() &#123; super.setUp() scheduler = TestScheduler(initialClock: 0)&#125;func testFilter() &#123; // 1 let observer = scheduler.createObserver(Int.self) // 2 let observable = scheduler.createHotObservable([ next(100, 1), next(200, 2), next(300, 3), next(400, 2), next(500, 1) ]) // 3 let filterObservable = observable.filter &#123; $0 &lt; 3 &#125; // 4 schedyler.scheduleAt(0) &#123; self.subscription = filterObservable.subscribe(observer) &#125; // 5 scheduler.start() // 6 let results = observer.events.map &#123; $0.value.element@ &#125; // 7 XCTAssertEqual(results, [1, 2, 2, 3])&#125;override func tearDown() &#123; scheduler.scheduleAt(1000) &#123; self.subsciprtion.dispose() &#125; super.tearDown()&#125; 下面来解释一下这个例子。首先在 setUp 方法中，创建了 TestScheduler 实例。所有的订阅事件都会在这个 Scheduler 中进行。然后就是测试方法。测试方法分为七个步骤： 用 Scheduler 创建 Observer，并且设置 Observable 事件值类型 用 Scheduler 创建 Hot Observable，并且设置了延迟多久发出事件，以及发出的事件值 这一步的过滤就是被测试的方法 用 Scheduler 在某个时刻开始订阅上面创建的 Observable 开启 Scheduler，不开启是不会有事件发生的哦 用一个对象收集 Observer 获得的事件值 断言判断 Observer 获得的事件值是否和预期的一样 RxBlocking上面的 RxTest 是一个同步测试。如果有网络请求之类的异步事件该如何呢？我们可以使用 XCTest 中提供的 expectation，不过这样就显得很啰嗦了。RxBlocking 可以简化这一过程。下面是一个使用实例： 123456789func testRgbIs010() &#123; let rgbObservable = viewModel.rgb.asObservable().subscribeOn(scheduler) viewModel.hexString.value = "#00ff00" let result = try! rgbObservable.toBlocking(timeout: 1.0).first()! XCTAssertEqual(0 * 255, result.0) XCTAssertEqual(1 * 255, result.1) XCTAssertEqual(0 * 255, result.2)&#125; 看一下这个例子，这里 rgb 是一个 Driver 类型，我没有把它的定义写出来。rgbObservable 是一个异步事件的 Observable。如果不适用 toBlocking()，那么程序顺序执行，订阅完了也就结束了。但是这里通过对 Observable 使用 toBlocking 方法，就将 Observable 阻塞住了。它会等待事件的到来，直到定时结束。 Scheduler 的介绍对 Scheduler 的通常误解是认为 Scheduler 就是 thread。其实 Scheduler 应该类比 dispatch queue。一个 Schelduler 可能在多个线程中，多个 Scheduler 也可能在一个线程中： 基本使用我们可以通过 subscribeOn() 以及 observerOn() 来将订阅和执行设置不同 scheduler： 12345678let globalScheduler = ConcurrentDispatchQueueScheduler(queue: DispatchQueue.global())observable.subscribeOn(globalScheduler) .subsribeOn(gloibalScheduler) .dump() .observeOn(MainScheduler.instance) .dumpingSubscription() .addDisposableTo(bag) 冷热Observable 对 Schedulers 的影响这里主要介绍了一个注意点，就是对于 hot Observable，它订阅所在的线程就是其发出事件所在的线程，所以使用 subscribeOn() 方法控制是无效的。 自定义 Rx 拓展这里是一个拓展 URLSession，使其通过 rx 获取数据以及处理数据的例子： 12345678910111213141516171819202122232425262728293031323334353637extensiong Reactive where Base: URLSession &#123; func response(request: URLRequest) -&gt; Observable&lt;(HTTPURLResponse, Data)&gt; &#123; return Observable.create &#123; observer in let tast = self.base.dataTask(with: request) &#123; (data, response, error) in guard let response = response, let data = data else &#123; observer.on(.error(error ?? RxURLSessionError.unKnown)) return &#125; guard let httpResponse = response as? HTTPURLResponse else &#123; observer.on(.error(RxURLSessionError.invalidResponse(response: response))) return &#125; observer.on(.next(httpResponse, data)) observer.on(.completed) &#125; task.resume() return Disponsables.create(with: task.cancel) &#125; &#125; func data(request: URLRequest) -&gt; Observable&lt;Data&gt; &#123; return response(requset: request).map &#123; (response, data) -&gt; Data in if 200 ..&lt; 300 ~= response.statusCode &#123; return data &#125; else &#123; throw RxURLSessionError.requestFailed(response: response, data: data) &#125; &#125; &#125; func image(request: URLResquest) -&gt; Observable&lt;UIImage&gt; &#123; return data(request: request).map &#123; d in return UIImage(data: d) ?? UIImage() &#125; &#125;&#125; 以上就是一个获取网络图片的的一个基本过程，先是一个 response 方法，因为是 rx 嘛，必须返回一个 Observable 以供订阅。在方法中通过 .create() 创建一个 Observable，然后在其中开始网络请求，也就是 dataTask 方法。在网络请求的回调中，将获取的数据作为事件值，发出一个事件，之后结束整个 Observable。另外的两个方法是在网络请求的基础上，通过 map 将事件值进行进一步处理。这个网络请求流程如图： 更进一步的，我们可以为这个网络请求设置一个缓存，即将获取的数据做一个接口层面的缓存。我们可以这样做： 12345678910111213// 全局的或者某个单例,用来保存缓存fileprivate var internalCache = [String: Data]()// 缓存方法extension ObservableType where E == (HTTPURLResponse, Data) &#123; func cache() -&gt; Observable&lt;E&gt; &#123; return self.do(onNext: &#123;(response, data) in if let url = response.url?.absoluteString, 200 ..&lt; 300 ~= response.statusCode &#123; internalCache[url] = data &#125; &#125;) &#125;&#125; 先创建一个全局的保存缓存的地方，键是 url，值是数据。然后在 ObservableType 中添加一个针对网络请求的缓存方法，所有 Observable 都是 ObservableType 类型的。这个 cache 方法做了一件事就是通过 .do给 Observable 添加了一个 onNext 方法，每次触发事件的时候都会调用。使用上和 map 类似。现在将之前的 data，以及 image 方法修改一下即可： 123return response(request: request).cache().map &#123; (response, data) -&gt; Data in //...&#125; 由于有了缓存，所以需要在请求数据前加一步验证。如果有缓存，直接返回一个 Observable： 123if let url = request.url?.absoluteString, let data = internalCache[url] &#123; return Observable.just(data)&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift 的概念]]></title>
    <url>%2F2017%2F10%2F26%2FRxSwift%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[学习 RxSwift，开始冲了个泊学会员看视频，发现看视频还不如直接看泊学文档。之后看到了这本书，果然看文档还不如看书。（泊学视频中的RxSwift 就是照搬了这本书的前两个 Section，例子也是照搬的） 着手 RxSwift简介RxSwift 本质上是通过对新数据的顺序处理，来简化异步程序的开发。 RxSwift 基础RxSwift 由三部分组成：Observables，Operators 和 Schedulers。 Observables&lt;T&gt; 帮助一个程序产生一个带有数据的事件序列，允许一个或多个 Observers 响应事件并处理新的数据。Observables 能发送三种类型的事件：next 事件，completed 事件，error 事件。使用事件序列是最终的解耦方式，不再需要使用 delegate 或者闭包。 Operators 指的是有着异步的输入，然后产生没有副作用的输出的方法。它们能够组合在一起，实现复杂的逻辑。比如下图的 filter 和 map 的过程： Schedulers 是 Rx 中的调度队列。我们可以通过 RxSwift 将同一个订阅在不同的调度队列中完成以达到最佳的性能： App 架构Rx 适合所有的架构。当然最匹配的还是 MVVM。MVVM 中有一层 ViewModel 能够暴露出各个 Observables 属性，你可以在 ViewController 中直接将其和 UI 绑定。 RxCocoaRxSwift 提供了通用的 Rx API。开发的时候还需要 RxCocoa 配合 RxSwift 使用 UIKit 和 Cocoa。比如 RxCocoa 给 UISwitch 添加了一个 rx.isOn 属性，你可以订阅它来监听 UISwitch 的事件队列。 ObservableObservable 的生命周期一个 Observable 不发出任何事件，直到有订阅发生。订阅者发送 error 或者 completed 事件能结束订阅。当订阅结束，也就不会再发出任何事件了。 事件 event 是个枚举类型： 12345678public enum Event&lt;Element&gt; &#123; /// Next element is produced. case next(Element) /// Sequence terminated with an error. case error(Swift.Error) /// Sequence completed successfully. case completed&#125; 创建 Observables.just 可以用来创建一个只有一个元素的 Observable： 1let observable = Observable&lt;Int&gt;.just(one) .of 接收多个元素形成一个 Observable： 1let observable2 = Observable.of(1, 2, 3) .from 接收一个数组，将数组元素生成一个 Observable： 1let observable3 = Observable.from([1, 2, 3]) .empty 提供 0 个元素的 Observable，只会触发 completed 事件。尽管 empty 不触发 next 事件，但是还需要明确泛型类型，所以使用 void 是最好的选择： 1let observable4 = Observable&lt;Void&gt;.empty() .never 创建的 Observable 不会触发 next，也不会触发 completed： 1let observable5 = Obnservable&lt;Any&gt;.never() .create 创建 Observable，需要传入一个入参为 observer，返回一个 Disposable 实例的闭包。在这个闭包里定义了所有将要发送的事件： 12345678910Observable&lt;String&gt;.create &#123; observer in // 1 observer.onNext("1") // 2 observer.onCompleted() // 3 observer.onNext("?") // 4 return Disposables.create()&#125; 注意前面生命周期中提及的，onCompleted 发生后，订阅结束。所以后面的 observer.onNext(&quot;?&quot;) 事件是无法接收到的。 订阅 Observables通过 .subScribe 订阅 Observable，返回一个 Disposable 对象。 下面是传入一个入参为事件 event 闭包的例子： 12345let disposable = observable.subScribe &#123; event in if let element = event.element &#123; print(element) &#125;&#125; .subScribe 还可以接受各种事件的回调闭包，比如 onNext,onCompleted,onError： 123let disposable2 = observable.subscribe(onNext: &#123; element in print(element) &#125;) 取消订阅 Observables如果不取消订阅，将会将会产生内存泄漏，取消订阅可以通过 .dispose 直接取消： 1disposable.dispose() 但是这种手动的取消非常的麻烦，RxSwift 提供了一个 DisposeBag 类型，用于自动回收，把订阅后返回的 disposable 对象直接加入 DisposeBag: 12let disposeBag = DisposeBag()disposable.addDisposableTo(disposeBag) 当 disposeBag 回收的时候，会自动取消订阅。 取消订阅有两种方式，一种是此处说的 disposebag，还有一种方式是订阅者调用 onCompleted 方法。比如线面的 Subjects 就可以直接调用取消：subject.onCompleted() Subjects什么是 subjects？subjects 既是 Observable 又是 Observer。有四种类型： PublishSubject：订阅后接受事件 BehaviorSubject：有初始值，新的订阅者会获得订阅前最新的事件 ReplySubject：有一个 buffer，新的订阅者会获得 buffer 中缓存的事件 Variable：包装了的 BehaviorSubject。把当前值作为状态，值改变时触发事件。新的订阅者同样会获得订阅前最新的事件。 PublishSubjectsPublishSubject 只有在订阅后才能接收到事件。流程如图所示，在事件1时并没有进行订阅，所以并没有收到事件；在事件1和事件2之间进行订阅，能收到事件2和事件3；在事件2和事件3之间订阅，能收到事件3： 示例代码如下，要注意初始化的时候要设置好泛型类型： 123456789101112131415let disposeBag = DisposeBag()// 创建 PublishSubjectlet subject = PublishSubject&lt;Int&gt;()// 订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(disposeBag)// 发送事件subject.onNext(1) //1// 结束订阅subject.onCompleted() //completed// 再次订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(disposeBag) //completed// 发送事件subject.onNext(2) //什么也没有发生 要注意一点，当一个 subject 取消订阅后，再订阅，会直接受到一个 completed 事件，之后再发送 next 事件是没有任何响应的。 BehaviorSubjectsBehaviorSubjects 在订阅之后可以接到最近一次的事件。并且接受一个初始值，当订阅前没有事件时，将初始值作为事件值发送。如果所示，事件1和事件2之间订阅的时候，还是能收到事件1；事件2和事件3之间订阅的时候，还是能收到事件2： 示例代码如下，由于有初始值的类型推断，就不需要设置泛型了： 123456789101112131415let disposeBag = DisposeBag()// 创建 BehaviorSubjectlet subject = BehaviorSubject(value: "Initial value")// 订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) // Initial Value// 发送事件subject.onNext("X") // X// 错误事件subject.onError(MyError.anError) // anError// 再次订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) // anError// 发送事件subject.onNext("X") // 没有任何事情发生 和 PublishSubject 类似的，当 subject 完成或者错误时，再订阅，就只会发出完成和错误事件，并且忽略后面的 next 事件。 ReplaySubjectsReplaySubject 有一个 buffer 用来暂存先前的事件值，初始化的时候设置缓存的大小。当有订阅时，将缓存的值发送。如图所示，当在事件2和事件3之间产生订阅的时候，缓存的事件1和事件2都触发了： 示例代码如下，还是要注意设置泛型，并且初始化方法是 create(bufferSize:) 12345678910111213141516let disposeBag = DisposeBag()// 创建 ReplaySubjectlet subject = ReplaySubject&lt;String&gt;.create(bufferSize: 2)// 发送事件subject.onNext("1")subject.onNext("2")// 订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) // 1 2// 发送错误subject.onError(MyError.annError) // annError// 再次订阅subject.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) // 1 2 annError// 发送事件subject.onNext("3") // 没有任何反应 注意，和前面都相同的是，由于之前 subject 已经发出错误事件，再次订阅的时候会立刻收到错误事件。不同的是，由于 ReplaySubject 有 buffer，所以仍然会先响应 buffer 中缓存的事件。 VariablesVariable 是 BehaviorSubject 的包装，将其值作为状态。当值变化时，触发事件，不再需要 onNext() 方法触发事件。Variable 不会出现 error，也不需要手动触发 completed 事件。 代码示例如下： 12345678910let disposeBag = DisposeBag()// 创建 Variablevar variable = Variable("Initial value")// 更改值variable.value = "New Value"// 订阅variable.asObservable() .subscribe &#123; print($0.element) &#125;.addDisposableTo(bag) // New Value Variable 需要使用 asObservable() 方法将其转换为 Observable，值是其 value 属性。另外，由于是 BehaviorSubject 的包装，因此，订阅的时候会打印最后一次的事件值。 Subject 与 Observer 和 Observable 的区别这一节是我自己的理解，可能在理解上有偏差。如果看到这里可以自己也思考一下。 Subject 与 Observable 的不同onNext，onError，onCompleted 都是 Observer 中的方法，但是本身并没有具体的实现。Observable 在订阅的时候传入了这几个方法的实现，所以在触发事件的时候，直接内部调用这些闭包响应事件即可。你可以把这个过程想象成 Observable 调用其内部的 Observer。所以 Observable 必须要能被订阅，订阅有什么用？用来传递事件处理方法。 Subject 既是 Observable 又是 Observer，我们订阅完，传入事件的实现后，就可以直接调用 observer.onNext()。相当于，我们可以选择主动触发事件的时机，然后 Observer 响应事件。这很有用，比如处理 UI 交互，就必须要在任意时刻都能主动触发 observer.onNext() 方法。而单纯的 Observable 则不行，它是非常被动的，要么直接触发，要么延迟多久或者多少周期触发。 Subject 与 Observer 的不同对于单纯的 Observer，由于没有这些事件方法的具体实现，所以我们也不能像 Subject 一样主动触发事件。但是有一些特殊的 Observer 本身在初始化的时候就提供了事件处理的方法，这种 Observer 不需要像 subscribe 一样订阅的时候传入事件处理方法，直接使用 bindTo() 绑定即可。 不过也正是因为 Observer 提供了默认的事件处理方法，所以我们不能用其处理 UI 交互。因为 UI 交互的事件处理方法是要根据具体情况而定的。比如点击一个按钮我可能要让计数加一，或者让计数减一。 总结所以，在我的理解下，Observable 需要传递事件处理方法，所以可以定制，但不能主动触发；Observer 有默认事件处理方法，所以可以主动触发，但不能定制。 因为 Subject 既能主动选择触发事件的时机，又能个性化事件处理的方法，所以一般交互的 UI 控件中的属性都是 Subject 类型。 操作符的最佳实践过滤操作符Igoring operatorsignoreElementsignoreElements 用来忽略所有的 .next 事件。所以用来指接受 completed 事件 示例如下： 1234let strikes = PublishSubject&lt;String&gt;strikes.ignoreElements() .subscribt &#123; print("You are out") &#125; .addDisposableTo(bag) elementAtelementAt 只会获取索引序号的事件，忽略其他的所有 .next。索引序号从 0 开始: 代码如下： 1234let strikes = PublishSubject&lt;String&gt;()strikes.elementAt(1) .subscribe &#123; print("You are out") &#125; .addDisposableTo(bag) filterfilter 接受一个断言闭包，入参为当前事件值。接受所有断言正确的事件。注意是接受而不是过滤掉： 代码如下： 1234Observable.of(1, 2, 3, 4, 5) .filter &#123; $0 % 2 == 0&#125; .subscribe &#123; print($0.elemetn ?? $0) &#125; .addDisposableTo(bag) Skipping operators上面一节是根据条件筛选；这一节是忽略到某个满足条件的，后面的全部接受。 skipskip 用来略过一定数量的 .next事件，然后开始接受。从 1 开始计数 代码如下： 1234Observable.of(1, 2, 3, 4, 5) .skip(2) .subscribe &#123; print($0.element ?? $0)&#125; .addDisposableTo(bag) skipWhileskipWhile 是略过直到某个满足条件的事件发生。skipWhile 还有一个兄弟方法 skipWhileWithIndex，除了接受事件值，还接受事件序号，index 从 0 开始： 代码如下： 1234Observable.of(1, 2, 3, 4, 5) .skipWhile &#123; $0 % 2 == 0 &#125; .subscribe &#123; print($0.element ?? $0)&#125; .addDisposableTo(bag) skipUntilskipUntil 是略过直到某个事件发生。就是当前 Observable 和另外一个 Observable 相关联，当特定的 Observable 的 .next 发生的时候，才开始接受事件： 代码如下： 123456789let subject = PublishSubject&lt;String&gt;()let trigger = PublishSubject&lt;String&gt;()subject.skipUntil(trigger) .subscribe &#123; print( $0.element ?? $0) &#125; .addDisposableTo(bag)// ... 当前时刻虽然订阅了，但是发送事件是无反应的trigger.onNext("a")// ... 由于 trigger 发送了 onNext 事件，现在 subject 可以接收到 next 事件了 Taking operators本小节和上一小结正好相反，这一小节是接受某个事件之前的所有事件，之后的都不接受。 taketake 和 skip 正好相反。take 是直到一定数量的事件发生后才开始取，而不是取到一定数量的时候停 代码如下： 1234Observable.of(1, 2, 3, 4, 5) .take(2) .subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) takeWhiletakeWhile 和 skipWhile 正好相反。takeWhile 是取到某个不满足条件的事件。takeWhile 还有一个兄弟方法 takeWhileWithIndex，除了事件值 value，还接受事件的序号 index： 代码如下： 12345Observable.of(1, 2, 3, 4, 5) .takeWhileWithIndex &#123; v, i in v &gt; 1 &amp;&amp; i &gt;1 &#125;.subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) takeUntiltakeUntil 和 skipUntil 相反。表示接受事件知道某个 Observable 的事件触发： 代码如下： 123456789let subject = PublishSubject&lt;String&gt;()let trigger = PublishSubject&lt;String&gt;()subject.takeUntil(trigger) .subscribe &#123; print($0.element ?? $0 )&#125; .addDisposableTo(bag)// ... 此时一直接受 next 事件trigger.onNext("x")// ... 现在忽略所有的 next 事件了 Distinct operators本小节的操作符可以防止重复事件 distinctUntilChanged如果当前事件和前一个事件的事件值相同，那么忽略这个事件： 代码如下： 1234Observable.of(1, 2, 2, 1) .distinctUntilChanged() .subscribe &#123; print($0.elemet ?? $0) &#125; .addDisposableTo(bag) distinctUntilChanged 还接受一个闭包，闭包入参为相邻事件的事件值，闭包返回值为 true 则忽略当前事件。 代码如下，当前一个事件值为 1，当前事件值为 2 的时候忽略当前事件： 1234567Observable.of(1, 2, 2, 1) .distinctUntilChanged &#123; a, b in if a == 1 &amp;&amp; b == 2 &#123; return true &#125; return false &#125; 转换操作符转换元素toArray将事件序列的元素转换成一个数组，然后将这个数组作为事件值，触发 .next 事件： 代码示例： 1234Observable.of("A", "B", "C") .toArray() .subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(bag) // ["A", "B", "c"] mapmap 和数组中的 map 无异： 代码示例： 1234Observable.of(1, 2, 3) .map&#123; $0 * 2&#125; .subscribe&#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) map 还有一个兄弟方法 mapWithIndex 带有一个索引： 代码示例： 12345Observable.of(1, 2, 3) .mapWithIndex&#123; v, i in i &gt; 1 ? v * 2 : v &#125;.subscribe&#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) 转换内部 ObservablesflatMapflatMap 主要就是将一个 Observable 中的每个元素都转换为一个 Observable，并且订阅。flatMap 需要一个闭包，传入当前 Observable 的事件值，返回一个新的 Observable。下面图示的例子中 Observable 的事件值类型为 Variable。传入一个 Variable，将其 value 属性扩大十倍： 代码示例： 12345678910let outter = PublishSubject&lt;Variable&lt;Int&gt;&gt;outter.asObservable() .flatMap &#123; $0.value *= 10 return $0.asObservable() &#125;.subscribe(onNext: &#123; print($0) &#125;) .addDisposableTo(bag)outter.onNext(Variable(1))outter.onNext(Variable(2)) flatMapLatestflatMapLatest 是 flatMap 和 switchlatest 的合体。在使用上和 flatMap 一致，但是它值订阅最新的 Observable： 看出区别了么？当有新的订阅产生的时候，旧的 Observable 就取消订阅了，所以这里由于订阅了绿色的 Observable，所以蓝色变为 30，并不会触发订阅；由于订阅了橙色的 Observable，所以绿色变为 50，也不会触发订阅。而 flatMap 则是全部都触发了订阅的。 关联操作符前缀与串联startWithstartWith 接受一个事件值，将其插到当前事件序列的最前面，返回一个新的 Observable： 代码如下： 1234let numbers = Observable.of(2, 3, 4)let observable = numbers.startWith(1)observable.subscribe&#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) concatconcat 连接两个事件序列，生成一个新的事件序列： 代码如下，注意要用 [] 将事件序列当成一个数组： 123456let first = Observable.of(1, 2, 3)let second = Observable.of(4, 5, 6)let observable = Observable.concat([first, second])observable.subscribe&#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) 连个事件序列的泛型类型一定要相同，否则崩溃给你看😖 合并mergemerge 将元素为事件序列的事件序列自动拆开，成为一个新的事件序列。其实你也可以分开来写，让它们分别订阅，merge 主要就是用来减少事件序列的订阅的： 代码如下： 123456789let left = PublishSubject&lt;String&gt;()let right = PublishSubject&lt;String&gt;()// 将两个事件序列作为事件值let source = Observable.of(left.asObservable(), right.asObservable())// 将新的事件序列的元素合并，返回一个新的事件序列let observable = source.merge()observable.subscribe&#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) 注意，只有当内部的时间序列都 completed 后，merge 产生的事件序列才会 completed。 关联元素combineLatest当 combineLatest 中的子序列中的任意一个发出事件的时候，将会调用一个你提供的闭包。这个闭包将子序列的最近的事件值作为入参传入，得到的返回值作为事件值执行订阅的方法。主要用在同时监控多个源的状态。 上面图示中，当事件 1 触发的时候，由于另外一个序列没有事件发生过，所以不触发订阅，直到那一个序列发生了事件 4，才触发了订阅。 代码如下： 123456789let left = PublishSubject&lt;String&gt;()let right = PublishSubject&lt;String&gt;()let observable = Observable.combineLatest(left, right, resultSelector: &#123; lastLeft, lastRight in "\(lastLeft) \(lastRight)"&#125;)observable.subscribe(onNext: &#123; value in print(value) &#125;).addDisposableTo(bag) 另外需要说明的就是只有两个子序列都 completed，外部序列才会 completed。如果其中一个子序列先结束了，当另外一个序列触发事件的时候，使用的是结束的那个子序列结束前最后一次事件的事件值。其实上面的图中也有展示，right 先结束了，此时left 触发了事件 3，所以最终是将 3，6 的值作为事件值的。 zip和上面的 combineLatest 不同，zip 要求必须每个子序列都有新消息的时候，才触发事件： 可以看到，left 和 right 都必须有新的消息最终才能产生事件。由于 right 已经结束了，所以 sunny 永远不会接收到。 代码如下： 123456789let left = PublishSubject&lt;String&gt;()let right = PublishSubject&lt;String&gt;()let observable = Observable.zip(left, right) &#123; lastLeft, lastRight in "\(lastLeft) \(lastRight)"&#125;)observable.subscribe(onNext: &#123; value in print(value) &#125;).addDisposableTo(bag) 需要注意的是，zip 不需要所有内部序列都完成，只要有一个 completed，整个事件序列就结束了。 (确实这个挺像拉链的，名字起得很形象) 触发器withLatestFrom当一个 Observable 触发的时候，获取另一个 Observable 的最新的事件值。很常用，比如点击按钮的时候要获取 textfield 的最新值： text 不管怎么修改，当 button 点击的时候，都获得最新的 text 的值。 代码如下： 123456let button = PublishSubject&lt;Void&gt;()let textField = PublishSubject&lt;String&gt;()button.WithLatestFrom(textField) .subScribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) simple触发某个 Observable 获取另一个 Observable 的最新值。但是和 withLatestFrom 不同的是，当再次触发这个 Observable 的时候，如果另一个 Observable 没有更新值，那么不会触发事件，类似于 distinctUntilChanged： 代码如下： 1let Observable = textField.sample(button) 一定要注意这里啊，前面是 button.withLatestFrom(textField)，这里是 textField.sample(button)。 开关amb当两个 Observable 中的任意一个触发的时候，取消订阅另一个，以后只接受当前 Observable 的事件。如图所示，由于 right 先出法，所以就取消了 left 的订阅，以后就只能接收到 right 的事件了： 代码如下： 123456let left = PublishSubject&lt;String&gt;()let right = PublishSubject&lt;String&gt;()left.amb(right) .subscribe &#123; print($0.element ?? $0) &#125; .addDisposableTo(bag) switchLatest前面那个是被动的哪个 Observable 最先触发就一直订阅哪一个。这个是可以自己控制当前想要订阅那个 Observable： 如图所示，source 在选择 one 的时候，只接受 one 的事件，在选择 two 的时候，只接受 two 的事件。 1234567891011121314151617let one = PublishSubject&lt;String&gt;()let two = PublishSubject&lt;String&gt;()let three = PublishSubject&lt;String&gt;()// source 的事件值类型是 Observable 类型let source = PublishSubject&lt;Observable&lt;String&gt;&gt;()let observable = source.switchLatest()let disposable = observable.subscribe(onNext: &#123; value in print(value) &#125;)// 选择Observable onesource.onNext(one)one.onNext("emit") // emittwo.onNext("emit") // 没有 emit// 选择Observable twosource.onNext(two)two.onNext("emit") // emit 还记得 flatMapLatest 吗？之前说过 flatMapLatest，就是 map + switchLatest 元素和序列的结合reduceRx 中的 reduce 类似于 Swift 中的 reduce，将一个序列的所有事件值通过运算，得到一个最终的事件值，并触发事件： 代码如下： 12345Observable.of(1, 2, 3) .reduce(0) &#123; summary, newValue in return summary + newValue &#125;.subscribe &#123; print($0.element &amp;&amp; $0) &#125; .addDeposiableAt(bag) scanscan 和 reduce 的不同在于，reduce 是一锤子买卖，scan 每次接收到事件值时都会触发一个事件： 代码如下： 1234Observable.of(1, 2, 3) .scan(0, accumulator: +) .subscribe(onNext: &#123; value in print(value) &#125;) .addDeposiableTo(bag) 基于时间的操作符缓存操作符replay这个操作符是针对一个 Observable，多个订阅者的。为 Observable 设置 replay ，当有新的订阅者订阅的时候，会立即触发最近的几个事件： 上面的是 Observable，每隔 1s 发出一次事件。下面是一个订阅者，在第 4s 的时候开始订阅。由于设置了 replay 的数量为 1，所以立刻重现之前的事件 3，再加上当前事件 4 的触发，所以再时刻 4，有两个事件一起触发了。 代码如下： 12345678910let interval = Observable&lt;Int&gt;.interval(1, scheduler:MainScheduler.instance).replay(1)_ = interval.connect()delay(3) &#123; _ = interval.subscribe(onNext: &#123; print("Subscriber 2: Event - \($0) at \(stamp())") &#125;)&#125; 这种一个 Observable，多个订阅者的情况叫做可连接 Observable，一般的 Observable 类型为 Observable&lt;E&gt;，这种类型为 ConnectableObservable&lt;E&gt;。所以需要使用 .connect 方法来表示 Observable 开始运行。 如果要所有元素都重现，那么可以使用 .replayAll() bufferbuffer 用于将事件缓存，在某个条件下，一并发出。buffer(timeSpan:count:scheduler:) 接受一个最大时间跨度 timeSpan，一个事件最大发生数量 count。处理逻辑在于，当最大时间跨度内事件数量没有到时，发送一个事件，其事件值为当前事件跨度内发出的时间的事件值组成的数组，重置时间跨度；当时间跨度内发生的事件超过了最大发生数量时，立即发送一个事件值为这些事件值所组成的数组的事件，重置时间跨度： 如图，时间跨度为4，最大事件值为2。最开始什么时间也没有发生，所以发送一个 0 个元素的数组。之后某个时刻发出了三个事件，所以将前两个事件值合成为一个数组发送，剩余一个事件，重置时间跨度。后面事件数量没有到最大值，但是时间跨度到了，所以也发送一个事件的数组，重置时间跨度。最后又没有事件发生，发送 0 个元素的数组的事件。 12345678let interval = Observable&lt;String&gt;.interval(1, scheduler: MainScheduler.instance) .buffer(timeSpan: 4, count: 2, scheduler: MainScheduler.instance)_ = interval.subscribe(onNext: $0)interval.onNext("🐈")interval.onNext("🐈")interval.onNext("🐈") 时间平移操作符delaySubscription延迟订阅，在正式订阅前发生的事件都会被忽略： 如图，在 1 时刻开始订阅，由于延迟了 1.5s，所以前两个事件被忽略了。 123Observable.of(1, 2, 3, 4, 5) .delaySubscription(RxTimeInterval(delayInSeconds), scheduler: MainSchedular.instance) .subscribe&#123; print($0.element ?? $0) &#125; delaydelay 则将序列中的所有事件延迟执行，所以并不会忽略掉事件： 差别就在于，上面的忽略了1，2，而这里则仍是从事件 1 开始。 123Observable.of(1, 2, 3, 4, 5) .delay(RxTimeInterval(delayInSeconds), scheduler: MainSchedular.instance) .subscribe&#123; print($0.element ?? $0) &#125; 定时操作符intervalRx 中的定时不需要使用 NSTimer，也不需要使用 DispatchSource。interval 的使用非常简单，比如一个1s的定时器： 1Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) 事件值默认是从 0 开始发送，依次递增。如果你不想要从 0 开始，可以使用 map。不过一般我们不需要使用这个事件值。 timertimer(_:period:scheduler:) 和 interval 的区别在于，可以设置一个重复次数 period。如果不设置，默认只执行一次： 1Observable&lt;Int&gt;.timer(3, period:3, scheduler: MainScheduler.instance)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Swift 技巧》笔记]]></title>
    <url>%2F2017%2F10%2F20%2FSwift%20%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[两天读完了这本书，干货满满 Swift 新元素柯里化原本一个函数要接收两个参数，但是通过科里化就不需要了，先传入一个参数，然后返回一个包含这个参数的闭包，然后就可以再传入任意的参数了。 将 protocol 方法声明为 mutatingstruct 和 enum 的方法需要使用 mutating 标记，否则无法通过编译。并且这个标记对于 class 类型没有影响。所以尽量将协议方法声明为 mutating Sequence所以能够 for…in 的都实现了 Sequence 协议。会调用这个协议的 makeIterator() 方法，该方法返回任意实现了 IteratorProtocol 协议的类。在枚举的时候，会调用该协议的 next() 方法。 元组对于一个需要返回多个对象的函数，可以使用元组。 @autoclosure如果一个函数的入参是一个闭包，并且只有一句且闭包类型为 () -&gt; T，那么可以在函数声明时，在函数类型前加上 @autoclosure 标记，就可以省略 {} 一个疑问：为什么要用 @autoclosure 而不直接传这个一句闭包的结果呢？因为这个闭包不一定会执行，如果直接传结果，会造成性能损耗。 @escaping如果一个函数的入参中包含一个闭包，且这个闭包将会被保存，那么需要将这个闭包标记为 @escaping。 其中所有的 self 的属性都需要写明，并且要注意需要打破引用循环。 Optional Chaining可选链上，即使左后访问的是一个非可选的值，但是我们拿到的仍然是一个可选值。如下，即使 name 是非可选，toyName 仍然是可选的：1let toyName = xiaoming.pet?.toy?.name 另外还有一个注意点，比如下面的例子：123let playClosure = &#123;(child: Child) -&gt; ()? in child.pet?.toy?.play()&#125; 由于只有一句，那么编译器默认省略了 return，由于 play() 返回 void，又因为是可选链，所以最终这个闭包返回的是可选的Void，即 Void？ 操作符可以对操作符进行重载：123func +(left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y +right.y)&#125; 创建新的操作符要先对操作符进行声明，用的不多，暂且不表。 func 的参数修饰可以在入参类型前加上 inout 标记，相当于在函数内部创建了一个新的值，然后在函数返回时将这个值赋给 &amp; 修饰的变量 下标下标就像是计算型属性和函数的结合，需要一个入参和出参的声明，并且还要提供 get、set 方法。 方法嵌套一个方法太长，为了明确职责，我们一般将其切分成多个小的方法，但是这些小的方法一般只会调用一次，平铺这些方法并不是最优办法。所以可以将这些方法嵌套在原方法内，这样既能明确职责，又不会出现很多方法。 命名空间Swift 的命名空间是以 target 作为区分的。如果重名，要在类型名称前面加上 target 名。 如果是同一 target 内的同名，那么可以使用 struct 将类型包裹。 typealias为已有类型添加一个别名，增加代码的可读性。主要用在协议的关联类型上。在实现协议的类中，为协议的关联类型指定具体的类型。 如果类型存在泛型，别名同样需要引入：1typealias Worker&lt;T&gt; = Person&lt;T&gt; 可以为组合类型实现别名：1typealias Pat = Cat &amp; Dog associatedtype在协议中可以使用 associatedtype 关键字来定义一个占位符类型，需要实现协议的类通过 typealias 或者类型推断，将占位符类型转化为一个具体的类型：1234567891011protocol Animal &#123; associatedtype F func eat(_ food: F)&#125;struct Tiger: Animal &#123; typealias F = Meat func eat(_ food: Meat) &#123; print("eat \(food) &#125;&#125; 注意，associatedtype 后，就不能将协议当做独立的类型使用了。这是因为 Swift 需要在编译时确定所有类型，所以不能容忍使用了类型中的 F 没有确定。如果一定要使用，需要使用泛型。比如下面方法中我们只能在方法中使用泛型 T，来代表所有实现 Animal 协议的类型，而不能直接使用 Animal 了：12func isDangerous&lt;T: Animal&gt;(animal: T) -&gt; Bool &#123;&#125; 可变参数函数写一个可变参数的函数只需要在声明参数时再类型后面加上 ... 即可。输入的参数将在函数体内部被当做数组来使用。 初始化方法顺序Swift 的初始化方法需要保证类型的所有属性都被初始化。需要先初始化当前类型的所有属性后，才能调用 super.init()，然后修改父类属性。如果我们不需要修改父类属性，那么可以省略 super 的调用，编译时会自动加上。 Designated，Convenience 和 Required初始化方法遵循两个原则： 初始化路径必须保证对象完全初始化 子类的 designated 初始化方法必须调用父类的 designated 方法 对于某些希望子类中一定实现的 designated 初始化方法，我们可以添加 required 关键字就行限制，强制重写。 初始化返回 nil使用 init? 定义可失败方法 static 和 class描述类型方法或者属性的时候，可以使用关键字 static 或者 class。但是 class 有一些限制，不能再枚举和机构体中使用，且不能用在类类型的存储属性上。 所以其实无论怎么样，使用 static 就不会错，不要没事用 class 多类型容器容器存放多类型，可以使用 Any 类型，但是这样会失去属性的特性。我们可以将容器声明为都满足某一种协议。 default 默认参数可以为某一个入参添加默认值，只需要在在参数类型后加上值，形如str1: String = &quot;Default&quot;。调用的时候，如果想要使用默认值，只要在调用的时候省略掉那个参数即可。 … 和 ..&lt;这两个操作符可以接受 Int 返回一个 Range。除此之外，还可以接受任何实现了 Comparable 协议的输入，比如 String。下例表示一个 a-z 的字母范围。1let interval = "a"..."z" AnyClass，元类型和 .selfA.Type 表示的是 A 这个类型的类型。我们可以通过 .self 取出：1let typeA: A.Type = A.self Swift 中定义了一个别名 AnyClass 表示任意类型的类型。1typealias AnyClass = AnyObject.Type 我们可以通过这个类型的类型来调用类型方法：12let anyClass: AnyClass = A.self(anyClass as! A.Type).method() 上面的例子和直接使用 A.method() 是一个效果。但是使用元类型的好处就是可以动态的传递某个类型，而不是如这里只能用 A 调用。 Any 表示所有类型，包括 class，struct，enumAnyObject 值表示 classAnyClass 表示 AnyObject.Type 协议和类方法中的 Self在协议和类方法中，我们可以使用 Self 表示自己的类型：123protocol IntervalType &#123; func clamp(intervalToClamp: Self) -&gt; Self&#125; 声明协议的时候，我们希望协议中使用的类型就是实现这个协议本生的类型，所以使用 Self。 这个 Self 表示自身，或者子类。因此，我们不能使用明确的类型，比如下面这样就是错的：12345// 错误示例func copy() -&gt; Self &#123; let result = MyClass() return result&#125; 我们创建的也需要是 Self 类型的：12345678// 正确示例func copy() -&gt; Self &#123; let result = type(of: Self).init() return result&#125;required init() &#123;&#125; 注意，这里一定要为 init() 方法加上 required 关键词。因为前面说了 Self 是当前类或者子类，所以我们必须保证子类也实现了 init() 方法。另外，我们可以把当前类定义为 final ，即不可能有子类，那么就不需要 required 了。 属性观察我们可以为一个存储型属性添加 willSet 和 didSet 对属性进行观察。我们可以使用 newValue 和 oldValue 获取设定和已经设定的值。 属性观察的一个重要的作用是作为设置值的验证。 lazy 修饰符我们可以对一个变量使用 lazy 关键字，表示延迟加载。我们可以对这个变量直接赋值，或者使用执行一个闭包。这会在该变量第一次被使用时执行。 隐式解包 Optional隐式解包 Optional 就是在变量后加上 !，达到形式上的非可选的效果，但是实质上还是可选类型。 最好少用隐式解包，现在的一种常用的场景是 IBOutlet：1@IBOutlet weak var button: UIButton! 多重 Optional多重可选就是可选变量的可选，普通的可选的两个状态是有或者没有，多重可选的状态是没有或者另一个可选变量：12var string: String? = “String”var another: String?? = string 如上所示，another 的值为一个可选类型， 因为可选是一个枚举类型，分为有值和没值，所以可以想象多重可选产生的树状结构。 Optional Map对于可选类型的集合也可以使用 Map，如果元素不为 nil，则对元素执行 map，如果元素为 nil，则直接返回 nil Protocol Extension协议的拓展可以给协议提供一个默认的实现。我们可以大胆的用动态派发使用最终的实现，不论是类中的具体实现，还是协议中的默认实现。这其实变相的，将 protocol 中的方法设定为了 optional 但是还存在一种情况，协议拓展中实现了协议中没有定义的方法。这个协议没有规定该方法必须要实现。当你协议的实现类也实现了这个方法的时候，那就要看调用该方法的是以协议的类型还是以实现类的类型了。如果以协议类型调用，那么调用协议拓展中的实现；如果以类类型调用，那么调用类中的实现。 where 和模式匹配where 的使用场景还是很多的，总结了四种场景。前两种可以代替 if，后两种用来限制泛型： case 条件中的限定 for…in 循环中限制循环的掉入 限制泛型，当泛型中存在关联类型时，还可以限制关联类型 限制 extension 中的泛型 12345678910111213141516171819// caseswitch A case let x where x == 5: // for...infor score in n where score &gt; 60 &#123;&#125;// classclass A&lt;T,K&gt;: a where T: t, K: k, T.tType = K.kType: &#123;&#125;// funcfunc method&lt;T&gt;(param: T) where T: s &#123;&#125;// extensionextension A where T: t, K: k, T.tType = K.kType &#123;&#125; indirect 和嵌套 enum如果要在枚举类型中嵌套使用当前类型的话，需要在枚举类型前加上关键字 indirect。 从 OC 到 SwiftSelectorOC 中使用 @selector 获取关键字，Swift 中使用 #selector 获取一个方法暴露给 OC。在要暴露给 OC 的方法前需要添加 @objc 关键字：12345@objc private func call(to: String)&#123;&#125;let someMethod = #selector(call(to:))NSTimer.scheduledTimerWithTimeInterval(1,target: self. selector: someMethod, userInfo: nil, repeats: true) 实例方法的动态调用Swift 提供了一种方法替代直接调用实例方法。通过类型先取出某个实例方法的签名，然后再传递实例拿到实例需要调用的方法：123let f = MyClass.methodlet object = MyClass()let result = f(object)(1) 其实第一句相当于做了以下的字面量转换，也就是将这个方法放到了一个闭包中去：1let f = &#123; (obj: MyClass) in obj.method &#125; 这种写法只适用于实例方法，不适用于属性的 getter 和 setter 方法。另外，如果有多个同名但是函数签名不同的方法，或者与类方法同名的话，可以在获得方法签名的时候，显示的加上类型声明：123456// 有同名类方法，那么获取的就是类方法let f1 = MyClass.method// 同f1，因为是类方法，所以不需要传入类对象let f2: (Int) -&gt;Int = MyClass.method// 实例方法，需要传入类对象let f3: (MyClass) -&gt; (Int) = MyCLass.method 单例Swift 可以无缝使用 GCD，但是 Swift3 中移除了 dispatch_once。可以使用 Swift 中有更简单的保证线程安全的方式 let：1234class MyClass &#123; static let shared = MyClass() private init() &#123;&#125;&#125; 最主要的就是将 init 方法私有化，这样外部无法调用 条件编译Swift 中没有了宏的概念，不能使用 #ifdef 来检查某个符号是否通过宏编译。但是我们仍可以通过 #if，#else，#endif 来控制编译流程和内容。 为了自定义编译符号，我们需要在编译选项中进行设置，在项目的 Build Setting 中，找到 Swift Compiler - Custom Flags，然后再 Other Swift Flags 上加上 -D DEBUG 即可定义一个 DEBUG 宏。 编译标记OC 中一般使用 #param mark - xxx 的方式来标记代码区间。Swift 中可以使用 // MARK: xxx 进行标记。在冒号后面加上横杠 - ，这样导航栏中这个位置会再多显示一个横条。 还有包括 // TODO:，// FIXME: 的标记。 @UIApplicationMainOC 中会有一个 main 文件，调用 UIApplicationMain 的方法。Swift 中只有在 AppDelegate 上有一个 @UIApplicationMain 标记。这个标签将被标注的类作为委托，去创建一个 UIApplication 并启动整个程序。编译的时候，编译器将寻找这个标记的类，然后插入像 main 函数这样的模板代码。 @objc 和 dynamic可以对需要暴露给 OC 使用的任意地方(包括类，属性和方法等)的声明前加上 @objc 修饰符。这个步骤只需要对那些不是继承于 NSObject 的类型进行，如果使用 Swift 写的 class 是继承于 NSObject 的话，Swift 会自动为所有 非 private 类和成员加上 @objc。 添加了 @objc 也并不意味着方法或者属性会变成动态派发，Swift 会将其优化为静态调用。如果需要动态调用，需要使用修饰符 dynamic 可选协议和协议拓展Swift 的协议中没有可选项，所有方法默认必须实现。可以使用协议拓展，在可选的方法定义默认实现。 内存管理，weak 和 unowned闭包中的弱引用，在函数类型前添加中括号：123&#123; [unowned self, weak someObject] (number: Int) -&gt; Bool in return true&#125; @autoreleasepoolSwift 中也可以自建自动释放池：12autoreleasepool &#123;&#125; 值类型和引用类型Swift 中的数组是值类型，在频繁增减其中元素时，复制产生的消耗非常大。因此，在使用数组和字典时，如果数据增减频繁，使用 NSMutableArray 和 NSMutableDictionary 会比较好，容器内条目小并且数目稳定的时候，使用 Swift 的 Array 和 Dictonary。 String 还是 NSStringString 和 NSString 可以无缝替换。但是最好使用原生的 String UnsafePointerC 语言中的指针，将会在 Swift 中被转为 UnsafePointer&lt;Type&gt;类型：123456789// C 中void method(const int *num) &#123; printf("%d", *num);&#125;// Swift 中func method(_ num: UnsafePointer&lt;CInt&gt;) &#123; print(num.pointee)&#125; C 中的基础类型，Swift 遵循统一的命名规则，在基本类型前加上 C。 传入指针地址是都是在前面加上 &amp; GCD 和延时调用Swift 中无缝使用 GCD:123456789101112// 创建⽬标队列let workingQueue = DispatchQueue(label: "my_queue")// 派发到刚创建的队列中，GCD 会负责进⾏线程调度workingQueue.async &#123; // 在 workingQueue 中异步进⾏ print("努⼒⼯作") Thread.sleep(forTimeInterval: 2) // 模拟两秒的执⾏时间 DispatchQueue.main.async &#123; // 返回到主线程更新 UI print("结束⼯作，更新 UI") &#125;&#125; 延迟调用：1234let time: TimeInterval = 2DispatchQueue.main.asuncAfter(deadline: DisaptchTime.now() + time) &#123; print("2秒后输出")&#125; 获取对象类型调用 type(of: xxx) 来获取对象类型 自省向一个对象发出询问，确定它是不是属于某个类，这种操作叫做自省。Swift 中使用 is 相当于 OC 中的 isKindOfClass:1234let obj: AnyObject = ClassB()if (obj is ClassB) &#123; print("属于 ClassB")&#125; KVO暂时还没有比较好的 KVO 的纯 Swift 方案，可以使用属性观察实现类似替代。现有库 Observable-Swift 对这一思路进行了封装。 判等Swift 中，== 是你一个操作符的声明，在 Equatable 中声明了这个操作符的协议方法：123protocol Equatable &#123; func ==(lhs: Self, rhs: Self) -&gt; Bool&#125; 对于自建类型，如果想要能够使用 == 判等，需要实现 Equatable 协议。Swift 中的操作符都是全局的，我们不需要在拓展中实现这个重载方法，要在全局的 scope 里定义这个方法。使用的时候通过类型推断调用正确的 == 重载：1234567891011121314class TodoItem &#123; let uuid: String init(uuid: String) &#123; self.uuid = uuid &#125;&#125;extension TodoItem: Equatable &#123;&#125;func ==(lhs: TodoItem, rhs: TodoItem) -&gt; Bool &#123; return lhs.uuid == rhs.uuid&#125; Swift 中使用 === 判断两个类型是否是同一个地址。 OptionsOC 中的 NS_ENUM 与 Swift 中的 enum 对应。那么 OC 中的 NS_OPTIONS 呢？对应于满足 OptionSetType 协议的 struct 类型，以及一组静态的 get 属性。 以动画选项为例：1234567public struct UIViewAnimationOptions : OptionSetType &#123; public init(rawValue: UInt) static var layoutSubviews: UIViewAnimationOptions = UIViewAnimationOptions(rawValue: 0) static var allowUserInteraction: UIViewAnimationOptions UIViewAnimationOptions(rawValue: 1)//... static var transitionFlipFromBottom: UIViewAnimationOptions UIViewAnimationOptions(rawValue: 1 &lt;&lt; 1)&#125; 使用的时候直接使用类属性，options 接受一个 OptionSetType 的数组：12345UIView.animate(withDuration: 0.3, delay: 0.0, options: [.curveEaseIn, .allowUserInteraction], animations: &#123;&#125;, completion: nil) 数组 enumerateOC 中需要获得数组的下标索引一般使用方法 enumerateObjectsUsingBlock:。Swift 中有一个替代方法：1234567var result = 0for (idx, num) in [1,2,3,4,5,6].enumerated() &#123; result += num if idx ==2 &#123; break &#125;&#125; delegateSwift 中一般的 protocol 不能作为 delegate 的类型，因为 struct 和 enum 也能遵循 protocol，但是它们不是通过引用计数来管理内存的，所以这样就会导致 delegate 不能使用 weak 修饰。 所以一个能作为 delegate 类型的 protocol 必须是只能由 class 实现的。需要在声明的名字后面加上 class:123protocol MyClassDelegate: class&#123; func method()&#125; Associated ObjectOC 中可以通过 Associated Object 在 Category 中给已有类添加成员变量。Swift 中也可以通过 Associated Object 在 extension 中给已有类添加成员变量：12345678910111213141516private var key: Void?extension MyClass &#123; var title: String? &#123; get &#123; return objc_getAssociatedObject(self, &amp;key) as? String &#125; set &#123; objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125;&#125;let a = MyClass()a.title = "123" key 的乐行为 Void?，通过 &amp; 操作符取地址并作为 UnsafePointer&lt;Void&gt; 类型被传入。 LockOC 中常用 @sychronized 作为锁，但是 Swift 中不存在了。如果想要 lock 一个变量的话需要如下：12345func myMethod(anObj: AnyObject!) &#123; objc_sync_enter(anObj) // 在 enter 和 exit 之间 anObj 不会被其他线程改变 objc_sync_exit(anObj)&#125; 可以写一个全局方法做适当封装，使其类似于 OC：1234567891011func synchronized(_ lock: AnyObject, closure: () -&gt; ()) &#123; objc_sync_enter(lock) closure() objc_sync_exit(lock)&#125;func myMethodLocked(anObj: AnyObject!) &#123; synchronized(anObj) &#123; // 在括号内 anObj 不会被其他线程改变 &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Swift 进阶》笔记]]></title>
    <url>%2F2017%2F10%2F18%2FSwift%20%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[这书读的累觉不爱 Swift 风格 使用类型推断。省略显而易见的类型有助于提高可读性 优先使用结构体。只有确定要使用类的特性或者引用语义的时候才使用类 避免使用强制解包或隐式强制解包，除非能确定非 nil 试着使用 map 和 reduce 代替 for 循环 除非需要改变某个值，否则尽量用 let 尽量不要使用 self。使用 self 是一个清晰的信号，表明闭包会捕获 self 內建集合数组数组和可变性 值类型并不是赋个值就创建一个内存空间。值类型在不变的情况下还是共享内存的。只有其中一个变化的时候才会分配新的内存。这样能减少复制带来的性能问题。数组和可选值 应该尽量不使用强制解包。养成习惯后会导致你强制解包原本不该解包的东西。数组变形 map 对每个元素进行操作，闭包返回处理过的值，最后得到一个处理完成的数组 filter 对每个元素进行判断，闭包返回 Bool 值，最后得到一个所有符合要求元素的数组 reduce 对所有元素进行运算，闭包返回的值和下一个元素作为下一次运算的输入，最后返回一个所有元素的处理结果值。 flatMap 针对于每一次 map 闭包处理后返回的是一个数组，即最终返回一个元素是数组的数组的情况。可以使用 flatMap 将内部数组展开，最后得到一个包含所有元素的数组。 forEach 的 return 并不能返回给外部。所以一般不要使用 forEach，而使用 for…in数组类型 当我们通过数组下标获得数组中的一段时，获得的不是一个新的 Array，而是 ArraySlice。ArraySlice 是 Array 的一种表现方式，没有真正的 alloc。相当于在原数组的基础上，多加了保存两个 index 的变量，也就是说，index 不是从 0 开始的。 Range range 表示一个区间，但是并不是所有范围都是序列或者集合类型。只有那些步长为整数的才是集合类型。 集合类型协议序列 一个集合 Collection 就是一个序列 Sequence，这要满足 Sequence 协议。满足 Sequence 协议要求实现一个返回迭代器 实例的方法 makeIterator()迭代器 迭代器要满足 IteratorProtocol 协议，要求实现 next() 方法。 for 循环的基本过程是，集合调用 makeIterator() 返回一个迭代器实例，迭代器在创建的时候将集合传入。不停调用迭代器的 next() 方法，返回集合中的元素。 绝大多数迭代器都是值语义，复制的时候两个迭代器分别工作。AnyIterator 是一个用来封装其他迭代器的迭代器，它是引用语义的。AnyIterator 相当于一个盒子，盒子被引用复制，盒子里的迭代器将被共享。 创建一个序列的方式: AnySequence 提供了一个初始化方法，接收一个返回值为迭代器的函数。 通过 sequence(first:next:) 或者 sequence(state:next:) 两个方法。除了 next 要求传入一个生成后续值的闭包外，前者传入一个初始值，后者传入一个元组。 无限序列 序列可以是无限的，而集合则是有限的。这是一个重要区别 可以通过 let value = someSequence.prefix(10) 的方式获取序列的前十个元素。然后 Array(value) 生成一个数组。不稳定序列 不只是数组这样的才叫序列。网络流，文件流也可以当做序列。序列并不保证可以被多次遍历都一样。 如果序列遵守 Colleciton 协议，那么就是集合。集合是稳定的。这是两者的另一个差别。序列和迭代器的关系 需要在序列中提供一个迭代器的意义在于，每次遍历的时候都生成一个新的迭代器，这样内部状态独立。否则内部状态随着 for 循环改变。子序列 Sequence 提供了一个关联类型 associatedtype SubSequence。在返回原序列切片的操作中，SubSequence 被用作返回值的类型，比如 ArraySlice。 集合类型 集合类型指的是可以多次遍历的稳定的序列 Collection 协议是建立在 Sequence 协议上的 本节后部分加起来实现了一个 FIFO 队列如何实现一个 FIFO 队列 创建一个 FIFO 队列的结构体，然后提供 FIFO 队列的特有 enqueue、dequeue 方法。 若你想自己创建一个 Collection 类型，由于 Collection 提供了很多默认实现，比如迭代器就有默认实现，你只要自己实现 startIndex、endIndex、根据索引访问特定位置，以及下标方法。 实现 ExpressibleByArrayLiteral 协议，可以用数组字面量( 形如[1,2,3] ) 的形式创建队列，数组也实现了这个协议，实现了这个协议的不一定是数组。 切片 切片和原来的集合共享存储缓冲区。也就是说，切片不会单独取出内存，它只是标记了集合的开始和结束位置。 可选值通过枚举解决魔法数的问题 可选是一个枚举类型1234enum Optional&lt;Wrapped&gt; &#123; case none case some(wrapped)&#125; 可选值概览if let 和 while let 通过可选绑定 if let 获得一个非空值。while let 代表一个当遇到 nil 时终止的循环。 for…in 其实就是一个 while let 循环。双重可选值 可选值的值仍然是一个可选值 optional&lt;Optional&lt;Int&gt;&gt; 即 Int??if var 和 while var 获取一个能在作用域内使用的副本的简介，并不会改变原来的值。解包后的可选值的作用域 如果使用 guard 语句要求必须有 return ，在循环中的话则是 break 和 continue 一个函数的返回值如果是 Never，那么表示什么也不返回。一般我们定义的方法不会返回 Never可选链 如果某个方法的返回值可能为空，那么可选链的调用上需要加上 ?；反之，则不需要。nil 合并运算符 a ?? b 表示 a 不为空位 a，为空则为 b。类似于三元运算符 ?? 可以结合 if let：1234// “，”表示与，需要同时满足不为空if let n = i,let m =j &#123;&#125;// “??”表示或，只要其中一个不为空if let n = i ?? j &#123;&#125; 结构体和类结构体 使用 let 定义的的结构体，其中 var 定义的属性也是不能被改变的。需要注意的是，结构体中包含引用属性，只要引用属性没有指向新的地址，那么改变引用属性中的属性是没有问题的。 如果我们自定义了一个结构体初始化方法，Swift 就不会自动生成默认初始化方法了 初始化方法可以放在 extension 中 当我们改变结构体中的某个属性的时候，结构体的 didSet 方法会被触发。因为结构体的属性改变导致新建了一个结构体。如果是类，则不会触发 数组是结构体，因此当我们改变数组中的某个元素时，数组的 didSet 方法也会触发 要改变结构体其中属性的值，需要在方法前加上 mutating 标识。加了标识的方法不能被 let 定义的结构体对象调用。 Swift 会自动将属性的 setter 标记为 mutating。因此，你无法调用 let 的 setter。 结构体的有一些方法有两个版本，比如数组的 sort() 和 sorted()，前者一类使用祈使动词短语的是 mutating 方法，在原对象上修改；后者返回一个新对象 mutating 关键字如何工作？它将隐式的 self 参数变为 inout 可变。 写时复制 Swift 中集合类型实现了写时复制，即赋值时两个集合指向内存中的同一个位置，只有在改变其中一个集合时，才会复制数组，再进行修改。这样能减少结构体频繁的复制操作带来的性能损耗 写时复制不是编译器的优化，而是要自己实现的。写时复制(昂贵方式) 对于自己实现的结构体，在方法中复制自己，然后对复制的对象进行修改返回 对于引用类型，需要将其包装在一个结构体内，作为一个私有属性。创建一个计算属性，get 方法创建这个引用类型的复制并覆盖原属性，然后返回。在需要写时复制的方法中操作计算属性即可。写时复制(高效方式) 上面存在的问题是，如果你对象只有唯一引用，还是会在修改前复制对象。我们需要先使用 isKnownUniquelyReferenced 函数来检查引用的唯一性。 闭包和可变性 Swift 的结构体一般被存储在栈上，而非堆上，这是 Swift 的一种优化。默认情况下结构体存储在堆上，绝大多数情况下，优化会生效，将结构体存储到栈上。但是当结构体变量被一个闭包引用的时候，优化失效，结构体将存储在堆上。因为如果存在栈上，当前作用域结束就会销毁，但是被闭包引用了，需要在未来的某个时候用到，所以必须要放在堆上。 函数inout 函数和可变方法 Swift 中 inout 参数前面使用的 &amp; 符号不是传递引用。事实上，inout 做的事是将值传回去，替代原来的值。 可以在嵌套函数的外部函数中使用 inout 参数，但是不能让 inout 参数逃逸。因为逃逸了就不知道应该什么时候复制回去了。 计算属性 延迟存储属性在第一次被访问时，闭包被执行。 延迟存储属性闭包中访问外部成员的时候要明确使用 self 我们可以将属性的 didSet 和 IBOutlet 配合使用，在 IBOutlet 被链接的时候运行代码，做一些视图配置。 自动闭包和逃逸闭包 使用 @autoclosure 标注自动为一个参数创建闭包。(我觉得这样代码可读性很差) 逃逸闭包需要加上 @escaping 标注，否则编译器不允许保存这个闭包。 字符串字符串和集合 String 符合 Collection 协议的所有要求，但是 String 不是一个集合。String 提供了 characters 这个集合访问字符串 数组上的切片不是 Array 而是 ArraySlice。而 String 的切片类型则是自身。 String 的内部结构 结构体 String 内部包含了一个 StringCore 类型的结构体，StringCore 包含了三个属性：_baseAddress 栈上或者堆上的位置；_countAndFlags 长度；_owner负责写时赋值和内存回收的对象。 字符串 split 不会做大量的拷贝，而是持有字符串某个切片。这会导致即使切片只有几个字符大小，还是会导致整个字符串内存无法释放。 CustomStringConvertible 如果想要自定义 print 的输出，可以在一个 extension 中实现 CustomStringConvertible 协议，重写 description 属性的 get 方法。 错误处理Result 类型 Result 类型和可选值非常类似。Result 类型也是两个成员组成的枚举，一个代表失败情况，并关联了具体的错误值；一个代表成功情况，它关联了一个泛型参数。 这样，对于可能抛出错误的方法，我们使其返回一个 Result 类型。然后判断到底是成功枚举还是失败枚举，然后取出关联值。 抛出和捕获 Swift 并没有使用返回 Result 的方式处理失败，而是将方法标记为 throws。Result 是作用在类型上的，而 throws 是作用于函数的。对于每个可以抛出的函数，编译器会验证调用者有没有捕获错误，或者把错误向上传递。 包含 throws 的函数是这样的： 1func contents(ofFIle filename: String) throws -&gt; String 处理的时候我们要将会抛出异常的函数标记为 try。try 的目的是为了强调调用者知道函数会抛出错误。 我们需要通过 do/catch 来处理错误，或者把当前函数也标记为 throws。如果使用 catch，我们用模式匹配的方式获取某个特定的错误或者所有错误，然后在最后 catch-all 中处理所有错误。在 catch-all 中，变量 error 可以直接使用： 12345678do &#123; let result = try contents(ofFile:"input.txt") pint(result)&#125; catch FileError.fileDoesNotExist &#123; print("File not found")&#125; catch &#123; print(error)&#125; 除了系统提供的错误，我们还可以自己定义错误类型。创建一个继承于 Error 的枚举： 1234enum ParseError: Error &#123; case wrongEncoding case warning(line: Int, message: String)&#125; Swift 的错误是无类型的，我们只将函数标记为 throws，但是没有指出应该抛出那个类型的错误。所以我们最好在函数定义的时候规范的加好注释。 错误和函数参数 在函数封装的时候可能会遇到一种情况：一个函数的函数参数可能会抛出错误也可能不会抛出错误。如果这个函数使用 try 调用这个函数参数，那么这个函数参数不会抛出错误的版本也需要加上 throws。 可以通过 rethrows 标记代替 throws。使用这个标记的函数还是需要对于函数参数使用 try，但是如果函数参数不会抛出错误，那么也不强制函数参数用 throws 标记了。 使用 defer 进行清理 Swift 中的 defer ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作） defer 类似于其他语言的 finally，但是 defer 不只是用于错误处理，可以将 defer 放在代码块的任意地方。 如果同一个作用域里使用多个 defer，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 defer 就能自然的先关闭连接，再关闭数据库。 错误和可选值 可以使用 try? 来忽略函数返回的错误，也就是说不用再 do-catch 了。 高阶函数和错误 在异步操作，比如回调函数中并不能使用 throws，因为这并不表示函数里执行的内容可能失败，而是指函数本生会失败。这个时候，我们就要使用 Result 替代了。 泛型泛型的工作方式 Swift 为泛型引入一个中间层，当遇到泛型类型的值时，它会将其包装到一个容器中。 对于泛型类型的参数，编译器维护了一系列一个或多个目击表，其中包含一个值目击表，以及类型上每个协议约束一个协议目击表。目击表将被用来将运行时的函数调用动态派发到正确的实现 任意的泛型类型，总会存在值目击表。它包含了指向内存申请，复制和释放这些类型的基本操作的指针(就是创建泛型类型实例的指针) 关于协议目击表，对于这个协议声明的每个方法或者属性，协议目击表中都含有一个指针，指向该满足协议的类型中的对应实现。在泛型函数中对这些方法的每次调用，都会在运行时通过目击表转换为方法派发。(每个方法属性都有对应指针) 协议目击表提供了一组映射关系，可以知道协议和具体的协议功能的映射关系。 泛型参数的容器只包含值存储，目击表被单独存储。这样泛型函数中同样类型的其他变量就可以共享这个目击表了 泛型特化 因为泛型是动态派发，所以会有一些性能损耗。不过 Swift 可以通过泛型特化的方式避免额外开销。 泛型特化指的是编译器按照具体的参数类型，将泛型类型或者函数进行复制。(就是在编译的时候，用会用到的特定的类型代替泛型) 协议 一个由关联类型的协议不能作为类型，只能作为泛型约束 当我们通过协议类型创建一个变量的时候，这个变量会被包装到一个叫做存在容器的盒子中。 对于普通协议，会使用不透明存在容器，不透明存在容器中含有一个存储值的缓冲区，一些元数据，以及若干目击表。 对于只适用于类的协议，会有一个叫做类存在容器的特殊存在容器。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中的网络框架]]></title>
    <url>%2F2017%2F09%2F19%2FiOS%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[最近在看巩固网络请求相关的知识。准备把 AFNetworking 以及基于 AFNetworking 的一些封装库看一看，了解一下原理。这一篇将探究一下 AFNetworking 的两个封装库 Casa 的 CTNetworking，以及猿题库的 YTKNetwork 的实现过程。 Casa 的 CTNetworkingCasa 关于网络架构的博客中主要讲了如何渔，没有分析他的鱼是什么样的。刚看的时候，我是一头雾水，相关的类目太多了，有些类还不太能够理解意图。进过一段时间的研究，现在明白了各个环节的作用，做一个整理。 初始化由于采用的是离散型的 API，每一个 API 都对应一个 APIManager，所以进行网络请求的时候，要分别初始化各自需要的 APIManager。初始化 APIManager 的时候，要设置一些 APIBaseManager 中的属性，如下图所示： 其中包括成功与失败的着陆点 delegate，提供参数的 paramSource，验证参数的 validator，以及拦截器 interceptor。它们都实现了各自协议。一般来说 delegate 是调用的 ViewController，paramSource 也是调用的 ViewController，validator 是 APIManager 自身，interceptor 是调用的 ViewController，validator 和 interceptor 都不是必须的。这些属性需要在初始化的时候设置好。 可以看到，其中还有一个实现 CTAPIManager 协议的 child 属性，所有派生的 APIManager 都必须实现 CTAPIManager 协议。网络请求所需的 API 名，服务类型，请求类型以及是否缓存 (是否缓存其实没必要作为必须的方法吧，默认不缓存，要缓存的子类实现就好了啊) 都需要通过这个接口中返回： 所以现在的继承关系应该是：APIManager 继承于 CTAPIBaseManager，并且实现协议 CTAPIManager。基类本生并不实现协议。 那么为什么基类不直接提供协议中的方法，而是要以协议的方式获取呢？协议的特点就是提供接口规范。对于这些必须实现的方法，确实是可以通过在基类中抛出异常来强制子类重写，达到目的。但是这有两个缺点，一个是不直观，调用者不能立即知道需要重写哪些方法。另一个缺点是，可能有些方法忘记了重写，这样只有在运行的时候才会抛出异常，但是使用协议，如果没有完全实现必须的方法，编译都无法通过。 因此，在初始化的时候要先判断派生类是否实现了 CTAPIManager，没有实现的直接抛出异常。 基本流程在创建了 APIManager 的实例后，调用其统一的方法 loadData 来开始网络请求。基本流程如图所示： 首先是获取参数。一般情况下，我们是在网络请求的时候将参数一并传过去，而这里需要你将实现了 CTAPIManagerParamSource 协议的类作为数据源，实现其获取数据的方法，通过 manager 的不同来区分不同 API： 重组参数 reformParams:，并不是一个必须的方法，默认返回原参数。子类可以重写该方法在调用 API 之前额外添加一些与业务逻辑无关的参数，比如 pageNumber 和 pageSize 之类的。 拦截器不是必须的，所以调用拦截器方法前，先要判断一下是否有拦截器。拦截器是和业务逻辑有关的，所以一般是 ViewController，其需要实现 CTAPIManagerInterceptor 协议。这个协议中包含了很多拦截方法，包括调用 API 之前之后，请求成功之前之后，请求失败之前之后的回调方法。当前调用的是 manager:shouldCallAPIWithParams: 方法，用来检测此 manager 是否能以该 params 调用网络请求。如果允许调用 API 则进入下一步，如果不允许，直接结束请求(你也可以在不允许的时候设置走到失败回调)。拦截器一般用来展示和隐藏菊花~ 接下来是验证器，用来验证请求数据以及返回数据的合法性。验证器是和业务无关的，所以一般交给 APIManager 就行了。在 API 调用前，验证器一般用来在 API 调用前验证参数是否符合规则，比如手机号啊，邮箱啊之类，避免无效的 API 请求，加快响应速度。如果验证失败了，直接走失败回调，将CTAPIBaseManager 中的 CTAPIManagerErrorType errorType 属性设置为 CTAPIManagerErrorTypeParamsError 表示参数错误。 接下来询问子类 APIManager 是否要从本地获取数据。如果可以从本地获取，那么从 UserDefault 中取出数据。如果有数据，那么在主线程中执行成功回调，如果没有数据，那么设置 isNativeDataEmpty 标识位 YES，这个标识位后面会用到。 注意到，这里即使从本地加载了数据，也不会直接 return 而是要继续进行网络请求的。这里的逻辑是可能存在一些 API 获取到数据后不会立即展示，而是保存起来，展示上次保存的数据。比如首屏广告图片。 接下来询问是否可以缓存，如果子类没有实现这个方法，那么从 CTNetworkingConfigurationManager 这个配置中心获取。（这里不太对，因为 shouldCache 是 APIManager 协议中定义的必须实现的方法方法，所以不会存在从配置中心读取这一步。其实最好还是直接设置成可选方法，在 base 中提供个默认实现。） 如果这个 API 可以缓存，那么再通过 serviceType，methodName 以及 requestParams 组成的字符串，使用 CTCache 这个单例去查看本地是否有数据。取出一个自定义的 CTCachedObject 类型。这个类型保存两个 NSData 对象，一个是缓存的数据 content，一个是缓存的时间 lastUpdateTime，因为要判断是否超过了缓存的时间。如果既有缓存内容，缓存还没有超时，那么拿出来，在主线程中执行成功回调。 不论是从本地还是从 Cache 都使用了生成了一个返回实例的封装 CTURLResponse，这个封装里有一个标识符 isCache，表示非网络请求得到的数据，以此和网络请求数据进行区别。它提供了三个初始化方法，上面两个是网络返回成功和失败的初始化的方法。最后一个 initWithData: 就是刚才说的本地数据的初始化方法。 如果没有缓存，那么就要执行网络请求了。但是在请求前，还需要检查一下网络情况。在上面的配置中心(CTNetworkingConfigurationManager，关于配置的都扔在这里)还提供了一个方法调用 AFNetworking 的方法，只要不是明确的无网络 NotReachable 就返回 YES。如果无连接，那么执行失败回调， errorType 为无网络连接。 最后，发送网络请求前，将 APIManager 中的 isLoading 标志位置为 YES，表示正在进行网络请求。这个的作用是在某些 API 中可以防止重复发送请求。比如翻页，就可以判断 isLoading 的状态来执行不同的请求策略。 网络请求网络请求大致分为两步，第一步是生成一个 NSURLRequest，第二步就是执行。整个过程在 CTApiProxy 中进行。 生成 Request生成 Request 的主要过程在 CTRequestGenerator 中完成。 在开始前，我们先要知道 CTService 是个什么东西。来看一下它的构成： 主要定义了公钥、私钥、根 Url 以及 API 版本。根据这个 CTService 可以派生出各种 service，每一个 service 都有自己的 apiBaseUrl。所以 CTService 的设计是用于描述第三方API的相关配置和信息的。如果没有第三方 API，只要创建一个自身的 Service 就行了。 另外我们看到，同 BaseAPIManager 一样，CTService 也有一个 child。它实现了 CTServiceProtocol 协议： 将 CTService 中的几个属性分为了线上和线下版本。所有实现该协议的类都需要定义这些属性的 get 方法。事实上，我们定义的子类不需要设置 CTService 的几个属性。它会自动根据当前环境 isOnline 进行选择，isOnline 可以统一读取配置信息中的设置。例如： CTServiceProtocol 定义了几个需要实现的读写方法。CTService 不实现 CTServiceProtocol 协议，但是实现了协议中的读写方法，这样 CTService 的子类就不需要再重复写读写方法了。CTService 的子类要做的就是提供 CTServiceProtocol 中定义的几个属性。相关逻辑就会通过 CTService 中提供的读写方法获取这几个属性值了。 由于可能有多个 service，并且如果每次都创建 Service 太损耗性能，所以就提供了一个工厂 CTServiceFactory 用于统一管理保存所有的 service。APIManager 通过 serviceType 字符串表示其属于哪个 service，即要创建的 service 类型。因此，我们需要一个 serviceType 和 CTService 的映射表。这个映射表由一个实现了 CTServiceFactoryDataSource 协议的类提供。一般我们将 AppDelegate 设置为这个 DataSource，提供 type → Service 的映射。 回到主流程。先到 CTServiceFactory 中查看是否已经存在相应的 Service。如果不存在就要通过映射表找到对应的 Service 类，创建一个。 得到 Service 后，就可以进行完整 url 的拼接。这一操作也是由 CTService 完成的。因为不同 Service 可能有不同的拼接规则。 之后添加额外的参数。这个参数不是业务级的，也不是接口级的，而是 Service 级的，即所有该 Service 都需要传递的参数，比如 token 之类的。 调用 AFNetworking 提供的方法，传入 url、参数和请求类型，创建一个 NSURLRequest 实例。 有一些 Service 需要添加自己特有的 header。因此，调用 CTService 中的方法，为不同 Service添加 header。 Request 本生是没有请求参数这个属性的。但是我们想把请求参数保存起来，因为某些情况下，在成功失败回调的时候可能需要用到请求参数。所以我们需要为 NSURLRequest 添加一个分类，用于保存请求参数。 现在 Request 生成完毕 执行 Request 执行过程清晰了很多。通过上面创建的 Request，创建一个 NSURLSessionDataTask 的实例 dataTask。然后通过拿到该 task 的 taskIdentifier 作为这个请求的 requestId。在 CTApiProxy 中保存了一个 dispatchTable 字典，用于存储 requestId 对应的 dataTask。接着执行这个 dataTask，再将 requestId 一层层传出，CTAPIBasemanager 中有一个保存这些 id 的数组 requestIdList。这个 requestId 的用处在于通过这个 requestId 可以随时取消请求。取消的时候通过 requestIdList 中的requestId 找到 dispatchTable 中的 NSURLSessionDataTask 实例，然后调用其 cancel 方法。 但是要注意，当 API 请求速度非常快的时候，APIManager 并不能确保当前正在进行的请求所对应的 requestId 的正确性。所以如果要取消请求的时候，最好 cancelAll，而不是只取消某一个。 回调统一的回调过程在完成了 dataTask 的执行后，会由 APIProxy 执行统一的回调过程。回调会传入响应信息 NSURLResponse *response，响应体id responseObject，以及错误 NSError *error。因为请求已经完成，所以移除 dispatchTable 中相应的项。如果出错了，那么生成一个出错的返回对象 CTURLResponse，如果没有出错，那么生成一个正确的返回对象 CTURLResponse，然后将这个 CTURLResponse 传入由 CTAPIBaseManager 传入的成功失败回调。对于响应信息的日志打印，也是在这里完成。 CTURLResponse 没有什么特别的方法，只是添加了一些标识属性，比如前文说到的 isCache，以及 requestId，error 等，还有就是数据。反正你想让回调方法知道的东西都放在这里就可以了。 成功回调成功回调在 APIManager 中进行，除了调用 ViewController 中提供的成功回调外，主要用来保存数据、验证以及拦截。流程如图： 首先是要保存数据到本地，这要求该 API 允许从本地获取数据并且响应结果来自于网络，也就是上面所说的 isCache 为 NO。这种情况下，用 NSUserDefaults 保存网络端传来的响应数据。 前面在网络请求完成时删除了 dispatchTable 中的 requestId 和 dataTask 的键值对。现在要删除 requestList 保存的 requestId。 由于每个 API 都有一个 Manager，所以现在没有必要将数据交给 ViewController 保管了。在 BaseManager 中，定义了一个 id fetchedRawData 专门保存原始的返回数据。 之后是验证器对于返回结果正确性的验证。一般是对于返回状态是否正确、某些特定字段是否为空的判断。这些都由 APIManager 来完成。如果失败，则直接走失败回调，并且设置相应的错误类型。 除了保存到本地就是判断是否要缓存。同样的要判断是否能缓存，以及数据是否来此网络。如果可以，调用 CTCache 的相应方法更新缓存。 接下来就是在最终成功回调前的拦截。拦截分为内部拦截和外部拦截。在 base 中定义了 beforePerformSuccessWithResponse: 方法，会调用拦截器的相应方法。如果要实现内部拦截，需要子类重写该方法，并且要调用 super 方法。成功回调后的拦截也是相同的道理。 最后要说的就是成功回调了。这里要强调一下，并不是所有网络请求都要走最终的成功回调的（至少在本文这个情景下是这样的）。 else 的逻辑，不是从本地获取的，那么直接成功回调没有问题。那么从本地获取的数据再分这两种情况，有何用意呢？前面说过，从本地加载的数据成功后会有一次成功回调，之后并没有结束网络请求，而是继续请求新的数据去了。从网络获得数据后又会产生一个成功回调。这里就要把后面这个成功回调屏蔽掉。所以这里先判断是否应该从本地拿数据。如果是，那么就面临着两次回调的情况。本地数据的成功回调是应该执行的，另外本地没有数据时从网络端拿数据也是应该执行的。而本地存在数据，又从网络端拿到的，是不能执行成功回调的。（具体还需要根据实际业务做相应调整的） 失败回调失败回调较为简单，但是和我们平时写的不一样。由于框架中有很多地方主动调用了失败回调，比如拦截器、验证器发起的失败回调。所以我们需要根据错误类型，先做一些处理。 CTServiceProtocol 中提供了一个可选方法 shouldCallBackByFailedOnCallingAPI:，用来集中处理 Service 层的错误，比如 token 失效。我们就可以在 Service 中实现该方法，在其中发出通知。处理完错误后，直接 return，不再继续执行。 所以总的来说，分为三层，Service 层，APIManager 层和业务层，每一层都能进行处理。 Q&amp;A链式请求如何处理链式请求？一般我们都是在成功回调后拿到数据，然后再进行下一个请求。如果存在多个请求，那么这个成功回调会嵌套的非常长。进行的改进就是争取将各个请求从回调中取出。我们可以将每一个回调放在一个专门的类中： 如图所示，为每一个请求链上的 API 创建一个 Command 类。这个 Command 类是对 APIManager 的一层封装，ViewController 中不再直接调用 APIManager 中的 loadData 方法，而是调用 Command 中提供的 execute(名字叫什么不重要)表示我发起了一个请求链。将 Command 设置为 APIManager 的 paramSource，delegate。APIManager 先执行 Command 的回调。Command 中提供了一个同为 Command 类型的 next 属性，这就是请求链的下一级。在 Command 的回调中，判断 next 是否为空。当存在时，如果下一级要依赖上一级返回的结果作为参数，就将下一级的 paramSource 设置为上一级，然后通过 [self.next execute] 执行。如果不存在，那么调用 delegate（一般是 ViewController）的完成回调，表示请求链结束。 使用的时候为每一个 Command 设置 next 即可： 12345678910// ViewController 中API1Command *api1 = [[API1Command alloc] init];API2Command *api2 = [[API2Command alloc] init];API3Command *api3 = [[API3Command alloc] init];api1.next = api2;api1.paramSource = self;api1.delegate = self;api2.next = api3;api3.delegate = self;[api1 execute]; 这样做有一个优点，就是有些时候，下一级的网络请求并不依赖于 VC，而是从上一级网络请求直接获得。这样，我们就可以直接设置 next 的 params，而不需要让 next 继续问 VC 要数据了。上面的代码示例里也是这样。首先建立调用链 api1→api2→api3，api1 和 api3 需要执行 VC 中的回调，就设置其 delegate，api2 和 api3 都不需要 VC 作为 paramSource，所以就不设置了。 这种新建 Command 的好处是，把 delegate，paramSource 做的事放到了 Command 里，不需要在 VC 中处理了。但是这样也带来一个问题就是每个 APIManager 都需要创建一个创建一个与之对应的 Command，导致类目增多。当然，这是不可避免的，毕竟这些 delegate，paramSource 的方法总是要有一个地方放的。 另外，最好不要将 next 放在 APIManager 中，这样会污染 APIManager。 等待视图在哪实现等待视图的展示和隐藏在 interceptor 的请求开始前和请求结束后调用。我们应该将加载框设置为一个单例，其中维护一个计数器。当请求开始的时候计数加一，请求结束的时候计数减一。计数器要加锁，因为 API 是异步的。 paramsource 是谁？一般我们的 paramsource 设置为 VC。但是如果不涉及业务上的数据，可以直接设置为 APIManager。 如何分页将页数保存在 APIManager 中。每次我们要加载下一页的时候使用 loadNextPage 方法即可，不需要 VC 管理请求页了。 关于实现，实现方式应该是这样的。首先在 APIBaseManager 中定义一个 pageNo 属性，设置默认值为 1，表示第一页；一个 pageSize 属性，设置默认值为 10。然后还定义 reloadData 方法，它的默认实现就是将 pageNo 置为 1，然后调用 loadData。 再定义一个协议 PageProtocol，声明可选的 pageNo 和 pageSize 属性，再声明一个可选的 reloadData 方法，以告诉使用者可以使用。 对于要分页的 API，在 loadData 方法中的重组参数方法中，将当前 pageNo 传入。在 APIBaseManager 中的内部拦截器中，判断当前 APIManager 是否实现了 PageProtocol 协议，实现了，就把 pageNo 加一。 requestId 的用处requestId 设计出来是为了针对 request 的控制留有余地用的，但是现在在工程中用的很少。所以还不如像 YTK 那样，保存 dataTask 就行了。 CTService 的设计意图Service 是用来接入第三方 API 的。对于第三方的 API，就创建一个全新的 Service。 简单总结一下，大致分为三步： 每个 API 都有一个 APIManager，其中有 ServiceType，interceptor，delegate，validator，paramSource 等属性。在正真的数据请求前，先对请求参数做一些处理，比如添加 pageNum 等，然后在其中经过一系列的判断，包括 interceptor，validator，是否有本地缓存，是否有 cache 等，涉及到具体的策略。然后进行网络请求。 网络请求通过 APIProxy 完成，它需要 APIManager 提供各种网络请求需要的东西，包括请求参数，请求名，请求类型，ServiceType。它先用这些参数，通过 CTRequestGenerator 创建 Request。创建 Request 的过程是根据 APPDelegate 中定义的对照表，用 ServiceType 在 CTServiceFactory 中找到正真的 CTService 实例，然后获取一些 Service 层面的参数，比如 baseUrl，Service 层的参数等。最后通过 AF 提供的 AFHTTPRequestSerializer 的方法生成 NSURLRequest。 最后 APIProxy 就要发起请求了。还是通过 AF 的方法生成 dataTask，并开始。将 dataTask 和网络请求返回的 requestId 以字典的方式保存起来，又将 requestId 返回给 APIManager 保存。然后等待回调。回调先将 APIProxy 的字典中相应键值对删除，然后删除 APIManager 的数组中的 requestId 删除。 猿题库的 YTKNetworkYTKNetWork 同样是一个 star 数非常高的网络框架，它也是基于离散型 API 完成的。同样的来解析一下 YTK 封装的基本流程。坦白说，CTNetworking 真的很折腾，类目很多，对第一次看的人很不友好。YTKNetwork 则简单了许多，总共也就十来个文件。 基本流程YTK 没有了那么多的 delegate，没有了重组参数，没有了验证器，拦截器，只有关于缓存的讨论。因此，它的主流程也显得简单了许多： 首先这个过程基本都是在 YTKRequest 中完成的，基本类比于 APIBaseManager，所有的 API 都继承于它。第一步判断是否忽略缓存，这是各个 API 需要设置的属性。默认为不缓存。 然后判断是否有下载路径。也就是各个 API 是否实现了提供下载路径的方法。如果有下载路径，那么就得发送网络请求。 最后是判断是否能够读取缓存。先获取各个 API 设置的缓存时间，如果没有设置，那么就得发送网络请求。然后尝试读取缓存数据的元数据。元数据包括缓存的缓存时间，APP 版本号，敏感信息等。这些都要分别判断是否和当前一致。如果没有元数据，或者元数据不符合要求的都得进行网络请求。 如果以上都没有问题，那么执行成功回调，将整个 API 作为参数返回。但是其中任意一个不满足，就会要发送网络请求。发送网络请求前有一个执行准备方法的机会，类似于 interceptor。 网络请求YTK 的网络请求由 YTKNetworkAgent 完成，类比于 ApiProxy。不过不同的是，YTK 的这个 Agent 做了所有的事，并且包含了文件下载。而 Casa 的 Proxy 则结合 CTService 以及 CTRequestGenerator 添加了更多的参数配置。YTK 网络请求过程如图： 首先，YTK 允许使用者自己提供 NSURLRequest 的实例。所以判断使用者是否使用了 Request。如果没有提供，那么需要帮使用者创建一个 Request。 创建的时候首先是对 detailUrl 的修改。YTK 提供了一个 YTKFilterProtocol，实现了这个协议的类可以对 YTKRequest 提供的 detailUrl 进行一定的修改。 之后还可以修改 baseUrl。这一过程主要是判断是否使用了 cdn，如果使用了 cdn，那么切换到 cdn 的 baseUrl。这个方法是每个 YTKRequest 选择实现的。 AFConstructingBlocks 是 AFNetwork 中的属性，它一般是在上传文件的时候使用。由 YTKRequest 选择完成它的创建。比如下例中将一张图片以 Content-Type 为 image/jpeg 的形式上传： 准备工作结束，创建 Request 前还需要检查一下该请求是否是一个下载请求。还是 YTKRequest 提供的可选实现的方法，如果提供了下载路径就表示是一个下载请求。下载的请求涉及到判断路径上文件是否存在，是否可以继续下载等，会通过 AFNetworking 创建一个站稳的 dataTask 类:NSURLSessionDownloadTask，所以必须专门创建一个下载请求的 dataTask。 不是下载请求的情况下，将上面准备的各种传给 AFNetwork，生成一个 Request。之后再将这个 Request 传给 AFNetwork，得到一个 dataTask。 之后设置 dataTask 的优先级。这个一般也没有太大用处啦。 在执行前，dataTask 肯定是要保存起来的，一来为了方便取消，二来为了到时候能拿到请求的参数等数据。Casa 的实现方式是将 dataTask 保存在 APIProxy (对应 YTKNetworkAgent)中，以键值分别为 requestId 和 dataTask 的字典的形式保存，然后将 requestId 以数组的形式又保存在了各个 APIManager(对应 YTKRequest) 里。每发送一次请求，数组添加一个 id。VC 可以拿着 id 调用 APIManager 的相关方法来取消请求。 YTK 将 dataTask 直接保存在了 YTKRequest (对应 APIManager)中。虽然也是通过 requestId 和 dataTask 的键值对的方式保存，但是取消并不是以 id 为标识来取消的，而是以 YTKRequest 为标识取消的。VC 调用 YTKNetworkAgent 的取消方法取消请求。所以 YTK 中每次网络请求，都需要实例化一个 YTKRequest。相关过程如图所示： 不过就算一个 APIManager 能发多个网络请求了，最后的返回结果还是只有一个并且是会被覆盖的，所以这种保存 requestId 数组的方式并不比每个请求实例化一个 YTKRequest 好。 最终通过 dataTask 的 resume 就可以开启任务了。 回调统一的回调过程YTK 的统一的回调过程在 YTKNetworkAgent 中完成。主要做了两件事，首先通过 requestId 移除保存的 dataTask。其次，将返回的结果设置为 YTKRequest 的属性，并验证器有效性。 验证有效性的过程就是在 YTKRequest 中提供一个结果的模板，然后比较返回结果和模板的形态是否相同。总的来说就是一个递归验证的过程，就不多赘述了。 成功回调YTK 的成功回调主要过程就是写入缓存，相比较 CTNetworking 根据需求设置的较为复杂的判断逻辑要直接了许多：就是如果要缓存那么就缓存。 这个成功回调还是在 YTKNetworkAgent 中实现的。在允许缓存并且是从网络获取的情况下写入缓存。这两步也没有太多可以说的。写入缓存也是正常操作。关于创建元数据，前面也说到过了，写缓存的时候一并创建元数据并保存起来。最后的拦截以及成功回调和 CTNetworking 类似。 这里成功回调仍然是在 YTKNetworkAgent 进行，相比较 CTNetworking 交由 APIManager 处理，这样少了一些定制性。 失败回调YTK 对于失败的回调基本完全是给到使用者处理了。在失败回调中做的一件事就是对于下载失败的情况，删除未完成的下载项，并将这些数据保存在一个未完成的路径中。 批量请求与链式请求批量请求批量请求要做的是同时开始多个请求，在最后一个请求完成的时候回调处理方法。YTK 提供了批量请求的封装 YTKBatchRequest。虽然也叫 Request，但是它并不继承于 YTKRequest。而是保存了 YTKRequest 的一个集合。 简单来说，它的实现方式就是初始化的时候传入一个 YTKRequest 的集合。在调用 YTKBatchRequest 的 start 方法开始请求的时候，将每个 YTKRequest 的 delegate 都设置为当前的 YTKBatchRequest。这样在每一个请求返回的时候，都会走到 YTKBatchRequest 的处理方法中。 然后 YTKBatchRequest 中为完成的请求计数。当完成的请求小于总请求时，回调方法直接 return。只有当完成的请求等于总请求时，表示全部请求完成，此时执行成功回调。 如果其中有任意一个请求失败了，那么在失败回调中立即为每一个 Request 调用 cancel 方法，取消所有请求。 以上就是批量请求的实现。非常简单。 链式请求YTK 为链式请求提供了一个 YTKChainRequest 类，同样要求在初始化的时候传入一个 YTKRequest 的数组。在调用 YTKChainRequest 的 start 方法开始请求的时候，将第一个 YTKRequest 的 delegate 设置为当前的 YTKChainRequest。这样在请求返回的时候，都会走到 YTKChainRequest 的处理方法中。 除了 YTKRequest 的数组，创建的时候还需要传入一个回调闭包的数组。这样，在每个请求完成后，依次执行回调闭包中的方法。 如果其中一个请求失败了，那么执行自定义的失败回调即可。 和 CTNetworking 比较，这样的处理方式比较直接，但是不够优雅。 总结CTNetworking 和 YTKNetwork 都是离散型 API 的实现。不过我认为 CTNetworking 的实现方式更为优雅。以协议的方式明确职责，引入 delegate，validator，interceptor，让定制化程度更高，并且减轻了 VC 的负担。引入 CTService 让多服务接入验证变得简单。但是反过来说，这也一定程度上提高了学习成本。并且 CTNetworing 并不支持上传与下载文件。其缓存策略也需要使用者根据实际需求做一定的改写。相比较而言，YTKNetwork 的功能就更纯粹了一些，专注于网络请求，在缓存与下载方面做了充足的处理。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 单元测试]]></title>
    <url>%2F2017%2F09%2F09%2FiOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[对于单元测试一直都是轻视的，但是好的单元测试对一些低级错误的检测还是非常高效的。这里收集一下单元测试的使用方式。 单元测试的好处主要在于，如果一个项目比较大，或者某个功能改动比较多，那么你可能顺手改掉了某些零碎的东西，比如某个配置，但是这个错误又不容易被发现。有了单元测试，当你改掉某些东西的时候，立马就会显示出来。 结构可以通过 new 的方式创建一个 iOS Unit Testing Bundle target。可以看到默认创建了一个单元测试文件： 其中，。这个测试文件继承于 XCTestCase，并且提供了几个默认的方法： setUp 表示在进行测试方法前的准备工作。 tearDown 表示测试方法后的善后工作。 testExample 是一个具体的测试方法，所有的测试方法都必须以 test 为开头。Xcode 会识别到，在其前面的代码行数区域就会有一个小方块，可以执行，执行成功就是如图所示。 testPerformanceExample 表示测试性能，在这个闭包中写入要测试的代码。 引入目标我们可以自己创建单元测试文件。对于你要测试的类，你需要引入目标文件，你需要在 import 前加上 @testable 标注： 1@testable import TargetClass 开始测试在左面板的测试导航栏，可以看到所有的测试方法，你可以邮件运行所有方法，也可以单独运行其中一个方法。当然，你也可以在每个测试文件的测试方法前的代码行数处看到一个小方块，也可以点击这个小方块开始测试。 测试断言测试肯定需要断言的，不然怎么知道测试是否成功呢。常用断言有以下： 12345678910XCTAssert(expression, format...)XCTFail(format...)XCTAssertTrue(expression, format...)XCTAssertFalse(expression, format...)XCTAssertEqual(expression1, expression2, format...)XCTAssertNotEqual(expression1, expression2, format...)XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)XCTAssertNil(expression, format...)XCTAssertNotNil(expression, format...) 这些断言的意思还是比较好理解的。 性能测试性能测试可以设置基准时间，最大允许的标准差，超过这个标准差，就表示性能测试不通过。具体设置如图所示： 点击性能测试前的灰色小方块，就会出现一个弹框，然后在其中设置即可，包括 baseline 和 Max STDDEV。 测试断点我们知道异常有异常断点。测试失败也有断点。还是老地方设置： 异步测试测试代码一般执行完就结束了。像网络请求等异步操作需要特殊的方式。 12345678910111213141516171819// 异步测试: 成功块，失败慢func testValidCallToiTunesGetsHTTPStatusCode200() &#123; let url = URL(string: "https://itunes.apple.com/search?media=music&amp;entity=song&amp;term=abba") let promise = expectation(description: "Status code: 200") let dataTask = sessionUnderTest.dataTask(with: url!) &#123; data, response, error in if let error = error &#123; XCTFail("Error: \(error.localizedDescription)") return &#125; else if let statusCode = (response as? HTTPURLResponse)?.statusCode &#123; if statusCode == 200 &#123; promise.fulfill() &#125; else &#123; XCTFail("Status code: \(statusCode)") &#125; &#125; &#125; dataTask.resume() waitForExpectations(timeout: 5, handler: nil)&#125; 这里的 expectation() 方法返回一个预期对象。然后通过 waitForExpectations(timeout:handler:) 方法设置一个超时时间，执行到这句的时候就会等待预期对象的到来。所以在异步的成功回调中调用 fulfill() 方法，表示预期对象到来了。这样代码就执行完了。只要不是通过断言抛出的错误，或者超时，都表示测试成功。 注意，waitForExpectations 是暂停，也就是说，这个方法后面的方法会先不执行，等到 fulfill() 后再执行。所以，一般我们可以把判断的断言放在这个方法之后。 方法命名测试方法必须要以 test 为头，方法命名要把这个测试方法的功能讲清楚，不需要使用驼峰式命名，用下划线隔开即可。如： 1func test_weatherDataAt_handle_statuscode_not_equal_to_200() &#123;&#125; 测试私有方法和属性我们不能直接获取到私有的方法或者属性，但是我们可以通过 category 暴露私有方法和属性： 1234@interface JHSTestDataSource (UnitTest)- (NSInteger)getSellGroupCount;- (BOOL)needShowHeader:(NSInteger)section;@end 最后关于如何 mock 数据，OC 中提供了 OCMock 这个库，可以通过 runtime 将方法返回的结果替换。但是 Swift 由于是静态语言，并不能提供支持。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何配置应用的环境变量]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[一般的项目中多个环境的切换，都是依靠修改代码。但是这样的做法不够优雅，我们其实可以通过两种更好的方式去实现。 使用 Build Configuration 配置系统默认有两个 Configuration，一个是 Debug，一个是 Release。如果要多环境切换的话就需要我们自己创建 Build Configuration。 新建 Build Configuration在 Project 的 Configuration 中选择 Duplicate &quot;Debug&quot; Cofiguration，添加一个 Bebug 模式的 copy。将其改名为 OnlineDebug，之后它将被用于线上环境的 debug： 如果使用 Cocoapods，那么添加新的 Configuration 后必须执行 pod install。pod 会为新的 Configuration 生成 xcconfig 文件： 添加了这个 Configuration 后，在 Build Setting 中就多了一个 OnlineDebug 的配置： 修改 Build Setting创建好了新的 Configuration，我们要用它干什么呢？我们可以在 Build Setting 中根据不同的 Configuration 设置不同的参数。比如我们可以针对不同的 Configuration 设置 target 的 Build Settings(注意是 target 不是 project，为什么后面再说) 中的 Product Bundle Indentifer 以及 Product Name 。这样安装的时候就会按照配置更换 Bundle ID 和 名字： 不仅如此，我们还可以自定义一些设置。这次我们回到 project 的 Build Setting 中去，点击 Add User-Defined Setting: 之后就会在 Build Setting 底部的 User-SETTING 一栏添加了一个 NEW_SETTING。举个例子，我们将其改名为 CustomProductName，然后修改各个 Configuration 对应的值： 这样我们就可以在其他地方使用这个 CustomProductName 了。 虽然我们是在 Project 中修改的，但是打开 target 的 Build Setting，可以看到，在其中也添加了一个 CustomProductName: 修改 info.plist 文件info.plist 文件中保存着许多应用的配置信息： 比如上面的 Bundle Name 对应的值 $(PRODUCT_NAME)，就表示 Build Setting 中的 Product Name 这一项。其实可以直接在 Build Setting 中设置 Product Name 的，但是由于上面我们是自定义了一个 CustomProductName，所以我们这里将其改为 ${CustomProductName}(用小括号和大括号是一样的，参考)。运行一下发现 App 的名称确实和 CustomProductName 配置的一样。 其实 info.plist 也是可以在 Build Setting 中设置的，我们可以自己创建诸如 myInfo.plist，yourInfo.plist 等文件，只要设置好其索引就行： 新建 Scheme现在我们如果要切换 Configuration，需要在 Edit Scheme 中切换 Build Configuration: 这样每次 Run 都需要多点几下比较麻烦。既然在一个 scheme 中修改比较麻烦，那么我们为什么不新建多个 Scheme 呢？ 我们选择 New Scheme 后，会弹出如下对话框，选择正确的需要运行的 Target，然后给新的 Scheme 取一个名字 TestConfigurationNew: 新建号 Scheme 后，我们选择 manage scheme 查看: 看到有两个勾选项，一个叫 show，一个叫 shared。show 选项勾上后，就可以在上图的位置显示以及能被选择运行，否则就隐藏起来。shared 选项表示是否将 scheme 共享给别人。如下图所示，如果我们不为刚刚创建的 TestConfigurationNew 勾上，那么该 scheme 生成的 TestConfigurationNew.xcscheme 文件将会保存在 zachary.xcuserdatad 文件夹下，别人的 xcode 是无法识别的。但是如果你勾上了 share，那么就会像下面那样显示在 xcshareddata 文件夹下。这也告诉我们，在写 gitignore 的时候，可以忽略 xcuserdata 文件夹内的文件，但是一定不能忽略 xcshareddata 内的文件。 现在我们新建了 TestConfigurationNew 这个 scheme 后，就可以为每个 scheme 设置单独的 Build Configuration。每次 Run 的时候，切换 scheme，而不是切换 scheme 中的 Configuration。 分环境的比较好的方式上面的方式是新建一个 scheme，然后在 debug 模式下对应的 Configuration 是 OnlineDebug，但是其 Archieve 对应的还是 release。那么如果想要针对 OnlineDebug 的环境打一个 release 包，该怎么办呢？我们需要再 Deplicate release Configuration，然后将其命名为 OnlineRelease: 然后，将 TestConfigurationNew 的 archieve 中的 Build Configuration 改为 OnlineRelease: 也就是说，每一个环境都应该有其对应用 debug 以及 release 的 Configuration： 配置和获取环境变量说了半天添加 Configuration，那么到底和区分环境有什么关系呢？有两种方式可以处理。 使用预编译宏我们进入 Project 的 Build Setting，其中的 Preprocessor Macros 可以添加一些环境变量的宏来做标识符，比如添加 ONLINE 和 OFFLINE 标识符，来区分线上和线下环境： 现在，你就可以这样设置环境了： 12345678910#ifdef ONLINE#define searchURL @"http://www.baidu.com"#define sociaURL @"weibo.com"#elif OFFLINE#define searchURL @"http://www.bing.com"#define sociaURL @"twitter.com"#else#define searchURL @"http://www.google.com"#define sociaURL @"facebook.com"#endif 使用 plist 文件动态配置除了使用宏，还可以读取 plist 里的配置信息。我们可以为每一个 Configuration 提供一个 plist 文件，将配置信息分别写入。由于一个文件夹内不能有同名的文件，所以我们为每一个 Configuration 的 plist 都创建一个文件夹： 然后在 target 的 build phase 中添加 New Run Script Phase，将其命名为 Copy Configuration: 在其中添加如下 shell 脚本： 1234567echo "CONFIGURATION -&gt; $&#123;CONFIGURATION&#125;"RESOURCE_PATH=$&#123;SRCROOT&#125;/$&#123;PRODUCT_NAME&#125;/config/$&#123;CONFIGURATION&#125;BUILD_APP_DIR=$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;PRODUCT_NAME&#125;.appecho "Copying all files under $&#123;RESOURCE_PATH&#125; to $&#123;BUILD_APP_DIR&#125;"cp -v "$&#123;RESOURCE_PATH&#125;/"* "$&#123;BUILD_APP_DIR&#125;/" 这个脚本的目的就是将根据 Configuration 复制不同 config 文件夹下的文件，到 xxx.app 的根目录下，也就是 mainBundle 下。 读取配置文件的时候，可以根据文件路径获取： 123456- (NSString *) readValueFromConfigurationFile &#123; NSBundle *bundle = [NSBundle mainBundle]; NSString *path = [bundle pathForResource:@"Configuration" ofType:@"plist"]; NSDictionary *config = [NSDictionary dictionaryWithContentsOfFile:path]; return config[@"serverURL"];&#125; 除了 plist，我们也可以用这种方法配置不同的文件。 上面提到的几个概念上面一会儿修改 project 的 Build Setting，一会儿修改 target 的 Build Setting。一会儿添加 Configuration，一会儿又添加 Scheme 的。那么这些概念到底是什么意思呢？ Scheme，Configuration 以及 Target这三者的关系，用 Edit Scheme 就可以表现的一目了然： 可以看到，Scheme，就是同意调配 Configuration 以及 Target 的，也就是让哪个 Target 对应于 哪个 Configuration。 .xcconfig 和 Configuration我们可以看一下一个非官方的 xccofig 的教程(这个教程对于 xcconfig 介绍的非常好)中的一句话： A xcconfig file is used as a supplemental file to a specific build configuration. A build configuration can have an associated xcconfig file, this allows for additional changes to the target’s build settings from outside the Xcode project editor. 意思是一个 Configuration 可以有一个与其相关联的 xcconfig。xcconfig 可以使我们能够不在 Xcode 的提供的编辑器中编辑 Build Setting。 对于一个没有使用 Cocoapods 的项目，其 Configuration 下 Based on Configuration File 都是 None，因为我们直接修改 Build Setting 就可以了： 但是使用了 Cocoapods 的项目，在 pod install 后，会自动为每一个 Configuration 生成一个 xcconfig。因为 Pod 不能直接修改你的 Build Setting，所以只能借助于 xcconfig： 我们来看一下 Pod 生成的一个 xcconfig： 首先看第一句 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1。GCC_PREPROCESSOR_DEFINITIONS 是 GCC 预编译头参数，也就是我们之前设置过的 Preprocessor Macros。$(inherited) 表示继承于之前的设置。我们打开 target 的 Build Setting，找到这一项： 可以看到，这一项和 xcconfig 中设置的一样。因此，我们可以猜想：在 project 的 Configuration 这一项中，将 target 和xcconfig 关联了起来，xcconfig 中的每一项，如果 target 的 Build Setting 中原来不存在，那么就是新建的 User-Defined，如果 target 的 Build Setting 中存在，那么就是重写。上面提及的非官方教程中也有详细说明。 比如上面 xcconfig 中提及的 PODS_ROOT 一项是 Build Setting 中原本没有的，那我们就到 target 的 User-Defined 中去查看，确实被新建了出来。 再比如，我们修改 xcconfig 中的 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1 为 GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1 hello=1，增加了一个 hello=1。我们来看 Build Setting，确实增加了 hello 这一项。再次验证了猜想： 每一个 target 都可以设置一个相关的 xcconfig，来配置其 Build Setting，没有就是 None，Cocoapods 就是基于这个原理。我们也可以自己创建 xcconfig 来配置： 这里盗用了一张别人的图，他为每一个 Configuration 都创建了一个 xcconfig，并将其与 target 关联： 然后在其中添加自己的设置。注意，如果使用了 pod 要在其中引入 pod 的 xcconfig： 所以，对于我们来说，自定义 xcconfig 其实完全等价于直接处理 Build Setting。因此，这也是一种修改环境变量的方式。 Target 以及 Project 的 Build Setting之前我们时而设置 Target 的 Build Setting，时而设置 Project 的 Build Setting，那么到底两者有什么区别呢。其实之前说的那篇教程中也有说明。 简单来说，Build Setting 有一个继承关系，我们可以通过下面一张图了解： 我们在 Build Setting 中选择 Levels，这样整个继承关系就平铺了下来。继承级别从左向右依次降低。最右边的是 iOS Default，提供一个默认的设置，我们可以在 Project 的 Build Setting 中修改它。然后是 target 的 xcconfig，这里就是 pod 生成的 xcconfig，它可以修改 Build Setting 的选项。最后是 target 的 Build Setting，修改级别最高。最终的结果就是 Resolved 一栏显示的。 这也就解释了之前为什么时而用 Project 的 Build Setting，时而用 Target 的 Build Setting。当你想要修改的东西要作用于所有 target 的时候，就在 Project 中修改。如果只是想针对某一个 target，那么就修改 target 的 Build Setting。 一个小问题这里在看到一个关于新建 Configuration 会产生的一个问题：新建的 Configuration 在默认情况下无法调试： 可见官方文档 使用 Target 配置在创建了项目后，项目本身包含一个 target，我们可以以这个 target 为基础，创建出测试环境，线上环境的 target。 我们先 Duplicate 一个 target： 将会生成一个 TestConfiguration copy，以及一个 TestConfiguration copy-Info.plist 文件： 我们将其名字修改为 TestConfiguration_Test 以及 TestConfiguration_Test-Info.plist。改了 plist 的名称后，对应的，在 target 的 Build Setting 中 Info.plist File 也要改成对应的名称： 除此之外，新建了 target 后，还会自动创建一个 scheme，我们同样要修改 scheme 的名字。记得要勾上 shared： 之后配置和获取环境变量的方式和之前的 Configuration 一模一样。两者的不同在于 Configuration 修改的是同一个 Build Setting；复制 Target，则相当于创建了一个 Build Setting 的副本。 如果维护一套代码，以后这些app如果需求有不同怎么办？？比如要进入不同界面，跳转不同界面，页面也显示不同怎么办？？这个问题其实很简单。在Targets里面的Compile Sources里面是可以给每个不同的Targets添加不同的编译代码的。只需要在每个不同的Targets里面加入不同界面的代码进行编译就可以了，在跳转的那个界面加上宏，来控制不同的app跳转到相应界面。这样本地还是维护的一套代码，只不过每个Targets编译的代码就是这套代码的子集了。这样维护起来还是很方便。也实现了不同app不同界面，不同需求了。 如何选择那么什么时候选择 Configuration 什么时候选择 Target 呢？如果只上架一个 app，但是需要多个环境，并且不同环境的功能基本相同，那么用 Configuration 就可以了。如果要上架多个类似的 app，那么一定要用 target，因为不同 app 所需的证书不同，archive的时候还会有各种问题。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式学习]]></title>
    <url>%2F2017%2F08%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学习架构的时候复习一下设计模式 面向对象设计原则单一职责原则 单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 单一职责原则是实现高内聚、低耦合的指导方针，需要设计人员发现类的不同职责并将其分离。 例子比如一个类即创建了数据库连接，又查询客户信息，还生成和展示图表。它的职责就有点多了。 重构后将各个功能拆分成不同的类，然后加以组合： 其实就是，把一个大的功能模块划分为一个个小的功能模块，然后以组合的方式合并这些功能 开闭原则开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。 开闭原则：一个软件实体，应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 抽象化是开闭原则的关键。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成拓展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 例子下面这个例子主要是通过里氏代换原则（抽象类可以转换为实体类）和依赖倒转原则（即用抽象类来代替实体类）来实现开闭原则的。开闭原则是目的，里氏代换和依赖倒转是手段。 下面调用两个 Chart 的展示方法，如果是硬编码就会在 ChartDisplay 中写明要调用的类型，通过 if.else 判断： 123456789...... if (type.equals("pie")) &#123; PieChart chart = new PieChart(); chart.display(); &#125;else if (type.equals("bar")) &#123; BarChart chart = new BarChart(); chart.display(); &#125; ...... 现在可以将这个方法抽象出来，通过调用抽象方法来解决： 其实就是，将多个类中类似的功能抽取出来，作为一个抽象类，以后所有有这个功能的就继承这个抽象类，要调用的时候就调用这个抽象类的方法。 接口隔离原则 接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 每一个接口应该承担一种相对独立的角色，不干不该干的事。接口可以有两种不同的定义： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 合成复用原则 合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类；从基类继承而来的实现是静态的（组合就可以通过抽象类的方式，在运行时随时变换具体的实例），不可能在运行时发生改变，没有足够的灵活性。 例子比如你想自定义一个 button，那么你可以通过继承实现，重写 initWithFrame: 方法。也可以通过为 UIButton 添加一个分类 UIButton+Custom，在其中添加自己的自定义方法。当然，按照本原则，尽量使用组合的方式。 组合就是在原来的基础上添加新的方法，可以直接添加（如 iOS 中的分类），也可以通过添加一个属性，由这个属性来执行要实现的方法。 继承主要是为了代码复用，是在原来方法的基础上拓展原方法。继承的目的并不是为了给子类提供一个方法标准，因为定义方法标准最好的方式是协议。所以不要单纯为了提供定义方法来继承。 也就是说，假如基类中有些方法是空方法，是要子类实现的，那么就抽出来作为协议。你可以将该方法直接声明在基类的 interface 里，然后不在 implementation 中实现这个方法，或者直接在这个实现方法中抛出异常(两者是等效的，执行到的时候如果子类没有重写该方法都会异常)，这样所有子类都可以调用这个方法了。然后让子类实现一个将该方法声明为 required 的协议。为什么要再弄一个 required 的协议呢？因为这样能提醒开发者这一类型的子类必须要实现该方法，有助于代码规范。 何时用继承何时用组合没有绝对的定义。只要记住不要滥用继承。想要用继承的时候先问自己，能不能用组合？ 分类和 AOP 都是组合的实现思路。不过使用 AOP 时要注意如果某些子类不接受 AOP 需要如何特殊化处理（比如你对 UIViewController 的 viewDidLoad 方法做 AOP，但是一些系统的 UIViewController 就不适用你的 AOP 方法，那么你要如何把系统的 UIViewController 派生的子类排除？）。这个时候你就要评估使用 AOP 的组合和使用继承在代码实现上的难易程度了 迪米特法则 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。 应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 例子下面点击 button 后，会调用各种控件产生变化，这样 button 就要和各种空间耦合。 可以通过加入中间件，解耦 button 和其他控件： 其实就是，通过中间层，减少类与类的耦合 原则总结设计原则总结起来两点：”少”，”解耦”： 少 内部功能少 =&gt; 单一职责 外部暴露少 =&gt; 接口隔离 相互关系少 =&gt; 迪米特 解耦 类与内部属性解耦 =&gt; 开闭 类与拓展方法解耦 =&gt; 组合复用 类与类解耦 =&gt; 迪米特 设计模式的意义一个方法被多个类调用，一般的做法是将这个方法抽出来作为一个方法类供其他类调用，这种做法没有使用设计模式，是一种合成复用；一个类要根据不同情况调用不同方法或者拓展方法的时候，我们可以选择将方法抽出为类，直接调用方法基类提供的方法，切换方法类的实例来切换方法，也可以选择通过一个中间类的基类调用方法类的方法，通过切换中间类的实例来切换方法。这就是一种设计模式的选择。 设计模式作用在于解耦。但是你可能会问，我们虽然是要么调用方法基类的方法，要么是调用中间类基类的方法，但是最后还是要实例化究竟是哪个方法类和哪个中间类，难道不还是要耦合具体的方法类或者中间类吗？是的，有些情况下是，但是有些时候我们还可以将方法类或者中间类的实例传给调用者，或者使用放射的方式动态创建调用者，这两种情况下，调用者就不需要引入具体的类了。这样就实现了解耦。 所以，当你发现你的某个类需要调用不同方法或者拓展方法的时候，就可以考虑使用设计模式了 六种创建型模式创建型模式主要用于描述如何创建对象 为什么要用工厂？这一节不是一个设计模式，但是有必要探讨一下，为什么要使用工厂？工厂目的是为了将对象的创建和使用分离。那么这样有什么好处？ 对于创建类与产品类之间来说：工厂类的引入将减少耦合，降低因为产品类改变所造成的维护工作量。如果产品类需要添加或者移除的子属性，或者要修改产品类的接口，如果和业务数据数据无关，那么只要修改工厂类的代码就行了，不需要改动创建类中的代码。 对于创建类来说：防止用来实例化一个类的数据和代码在多个类中到处都是。产品类的某些参数可能不能直接使用，而需要转化(比如日期字符串的转化)，再比如产品类的构建的参数可能需要从文件读取。这些写在创建类中就会让初始化的代码到处都是。 对于产品类来说：防止产品类职责过重，耦合其他类。对于2，获取你认为可以将参数的转化放在产品的初始化方法中，但是这样容易产生耦合，不便移植。比如我(产品类)本来就只要一个字符串，你非得让我从某个路径读文件；本来我只要一个 UIView，你非得让我自己引入并创建一个 CustomView 的实例。 归根到底，工厂还是在两个类之间起到一个中间人的作用，只不过它是专门用来创建实例的。所有的中间人都可以分为三部分来分析：调用者，被调用者，两者之间。 工厂模式适用于创建产品类的时候，需要做很多初始化操作。 iOS 中的类簇就是工厂模式的体现。比如 NSString NSNumber NSArray 的创建都隐藏了其实际的子类信息。 简单工厂模式难度：2 频率：3 简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 如果我们要根据参数 type 的不同，创建不同类型的产品类，那么我们就要在调用者类中添加很多的 if…else… 判断。如果其他调用者也要创建这种产品类，也会添加很多 if…else…，那么就不如直接将这些判断提取出来，作为一个简单工厂类。 这里是因为有很多产品类才创建使用的简单工厂模式，复用 if…else…。如果只有一个产品类呢？如果只是单纯的创建，确实没什么代码可以复用的，直接创建就行了。但是如果对产品类有一些设置，这是共性的，可以复用，所以还是可以创建工厂，也就是下面要说的工程方法模式。 例子下面工厂 ChartFactory 通过 getChart: 方法创建不同的 Chart 对象。其内部是通过 if…else 实现的。HistogramChart，LineChart，PieChart 分别实现了接口 Chart 的 display() 方法： 这里由于所有 Chart 都要实现一个 display 方法供调用者创建好对象后调用，所以要设置一个接口类型。 其实就是，在抽象类中提供一个静态方法，通过输入参数的不同，创建不同的具体子类实例。 工厂方法模式难度：2 频率：5 工厂方法模式：定义一个抽象工厂类，让其子类决定将哪一个产品类实例化。工厂方法模式让一个产品类的实例化延迟到其工厂子类中。 使用简单工厂面临的问题是所有的初始化方法都在一个工厂类中，通过 if…else…判断，这样职责过重，并且不易拓展。所以使用工厂方法模式。 工厂模式中不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。工厂方法通过反射的方式，动态的创建具体工厂实例，代替简单工厂中的 if…else，满足了开闭原则。如果不适用反射的方式，那么就得先创建工厂实例，然后在调用工厂创建产品的方法了。 那为什么不直接在简单工厂里使用反射动态地创建具体产品实例呢？反射生成对象只能适用一些最简单的情况，如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置一些不同的环境等等，需要将这些代码封装到工厂中。 例子提供了接口 LoggerFactory 和接口 Logger。FileLoggerFactory 和 DatabaseLoggerFactory 实现了接口 LoggerFactory 的 createLogger() 方法；FileLogger 和 DatabaseLogger 实现了接口 Logger 的 writeLog() 方法。在实现的时候可以通过反射，动态地创建具体工厂类 FileLoggerFactory 和 DatabaseLoggerFactory。然后调用各自实现的接口方法 createLogger: 创建具体的产品类 iOS 中 [NSNumber numberWithInt:1] 这种非 alloc 创建的就是工厂方法，或则准确的说这种不通过 Factory 类的工厂叫做类工厂方法。工厂方法直接将需要的变量作为参数传入。工厂方法的名称不要用图示的 createXXX，应该类似于 NSNumber 这种 OC 特色的方法命名方式。 由于要解耦，所以将 LoggerFactory 和 Logger 都设置为接口类型，然后子类分别实现他们的方法。 命名最好以 XxxFactory 和 createXxxWithXxx: 命名。 其实就是，为每一个具体的产品类都创建一个具体的工厂类，来包裹一些复杂的创建过程。抽象类通过反射方式创建具体的工厂，再由工厂实例创建产品实例。 抽象工厂模式难度：4 频率：5 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 先要了解两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。 对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改；对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 例子下面是一个定制不同皮肤的例子。由 SpringSkinFactory 和 SummerSkinFactory 实现了接口 SkinFactory 的三个创建对象的方法。同样的，通过反射，动态的创建工厂实例。调用其实现的创建方法获取产品实例： 其实就是，抽象工厂模式和工厂方法模式没啥大的差别，只不过把几个不同类别(即不同产品等级结构)的东西的创建方法放在一起，减少了工厂类的数量。 单例模式难度：1 频率：4 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 缺点：单例类没有抽象层，不易于扩展。同时单例类职责过重，即充当了工厂角色，又充当了产品角色 结构单例类中有一个对象属性，并且声明了一个静态方法。这个静态方法被调用时，会先判断对象是否为空，如果为空就创建一个，然后返回: 原型模式难度：3 频率：3 原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。 缺点：要为每一个类提供一个克隆方法，当对类进行改造时，需要修改源代码，违反了开闭原则。另外，嵌套多层时，实现代码会较为复杂。 结构每个要 clone 的类都继承于 Prototype 抽象类，然后实现其 clone 方法，注意这里的方法是实例方法： 调用的代码类似： 123Prototype obj1 = new ConcretePrototype();obj1.setAttr("Sunny");Prototype obj2 = obj1.clone(); 其实就类似于 iOS 中的实现 NSCopy 协议，完成 copyWithZone 方法，然后调用 copy。 建造者模式难度：4 频率：2 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式其实是为了给一个特定对象在不同情况下赋不同值的。比如你要初始化一个对象，这个对象会根据你给出的 type 不同，将属性初始化为不同的值。你可以用 if…else 判断不同属性赋不同值，但是这样显然违背了开闭原则。所以建造者模式就需要你为每一种 type 创建一个 builder 类，在 builder 中提供对对象的属性进行赋值的方法。然后，创建的时候传入不同的 builder（你也可以通过反射的方式，只传入字符串），调用这些赋值方法，以此达到分拆 if…else 的目的。 结构抽象类 Builder （因为 Builder 中含有创建的对象属性，所以不能设置为接口）提供了创建对象的方法以及设置这个对象中的属性的各种方法。会有多个 ConcreteBuilder 实现了抽象 Builder 的方法。每个 ConcreteBuilder 中设置属性方法所设置的属性都是不同的。Director 中会保存一个 Builder 的实例，可以通过反射创建不同的 Builder 设置给 Director。同时，Director 提供了一个 construct 方法，用来调用 Builder 中设置属性的方法，我们可以自由控制是否需要设置某一属性（即控制是否调用 builder 中设置属性的方法）。最后通过 getResult() 返回设置好的对象： 建造者模式与抽象工厂模式有点相似，但是建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导指挥者如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。 例子下面例子中，ActorController 充当指挥者(Director)，ActorBuilder 充当抽象建造者，HeroBuilder、AngelBuilder 和 DevilBuilder 充当具体建造者，Actor 充当复杂产品: ActorController 中预先设置一个 builder，然后通过 construct 方法调用 builder 的各种设置方法，达到设置 Actor 的目的。具体的流程上面已经叙述过了。 类比工厂方法模式，builder 其实和 factory 基本一致，两个都是初始化属性，builder 中有更统一的初始化属性的方法。并且一个 builder/factory 对应一个产品类。但是为什么这里专门要有一个指挥者(Director)呢？因为有了指挥者就可以控制 builder 中的方法到底哪些要执行哪些不要执行了，可以装门创建一个 Director 对象，以组合的方式作为d调用者的一个属性，随时可以替换。工厂方法模式的调用者话就不关心要设置哪些属性了，所以工厂方法模式的调用者只调用 factory 的 create 方法，具体如何设置属性的，调用者无从知晓。 这里 Actor 没有继承任何类，ActorBuilder 是一个抽象类，其中保存了 Actor 的实例。其实设计模式中没有硬性规定这个设计模式中一定要包含某个接口，或者某个基类，完全是按照实际需求来的，只需要提供通用方法的就设置为接口，需要提供通用属性的，就设置为基类，什么也不需要的就是普通的类。比如本例，我们就只需要生成这一个 Actor ，所以就不需要搞任何继承和组合；ActorBuilder 必须保存一个 Actor 实例属性（因为各种build 方法都要调用它的方法），所以就必须要设置为抽象类，不能设置为接口。 命名最好以 XxxBuilder 和 buildXxxWithXxx: 方式命名。 建造者模式的抽象程度比工厂方法模式的高，所以同样是初始化属性的操作，建造者模式抽象出了各种 build 方法，而工厂方法模式则全部藏在工厂的 create 方法中。 七种结构型模式结构型模式主要用于描述类与类之间的关系，几个类之间如何解耦的 适配器模式 适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高. 结构 调用目标抽象类的某个方法的时候，通过适配器，转而调用了适配者类的某个方法，完成适配。 例子对象适配器对象适配器的适配器（adapter）和适配者（adaptee）是关联关系。下面的 OperationAdapter 是实现了接口 ScoreOperation 的 sort 以及 search 方法。可以通过反射的方式自由更改接口 ScoreOperation 的实现类以满足开闭原则。在适配器中，真正的实现对象 QuickSort 以及 BinarySearch 是作为其属性 sortObj,searchObj 存在的，所以称为关联关系。在调用 sort，search 方法后，将调用真正的实现方法： 类适配器类适配器的适配器和适配者是继承关系， Adapter 是继承于 Adaptee 的，实现了 specificRequest() 方法.同时， Adapter 也实现了接口 Target 的 request() 方法，在 request() 方法中调用实现方法 specificRequest()。注意下图和上面结构图的区别： Target 是一个接口，提供了一个通用的方法供被适配对象调用，由具体的 Adapter 继承实现。Adaptee 由于是具体的适配类，各个类不同，所以不提供通用的方法。 命名最好以 XxxAdapter 和 requestXxxWithXxx: 命名。 其实大部分设计模式的结构都和上面拿到很像，一个类通过一个中间人调用另一个类的方法，我们可以中间人调用另一个类方法前后分别调用一些自己的方法。比如外观模式，代理模式，命令模式等 区分这些设计模式的要点在于区分目的。 适配器模式的目的是适配，举个简单的例子，比如我只能提供 CFloat 的参数，但是被调用者必须要 NSNumber，那么我就不能直接调用被调用者。所以这个中间类就是用来适配的。 代理模式的目的是代理，就是我就不想用原来的被调用对象，我想用一个新的中间类代替它，然后做一些额外的操作。所以这个中间类是用来代理的，虽然可能也做了适配的工作，但是我目的就是想用它代理原来的类。 外观模式的目的是改变外观。就是原来我既要调用这个类的接口，又要调用那个类的接口，太麻烦了，所以我创建了一个中间类，来统一所有的接口。所有的调用都走这个中间类，虽然可能它也做了适配和代理的工作，但是我的目的就是要统一所有接口。 命令模式的目的是包装方法。这和上面的解构型设计模式不太一样。命令模式是行为型设计模式，讲究的是对于方法的执行，结构型讲究的是类与类之间的关系。我不是让他适配某一个类，也不是让它代理某一个类，更不是想让它替换某一个类的接口。就是想把某个类的某个方法包装一下。 桥接模式难度：3 频率：3 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 如果软件系统中某个类存在两个或者多个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 缺点：要能正确识别系统中两个独立变化的维度。如果不是独立变化的，那还是不可避免的要通过 if…else 判断。 结构 如图，抽象类 Abstraction 为一个维度，它要求它的子类都实现 operation() 方法。接口 Implementor 是另一个维度，它要求实现它接口的类都需要实现 operationImpl 方法。在抽象类 Abstraction 中保留有接口 Implementor 的具体实现属性 impl。两者通过组合的方式实现了同一，能够实现两个维度需要的方法 operation() 和 operationImpl()。 仍然可以通过反射的方式获得抽象类的实现，和接口的实现。增加新的抽象类或接口实现就可以拓展系统，符合开闭原则。 例子比如要实现一个图像浏览系统，要能够显示不同格式的图片文件，又要兼容不同的平台。如果不用桥接模式，会产生如下的继承树。因为有格式和平台两个维度，所以继承树有两层： 但是使用桥接模式，可以将平台维度作为接口独立出来。以图片维度作为主维度，设置抽象类 Image，其中除了自己维度需要的方法 parseFile() 外，还保存了平台维度 ImageImp 的实例 imp。可以通过 imp.doPaint() 调用平台维度的方法。 一个维度是主要维度，涉及属性，所以涉及为抽象类，另一个维度不涉及属性，只涉及一些方法，所以涉及为接口。这是组合的一个典型运用，没有涉及到中间人。 没有固定的命名方式 什么是维度？是要做相似处理（有着相同的方法名，但方法实现方式不同）的抽象 其实就是，将主要维度作为抽象类用于继承。次要维度分离为接口。最终还是通过组合的方式，代替继承。 组合模式难度：3 频率：4 组合模式：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。 组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理. 结构 抽象类 Component 定义了一系列方法，operation() 方法用来做实际业务处理，add() 和 remove() 用来添加和删除对象，这个对象可以是叶子也可以是容器，getChild() 用来返回叶子或者容器。在容器的 opeartion() 方法中，会调用其所有子对象的 operation() 方法。 Lead 和 Composite 继承于同一个超类 Component，Component 中的 add 和 remove 以及 getChild 在 Leaf 中国不实现，只实现 operation。 例子 抽象类 AbstractFile 定义了多个方法，其中 killVirus() 就是上面的 operation() 方法。ImageFile,VideoFile,TextFile 就是叶子对象。Folder 就是容器对象，容器对象里可能还有很多图像视图文本文件。 没有固定的命名方式，不过基类要定义添加、删除、查看子节点以及真正的执行方法的命名。 组合模式叶子和容器的关系；建造者模式是一个维度和另一个维度的关系。组合模式中叶子和容器其实是一类的，他们都继承于同一个抽象类；建造者模式中两个维度是不同的，继承于不同的抽象类或者接口。 组合模式不是我们通常讲的组合。通常将的组合是指把一个对象放在另一个对象中作为其属性。而组合模式则是指把一堆类似的叶子对象放在一起作为一个容器。 装饰模式难度：3 频率：3 装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 如果我们不适用装饰模式，那么对一个功能添加新的功能就要继承成为一个新类： 结构 如图所示，component 是一个抽象类，也可以是一个接口，定义了一个 operation() 方法。concreteComponent 是这个抽象类或接口的实现，也是被装饰对象。现在 Decorator 是一个抽象类，其中含有一个 concreteComponent 的具体实例 component，在其 operation() 方法中，每次都会调用这个 component 的方法。会有许多具体的实现类 ConcreteDecorateX 实现 Decorator，它们会在自身 operation() 方法中调用其中保存的 component 的方法，并且加上自己的实现。 调用的话，需要先创建一个 ConcreteComponent，然后把它设置给装饰者的 Component，然后调用装饰者中的处理方法。如果有多个装饰者，可以将某个装饰者作为另一个装饰者的 Component 设置进去。 缺点：会产生多个小对象。更容易出错，且排错困难。 例子 上面的那个例子的正确打开方式是，在装饰类 ComponentDecorator 的子类中实现方法 display() 的拓展。调用方式如下： 12345Component component,componentSB,componentBB; //全部使用抽象构件定义component = new Window();componentSB = new ScrollBarDecorator(component);componentBB = new BlackBorderDecorator(componentSB); //将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰componentBB.display(); 装饰模式的装饰对象和被装饰对象都继承于一个基类，基类中提供的方法就是将被装饰的方法。创建装饰者对象的时候要将被装饰者(被装饰着可以是最根本的 Component 也可以是其他的 Director)作为参数传入，装饰者内部会将其作为一个属性保存。外部直接调用装饰者的方法，装饰者在进行方法拓展后会调用被装饰者的相应方法。 命名最好以 XxxDirector 的方式，方法没有特别的命名，与被装饰对象相关。 外观模式难度：1 频率：5 外观模式(Facade)：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。 外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。 结构 Client 不和 SubSystem 直接接触，而是通过一个中间层 Facade 交互。 在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。 例子 上面的例子中提供了两个子系统类，它们的 cipher 是不同的。Client 只要调用 FileEncrypt() 即可，不需要再和 FileReader,FileWriter,CipherMachine 耦合了。 命名最好为 XxxFacade，方法没有特别的命名，与被调用方法相关 其实就是原本一个方法中要调用好几个类的好几个方法，现在就把这个方法拿出去，作为外观类的一个方法了。 代理模式难度：3 频率：4 代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 结构 抽象主题角色 Subject 中有一个方法 request()，代理主题角色 Proxy 和真实主题角色 RealSubject 都实现了其方法。Proxy 会自己创建 RealSubject 的实例，其 request() 方法中，不仅调用 RealSubject 的相应方法，还在其前后各加上自己的方法 PreRequest() 以及 PostRequest()。可以通过反射动态替换代理主题类名。 命名最好为 XxxProxy，方法没有特别的命名，与被代理对象相关。 装饰器模式和代理模式和外观模式的区别装饰器模式关注于在一个对象上动态的添加方法，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。装饰者能够在运行时递归地被构造。 然而代理模式关注于控制对对象的访问。对使用者来说，代理类就是你要用的那个对象。因此，当使用代理模式的时候，我们常常在一个代理类中自己创建一个对象的实例。代理和真实对象之间的的关系通常在编译时就已经确定了 外观模式用来封装子系统的方法，隐藏子系统间的通信和依赖关系。其实外观是使用最广的，是个方法都能抽出来做成外观模式，只不过一般接口没有复用需求的话没必要罢了。 十一个行为型模式行为型模式主要用于描述方法是如何执行的 职责链模式难度：3 频率：2 职责链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 我们经常会写出很长的 if…else 来分别处理不同的情况。例如 12345678910111213141516if (request.getAmount() &lt; 50000) &#123; //主任可审批该采购单 this.handleByDirector(request); &#125; else if (request.getAmount() &lt; 100000) &#123; //副董事长可审批该采购单 this.handleByVicePresident(request); &#125; else if (request.getAmount() &lt; 500000) &#123; //董事长可审批该采购单 this.handleByPresident(request); &#125; else &#123; //董事会可审批该采购单 this.handleByCongress(request); &#125; 这样各个方法都几种在一个类中，违反了单一职责原则。并且有 if…else 的地方基本都是违反开闭原则的。我们需要使用职责链模式修改。 结构 定义了一个抽象处理者handler ，它有一个 successor 属性，用来标识谁是响应链的下一级。 handler 还定义了一个抽象处理方法 handleRequest()，每一个具体处理者 concreteHandler 继承该方法都会先判断自己能否处理，如果能就走自己的实现逻辑，如果不能就调用 successor.handleRequest() 。 职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 例子 上图中 Approver 是抽象处理者，successor 的类型是自己本身，用来标记处理链中的下一级处理者。processRequest() 方法用来处理具体的事件，接收一个 PurchaseRequest 对象，这是一个具体要处理的事件。然后就是各个具体处理者。他们会在初始化的时候设置好处理层级。 所有责任链的对象都继承于统一的基类，因为要继承在基类中提供的 successor。 命名最好在基类中将属性定义为 successor 或者 next 责任链模式用在同类型的串行处理，比如网络请求，就可以提供一个 successor，保存下一级请求。再比如本例，各个处理者其实都是同级的，他们相应的处理方法都会执行到。 命令模式难度：3 频率：4 命令模式：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式别名为动作(Action)模式或事务(Transaction)模式。 命令模式将请求发送者和执行者解耦。如果没有命令模式，那么请求发送者和执行者是耦合在一起的。那么就像开关一样，一个开关只能控制一个电器，不能更换电器，且增加电器的时候必须要增加开关。 命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。 命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。 结构 调用者 Invoker 中有一个抽象命令类 Command 的实例。Invoker 不直接调用接受者 Receiver 的方法，而是在这个 Command 的 execute() 方法里调用。可以通过反射的方式动态创建 ConcreteCommand 实例，来决定 Invoker 最终调用的是那个 Receiver，完成了两者间的解耦。 例子 这个例子的场景是控制某一个按钮 FunctionButton 的功能。FunctionButton 并不直接控制究竟是执行 WindowHandler 还是 HelpHandler。它内部存有一个 command，这个 command 根据反射决定究竟是 MinimizeCommand 还是 HelpCommand 实例。最后调用其实现的 execute() 方法。 Command 类中可以添加自己的属性。你可以在 execute 方法前后添加自己的方法，如果调用者要监控命令的执行情况，可以在 command 中设置一个 delegate，提供 command:didRequestXXXWithXXX: 以及 command:didFinishXXX: 方法。 命名最好为 XxxCommand 以及 execute: 的形式，代理命名为 XxxCommandDelegate ，代理方法命名为 command:didRequestXXXWithXXX: 以及 command:didFinishXXX: 其实就是加个中间层，让调用和实现分离 命令模式的撤销命令模式的一个应用是在封装命令的时候，可以添加一些撤销和保存状态。iOS 中提供了 NSUndoManager 来实现这个撤销和恢复的过程。 迭代器模式难度：3 频率：5 迭代器模式：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。 在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。 结构 聚合类 ConcreteAggregate 中有一个列表属性，同时还提供了一个 createIterator() 方法，该方法会将其列表属性传入，并返回一个具体迭代器对象 ConcreteIterator。ConcreteIterator 中保存一个列表，同时还有一个私有的游标 cursor 用来标识迭代到的当前值，并提供 first(),next() 等方法进行迭代。 例子 这个例子和上面说的基本类似，ProductList 中有一个数组，还提供 createIterator() 方法创建迭代器 ProductIterator，并将数组设置给迭代器的 productList 属性中。迭代器提供了两个游标 cursor 分别用来正序遍历和逆序遍历。 就是在一个类中保存一个数组，然后调用一些方法遍历数组 中介者模式难度：3 频率：2 中介者模式：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式。 中介者模式是“迪米特法则”的一个典型应用. 缺点：中介者类可能非常复杂，难以维护 结构 中介者模式主要是消除耦合。所有的具体同事类 ConcreteColleague 都不能直接相互调用，它们内部有一个从 Colleague 中继承过来的 Mediator 属性，在创建的时候设置具体中介者 ConcreteMediator。ConcreteMediator 中存在各种调用具体同事类ConcreteColleague 的方法。 例子 这是一个各个组件相互调用的例子。同上面所说的一样，Component 中有抽象中介者 mediator，会在生成具体同事类(即各个组件)的时候，setMediator() 设置具体中介者 ConcreteMediator。它提供一个 componentChanged() 方法供具体同事类调用，这个方法用来处理跳转啊交互之类的逻辑。Component 中提供的 change() 方法用来调用其内部 mediator 的 componentChanged()，相当于是一个对于 componentChanged() 方法的封装。update() 方法是在其他类调用了 componentChanged() 后，当前类做出的响应操作。change() 和 update() 两个方法都不是必须的。 备忘录模式难度：2 频率：2 备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 其实就是提供了一个备忘录类，用来存储历史状态。 结构 负责人 Caretaker 是管理者，用来保存备忘录 Memento，但是不能对其内容进行操作。Caretaker 可以存储一个或多个备忘录对象。备忘录 Memento 用来保存原发器 Originator 的内部状态，根据原发器来决定保存哪些内部状态。原发器 Originator 是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以用备忘录来回复其内部状态。 例子 如图是一个保存象棋路径的例子。负责人 MementoCaretaker 中保存了一个备忘录 memento。这里的 memento 只是表示备忘一种状态，如果你想保存多个状态，那么需要使用一个 memento 的数组。它还提供了设置和获取 memento 的方法 getMemento() 和 setMemento()(由于只有原发器 Originator 能够创建备忘录 Memento，所以这里 setMemento() 传入的是此例中 Chessman 的 save() 方法)。备忘录对象 ChesmanMemento 保存了具体需要备忘的属性，这里指坐标x、y。原发器 Chessman 提供了需要备忘的状态值，它的 save() 方法用来创建新的备忘录对象 ChessmanMemento。同时，它还提供了一个 restore() 方法用来恢复原来的状态。由于其不管理 memento，所以传入的是 MementoCaretaker 中保存的备忘录。 123456789101112131415public static void main(String args[]) &#123; MementoCaretaker mc = new MementoCaretaker(); Chessman chess = new Chessman("车",1,1); display(chess); mc.setMemento(chess.save()); //保存状态 chess.setY(4); display(chess); mc.setMemento(chess.save()); //保存状态 display(chess); chess.setX(5); display(chess); System.out.println("******悔棋******"); chess.restore(mc.getMemento()); //恢复状态 display(chess);&#125; 没什么特别的命名方式，这是一个很基础的设计模式。 其实这个逻辑没有写的这么复杂。如果你想保存历史状态，你就需要一个对象去保存它，也就是管理者 Caretaker。那么要保存什么状态呢？那就抽象出来，编程一个备忘录类 Memento 吧。那么这个状态哪里来的呢？那只有原发器 Originator 能够创建，因为只有它才知道当前的状态啊。 观察者模式难度：3 频率：5 观察者模式：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 结构 目标 Subject 中保存了许多观察者 Observer，通过 attach() 和 detach() 方法增删。同时，还提供了一个 notify() 的方法，当 Subject 觉得状态变化了，需要通知观察者的时候，主动调用触发观察者的方法，。(不用管里面的 subjectState 相关) 例子 这个例子的背景是一个联机对战游戏，一个玩家被攻击后，会通知其它玩家。其中目标 Subject 是一个控制中心 ConcreteAllyControlCenter ，它继承了抽象目标 AllyControlCenter ，实现了其通知方法 notifyObserver()&gt;它的观察者 Observer 是各个玩家 Player。当某个玩家被攻击后，会调用 beAttached 方法，它会调用控制中心的 notifyObserver() 方法通知其它观察者。 状态模式难度：3 频率：3 状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。对象根据不同的状态执行不同的操作，同事对象中的状态也会因为外部因素改变。 结构 环境类 Context 是拥有不同状态 state 的对象。其中有一个 request() 方法，会执行不同状态下的不同操作。抽象状态类 State 中也保存了环境类的实例，目的是方便针对不同状态对环境类的属性操作。不同状态的不同操作在具体状态类 ConcreteState 中的 handle() 方法中实现。改变状态的方法最好在环境类中实现。 例子 该例子中，环境类 Account 有三种状态 OverdraftState,RestrictedState,NormalState。状态中也保存着环境类的实例 acc。环境类调用其处理方法诸如 deposit() 的时候，会调用状态类的相应方法进行处理。 这里，抽象状态类 AccountState 中有一个 stateCheck() 方法，用来改变环境类的状态，它会在处理完环境类的相关属性后被调用。我认为，在状态类中调用改变状态的方法是不对的，这样明显违反了迪米特法则，使调试变得艰难。我认为应该还是在环境类中进行判断。可以结合职责链模式进行状态的设置。 状态模式和职责链模式的区别其实，状态模式和职责链模式挺像的。 职责链模式对目标类中的某个属性进行判断，来决定职责链上的哪个类来进行处理；而状态模式预先将状态(即要处理的类)设置好，每次处理完之后再判断下一个状态是什么(即下次应该那个类处理)。 策略模式难度：1 频率：4 策略模式：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式 实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径。 策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开。 结构 环境类 Context 中有一个抽象策略类 Strategy，这个策略类将会在执行的时候通过反射的方式动态的生成具体抽象类 ConcreteStrategy，以表示不同的策略。在执行环境类中方法 algorithm() 的时候，会执行策略类的相应方法。 例子 这是一个电影票打折的例子。针对不同的人群有不同的打折策略 StudentDiscount,VIPDiscount,ChildrenDiscount。这个策略将保存在环境类 MoviewTicket 的 discount 属性中，可以。每次执行环境类的方法 setPrice() 的时候，都会调用相应策略的方法。 策略模式和状态模式的区别策略模式和状态模式很像。策略模式需要在环境类中设置一个策略类，状态模式也需要在环境类中设置一个状态类。两者的区别在于，状态模式会根据环境类中的属性自动改变状态的值，而策略类需要直接设置不同的策略。 策略模式和命令模式区别命令模式用来隐藏接收者执行的细节。也就是说要有一个接收者，命令类充当转发的过程。 策略模式不含有接收者，仅仅是对算法的多种封装。 模板方法模式难度：2 频率：3 模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 结构 抽象类中定义了多个方法，并在方法 TemplateMethod() 中定义了调用次序。具体子类中实现这些方法。 其实就是在基类中添加一个方法，调用一些需要子类实现的抽象方法。很普通的设计模式 访问者模式难度：4 频率：1 访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 试想一下，如果某个类要动态替换某一个方法怎么做？我们可以使用命令模式，不同的 command 类的 excute()执行不同的行为。那么更进一步，如果这个类有多个兄弟类也各自有实现了这个方法呢？如果还是用命令模式，那么每个兄弟类都要对应一个 Command 类，类型将非常多。这个时候，可以借助于访问者模式。下面看看访问者模式如何实现的。 结构 先看 Element ，就是上面说的要动态方法的基类，也就是下面所说的被访问者，它的子类各自实现了一些方法 opertaionA()，operationB()。现在还有一个访问者的基类 Visitor，在基类中直接就定义了针对 Element 不同子类会被调用的方法 visitConcreteElementA() 和 visitConcreteElementB()。Element 的子类将原本在 operationA() 中调用的业务方法，放到了 Visitor 的子类的 visitCooncreteElementA() 中去。另外， Element 方法提供了一个接收不同 Visitor 的方法 accept()。 具体的调用过程就是，原本调用业务逻辑的 operationA() 现在改为调用 accept() 方法，然后再在 accept() 方法中，调用具体的实现方法 visitConcreteElementA() 。参考代码如下: 12345678910111213141516171819// ElementA- operationA &#123; Visitor *visitor = [[ConcreteVisitorA alloc] init]; [self accept:visitor];&#125;- accept:(Visitor *)visitor &#123; [visitor visitConcreteElementA:self];&#125;// ElementB- operationB &#123; Visitor *visitor = [[ConcreteVisitorA alloc] init]; [self accept:visitor];&#125;- accept:(Visitor *)visitor &#123; [visitor visitConcreteElementB:self];&#125; 访问者模式可以方便的替换 Visitor 符合开闭原则，但是如果增加了 Element 的子类，就需要为每一个 Visitor 添加 visitConcreteElementC() 方法，不符合开闭原则。 命名上，访问者类命名为 XxxVisitor，然后为每一个被访问者对象的子类提供 visitXxx: 方法。被访问者的基类提供抽象方法 accept: 方法。 访问者模式确实用的比较少，算是一种针对于多子类对象的命令模式吧 分类接口适配 适配器 桥接 外观 对象去耦 中介者 观察者 抽象集合 组合 迭代器 行为拓展 访问者 装饰 责任链 算法封装： 模板方法 策略 命令 对象访问： 代理 对象状态： 备忘录 对象创建： 原型 工厂方法 抽象工厂 建造者 单例 备注本文中的所有示意图：紫色的都表示接口类型，蓝色的都表示实体类（如果要在某个类内部保存属性，那么就不能将其设置为接口） 本文中的所有示意图：“+” 表示方法，”-“ 表示对象 还有解释器模式和访问者模式和享元模式没有看，用的太少不看了。 感谢史上最全设计模式导学目录]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2017%2F07%2F31%2Fdatastructure%2F</url>
    <content type="text"><![CDATA[记录一些数据结构和算法的学习 极客时间数据结构与算法之美—王争数组为什么编程语言中数组多以 0 作为开始？数组的特点是随机访问，定位一个数据需要通过数组首地址和偏移量来确定。如果数组以 0 开始，那么计算 a[k] 的内存地址的公式为： 1a[k]_address = base_address + k * t 如果以 1 作为开始，那么公式就变为了： 1a[k]_address = base_address + (k - 1) * t 会需要多一次的计算量。 排序如何找到数组总第k大的数如果说先排序再直接过去第k大未免有些太慢了。可以参考快排的思路。选取最后一个数的值 x 作为标识，然后经过一次遍历把大于 x 的都放到 x 的右边，小于 x 的都放到 x 的左边。如果 x 所在位置大于 k，那么就对 x 左边继续之前的操作。否则对 x 右边进行之前的操作。这样就不需要像快排一样，每次都要对两边重复进行操作了。 时间复杂度为 O(n)，不过需要比较复杂的证明。 归并排序的思想是什么？为什么计算机不使用归并排序？归并排序是一种自下而上的排序，将两个分别排好序的队列 merge 为一个排好序的队列，不断重复，直到生成最终排好序的队列。 归并排序并不是一种原地排序，在 merge 的时候是需要申请额外的存储地址的，空间复杂度为 O(n)。因此，没有快排应用广泛。 什么是桶排序，时间复杂度是多少，适用场景是什么？桶排序的核心是将排序的数据分到有序的几个桶中，每个桶内的数据再单独进行快排。排完序后再把数据依次取出，组成有序序列。 时间复杂度为 O(n) 适用于外部排序。即数据存储在外部磁盘中，数据量较大，内存有限，无法将数据全部加载到内存中。（所以就先把外部数据先分到一个个桶中，然后将桶加载到内存中排序。） 跳表什么是跳表，时间复杂度是多少？有序链表如何能像数组一样快速找到第 n 个节点？增加一些索引节点，使时间复杂度从 O(n) 减少到 O(logn) 二叉树什么是二叉查找树二叉查找树要求树中的任意一个节点，其左子树中的每个节点的值都要小于这个节点，而右子树的值都要大于这个节点。 红黑树有什么用红黑树是一种不完全平衡的二叉查找树，红黑树的高度也就是红黑树的查找时间复杂度为 logn。 堆什么是堆 堆是一个完全二叉树 堆中的每一个节点的值都必须大于等于或小于等于子树中每个节点的值 堆排序的时间复杂度堆排序的时间复杂度是 nlogn。堆排序总共分两步： 第一步是建堆，就是把数组中的元素以满足堆的方式排列。办法就是将数据一个一个的插入堆中。 第二步是排序，依次将堆顶的元素取出，然后将其左右子重新构建堆。 什么是大顶堆什么是小顶堆每个节点都大于等于左右子树的堆叫大顶堆，反之则是小顶堆 堆的应用场景堆主要用在不需要所有数全排列的情况，比如主要找到最大，或者最大的几个： 优先级队列 求 Top k 和求中位数 不需要全排序的就可以用一个 k 的大顶堆或者小顶堆实现，好处是避免了排列其他不用的数据产生的时间复杂度。 什么是优先级队列优先级队列就是按照优先级大小排好序的队列。 优先级队列可以是直接排好序的数组。但一般来说，我们只要保证每次出队列的是优先级最高的元素即可。 因此优先级队列是使用堆的最适宜的场景，即每次求出堆中最大的元素。 回溯法回溯法的核心思想回溯法的思想不是纯粹的for循环，而是用 for 循环确定当前情况，然后运用递归，确定之后的情况。在确定当前情况的时候可以利用剪枝去除明显错误的情况。 例如八皇后问题，for循环确定当前列的位置，再判断当然选择是否符合规则，然后递归后面的列执行相同的操作。 动态规划动态规划的核心是存在重复子问题。 当存在重复子问题的时候可以尝试找到状态转移方程。当找到状态转移方程，问题基本就能解决了。不过还要注意递归终止条件 最短路径算法Dijkstra 算法第一步，找出与起点 O 相邻的点，设定这些点的权值是它们各自与起点 O 之间的距离。找出权值最小的点 a，Oa 就是最短路径。第二步，找出与点 a 相邻的所有点，这些点的权值等于点 a 的权值加上这些点到点 a 的距离。在这两步中获得的所有有权重的点中，找到权重最小的点 b。点 b 可能直接和起点 O 相连，那么 Ob 就是其最短路径。点 b 也可能与点 a 相连，那么 Oab 就是 b 到起点 O 的最短路径。如此反复，直到所有点都被遍历完。 迪科斯彻算法是 BFS 的拓展。它是一种贪心算法的实现。每次找距离起点最近的点。 迪科斯彻算法每次获得一个距离起点最近的点，不能存在负权值。只有在权值为正的情况下，a 到 O 权值最小，所以不存在任意点 x 使得 ax+xO &lt; aO，即 aO 是最短路径 这一假设才能够成立 迪科斯彻算法是路由选择协议 ospf 的解决方式 利用位图判重使用 hashmap 的判重将会占用比较大的内存空间。比如对一个文本先进行 hash，得到一个 32 位的 hash 值，将会占用 4 个字节。当数据量非常大的时候将占用极大的内存空间。 利用位图来判重，将使 32 位的占用量减少为 1 位。但是信息量的减少必然会造成大量的误判，如何解决这一问题？可以使用布隆过滤器 布隆过滤器布隆过滤器要求我们使用 k 个哈希函数，对同一个值求哈希值，将会得到 k 个不同的哈希值 X1 X2 X3 … Xn。我们把这 k 个数字作为位图的下标，将对应的 BitMap[X1],BitMap[x2],BitMap[x3]… 都设置为 true。这样就用 k 个二进制位，表示一个值的存在。 当要查询某个值是否存在的时候，使用同样的 k 个哈希函数，对这个数字求哈希，然后在位图中相应的位置查看是否都为 true。如果都是 true，那么说明这个值存在，如果存在一个为 false，那么就说明这个数字不存在。 布隆过滤器其实也存在误判(误判某个数存在)，但是几率比较低 解题技巧线性表 对数组排序 如果题目中是一个无序数组，那么通常可以先将数组进行排序。如果对时间复杂度有要求，可以使用 hashmap 二分查找 对于一个已经排了序的数组，可以通过二分法来降低时间复杂度 从中间向两边 匹配的通用做法。例如求最大连续序列，最长回文，最长有序括号。 双指针夹逼 例如找到序列中和为特定值的两个数 快慢指针 例如是否有环等问题 堆找最大的 k 个数使用堆比每次都排序快 树枚举所有的可能当题干中出现枚举所有可能的时候，要快速转换为树的形式，通过递归实现。 是否存在某种可能使用 DFS 或者 BFS 完成。一定要立刻反应到用树实现。 动态规划递归+备忘录和动态规划的差别在于，递归是通过递推公式，从结果往条件的反向递推。而动态规划是基于 for 循环的正向迭代。 核心核心是能写出状态转移方程，使之能转为求解一个个子问题。 在写状态转移方程的时候要考虑，当前问题需要多少个子问题共同参与求解。比如爬楼梯问题，每次只能爬一层或者两层，那么每个问题就只需要两个子问题参与。再比如求最长上升子序列，那么当前位置的最长上升子序列，就和之前的所有位置的最长上升子序列相关。再比如买卖股票的问题，求当前天的最大收益，就不只是求之前每一天的最大收益，还要分别计入每一天的买进卖出状态。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇较为详细的 UICollectionView 使用方法总结]]></title>
    <url>%2F2017%2F07%2F27%2FUICollectionView%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[花了一周的时间看完了《iOS UICollectionView:The Complete Guide》。英文书读起来还是有点累人的，读完写了些代码做了些笔记和大家分享。书中深入的东西不是太多，时间不充裕的话不太建议大家自己读一遍了。 基本展示UIScrollView 概述UICollectionView 继承于 UIScrollView，UICollectionViewDelegate 协议继承于 UIScrollViewDelegate 协议。所以在使用 UICollectionView 的时候，可以直接使用 UIScrollView 的各个属性方法。 UIScrollView 中有几个重要的属性，contentSize 用来标识 UIScrollView 的滚动范围；contentOffset 用来设置视图原点与可视区域左上角的距离；contentInset 可用通过 UIEdgeInsetMake(10,10,10,10) 的方法设置一个内边框，这个值可以是负的，能使视图超出可视的滚动范围。 我们可以通过 setContentOffset:animated: 将视图滚动到某一个位置，也可以使用 scrollRectToVisible:animated: 将某块 rect 滚动到可视区域内（如果已经可见则不会滚动）。 一些有用的 UIScrollViewDelegate 的方法： scrollViewDidScroll:：在任何 contentOffset 发生改变的时刻调用。可以用来自定义一个下拉刷新控件。 scrollViewWillBeginDragging:：在 scrollView 被拖拽的时候调用。可以在此时暂停一些复杂操作以保证滑动的流畅性。 scrollViewWillEndDragging:withVelocity:targetContentOffset:：在用户结束拖拽并抬起手指后调用。第二个参数表示结束拖动时的速度。第三个参数表示最终结束滚动时的 contentOffset 值，这里是一个 CGPoint 的指针，我们可以让其指向一个新的 CGPoint 以自由控制最终的 contentOffset 大小。除了让我们改变最终停止的位置，这个方法还可以使我们能够对要展示区域的数据提前进行准备。 scrollViewShouldScrollToTop:：在用户点击状态栏的时候回调，返回 YES 允许 scrollView 滚动到顶端。 scrollViewDidScrollToTop:：在点击顶部状态栏并且滚动到顶端后回调。 scrollViewDidEndDecelerating:：在结束减速动画的时候调用。可以用来继续之前暂停的复杂操作。 如何重用 UICollectionViewCell可以通过 UINib 以及 class 两种方式注册 cell： registerClass:forCellWithReuserIdentifier: registerNib:forCellWithReuseIdentifer: 当 dequeueReuseableCellWithReuseIdentifirer:forIndexPath: 被调用的时候，你将获得一个被重用的 cell，如果此时没有可用的 cell，系统会帮你创建一个。 展现内容准备一个 cell 类自定义一个类继承于 UICollectionViewCell: 1234567@interface SimpleCollectionViewCell : UICollectionViewCell@property (nonatomic,copy) NSString *num;- (void)refreshData;@end UICollectionViewCell 提供了一个重用前清空 cell 内数据的方法 prepareForReuse，重写它，： 1234- (void)prepareForReuse &#123; [super prepareForReuse]; self.num = @"";&#125; 一定要调用 super 方法 设置 ViewController先添加一个 CollectionView，然后注册，先定义一个 static 的 Identifier： 12345678910111213141516171819202122static NSString *SIMPLECELLIDENTIFIER = @"Simple Cell Identifier";- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置 flowLayout UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init]; flowLayout.minimumInteritemSpacing = 40; flowLayout.minimumLineSpacing = 40; flowLayout.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); flowLayout.itemSize = CGSizeMake(50, 50); // 添加 collectionView，记得要设置 delegate 和 dataSource 的代理对象 _collectionView = [[UICollectionView alloc] initWithFrame:self.view.frame collectionViewLayout:flowLayout]; _collectionView.delegate = self; _collectionView.dataSource = self; _collectionView.backgroundColor = [UIColor redColor]; [self.view addSubview:_collectionView]; // 注册 cell [_collectionView registerClass:[SimpleCollectionViewCell class] forCellWithReuseIdentifier:SIMPLECELLIDENTIFIER];&#125; 一定要先将 collectionView 的 delegate 和 dataSource 设置为 self 哦 实现代理实现两个必须的代理，一个返回 item 的数量，一个返回具体的 cell： 12345678910- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return _count;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; SimpleCollectionViewCell *cell = (SimpleCollectionViewCell *)[collectionView dequeueReusableCellWithReuseIdentifier:SIMPLECELLIDENTIFIER forIndexPath:indexPath]; cell.num = [NSString stringWithFormat:@"%ld",(long)indexPath.item]; [cell refreshData]; return cell;&#125; 批量处理可以将这些操作通过 performBatchUpdates:completion: 方法进行批量处理： 123456- (void)addItem:(id)sender &#123; [self.collectionView performBatchUpdates:^&#123; [self.collectionView deleteItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:2 inSection:0]]]; [self.collectionView insertItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:5 inSection:0]]]; &#125; completion:nil];&#125; Cell 的视图层级在 cell 中添加视图的时候，我们要将视图添加到 contentView 上，而不是 self。我们可以观察 cell 的视图层级： 在 contentView 和 UICollectionViewCell 之间还存在着 selectedBackgroundView 和 backgroundView。一般情况下，这两个 view 都是 nil 的。如果你希望他们能显示出来，那么需要 alloc 出来，不需要手动设置 frame 大小，系统会自己撑满整个 cell： 1self.backgroundView = [UIView alloc] init]; 更进一步上面一节讲了如何展示一个最基本的 CollectionView，本节要在展示的基础上拓展一些操作方法。 Supplementary ViewsSupplementary View 是 UICollectionViewLayout 提供的，可以随着 CollectionView 滚动，并且是数据驱动，可以展示信息的。 在 UICollectionViewFlowLayout 中提供了两种 Supplementary View：头部视图和尾部视图。但是这只是在这种 Layout 方式下的特殊类型，之后我们会学习如何自定义 Supplementary View。只要记住，任何有数据展示的并且不是 cell 的视图，都可以用 Supplementary View 展示。 Supplementary View 和 cell 类似，也需要注册 Nib 或者 Class，也会被一直重用。 定义一个 Supplementary View 类自定义的 Supplementary View 继承于 UICollectionReusableView。这个类提供了一些和 UICollectionViewCell 相同的方法（其实 UICollectionViewCell 就是继承于 UICollectionReusableView 的），但是比其更轻量级，比如无法像 Cell 一样，处理点击以及高亮等（如果你想要，你需要自己实现）。 1234567@interface SimpleReusableView : UICollectionReusableView@property (nonatomic,strong) NSString *num;- (void)refreshData;@end 同样实现以下 prepareForReuse 方法： 1234- (void)prepareForReuse &#123; [super prepareForReuse]; self.num = @"";&#125; 设置 ViewController还是在 viewDidLoad 方法中注册，同样先定义一个 Identifier： 12345678910111213static NSString *SIMPLESUPPLEMENTARYIDENTIFIER = @"Simple Supplementary Identifier";static NSString *SIMPLECELLIDENTIFIER = @"Simple Cell Identifier";- (void)viewDidLoad &#123; [super viewDidLoad]; ... // 设置大小 flowLayout.headerReferenceSize = CGSizeMake(self.view.bounds.size.width, 30); // 注册 Supplementary View [_collectionView registerClass:[SimpleReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:SIMPLESUPPLEMENTARYIDENTIFIER];&#125; 这里注册的是 header:UICollectionElementKindSectionHeader，类似的还可以注册 footer:UICollectionElementKindSectionFooter 另外，一定要设置 UICollectionViewFlowLayout 的 headerReferenceSize 属性，其默认是 CGSizeZero 的，如果不手动设置，Supplementary View 就无法显示。但是切记，如果你设置了这个值，就一定要实现 collectionView:viewForSupplementaryElementOfKind:atIndexPath: 返回一个 SupplementaryView，否则就会产生异常。 实现代理：同样实现两个代理，一个返回 section 的数量，一个返回 Supplementary View ： 12345678910- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return _sectionCount;&#125;- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath &#123; SimpleReusableView *reuseableView = (SimpleReusableView *)[collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:SIMPLESUPPLEMENTARYIDENTIFIER forIndexPath:indexPath]; reuseableView.num = [NSString stringWithFormat:@"%ld",(long)indexPath.section]; [reuseableView refreshData]; return reuseableView;&#125; 响应交互实现 CollectionViewDelegate 的方法 collectionView:didSelectedAtIndexPath: 1234567- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; // 取消选中 [collectionView deselectItemAtIndexPath:indexPath animated:YES]; // 获取当前点击的 cell SimpleCollectionViewCell *cell = (SimpleCollectionViewCell *)[collectionView cellForItemAtIndexPath:indexPath]; ...&#125; deselectItemAtIndexPath:animted: 方法取消选中。 cellForItemAtIndexPath: 方法通过 indexPath 获取当前 cell。 对 item 和 section 的操作系统提供了以下方法来对 item 和 section 进行插入、删除、重载、移动操作： insertSections: deleteSections: reloadSections: moveSection:toSection: insertItemsAtIndexPaths: deleteItemsAtIndexPaths: reloadItemsAtIndexPaths: moveItemAtIndexPath:toIndexPath: 注意一定要先改变 item 或者 section 的数量，然后才能对 item 或者 section 进行插入和删除。 这些方法可以放在 performBatchUpdates:completion: 中进行批量处理。 改变 item 和 section 的大小前面，我们通过 UICollectionViewFlowLayout 的 itemSize 和 headerReferenceSize (包括 footerReferenceSize) 统一设置了 item 和 section 的大小。 如何每个 item 和 section 的大小不规则呢？ 我们可以实现 UICollectionViewDelegateFlowLayout 协议中的以下方法实现： collectionView:layout:sizeForItemAtIndexPath: collectionView:layout:referenceSizeForHeaderInSection: collectionView:layout:referenceSizeForFooterInSection: 实现这些方法，并在根据 indexPath 返回响应的 CGSize. UICollectionViewDelegateFlowLayout协议继承于 UICollectionViewDelegate协议，所以仍然将 CollectionView 的 delegate 设置为 ViewController 就行了。 是否可以选中实现 UICollectionViewDelegate 协议中的以下方法可以实现控制 item 是否可以高亮，选中，取消选中： collectionView:shouldHighlightItemAtIndexPath: collectionView:shouldSelectItemAtIndexPath: collectionView:shouldDeselectedItemAtIndexPath: 复制粘贴操作有时候我们想复制一些 cell 中的东西，实现下面方法就可以复制： 12345678910111213141516171819202122// 能否选中- (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125;// 选中后能否弹出菜单- (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125;// 能否执行菜单里的某个操作- (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender &#123; return YES;&#125;// 棘突执行菜单选项的操作- (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender &#123; if ([NSStringFromSelector(action) isEqualToString:@"copy:"]) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; [pasteboard setString:((SimpleCollectionViewCell *)[collectionView cellForItemAtIndexPath:indexPath]).num]; &#125;&#125; 使用 UICollectionViewFlowLayout创建 UICollectionViewFlowLayout 的子类系统的 UICollectionViewFlowLayout 虽然允许你定义 item 以及 Supplementary Views 的大小，但是你不能自定义每个 View 的位置。比如下图，你想让所有 item 都沿着虚线排布，只用 UICollectionViewFlowLayout 是不够的。我们需要继承它，并且重写其中的部分方法，实现自定义的布局。 继承 UICollectionViewFlowLayout创建一个类，继承于 UICollectionViewFlowlayout，重写它 init 方法。我们可以把之前写在 ViewController 中的对于 layout 的设置移到 init 方法中，作为默认实现，减少 VC 中的代码量： 123456789101112- (instancetype)init &#123; if (!(self = [super init])) &#123; return nil; &#125; self.minimumInteritemSpacing = 20; self.minimumLineSpacing = 40; self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); self.itemSize = CGSizeMake(50, 50); self.headerReferenceSize = CGSizeMake([UIScreen mainScreen].bounds.size.width, 30); return self;&#125; 重写布局方法 layoutAttributesForElementsInRect:我们需要重写 layoutAttributesForElementsInRect: 方法，该方法返回一个包含所有布局信息 UICollectionViewLayoutAttributes的数组。比如我们可以把 CollectionView 中所有 cell 都旋转 45°： 123456789101112- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSArray *array = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newArray = [NSMutableArray array]; for (UICollectionViewLayoutAttributes *attrs in newArray) &#123; UICollectionViewLayoutAttributes *newAttrs = [attrs copy]; if (attrs.representedElementKind == nil) &#123; newAttrs.transform = CGAffineTransformMakeRotation(45); &#125; [newArray addObject:newAttrs]; &#125; return newArray;&#125; 我们通过父类方法 [super layoutAttributesForElementsInRect:rect] 先创建了一个正常情况下的所有属性的数组。这个父类方法默认情况下，只会创建在 rect 范围内的视图的布局属性。所以如果你想把原来不会被现实的视图也显示出来的话，你就不得不自己把所有布局属性都创建出来，放入数组中。 最好不要直接修改这个数组里的元素，而是创建一个新的拷贝。否则当你想增删修改 cell 的时候会出现下面的问题，极有可能引起应用崩溃： 修改的时候我们还要判断 attrs.representedElementKind == nil。这是由于这个属性数组包含了所有视图的布局信息，包括 cell,supplementary view,decortation view。当 representedElementKind 是 nil 的时候，表示这个布局信息是 Item 的布局信息。 重写其他布局方法除了layoutAttributesForElementsInRect: 方法，还提供了如下方法用来分别订制 Item，SupplementaryView，DecorationView： layoutAttributesForItemAtIndexPath: layoutAttributesForSupplementaryViewOfKind:atIndexPath: layoutAttributesForDecorationViewOfKind:atIndexPath: 这些方法用来订制某个特殊的视图的布局。系统一般不会主动调用你你重写的这几个方法（不是绝对不会调用啊，比如下面的移动 Item 的时候，就是系统调用这个方法获取被点击的 Item 的布局属性。所以最好还是实现这几个方法，然后手动在 layoutAttributesForElementsInRect: 中调用），需要你自己在 layoutAttributesForElementsInRect: 中手动调用。比如将第二栏的第五个 Item 及第二栏的 SupplementaryView 旋转 45°： 12345678910111213141516171819202122232425262728293031323334- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSArray *array = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newArray = [NSMutableArray array]; for (UICollectionViewLayoutAttributes *attrs in array) &#123; UICollectionViewLayoutAttributes *newAttrs = [attrs copy]; // 设置每一个 item if (attrs.representedElementKind == nil) &#123; if (attrs.indexPath.item == 5 &amp;&amp; attrs.indexPath.section == 1) &#123; newAttrs = [self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:5 inSection:1]]; &#125; &#125; // 设置每一个 SupplementaryView if (attrs.representedElementCategory == UICollectionElementCategorySupplementaryView) &#123; if (attrs.indexPath.section == 1) &#123; newAttrs = [self layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader atIndexPath:[NSIndexPath indexPathForItem:0 inSection:1]]; &#125; &#125; [newArray addObject:newAttrs]; &#125; return newArray;&#125;- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *itemAttributes = [super layoutAttributesForItemAtIndexPath:indexPath]; itemAttributes.transform = CGAffineTransformMakeRotation(-45); return itemAttributes;&#125;- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *supplementaryAttributes = [super layoutAttributesForSupplementaryViewOfKind:elementKind atIndexPath:indexPath]; itemAttributes.transform = CGAffineTransformMakeRotation(45); return supplementaryAttributes;&#125; 其中判断 representElementCategory 是否为 UICollectionElementCategorySupplementaryView 来区分是否是 SupplementaryView。 使用 DecorationViewDecorationView 不展示任何信息，所以不需要再 ViewController 中添加任何代码，所有的代码都在 UICollectionViewFlowLayout 的子类中。DecorationView 也是继承于 UICollectionReusableView。 创建一个 DecorationView 实例DecorationView 除了继承于 UICollectionReusableView 之外和普通 View 的创建毫无差异。重写它的 init 方法： 12345678910111213- (instancetype)initWithFrame:(CGRect)frame &#123; if (!(self = [super initWithFrame:frame])) &#123; return nil; &#125; _decorationView = [[UIView alloc] initWithFrame:frame]; _decorationView.backgroundColor = [UIColor blueColor]; [self addSubview:_decorationView]; return self;&#125;- (void)layoutSubviews &#123; _decorationView.frame = self.bounds;&#125; 重写 layoutAttributesForDecorationViewOfKind:atIndexPath:如果你愿意，你想设置多少个 DecorationView 就可以设置多少个。下面将实现为某个 section 添加一个 DecorationView 的背景： 1234567891011121314- (UICollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *decorationAttributes = [UICollectionViewLayoutAttributes layoutAttributesForDecorationViewOfKind:elementKind withIndexPath:indexPath]; UICollectionViewLayoutAttributes *newDecorationAttributes = [decorationAttributes copy]; if ([elementKind isEqualToString:SIMPLEDECORATIONKIND]) &#123; NSIndexPath *indexPathFirst = [NSIndexPath indexPathForItem:0 inSection:1]; NSIndexPath *indexPathLast = [NSIndexPath indexPathForItem:[self.collectionView numberOfItemsInSection:1] inSection:1]; UICollectionViewLayoutAttributes *attrsFirst = [self layoutAttributesForItemAtIndexPath:indexPathFirst]; UICollectionViewLayoutAttributes *attrsLast = [self layoutAttributesForItemAtIndexPath:indexPathLast]; newDecorationAttributes.frame = CGRectMake(attrsFirst.frame.origin.x, attrsFirst.frame.origin.y, self.collectionView.frame.size.width, attrsLast.frame.origin.y-attrsFirst.frame.origin.y); // 想要作为背景图像，就一定要将其 zIndex 设置为 -1 newDecorationAttributes.zIndex = -1; &#125; return newDecorationAttributes;&#125; 这个方法中，通过 section1 中最后一个 item 与第一个 item，计算得出了 section 的大小以及位置。将设置为 UICollectionViewLayoutAttributes 的 frame 属性。 由于是背景所以一定要将其 zIndex 设置为一个负值，使其永远在图层的下部。 这里判断的 SIMPLEDECORATIONKIND 是一个自己设定的字符串，用来标识是哪个 DecorationView。 可以通过 [UICollectionViewLayoutAttributes layoutAttributesForDecorationViewOfKind:elementKind withIndexPath:indexPath] 这个类方法获取了一个默认的布局属性的值（之前我们都是用 super 获取的），Item 和 SupplementaryView 也有类似的方法： [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath] [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:elementKind withIndexPath:indexPath] [UICollectionViewLayoutAttributes layoutAttributesForDecorationViewOfKind:elementKind withIndexPath:indexPath] 添加布局属性在 layoutAttributesForElementsInRect: 中调用上面的方法，将其属性添加到布局属性数组中。 1234567891011- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSArray *array = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newArray = [NSMutableArray array]; // 设置 Item 和 SupplementaryView ... // 设置 DecorationView UICollectionViewLayoutAttributes *newAttrs = [self layoutAttributesForDecorationViewOfKind:SIMPLEDECORATIONKIND atIndexPath:[NSIndexPath indexPathForItem:0 inSection:1]]; [newArray addObject:newAttrs]; return newArray;&#125; 初始方法中注册自己由于 DecorationView 是和数据无关的，不需要在 ViewController 中添加任何代码。我们在 UICollectionViewFlowLayout 中注册自己： 123456789101112// SimpleCollectionViewFlowLayout.mstatic NSString *SIMPLEDECORATIONKIND = @"Simple Decoration Kind";- (instancetype)init &#123; if (!(self = [super init])) &#123; return nil; &#125; // layout 的其他初始化设置 ... [self registerClass:[SimpleDecorationView class] forDecorationViewOfKind:SIMPLEDECORATIONKIND]; return self;&#125; 为什么要注册呢？因为布局属性中只知道 kind 这个标识的字符串是不行的，要将 kind 和 class 关联起来。所以需要 registerClass:forDecorationViewOfKind: 这一个步骤。Item 和 SupplementaryView 的注册也是类似的道理（这两个的注册是为了 class 和重用数组关联起来）。 最终的显示效果： UICollectionViewLayoutAttributes 的属性布局属性 UICollectionViewLayoutAttributes 包含了许多属性： Frame Center Size 3D Transform Alpha Z-Index Hidden Element category （cell，supplementary view，or decoration view） Element kind （nil for cells） 最后两个属性用来判断视图的类型，这个在之前也用到过了。representedElementCategory 是一个枚举，包含了表示 cell，SupplementaryView，DecorationView 的几个枚举值。representedElementKind 其实就是注册 SupplementaryView 和 DecorationView 时候传入的 kind，由于 Item 注册的时候不需要传入 kind，所以 Item 布局的这个属性就是 nil。 继承 UICollectionViewLayout一般情况下，能用 UICollectionViewFlowLayout 的，我们就不需要自己继承 UICollectionViewLayout。 新建一个类继承于 UICollectionViewLayout，该类提供了一个方法 prepareLayout 用来做布局前的准备，在每次布局的时候都会调用。我们可以把之前在 init 中的设置放到这个方法中： 1234567- (void)prepareLayout &#123; [super prepareLayout]; CGSize size = self.collectionView.bounds.size; _cellCount = [self.collectionView numberOfItemsInSection:0]; _center = CGPointMake(size.width/2, size.height/2); _radius = size.width/2.5;&#125; 同样的我们需要实现 layoutAttributesForElementsInRect: 来获取布局属性： 12345678910111213141516- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSMutableArray *attrs = [NSMutableArray array]; for (int i = 0; i &lt; self.cellCount; i++) &#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:i inSection:0]; [attrs addObject:[self layoutAttributesForItemAtIndexPath:indexPath]]; &#125; return attrs; &#125;- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *attrs = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; attrs.size = CGSizeMake(70, 70); attrs.center = CGPointMake(self.center.x +self.radius * cosf(2 * indexPath.item * M_PI / self.cellCount -M_PI_2), self.center.y +self.radius * sinf(2 * indexPath.item * M_PI /self.cellCount - M_PI_2)); attrs.transform3D = CATransform3DMakeRotation(2 * M_PI *indexPath.item / self.cellCount, 0, 0, 1); return attrs;&#125; 和 UICollectionViewFlowLayout 不同的是，这里的所有布局属性都需要我们自己实现，没有父类方法可以调用了。另外，由于 collectionView:sizeForItemAtIndexPath: 这个获取 Item 大小的方法也是 FlowLayout 提供的，所以我们需要自己设置布局属性的 size。 ### 一个例子如何将布局切换到下面这个图片的效果呢？下面将分析几个基本点，具体详见 Demo。 切换布局一个 CollectionView 可以通过其自身的 setCollectionViewLayout:animated: 方法随时切换布局。在切换布局后，需要通过 invalidateLayout 方法刷新新设置的布局。 一列展示一个一列展示一个，你可以重写 Item 的布局方法手动计算每一个 Item 的 frame，但是这是没有必要的。UICollectionViewFlowLayout 默认在当前列不能排下下一个 Item 的时候自动换列，所以我们只要将 minimumInteritemSpacing 设置的很大就可以了。 设置布局属性我们要对在屏幕上显示的视图，根据其所在的位置设置布局属性。我们可以通过自定义的 FlowLayout 类拿到 CollectionView 实例的 contentOffset（self.collectionView.contentOffset.x），然后和布局属性的 frame 进行比较。 12345678910111213141516- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSArray *array = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newArray = [NSMutableArray array]; float centerX = self.collectionView.contentOffset.x + self.collectionView.bounds.size.width/2; for (UICollectionViewLayoutAttributes *attrs in array) &#123; UICollectionViewLayoutAttributes *newAttrs = [attrs copy]; if (newAttrs.representedElementCategory == UICollectionElementCategorySupplementaryView) &#123; continue; &#125; float offset = 1.5 - fabs(centerX - attrs.center.x)/self.collectionView.frame.size.width; newAttrs.transform = CGAffineTransformScale(newAttrs.transform, offset, offset); [newArray addObject:newAttrs]; &#125; return newArray;&#125; 动态计算布局属性获取布局属性只会在加载的时候进行一次，而这个例子需要时时根据 offset 更新。这就需要重写 FlowLayout 的 shouldInvalidateLayoutForBoundsChange: 方法，并返回 YES，保证用户滑动的时候，布局属性的方法总是会重新计算的： 123- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds &#123; return YES;&#125; 滑动到特定位置这个例子中需要在停止滑动的时候，图片总是在最中间的，那就需要改变最终的 offset。可以重写 targetContentOffsetForProposedContentOffset:withScrollingVelocity:，该方法输入理想情况下的 contentOffset，返回一个自己设定的 contentOffset。因此，你可以找到离屏幕中心最近的布局属性，然后计算其与中心的差值作为补偿值： 1234567891011121314- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity &#123; CGRect proposedRect = CGRectMake(proposedContentOffset.x, 0, self.collectionView.bounds.size.width, self.collectionView.bounds.size.height); NSArray *array = [self layoutAttributesForElementsInRect:proposedRect]; float offset = 1000; for (UICollectionViewLayoutAttributes *attrs in array) &#123; if (attrs.representedElementCategory == UICollectionElementCategorySupplementaryView) &#123; continue; &#125; if (fabs(attrs.center.x - (proposedContentOffset.x+self.collectionView.bounds.size.width/2))&lt;fabs(offset)) &#123; offset = attrs.center.x - (proposedContentOffset.x+self.collectionView.bounds.size.width/2); &#125; &#125; return CGPointMake(proposedContentOffset.x + offset, proposedContentOffset.y);&#125; 总结 整个 CollectionView 可以划分为两个部分，视图部分和布局部分。这两者如何联系在一起的，或者说给定一块区域到底是如何知道应该显示哪个视图的呢？通过 indexPath 以及 representedElementKind。这两个都是 UICollectionViewLayoutAttributes 中的属性。 在视图加载的时候，会在 layoutAttributesForElementsInRect 返回的数组中找到会在屏幕上显示的布局，然后根据这个布局的 indexPath 以及 representedElementKind 通过 collectionView:viewForSupplementaryElementOfKind:atIndexPath,collectionView:cellForItemAtIndexPath 这两个代理方法，获取相对应的视图展示出来。 那么为什么有了 indexPath 了还要 representedElementKind 呢？对于 Item 来说，indexPath 可以通过 item 和 section 唯一地确定视图。但是对于 SupplementaryView 的 DecorationView，这两个视图通常只用到了 section 而不用 item（其实你想用 item 来标识也是可以的，representedElementKind 其实就相当于是个 item 的作用。比如一个 SupplementaryView 的头尾视图，你可以规定 item 为0代表头视图，item 为1代表尾视图，但是这样肯定没有用 UICollectionElementKindSectionHeader,UICollectionElementKindSectionFooter 来的直观），所以就要用一个 representedElementKind 来标识在同一个 section 内，这个位置到底是应该显示哪个视图。 一些应用移动 Item首先，在 ViewController 中为 CollectionView 添加长按手势： 12345- (void)viewDidLoad &#123; ... UILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handlelongGesture:)]; [self.collectionView addGestureRecognizer:longGesture];&#125; 实现手势操作，算是比较固定的套路： 123456789101112131415161718192021222324252627//再实现手势操作- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture &#123; //判断手势状态 switch (longGesture.state) &#123; case UIGestureRecognizerStateBegan:&#123; //判断手势落点位置是否在路径上 NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:[longGesture locationInView:self.collectionView]]; if (indexPath == nil) &#123; break; &#125; //在路径上则开始移动该路径上的cell [self.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath]; &#125; break; case UIGestureRecognizerStateChanged: //移动过程当中随时更新cell位置 [self.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:self.collectionView]]; break; case UIGestureRecognizerStateEnded: //移动结束后关闭cell移动 [self.collectionView endInteractiveMovement]; break; default: [self.collectionView cancelInteractiveMovement]; break; &#125;&#125; 其中 CollectionView 提供了 indexPathForItemAtPoint: 方法通过坐标找到对应的 Item。 在 CollectionView 中允许 Item 移动： 12345678//返回YES允许其item移动- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;//移动item时回调- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath &#123;&#125; 点击 Item 高亮操作实现方式是在高亮的回调方法中获取当前点击的 Item，然后对其布局属性进行修改： 12345678910111213141516171819// 允许选中时，高亮-(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;// 高亮完成后回调// 放大缩小效果-(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath]; [UIView animateWithDuration:1 animations:^&#123; selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f); &#125;];&#125;// 由高亮转成非高亮完成时的回调-(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *selectedCell = [collectionView cellForItemAtIndexPath:indexPath]; [UIView animateWithDuration:1 animations:^&#123; selectedCell.transform = CGAffineTransformMakeScale(1.0f, 1.0f); &#125;];&#125; 无限轮播无限轮播的主要方法就是将 CollectionView 的 Item 设置的足够多以至于让用户不能一下子滚动到底部。并且，在滑动到临界区的时候修改器 contentOffset. 初始化比如要实现一个图片的轮播，collectionview 传入了一组 url： 1234567891011121314151617181920212223242526- (instancetype)initWithURLs:(NSArray &lt;NSURL *&gt; *)urls &#123; // UICollectionViewFlowLayout self = [super initWithFrame:CGRectZero collectionViewLayout:[[LoopViewLayout alloc] init]]; if (self) &#123; _urls = urls; self.dataSource = self; self.delegate = self; // 自定义了一个 LoopViewCell 具体布局按照实际情况设置 [self registerClass:[LoopViewCell class] forCellWithReuseIdentifier:loopViewCellId]; // 初始显示第二组 [0,1,2] [3(_urls.count),4,5] // 主队列： // 1. 安排任务在主线程上执行 // 2. 如果主线程当前有任务，主队列暂时不调度任务！所以等cell的数据源和代理方法执行完毕后才执行这个block里面的滚动任务. dispatch_async(dispatch_get_main_queue(), ^&#123; NSIndexPath *indexPath = [NSIndexPath indexPathForItem:_urls.count inSection:0]; // 滚动位置！ [self scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionLeft animated:NO]; &#125;); &#125; return self;&#125; 初始化的时候先将 collectionview 滚动到第二组的第一个cell。 设置cell个数1234- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; //这里为了防止滚动到最后一页来回跳动导致的卡顿,多写点组数让一直到不了最后一组,因为cell重用,所以不影响内存. return _urls.count * 100;&#125; 防止滚动太多引起卡顿，所以将数量设置的很大 边界设置123456789101112131415161718#pragma mark - UICollectionViewDelegate- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; // 1. 获取当前停止的页面 NSInteger offset = scrollView.contentOffset.x / scrollView.bounds.size.width; // 2. 第0页，调转到，第1组的第0页 // 最后一页，跳转到第0组的最后一页 if (offset == 0 || offset == ([self numberOfItemsInSection:0] - 1)) &#123;// NSLog(@"%zd", offset); // 第 0 页 if (offset == 0) &#123; offset = _urls.count; &#125; else &#123; offset = _urls.count - 1; &#125; // 重新调整 contentOffset scrollView.contentOffset = CGPointMake(offset * scrollView.bounds.size.width, 0); &#125;&#125; 自行按照情况设置 contentOffse 流式布局其实就是在 prepareLayout 方法中，自定义了每一个 Item 的布局属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@interface MyLayout : UICollectionViewFlowLayout@property(nonatomic,assign)int itemCount;@end @interface MyLayout()@property (nonatomic,assign) CGFloat maxHeight;@end@implementation MyLayout&#123; //这个数组就是我们自定义的布局配置数组 NSMutableArray * _attributeAttay;&#125;//数组的相关设置在这个方法中//布局前的准备会调用这个方法-(void)prepareLayout&#123; _attributeAttay = [[NSMutableArray alloc]init]; [super prepareLayout]; //演示方便 我们设置为静态的2列 //计算每一个item的宽度 float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2; //定义数组保存每一列的高度 //这个数组的主要作用是保存每一列的总高度，这样在布局时，我们可以始终将下一个Item放在最短的列下面 CGFloat colHight[2]=&#123;self.sectionInset.top,self.sectionInset.bottom&#125;; //itemCount是外界传进来的item的个数 遍历来设置每一个item的布局 for (int i=0; i&lt;_itemCount; i++) &#123; //设置每个item的位置等相关属性 NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0]; //创建一个布局属性类，通过indexPath来创建 UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index]; //随机一个高度 在40——190之间 CGFloat hight = arc4random()%150+40; //哪一列高度小 则放到那一列下面 //标记最短的列 int width=0; if (colHight[0]&lt;colHight[1]) &#123; //将新的item高度加入到短的一列 colHight[0] = colHight[0]+hight+self.minimumLineSpacing; width=0; &#125;else&#123; colHight[1] = colHight[1]+hight+self.minimumLineSpacing; width=1; &#125; //设置item的位置 attris.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*width, colHight[width]-hight-self.minimumLineSpacing, WIDTH, hight); [_attributeAttay addObject:attris]; &#125; if (colHight[0]&gt;colHight[1]) &#123; _maxHeight = colHight[0]; &#125;else&#123; _maxHeight = colHight[1]; &#125; &#125;-(CGSize)collectionViewContentSize&#123; return CGSizeMake(100, _maxHeight);&#125;//这个方法中返回我们的布局数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125;@end 本文Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一次面试]]></title>
    <url>%2F2017%2F07%2F25%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[第一次面试结束，心里五味杂陈。 上上周bang突然找到我，说我博客写的不错，问我有没有兴趣去蚂蚁金服。看到消息我是即兴奋又忐忑的。当然这是一个好机会，但是我又害怕自身能力不足浪费了人家的好意。由于毕业前一直都是研究 android，从去年7月毕业开始学习 oc 到现在，我也就总共学习了一年。可以说经验非常的浅，各方面接触过的东西也严重不足。每每看到网上一些和我同龄的人的博客，都有种自惭形秽的感觉。感叹当时为什么要从 android 转到 iOS，白白浪费了一年的时间。 这一次的面试也是我第一次正式的面试，简历之前都没有写过，也不知道面试的时候会问什么，可以说非常的茫然，不过也是硬着头皮上了。第一面的时候波澜不惊吧，问的都是 oc 基础的东西，也是这一年里最开始学的东西。今天早上接到了第二面，开始问一些项目里的问题。虽然也都是很基础的问题，可以说是用过就会的东西，但是…..偏偏我并没有用过。哎。然后越问越紧张，一些原本知道的东西也变得支支吾吾的了。表现非常的糟糕。 说实话，心里还是很难过的。毕竟这是一个非常好的机会，而且本身觉得在现在公司学不到什么也犹豫是不是要换工作。但是还是自己太弱了啊，连一些基本的东西都没有看过，也怪不得别人。 失败了就失败了吧。这一次失败也让我意识到了长路漫漫，还需要不断的学习。一年的时间，收获不少，但是起点太低，时间太短，所以跑的没有别人远。但是，只要能保持着比别人更高的速度，就一定能在未来的某一天赶超上去。 干他妈的！]]></content>
      <categories>
        <category>无处置放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 和 OC 的混编实践]]></title>
    <url>%2F2017%2F07%2F05%2FSwift%E5%92%8COC%E7%9A%84%E6%B7%B7%E7%BC%96%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[最近想用 Swift 重写项目，接触了一下 OC 和 Swift 的混编技巧，发现坑还是挺多的。尤其是使用 cocoapods 导入的库的混编。这里记录一下各种应用场景。 主工程中使用Swift 中调用 OC首先创建一个 OC 的项目，然后直接在工程里添加 Swift 文件。此时会弹出一个提示，问你是否添加一个桥接文件，你需要自己添加要暴露给 Swift 使用的 OC 的头文件。 自动帮你创建的，不要白不要啊，所以果断点击 create。 这个时候就会生成一个 项目名-Bridgeing-Header.h 的头文件： 当然，你也可以自己创建与设置，在 Build Settings 中设置： 现在在桥接文件中添加要暴露给 Swift 调用的头文件： 然后在 Swift 中调用即可，非常的 easy： OC 中调用 SwiftOC 中要调用 Swift 也要导入一个头文件，这个头文件对外不可显示，其命名方式是：模块名-Swift.h。可以在 Build setting 中查看： 现在我们在 OC 中添加这个头文件： 比较 OC 和 Swift 的调用方式还是不同的，我们需要查看一下到底可以调用那些方法和类。这个时候，我们可以点进这个头文件中去。进入头文件往下拉，可以看到暴露出来的 Swift 的类名和方法： 涉及 cocoapods上面完全是主工程里使用当然毫无难度，但是日常的开发中肯定要用到其他的别人的库，或者自建的私有库，这个时候怎么混编呢？我们先用 pod lib create OCWithSwift 命令创建一个类库。然后在其中分别添加一个 Swift 文件和一个 OC 文件： 库中 Swift 调用 OC库中 Swift 调用 OC 和主工程中有什么不同呢？我们先到 Build Settings 中查看这个头文件应该叫什么： 发现什么也没有。这个时候千万不要手贱去创建一个，和主工程中不同的是，使用cocoapods 创建的库里面我们不需要自己创建这个桥接文件了。现在直接在 Swift 文件中调用，可以使用 OC 的类和方法： 我们点进这个类中，发现 Xcode 已经自动生成了这个 OC 文件的 Swift 代码： 那么这是为什么呢？搜索一下我们可以发现在 OCWithSwift-umbrella.h 中引用了这个 OC 文件。所以这个头文件其实就是做了桥接的作用，应该是由 cocoapods 设置的： 为了测试，我们再创建一个 OC 文件 OCFile_2.h，然后同样导入到 OCWithSwift-umbrella.h: 这个时候编译，报出异常： 我们需要做的就是将这个文件设置为 Public： 现在再编译就没有问题了。可以直接在 Swift 中使用： 库中 OC 调动 Swift库中 OC 调用 Swift 的过程还是大致相同的。先看看 Build Settings： 我们在 OC 文件中引入，不过这次要引入的格式为 #import &lt;产品名/模块名-Swift.h&gt;，我们还是可以在 Build Settings 中查看： 现在在 OC 中使用，编译后报出错误，use of undeclared identifier &#39;SwiftFile&#39;: 为什么 SwiftFile 会是未被声明的呢？我们进入 OCWithSwift-Swift.h 中查看： 桥接文件中并没有发现 SwiftFile 的身影，确实是没有声明。那么要如何才能将 SwiftFile 暴露出来呢？为 Swift 类和方法添加 public 修饰符： 重新 Build 一下， 我们再次进入 OCWithSwift-Swift.h 文件，方法出现了： 主工程中 Swift 调用库中类与方法在上一步中，其实库中的 Swift 和 OC 都已经生成了对应的 OC 和 Swift 方法。在主工程中直接引入调用即可: 可以看到，不论是 Swift 直接调用 Swift，还是 Swift 调用 OC 转换后的 Swift 都是没有问题的。 主工程中 OC 调用库中类与方法同样在主工程中的 OC 类中引用需要的类即可： OC 调用库中 OC 和 Swift 转换的 OC 同样没有问题。 到这里基本上该趟的坑都趟过了 参考自官方文档 我的demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app 间的跳转与信息传递]]></title>
    <url>%2F2017%2F07%2F02%2Fapp%E9%97%B4%E7%9A%84%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[日常使用中，经常会遇到分享、支付等功能需要跳转到另一个 app 进行处理，然后处理回调信息。本篇将对这个功能进行学习。 应用间跳转是通过苹果实现的类似于路由的 URL Schemes（自定义协议头）实现的。应用B约定好打开自身的协议头，应用A则在特定的场合调用这个协议头，实现跳转。 URL SchemeA-&gt;B直接跳转B中注册要跳转到B，就得先让B注册自己的 URL Schemes。在 Info-&gt;URL Types 中新建一个: 这里的添加最终映射到的是 plist 文件中，URL Schemes 将在 plist 文件中以键值对的方式保存，可以自由的添加和删除 A中调用B中注册好了 URL Schemes，我们可以直接在 safari 中输入 zacharyB1:// 就可以打开 app 了，这也是很多h5中要打开关联的 app 都提示在 safari 中打开的原因。我们现在在A中添加跳转逻辑： 123456789101112- (IBAction)jumpToAppB:(id)sender &#123; // 1.获取应用程序App-B的URL Scheme NSURL *appBUrl = [NSURL URLWithString:@"zacharyB1://"]; // 2.判断手机中是否安装了对应程序 if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) &#123; // 3. 打开应用程序App-B [[UIApplication sharedApplication] openURL:appBUrl]; &#125; else &#123; NSLog(@"没有安装"); &#125;&#125; 这里要注意一点，iOS9 后引入了白名单的概念。A在调用 canOpenURL: 方法的时候，会在A的白名单中查看是否可以跳转应用B，所以我们还要提前将B注册到A的白名单当中。具体做法就是在应用A的 plist 文件中，添加 LSApplicationQueriesSchemes 数组，然后减价键值为 zacharyB1 的字符串： 添加好白名单后，就可以正常的跳转了。 带参数的跳转A中调用上面是直接跳转打开应用B，但是实际情况下，我们可能要打开B的某个页面，并且要传递一些参数过去。本身 openURL 是不带参数的，我们需要按照约定的规则，将参数作为 URL 的一部分传入，由应用B自己解析。 比如区分跳转到B的某一个页面1还是页面2，我们分别定制 URL： 12345678910111213141516171819202122232425- (IBAction)jumpToAppBPage1:(id)sender &#123; // 1.获取应用程序App-B的Page1页面的URL NSURL *appBUrl = [NSURL URLWithString:@"zacharyB1://Page1"]; // 2.判断手机中是否安装了对应程序 if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) &#123; // 3. 打开应用程序App-B的Page1页面 [[UIApplication sharedApplication] openURL:appBUrl]; &#125; else &#123; NSLog(@"没有安装"); &#125;&#125;- (IBAction)jumpToAppBPage2:(id)sender &#123; // 1.获取应用程序App-B的Page2页面的URL NSURL *appBUrl = [NSURL URLWithString:@"zacharyB1://Page2"]; // 2.判断手机中是否安装了对应程序 if ([[UIApplication sharedApplication] canOpenURL:appBUrl]) &#123; // 3. 打开应用程序App-B的Page2页面 [[UIApplication sharedApplication] openURL:appBUrl]; &#125; else &#123; NSLog(@"没有安装"); &#125;&#125; B中处理在A调起B后，B中会执行特定方法，我们可以在其中添加处理逻辑，获取参数： 1234567891011121314151617- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; // 1.获取导航栏控制器 UINavigationController *rootNav = (UINavigationController *)self.window.rootViewController; // 2.每次跳转前必须是在跟控制器(细节) [rootNav popToRootViewControllerAnimated:NO]; // 3.根据字符串关键字来跳转到不同页面 if ([url.absoluteString containsString:@"Page1"]) &#123; // 跳转到应用B的Page1页面 [rootNav pushViewController:[[Page1ViewController alloc] init] animated:YES]; &#125; else if ([url.absoluteString containsString:@"Page2"]) &#123; // 跳转到应用B的Page2页面 [rootNav pushViewController:[[Page1ViewController alloc] init] animated:YES]; &#125; return YES;&#125; B-&gt;AB返回A的过程和A调用B的过程类似，相当于B主动调用A的 URL Scheme。B如何知道是哪个应用调用了它呢？这就需要A将自己的 URL Scheme 传给B。同样的，需要约定规则，比如如下： 1应用B的URL Schemes://要传的参数?应用A的URL Schemes 将应用A的 URL Scheme 在末尾传入，并且以 ? 分隔。B拿到后取出A的 URL Scheme，在必要的时候（如点击某个按钮）通过其调起应用A。 12345678910111213- (IBAction)page1BackToAppA:(id)sender &#123; // 1.拿到对应应用程序的URL Scheme NSString *urlSchemeString = [[self.urlString componentsSeparatedByString:@"?"] lastObject]; NSString *urlString = [urlSchemeString stringByAppendingString:@"://"]; // 2.获取对应应用程序的URL NSURL *url = [NSURL URLWithString:urlString]; // 3.判断是否可以打开 if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; [[UIApplication sharedApplication] openURL:url]; &#125;&#125; Universal Links除了 URL Scheme，iOS9中还提供了一种系统级的 APP 唤醒方式。这可以使你的应用可以通过传统的HTTP链接来启动APP(如果iOS设备上已经安装了你的app，不管在微信里还是在哪里)， 或者打开网页(iOS设备上没有安装你的app)。 开启使用首先要在开发者中心中开启这一功能： 然后在项目的配置中找到 Capabilities-&gt;Associated Domains： 以 applinks: 开头，后面跟着你的域名。这个域名必须支持 HTTPS 的 GET 请求。在第一次启动 APP 的时候，系统会自动到这个域名的根目录下，请求名为apple-app-site-association的文件，即会发送 https://domain.com/apple-app-site-association 请求。 apple-app-site-association 格式apple-app-site-association 是一个内容为json文件，且没有后缀名的文件(不能带.json的后缀)。文件内容大致如下： 123456789101112131415&#123; "applinks": &#123; "apps": [], "details": [ &#123; "appID": "9JA89QQLNQ.com.apple.wwdc", "paths": [ "/wwdc/news/", "/videos/wwdc/2015/*"] &#125;, &#123; "appID": "ABCD1234.com.apple.wwdc", "paths": [ "*" ] &#125; ] &#125;&#125; appID 的组成部分为：TeamID . BundleId TeamID。其中，TeamID 可以从苹果开发账号页面也 Your Account 下查看，BundleId 就直接在工程里看了。 完成这步后，系统就将域名和 app 绑定了起来。在任何其它应用中加载这个域名下的链接都将自动打开你绑定的 app。 APP 内的处理打开 APP 后会调用以下方法： 123456789101112131415- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb])&#123; //url是完整的带 domain 的url NSURL *url = userActivity.webpageURL; if (url是我们希望处理的)&#123; //打开对应页面 &#125; else&#123; //不能识别的用 safari 打开 [[UIApplication sharedApplication] openURL:url]; &#125; &#125; return YES;&#125; 当 userActivity 是 NSUserActivityTypeBrowsingWeb 类型, 则意味着它已经由通用链接 API 代理。这样的话, 它保证用户打开的 URL 将有一个非空的 webpageURL 属性。 iOS开发–一步步教你彻底学会『iOS应用间相互跳转』 iOS 9学习系列：打通 iOS 9 的通用链接（Universal Links）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 cocoapods 创建一个仓库]]></title>
    <url>%2F2017%2F06%2F30%2Fcocoapods%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%93%2F</url>
    <content type="text"><![CDATA[想搞一个组件化的项目，所以先好好看下如何使用 cocoapods 创建一个私有库 Cocoapods 简单原理之前的文章中我提到过，加速 pod install 的一个方法是 pod install--no-repo-update，下面就要解释一下这个后缀是要干什么。 Cocoapods 本地目录我们首先进入 Cocoapods 的本地目录： 1$cd ~/.cocoapods/repos/master 可以发现这其实是一个 git 仓库： 1234$ git remote -vorigin https://github.com/CocoaPods/Specs.git (fetch)origin https://github.com/CocoaPods/Specs.git (push) 进入 Specs 文件夹，会有很多歌0~f的文件夹嵌套，一层一层点下去，可以看到可以看到一些熟悉的第三方库，随便选一个点进去，是各个版本的文件夹，再随便找个文件夹进入，是一个json文件。 打开这个json文件，里面记录了这个版本的库的一些信息，包括这个库的远程仓库的地址： 所以我们就能大概明白了，每次我们 pod install 后，就会在这个 Specs 下查找对应的库的对应版本，然后找到相应的远程仓库，去远程仓库拉取代码。 Pod install 过程在 install 前，我们要编写一个 Podfile。整个依赖安装大概有四个部分： 解析 Podfile 中的依赖 下载依赖 创建 Pods.xcodeproj 工程 集成 workspace Podfile 是 ruby 的语法，在 install 过程中，执行 Podfile 文件，将会获取到要依赖的库以及库的版本号。然后在本地的 Specs 中进行比对，找到对应的远程仓库的地址。 大部分的依赖都会被下载到 ~/Library/Caches/CocoaPods/Pods/Release/ 这个文件夹中，然后从这个这里复制到项目工程目录下的 ./Pods 中。 如果 Specs 中如果没有找到 Podfile 中解析的库，就会报错。那么如果我们很久没有手动更新 Spec 了呢？不用担心，每次 Pod install 的时候，都会自动先去更新一下 Specs：pod repo update，当网络不好的时候就会很慢，所以才有了 pod install --no-repo-update，在 install 时，不更新 Specs 的命令。 pod install 完成后，会自动生成一个 Podfile.lock，用来锁定版本。我们不应该将其添加到 .gitignore 中去。只有在 pod update 后，才会自动更新 Podfile.lock。 CocoaPods 通过组件 CocoaPods-Downloader 已经成功将所有的依赖下载到了当前工程中，这里会将所有的依赖打包到 Pods.xcodeproj 中。主要做了几件事：生成 Pods.xcodeproj 工程；将依赖中的文件加入工程；将依赖中的 Library 加入工程；设置目标依赖（Target Dependencies） 这几件事情都离不开 CocoaPods 的另外一个组件 Xcodeproj，这是一个可以操作一个 Xcode 工程中的 Group 以及文件的组件，我们都知道对 Xcode 工程的修改大多数情况下都是对一个名叫 project.pbxproj 的文件进行修改，而 Xcodeproj 这个组件就是 CocoaPods 团队开发的用于操作这个文件的第三方库。 最后的这一部分与生成 Pods.xcodeproj 的过程有一些相似。首先会创建一个 workspace，之后会获取所有要集成的 Target 实例，然后将每一个 Target 加入到了工程，使用 Xcodeproj 修改 Copy Resource Script Phrase 等设置，保存 project.pbxproj，整个 Pod install 的过程就结束了。 CocoaPods 都做了什么? 深入理解 CocoaPods Podfile 中的一些关键词:path如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数：:path =&gt; &#39;~/Documents/AFNetworking&#39; 1234target ‘Mike’ dopod 'RNFS', :path =&gt; '../node_modules/react-native-fs'pod 'React', :path =&gt; '../node_modules/react-native'end cocoapods 会自动到 path 所在文件夹内查找 RNFS.podspec 以及 React.podspec 文件，然后根据这两个文件内提供的信息创建库（下面介绍如何创建库的时候会说到）。 platform这个参数是只依赖的库希望在哪个平台被编译。直接使用platform :ios, &#39;9.0&#39;。说希望采用iOS9.0的进行编译。 use_frameworks!这个指明编译成动态库，而不是静态库，特别是在使用Swift库的过程中，特别需要使用这句。不过他会把所有项目的编译动态库，这一点有点不好。不过在使用Swift库的过程中就没办法了。 source这个参数是指Cocoapods从哪些仓库(Spec)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。在用到自己私有库的情况下只需要在Podfile文件开头列出你需要引用库的所有仓库地址即可。 12source 'https://github.com/artsy/Specs.git' source 'https://192.168.0.90:8888/MySepcs/Specs.git' 最后一个官方 demo 123456789101112131415161718192021# open sourcesource 'https://github.com/CocoaPods/Specs.git'# my worksource 'https://github.com/Artsy/Specs.git'target 'App' do pod 'Artsy+UIColors' pod 'Artsy+UIButtons' pod 'FLKAutoLayout' pod 'ISO8601DateFormatter', '0.7' pod 'AFNetworking', '~&gt; 2.0' target 'AppTests' do pod 'FBSnapshotTestCase' pod 'Quick' pod 'Nimble' endend 创建一个公有库注册 CocoaPods 账号首先要注册一个 CocoaPods 账号，在终端使用 pod trunk 命令注册，之后会有一封确认邮件，激活账号： 1$pod trunk register 759740844@qq.com 'Zachary' --verbose 激活成功后，再到终端输入，可以看到注册信息： 1$pod trunk me 1234567ZacharydeMacBook-Pro:1.0.0 zachary$ pod trunk me - Name: Zachary - Email: 759740844@qq.com - Since: June 29th, 21:08 - Pods: None - Sessions: - June 29th, 21:08 - November 4th, 21:09. IP: 140.207.1.250 创建 .podspec这一部分之前的文章打包静态库里有较为详细的说明。为方便查看，复制了过来。 创建工程只需要输入 pod 的 lib 命令即可完成初始项目的搭建: 1pod lib create StaticWithCocoapods 输出指令后，会提示确认五个问题，按需求回答即可： 稍等片刻，就会自动生成一个工程。 配置信息在项目目录下有一个 xxx.podspec 配置文件，需要进行修改，摘录如下： 12345678910111213141516171819202122232425262728293031323334353637Pod::Spec.new do |s| s.name = 'StaticWithCocoapods' s.version = '0.1.0' s.summary = 'A short description of StaticWithCocoapods.'# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC s.homepage = 'https://github.com/zhang759740844' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'Zachary' =&gt; '759740844@qq.com' &#125; s.source = &#123; :git =&gt; '/Users/zachary/Desktop/StaticWithCocoapods', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'StaticWithCocoapods/Classes/**/*' s.resources = ['Images/*.png','Sounds/*'] s.resource_bundles = &#123; 'StaticWithCocoapods' =&gt; ['StaticWithCocoapods/Assets/*.png'] &#125; s.public_header_files = 'StaticWithCocoapods/Classes/**/*.h' s.frameworks = 'UIKit', 'MapKit' s.dependency 'AFNetworking', '~&gt; 2.3' s.dependency 'SVProgressHUD' s.subspec 'Aswift' do |a| a.source_files = 'A_swift/A_swift/**/*' endend s.version 表示的是当前类库的版本号 s.source 表示当前类库源 s.sources_files 表示类库的源文件存放目录 s.resources 表示将资源文件打包在 mainBundle 中 s.resource_bundles 表示将资源文件创建为某个 bundle s.frameworks 表示类库依赖的framework s.dependency 表示依赖的第三方类库，如果有多个要写多个 s.dependency s.subspec 表示依赖的子 podspec。 其中要说明的是： source 表示从哪里拉取代码。可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。如果 Podfile 中指定了 :path， 那么，就会在指定的路径查找，source 这里写啥都无所谓。 依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。 source_file 路径中出现的通配符 * 表示匹配任意字符， ** 表示匹配所有当前文件夹和子文件夹。 s.resources 中的资源文件如果是静态库就直接放在 mainBundle 中，如果是动态库就放在动态库所在 bundle 中。这样文件多了可能会重名，一般的做法是讲资源文件先自己打个 bundle，然后再通过 s.sources 引入。另外，Cocoapods 提供了 s.resource_bundles，可以将资源文件按需打成不同的 bundle。比如上面就是将 StaticWithCocoapods/Assets/*.png 目录下的所有图片打成 StaticWithCocoapods 的 bundle。 这里的 dependency 一般情况下是 cocoapods 的官方库中的。当然你也可以给自己创建的库添加自己的私有库，同样是直接写在 dependency 里。但是由于 dependency 表示编译器需要这样的一个依赖，没有指定从哪里获取，因此，添加私有库的时候要在使用这个库的工程的 Podfile 中添加你私有库的远端地址。这样的话，在下载 s.dependency 时，官方库找不到的情况下，就会到私有库的远端地址中查找。如果都找不到就会 pod install 失败。有一种情况不用添加私有库的远端地址，也可以 install 成功。那就是在 Podfile 中添加这个私有库，并为这个私有库设置本地路径 :path。由于 s.dependency 其实是创建了一个外部依赖，所以只要外部存在这个私有库，s.denpendency 就会自动链接过去。这一点非常非常重要。我们平时用 pod 实现组件化就是这么做的。比如你的主工程同时依赖于私有库 pod A，pod B，以及本地私有库 pod C。与此同时，pod A 和 pod B 也依赖于 pod C。这个时候是不是一定要将 pod C 放到远端，然后才能成功设置 pod A 和 pod B 呢？肯定不用。因为 pod C 已经通过本地路径引入: pod &#39;C&#39;, :path =&gt; &#39;../&#39;。所以 pod A 和 pod B 的 s.dependency 就不需要再到远端去查找 pod C 了。 什么时候用 s.subspec 呢？一般一个大的项目写成pod的时候，它可能会分为多个subspec，这样的话当你用一个庞大的库时，只需要其中的一小部分，那么就可以使用其中的某个subspec了。 我们拿AFNetworking.podspec来看: 123pod 'AFNetworking/Reachability'或者pod 'AFNetworking',:subspecs=&gt;['Reachability','Security'] 所以可以把subspec当做一个小型的pod来看。来看一下用 subspec 后，在 pod install 后得到如下文件结构。使用了 subspec 后，subspec 会单独变成一个文件夹： 添加文件向 sources_files 和 public_header_files 以及 resource_bundle 中添加图片和类文件。在 demo 的文件夹下执行 pod install。现在打开 demo 工程，可以看到创建的 StaticWithCocoapods 库的文件结构如下图： 现在工程里是带有 demo application 的，不过不用担心，在.podspec 中已经设置了源文件的目录，不会把 demo 中的各种测试文件也打包进去的。 不要在意上面图片上的图片路径 和 .podspec 中设置的 s.resource_bundles 路径不一致。这里的 Resources 看似是个文件夹，其实是一个 group，不是实际文件路径的地址。本例中实际的地址就是 [&#39;StaticWithCocoapods/Assets/*.png&#39;] 这个路径。 加载图片资源的问题到这里一切正常，也可以使用 SVProgressHUD ，但是当我想用 [UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@&quot;StaticWithCocoapods&quot; ofType:@&quot;bundle&quot;] stringByAppendingString:@&quot;/author.png&quot;]] 加载图片资源文件时，一直返回 nil 。最后在 Stackoverflow 的一个评论里总算找到了解决方法[Cocoapods]:Resource Bundle not accessbile 原先 demo 中 prdfile 的内容如下： 1234567891011use_frameworks!target 'StaticWithCocoapods_Example' do pod 'StaticWithCocoapods', :path =&gt; '../' target 'StaticWithCocoapods_Tests' do inherit! :search_paths pod 'FBSnapshotTestCase' endend 现在要删除 use_frameworks! 以及其相关内容，变成这样： 123target 'StaticWithCocoapods_Example' do pod 'StaticWithCocoapods', :path =&gt; ‘../‘end 再次尝试加载图片，可以得到正确结果. ^_^。但是为什么会这样？ use_frameworks! 的添加与否，表示将 pod 中的库打包成静态库.a 还是动态库.framework。其实就是图片在盗宝成静态库或者动态库的时候所处的 bundle 不同。 如果打包成了 .a，那么编译的时候库里的所有文件其实是被打包在主工程下的，即 mainBundle 中，即可像通常那样在 mainBundle 中获取 StaticWithCocoapods.bundle 中的图片。 如果打包成了 .framework ，动态库里的文件不再被打包在主工程下了，而是在动态库自己的 bundle 中，比如本例中的动态库 bundle 路径如下： 此时就不能再在 mainBundle 中，而需要在动态库中的 bundle 下找文件了。我们可以学习下 SVProgressHUD 的做法，通过 [NSBundle bundleForClass:[SVProgressHUD class]] 拿到 SVProgressHUD 文件所在的 bundle，也就是资源文件所在的 SVProgressHUD.Bundle 所在的 bundle，然后获取图片： 1234NSBundle *bundle = [NSBundle bundleForClass:[SVProgressHUD class]];NSURL *url = [bundle URLForResource:@"SVProgressHUD" withExtension:@"bundle"];NSBundle *imageBundle = [NSBundle bundleWithURL:url];UIImage* infoImage = [UIImage imageWithContentsOfFile:[imageBundle pathForResource:@"info" ofType:@"png"]]; 测试类库在 demo application 中，如果把自己的库使用 pod 引入，注意要修改 Podfile 中库的路径为本地 podspec 所在的路径，不然每次都要从远端拉了。另外还有一个问题是这样每次更新库里的内容，运行的时候都要先 pod install 一下，这样非常的麻烦。 因此，我们可以直接将库里的文件添加到 demo application 中，同时要修改 Podfile，使其不要 pod 自身，而是 pod 其依赖的其他类库。这样做就是把类库的文件放到主工程下，就不用每次都 pod install 更新修改了。比如： 123456789# 原来可能是这样的target 'StaticWithCocoapods_Example' do pod 'StaticWithCocoapods', :path =&gt; ‘../‘end# 现在要把依赖 StaticWithCocoapods 的类库加上，删除自己：target 'StaticWithCocoapods_Example' do pod 'SVProgressHUD'end 不用担心这样做不会产生任何问题。demo 中的文件依赖的改动并不影响 .podspec 中的设置，只要文件还是放在 .podspec 的指定路径下就行。发布类库的时候还是按照 .podspec 进行的，所以没有任何影响。 但是要注意一点，虽然你把文件放在主工程下编译，但是代码中获取资源文件的时候绝对不能偷懒使用 mainBundle 加载。因为别人可能将你发布的库打成动态库放到自身的工程中，这就会造成上面加载图片资源一样的问题。所以加载资源文件的时候一定要用上面说的通用的方法。 提交代码 使用 sourcetree 添加本地仓库 提交上面的所有改动 为改动添加 tag 为 0.1.0 设置好后如图： 这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。 验证类库开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 --allow-warnings 忽略警告： 打包库如果你要发布到 cocoapds，那么这个操作是不必要的。但是如果你想直接获得一个动态或者静态库，那么可以手动打包这个库。 打包库需要一个 cocoapods 的插件 cocoapods-packager来完成类库的打包。 在终端执行以下命令，安装插件： 1sudo gem install cocoapods-packager 在目标文件夹内执行以下命令，完成打包： 1pod package StaticWithCocoapods.podspec --force 打包成 .framework ，也可以用 --library 打包成 .a 。 现在在目标文件夹下就会多出一个 StaticWithCocoapods-0.2.0 目录，里面是打包好的 framework 。 虽然 s.dependency 只是创建了一个链接，但是 package 会下载 dependency 的代码，并将其打包进你的库中 发布.podspec最后一步：发布。在仓库目录下执行： 1pod trunk push xxxxx.podspec 上述命令将会更新本地的 repo 目录，然后将其提交到Cocoapods官方的仓库里去。 提交完成后，我们可以通过一下命令查询是否上传成功： 1pod search xxx 如果是多人开发，希望将其他人也加入到项目中去的话，可以通过以下方式： 1pod trunk add-owner '项目名' '邮箱' 更新删除等操作当版本更新后，需要做的就是改变 xxx.podspec 中的版本号，然后重复上一步的步骤发布即可。 至于删除废弃等操作可以详见pod trunk 的 help中： CocoaPods公有仓库的创建 Cocoapods系列教程(二)——开源主义接班人 创建一个私有库创建版本库（repo）之前说到，在~/.cocoapods/repos/ 目录下有一个 master 文件夹，对应着 cocoapods 官方的一个版本库，保存着各个第三方库的索引。我们要创建一个私有库，就得先创建一个私有的版本库来存放这些私有库的索引。 我们先在远端创建一个空的仓库test，然后再终端执行： 1$ pod repo add test https://git.oschina.net/baiyingqiu/test.git 这个仓库就被 clone 了下来，作为本地的版本目录了，可以进入~/.cocoapods/repos/ 文件夹查看： 创建.podspec和上面公有的无二致。将本地代码推送到远程，并打上 tag。 需要明确，cocoapods 是通过 tag 来区分版本信息的，而不是 branch。也就是说，不论你的 tag 是打在 master 还是 develop 亦或任意一个其他分支，cocoapods 都能够正确获取该 tag 所处的 commit 的文件。 所以你的私有库其实不用再开一个新的 repo 去存储，可以直接在当前工程下开发。新开一个私有库的分支，专门开发私有库也是没有问题的。 将描述文件推送到版本库将我们私有库的描述信息 push 到刚才的版本库中： 1$ pod repo push test xxx.podspec --verbose --allow-warnings 要加上 --allow-warnings 不然还是不能通过。 现在就可以通过 pod search xxx 来搜索了。 使用私有库使用私有库的时候要在使用的工程的 Podfile 中加上私有库的版本库的路径，若有还使用了公有的pod库，需要把公有库地址也带上。例子： 12345678source ‘https://github.com/CocoaPods/Specs.git’source ‘https://github.com/zhang759740844/test.git’platform :ios, '8.0'target ‘Mike’ do pod 'xxx'end 现在就可以 pod install 了。 CocoaPods私有仓库的创建 Cocoapods系列教程(三)——私有库管理和模块化管理 使用Cocoapods创建私有podspec推荐]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中的宏]]></title>
    <url>%2F2017%2F06%2F30%2FiOS%E4%B8%AD%E7%9A%84%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[学一下如何在 OC 中自定义宏。参考自官方文档 类对象宏类对象宏是一种会在预处理时被代码片段替代的简单标识。之所以被叫做类对象宏是因为在使用的时候类似于一个对象。最常见的使用方式是用其为一个常量定义一个别名。 基本使用最基本的使用方式： 123456// 定义#define BUFFER_SIZE 1024// 使用foo = (char *) malloc (BUFFER_SIZE); → foo = (char *) malloc (1024); 一般的，都要使用大写来命名宏。 换行宏定义在 #define 那一行结束。如果你要书写多行，需要使用 \ 换行。在宏展开的时候，会被自动展开为一行： 12345#define NUMBERS 1, \ 2, \ 3int x[] = &#123; NUMBERS &#125;; → int x[] = &#123; 1, 2, 3 &#125;; 顺序替换预处理器顺序的读取程序，因此只有在定义宏之后，宏才能生效： 1234567foo = X;#define X 4bar = X;//----result----foo = X;bar = 4; 宏是一个替换过程，在顺序替换的时候，X 还没有被定义，所以 foo = X，之后宏 X 被定义了，所以之后的读取宏的都会被替换为具体内容。 嵌套宏在拓展宏的时候，预处理器会检查宏的内容是否还是一个宏，会对其继续替换： 12345#define TABLESIZE BUFSIZE#define BUFSIZE 1024TABLESIZE → BUFSIZE → 1024 宏定义以最后生效的定义为准，因此下面的代码 TABLESIZE 对应37: 1234#define BUFSIZE 1020#define TABLESIZE BUFSIZE#undef BUFSIZE#define BUFSIZE 37 类函数宏宏还可以定义函数： 123#define lang_init() c_init()lang_init() → c_init() 注意，() 一定要跟在名称后面，否则会被认为是一个类对象宏： 123#define lang_init () c_init()lang_init() → () c_init()() 预处理器会认为 lang_init 是一个整体，() c_init() 是一个整体进行替换。 宏参数可以在类函数宏中传入参数： 123#define min(A, B) ((A) &lt; (B) ? (A) : (B))x = min(a, b); → x = ((a) &lt; (b) ? (a) : (b)); 如果宏的内容中有字符串，那么不会被宏参数替换： 12#define foo(x) x, "x"foo(bar) → bar, "x" 三个非常重要的注意事项宏的使用经常会产生错误，下面三点请一定注意，有助于消除大部分的 bug 为宏参数添加括号比如上面的 min 的例子，如果我们在宏的内容中不为 X 和 Y 添加括号，会出现什么样的情况？ 1#define MIN(A,B) (A &lt; B ? A : B) 一般情况下不会有任何问题，但是如果 A 或 B 是一个表达式，就会出错： 123456int a = MIN(3, 4 &lt; 5 ? 4 : 5);// =&gt; int a = (3 &lt; 4 &lt; 5 ? 4 : 5 ? 3 : 4 &lt; 5 ? 4 : 5); //希望你还记得运算符优先级// =&gt; int a = ((3 &lt; (4 &lt; 5 ? 4 : 5) ? 3 : 4) &lt; 5 ? 4 : 5); //为了您不太纠结，我给这个式子加上了括号// =&gt; int a = ((3 &lt; 4 ? 3 : 4) &lt; 5 ? 4 : 5)// =&gt; int a = (3 &lt; 5 ? 4 : 5)// =&gt; int a = 4 所以，一定要为宏参数添加括号，使其作为一个值被使用。 若宏的结果为值，则为整个宏添加括号还是上面 min 的例子，如果此时不在整个红的外面添加括号，会如何呢？ 1#define min(A, B) (A) &lt; (B) ? (A) : (B) 同样的，一般不会出现什么问题，但是如果对这个值做其他的操作： 1234int a = 2 * MIN(3, 4);// =&gt; int a = 2 * 3 &lt; 4 ? 3 : 4;// =&gt; int a = 6 &lt; 4 ? 3 : 4;// =&gt; int a = 4; 被替换后，由于优先级的问题，2*3 会被率先执行。所以还上面类似的，要为整个宏添加括号，使其作为一个值被使用。 若宏替换的是代码块，则要为这段代码添加 do{...}while(0)如果宏替换的是某个代码块，比如👇(不用考虑具体代码块表达什么意思)： 123//A wrong version of NSLog#define NSLog(format, ...) ...(语句1); \ ...(语句2); 一般使用任然不会出错，比如下面这种情况就能正确替换： 123...NSLog(@"Oops, error happened");... 但是考虑如果代码块是 if 中单条语句的简写形式： 12if (errorHappend) NSLog(@"Oops, error happened"); 展开后可以知道这样一定编译出错： 123if (errorHappend) ...(语句1); ...(语句2); 你可以在宏中为代码块加上 {}。但是如果判断中有 else 语句，那么即使为宏套上了 {}，也不能通过编译： 123456if (errorHappend) &#123; ...(语句1); ...(语句2);&#125;; else &#123; //Yep, no error, I am happy~ :)&#125; 因此，解决方式是在定义宏的时候为代码块套上 do{...}while(0)，使整个代码块形成一个整体，相当于一条语句，并且保证了代码块只会执行一次。这样就可以符合 if 的简写方式了： 12345678if (errorHappend) do &#123; ...(语句1); ...(语句2); &#125; while (0);else &#123; //Yep, no error, I am really happy~ :)&#125; 为代码块添加 do{...}while(0) 是通用写法 字符串化可以在宏参数前添加 #，将参数转换为字符串： 1234567#define WARN_IF(EXP) \do &#123; if (EXP) \ fprintf (stderr, "Warning: " #EXP "\n"); &#125; \while (0)WARN_IF (x == 0); → do &#123; if (x == 0) fprintf (stderr, "Warning: " "x == 0" "\n"); &#125; while (0); 字符串化会将参数中的所有字符(包括引号)都字符串化，如果中间有很多空格，字符串化后将只有一个空格。 那如果想通过 # 来实现参数值的字符串化，而不仅仅是将参数名字符串化呢？这就需要需要使用两层的宏： 123456789#define xstr(s) str(s)#define str(s) #s#define foo 4str (foo) → "foo"xstr (foo) → xstr (4) → str (4) → "4" 在使用 str 的时候，s 会立即被字符串化，而没有被宏展开。但是如果我们使用另外一个宏 xstr 嵌套着，那就会先展开，将值带入后，然后再字符串化。 连接可以使用 ## 连接两个 token： 123456789101112131415161718192021struct command&#123; char *name; void (*function) (void);&#125;;struct command commands[] =&#123; &#123; "quit", quit_command &#125;, &#123; "help", help_command &#125;, …&#125;;#define COMMAND(NAME) &#123; #NAME, NAME ## _command &#125;struct command commands[] =&#123; COMMAND (quit), COMMAND (help), …&#125;; 预处理器会将所有注释转为空格，## 会将左右的空格都忽略。 多参数宏如果不确定有多少个宏参数，可以使用 … 代替，这在很多语言中都有类似的做法。相应的，使用 __VA_ARGS__ 在具体的宏中，代替 ...： 1234#define eprintf(…) fprintf (stderr, __VA_ARGS__)eprintf ("%s:%d: ", input_file, lineno) → fprintf (stderr, "%s:%d: ", input_file, lineno) 上面的例子中，如果宏参数缺失，那么替换后不就成 fprintf (stderr,) 了么？需要稍微修改： 1#define eprintf(…) fprintf (stderr, ##__VA_ARGS__) 在加上 ## 之后，预处理器就会在传入空的时候，删掉前面的 , 了。 条件编译#if/#elif/#else如果 IOS10 值为真时，输出 It is an iOS10 device!； 若 IOS10 值为假且 IOS9 值为真时，输出It is an iOS9 device!；否则输出It is a device NOT runing iOS10 or iOS9! #if 和 #endif 配对出现，#endif 用于终止 #if 预处理指令 1234567#if IOS10 NSLog(@"It is an iOS10 device!");#elif IOS9 NSLog(@"It is an iOS9 device!");#else NSLog(@"It is a device NOT runing iOS10 or iOS9!");#endif #ifdef#ifdef 等价于 #if defined，如果后面跟的宏被定义过，则执行下面的代码。 123#ifdef RUN NSLog(@&quot;defined...&quot;);#endif #ifndef和上面相反，如果没有被定义过，则执行下面的代码： 123#ifndef RUN NSLog(@&quot;not defined...&quot;);#endif 内联函数在 iOS 的一些框架中，static incline 是经常出现的关键字组合。比如： 1234// 直接写在文件内，不要作为类方法static inline CGFloat CGFloatFromPixel(CGFloat value) &#123; return value / YYScreenScale();&#125; 内联函数的标志就是 incline。内联函数直接写在文件内，不要作为类方法，使用的时候导入文件，直接调用即可。 内联函数有什么用呢？内联函数类似于宏，会把代码直接嵌入调用代码中，因此没有普通函数调用产生的性能损耗。如果该函数会被经常调用，那么就可以提高性能。它与 #define 宏的区别在于： #define 定义的格式要有要求，而使用inline则就行平常写函数那样，只要加上inline即可！ 使用 #define 宏定义的代码，编译器不会对其进行参数有效性检查，仅仅只是对符号表进行替换 #define 宏定义的代码，其返回值不能被强制转换成可转换的适合的转换类型 在inline加上static修饰符，只是为了表明该函数只在该文件中可见！也就是说，在同一个工程中，就算在其他文件中也出现同名、同参数的函数也不会引起函数重复定义的错误！ 参考文章官方文档 iOS开发高级：使用宏定义macros 宏定义的黑魔法 - 宏菜鸟起飞手册]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode other link flags 分析]]></title>
    <url>%2F2017%2F06%2F19%2FiOS%E9%93%BE%E6%8E%A5%20%2F</url>
    <content type="text"><![CDATA[导入第三方库的时候，经常会看到要设置 “other link flags”。那么这到底是有什么用？ 基础编译连接从C代码到可执行文件经历的步骤是：1源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件 经过编译汇编之后输出的文件是.o文件，然后对这些.o文件进行链接，就是最终的可执行文件。静态链接库一般是一个.a 压缩文件，解压后可以得到众多的.o文件，静态库也会在链接过程中连接到你的可执行文件中去。 符号我们在源码中写的全局变量名、函数名、类名在生成的 .o 文件中都可以叫做符号，存在一个符号表中。 OC 链接特性 The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. Object-C的链接器并不会为每个方法建立符号表，而是为每个类建立链接符号。这样的话静态库中定义了已存在的类的分类，链接器就以为这个类存在了，不会将分类和核心类代码关联（合并）起来，这样在最后可执行文件中，就会找不到分类里所定义的方法。 三个参数-ObjC This flag causes the linker to load every object file in the library that defines an Objective-C class or category. While this option will typically result in a larger executable (due to additional object code loaded into the application), it will allow the successful creation of effective Objective-C static libraries that contain categories on existing classes. 加入这个参数后，链接器会将静态库中的每个类和分类按需加载到最后的可执行文件，当然，这个参数会导致可执行文件比较大，原因是加载了更多的额外对象的代码到可执行文件当中去，但是这会解决 Objec-C 中静态库中已存在的类包含的分类问题。 Important: For 64-bit and iPhone OS applications, there is a linker bug that prevents -ObjC from loading objects files from static libraries that contain only categories and no classes. The workaround is to use the -allload or -forceload flags. 这里还提到，链接器有一个bug，就是当静态库中只有 category 没有 class 的时候，必须使用 -all_load 或者 -force_load 代替。 -all_load:该参数把所找到的目标文件都加载到可执行文件当中去（-ObjC 是按需加载），但是这就存在一个问题了，如果两个静态库中，都使用了同一份可执行文件（这是一个很常见的问题，例如大家的目标文件都使用了用以名字 base64.o）就会发生 ld: duplicate symbol 符号冲突问题，所以不太建议使用。 -force_load：该参数的作用跟 -all_load其实是一样的，但是 -force_load 需要指定要进行全部加载的库文件的路径，这样的话，只要完全加载一个库文件，不影响其余库文件的按需加载。 原理在对静态库进行链接的时候，链接器会获取静态库的符号表。只有被使用了的类才能才会被链接到可执行文件中去。比如你有50个类文件，但是只有20个是使用到的，那么只有这20个会被链接，其它30个被忽略。 这种方式对于C或者C++是非常有效的，因为这些静态语言会在编译的时候就已经把该做的工作都做完了。但是 OC 是一门动态语言，很多 OC 的特性要在运行时决定。因此，链接器不能得知其是否是被使用到的。category 就是一个运行时特性，category 不是像 class 那样的符号，所以链接器不会直接把 category 链接到可执行文件中去。通过 -ObjC 可以告知链接器，在按需加载的前提下，将 category 也链接进可执行文件。 Xcode other link flags 详解 [Objective-C categories in static library] 中 Vladimir 和 Mecki 的回答]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 绘图]]></title>
    <url>%2F2017%2F06%2F10%2FiOS%E7%BB%98%E7%94%BB%2F</url>
    <content type="text"><![CDATA[有些时候需求上的动画效果不能仅通过贴图来解决，这就需要我们自定义各种图案，然后动态的绘制完成动态效果。比较复杂，但是实现出来的东西非常精致。 drawRect 获取当前图形上下文绘图绘制矩形123456789101112- (void)drawRect:(CGRect)rect&#123; UIColor *color = [UIColor colorWithRed:0 green:0 blue:0.7 alpha:1]; [color set]; //设置线条颜色 UIBezierPath* aPath = [UIBezierPath bezierPathWithRect:CGRectMake(20, 20, 100, 50)]; aPath.lineWidth = 8.0; aPath.lineCapStyle = kCGLineCapRound; //线条拐角 aPath.lineJoinStyle = kCGLineCapRound; //终点处理 [aPath stroke];&#125; 圆和椭圆替换上面的代码为： 1234// 圆UIBezierPath* aPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, 100, 100)];// 椭圆UIBezierPath* aPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, 100, 50)]; 都是需要一个外接矩形，椭圆和圆不同之处在于圆的外接矩形是个正方形。 多边形多边形是一些简单的形状,这些形状是由一些直线线条组成，我们可以用 moveToPoint: 和 addLineToPoint: 方法去构建。moveToPoint: 设置我们想要创建形状的起点。从这点开始，我们可以用方法 addLineToPoint: 去创建一个形状的线段。我们可以连续的创建 line，每一个 line 的起点都是先前的终点，终点就是指定的点。closePath 可以在最后一个点和第一个点之间画一条线段。 1234567891011121314151617181920212223242526- (void)drawRect:(CGRect)rect&#123; UIColor *color = [UIColor colorWithRed:0 green:0.7 blue:0 alpha:1]; [color set]; UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; aPath.lineJoinStyle = kCGLineCapRound; // 起点 [aPath moveToPoint:CGPointMake(100.0, 0.0)]; // 绘制线条 [aPath addLineToPoint:CGPointMake(200.0, 40.0)]; [aPath addLineToPoint:CGPointMake(160, 140)]; [aPath addLineToPoint:CGPointMake(40.0, 140)]; [aPath addLineToPoint:CGPointMake(0.0, 40.0)]; [aPath closePath];//第五条线通过调用closePath方法得到的 //根据坐标点连线 [aPath stroke]; // 将图形填充满 [aPath fill];&#125; closePath 可以将路径封闭 不规则形状要用弧线组成不规则的形状，我们需要用到中心点、弧度和半径。弧度以顺时针为准，0° 指向右边。 绘制一段弧度1234567891011121314151617- (void)drawRect:(CGRect)rect&#123; UIColor *color = [UIColor redColor]; [color set]; //设置线条颜色 UIBezierPath* aPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(80, 80) radius:75 startAngle:0 endAngle:DEGREES_TO_RADIANS(135) clockwise:YES]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; //线条拐角 aPath.lineJoinStyle = kCGLineCapRound; //终点处理 [aPath stroke];&#125; 贝塞尔曲线贝塞尔曲线需要一个起始点，终点和控制点 1234567891011121314151617- (void)drawRect:(CGRect)rect&#123; UIColor *color = [UIColor redColor]; [color set]; //设置线条颜色 UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; //线条拐角 aPath.lineJoinStyle = kCGLineCapRound; //终点处理 // 起始点 [aPath moveToPoint:CGPointMake(20, 100)]; // 终点 和 控制点 [aPath addQuadCurveToPoint:CGPointMake(120, 100) controlPoint:CGPointMake(70, 0)]; [aPath stroke];&#125; 贝塞尔曲线可以有多个控制点，可以实现类似波浪的效果： 1234567891011121314151617- (void)drawRect:(CGRect)rect&#123; UIColor *color = [UIColor redColor]; [color set]; //设置线条颜色 UIBezierPath* aPath = [UIBezierPath bezierPath]; aPath.lineWidth = 5.0; aPath.lineCapStyle = kCGLineCapRound; //线条拐角 aPath.lineJoinStyle = kCGLineCapRound; //终点处理 [aPath moveToPoint:CGPointMake(5, 80)]; [aPath addCurveToPoint:CGPointMake(155, 80) controlPoint1:CGPointMake(80, 0) controlPoint2:CGPointMake(110, 100)]; [aPath stroke];&#125; 根据手势绘图方法是根据手势移动生成相应的贝塞尔曲线，然后设置重绘。在 drawRect 中把这些曲线绘制出来： stroke 方法的解释上文中都是在 drawRect 方法中通过 UIBezierPath 绘制的。stroke 实质上帮我们省略了好几个步骤，包括： 获取当前上下文：CGContextRef ctx = UIGraphicsGetCurrentContext() 把贝塞尔曲线添加到上下文中：CGContextAddPath(ctx, aPath.CGPath) 绘制图形：CGContextStrokePath(ctx) 也就是说在 drawRect 中都是需要开启上下文的。只不过通过 stroke 方式就省略了。 drawRect 的问题drawRect 会生成一个图形上下文，这个空间为 图层宽*图层高*4 字节，会引起内存的暴增。所以，一般情况下，不要使用 drawRect 方法。 CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。用CGPath来定义想要绘制的图形，它的优点有: 1. 渲染快，有 GPU 硬件加速 2. 不会占用系统内存 3. 不会被图层边界裁减掉 4. 不会有像素化 推荐使用 CAShapeLayer，使用方式差不多，drawRect 是把 path add 到 context 上，CAShapeLayer 是把 path 赋给 layer.path 创建新的图形上下文绘图上面 drawRect 使用的是当前图形上下文UIGraphicsGetCurrentContext() 绘制的。事实上，可以在任何时候，创建新的图形上下文新建 UIImage 在图片上写字生成新的图片生成一个位图上下文，然后把图片和文字画上去，再获取位图： 裁剪图片（这个方法可以用来绘制圆角图片）先设置裁剪的范围为一个贝塞尔曲线，然后把图片画到贝塞尔曲线中： 生成一张带边框的圆角图片这在上面的基础上添加边框，也就是改变绘图的位置： 截图开启一个上下文，然后把视图通过 renderInContext: 绘制到上下文上。这种方式获取的是 UIImage 对象： 当然还有一种情况，直接通过系统 api 获取，该方法生成一个 UIView： 1234- (UIView *)snapshotView &#123; UIView *snapView = [self snapshotViewAfterScreenUpdates:YES]; return snapView;&#125; CAShapeLayer 的使用只要把贝塞尔曲线的 CGPath 赋值给 CAShapeLayer 的 path 就可以了，不需要调用任何重绘方法。它的基本属性有： path：绘制路径 fillColor：填充颜色 fillRule：填充规则，就是如果图形里面也有线条，那么是否中间也要填充 strokeColor：描边的颜色 strokeStart：描边的开始点，默认为0最大为1 strokeEnd：描边的结束点，默认为1 (配合核心动画可以实现那种慢慢变化的效果) lineWidth：线宽 lineCap：线的端点的样式 lineJoin：线交界处样式 使用 CAShapeLayer 设置圆角将 CAShapeLayer 作为图片的 layer 的mask：1234let roundedRectPath = UIBezierPath(roundedRect: avatorView.bounds, byRoundingCorners: .AllCorners, cornerRadii: CGSize(width: 10, height: 10))let shapeLayer = CAShapeLayer()shapeLayer.path = roundedRectPath.CGPathavatorView.layer.mask = shapeLayer 这种通过 mask 的方式不会消除离屏渲染，只是这种方式比 cornerRadius 性能好一些。 进度条不断的给 layer 赋不断边长的贝塞尔曲线 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; // 创建一个 layer CAShapeLayer *layer = [CAShapeLayer layer]; layer.bounds = CGRectMake(0, 0, 200, 45); layer.position = self.view.center; layer.path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, count / 6 * 2, 45)].CGPath; layer.fillColor = [UIColor redColor].CGColor; layer.fillRule = kCAFillRuleEvenOdd; self.redLayer = layer; // 添加 layer 到图层上 [self.view.layer addSublayer:self.redLayer]; // 添加一个定时器 self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(action)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];&#125;// 定时器方法- (void)action &#123; count ++; self.redLayer.path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, count / 6 * 2, 45)].CGPath; if (count &gt; 60 * 10 -1) &#123; [self.displayLink invalidate]; &#125;&#125; 图层的 bounds 的 x，y 不能瞎改，否则 path 会跟着 x，y 变化 View 消除阴影的离屏渲染准确的说，这不属于 CAShapeLayer。 如果直接对一个 View 加一个 shadow，那么会产生离屏渲染。我们可以指定 shaowPath，避免离屏渲染： 12345678let imageViewLayer = avatorView.layerimageViewLayer.shadowColor = UIColor.blackColor().CGColorimageViewLayer.shadowOpacity = 1.0 //此参数默认为0，即阴影不显示imageViewLayer.shadowRadius = 2.0 //给阴影加上圆角，对性能无明显影响imageViewLayer.shadowOffset = CGSize(width: 5, height: 5)//设定路径：与视图的边界相同let path = UIBezierPath(rect: cell.imageView.bounds)imageViewLayer.shadowPath = path.CGPath//路径默认为 nil]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS 使用方式]]></title>
    <url>%2F2017%2F05%2F31%2FHTML%2BCSS%2F</url>
    <content type="text"><![CDATA[从最简单的看起，这篇文章知识为了备忘 HTML基本的四个 HTML 标签HTML 标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的。 1&lt;h1&gt;This is a heading&lt;/h1&gt; HTML 段落是通过 &lt;p&gt;标签进行定义的。 1&lt;p&gt;This is a paragraph.&lt;/p&gt; HTML 链接是通过 &lt;a&gt; 标签进行定义的。在 href 属性中指定链接的地址。 1&lt;a href="http://www.w3school.com.cn"&gt;This is a link&lt;/a&gt; HTML 图像是通过 &lt;img&gt; 标签进行定义的。 1&lt;img src="w3school.jpg" width="104" height="142" /&gt; HTML 元素HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 &lt;p&gt;元素定义了 HTML 文档中的一个段落。 1&lt;p&gt;This is my first paragraph.&lt;/p&gt; &lt;body&gt; 元素定义了 HTML 文档的主体 123&lt;body&gt;&lt;p&gt;This is my first paragraph.&lt;/p&gt;&lt;/body&gt; &lt;html&gt; 元素定义了整个 HTML 文档。 1234567&lt;html&gt;&lt;body&gt;&lt;p&gt;This is my first paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。所有元素都必须被关闭，在开始标签中添加斜杠，比如&lt;br /&gt;，是关闭空元素的正确方法。 HTML 属性HTML 标签可以拥有属性，总是以名称/值对的形式出现，比如：name=”value”。属性总是在 HTML 元素的开始标签中规定，例如： 1&lt;table border="1"&gt; 属性值应该始终被包括在引号内。双引号是最常用的，在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如： 1name='Bill "HelloWorld" Gates' 常用属性： 1234class: 规定元素的类名id: 规定元素的唯一 idstyle: 规定元素的行内样式title: 规定元素的额外信息 HTML 标题标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt;等标签进行定义的。 123&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;h3&gt;This is a heading&lt;/h3&gt; &lt;hr /&gt;标签在 HTML 页面中创建水平线。hr 元素可用于分隔内容。 12345&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;This is a paragraph&lt;/p&gt; HTML 段落段落是通过 &lt;p&gt; 标签定义的。 12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; 对于 HTML，您无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。如果希望在不产生一个新段落的情况下进行换行（新行），请使用 &lt;br /&gt; 标签： 1&lt;p&gt;This is&lt;br /&gt;a para&lt;br /&gt;graph with line breaks&lt;/p&gt; HTML 样式style 属性用于改变 HTML 元素的样式。具体在 CSS 系列中能够学到 12345678&lt;html&gt;&lt;body&gt;&lt;h1 style="font-family:verdana"&gt;A heading&lt;/h1&gt;&lt;p style="font-family:arial;color:red;font-size:20px;"&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 文本格式化12345678910&lt;b&gt; 定义粗体文本。&lt;big&gt; 定义大号字。&lt;em&gt; 定义着重文字。&lt;i&gt; 定义斜体字。&lt;small&gt; 定义小号字。&lt;strong&gt; 定义加重语气。&lt;sub&gt; 定义下标字。&lt;sup&gt; 定义上标字。&lt;ins&gt; 定义插入字。&lt;del&gt; 定义删除字。 HTML 引用&lt;q&gt;元素定义短的引用。浏览器通常会为 &lt;q&gt; 元素包围引号。 1&lt;p&gt;WWF 的目标是：&lt;q&gt;构建人与自然和谐共存的世界。&lt;/q&gt;&lt;/p&gt; &lt;blockquote&gt; 元素定义被引用的节。浏览器通常会对 &lt;blockquote&gt;元素进行缩进处理。 123456&lt;p&gt;以下内容引用自 WWF 的网站：&lt;/p&gt;&lt;blockquote&gt;五十年来，WWF 一直致力于保护自然界的未来。世界领先的环保组织，WWF 工作于 100 个国家，并得到美国一百二十万会员及全球近五百万会员的支持。&lt;/blockquote&gt; HTML 计算机代码元素 &lt;code&gt; 元素定义编程代码,不保留多余的空格和折行,示例： 1234&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue" &#125;&lt;/code&gt; 如需保留空格折行，需要使用 &lt;pre&gt; : 123456789101112&lt;p&gt;Coding Example:&lt;/p&gt;&lt;code&gt;&lt;pre&gt;var person = &#123; firstName:"Bill", lastName:"Gates", age:50, eyeColor:"blue"&#125;&lt;/pre&gt;&lt;/code&gt; HTML 注释注释是这样写的，开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要。： 1&lt;! This is a comment &gt; HTML CSS当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="/html/csstest1.css"&gt;&lt;/head&gt; 这里的路径是相当于网站根路径的 当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 &lt;style&gt; 标签定义内部样式表。 123456&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&lt;/head&gt; 当特殊的样式需要应用到个别元素时，就可以使用内联样式: 123&lt;p style="color: red; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; HTML 链接开始标签和结束标签之间的文字被作为超级链接来显示。”链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 1&lt;a href="http://www.w3school.com.cn/"&gt;Visit W3School&lt;/a&gt; 使用 Target 属性，你可以定义被链接的文档在何处显示。 12// 这段代码会在新窗口显示&lt;a href="http://www.w3school.com.cn/" target="_blank"&gt;Visit W3School!&lt;/a&gt; name 属性规定锚（anchor）的名称。可以使用 name 属性创建 HTML 页面中的书签。当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 首先，我们在 HTML 文档中对锚进行命名（创建一个书签）： 1&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt; 然后，我们在同一个文档中创建指向该锚的链接： 1&lt;a href="#tips"&gt;有用的提示&lt;/a&gt; 您也可以在其他页面中创建指向该锚的链接： 1&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt; 在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。 HTML 图像图像由 &lt;img&gt; 标签定义。要在页面上显示图像，你需要使用源属性 1&lt;img src="http://www.w3school.com.cn/images/boat.gif" /&gt; alt 属性用来为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。 1&lt;img src="boat.gif" alt="Big Boat"&gt; HTML 表格表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义） 使用边框属性来显示一个带有边框的表格 表格的表头使用 &lt;th&gt; 标签进行定义。大多数浏览器会把表头显示为粗体居中的文本。 使用&lt;caption&gt; 属性描述表格标题，标题的显示位置：表格上方。 1234567891011121314&lt;table border="1"&gt;&lt;caption&gt;标题文本&lt;/caption&gt;&lt;tr&gt;&lt;th&gt;Heading&lt;/th&gt;&lt;th&gt;Another Heading&lt;/th&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; HTML 列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于 &lt;ul&gt; 标签。每个列表项始于 &lt;li&gt;。 1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。 1234&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; HTML &lt;div&gt; 和 &lt;span&gt;大多数 HTML 元素被定义为块级元素或内联元素。块级元素在浏览器显示时，通常会以新行来开始和结束，如： 1&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt; 内联元素在显示时通常不会以新行开始: 1&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt; HTML &lt;div&gt; 元素是块级元素，它是可用于组合其他 HTML 元素的容器。与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。&lt;div&gt; 元素的另一个常见的用途是文档布局。 HTML &lt;span&gt; 元素是内联元素，可用作文本的容器。当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。 HTML 类对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里的 .cities 表示任意名为 cities 的类，可以在前面加上前缀 div 表示只有 &lt;div&gt; 才能使用这个类. 还可以二级元素，如 &lt;table&gt; 中的 &lt;th&gt; 等： 123456789101112131415161718192021222324252627282930//html&lt;body&gt;&lt;table class="lamp"&gt;&lt;caption&gt;标题文本&lt;/caption&gt;&lt;tr&gt; &lt;th&gt; &lt;img src="/images/lamp.jpg" alt="Note" style="height:32px;width:32px"&gt; &lt;/th&gt; &lt;td&gt; The table element was not designed to be a layout tool. &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;//css&lt;style&gt;table.lamp &#123; width:100%; border:1px solid #d4d4d4;&#125;table.lamp th, td &#123; padding:10px;&#125;table.lamp td &#123; width:40px;&#125;&lt;/style&gt; HTML 布局&lt;div&gt; 元素常用作布局工具： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// html&lt;body&gt;&lt;div id="header"&gt;&lt;h1&gt;City Gallery&lt;/h1&gt;&lt;/div&gt;&lt;div id="nav"&gt;London&lt;br&gt;Paris&lt;br&gt;Tokyo&lt;br&gt;&lt;/div&gt;&lt;div id="section"&gt;&lt;h1&gt;London&lt;/h1&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom,with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;p&gt;Standing on the River Thames, London has been a major settlement for two millennia,its history going back to its founding by the Romans, who named it Londinium.&lt;/p&gt;&lt;/div&gt;&lt;div id="footer"&gt;Copyright W3School.com.cn&lt;/div&gt;&lt;/body&gt;//css&lt;style&gt;#header &#123; background-color:black; color:white; text-align:center; padding:5px;&#125;#nav &#123; line-height:30px; background-color:#eeeeee; height:300px; width:100px; float:left; padding:5px; &#125;#section &#123; width:350px; float:left; padding:10px; &#125;#footer &#123; background-color:black; color:white; clear:both; text-align:center; padding:5px; &#125;&lt;/style&gt; 使用了 id 表示元素，对应需要加上 # HTML 脚本&lt;script&gt; 标签用于定义客户端脚本，script 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。 HTML 头部元素&lt;head&gt; 元素是所有头部元素的容器。&lt;head&gt; 内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息。 &lt;title&gt; 标签定义文档的标题。能够定义浏览器工具栏中的标题;提供页面被添加到收藏夹时显示的标题;显示在搜索引擎结果中的页面标题. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title of the document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;The content of the document......&lt;/body&gt;&lt;/html&gt; &lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标（target）： 1234&lt;head&gt;&lt;base href="http://www.w3school.com.cn/images/" /&gt;&lt;base target="_blank" /&gt;&lt;/head&gt; &lt;link&gt; 标签定义文档与外部资源之间的关系。最常用于连接样式表： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; &lt;style&gt; 标签用于为 HTML 文档定义样式信息: 123456&lt;head&gt;&lt;style type="text/css"&gt;body &#123;background-color:yellow&#125;p &#123;color:blue&#125;&lt;/style&gt;&lt;/head&gt; &lt;meta&gt; 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。&lt;meta&gt; 标签始终位于 head 元素中。 &lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。 HTML 字符实体在 HTML 中，某些字符是预留的. 比如不能直接使用 &lt; 因为会被认为是标签，必须写成 &amp;lt;。再比如不能直接使用空格，需要空格则必须写成&amp;nbsp，具体可以查表。 HTML 统一资源定位器统一资源定位器（URL）用于定位万维网上的文档，遵守以下的语法规则： 12345678scheme://host.domain:port/path/filenamescheme - 定义因特网服务的类型。最常见的类型是 httphost - 定义域主机（http 的默认主机是 www）domain - 定义因特网域名，比如 w3school.com.cn:port - 定义主机上的端口号（http 的默认端口号是 80）path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。filename - 定义文档/资源的名称 HTML URL字符编码URL 只能使用 ASCII 字符集来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 HTML &lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。最常用的带有 HTML5 DOCTYPE 的 HTML 文档： 1&lt;!DOCTYPE html&gt; HTML 表单HTML 表单用于搜集不同类型的用户输入。&lt;form&gt; 元素定义 HTML 表单。表单元素指的是不同类型的 input 元素、复选框、单选按钮、提交按钮等等。 &lt;input&gt; 元素是最重要的表单元素。&lt;input&gt; 元素有很多形态，根据不同的 type 属性。 &lt;input type=&quot;text&quot;&gt; 定义用于文本输入的单行输入字段： 1234567&lt;form&gt;First name:&lt;br&gt;&lt;input type="text" name="firstname"&gt;&lt;br&gt;Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; 上面代码说明不要任何标签也是可以显示出字符的 &lt;input type=&quot;radio&quot;&gt; 定义单选按钮: 12345&lt;form&gt;&lt;input type="radio" name="sex" value="male" checked&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt; &lt;input type=&quot;submit”&gt;定义用于向表单处理程序提交表单的按钮: 123456789&lt;form action="action_page.php" target="_blank"&gt;First name:&lt;br&gt;&lt;input type="text" name="firstname" value="Mickey"&gt;&lt;br&gt;Last name:&lt;br&gt;&lt;input type="text" name="lastname" value="Mouse"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/form&gt; action 属性定义在提交表单时执行的动作。在上面的例子中，指定了某个服务器脚本来处理被提交表单： 1&lt;form action="action_page.php"&gt; target属性表示规定 action 属性中地址的目标（默认：_self）。本例中表示打开新的网页： 1&lt;form action="action_page.php" target="_blank"&gt; method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST），默认 GET： 1&lt;form action="action_page.php" method="GET"&gt; 如果要正确地被提交，每个输入字段必须设置一个 name 属性，相当于键。上面的例子只会提交 “Last name” 输入字段，其 http 请求是： 1baseUrl/action_page.php?lastname=Mouse 每个输入字段的value属性是被提交的值，上面的 value 是默认的填充。 HTML 表单元素&lt;select&gt; 元素定义下拉列表，&lt;option&gt; 元素定义待选择的选项。您能够通过添加 selected 属性来定义预定义选项。 12345&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="saab"&gt;Saab&lt;/option&gt;&lt;option value="fiat" selected&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;textarea&gt; 元素定义多行输入字段（文本域）: 123&lt;textarea name="message" rows="10" cols="30"&gt;The cat was playing in the garden.&lt;/textarea&gt; HTML Input 属性value 属性规定输入字段的初始值： 1234567&lt;form action=""&gt; First name:&lt;br&gt;&lt;input type="text" name="firstname" value="John"&gt;&lt;br&gt; Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; readonly 属性规定输入字段为只读: 1234567&lt;form action=""&gt; First name:&lt;br&gt;&lt;input type="text" name="firstname" value="John" readonly&gt;&lt;br&gt; Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; disabled 属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。 1234567&lt;form action=""&gt; First name:&lt;br&gt;&lt;input type="text" name="firstname" value="John" disabled&gt;&lt;br&gt; Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; size 属性规定输入字段的尺寸（以字符计）： 1234567&lt;form action=""&gt; First name:&lt;br&gt;&lt;input type="text" name="firstname" value="John" size="40"&gt;&lt;br&gt; Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; maxlength 属性规定输入字段允许的最大长度，该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码： 1234567&lt;form action=""&gt; First name:&lt;br&gt;&lt;input type="text" name="firstname" maxlength="10"&gt;&lt;br&gt; Last name:&lt;br&gt;&lt;input type="text" name="lastname"&gt;&lt;/form&gt; HTML label标签label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。 语法：&lt;label for=&quot;控件id名称&quot;&gt; 123456789&lt;form&gt; &lt;label for="male"&gt;男&lt;/label&gt; &lt;input type="radio" name="gender" id="male" /&gt; &lt;br /&gt; &lt;label for="female"&gt;女&lt;/label&gt; &lt;input type="radio" name="gender" id="female" /&gt; &lt;label for="email"&gt;输入你的邮箱地址&lt;/label&gt; &lt;input type="email" id="email" placeholder="Enter email"&gt;&lt;/form&gt; CSSCSS 基础语法CSS 的声明方式： 1selector &#123;property: value; property: value; property: value&#125; 如果是若干单词，需要给值加上引号，值之前最好加个冒号，一行最好只写一个属性： 1234h1 &#123; color: red; font-size: 14px; font-family: "sans serif";&#125; CSS 高级语法可以对选择器进行分组，被分组的选择器就可以分享相同的声明： 123h1,h2,h3,h4,h5,h6 &#123; color: green;&#125; CSS 派生选择器通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁： 1234li strong &#123; font-style: italic; font-weight: normal;&#125; 这样只有 li 中的 strong 才是如上的定义： 123456&lt;p&gt;&lt;strong&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;我是正常的字体。&lt;/li&gt;&lt;/ol&gt; id 选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 # 来定义: 12#red &#123;color:red;&#125;#green &#123;color:green;&#125; 12&lt;p id="red"&gt;这个段落是红色。&lt;/p&gt;&lt;p id="green"&gt;这个段落是绿色。&lt;/p&gt; id 属性只能在每个 HTML 文档中出现一次 在现代布局中，id 选择器常常用于建立派生选择器: 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 与页面中的其他 p 元素明显不同的是，sidebar 内的 p 元素得到了特殊的处理 CSS 类选择器类选择器以一个点号显示： 1.center &#123;text-align: center&#125; 1234567&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class="center"&gt;This paragraph will also be center-aligned.&lt;/p&gt; 和 id 一样，class 也可被用作派生选择器，此例中类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字： 1234.fancy td &#123; color: #f60; background: #666; &#125; 元素也可以基于它们的类而被选择，任何其他被标注为 fancy 的元素不会受这条规则的影响： 1234td.fancy &#123; color: #f60; background: #666; &#125; 1&lt;td class="fancy"&gt; CSS 子选择器子选择器，大于符号(&gt;)，用于选择指定标签元素的第一代子元素 1.food&gt;li&#123;border:1px solid red;&#125; 这个是类型下面的元素，派生选择器是元素下面的元素 CSS 包含(后代)选择器包含选择器，即加入空格,用于选择指定标签元素下的后辈元素： 1.first span&#123;color:red;&#125; &gt;作用于元素的第一代后代，空格作用于元素的所有后代。 CSS 通用选择器它使用一个（*）号指定，它的作用是匹配html中所有标签元素： 1* &#123;color:red;&#125; CSS 属性选择器为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。下面的例子为带有 title 属性的所有元素设置样式： 123[title] &#123; color:red;&#125; 下面的例子为 title=&quot;W3School&quot; 的所有元素设置样式： 123[title=W3School] &#123; border:5px solid blue;&#125; 属性选择器在为不带有 class 或 id 的表单设置样式时特别有用： 12345678910111213141516input[type="text"]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125;input[type="button"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125; CSS 继承CSS的某些样式是具有继承性的，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签： 1p&#123;color:red;&#125; 1&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 但注意有一些css样式是不具有继承性的。如 border:1px solid red; CSS 创建插入样式表的方法有三种： 外部样式表：当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 &lt;link&gt; 标签链接到样式表。&lt;link&gt; 标签在（文档的）头部： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;&lt;/head&gt; 内部样式表:当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 &lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 1234567&lt;head&gt;&lt;style type="text/css"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url("images/back40.gif");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式:由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性： 123&lt;p style="color: sienna; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt; CSS 注释和 html 的注释不同，css 的使用 /*…*/ 注释 12345/* 注释 */p&#123; font-size:12px; color:red;&#125; 一些常用的 CSS 属性1234567891011body&#123; font-size:12px; color:#666; font-weight:bold; font-style:italic; text-decoration:underline; text-indent:2em; line-height:1.5em; letter-spacing:50px; text-align:center;&#125; CSS 边框的一些属性12345div&#123; border-width:2px; border-style:solid; border-color:red;&#125; CSS 内边距padding 属性定义元素的内边距： 1h1 &#123;padding: 10px;&#125; 还可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值： 123456h1 &#123; padding-top: 10px; padding-right: 0.25em; padding-bottom: 2ex; padding-left: 20%; &#125; 百分数值是相对于其父元素的 width 计算的，这一点与外边距一样。所以，如果父元素的 width 改变，它们也会改变。 CSS 外边距设置外边距的最简单的方法就是使用 margin 属性。 1h1 &#123;margin : 0.25in;&#125; 一个规则中可以使用多个这种单边属性: 123456h2 &#123; margin-top: 20px; margin-right: 30px; margin-bottom: 30px; margin-left: 20px;&#125; CSS 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。 CSS 代码缩写不论是 padding 还是 margin 都可以简写，顺序为 上右下左： 1234p&#123; padding:13px 13px 13px 13px; margin:10px 40px 10px 40px;&#125; 关于字体也有很多属性可以进行缩写： 123456789101112body&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:"宋体",sans-serif;&#125;=&gt;body&#123; font:italic small-caps bold 12px/1.5em "宋体",sans-serif;&#125; 在缩写时 font-size 与 line-height 中间要加入“/”斜扛。不然浏览器无法知道哪个是 size 哪个是 height CSS 相对定位设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。 12345#box_relative &#123; position: relative; left: 30px; top: 20px;&#125; 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 CSS 绝对定位设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 12345#box_relative &#123; position: absolute; left: 30px; top: 20px;&#125; 小技巧：如果有一个元素要放在另一个元素中，比如图片上要防放置一行文字，那么可以将文字设置为绝对定位，放置在图片所在的块中，注意，参照定位的元素必须加入 position:relative;： 12345678910#box1&#123; width:200px; height:200px; position:relative; // 这个一定要有 &#125;#box2&#123; position:absolute; top:20px; left:30px;&#125; 123&lt;div id="box1"&gt; &lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;/div&gt; 绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 CSS 浮动浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 123456789101112.news &#123; background-color: gray; border: solid 1px black; &#125;.news img &#123; float: left; &#125;.news p &#123; clear:both; &#125; 1234&lt;div class="news"&gt;&lt;img src="news-pic.jpg" /&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 浮动框会影响后一个元素，使其与自身在同一行中。上面例子中，&lt;p&gt; 就会和两个浮动框在同一行中，如果不想让&lt;p&gt; 受到浮动的影响，另起一行，需要使用 clear 属性。 浮动的作用是实现文字环绕效果一般可以用其实现两栏 CSS 元素分类12345678常用的块状元素有：&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;常用的内联元素有：&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;常用的内联块状元素有：&lt;img&gt;、&lt;input&gt; 设置 display:block 就是将元素显示为块级元素。如下代码就是将内联元素 &lt;a&gt; 转换为块状元素，从而使 &lt;a&gt;元素具有块状元素特点。 1a &#123;display:block;&#125; 块级元素的特点：每个块级元素都从新的一行开始，并且其后的元素也另起一行。元素的高度、宽度、行高以及顶和底边距都可设置。元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 当然块状元素也可以通过代码 display:inline 将元素设置为内联元素。如下代码就是将块状元素 &lt;div&gt; 转换为内联元素，从而使 &lt;div&gt; 元素具有内联元素特点。 1div &#123;display:inline;&#125; 内联元素特点：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距不可设置；元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素就是同时具备内联元素、块状元素的特点，代码 display:inline-block 就是将元素设置为内联块状元素。&lt;img&gt;、&lt;input&gt; 标签就是这种内联块状标签。 内联块状元素特点：和其他元素都在一行上；元素的高度、宽度、行高以及顶和底边距都可设置。 CSS 技巧——水平居中如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。 12345&lt;style&gt; .txtCenter&#123; text-align:center; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class="txtCenter"&gt;我想要在父容器中水平居中显示。&lt;/div&gt;&lt;/body&gt; 当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。 满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。我们来看个例子就是设置 div 这个块状元素水平居中： 12345678&lt;style&gt;div&#123; border:1px solid red;/*为了显示居中效果明显为 div 设置了边框*/ width:200px;/*定宽*/ margin:20px auto;/* margin-left 与 margin-right 设置为 auto */&#125;&lt;/style&gt; 123&lt;body&gt; &lt;div&gt;我是定宽块状元素，哈哈，我要水平居中显示。&lt;/div&gt;&lt;/body&gt; 使不定宽块状元素水平居中，可以改变块级元素的 display:inline; 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： 1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; 123456789&lt;body&gt;&lt;div class="container"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; CSS 技巧——垂直居中父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。 1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 123&lt;div class="container"&gt; hi,imooc!&lt;/div&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中的自动引用计数]]></title>
    <url>%2F2017%2F05%2F13%2Farc%2F</url>
    <content type="text"><![CDATA[对这本书做一下《oc 高级编程》的读书笔记 内存管理/引用计数内存管理的思考方式对象操作与OC 方法的对应: 生成并持有对象：alloc/new/copy/mutableCopy 持有对象：retain 释放对象：release 废弃对象：dealloc NSObject 类负担内存管理的职责。 自己生成对象，自己持有使用以下名称开头的方法意味着自己生成的对象只有自己持有： alloc new copy mutableCopy 这里的意思是只要以这几个词开头，就不需要再调用 retain 方法就可以保留了对象了。在 ARC 中，系统不会自动补上 retain 方法 123// 自己生成并持有对象id obj = [[NSObject alloc] init];// 自己持有对象 这里就不会再调用 [obj retain] 了。obj 已经持有了对象。 非自己生成的对象，自己也能持有除了上面的方法取得的对象，因为非自己生成并持有，所以自己不是该对象的持有者。 12345// 取得非自己生成并持有的对象id obj = [NSMutableArray array];// 取得对象的存在，但自己不持有对象[obj retain];// 自己持有对象 通过 retain 方法，非自己生成的对象也可以成为自己持有。 不再需要自己持有的对象时释放release自己持有的对象，一旦不再需要，持有者可以通过 release 方法，释放该对象。 1234567// 取得非自己生成并持有的对象id obj = [NSMutableArray array];// 取得对象的存在，但自己不持有对象[obj retain];// 自己持有对象[obj release];// 释放对象，对象不可再被访问 autorelease自定义一个符合前文命名规范的生成对象的方法： 12345678910- (id)allocObject&#123; //自己生成并持有对象 id obj = [[NSObject alloc] init]; // 自己持有对象 return obj；&#125;// 取得非自己生成并持有的对象id obj1 = [obj0 allocObject];// 自己持有对象 由于外部是通过 allocObject 生成的，所以内部不用 [obj autorelease] 上面的例子把 allocObject 中不用 alloc 创建，这个时候就会添加 retain 了： 123456789101112- (id)allocObject&#123; //取得非自己生成并持有的对象 id obj = [NSArray array]; //取得对象的存在，但自己不持有对象 [obj retain]; // 自己持有对象 return obj；&#125;// 取得非自己生成并持有的对象id obj1 = [obj0 allocObject];// 自己持有对象 由于外部是符合命名规范的，因此，内部不添加 autorelease 方法。 其实可以这么理解，方法内如果是用 alloc 创建对象并返回的，那么不用 retain；如果不用 alloc 创建对象的，会自动插入 retain，所以不管怎样引用计数器必然加一。这个时候，由于方法是带有 alloc 等字眼的，编译器不会在方法中的最后添加 release 方法。因此，外部就不用再 retain 了，因为内部已经加过一了。 那么如果是类似 [NSMutableArray array] 方式，该如何取得对象呢？以自定义一个 object 方法为例： 123456789101112- (id)object&#123; id obj = [[NSObject alloc] init]; // 自己持有对象 [obj autorelease]; // 取得对象的存在，但自己不持有对象 return obj;&#125;id obj1 = [obj0 object];// 取得对象的存在，但自己不持有[obj1 retain]；// 自己持有对象 在 ARC 中，如果不符合上面的命名规范，那么系统会自动添加 autorelease 方法，并且外部就需要再 retain 一次了。 如此：符合命名规范，既不要内部 release，也不要外部 retain；不符合命名规范，既要内部 release 一次，也要外部 retain 一次。这样成对的操作，才保证了引用计数的正确性。 那不符合命名规范的时候先 release 在 retain 不是很浪费性能么？其实在这种情况下，oc 做了优化，不会把对象注册到 AutoreleasePool 中，实现方法是使用objc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue()，具体在下方。 上例中，使用 autorelease 方法，取得对象的存在，但是自己不持有对象。autorelease 提供这样的功能，使对象在超出指定的生存范围能够自动并正确的释放(调用 release 方法)。 无法释放非自己持有的对象释放非自己持有的对象时会发生崩溃 alloc/retain/release/dealloc 实现苹果将对象的引用计数保存在散列表中。这样的好处是： 对象用内存块的分配无须考虑内存块头部 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块。 实现规则： 调用 alloc 或者 reatain 后，引用计数值加1 调用 release 后，引用计数减1 引用计数值为0后，调用 dealloc 方法废弃对象 autoreleaseautorelease 使对象超出作用域后，对象实例的 release 实例方法被调用。其具体使用方法如下： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 实例方法 废弃 NSAutoreleasePool 对象 对于所有掉用过 autorelease 实例方法的对象，在废弃 NSAutoreleasePool 对象时，都将调用 release 实例方法。 NSRunLoop 会自动完成 NSAutoreleasePool 的生成、持有和废弃处理，不一定非要应用开发者手动使用 NSAutoreleasePool。不过如果存在大量 autorelease 的对象的话，还是建议自己生成和废弃 NSAutoreleasePool 的。 autorelease 实现autorelease 实例方法的本质是调用 NSAutoreleasePool 对象的 addObject 类方法。 其实就是将要释放的对象添加到 NSAutoreleasePool 中的数组中去。当 NSAutoreleasePool 将要销毁时，对数组中的所有对象调用 release 方法。 ARC 中的所有权修饰符ARC 有效时，对象类型上必须附加所有权修饰符： __strong __weak __unsafe_unretained __autoreleasing __strong 修饰符__strong 修饰符是默认的所有权修饰符，也就是说，下面的 id 变量，实际上被附加了所有权修饰符 12id obj = [[NSObject alloc] init];=&gt; id __strong obj = [[NSObject alloc] init]; 如果指定了变量的作用域： 12345678&#123; id __strong obj = [[NSObject alloc] init];&#125;// 相当于下面👇&#123; id obj = [[NSObject alloc] init]; [obj release];&#125; __strong 修饰符表示对对象的强引用，持有强引用的对象，在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。 __weak修饰符__strong 修饰符容易引起引用循环，使用 __weak 修饰符可以避免循环引用。 1id __weak obj = [[NSObject alloc] init]; 上面的代码存在一个问题，由于使用弱引用，新建 NSObject 对象在创建后会立刻释放(这也是平时使用 weak 时需要注意的)。需要修改成下面 12id __strong obj0 = [[NSObject alloc] init];id __weak obj1 = obj0; 举个例子： 1234567id __weak obj1 = nil;&#123; id __strong obj0 = [[NSObject alloc] init]; obj1 = obj0; NSLog(@"A: %@",obj1);&#125;NSLog(@"B: %@",obj1); 由于弱引用，在括号后范围外，obj0 被回收，obj1 为置为 nil __unsafe_unretained修饰符已经被废弃的修饰符，这个修饰符和 __weak 的差别在于，__weak 修饰符在对象被回收后会置为 nil，而该修饰符则仍指向原有内存地址，访问被废弃的对象将可能会产生崩溃。 __autoreleasing 修饰符 autorelease 其实就是将 release 方法延迟一段时间执行 ARC 中无法直接使用 autorelease。在 ARC 无效时会像下面来使用： 12345// ARC 无效NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; ACR 有效时，将源代码写成这样: 123@autoreleasepool&#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; 在 ARC 有效时，用 @autoreleaseing 块代替 NSAutoreleasePool类，用附有 __autoreleasing 修饰符的变量替代 autorelease 方法。 ARC 的实现__strong修饰符123456789&#123; id __strong obj = [[NSObject alloc] init];&#125;编译器模拟的代码 =&gt;&#123; id obj = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(obj, @selector(init)); objc_release(obj);&#125; 两次调用 objc_msgSend 方法，变量作用域结束时通过 objc_release 释放对象。虽然 ARC 有效时不能使用 release 方法，但是编译器会自动插入。 如果使用其他的创建方法： 123456789&#123; id __strong obj = [NSMutableArray array];&#125;编译器模拟的代码 =&gt;&#123; id obj = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(obj); objc_release(obj);&#125; 中间调用了 objc_retainAutoreleasedReturnValue() 方法。它持有的对象应为 返回注册在 autoreleasepool 中对象的方法，或是函数的返回值。这个方法是与 objc_autoreleaseReturnValue() 方法成对出现的，用于优化程序运行。来看 [NSMutableArray array] 方法: 123456789+ (id)array&#123; return [[NSMutableArray alloc] init];&#125;编译器模拟的代码 =&gt;+ (id)array&#123; id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 这样做就不需要再把 obj 对象注册到 NSAutoreleasePool 中了，而是直接强引用这个对象。如下图： __weak假设变量 obj 附加 __strong 修饰符且对象被赋值: 123456789&#123; id __weak obj1 = obj;&#125;编译器模拟代码 =&gt;&#123; id obj1; objc_initWeak(&amp;obj1,obj); objc_destroyWeak(&amp;obj1);&#125; 其中 objc_initWeak 函数，会将附有 __weak 修饰符的变量初始化为0后，调用 objc_storeWeak 函数。objc_destroyWeak 函数会将0作为参数调用 objc_storeWeak 函数。所以，上面等效于下面： 1234567编译器模拟代码 =&gt;&#123; id obj1; obj1 = 0; objc_storeWeak(&amp;obj1, obj); objc_storeWeak(&amp;obj1, 0);&#125; objc_storeWeak 函数把第二参数的赋值对象的地址作为键值，将第一参数的附有__weak 修饰符的变量的地址注册到 weak 表中。如果第二个参数为0，则把变量的地址从 weak 表中删除。 weak 表和引用计数器表相同，作为散列表被实现。如果使用 weak 表，将废弃对象的地址作为键值进行检索，就能高速地获取对应的附有 __weak 修饰符的变量的地址。 假设考虑到 obj1 是被加入到 autoreleasepool 中的。那么编译器模拟代码又是什么呢？ 12345678910111213&#123; id __weak obj1 = obj; NSLog(@"%@",obj1);&#125;编译器模拟代码 =&gt;&#123; id obj1; objc_initWeak(&amp;obj1,obj); id tmp = objc_loadWeakRetained(&amp;obj1); objc_autorelease(tmp); NSLog(@"%@",tmp); objc_destroyWeak(&amp;obj1);&#125; 与被赋值相比，增加了objc_loadWeakRetained 和 objc_autorelease 方法的调用： objc_loadWeakRetained 取出了附有 __weak 修饰符变量所引用的对象并 retain objc_autorelease 将对象注册到 autoreleasepool 中 也就是说在使用 weak 变量的代码块里，临时的产生了强引用 如果大量地使用附有 __weak 修饰符的变量，注册到 autoreleasepool 的对象会大量地增加，即会大量创建 tmp。所以，使用附有 __weak 修饰符的变量，最好先暂时给附有 __strong 修饰符的变量后再使用： 1234567&#123; id __weak obj1 = obj; id tmp = obj1; NSLog(@"1 %@",obj1); NSLog(@"2 %@",obj1); NSLog(@"3 %@",obj1);&#125; 如果没有 id tmp = obj1，obj1 就会被注册到 autoreleasepool 注册3次，但是如果有这句，就只会注册一次。 __autoreleasing__autoreleasing 修饰符的变量等同于 ARC 无效时调用对象的 autorelease 方法： 1234567891011@autoreleasepool&#123; id __autoreleasing obj = [[NSObject alloc] init];&#125;编译器模拟编码 =&gt;&#123; id pool = objc_autoreleasePoolPush(); id obj = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(obj,@selector(init)); objc_autorelease(obj); objc_autoreleasePoolPop(pool);&#125; 和苹果 autorelease 实现中的说明完全相同。 oc 对象指针与 c 指针的转换__bridge __bridge_transfer 和 __bridge_retained 的区别我们在将将 c 指针和 oc 对象指针之间做转换的时候会用到上述几个修饰符。它们都会将 c 指针转为 oc 对象指针。差别在于： __bridge：ARC 不会插入 retain 和 release ，即生命周期和 c 指针一致 __bridge_retained ： ARC 会插入一条 retain，不会插入 release __bridge_transfer：ARC 会插入一条 release，不会插入 retain 解决 NSInvocation getArgument 引发的 Double Release从 NSInvocation 中获取参数会这样取： 12id arg;[invocation getArgument:&amp;arg atIndex:i]; 一般情况下赋值操作会成对的插入 retain 和 release： 123456- (void)method &#123;id arg = [SomeClass getSomething];// [arg retain]...// [arg release] 退出作用域前release&#125; 但是 ARC 下由于 arg 不是赋值操作，因此没有加入 [arg retain]。但是在结尾的时候还是调用了 [arg release] 就会造成 crash： 123id arg;[invocation getArgument:&amp;arg atIndex:i];// [arg release]; 我们有两种方式解决这个问题，一种是通过 __unsafe_unretained 修饰符，告诉编译器不要插入 [arg release] 和 [arg retain] 12__unsafe_unretained id arg;[invocation getReturnValue:&amp;arg]; 还有一种方式就是通过上面提到的 __bridge，同样告诉编译器不要插入 [arg release] 和 [arg retain] 1234id returnValue;void *result;[invocation getReturnValue:&amp;result];returnValue = (__bridge id)result; 这种操作指针的还是通过 __bridge 比较好 解决 NSInvocation 创建对象后 getReturnValue 引发的内存泄漏前面说过，当方法名开头是 alloc / new / copy / mutableCopy 时，返回的对象是 retainCount = 1 的。因此，需要在作用于结束的时候添加 release ，释放引用计数。但是通过 __bridge 将 c 对象转为 oc 对象的时候会省略 release 。因此，要使用 __bridge_transfer，仍然插入 release： 12345678id returnValue;void *result;[invocation getReturnValue:&amp;result];if ([selectorName isEqualToString:@"alloc"] || [selectorName isEqualToString:@"new"]) &#123; returnValue = (__bridge_transfer id)result;&#125; else &#123; returnValue = (__bridge id)result;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Vim 实用技巧》读书笔记]]></title>
    <url>%2F2017%2F05%2F08%2FVim%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[学习 Vim 的一些快捷键与技巧。 编辑 . 命令可以重复上次修改。在普通模式中的各种操作算一次修改(不包括光标移动及跳转)，在编辑模式下的内容的编辑也算一次修改。(能用 . 的就不要直接用数字） caw 删除当前单词并进入插入模式。c3w 删除3个单词。c 就表示删除文本并进入编辑模式。(这个命令可以配合下面的向下查找/{char} 或 *，方便的通过 .批量替换单词) C 删除光标后的所有，并且进入插入模式。 dw 删除当前光标后的(包括光标)，daw 删除一整个单词。(w,b 本身分别表示移动到下一个单词和上一个单词)。D 删除当前光标之后(包括当前光标)的所有单词。dd 删除整行。 y 复制，与 d 基本相同 d+i] 表示删除当前光标所在位置的[] 匹配项内的内容，如果是a]那么会连括号一起删除。类似的还有 c,y 表示删除并插入以及复制。i]也可以是i),i} 等相应命令。(上面的 daw 其中 aw 就和这里类似，相应的还有 diw)。(很有用很酷的一个命令) p 粘贴。分为两种情况： 如果复制的整行则 p 表示在当前行下粘贴，P 在当前行上粘贴。 如果复制的几个单词则 p 表示在当前光标后粘贴，P 表示在当前光标前粘贴。 o 在当前行下插入一行并编辑，O 在当前行上插入一行并编辑 x 删除光标下字母，i 在光标后插入，a 在光标前插入，A 在行尾插入，I 在行首插入。 ​ 搜索 /{char} 命令向下查找匹配项。类似的还有 * 用来匹配当前光标所在单词。n 下一处，N 上一处。查找的文字可以调成高亮的，如果没有可以通过 :set hls(hightlight search 的意思) 设置,取消用 :set nohls 即可。 如果要取消搜索键入 :noh（nohighlight）即可。 Vim 默认是大小写敏感的，可以通过 :set ic(ignore case 的意思) 取消大小写敏感，也可以再使用 :set smartcase 当有一个字母是大写的时候启动大小写敏感 在选中情况下键入 :&#39;&lt;,&#39;&gt;s/foo/bar/g 表示将 foo 替换为 bar。选种情况下键入:的时候vim会默认填充&#39;&lt;,&gt;&#39;，所以只要输入s/foo/bar/g 即可。 /g 表示全部替换，s 表示 selected 跳转 zz 将当前行显示在窗口正中。比如你代码写着写着写到了屏幕的最底下，这时候不需要滑动鼠标滚轮，使用该快捷键就可以将当前行移动到窗口正中，继续进行编辑。 gg 跳转到页面最上面 (加 import 文件的时候挺好用的)。G跳转到页面最下面(加方法的时候用)。 w,b 跳到后一个/前一个单词(连续的符号也算一个单词)。W,B 忽略符号，以空格为分界。 e(end) 快速将光标跳转到单词的末尾。和 w,b 搭配使用。(也挺好用的，w 和 b 能以单词向后向前跳转，但是光标都是在单词的前面。用 e 可以到单词末尾，可以用 a 在单词后面输入)。E 类似于 W,B 以空格为分界，跳到单词的尾部。 mx 标记x (mark x)，`x调到标记x。这个也挺好用的，比如你要在文件头添加个引用，那么先标记一下当前行。 % 可以在一组开、毕括号间跳转。如果当前光标处不是个括号，那么就跳转到当前光标后最近的一个括号处。这个方法写 oc 的时候很有用啊。 CTRL+E 屏幕向下滚动一行，CTRL+Y 屏幕向上滚动一行。CTRL+D 和 CTRL+U 原本是滚动半屏，我们可以在 .vimrc 中 map 为5行： 123".vimrcmap &lt;C-U&gt; 5&lt;C-Y&gt;map &lt;C-D&gt; 5&lt;C-E&gt; 选择主要用来复制和删除 v 进入选择模式。可以配合上面说到的所有：w,b,i],3w V 选择整行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UINavigationController使用方法]]></title>
    <url>%2F2017%2F05%2F04%2FUINavigationController%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[navigation 简单了解下使用 常用方法添加导航栏123TestViewController * mainVC = [[TestViewController alloc] init];UINavigationController * nav = [[UINavigationController alloc] initWithRootViewController:mainVC];self.window.rootViewController = nav; push首先是最常用的方法： 1- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated; 使用 setViewControllers 一次性依次压入多个控制器，最后显示最后的控制器： 1234567891011UINavigationController *nav = [[UINavigationController alloc] init];window.rootViewController = nav;// 创建3个测试控制器UIViewController *vc1 = [[UIViewController alloc] init];vc1.view.backgroundColor = [UIColor blueColor];UIViewController *vc2 = [[UIViewController alloc] init];vc2.view.backgroundColor = [UIColor redColor];UIViewController *vc3 = [[UIViewController alloc] init];vc3.view.backgroundColor = [UIColor greenColor];// 最终会显示vc3[nav setViewControllers:@[vc1,vc2,vc3] animated:YES]; pop常用方法： 1- (UIViewController *)popViewControllerAnimated:(BOOL)animated; 一层层返回不方便，可以直接返回到某一个控制器： 12345// 返回到某一个控制器- (NSArray *)popToViewController:VC_A animated:(BOOL)animated;// 返回到根控制器-(NSArray *)popToRootViewControllerAnimated:(BOOL)animated; 那么如何获取要 pop 到的控制器呢？ 12345678/// 当前管理的所有的控制器@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;/// 栈顶控制器@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController;/// 当前可见的VC，可能是topViewController，也可能是当前topViewController present(modal)出来的VC，总而言之就是可见的VC@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController; 注意，topViewController与visibleViewController大部分情况一样，也有可能不同 导航条基本属性NaviagationItem 来决定大部分的显示与控制。首先看看有哪些属性： 12345678// 中间的标题文字@property(nullable, nonatomic,copy) NSString *title;// 中间标题视图@property(nullable, nonatomic,strong) UIView *titleView;// 自定义左上角的返回按钮@property(nullable, nonatomic,strong) UIBarButtonItem *leftBarButtonItem; 设置默认返回按钮设置返回箭头导航栏默认有一个返回的按钮，我们可以自定义它的箭头： 1234567// 设置颜色时，imageWithRenderingMode 设置 UIImage 渲染为原来的颜色[[UINavigationBar appearance] setBackIndicatorImage:[[UIImage imageNamed:@"back"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]];// 使用 tintColor 设置颜色[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"back"]];[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"back"]];[[UINavigationBar appearance] setTintColor:[UIColor lightGrayColor]]; 通用的隐藏返回文字返回按钮旁的标题默认是上一级页面的 title，可以如下设置隐藏 title: 1[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(-100, 0) forBarMetrics:UIBarMetricsDefault]; 特殊页面设置返回按钮把自定义的 barbutton 设置到 backBarButtonItem 即可 12let backbtn = UIBarButtonItem(title: "取消", style: UIBarButtonItemStyle.Plain, target:self, action: nil)self.navigationItem.backBarButtonItem = backbtn 注意，这段代码要写在上一个控制器中。因为 back 要返回的是上一个控制器。 自定义左侧按钮按钮使用的是 UIBarButtonItem 这个类，通过 initWithCustomView: 方法初始化。 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // 自定义导航栏左侧按钮 UIButton * leftBtn = [UIButton buttonWithType:UIButtonTypeRoundedRect]; leftBtn.frame = CGRectMake(0, 7, 83, 30); leftBtn.backgroundColor = [UIColor orangeColor]; [leftBtn addTarget:self action:@selector(onTap) forControlEvents:UIControlEventTouchUpInside]; UIBarButtonItem * leftItem = [[UIBarButtonItem alloc] initWithCustomView:leftBtn]; self.navigationItem.leftBarButtonItem = leftItem;&#125;// 点击事件处理- (void)onTap &#123; NSLog(@"点击了导航栏左侧按钮");&#125; 自定义右侧按钮和左侧按钮方法类似。 注意，设置了 leftBarButtonItem 就替代了原来的的返回按钮。可以通过设置 self.navigationItem.leftItemsSupplementBackButton = YES; 保留返回按钮和 leftItems 自定义中间视图自定义中间视图比较简单，直接设置 navigationItem 的 titleView。 给系统的 leftBarButtonItem 添加 Badge上面提到了如何自定义左侧按钮，我们可以在自定义的 Button 上添加 Badge 实现效果。如果是系统的呢？由于 leftBarButtonItem 是 UIBarButtonItem 的实例，而 UIBarButtonItem 并非继承于 UIView，可以推测出，UIBarButtonItem 上显示的 image 和 label 是隐藏的属性。 我们需要使用 runtime 查找 UIBarButtonItem 中视图的属性名，并且通过 KVC，拿到这个视图属性： 1234567891011121314// UIBarButtonItem+Badge.m#pragma mark - 获取Badge的父视图- (UIView *)bottomView&#123; // 通过Xcode视图调试工具找到UIBarButtonItem的Badge所在父视图为:UIImageView UIView *navigationButton = [self valueForKey:@"_view"]; for (UIView *subView in navigationButton.subviews) &#123; if ([subView isKindOfClass:NSClassFromString(@"UIImageView")]) &#123; subView.layer.masksToBounds = NO; return subView; &#125; &#125; return navigationButton;&#125; 经过比对，发现视图属性名为 _view，拿到这个属性后，对其内部视图进行遍历，找到 UIImageView 的对象，我们就可以在 UIImageView 上添加 Badge 了。 同样的，我们还可以通过这种方法，自定义 UITabBarItem 的 Badge 1234567891011#pragma mark - 获取Badge的父视图- (UIView *)bottomView&#123; // 通过Xcode视图调试工具找到UITabBarItem原生Badge所在父视图为:UITabBarSwappableImageView UIView *tabBarButton = [self valueForKey:@"_view"]; for (UIView *subView in tabBarButton.subviews) &#123; if ([subView isKindOfClass:NSClassFromString(@"UITabBarSwappableImageView")]) &#123; return subView; &#125; &#125; return tabBarButton;&#125; Demo 参考自:iOS: 教你给 UI 控件添加 Badge(消息提醒小圆点) 自定义右上角按钮或多个按钮123@property(nullable, nonatomic,strong) UIBarButtonItem *rightBarButtonItem;/// 一次设置多个按钮@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *rightBarButtonItems; 设置 navigationItem 字体格式可以通过 [UINavigationBar appearance] 方法 设置： 1[[UINavigationBar appearance]setTitleTextAttributes:@&#123;NSForegroundColorAttributeName:[UIColor whiteColor],NSFontAttributeName:[UIFont systemFontOfSize:18]&#125;]; 这个设置和是否隐藏导航栏一样，都是全局的，无法孤立地设置某一个 ViewController。如果有一个地方需要特殊设置，那么需要在其它地方再设置回去。 操作 navigationItem上面我们看到操作 navigationBar 都是通过 self.navigationController.navigationBar，操作 navigationItem 都是通过 self.navigationItem。 事实上，UINavigationController 并没有navigationItem这样一个直接的属性，由于 UINavigationController 继承于 UIViewController ,而 UIViewController 是有navigationItem这个属性的是，所以对 navigationController 使用点语法获取 navigationItem 是编译得过的，但是这样操作是没有效果的。 NavigationItem 是一个 NSObject 对象，里面保存了导航栏上的各个 view； NavigationBar 是一个 UIView 对象，NavigationItem 中的各个 view 都被添加到其上 UINavigationController 返回手势失效系统为 UINavigationController 提供了一个 interactivePopGestureRecognizer 用于右滑返回(pop),但是，如果自定了 left button 或者隐藏了 navigationBar ，该手势就失效了。我们需要自己实现一下 delegate 方法; 不过一般我们最好还是使用默认的 backbutton 返回为好。一般自定义了 left button，并且隐藏了 backbutton 的情况，都应该是不让用户能够直接返回的情况。 新建一个 BaseNavigationController 实现 delegate： 1234- (void)viewDidLoad &#123; [super viewDidLoad]; self.interactivePopGestureRecognizer.delegate = self;&#125; 需要实现的代理方法： 1234567891011- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; if (gestureRecognizer == self.interactivePopGestureRecognizer) &#123; //屏蔽调用rootViewController的滑动返回手势，避免右滑返回手势引起死机问题 if (self.viewControllers.count &lt; 2 || self.visibleViewController == [self.viewControllers objectAtIndex:0]) &#123; return NO; &#125; &#125; //这里就是非右滑手势调用的方法啦，统一允许激活 return YES;&#125; 考虑到在 push 动画发生的时候，要禁止滑动手势，所以继续在 BaseNavigationController 中实现代理方法，禁止滑动手势： 1234- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; [super pushViewController:viewController animated:animated]; self.interactivePopGestureRecognizer.enabled = NO;&#125; 然后在新 push 出来的 ViewController 中设置启用滑动手势： 1234- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; self.navigationController.interactivePopGestureRecognizer.enabled = YES;&#125; 这种是开启了全局的右滑返回，对于特定页面的禁用右滑手势可以通过： 1234567- (void)viewDidAppear:(BOOL)animated &#123; self.navigationController.interactivePopGestureRecognizer.enabled = NO;&#125;- (void)viewWillDisappear:(BOOL)animated &#123; self.navigationController.interactivePopGestureRecognizer.enabled = YES;&#125; 导航栏隐藏导航栏123- (void)viewWillAppear:(BOOL)animated&#123; [self.navigationController setNavigationBarHidden:YES animated:animated];&#125; 这个方法设置之后，后面的页面的导航栏也都隐藏了。所以要注意一个原则，在当前页面 viewWillAppear 方法中做的修改，也要在当前页面的 viewWillDisappear 中还原回来。 修改导航栏背景色错误示范12345- (void)viewDidLoad &#123; [super viewDidLoad]; // 无效果 self.navigationController.navigationBar.backgroundColor = [UIColor redColor];&#125; 这个方法无法达到理想效果，上面会盖上白色的一层 UIImageView，必须直接设置这个 UIImageView 才能达到理想的效果。 正确示范1[self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@"xxx"] forBarMetrics:UIBarMetricsDefault]; 就像上面说的，必须要直接设置 UIImageView，可以自己写个纯色的 UIImage 也可以直接放一张图片。 设置导航栏透明度设置导航栏透明度需要自己创建一个带有透明度的 UIImage: 1234567891011121314// 背景色UIImage *image = [self imageWithColor:[color colorWithAlphaComponent:alpha]];[self.navigationController.navigationBar setBackgroundImage:image forBarMetrics:UIBarMetricsDefault];- (UIImage *)imageWithColor:(UIColor *)color &#123; CGRect rect = CGRectMake(0, 0, 1, 1); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 这里只创建了一个像素的图片，但是还是能达到平铺整个导航栏的效果。 创建的 UIImage 的大小只有一个像素的好处是节约 CPU 资源。 隐藏导航栏底部的分割线就是设置一个透明的图片，和设置导航栏背景色一个道理。 123UINavigationBar *navigationBar = self.navigationController.navigationBar;//此处使底部线条失效[navigationBar setShadowImage:[UIImage new]]; 导航栏的几个属性这些属性一般用处不大，但是有点印象就行了。以下为默认值 1234self.navigationController.navigationBar.translucent = YES;self.edgesForExtendedLayout = UIRectEdgeAll;self.automaticallyAdjustsScrollViewInsets = YES;self.extendedLayoutIncludesOpaqueBars = NO; 导航半透明的时候 设置 edgesForExtendedLayout 为 UIRectEdgeAll ，视图会延伸到导航栏下。默认为 YES 此时默认 automaticallyAdjustScrollViewInsets 为 YES。ScrollView 会自动设置 contentInset 设置edgesForExtendedLayout 为 UIRectEdgeNone ，视图不会延伸。 导航栏不透明的时候 设置 edgesForExtendedLayout 无效。 设置 extendedLayoutIncludesOpaqueBars 为 YES，可以延伸到不透明的导航栏下 设置extendedLayoutIncludesOpaqueBars 为 NO，不会延伸到透明的导航栏系下，默认为 NO 更改顶部状态栏颜色 在工程的Info.plist文件中添加一行UIViewControllerBasedStatusBarAppearance，选择Boolean类型，并设置为YES，Xcode会自动把名称变为View controller-based status bar appearance。 在你的ViewController中添加下面的方法 1234-(UIStatusBarStyle)preferredStatusBarStyle&#123; // return UIStatusBarStyleDefault; 黑色 return UIStatusBarStyleLightContent; // 白色&#125; 调用 UIViewController 的 setNeedsStatusBarAppearanceUpdate 方法，通知状态栏颜色改变了。 全屏滑动返回实现全屏滑动返回仅需在导航栏给导航栏添加UIGestureRecognizerDelegate协议，并在ViewDidLoad中设置。关键在于调用系统返回处理方法 hyandleNavigationTransition 1234567891011121314// 获取系统自带滑动手势的target对象id target = self.interactivePopGestureRecognizer.delegate;// 创建全屏滑动手势，调用系统自带滑动手势的target的action方法UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];// 设置手势代理，拦截手势触发pan.delegate = self;// 给导航控制器的view添加全屏滑动手势[self.view addGestureRecognizer:pan];// 禁止使用系统自带的滑动手势self.interactivePopGestureRecognizer.enabled = NO; 导航栏过渡导航栏过渡是一个需要好好设计的功能。如果做得不好，push 和 pop 时候会非常僵硬。 比较好的方式是通过 Method Swizzling 获取系统方法 _updateInteractiveTransition 拿到当前的进度。 具体可参考如下两篇文章： iOS: 记一次导航栏平滑过渡的实现 超简单！！！ iOS设置状态栏、导航栏按钮、标题、颜色、透明度，偏移等 如果要求不高，对于特殊的页面，直接在 viewWillAppear 和 viewWillDisapper 中通过 [self.navigationController setNavigationBarHidden:YES animated:YES] 显示和隐藏即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITextField 简介]]></title>
    <url>%2F2017%2F04%2F23%2FUITextField%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[UITextFied 是经常用到的一个控件。还是有一些点需要注意的。 基本属性挑选一些可能会忘记需要查阅的常用的基本属性，可能不完全，比如背景色啊，占位符啊，设置和读取文字啊都没列入。 设置边框样式1234567textField.borderStyle = UITextBorderStyleRoundedRect;//圆角//可选属性：UITextBorderStyleNone,无边框UITextBorderStyleLine,有边框UITextBorderStyleBezel,有边框和阴影UITextBorderStyleRoundedRect圆角 设置字体1[textField setFont:[UIFont fontWithName:@"Arial" size:30]]; 密文输入1textField.secureTextEntry = YES; 键盘类型12345678910textField.keyboardType = UIKeyboardTypeNumberPad; 数字键//全部类型 UIKeyboardTypeDefault,当前键盘（默认）UIKeyboardTypeASCIICapable,字母输入键UIKeyboardTypeNumbersAndPunctuation,数字和符号UIKeyboardTypeURL,URL键盘UIKeyboardTypeNumberPad,数字键盘UIKeyboardTypePhonePad,电话号码输入键盘 UIKeyboardTypeEmailAddress,邮件地址输入键盘 键盘风格12345textView.keyboardAppearance=UIKeyboardAppearanceDefault；//可选属性UIKeyboardAppearanceDefault， 默认外观，浅灰色UIKeyboardAppearanceAlert， 深灰 石墨色 设置左右视图textField 可以 leftView 和 rightView，文本输入区域在两者之间。设置清除按钮样式 12textField.clearButtonMode = UITextFieldViewModeAlways;//Mode同左右视图的mode一样。 再次编辑时是否清除之前内容12// 默认是NOtextField.clearsOnBeginEditing = YES 对齐方式垂直对齐： 1234567textField.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter //可选属性：UIControlContentVerticalAlignmentCenter 居中对齐UIControlContentVerticalAlignmentTop 顶部对齐，默认是顶部对齐UIControlContentVerticalAlignmentBottom 底部对齐UIControlContentVerticalAlignmentFill 完全填充 水平对齐： 123456textField.textAlignment = UITextAlignmentCenter;//可选属性：UITextAlignmentLeft，左对齐，默认是左对齐UITextAlignmentCenter，UITextAlignmentRight，右对齐 设置滚动1textField.adjustsFontSizeToFitWidth = YES; 默认是 NO。当是 YES当充满边框时，文字会缩小，当小到一定程度时仍然会滚动。 1textField.minimumFontSize = 20; 设置滚动时候的最小字号。 设置return键1234567891011121314textField.returnKeyType = UIReturnKeyGoogle;search//可选属性UIReturnKeyDefault, 默认 灰色按钮，标有ReturnUIReturnKeyGo,标有Go的蓝色按钮UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索UIReturnKeyJoin,标有Join的蓝色按钮UIReturnKeyNext,标有Next的蓝色按钮UIReturnKeyRoute,标有Route的蓝色按钮UIReturnKeySearch,标有Search的蓝色按钮UIReturnKeySend,标有Send的蓝色按钮UIReturnKeyYahoo,标有Yahoo的蓝色按钮UIReturnKeyYahoo,标有Yahoo的蓝色按钮UIReturnKeyEmergencyCall, 紧急呼叫按钮 文本编辑框代理首先要注意，必须先设置当前 textField 的 delegate，否则下面的回调无法响应。可以代码设置，也可以在 xib 中连当前 textField 的 delegate 到 file&#39;s owner 上。 是否进入编辑模式1- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField 默认返回YES，进入编辑模式。NO不进入编辑模式。 进入编辑模式1- (void)textFieldDidBeginEditing:(UITextField *)textField 是否退出编辑模式1- (BOOL)textFieldShouldEndEditing:(UITextField *)textField 默认返回YES，退出编辑模式。NO不退出编辑模式 退出编辑模式1- (void)textFieldDidEndEditing:(UITextField *)textField 点击清除按钮是否清空1- (BOOL)textFieldShouldClear:(UITextField *)textField 默认返回YES，返回NO不清除。 点击键盘上Return按钮时候调用1- (BOOL)textFieldShouldReturn:(UITextField *)textField 输入任何字符的时候调用该方法1-(BOOL)textField:(UITextField *)field shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string 当输入字符时，代理调用该方法，如果返回YES则这次输入可以成功，如果返回NO，不能输入成功。range表示光标位置，string表示这次输入的字符串。 一些技巧全屏触摸关闭监听手势，当点击开始时，关闭 textfield 123- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self.textField resignFirstResponder];&#125; 如果你不能拿到 textfield 的实例，其实可以直接设置 endEditing 属性，表示结束编辑： 1[self.view endEditing:YES]; 限制长度使用上面的 shouldChangeCharactersInRange: 方法： 12345678910111213141516171819- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反 //按会车可以改变 if ([string isEqualToString:@"\n"])&#123; return YES; &#125; NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容 //判断是否时我们想要限定的那个输入框 if (self.myTextField == textField)&#123; if ([toBeString length] &gt; 20) &#123; //如果输入框内容大于20则弹出警告 textField.text = [toBeString substringToIndex:20]; UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@"超过最大字数不能输入了" delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil, nil] autorelease]; [alert show]; return NO; &#125; &#125; return YES; &#125; UITextField输入中文时文字下沉的解决方法出现情况：在 xib 创建的 UITextField 中输入中文的时候，Border Style 这个属性设置为第一种 UITextBorderStyleNone，同时 Clear Button 设置为 Never appears 时会出现这种情况 解决方法：可以设置 Clear Button 的出现时机，或者设置 Border Style 为其他类型 。如果一定要是这种 Border Style 和 Clear Button，那么可以将 xib 中的 UITextField 拖出来，通过代码设置 Border Style 的方式设置其为UITextBorderStyleNone (在 xib 中要先设置为其他的再在代码里这样设置才能成功)。 多个 UITextField 点击换行按钮，切换 FirstResponder主要就是利用 textFieldShouldReturn: 这个回调方法： 12345678910111213- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123; if (textField == errorTF1) &#123; [errorTF2 becomeFirstResponder]; &#125; else if (textField == errorTF2) &#123; [errorTF3 becomeFirstResponder]; &#125; else if (textField == errorTF3) &#123; [errorTF4 becomeFirstResponder]; &#125; else if (textField == errorTF4)&#123; [errorTF4 resignFirstResponder]; &#125; return NO;//YES or NO,that is a question&#125; textField 键盘遮挡界面上移主要的思想就是监听键盘弹出和消失的通知，然后判断是否需要将屏幕上移。完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374- (void)viewDidLoad &#123; [super viewDidLoad]; //Do any additional setup after loading the view, typically from a nib. //self.view.backgroundColor = [UIColor underPageBackgroundColor]; myTextField = [[UITextField alloc] init];//初始化UITextField myTextField.frame = CGRectMake(35, 230, 250, 35); myTextField.delegate = self;//设置代理 myTextField.borderStyle = UITextBorderStyleRoundedRect; myTextField.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;//垂直居中 myTextField.placeholder = @"Please entry your content!";//内容为空时默认文字 myTextField.returnKeyType = UIReturnKeyDone;//设置放回按钮的样式 myTextField.keyboardType = UIKeyboardTypeNumbersAndPunctuation;//设置键盘样式为数字 [self.view addSubview:myTextField]; //注册键盘出现与隐藏时候的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboadWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; //添加手势，点击屏幕其他区域关闭键盘的操作 UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hideKeyboard)]; gesture.numberOfTapsRequired = 1;//手势敲击的次数 [self.view addGestureRecognizer:gesture]; &#125; //键盘出现时候调用的事件 -(void) keyboadWillShow:(NSNotification *)note&#123; NSDictionary *info = [note userInfo]; CGSize keyboardSize = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].size;//键盘的frame CGFloat offY = (460-keyboardSize.height)-myTextField.frame.size.height;//屏幕总高度-键盘高度-UITextField高度 [UIView beginAnimations:nil context:NULL];//此处添加动画，使之变化平滑一点 [UIView setAnimationDuration:0.3];//设置动画时间 秒为单位 myTextField.frame = CGRectMake(35, offY, 250, 35);//UITextField位置的y坐标移动到offY [UIView commitAnimations];//开始动画效果 &#125; //键盘消失时候调用的事件 -(void)keyboardWillHide:(NSNotification *)note&#123; [UIView beginAnimations:nil context:NULL];//此处添加动画，使之变化平滑一点 [UIView setAnimationDuration:0.3]; myTextField.frame = CGRectMake(35, 230, 250, 35);//UITextField位置复原 [UIView commitAnimations]; &#125; //隐藏键盘方法 -(void)hideKeyboard&#123; [myTextField resignFirstResponder]; &#125; #pragma mark - #pragma mark UITextFieldDelegate //开始编辑： - (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123; return YES; &#125; //点击return按钮所做的动作： - (BOOL)textFieldShouldReturn:(UITextField *)textField &#123; [textField resignFirstResponder];//取消第一响应 return YES; &#125; //编辑完成： - (void)textFieldDidEndEditing:(UITextField *)textField &#123; &#125; -(void)viewDidDisappear:(BOOL)animated&#123; [super viewDidDisappear:animated]; [[NSNotificationCenter defaultCenter] removeObserver:self];//移除观察者 &#125; 设置 UITextField 的 Padding（leftview 和 rightview）当设置 UITextField 为左对齐的时候，就会发现输入的字和 placeholder 会紧贴着左边框。想要将字往右移，可以利用好 leftView 和 rightView 这两个属性。 这两个属性会被放在 textField 的最左边和最右边。我们只要创建一个 UIView 然后赋值给 leftView 就可以了： 123UIView spacerView = [[UIView alloc] initWithFrame: CGRectMake(0, 0, 10, 10)]; [textfield setLeftViewMode: UITextFieldViewModeAlways]; [textfield setLeftView: spacerView]; 注意这里要将 mode 设置为 UITextFieldViewModeAlways，否则左视图无法显现出来。 点击事件，不触发弹出键盘，触发其他事件就是不让直接修改，点击后触发自己的响应。只要实现代理方法就可以了： 1234- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField&#123;//写你要实现的：页面跳转的相关代码 return NO；&#125; 先完成自己的操作，然后设置这个 textField 不能响应。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notification 使用小结]]></title>
    <url>%2F2017%2F04%2F03%2FNotification%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近需求有关于通知的，折腾了许久，现在集中学习一下。主要针对 iOS10 的新特性。 基本原理本地推送（Local Notification） App 本地创建通知，加入系统的 Schedule 中。 如果达成触发条件则推送相应消息内容。 远程推送（Remote Notification） 设备向 APNS(Apple Push Notification Service)发送请求，注册自己。APNS 返回一个 deviceToken，设备再将发送给 PUSH 服务器。 服务器将要发送的消息，目标设备的 deviceToken 打包，发给 APNS。 APNS 在自身的已注册 Push 服务的 iPhone 列表中，查找有相应标识的iPhone，并把消息发到 iPhone。 iPhone 把发来的消息传递给相应的应用程序， 并且按照设定弹出 Push 通知。 基本设置配置关于推送证书的准备就不说了。除了推送证书，还需要打开 Push Notification 开关进行授权。打开开关后，会自动生成一个 xxx.entitlements 文件，如下图所示： 这里的 value 默认是 development，不需要我们手动改，Xcode 会在我们发布的时候自动改成 producetion 的。 方法头文件导入 #import &lt;UserNotifications/UserNotifications.h&gt;且要遵守&lt;UNUserNotificationCenterDelegate&gt;的协议，在 Appdelegate.m中。这里需要注意，我们最好写成这种形式（防止低版本找不到头文件出现问题）: 123#ifdef NSFoundationVersionNumber_iOS_9_x_Max#import &lt;UserNotifications/UserNotifications.h&gt;#endif 获取权限与注册在 Appdelegate 中先向用户获取权限与注册： 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [self replyPushNotificationAuthorization:application]; return YES;&#125;#pragma mark - 申请通知权限// 申请通知权限- (void)replyPushNotificationAuthorization:(UIApplication *)application&#123; if (IOS10_OR_LATER) &#123; //iOS 10 later //获取单例对象 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; //必须写代理，不然无法监听通知的接收与点击事件 center.delegate = self; [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (!error &amp;&amp; granted) &#123; //用户点击允许 NSLog(@"注册成功"); &#125;else&#123; //用户点击不允许 NSLog(@"注册失败"); &#125; &#125;]; // 可以通过 getNotificationSettingsWithCompletionHandler 获取权限设置 //之前注册推送服务，用户点击了同意还是不同意，以及用户之后又做了怎样的更改我们都无从得知，现在 apple 开放了这个 API，我们可以直接获取到用户的设定信息了。注意UNNotificationSettings是只读对象哦，不能直接修改！ [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; NSLog(@"========%@",settings); &#125;]; &#125;else if (IOS8_OR_LATER)&#123; //iOS 8 - iOS 10系统 UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil]; [application registerUserNotificationSettings:settings]; &#125; //向APNS注册 [application registerForRemoteNotifications];&#125; 其中定义的宏： 1234#define IOS10_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 10.0)#define IOS9_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9.0)#define IOS8_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)#define IOS7_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7.0) 上面方法兼顾了 iOS8 以上的各个系统。调用了上面的方法后，真机就会在屏幕上显示获取通知权限的对话框。 通过 getNotificationSettingsWithCompletionHandler: 这个新方法可以获取用户的设定信息，打印信息如下： 12345 [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; NSLog(@"========%@",settings); &#125;];打印信息如下：========&lt;UNNotificationSettings: 0x1740887f0; authorizationStatus: Authorized, notificationCenterSetting: Enabled, soundSetting: Enabled, badgeSetting: Enabled, lockScreenSetting: Enabled, alertSetting: NotSupported, carPlaySetting: Enabled, alertStyle: Banner&gt; UNUserNotificationCenter 是一个单例的对象，可以在代码的任意位置获取该对象的实例，请求通知权限。 DeviceToken可能会有更改，因此需要在程序的每次启动都去注册和设置。 获取 deviceToken上面的方法向苹果注册后，苹果返回 deviceToken: 123456789101112#pragma mark - 获取device Token//获取DeviceToken成功- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@"deviceToken===========%@",deviceString); // 将 deviceToken 发送给各种第三方推送或者自己的服务端 ...&#125;//获取DeviceToken失败- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error&#123; NSLog(@"[DeviceToken Error]:%@\n",error.description);&#125; 接收通知通知的类型在 iOS10 中，本地通知和远程通知合二为一。区分本地通知跟远程通知的类是UNPushNotificationTrigger.h类中，UNPushNotificationTrigger的类型是新增加的，通过它，我们可以得到一些通知的触发条件 ，解释如下： UNPushNotificationTrigger （远程通知） 远程推送的通知类型 UNTimeIntervalNotificationTrigger （本地通知） 一定时间之后，重复或者不重复推送通知。我们可以设置timeInterval（时间间隔）和repeats（是否重复）。 UNCalendarNotificationTrigger（本地通知） 一定日期之后，重复或者不重复推送通知 例如，你每天8点推送一个通知，只要dateComponents为8，如果你想每天8点都推送这个通知，只要repeats为YES就可以了。 UNLocationNotificationTrigger （本地通知）地理位置的一种通知，当用户进入或离开一个地理区域来通知。 iOS10对于 iOS10，且实现了 UNUserNotificationCenterDelegate 协议，将通过下面两个方法接收和处理通知： 当App处于前台： 12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler&#123; //收到推送的请求 UNNotificationRequest *request = notification.request; //收到推送的内容 UNNotificationContent *content = request.content; //收到用户的基本信息 NSDictionary *userInfo = content.userInfo; //收到推送消息的角标 NSNumber *badge = content.badge; //收到推送消息body NSString *body = content.body; //推送消息的声音 UNNotificationSound *sound = content.sound; // 推送消息的副标题 NSString *subtitle = content.subtitle; // 推送消息的标题 NSString *title = content.title; if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123; //此处省略一万行需求代码。。。。。。 NSLog(@"iOS10 收到远程通知:%@",userInfo); &#125;else &#123; // 判断为本地通知 //此处省略一万行需求代码。。。。。。 NSLog(@"iOS10 收到本地通知:&#123;\\\\nbody:%@，\\\\ntitle:%@,\\\\nsubtitle:%@,\\\\nbadge：%@，\\\\nsound：%@，\\\\nuserInfo：%@\\\\n&#125;",body,title,subtitle,badge,sound,userInfo); &#125; // 需要执行这个方法，选择是否提醒用户，有Badge、Sound、Alert三种类型可以设置 completionHandler(UNNotificationPresentationOptionBadge| UNNotificationPresentationOptionSound| UNNotificationPresentationOptionAlert);&#125; 这里就可以通过上面列举的类型判断推送的类型了。最后一个执行的 completionHandler(...) 方法可以在前台下也显示横幅。 App 横幅的点击事件： 12345678910111213141516171819202122232425262728293031323334353637- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123; //收到推送的请求 UNNotificationRequest *request = response.notification.request; //收到推送的内容 UNNotificationContent *content = request.content; //收到用户的基本信息 NSDictionary *userInfo = content.userInfo; //收到推送消息的角标 NSNumber *badge = content.badge; //收到推送消息body NSString *body = content.body; //推送消息的声音 UNNotificationSound *sound = content.sound; // 推送消息的副标题 NSString *subtitle = content.subtitle; // 推送消息的标题 NSString *title = content.title; if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123; NSLog(@"iOS10 收到远程通知:%@",userInfo); //此处省略一万行需求代码。。。。。。 &#125;else &#123; // 判断为本地通知 //此处省略一万行需求代码。。。。。。 NSLog(@"iOS10 收到本地通知:&#123;\\\\nbody:%@，\\\\ntitle:%@,\\\\nsubtitle:%@,\\\\nbadge：%@，\\\\nsound：%@，\\\\nuserInfo：%@\\\\n&#125;",body,title,subtitle,badge,sound,userInfo); &#125; completionHandler(); // 系统要求执行这个方法&#125; 这个方法的名字是 didReceiveNotificationResponse，是把本地推送和远端推送整合在一起了。下面👇的方法就是专门针对远端推送的。 iOS10 前app 在前台，不会有通知条幅，但是还是能走到下面的方法。进程杀死，点击条幅启动后也能走到下面的方法。 12345- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler &#123; NSLog(@"iOS7及以上系统，收到通知:%@", userInfo); completionHandler(UIBackgroundFetchResultNewData); //此处省略一万行需求代码。。。。。。&#125; 如果iOS10，且实现了上面的代理方法，则不会走下面的这个方法。 无论进程是否被杀死，都能走到上面的方法中。 添加推送本地推送本地推送的基本流程是： 创建一个触发器（trigger） 创建推送的内容（UNMutableNotificationContent） 创建推送请求（UNNotificationRequest） 推送请求添加到推送管理中心（UNUserNotificationCenter）中 创建触发器（trigger）新功能trigger可以在特定条件触发，有三类: UNTimeIntervalNotificationTrigger、UNCalendarNotificationTrigger、UNLocationNotificationTrigger。 定时推送： 123//timeInterval：单位为秒（s） repeats：是否循环提醒//50s后提醒UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:50 repeats:NO]; 定期推送： 1234567//在每周一的14点3分提醒NSDateComponents *components = [[NSDateComponents alloc] init]; components.weekday = 2;components.hour = 16;components.minute = 3; // components 日期UNCalendarNotificationTrigger *calendarTrigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES]; 地点推送： 地区信息使用CLRegion的子类CLCircularRegion，可以配置region属性 notifyOnEntry和notifyOnExit，是在进入地区、从地区出来或者两者都要的时候进行通知: 12345678//首先得导入#import &lt;CoreLocation/CoreLocation.h&gt;，不然会regin创建有问题。// 创建位置信息CLLocationCoordinate2D center1 = CLLocationCoordinate2DMake(39.788857, 116.5559392);CLCircularRegion *region = [[CLCircularRegion alloc] initWithCenter:center1 radius:500 identifier:@"经海五路"];region.notifyOnEntry = YES;region.notifyOnExit = YES;// region 位置信息 repeats 是否重复 （CLRegion 可以是地理位置信息）UNLocationNotificationTrigger *locationTrigger = [UNLocationNotificationTrigger triggerWithRegion:region repeats:YES]; 创建推送的内容（UNMutableNotificationContent）属性有 title、subtitle、body、badge、sound、lauchImageName、userInfo、attachments、categoryIdentifier、threadIdentifier。 12345678// 创建通知内容 UNMutableNotificationContent, 注意不是 UNNotificationContent ,此对象为不可变对象。 UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]; content.title = @"Dely 时间提醒 - title"; content.subtitle = [NSString stringWithFormat:@"Dely 装逼大会竞选时间提醒 - subtitle"]; content.body = @"Dely 装逼大会总决赛时间到，欢迎你参加总决赛！希望你一统X界 - body"; content.badge = @666; content.sound = [UNNotificationSound defaultSound]; content.userInfo = @&#123;@"key1":@"value1",@"key2":@"value2"&#125;; categoryIdentifier 后面会用到,就是下面 Notification Actions 里面的 identifier. 创建推送请求（UNNotificationRequest）1234// 创建通知标示NSString *requestIdentifier = @"Dely.X.time";// 创建通知请求 UNNotificationRequest 将触发条件和通知内容添加到请求中UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier content:content trigger:timeTrigger]; 这里的 identifier 是用来标识本地推送的，用在对本地推送的修改删除，一般用处不是太大。 添加到推送管理中心（UNUserNotificationCenter）中12345678910111213UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];// 将通知请求 add 到 UNUserNotificationCenter[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@"推送已添加成功 %@", requestIdentifier); //你自己的需求例如下面： UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"本地通知" message:@"成功添加推送" preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]; [alert addAction:cancelAction]; [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:alert animated:YES completion:nil]; //此处省略一万行需求。。。。 &#125;&#125;]; 远端推送远端推送需要服务器按照苹果的格式推送 aps 内容： 12345678910&#123; "aps" : &#123; "alert" : &#123; "title" : "iOS远程消息，我是主标题！-title", "subtitle" : "iOS远程消息，我是主标题！-Subtitle", "body" : "Dely,why am i so handsome -body" &#125;, "badge" : "2" &#125;&#125; Notification Actions这是 iOS10 推出的通知功能拓展，可加可不加，用来给推送添加一些按钮。 创建Actionbutton型：12345 UNNotificationAction *lookAction = [UNNotificationAction actionWithIdentifier:@"action.join" title:@"接收邀请" options:UNNotificationActionOptionAuthenticationRequired];UNNotificationAction *joinAction = [UNNotificationAction actionWithIdentifier:@"action.look" title:@"查看邀请" options:UNNotificationActionOptionForeground];UNNotificationAction *cancelAction = [UNNotificationAction actionWithIdentifier:@"action.cancel" title:@"取消" options:UNNotificationActionOptionDestructive]; 其中 UNNotificationActionOptions 是一个枚举类型，用来标识 Action 触发的行为方式分别为： UNNotificationActionOptionAuthenticationRequired = (1 &lt;&lt; 0)，需要解锁显示，点击不会进app UNNotificationActionOptionDestructive = (1 &lt;&lt; 1)，红色文字。点击不会进app UNNotificationActionOptionForeground = (1 &lt;&lt; 2)，黑色文字，点击会进app 输入框型：1UNTextInputNotificationAction *inputAction = [UNTextInputNotificationAction actionWithIdentifier:@"action.input" title:@"输入" options:UNNotificationActionOptionForeground textInputButtonTitle:@"发送" textInputPlaceholder:@"tell me loudly"] 输入框型多了两个参数，buttonTitle 输入框右边的按钮标题，placeholder 输入框占位符。 创建categorybutton型1UNNotificationCategory *notificationCategory = [UNNotificationCategory categoryWithIdentifier:@"Dely_locationCategory" actions:@[lookAction, joinAction, cancelAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; 其中： identifier: 标识符是这个 category 的唯一标识，用来区分多个 category,这个 id 不管是 Local Notification，还是 remote Notification，一定要有并且要保持一致 actions: 创建的 action 操作数组 intentIdentifiers: 意图标识符 可在 &lt;Intents/INIntentIdentifiers.h&gt; 中查看，主要是针对电话、carplay 等开放的 API options: 一般都是 UNNotificationCategoryOptionCustomDismissAction 就行 不同通知，action 的方式也会不同。所以这个 identifier 是用来标识该用哪种方式处理的。对于 remote notification，需要在发给 APNS 的消息中添加 category 字段，值与 identifier 相同。对于 local notification，需要设置 UNMutableNotificationContent 实例的 categoryIdentifier 属性。 输入框型1UNNotificationCategory *notificationCategory = [UNNotificationCategory categoryWithIdentifier:@"Dely_locationCategory" actions:@[inputAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; 将 category 添加到通知中心123// 将 category 添加到通知中心 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; [center setNotificationCategories:[NSSet setWithObject:notificationCategory]]; 事件的操作上面代码并没有添加具体的操作方式，具体的操作都在前面说过的 didReceiveNotificationResponse 方法中进行： 1234567891011121314151617181920212223//App通知的点击事件- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123; //点击或输入action NSString* actionIdentifierStr = response.actionIdentifier; //输入框型 if ([response isKindOfClass:[UNTextInputNotificationResponse class]]) &#123; NSString* userSayStr = [(UNTextInputNotificationResponse *)response userText]; NSLog(@"actionid = %@\n userSayStr = %@",actionIdentifierStr, userSayStr); //此处省略一万行需求代码。。。。 &#125; //button型 if ([actionIdentifierStr isEqualToString:@"action.join"]) &#123; //此处省略一万行需求代码 NSLog(@"actionid = %@\n",actionIdentifierStr); &#125;else if ([actionIdentifierStr isEqualToString:@"action.look"])&#123; //此处省略一万行需求代码 NSLog(@"actionid = %@\n",actionIdentifierStr); &#125; 通过 response 拿到前面设置的 identifier，来按照需求，定制操作。 Media Attachments这个东西是给推送添加多媒体效果，比如图片，视频等。暂时用到的不多，用到再看。 详细的参考文档 推送拓展详解 iOS10拓展完全解析]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因为IPv6被拒之后]]></title>
    <url>%2F2017%2F03%2F31%2F%E7%94%B1%E4%BA%8EIPv6%E8%A2%AB%E6%8B%92%2F</url>
    <content type="text"><![CDATA[最近的两个 app 相继被拒。被拒的原因都是由于 IPv6，导致网络无法连接。一般来说需要更新网络库。但是也说不定是审核的问题啊。所以可以先搭建一个本地的 IPv6 的环境，测试下是否是自己的问题。 搭建步骤可以通过 mac 构建一个 IPv6 的环境，然后让手机连接上 mac。但是这就需要一个转接口，因为需要 mac 直接连接到以太网。如果没有转接口，那么就可以参照下面的方法需要两台 iphone（一部提供网络，一部用于测试） 以及一根数据线。 第一步，将用于提供网络的机器通过数据线连接上mac。 第二步，关闭机器的 wifi 和 4G，打开机器的个人热点并且选择仅 USB 如下图所示： 第三步，打开系统偏好设置,按住option(alt)键（一定要按）点击共享： 第四步，创建 NAT64 网络 第五步，关闭 mac 当前连接的wifi，等待一会就会显示如下图片所示的图标： 第六步，测试用的手机连接 wifi 如果连接正确，如果显示如上图的 DNS，那么就表示 IPv6 的环境已经搭建好了。可以测试是否是自己代码的问题，还是苹果测试的问题了。 依旧被拒如果依旧被拒那么可以拍一个视频给审核人员详情参考这个链接,有详细例子如何拍视频,点击查看,如何录制视频的样例,有几位按照这个录制顺利通过审核 问题:如何拍视频啊? 答:拿个安卓或者iOS手机拍摄.个人觉得不应该是录制屏幕,录制屏幕不能很好的反映出你适配ipv6的过程问题:怎么拍 答:先拍你搭建环境的过程,ipv6环境搭建好了,wifi有箭头吧,ipv6 的DNS是:隔开的,iPv4 的DNS 是隔开的,手机正确连接电脑wifi的过程也需要拍摄的,这些标志你搭建ipv6环境搭建成功的画面都需要 拍,在拍的时候把自己的app所有界面(都可以加载数据)运行良好的状态拍一下问题:拍好的视频怎么传给苹果审核人员? 答:拍好的视频传到youtwobe,(不推荐传到优酷,万一美国的审核人员没有耐心等待你的视频加载,又给你打回来 了,美国访问中国的网速会比中国访问中国的网速要慢) 如果你重新提交新版本,就把链接贴在备注的描述 下,平时在这个描述里写这个app.如果你的app 你觉得没任何问题,不想再上传ipa包,登录苹果开发者账号 找到苹果拒绝的描述,这个描述是可以回复的(Reply),在这个Reply里面贴上你的视频链接,写上大致意思 是:”我真的适配了ipv6,我把适配和测试过程都排了,麻烦你再审一遍”的话,说话一定要诚恳,礼貌,说话一定要诚恳,礼貌,说话一定要诚恳,礼貌(重要事说三遍),上面的这些做了还是被拒绝怎么办,措施1试过,措施2也试过,还是不管用,我只能建议你继续提交了,stakeoverflow上面有人说,自己测试了都是没问题,怎么苹果还是拒绝,苹果的工程师告诉他你就继续提交吧,这是审核人员的bug,其实这种情况国内的开发者(包括笔者)也遇到过,你明明提供了app的测试账号,他说你没提供,你回复下就好了!他们人工审核也会有失误的时候,只是这个失误被你碰到了!这就是为什么有部分网友啥都没修改,只是在拒绝的描述哪里reply 一下就通过了. 参考文章： iOS-用手机网络测试Ipv6 ipv6审核被拒绝的解决方案]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 文件下载与处理相关]]></title>
    <url>%2F2017%2F03%2F30%2FiOS%20%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[iOS 文件下载与处理相关 iOS 沙盒机制每个应用程序的活动范围都限定在自己的沙盒里。不能随意跨越自己的沙盒去访问别的应用程序沙盒中的内容。 沙盒中的目录类型详解就像 url 一样，每个手机中的 app 都有一个独一无二的路径，通过这个路径，我们能拿到 app 中保存的资源。在根路径下保存着几个特定的文件夹，下面将介绍这几个文件夹： Document:保存应用运行时生成的需要持久化的数据。建议将在应用程序中只有用户生成的文件、应用程序不能重新创建的文件保存在该文件夹。iCloud 会自动备份这个文件夹。 Library:该文件夹下又有两个子文件夹。 Caches:可以重新下载或者重新生成的数据应该保存在该目录下，该文件夹下的文件不会因为退出而清除。iCloud 不会自动备份该文件夹 Preferences:保存应用程序的所有偏好设置 iOS 的 Settings，我们不应该直接在这里创建文件，而是需要通过 NSUserDefault 这个类来访问应用程序的偏好设置。 Tmp:保存临时使用的数据，其中的数据会在应用退出后清除。 根路径一般形式如下，各个文件夹都保存在该目录下: 1/var/mobile/Containers/Data/Application/一串随机字符用以和其他app区分开 除了上面的提到的根目录，随着 app 一起打包的资源文件都会被放在一个 bundle 目录下，路径一般为： 1/var/containers/Bundle/Application/随机字符串，和上面的不同/应用名.app 资源文件都是通过这个根路径拼接获得的，比如要得到一个 www 目录下的 test.js 文件，那么路径就是 1/var/containers/Bundle/Application/随机字符串，和上面的不同/应用名.app/www/test.js 注意如果你做个记事本的app，那么用户写了东西，总要把东西存起来。那么这个文件则是用户自行生成的，就放在documents文件夹里面。 如果你有一个app，需要和服务器配合，经常从服务器下载东西，展示给用户看。那么这些下载下来的东西就放在 library/cache。 在 cache 目录下的文件在存储空间不足的情况下，会被清空。所以一些重要的文件最好不要放在 cache 中。 apple对这个很严格，放错了就会被拒。主要原因是ios的icloud的同步问题。 获取沙盒路径获取沙盒的 Home 目录123//获取根目录 NSString *homePath = NSHomeDirectory(); NSLog(@"Home目录：%@",homePath); 获取沙盒的 Documents 目录1NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject]; 获取 Library 文件路径1NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES) firstObject]; 获取 Caches 文件路径1NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES) firstObject]; 获取 Tmp 文件路径1NSString *filePath = NSTemporaryDirectory(); 其中 NSUserDomainMask 表示在当前沙盒范围内查找，YES 表示展开路径，NO 表示不展开路径。里面的所有文件夹都可以通过 Home 目录拼接而成。 沙盒里还有很多其他的文件夹，上面只是列举了常用的几个。 获取 Bundle 文件路径1NSString *bundle = [[NSBundle mainBundle] resourcePath]; 这个 Bundle 路径就是工程的主路径，可以通过拼接路径的方式，获取工程下的各种资源文件。需要注意，路径是文件夹的绝对路径，而不是 xcode 中显示的 group 路径。 文件下载文件操作创建文件夹在 Document 目录下创建 test 文件夹： 123456789101112//创建文件夹 -(void)createDir&#123; NSString *documentsPath =[self dirDoc]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *testDirectory = [documentsPath stringByAppendingPathComponent:@"test"]; // 创建目录 BOOL res=[fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil]; if (res) &#123; NSLog(@"文件夹创建成功"); &#125;else NSLog(@"文件夹创建失败"); &#125; NSFileManger 是一个文件处理的类。 self dirDoc 是自定义的获得 Document 文件路径的方法，上面说到过。 创建文件123456789101112//创建文件 -(void)createFile&#123; NSString *documentsPath =[self dirDoc]; NSString *testDirectory = [documentsPath stringByAppendingPathComponent:@"test"]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *testPath = [testDirectory stringByAppendingPathComponent:@"test.txt"]; BOOL res=[fileManager createFileAtPath:testPath contents:nil attributes:nil]; if (res) &#123; NSLog(@"文件创建成功: %@" ,testPath); &#125;else NSLog(@"文件创建失败"); &#125; 写数据到文件123456789101112//写文件 -(void)writeFile&#123; NSString *documentsPath =[self dirDoc]; NSString *testDirectory = [documentsPath stringByAppendingPathComponent:@"test"]; NSString *testPath = [testDirectory stringByAppendingPathComponent:@"test.txt"]; NSString *content=@"测试写入内容！"; BOOL res=[content writeToFile:testPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; if (res) &#123; NSLog(@"文件写入成功"); &#125;else NSLog(@"文件写入失败"); &#125; 从文件读数据12345678910//读文件 -(void)readFile&#123; NSString *documentsPath =[self dirDoc]; NSString *testDirectory = [documentsPath stringByAppendingPathComponent:@"test"]; NSString *testPath = [testDirectory stringByAppendingPathComponent:@"test.txt"]; // NSData *data = [NSData dataWithContentsOfFile:testPath]; // NSLog(@"文件读取成功: %@",[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); NSString *content=[NSString stringWithContentsOfFile:testPath encoding:NSUTF8StringEncoding error:nil]; NSLog(@"文件读取成功: %@",content); &#125; 文件大小12345678+(float)fileSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager=[NSFileManager defaultManager]; if([fileManager fileExistsAtPath:path])&#123; long long size=[fileManager attributesOfItemAtPath:path error:nil].fileSize; return size/1024.0/1024.0; &#125; return 0;&#125; 这个方法获得文件的各个属性，其中一个属性是 fileSize。一般清除缓存的时候需要用到计算文件大小。 删除文件12345678910111213//删除文件 -(void)deleteFile&#123; NSString *documentsPath =[self dirDoc]; NSString *testDirectory = [documentsPath stringByAppendingPathComponent:@"test"]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *testPath = [testDirectory stringByAppendingPathComponent:@"test.txt"]; BOOL res=[fileManager removeItemAtPath:testPath error:nil]; if (res) &#123; NSLog(@"文件删除成功"); &#125;else NSLog(@"文件删除失败"); NSLog(@"文件是否存在: %@",[fileManager isExecutableFileAtPath:testPath]?@"YES":@"NO"); &#125; NSData 使用下载得到的文件，一般是以 NSData 的形式出现，使用时需要将其转换成相应的类，比如 NSString,UIImage 等类的形式。 NSData 与 NSStringNSData 转 NSString： 1NSString *newStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSString 转 NSData： 1NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding]; NSData 与 UIImageNSData 转 UIImage： 1UIImage *aimage = [UIImage imageWithData: imageData]; UIImage 转 NSData： 1NSData *imageData = UIImagePNGRepresentation(aImage); 下载可以通过 NSURLConnection类创建下载，不过该类在 iOS9 中被废弃了，取而代之的是 NSURLSession 类。我们下面只学习下该类的使用方式和技巧。 普通的网络请求创建任务后，不会自动发送请求，需要手动开始任务： 1234567891011121314// 1.得到session对象NSURLSession* session = [NSURLSession sharedSession];NSURL* url = [NSURL URLWithString:@""];// 2.创建一个task，任务NSURLSessionDataTask* dataTask = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; // data 为返回数据 dispatch_async(dispatch_get_main_queue(), ^&#123; [_image setImage:[UIImage imageWithData:data]]; &#125;);&#125;];// 3.开始任务[dataTask resume]; 因为是主要讲下载文件的，所以这里省略了 Session 创建的具体过程。一般情况下，我们是需要为 Session 设置 delegate 的，以此监听下载情况，这里都省略了。 注意，completionHandler 这个回调是在后台线程中的，如果想要改变UI，就必须dispatch到主线程中去，否则会等待很长时间才能显示出来 下载文件如果使用 NSURLSessionDataTask 下载文件，那么就要考虑边下边存的情况，如果文件很大，那么内存很容易爆炸。但是使用 NSURLSessionDownloadTask 就不需要边下载边写入等问题，苹果做好了封装。只需要在结束的时候将临时文件移动到目标文件目录中即可： 1234567891011NSURL* url = [NSURL URLWithString:@"http://dlsw.baidu.com/sw-search-sp/soft/9d/25765/sogou_mac_32c_V3.2.0.1437101586.dmg"];// 得到session对象NSURLSession* session = [NSURLSession sharedSession];// 创建任务NSURLSessionDownloadTask* downloadTask = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123; // ... 省略了将 location 下的文件移动到目标文件目录中的过程&#125;];// 开始任务[downloadTask resume]; 这里回调参数没有了 NSData，多了一个 location，这个就是下载好的文件写入沙盒的地址，打印后发现下载好的文件被写入了 temp 文件夹下。 这里直接在创建 downloadTask 的时候提供了结束的回调，其实也可以设置 delegate，比如要监听下载进度的时候，就必须使用 delegate 了。具体见下方 所以我们需要将 temp 目录下的文件转移到不会被删除的 caches 目录下。 12345678910NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];// response.suggestedFilename ： 建议使用的文件名，一般跟服务器端的文件名一致NSString *file = [caches stringByAppendingPathComponent:response.suggestedFilename];// 将临时文件剪切或者复制Caches文件夹NSFileManager *mgr = [NSFileManager defaultManager];// AtPath : 剪切前的文件路径// ToPath : 剪切后的文件路径[mgr moveItemAtPath:location.path toPath:file error:nil]; 监听下载进度上面的方法可以下载，但是无法监听下载的进度。想要监听下载进度，需要通过 delegate，要遵循协议NSURLSessionDownloadDelegate ： 123456789101112131415161718192021222324252627282930313233343536373839404142/* * Messages related to the operation of a task that writes data to a * file and notifies the delegate upon completion. */@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;/* Sent when a download task that has completed a download. The delegate should * copy or move the file at the given location to a new location as it will be * removed when the delegate message returns. URLSession:task:didCompleteWithError: will * still be called. * 下载完毕会调用 * * @param location 文件临时地址 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location;@optional/* Sent periodically to notify the delegate of download progress. * 每次写入沙盒完毕调用 * 在这里面监听下载进度，totalBytesWritten/totalBytesExpectedToWrite * * @param bytesWritten 这次写入的大小 * @param totalBytesWritten 已经写入沙盒的大小 * @param totalBytesExpectedToWrite 文件总大小 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;/* Sent when a download has been resumed. If a download failed with an * error, the -userInfo dictionary of the error will contain an * NSURLSessionDownloadTaskResumeData key, whose value is the resume * data. * 恢复下载后调用， */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;@end 上面说到设置 delegate 时， NSURLSessionDownloadTask 创建方式有所不同： 12345678910// 得到session对象NSURLSessionConfiguration* cfg = [NSURLSessionConfiguration defaultSessionConfiguration]; // 默认配置NSURLSession* session = [NSURLSession sessionWithConfiguration:cfg delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 创建任务NSURLSessionDownloadTask* downloadTask = [session downloadTaskWithURL:url];// 开始任务[downloadTask resume]; 断点下载主动暂停文件的暂停和恢复可以通过 resume 和 suspend 方法实现。但是这样做，程序退出后再开启就不能接着下载了。一般如果是主动暂停的话会使用 cancelByProducingResumeData: 方法: 123456__weak typeof(self) selfVc = self;[self.downloadTask cancelByProducingResumeData:^(NSData *resumeData) &#123; // resumeData : 包含了继续下载的开始位置\下载的url selfVc.resumeData = resumeData; selfVc.downloadTask = nil;&#125;]; 调用该取消方法后会回调一个 block，并传入 resumeData，该参数包含了继续下载文件的位置信息，你可以将其转换为 NSString，打印出来可以看到其实是 plist 的形式，你可以将其保存为 plist 文件。上面 selfVc.downloadTask = nil 直接将 downloadTask 直接置为了 nil，因为后面继续下载的时候会重新创建一个。 继续下载的时候需要重新创建一个与 resumeData 相关的downloadTask： 123// 传入上次暂停下载返回的数据，就可以恢复下载self.downloadTask = [self.session downloadTaskWithResumeData:self.resumeData];[self.downloadTask resume]; // 开始任务 手动杀掉应用后的被动暂停不论是普通的 NSURLSession 还是可以在后台使用的 NSURLSession，它们在被手动杀掉后都会保存当前的 NSURLSession 信息，在下次启动并且创建了相同 Identifier 的 session 实例之后，就会自动调用 NSURLSessionTaskDelegate 中的 task 结束回调。由于是下载失败，所以 error 中会包含信息，可以从其中取出 resumeData，并重新创建下载： 1234567891011121314- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; if (error) &#123; // check if resume data are available if ([error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData]) &#123; NSData *resumeData = [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData]; // 重新创建一个 DownloadTask，并开始下载 NSURLSessionDownloadTask *task = [self.session] downloadTaskWithResumeData:resumeData]; [task resume]; &#125; &#125;&#125; 各个系统版本导致的 resumeData 的错误iOS10.0 - 10.1 中使用系统的 resumeData 无法直接恢复下载，原因是currentRequest和originalRequest 的NSKeyArchived编码异常。获取到resumeData后，需要对它进行修正，使用修正后的resumeData创建downloadTask，再对downloadTask的currentRequest和originalRequest赋值，Stack Overflow上面有具体说明。 iOS 11.0 - 11.2 中由于多次对downloadTask进行 取消 - 恢复 操作，生成的resumeData会多出一个key为NSURLSessionResumeByteRange的键值对，所以会导致直接下载成功（实际上没有），下载的文件大小直接变成0。需要把key为NSURLSessionResumeByteRange的键值对删除。 普通下载与后台下载普通下载后后台下载的区别在于创建的 NSURLSession 是普通的还是支持后台的，也就是创建时传入的 config 的区别： 12345// 支持后下载的 NSURLSession 的 configNSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@"some Identifier"];// 普通的 NSURLSession 的 configNSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration default]; 后台的 config 要求传入一个 Identifier，而普通的 config 则是默认的。 进入后台、应用 crash普通下载在后台 crash 时会立刻停止下载；而后台下载则不同，它在进入后台后，会和 background task 一样让应用获取 3 分钟的活动时间，时间到后还没下载完成的，会被系统的 watchdog 杀死，进而由另一个系统的进程继续下载。其他各种代码不严谨导致的 crash 也是一样，系统会创建另一个进程下载。 在回到前台，或者重新创建 Session 之后，session 的代理方法会被继续调用。在重建 Session 的时候，可以通过 Session 的 getTasksWithCompletionHandler: 方法获取重建 Session 之后，恢复的之前的 downloadTask，并对其做一定的设置(比如你用一个包装类将 Task 包装了起来，Task 回调中使用的是包装类的方法，那么你就一定要在创建完 Session 之后立即获取所有的 Task，重建包装类。) 下载完成普通下载的下载完成就是正常的前台下载完成。而后台下载完成则区分各种情况： 应用在前台 应用在后台 应用被杀，且下载完成时应用没有被打开 应用被杀，且下载完成时应用被打开，且同时创建好相同 Identifier 的 Session 应用被杀，且下载完成时应用被打开，但没有创建相同 Identifier 的 Session 1 就是走普通的回调 2 全部 task 完成后回调下面方法激活 app： 1234//在应用处于后台，且后台任务下载完成时回调 - (void)application:(UIApplication *)applicationhandleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler; 之后会调用 session 相关代理方法，最后调用: 12345/* 应用在后台，而且后台所有下载任务完成后， * 在所有其他NSURLSession和NSURLSessionDownloadTask委托方法执行完后回调， * 可以在该方法中做下载数据管理和UI刷新 */ - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session; 最好将handleEventsForBackgroundURLSession中completionHandler保存，在该方法中待所有载数据管理和UI刷新做完后，再调用completionHandler() 3 由于应用没有被打开，会先启动 app，回调 AppDelegate 中的 didFinishLaunchingWithOptions: 方法。随后会回调 2 中的 handleEventsForBackgroundURLSession。由于 2 在后台，Session 没有被清除，所以后面就可以直接回调 Session 的代理方法。而 3 此时刚刚重新启动，没有创建 Session，因此，需要在 handleEventsForBackgroundURLSession 方法中通过 Identifier 重建 Session，才能进行后续的回调方法。重建好 Session 之后的过程和 2 相同。 4 由于在前台，且创建好了 Session，因此和 1 一样 5 由于没有创建 Session，会调用 handleEventsForBackgroundURLSession 创建 Session，和 3 类似。 参考iOS使用NSURLSession进行下载（包括后台下载，断点下载） 写的非常好 iOS原生级别后台下载详解]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 证书相关]]></title>
    <url>%2F2017%2F03%2F04%2FiOS%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[关于苹果的证书问题搞得焦头烂额，代码没问题，跑不起来这是最气的。所以决定完整地了解一下。 基础密码基础加密方法可以分为两大类。一类是对称加密（private key cryptography），还有一类叫做非对称加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。 对称加密情况下，密钥只有一把，加密解密都通过其完成。密钥的保存非常重要。 非对称加密时，密钥有两把，一把给别人使用的公钥，一把只有自己知道的私钥。公钥和私钥一一对应，公钥能解开私钥加密的信息，私钥也能解开公钥加密的信息。同时生成公钥和私钥比较容易，但是从公钥推算出私钥是几乎不可能的。 目前，通用的对称加密算法为AES（Advanced Encryption Standard），通用的非对称加密算法为RSA（ Rivest-Shamir-Adleman）。 在非对称体系中，公钥用来加密信息（因为只有私钥才能打开），私钥用来数字签名（保证数据完整性的，但它不保证数据加密，不保证数据传输途中无人嗅探窃听）。 因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。 非对称加密原理关于非对称加密，在之前写过的 “http原理” 一文中也有大概的梳理。这边再仔细说下。 需要明确：公钥任何人都能有，私钥只能自己持有，如果别人拿到了你的私钥，那么别人也就成为了你。因此，用公钥加密，私钥解密的信息是绝密的；而用私钥加密，公钥解密的信息，并不能保证安全。所以用私钥加密的信息一般用来保证传输信息的完整性与未被修改。 整个加密解密的流程大概是这样的： A 有公钥，B 有私钥。A 将用公钥加密的消息发送给 B，那么只有拥有私钥的 B 才能够解密，其他人无法解密出消息明文。 B 要发消息给 A。由于公钥是公开的，那么 B 用私钥加密的消息对所有人其实都是公开的，所以一般不用 B 的私钥加密消息。而只是拿 B 的私钥产生一个“数字签名”。数字签名就是 将 B 即将给 A 发送的消息的 hash 值（通过 MD5、SHA等算法）进行加密。B 发送消息的时候，将消息原文和数字签名一并发出。A 接收到两者后，对原文取 hash，与公钥解密的数字签名中获得的 hash 值比对，如果相同表示消息没有经过别人的修改。 上面保证了 A 的信息能安全的到 B。但是没有解决“如何才能使 B 给 A 发送的消息不被别人窥探？” 很容易想到，只要再来一套公钥私钥，即 B 同时也拥有 A 的公钥，发信息的时候用 A 的公钥加密即可，不过这样处理非常麻烦费时。https 是这样做的：客户端拥有服务端的公钥（即上面所说的 A，先不要管怎么拿到的服务端公钥的以及是如何确定就是服务端公钥而不是其他攻击者的公钥的这两点），服务端拥有其自己的私钥（即 B）。A 在本地生成一段随机字符，作为之后对称加密的密钥，将这个密钥通过公钥加密发给 B，这样 A B 就共同拥有了其他人都不知道的共同密钥，两者之间的通信就安全了。所以 https 的本质是对称加密，核心是客户端如何将密钥传给服务端，根本问题就是如何能够正确的拿到服务端的公钥，而不被中间人篡改。 上面说到如何拿到服务端的公钥，在客户端发起请求后，服务端会返回一个证书，这个证书中就包含着公钥。客户端如何相信这个证书就是想要请求的服务端的证书而不是攻击者的证书呢？这就需要一个权威的第三方的验证，即”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥为服务器的公钥，以及服务端的信息做加密，连同 CA 信息，保存在新生成的”数字证书”中。客户端最终获取到证书就是经过证书中心加密过的证书。拿到证书后，客户端先到自身根证书列表查看该证书中心是否是本机信任的证书中心（自己计算机的物理安全是前提，如果别人已经可以直接控制你的计算机，修改根证书列表，那什么证书安全也救不了你。）。然后就用根证书里的公钥去解析该证书，验证服务端信息以及公钥是否被修改。 其实道理就是：你不是不相信发来的公钥的可靠性么。那么就你自己先保存一些信任的第三方的公钥，通过 CA 的公钥去解析获得服务端的公钥。攻击者是没有 CA 认证过 ，或者即使认证了，证书中的信息也是与真正要请求的服务端不同的。因此，这样就能保证其可信性了。 说完了 https，其实 SSH 也是类似的，服务端传输公钥给客户端给其加密使用，同样的也会遇到中间人攻击的问题。由于 SSH 没有 CA 认证，所以在第一次连接服务器时要慎重，会提示你是否接受这个远程主机的公钥： 1Are you sure you want to continue connecting (yes/no)? yes 如果接受，那么该公钥就会保存在本机中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了。 https 和 SSH 都接受用户名密码登录，即客户端通过服务器下发的公钥加密后传输给远程主机。SSH 还接受公钥登录，就是本机生成一对公钥和私钥（保存在根目录的 .ssh 文件夹下），将公钥保存在服务器上，有点类似于上面说的 A 和 B 各自保存自己的公钥和对方的私钥。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 在 Apple 开发网站上传包含公钥的 CSR 文件作为换取证书的凭证（Upload CSR file to generate your certificate）（即自己的公钥），有点类似为github账号添加SSH公钥到服务器上进行授权。 iOS 相关App IDsapp id 和 bundle identifier 是一致（Explicit）的或匹配（Wildcard）的。 在 name 中输入 app id 显示的名字： 可以选择 explicit app id 或者 wildcard app id。前者用于表示标识唯一的应用程序，后者为含有通配符的 app id，用于标识一组应用程序。一般推荐用前者。 最后勾选需要用到的 app service，比如 push notification: 继续点击 continue-&gt;submit-&gt;done，完成 app id 的创建。可以点击刚申请的 id，对其进行编辑： 比如如果用到推送功能，就要为其添加推送证书： 总结：app id 主要设置了 bundle id 的 app 特有标识，另外为该 app 设置了所需的服务。 CertificatesiOS证书是用来证明iOS App内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证App内容是完整、未经篡改的。上面讲了许多关于证书的原理，这里主要讲讲 iOS 中证书的配置。 证书分类iOS证书按功能分为两种：开发证书（Development） 和生产证书（Production）。 开发证书用于开发和调试应用程序，可用于联机调试。无论是 debug 还是 release 用的都是开发证书 生产证书用来发布应用程序。 iOS 证书按类型分为两种：个人证书（Personal） 和企业证书（enterprise） 个人证书仅会在安装的时候验证证书的有效性。因此，当你安装完 app 后，即使你删除 developer 账号中的开发证书或者生产证书都是没有关系的。 企业证书在任何打开 app 的时候都会验证证书的有效性。因此，无论何时，一定不能删除 developer 账号中的开发证书或者生产证书。否则，用该证书签名的 app 将提示证书错误，将无法打开。 生成证书请求文件 （CSR）CSR 是 Cerificate Signing Request 的英文缩写，即证书请求文件，也就是证书申请者在申请数字证书时由 CSP (加密服务提供者)在生成私钥的同时也生成证书请求文件（私钥和 CSR 同时生成）（CSR 其实也就是公钥），证书申请者只要把 CSR 文件提交给证书颁发机构后，证书颁发机构使用其根证书私钥签名就生成了证书公钥文件，也就是颁发给用户的证书。通过如下方式申请： 选择 “从证书颁发机构请求证书” 后出现下面情况，填写开发账号右键和常用名称，CA 电子右键地址可不填，勾选 “存储到磁盘”，然后继续： 最后得到一个 csr 文件 申请证书现在进入申请证书的流程： 由于 apple 规定一个账号只能申请3个开发证书，2个发布证书，所以现在图片上的部分不能被勾选。除了开发证书和发布证书，还可以勾选 Apple Push Notification service SSL (Sandbox) 和 Apple Push Notification service SSL (Sandbox &amp; Production) 来制作开发和发布推送证书。 如果是制作推送证书，需要绑定 App id： 如果不是推送证书跳过上一步，直接往下走，上传 CSR 文件： 点击生成，就完成了苹果用私钥对你的公钥加密生成证书的过程。将生成的证书下载后双击导入钥匙串，自动和之前生成的私钥匹配。在钥匙串的我的证书中就能看到相应证书。 导出证书对于团队合作，别人需要你创建的证书，你就要将苹果下发的证书（用苹果私钥加密的你的公钥）以及相应私钥导出为 .p12 格式的文件，发给别人使用。注意，你导出 p12 的时候一定要将证书和私钥一起选中导出 证书来自某人的 MacBook不知道你有没有注意过，当你登录到 developer 账号中查看证书的时候，经常会看见如下的情况： 这种带括号某某人的 MacBook 的证书怎么产生的呢？这是因为我们在 Xcode 中登录了开发者账号，如下所示： 登录 AppleId 后，会显示你一个 User 的 Team 一个 Agent 的 Team 里。Xcode 自动帮你在签名的时候生成了一个私钥以及证书。 DevicesDevice是指运行iOS系统用于开发调试App的设备（即苹果设备）。每台Apple设备使用UDID来唯一标识。 设备的UDID可通过iTunes-&gt;Summary或者Xcode-&gt;Window-&gt;Devices获取。 添加设备比较简单，就是输入设备的 UUID，并且给设备取一个别名即可。 Provisioning ProfilesProvisioning Profile 包含了上述的所有内容：证书，app id，设备。用来将证书和 app id 绑定。 Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Development 版本的 ProvisioningProfile 用于开发调试，包括 debug 和 release 版本，Distribution 版本的 ProvisioningProfile 只用于提交 App Store 审核，其不指定开发测试的 Devices。 在 XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile 可选择“Automatic”，xcode 会根据该 Target 的“Bundle identifier”选择默认的配置文件及证书： 自动签名的情况下，不需要自己设置 Provisioning Profiles。不过你也可以选择手动设置签名： debug 和 release 用的都是开发的配置文件。 更多这方面的信息可以参考iOS 各种证书/签名详解文章写得很详细。 iOS app 签名相关目的对 APP 进行签名的目的很简单，就是为了验证，你下载的 app 是合法的经过苹果审核的。 简单的签名方式下面图中有说明： 这种简单的签名方式是苹果自己生成了私钥和公钥，公钥保存在每一个生产出来的 iOS 设备中。通过苹果的私钥和公钥直接对 app 进行签名和验证。 新的问题 这种方式面临的问题是所有的 app 都要经过苹果的 app store。但是，比如企业发布啊，开发时的直接调试啊，都不经过 app store。我们面临两个需求： 安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。即不能直接用苹果的私钥对 app 进行签名，因为这样必然要将 app 上传 苹果必须对这里的安装有控制权，包括经过苹果允许才可以这样安装，不能被滥用导致非开发app也能被安装。即要保证 app 经过了苹果的私钥和公钥的签名和验证过程 两步签名明白了需求就容易找到思路了。既然不能将app的签名验证放在云端（苹果），那么就把验证放在本地。 首先不能用苹果的私钥签名 app，那么很容易想到，我们可以自己创建一对钥匙，用我们自己的私钥对 app 签名，公钥对 app 验证。 为了满足需求二，我们将我们自己创建的公钥上传到苹果的服务器让苹果用其自己的私钥签名（这就是所谓的开发者证书），这样就避免了传 app 进行签名的麻烦。当装到手机中后，会将苹果下发的证书以及我们的私钥对 app 的签名导报到设备中（我们的私钥没有放到设备中，只是将私钥对app 的签名放进去了）。通过设备中的苹果公钥就能解析出我们自己创建的公钥了。然后用公钥对私钥对app的签名进行解密，验证应用的完整性。这些操作都是在本地完成的，所以本地安装的时候就不需要联网请求任何东西进行验证了。 具体流程如下图： 在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple 把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。 在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。 在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。 验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。 注意，使用苹果的私钥去签名开发者的公钥，开发者的私钥去签名 APP。 想要确保什么的完整性，就用私钥去签名什么 更多细节上面已经是基本的流程了。不过苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。 流程就变成了下面的样子： 签名与证书的关系我们看到用私钥对 app 加密叫做签名，用私钥对别人的公钥进行加密叫做证书。 苹果的验证机制和 https 验证机制的异同其实只要涉及到证书的都是为了拿到公钥。https 中服务器拿公钥向 CA 要取签名，苹果的验证中则开发者拿公钥向苹果要取签名。https 中浏览器中有 CA 机构的公钥，苹果的验证中 iOS 设备中有苹果的公钥。 不同的是，https 中，浏览器拿到公钥，是为了加密数据；而 iOS 设备中拿到公钥，是为了验证签名。 总结所以对于上面的各个概念应该有了更深的理解： 证书cer：内容是公钥或私钥，由其他机构对其签名组成的数据包。 Entitlements：包含了 App 权限开关列表。 CertificateSigningRequest：本地公钥。 p12：本地私钥或者证书或者私钥与证书的二级制形式，可以导入到其他电脑。 PEM：本地私钥或者证书或者私钥与证书的base64形式，与 p12 类似。 Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。 上面说的是开发时或者是企业的签名验证流程。AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。 那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。 所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。 更多这方面的信息可以参考bang的文章 文章写得很详细。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（七）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%957%2F</url>
    <content type="text"><![CDATA[接着上一篇 访问控制模块和源文件模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。 源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。 访问级别 open:提供最高的权限，模块内外都能访问和重写。和 public 的区别下面说 public:可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体，但是不允许重写。 internal:可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。 fileprivate:限制实体只能在所在的源文件内部使用，即使不在同一个作用域内。 private：提供最低的权限，只有在同一个作用域内可访问。 open 和 public 在作用上很像。open 则是为了弥补 public 语义上的不足。通过 open 和 public 标记区别一个元素在其他 module 中是只能被访问还是可以被 override。现在的 public 在 module 内可以被 override，在被 import 到其他地方后其他用户使用的时候不能被 override，而 open 则可以。下面的例子很好的解释了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// ModuleA:// 这个类在ModuleA的范围外是不能被继承的，只能被访问public class NonSubclassableParentClass &#123; public func foo() &#123;&#125; // 这是错误的写法，因为class已经不能被继承， // 所以他的方法的访问权限不能大于类的访问权限 open func bar() &#123;&#125; // final的含义保持不变 public final func baz() &#123;&#125;&#125;// 在ModuleA的范围外可以被继承open class SubclassableParentClass &#123; // 这个属性在ModuleA的范围外不能被override public var size : Int // 这个方法在ModuleA的范围外不能被override public func foo() &#123;&#125; // 这个方法在任何地方都可以被override open func bar() &#123;&#125; ///final的含义保持不变 public final func baz() &#123;&#125;&#125;/// final的含义保持不变public final class FinalClass &#123; &#125;/// ModuleB:import ModuleA// 这个写法是错误的，编译会失败// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承class SubclassA : NonSubclassableParentClass &#123; &#125;// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.class SubclassB : SubclassableParentClass &#123; // 这样写也会编译失败 // 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'. override func foo() &#123; &#125; // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写 // 这里不需要再声明为open，因为这个类是internal的 override func bar() &#123; &#125;&#125;open class SubclassC : SubclassableParentClass &#123; // 这种写法会编译失败，因为这个类已经标记为open // 这个方法override是一个open的方法，则也需要表明访问权限 override func bar() &#123; &#125; &#125;open class SubclassD : SubclassableParentClass &#123; // 正确的写法，方法也需要标记为open open override func bar() &#123; &#125; &#125;open class SubclassE : SubclassableParentClass &#123; // 也可以显式的指出这个方法不能在被override public final override func bar() &#123; &#125; &#125; 在 Swift3 中 private 修饰的变量 extension 中是不能访问的，因为不在一个作用域中。但是 Swift4 中修改了这一个限制。现在在 extension 中也是能够访问 private 的属性的。 访问级别基本原则Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更高的实体。 看起来很简单的一个原则，但是要很注意的。 默认访问级别对于非 private 的类，你不为代码中的实体显式指定访问级别时，它们默认为 internal 级别。对于 private 的类，没必要显式指定访问级别，默认为 private。 元组类型元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 internal 级别，另一个类型为 private 级别，那么这个元组的访问级别为 private。 元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。 函数类型函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。 下面的例子定义了一个名为 someFunction 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译： 123func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // 此处是函数实现部分&#125; 根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别： 123private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // 此处是函数实现部分&#125; 将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。 枚举类型枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。 123456public enum CompassPoint &#123; case North case South case East case West&#125; 原始值和关联值枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。 嵌套类型如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。 子类子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。 此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。可以通过重写为继承来的类成员提供更高的访问级别： 1234567public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123;&#125;&#125; 注意提供更高访问级别需要注意符合当前访问级别，上面 someMethod 是 fileprivate 的，所以可以重写，但是下面就是错的： 12345678public class A &#123; //不能这么写 private func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123;&#125;&#125; 常量、变量、属性、下标常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。 如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private： 1private var privateInstance = SomePrivateClass() 协议如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。 协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。 如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。 协议继承如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public协议。 协议一致性一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。 采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。 如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别 补充断言与先决条件断言和先决条件用来检查某些条件是否满足。断言和先决条件不同之处在于什么时候做检查：断言只在 debug 时候检查，先决条件则在 debug 和生产构建中都生效。生产构建中，断言的条件不会被计算，因此无需担心新能。 断言的使用方式使用 assert(_:_:) 来进行断言： 12let age = -3assert(age &gt;= 0, "A person's age cannot be less than zero") 如果不需要检查条件直接抛出异常，那么可以使用 assertionFailure(_:) 1234567if age &gt; 10 &#123; print("You can ride the roller-coaster or the ferris wheel.")&#125; else if age &gt; 0 &#123; print("You can ride the ferris wheel.")&#125; else &#123; assertionFailure("A person's age can't be less than zero.")&#125; 强制先决条件使用上和断言类似，使用 precondition(_:_:) 也有 preconditionFailure(_:) 来强制抛出： 1precondition(index &gt; 0, "Index must be greater than zero.") 泛型中的 Where泛型中的 Where 主要用来约束泛型或者协议中的关联类型。在类型、函数、拓展、协议中都可以使用。 类型和函数中类型或函数中本来是可以直接定义泛型的，可以直接对泛型做约束： 12345678910111213protocol a &#123; associatedtype itemType&#125;protocol b &#123; associatedtype itemType&#125;class s &#123;&#125;class S&lt;T: a, K: b&gt; : s &#123;&#125; 但是这样，我们无法约束协议 a 和 b 中的关联类型。所以我们可以用 where 分句： 123456class S&lt;T: a, K: b&gt; : s where T.itemType == K.itemitemType &#123;&#125;或者class S&lt;T,K&gt; : s where T: a, K: b, T.itemType == K.itemType &#123;&#125; 泛型实现的协议以及协议中的关联类型都可以用 where 限制。 函数中使用 where 也类似，将 where 放在函数签名之后： 12func method&lt;T&gt;(param: T) where T: s &#123;&#125; extension 中由于 extension 中不能定义泛型，只能使用泛型，所以不能直接在 &lt;&gt; 中直接约束泛型了，但是仍然可以使用 Where： 12345678extension Stack where Element: Equatable &#123; func isTop(_ item: Element) -&gt; Bool &#123; guard let topItem = items.last else &#123; return false &#125; return topItem == item &#125;&#125; 协议中协议中不适用 &lt;&gt; 定义泛型，而是使用关联类型。如果要约束关联类型，那么也可以使用 where： 1234567891011protocol pro &#123;&#125;protocol Container where Item: pro &#123; associatedtype Item mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125; associatedtype Iterator: IteratorProtocol where Iterator.Element == Item func makeIterator() -&gt; Iterator&#125; 我们可以看到：where 都是将泛型或者关联类型约束为实现某个协议而不是继承某个类，原因很明显，因为明确了某个类了就不需要泛型以及关联类型了。 条件判断的 wherewhere 还可以用在条件判断上，比如之前在学习 Swith 的使用用到的，where 接受一个返回 Bool 类型的分句，用来做条件判断： 1case let(x, y) where x == y: 在 for…in 循环中，同样可以使用 where： 1234for element in 1...5 where element &gt;3 &#123; print(element)&#125;// 4,5 相当于： 12345for element in 1...5 &#123; if element &gt; 3 &#123; print element &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（六）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%956%2F</url>
    <content type="text"><![CDATA[接着上一篇 拓展扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力。 类似于 oc 的 category Swift 中的扩展可以： 添加计算型属性和计算型类型属性 定义实例方法和类型方法 提供新的构造器(具体看下面) 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议 拓展可以为一个类型添加新的功能，但是不能重写已有功能，也不可以添加存储型的属性、类属性，这和 oc 一致 拓展语法使用关键字 extension 来声明扩展： 123extension SomeType &#123; // 为 SomeType 添加的新功能写到这里&#125; 可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样： 123extension SomeType: SomeProtocol, AnotherProctocol &#123; // 协议实现写到这里&#125; 如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。 swift4 中新特性，extension 中也可以访问原本 private 的属性。在 Swift3 中就需要使用 fileprivate。 12345678910111213struct Date &#123; private let secondsSinceReferenceDate: Double&#125;extension Date: Equatable &#123; static func ==(lhs: Date, rhs: Date) -&gt; Bool &#123; return lhs.secondsSinceReferenceDate == rhs.secondsSinceReferenceDate &#125;&#125;extension Date: Comparable &#123; static func &lt;(lhs: Date, rhs: Date) -&gt; Bool &#123; return lhs.secondsSinceReferenceDate &lt; rhs.secondsSinceReferenceDate &#125;&#125; 这里就可以访问 secondsSinceReferenceDate 属性。 在 Swift 4 中，private 的属性的作用域扩大到了 extension 中，并且被限定在了 struct 和 extension 内部，这样就不需要再改成 fileprivate 了，这是最好的结果。 计算型属性扩展可以为已有类型添加计算型实例属性和计算型类型属性。 12345678910111213extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m : Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mmprint("One inch is \(oneInch) meters")// 打印 “One inch is 0.0254 meters”let threeFeet = 3.ftprint("Three feet is \(threeFeet) meters")// 打印 “Three feet is 0.914399970739201 meters” 由于拓展里不会有非可选属性，所以，这里可以直接获取 self 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。 添加计算型属性就相当于是添加方法 构造器扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。 复习一下，便利构造器和指定构造器是类中的两种不同类型构造器，不是结构体中的。因此，上面的话不适用于结构体，结构体中还是可以用拓展添加构造器的。 1234567891011121314151617181920212223242526struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0)) extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125;let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0) 方法扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法： 1234567891011121314extension Int &#123; func repetitions(task: () -&gt; Void) &#123; for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;3.repetitions(task: &#123; print("Hello!")&#125;)// Hello!// Hello!// Hello! ​ 可变实例方法通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self或其属性的方法必须将该实例方法标注为 mutating，正如来自原始实现的可变方法一样。 12345678extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square()// someInt 的值现在是 9 所以说嘛 Int 是结构体 下标扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字： 123456789[0] 返回 9 123456789[1] 返回 8 1234567891011121314151617extension Int &#123; subscript(digitIndex: Int) -&gt; Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self / decimalBase) % 10 &#125;&#125;746381295[0]// 返回 5746381295[1]// 返回 9746381295[2]// 返回 2746381295[8]// 返回 7 0..&lt;digitIndex 表示一个范围 嵌套类型扩展可以为已有的类、结构体和枚举添加新的嵌套类型： 123456789101112131415extension Int &#123; enum Kind &#123; case Negative, Zero, Positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .Zero case let x where x &gt; 0: return .Positive default: return .Negative &#125; &#125;&#125; 该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。 不能添加属性，但是可以添加枚举 使用： 123456789101112131415func printIntegerKinds(numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .Negative: print("- ", terminator: "") case .Zero: print("0 ", terminator: "") case .Positive: print("+ ", terminator: "") &#125; &#125; print("")&#125;printIntegerKinds([3, 19, -27, 0, -6, 0, 7])// 打印 “+ + - 0 - 0 + ” 由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 .Negative而不是 Int.Kind.Negative。 协议规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。 协议语法123protocol SomeProtocol &#123; // 这里是协议的定义部分&#125; 要让自定义类型采纳某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。采纳多个协议时，各协议之间用逗号（,）分隔，拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔： 123class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123; // 这里是类的定义部分&#125; 属性要求协议可以要求采纳协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。 如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。（可读包括可写可读） 协议总是用 var 关键字来声明变量属性，在类型声明后加上 { set get } 来表示属性是可读可写的，使用{get} 来明确可读的属性： 1234protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; var doesNotNeedToBeSettable: Int &#123; get &#125;&#125; 在协议中定义类型属性时，总是使用 static 关键字作为前缀。 123protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125;&#125; 当类类型采纳协议时，除了 static 关键字，还可以使用 class 关键字来声明类型属性，表示可被继承 Swift 中是真能在协议中添加属性，而 OC 中，添加的属性只是表示要求实现 get set 方法，但是并没有实例变量 方法要求这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。 正如属性要求中所述，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。 123protocol SomeProtocol &#123; static func someTypeMethod()&#125; 当类类型采纳协议时，除了 static 关键字，还可以使用 class 关键字作为前缀 12345678910111213141516171819protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125;class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; lastRandom = ((lastRandom * a + c) % m) return lastRandom / m &#125;&#125;let generator = LinearCongruentialGenerator()print("Here's a random number: \(generator.random())")// 打印 “Here's a random number: 0.37464991998171”print("And another one: \(generator.random())")// 打印 “And another one: 0.729023776863283” Mutating 方法要求如果你在协议中定义了一个实例方法，该方法会改变采纳该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够采纳此协议并满足此方法要求。 实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。 1234567891011121314enum OnOffSwitch: Togglable &#123; case off, on mutating func toggle() &#123; switch self &#123; case .off: self = .on case .on: self = .off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.offlightSwitch.toggle()// lightSwitch is now equal to .on 构造器要求你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体： 123protocol SomeProtocol &#123; init(someParameter: Int)&#125; 构造器要求在类中的实现你可以在采纳协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 required 修饰符： 12345class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // 这里是构造器的实现部分 &#125;&#125; 使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。就是构造器比较特殊 如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。 如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符： 1234567891011121314151617protocol SomeProtocol &#123; init()&#125;class SomeSuperClass &#123; init() &#123; // 这里是构造器的实现部分 &#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123; // 因为采纳协议，需要加上 required // 因为继承自父类，需要加上 override required override init() &#123; // 这里是构造器的实现部分 &#125;&#125; 貌似也没那么巧，重写的方法和继承的方法同名吧 可失败构造器要求采纳协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。 协议作为类型尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。 注意，Swift 中协议也是一种类型。 12345678910111213141516171819202122class Dice &#123; let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125;//LinearCongruentialGenerator 和 RandomNumberGenerator 上面定义过var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123; print("Random dice roll is \(d6.roll())")&#125;// Random dice roll is 3// Random dice roll is 5// Random dice roll is 4// Random dice roll is 5// Random dice roll is 4 RandomNumberGenerator 是上面定义的协议名 oc 中使用某个协议是 id&lt;协议名&gt;。swift 中直接将协议当成一种类型了 通过扩展添加协议一致性即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。 通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。 123456789protocol TextRepresentable &#123; var textualDescription: String &#123; get &#125;&#125;extension Dice: TextRepresentable &#123; var textualDescription: String &#123; return "A \(sides)-sided dice" &#125;&#125; 使用拓展声明采纳协议如果一个类型已经遵循了协议的所有需求，但是还没有声明它采纳了这个协议，你可以让通过一个空的扩展来让它采纳这个协议： 1234567struct Hamster &#123; var name: String var textualDescription: String &#123; return "A hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125; 协议的继承协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： 123protocol PrettyTextRepresentable: TextRepresentable &#123; var prettyTextualDescription: String &#123; get &#125;&#125; 任何采纳 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。 类类型专属协议你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前： 123protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // 这里是类类型专属协议的定义部分&#125; 协议合成有时候需要同时采纳多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成。你可以罗列任意多个你想要采纳的协议，以与符号(&amp;)分隔。 12345678910111213141516protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person: Named, Aged &#123; var name: String var age: Int&#125;func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")&#125;let birthdayPerson = Person(name: "Malcolm", age: 21)wishHappyBirthday(to: birthdayPerson)// 打印 “Happy birthday Malcolm - you're 21!” 协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。 检查协议一致性前面说过协议也能作为类型使用。那么也就可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。 12345678910for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print("Area is \(objectWithArea.area)") &#125; else &#123; print("Something that doesn't have an area") &#125;&#125;// Area is 12.5663708// Area is 243610.0// Something that doesn't have an area 可选的协议要求协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String的方法会变成 ((Int) -&gt; String)?。需要注意的是整个函数类型是可选的，而不是函数的返回值。 协议中的可选要求可通过可选链式调用来使用，因为采纳协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。 1234@objc protocol CounterDataSource &#123; @objc optional func increment(forCount count: Int) -&gt; Int @objc optional var fixedIncrement: Int &#123; get &#125;&#125; 一个完整的例子： 1234567891011121314151617181920212223242526class Counter &#123; var count = 0 var dataSource: CounterDataSource? func increment() &#123; if let amount = dataSource?.increment?(forCount: count) &#123; count += amount &#125; else if let amount = dataSource?.fixedIncrement &#123; count += amount &#125; &#125;&#125;class ThreeSource: NSObject, CounterDataSource &#123; let fixedIncrement = 3&#125;var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123; counter.increment() print(counter.count)&#125;// 3// 6// 9// 12 这里方法后的可选是指这个方法是否存在，而之前出现过的方法后的可选是指，方法是否有返回值。 注意 fixedIncrement 在协议中是 var，但是实现是可以设置为 let 协议扩展协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。 例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法： 12345extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125; 通过协议扩展，所有采纳协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改。 这个协议拓展的本意是为了给协议提供默认实现，这样就可以不必在每个的类中都实现该协议的方法。但是，这样一搞就有点像多继承了。多继承的问题是如果继承了多个实现相同方法的协议，那么调用的时候该如何取舍？ Swift 中的类如果拥有两个有相同方法名的协议拓展，那么编译都不能通过，除非在类中自己实现了。 提供默认实现可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。 如上面的 PrettyTextRepresentable 协议的方法： 12345extension PrettyTextRepresentable &#123; var prettyTextualDescription: String &#123; return textualDescription &#125;&#125; 泛型泛型函数泛型的使用实例： 1234567891011121314func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoValues(&amp;someInt, &amp;anotherInt)// someInt is now 107, and anotherInt is now 3var someString = "hello"var anotherString = "world"swapTwoValues(&amp;someString, &amp;anotherString) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。可提供多个类型参数，将它们都写在尖括号中，用逗号分开。 这里范型名为 T，可以替换为任意字符 泛型类型除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。 1234567891011struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125;var stackOfStrings = Stack&lt;String&gt;() 拓展一个泛型类型当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 12345extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; 类型约束上面的泛型是所有类型都可用的，但是实际使用中，可能需要排除掉一些类型。比如 Dictionary 类型对字典的键做了限制，只有可以 hash 的类型才能成为键。 当你创建自定义泛型类型时，你可以定义你自己的类型约束 类型约束语法可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。 123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这里是泛型函数的函数体部分&#125; 上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。 关联类型为协议提供泛型即使用关联类型。关联类型可以通过 associatedtype 关键字来指定。 关联类型实例下面定义了一个关联类型 ItemType： 123456protocol Container &#123; associatedtype ItemType mutating func append(item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125; Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。 使用： 123456789101112131415161718192021struct IntStack: Container &#123; // IntStack 的原始实现部分 var items = [Int]() mutating func push(item: Int) &#123; items.append(item) &#125; mutating func pop() -&gt; Int &#123; return items.removeLast() &#125; // Container 协议的实现部分 typealias ItemType = Int mutating func append(_ item: Int) &#123; self.push(item: item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Int &#123; return items[i] &#125;&#125; 这里显式地指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。 typealias 总算有用了 不过由于类型推断，可以不用声明 ItemType 为 Int： 1234567891011121314151617181920struct Stack&lt;Element&gt;: Container &#123; // Stack&lt;Element&gt; 的原始实现部分 var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // Container 协议的实现部分 mutating func append(item: Element) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125; 这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（五）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%955%2F</url>
    <content type="text"><![CDATA[接着上一篇 析构过程析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示，类似于构造器要用init来标示。 析构过程原理Swift 通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。 在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示： 123deinit &#123; // 执行析构过程&#125; 析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。 因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。 其实就是一个在对象销毁前的回调，你可以在对象销毁前做任何你想做的事。 自动引用计数 引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。 解决实例间的循环强引用Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。 对于生命周期中会变为nil的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。 弱引用在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。 弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。 弱引用只能修饰类对象，不能修饰引用传递对象，即类对象，不能修饰值传递引用，即不能修饰基本类型，结构体，数组等。(涉及到引用了，肯定是要修饰引用传递对象啊) 因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。 弱引用的声明在变量前加上 weak 关键字： 123456class Apartment &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; weak var tenant: Person? deinit &#123; print("Apartment \(unit) is being deinitialized") &#125;&#125; 无主引用和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。 由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。 如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。(A 中有一个属性 B为无主引用，那么就要确保 B 没有被回收) 无主应用也只能修饰引用传递对象 无主引用以及隐式解析可选属性上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。 两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。 然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。 非可选 A 和 非可选 B 相互引用，但是由于“两段式构造过程”，比如要初始化 A，那么必须要先初始化B，但是B要初始化完成必须先初始化A，这就像死锁一样。所以为了打破这种循环，必须用隐式可选属性，既能表示不能为空，又能不影响初始化的进行。 123456789101112131415161718192021class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125;&#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125;&#125;var country = Country(name: "Canada", capitalName: "Ottawa")print("\(country.name)'s capital city is called \(country.capitalCity.name)")// 打印 “Canada's capital city is called Ottawa” 上面如果使用无主引用，无主引用是常量类型，并且对象必须要在其内部常量属性都有了初值之后才能使用 self 属性，所以 country:self 就会产生异常。必须要使用变量类型来替代原来的无主引用。 无主引用和隐式解析的区别在于，无主引用永远不能为 nil，而隐式解析值要保证用到的时候不为 nil 闭包引起的循环强引用这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用: 1234567891011121314151617181920212223class HTMLElement &#123; let name: String let text: String? lazy var asHTML: () -&gt; String = &#123; if let text = self.text &#123; return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;" &#125; else &#123; return "&lt;\(self.name) /&gt;" &#125; &#125; init(name: String, text: String? = nil) &#123; self.name = name self.text = text &#125; deinit &#123; print("\(name) is being deinitialized") &#125;&#125; asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。如果没有 lazy 修饰，那么是不能编译通过的。 解决闭包引起的循环强引用获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。 如果闭包有参数列表和返回类型，把捕获列表放在它们前面： 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index, stringToProcess) in // 这里是闭包的函数体&#125; 上面闭包的参数类型由于可以通过类型推断得到，因此都省略了。如果闭包没有指明参数列表，那么可以把捕获列表和关键字in放在闭包最开始的地方： 1234lazy var someClosure: () -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] in // closure body goes here&#125; 可选链式调用可选链式调用（Optional Chaining）是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。 使用可选链式调用代替强制展开通过在想调用的属性、方法、或下标的可选值（optional value）后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。 可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。 下面的例子很清楚活命可选链式调用： 12345678910111213141516171819class Person &#123; var residence: Residence?&#125;class Residence &#123; var numberOfRooms = 1&#125;let john = Person()let roomCount = john.residence!.numberOfRooms// 这会引发运行时错误if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125;// Prints "John's residence has 1 room(s)." 不只是属性，方法和下标也是可选链式调用的。 连接多层可选链式调用有时候会嵌套使用，如： 123456if let johnsStreet = john.residence?.address?.street &#123; print("John's street name is \(johnsStreet).")&#125; else &#123; print("Unable to retrieve the address.")&#125;// 打印 “Unable to retrieve the address.” 返回的仍然是 String? 而不是 String?? 在方法的可选返回值上进行可选链式调用如果要在方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可： 123456789if let beginsWithThe = john.residence?.address?.buildingIdentifier()?.hasPrefix("The") &#123; if beginsWithThe &#123; print("John's building identifier begins with \"The\".") &#125; else &#123; print("John's building identifier does not begin with \"The\".") &#125;&#125;// 打印 “John's building identifier begins with "The".” 错误处理表示并抛出错误在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。 1234567enum VendingMachineError: Error &#123; case invalidSelection case insufficientFunds(coinsNeeded: Int) case outOfStock&#125;throw VendingMachineError.insufficientFunds(coinsNeeded: 5) 这里枚举中的 coninsNeeded 就是前面讲枚举的时候的关联值，只是设置了参数名，比如下面枚举的元组情况可能会用到 类型转换类型检查用类型检查操作符（is）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。 1234567for item in library &#123; if item is Movie &#123; movieCount += 1 &#125; else if item is Song &#123; songCount += 1 &#125;&#125; 这里只截取了代码的部分。演示了 is 的用法。 类型转换用类型转化你操作符 as 来转换类型。 as 应用条件有2种情况： 和 as 右边类型一致 是右边类型的子类(向上转型) 向下转型某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。 因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式（conditional form）as? 返回一个你试图向下转成的类型的可选值（optional value）。强制形式 as! 把试图向下转型和强制解包（force-unwraps）转换结果结合为一个操作。 在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转： 12345678910111213for item in library &#123; if let movie = item as? Movie &#123; print("Movie: '\(movie.name)', dir. \(movie.director)") &#125; else if let song = item as? Song &#123; print("Song: '\(song.name)', by \(song.artist)") &#125;&#125;// Movie: 'Casablanca', dir. Michael Curtiz// Song: 'Blue Suede Shoes', by Elvis Presley// Movie: 'Citizen Kane', dir. Orson Welles// Song: 'The One And Only', by Chesney Hawkes// Song: 'Never Gonna Give You Up', by Rick Astley Any 和 AnyObject 的类型转换Swift 为不确定类型提供了两种特殊的类型别名： AnyObject 可以表示任何类类型的实例。 Any 可以表示任何类型，包括函数类型。 例如下面使用 Any 的例子： 12345678910var things = [Any]() things.append(0)things.append(0.0)things.append(42)things.append(3.14159)things.append("hello")things.append((3.0, 5.0))things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))things.append(&#123; (name: String) -&gt; String in "Hello, \(name)" &#125;) 现在结合 is 和 as 使用： 123456789101112131415161718192021222324252627282930313233for thing in things &#123; switch thing &#123; case 0 as Int: print("zero as an Int") case 0 as Double: print("zero as a Double") case let someInt as Int: print("an integer value of \(someInt)") case let someDouble as Double where someDouble &gt; 0: print("a positive double value of \(someDouble)") case is Double: print("some other double value that I don't want to print") case let someString as String: print("a string value of \"\(someString)\"") case let (x, y) as (Double, Double): print("an (x, y) point at \(x), \(y)") case let movie as Movie: print("a movie called \(movie.name), dir. \(movie.director)") case let stringConverter as (String) -&gt; String: print(stringConverter("Michael")) default: print("something else") &#125;&#125; // zero as an Int// zero as a Double// an integer value of 42// a positive double value of 3.14159// a string value of "hello"// an (x, y) point at 3.0, 5.0// a movie called Ghostbusters, dir. Ivan Reitman// Hello, Michael case 还能用 is 类型 判断是某一类类型；let xx as 类型 判断是某一种类型。 厉害了 嵌套类型枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。 要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。 嵌套类型实践12345678910111213141516171819202122232425262728293031323334353637383940struct BlackjackCard &#123; // 嵌套的 Suit 枚举 enum Suit: Character &#123; case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣" &#125; // 嵌套的 Rank 枚举 enum Rank: Int &#123; case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King, Ace struct Values &#123; let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .Ace: return Values(first: 1, second: 11) case .Jack, .Queen, .King: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard 的属性和方法 let rank: Rank, suit: Suit var description: String &#123; var output = "suit is \(suit.rawValue)," output += " value is \(rank.values.first)" if let second = rank.values.second &#123; output += " or \(second)" &#125; return output &#125;&#125;let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)print("theAceOfSpades: \(theAceOfSpades.description)")// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11” 注意看这个例子的应用部分。尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。 如果没有类型推断，需要将代码补全的话，需要写成：BlackjackCard.Rank.Ace 的形式。 引用嵌套类型在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀。就和上面说的一样： 12let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue// 红心符号为 “♡”]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（四）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%954%2F</url>
    <content type="text"><![CDATA[接着上一篇 继承只有类可以被继承，结构体和枚举不能被继承 定义一个基类不继承于其它类的类，称之为基类。 123456789class Vehicle &#123; var currentSpeed = 0.0 var description: String &#123; return "traveling at \(currentSpeed) miles per hour" &#125; func makeNoise() &#123; // 什么也不做-因为车辆不一定会有噪音 &#125;&#125; 子类生成为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔： 123class SomeClass: SomeSuperclass &#123; // 这里是子类的定义&#125; 继承上面的基类： 123class Bicycle: Vehicle &#123; var hasBasket = false&#125; 除了继承了 Vehicle 的属性外，还定义了一个 hasBasket 属性。 基本和其他语言的继承无异。 重写如果要重写某个特性，你需要在重写定义的前面加上override关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。 override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。 访问超类的方法属性和下标使用 super 关键字。 重写属性你可以重写继承来的实例属性或类型属性，在属性前加上 override 关键字，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。 重写属性的 Getters 和 Setters你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。 你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。 如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。 重写属性观察器你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。 123456789101112class AutomaticCar: Car &#123; override var currentSpeed: Double &#123; didSet &#123; gear = Int(currentSpeed / 10.0) + 1 &#125; &#125;&#125;let automatic = AutomaticCar()automatic.currentSpeed = 35.0print("AutomaticCar: \(automatic.description)")// AutomaticCar: traveling at 35.0 miles per hour in gear 4 重写的是属性的方法，重写不能改变非计算型属性原有的值。所以，比如上面的 currentSpeed 不能赋值，因为父类 Car 里已经有这个属性的初值了。 防止重写可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。 你可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。 构造过程构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。 通过定义构造器（Initializers）来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值。 类的实例也可以通过定义析构器（deinitializer）在实例释放之前执行特定的清除工作。 存储属性初始赋值类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。 注意，当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者（property observers）。 构造器构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字init命名： 123init() &#123; // 在此处执行构造过程&#125; 例子： 123456789struct Fahrenheit &#123; var temperature: Double init() &#123; temperature = 32.0 &#125;&#125;var f = Fahrenheit()print("The default temperature is \(f.temperature)° Fahrenheit")// 输出 "The default temperature is 32.0° Fahrenheit” 默认属性值你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值： 123struct Fahrenheit &#123; var temperature = 32.0&#125; 自定义构造过程你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。 构造参数自定义构造过程时，可以在定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。 12345678910111213struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius 是 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius 是 0.0” 第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit；第二个构造器也拥有一个构造参数，其外部名字为fromKelvin，内部名字为kelvin。这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性temperatureInCelsius中。 和函数和方法的定义类似 可选属性类型如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型（optional type）。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。 例子： 1234567891011121314class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")cheeseQuestion.ask()// Prints "Do you like cheese?"cheeseQuestion.response = "Yes, I do like cheese." 构造过程中常量属性的赋值你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。 对于类的实例来说，它的常量属性只能在定义它的类的构造过程中赋值；不能在子类的构造过程中赋值。道理很浅显，由于常量不论是否可选都要被赋值，不能通过类型推断，所以父类初始化的方法中必须要对常量赋值。又因为常量在赋值之后就不能更改了，所以父类中赋值之后，就不能再在子类中赋值了。 可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值： 1234567891011121314class SurveyQuestion &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let beetsQuestion = SurveyQuestion(text: "How about beets?")beetsQuestion.ask()// 输出 "How about beets?"beetsQuestion.response = "I also like beets. (But not with cheese.)" 默认构造器如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。 下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state： 123456class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 由于ShoppingListItem类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为name属性设置默认值，但由于name是可选字符串类型，它将默认设置为nil）。上面例子中使用默认构造器创造了一个ShoppingListItem类的实例（使用ShoppingListItem()形式的构造器语法），并将其赋值给变量item。 默认构造器要求所有属性都有默认值。所以上面例子里的 name 必须是可选的。如果是非可选的就会产生异常，你需要添加一个 init 方法来初始化这个 非可选name 结构体的逐一成员构造器除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。 逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。 1234struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) (类就不存在这种逐一成员构造器) 值类型的构造器代理构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。 构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。 如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用自动生成的构造器。 举例： 123456789101112131415161718192021struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 就是类中的构造器调用类中的另一个构造器 类的继承和构造过程类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。（基本上所有后面的所有的限制都是围绕这一规定） Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器指定构造器（designated initializers）是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性(就是需要确保所有非可选属性都有值)，并根据父类链往上调用父类的构造器来实现父类的初始化。 每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。 指定构造器只能调用父类的构造器，不能调用自己的其他构造器 便利构造器便利构造器（convenience initializers）是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。 你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。 便利构造器只能调用自己的其他构造器，不能调用父类的构造器 指定构造器和便利构造器的语法类的指定构造器的写法跟值类型简单构造器一样： 123init(parameters) &#123; statements&#125; 便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开： 123convenience init(parameters) &#123; statements&#125; 类的构造器代理规则 指定构造器必须总是向上代理 便利构造器必须总是横向代理 两段式构造过程Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。 上面的话的大致意思是：先把子类特有的属性初始化完成后，再调用父类的构造函数初始化父类的属性。初始化父类的属性完后，再修改父类的属性。 Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成： 安全检查1指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。 如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。 就是在 super 之前，先要让子类的所有属性都有默认值 安全检查2指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。 就是第一步之后先super，然后修改其属性 安全检查3便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。 便利构造器先调用其他构造器，再修改其属性 安全检查4构造器在第一阶段(super 完成后)构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。 只有 super 完成后，才能使用实例的属性方法 类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。 总结到这里我们就可以将指定构造器和便利构造器的职责划分一下了。 指定构造器实现的就是阶段一，先设置自身的非可选属性，然后调用 super 便利构造器实现的就是阶段二，在指定构造器构造完成后进行一些属性值的修改 一般都是外部调用便利构造器，再由便利构造器调用指定构造器 构造器的继承和重写跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。 关于指定构造器，当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上override修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。你也可以将指定构造器重写为便利构造器。 相反，关于便利构造器，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写，而是直接覆盖。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀，即虽然类型相同，但不是同一个方法。 构造器的自动继承子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器： 如果子类没有定义任何指定构造器，它将自动继承所有父类的构造器（包括指定构造器和便利构造器）。 如果子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。 即使你在子类中添加了很多的便利构造器，这两条规则仍然适用。对于规则 2，子类可以将父类的指定构造器实现为便利构造。 关于构造器继承与重写的总结前面基本上以及都提及了什么时候能够能什么时候不能继承与重写，以及为什么。再强调一下之后的所有原则都是围绕：如果哪里用到了未赋值的属性，就会产生异常 一个指定构造器不能调用同一个类内的其他指定构造器 这个原因很简单。如果指定构造器能够调用同类的其他指定构造器，那还要便利构造器干嘛？ 子类的便利构造器不能调用父类的构造器 因为便利构造器的目的就是为类中的指定构造器提供辅助的，即其作用于横向。如果其能够调用父类的构造器，那么便利构造器和指定构造器就没有区别了，也就是说没有必要提供便利构造器这个概念了。 子类的指定构造器不能调用父类的便利构造器 如果子类的指定构造器可以调用父类的便利构造器，那么考虑一种情况：子类的指定构造器重写了父类的指定构造器，并且父类的便利构造器会调用该指定构造器。这种情况下，由于重写，就会造成循环调用： 为什么会有两段式构造过程 和其他的语言不同：一般的语言不是第一句话都是调用 super 么，然后再自己修改值。Swift 则必须先初始化子类的属性后，才能进行后面的 super。为什么一定要这样？因为其他语言可以先将子类的属性默认设为0或者 nil，而 Swift 不行，不会为非可选属性设置初值。 安全检查2，3，4的目的就知道了，这三种情况都有可能用到未赋值的非可选属性（让某个属性等于某个未赋值的属性；在某个方法中使用了未赋值的属性） 安全检查1中，为什么一定要让赋初值在 super 前呢？因为父类的调用也有可能使用到未赋初值的子类属性。比如子类重写了某个父类的方法，然后父类的初始化方法中正好调用了这个方法。具体可见详见 子类默认情况下不会继承父类的构造器 继承的构造器不会为子类的非可选属性设置初始值，如果哪里使用到了这个属性，就将产生异常。所以子类一般情况下不会继承父类的构造器。 子类中有与父类同名的便利构造器，不算重写，不需要加上 override 重写的意义是可以在子类中通过 super 调用父类的同名方法，如果不需要调用父类的该方法，那么不如直接覆盖。这里的便利构造器就是覆盖，而不是重写，因为不存在子类调用父类便利构造器的情况。 父类中的指定构造器，子类可以将其重写为指定构造器，也可以将其重写为便利构造器 和上面不同的是，父类的指定构造器是会被调用的，所以无论你在子类中将其实现为指定构造器还是便利构造器，都是重写，需要加上 override 为什么子类没有实现指定构造器，或者重写了所有指定构造器，就能继承父类所有的构造器？ 前面说过，默认不能继承是因为可能存在子类调用父类继承过来的方法后，访问未赋初始值的属性，产生异常。这里能够继承是因为： 没有实现任意指定构造器，说明子类没有任何没有初始值的属性 实现了所有指定构造器，说明子类将所有没有初始值的属性都已经赋了初值 可失败构造器如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。 为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在init关键字后面添加问号(init?)。 可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。 可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。 严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。 下例中，定义了一个名为Animal的结构体，检查传入参数是否是空字符串。如果是空字符串，那么构造失败。否则，species属性被赋值，构造成功。 其实就是允许在某些自己设定的情况下，构造返回 nil 1234567struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125; 你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功： 123456789101112131415let someCreature = Animal(species: "Giraffe")// someCreature 的类型是 Animal? 而不是 Animalif let giraffe = someCreature &#123; print("An animal was initialized with a species of \(giraffe.species)")&#125;// 打印 "An animal was initialized with a species of Giraffe"let anonymousCreature = Animal(species: "")// anonymousCreature 的类型是 Animal?, 而不是 Animalif anonymousCreature == nil &#123; print("The anonymous creature could not be initialized")&#125;// 打印 "The anonymous creature could not be initialized" 枚举类型的可失败构造器可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。 123456789101112131415enum TemperatureUnit &#123; case Kelvin, Celsius, Fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case "K": self = .Kelvin case "C": self = .Celsius case "F": self = .Fahrenheit default: return nil &#125; &#125;&#125; 带原始值的枚举类型的可失败构造器带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。 因此上面的TemperatureUnit的例子可以重写为： 123456789101112131415enum TemperatureUnit: Character &#123; case Kelvin = "K", Celsius = "C", Fahrenheit = "F"&#125;let fahrenheitUnit = TemperatureUnit(rawValue: "F")if fahrenheitUnit != nil &#123; print("This is a defined temperature unit, so initialization succeeded.")&#125;// 打印 "This is a defined temperature unit, so initialization succeeded."let unknownUnit = TemperatureUnit(rawValue: "X")if unknownUnit == nil &#123; print("This is not a defined temperature unit, so initialization failed.")&#125;// 打印 "This is not a defined temperature unit, so initialization failed." 构造失败的传递类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。 无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。 可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。 重写一个可失败构造器父类的可失败构造器可被子类的可失败构造器重写，也可被子类的非可失败构造器重写。但是反过来，父类的非可失败构造器不能被子类的可失败构造器重写。 为什么会有这样的规定？试想一下你正在子类中用一个可失败构造器重写父类非可失败构造器，编译器是肯定会报错的，那么你应该怎么做？你需要将子类中可失败的情况移到父类中去。这就体现了苹果的设计意图了。诸如字符串为空等造成构造失败的情况是共性的，苹果希望你将这些情况放在父类中判断。至于子类中允许这样的发生的话，就再用非可失败构造器重写。 一个重写可失败构造器的例子： 12345678910class Document &#123; var name: String? // 该构造器创建了一个 name 属性的值为 nil 的 document 实例 init() &#123;&#125; // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例 init?(name: String) &#123; self.name = name if name.isEmpty &#123; return nil &#125; &#125;&#125; 可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是&quot;[Untitled]&quot;，它在构造过程中使用了父类的可失败构造器init?(name:)： 12345class UntitledDocument: Document &#123; override init() &#123; super.init(name: "[Untitled]")! &#125;&#125; 在这个例子中，如果在调用父类的可失败构造器init?(name:)时传入的是空字符串，那么强制解包操作会引发运行时错误。 可失败构造器 init!通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。 你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。 这里 self.init!() 其实等价于 self.init?()!。这样写更方便一些。 这和变量的强制解包有一定的区别。变量的强制解包是变量在其他地方以可选的形式存在，可以为nil，而某些地方需要表现为非可选，不能为nil。而这里你是创建的时候就进行了隐式解包，其他地方根本不会用到其为 nil 的形式。如果你想创建一个非空的实例，为什么不直接用非可选构造器？ 因为这里就是想要在某些构造失败的情况下触发断言。等同于非可选的 init 方法中，在某些情况下手动抛出异常。 必要构造器在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器： 12345class SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; 在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符： 12345class SomeSubclass: SomeClass &#123; required init() &#123; // 构造器的实现代码 &#125;&#125; required 表示所有子类都必须实现这个构造器，而不是说，只要一个子类实现就可以了。 通过闭包或函数设置属性的默认值如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。 这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。 1234567class SomeClass &#123; let someProperty: SomeType = &#123; // 在这个闭包中给 someProperty 创建一个默认值 // someValue 必须和 SomeType 类型相同 return someValue &#125;()&#125; 注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。 如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。 如果一定想要用到self等怎么办，将该属性设置为 lazy。使用懒加载就能保证该属性一定在对象初始化完成后再初始化了 一定注意区分闭包和计算型属性的不同，闭包是个赋值操作，且最后有一个执行闭包的 ()。计算型属性则是直接将计算方式写在属性后面 例如下面初始化一个西洋棋盘（黑白相间那种）： 1234567891011121314151617181920212223struct Checkerboard &#123; let boardColors: [Bool] = &#123; var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 &#123; for j in 1...8 &#123; temporaryBoard.append(isBlack) isBlack = !isBlack &#125; isBlack = !isBlack &#125; return temporaryBoard &#125;() func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool &#123; return boardColors[(row * 8) + column] &#125;&#125;let board = Checkerboard()print(board.squareIsBlackAtRow(0, column: 1))// 打印 "true"print(board.squareIsBlackAtRow(7, column: 7))// 打印 "false"]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（三）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%953%2F</url>
    <content type="text"><![CDATA[接着上一篇 枚举枚举语法使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内： 123enum SomeEnumeration &#123; // 枚举定义放在这里&#125; 例子: 123456enum CompassPoint &#123; case North case South case East case West&#125; 注意每一个 case 来定义一个新的枚举成员。如果出现在同一行上，需要用逗号隔开： 123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 和 oc 不同，这里的枚举值不会被完全的隐式赋值为 0，1，2，3（但是如果你给定了其中一个的值，其他的值可以被隐式地推断出来）。这些枚举成员本身就是完备的值，比如最上面的这些值的类型是已经明确定义好的 CompassPoint 类型。 使用方式： 1var directionToHead = CompassPoint.West directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值： 1directionToHead = .East 使用 switch 枚举可以使用 switch 匹配枚举值： 1234567891011121314directionToHead = .Southswitch directionToHead &#123; case .North: print("Lots of planets have a north") case .South: print("Watch out for penguins") case .East: print("Where the sun rises") case .West: print("Where the skies are blue") default: print("Not a safe place for humans")&#125;// 输出 "Watch out for penguins” 关联值有些时候枚举值会需要存储一些关联值以方便使用，比如： 1234enum Barcode &#123; case UPCA(Int, Int, Int, Int) case QRCode(String)&#125; 表示 UPCA 具有 (Int，Int，Int，Int) 的关联值，QRCode 具有 String 的关联值。使用： 12var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)productBarcode = .QRCode("ABCDEFGHIJKLMNOP") 类型推断为 Barcode，关联值只是附加信息，便于存储一些必要信息。比如在使用 switch 语句时，可以将关联值提取出来，就可以在执行语句中使用。可以在switch的 case 分支代码中提取每个关联值作为一个常量（用let前缀）或者作为一个变量（用var前缀）来使用： 1234567switch productBarcode &#123;case .UPCA(let numberSystem, let manufacturer, let product, let check): print("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")case .QRCode(let productCode): print("QR code: \(productCode).")&#125;// 输出 "QR code: ABCDEFGHIJKLMNOP." 为了简洁，可以将let或者var 提取出来： 1234567switch productBarcode &#123;case let .UPCA(numberSystem, manufacturer, product, check): print("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")case let .QRCode(productCode): print("QR code: \(productCode).")&#125;// 输出 "QR code: ABCDEFGHIJKLMNOP." 原始值原始值的定义和 oc 中枚举的效果很像。可以为每个枚举成员定义一个默认值。这些默认值的类型必须相同： 12345enum ASCIIControlCharacter: Character &#123; case Tab = "\t" case LineFeed = "\n" case CarriageReturn = "\r"&#125; 其中，将枚举类型定义为字符串类型。原始值还可以是字符，任意整形或浮点型值。 注意，原始值和关联值是不同的。原始值是定义枚举时被预先填充的值。对于一个特定的枚举成员，原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。 关联值和原始值不能同时混合使用 原始值的隐式赋值使用整数或者字符串作为原始值枚举时，不需要显式赋值，Swift 会自动赋值： 123enum Planet: Int &#123; case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 在上面的例子中，Plant.Mercury的显式原始值为1，Planet.Venus的隐式原始值为2。 当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称： 123enum CompassPoint: String &#123; case North, South, East, West&#125; 上面例子中，CompassPoint.South拥有隐式原始值South，即就是其本生。可以使用枚举成员的rawValue属性可以访问该枚举成员的原始值： 12345let earthsOrder = Planet.Earth.rawValue// earthsOrder 值为 3let sunsetDirection = CompassPoint.West.rawValue// sunsetDirection 值为 "West" 这里拿出了 rawValue，那么 earthsOrder 和sunsetDirection 就是明确的值了，而不是枚举类型。 使用原始值初始化枚举实例如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。 比如利用原始值7创建了枚举成员Uranus： 12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet 类型为 Planet? 值为 Planet.Uranus 原始值构造器总是返回一个可选的枚举成员，因为可能没有对应的枚举类型。在上面的例子中，possiblePlanet是Planet?类型。 类和结构体定义语法使用 class 和 struct 分别表示类和结构体。示例如下： 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 这里面可以注意一点。就是对于变量进行了初始化。这样有什么好处呢？可以使 swift 进行类型推断出当前变量的类型。在 swift 中，每个变量的类型都必须是确定的。 类和结构体实例创建类和结构体实例的语法相似： 12let someResolution = Resolution()let someVideoMode = VideoMode() 通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。更多构造过程在后面将会更详细的讨论。 属性访问通过 . 语法，可以访问实例的属性。与 oc 不同的是，Swift 允许直接设置结构体属性的子属性。反正通过 . 什么都能拿到就是了。 结构体类型的成员逐一构造器所有结构体（特指结构体）都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中： 1let vga = Resolution(width:640, height: 480) 与结构体不同，类实例没有默认的成员逐一构造器。详细见后面。 结构体和枚举是值类型什么是值类型？就是我们所说的值传递和引用传递中的值传递。指在被赋给一个变量常量或者传递给一个函数的时候，值会被拷贝。 所有的基本类型都是值拷贝这和以前毫无异议。但是在 Swift 中，字符串、数组和字典也是值拷贝，这和 oc 中很不相同。这意味着数组和字典中的所有元素都会被拷贝一份。其实是因为它们底层都是以结构体的形式实现的。 12let hd = Resolution(width: 1920, height: 1080)var cinema = hd 例如上面的例子，cinema 和 hd 相同，但其实在内存中是两个不同的对象。修改其中一个的值不会改变另一个实例相应属性的值。枚举同样。 这里只是数组对象会被创建一个新的，但是数组里的对象都是引用类型。 类是引用类型这点没啥不同的。就是不同常量或者变量指向内存上的相同地址。 恒等运算符Swift 中内建了两个恒等运算符： 等价于（===） 不等价于 （!==） 注意这和“等于” == 有什么区别呢？ “等价于”表示两个类类型(注意只能用在类类型中)的常量或者变量引用同一个类实例。 “等于”表示两个实例的值“相等”或“相同”。 也就是说 === 为 true ，那么两个类实例必然指向同一块内存地址。== 为 true 则只要类内属性相同即可。（oc 中的 == 就是这里的 ===，比较的是指针地址。 一般对象相等都是比较地址，即 ===。如果要使用 == 必须要实现 Equatable 协议。在 Equatable 里声明了这个操作符的接口方法: 123protocol Equatable &#123; func ==(lhs: Self, rhs: Self) -&gt; Bool&#125; 实现它： 123456789101112131415161718class MyClass: Equatable &#123; let myProperty: String init(s: String) &#123; myProperty = s &#125;&#125;func ==(lhs: MyClass, rhs: MyClass) -&gt; Bool &#123; return lhs.myProperty == rhs.myProperty&#125;let myClass1 = MyClass(s: "Hello")let myClass2 = MyClass(s: "Hello")myClass1 == myClass2 // truemyClass1 != myClass2 // falsemyClass1 === myClass2 // falsemyClass1 !== myClass2 // true 类和结构体的选择结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。 其实大部分数据构造都是用类，而非结构体。只有在数据结构非常简单的时候用结构体。 字符串、数组、字典的赋值和复制行为上面也说过了 Swift 中的 String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 不过不用担心值拷贝会影响新能，Swift 中有优化。 属性存储属性类和结构体中用 var 或者 let 修饰的就是存储属性： 12345678struct FixedLengthRange &#123; var firstValue: Int let length: Int&#125;var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// 该区间表示整数0，1，2rangeOfThreeItems.firstValue = 6// 该区间现在表示整数6，7，8 常量结构体的存储属性如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行： 1234let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// 该区间表示整数0，1，2，3rangeOfFourItems.firstValue = 6// 尽管 firstValue 是个变量属性，这里还是会报错 因为 rangeOfFourItems 被声明成了常量（用 let 关键字），即使 firstValue 是一个变量属性，也无法再修改它了。 这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。 因此数组字典等如果设置为 let ，那么数组字典中的项，值类型无法给内容，引用类型无法改地址 延迟存储属性指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标识。注意，延迟存储属性必须被声明为 var。 12345678910111213141516171819class DataImporter &#123; /* DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。 */ var fileName = "data.txt" // 这里会提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // 这里会提供数据管理功能&#125;let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data")// DataImporter 实例的 importer 属性还没有被创建 上面这个类中，DataImporter 是一个很费时的操作。所以设置为 lazy，只有在第一次访问到的时候才会被创建。 计算属性计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。其实就是每次点到这个属性的时候都会再计算一遍，适用于会根据其他值变化的属性，这样就不用每次用到的时候专门调用一个处理方法了。而是由系统直接调用了 getter 方法 123456789101112131415161718192021222324252627struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print("square.origin is now at (\(square.origin.x), \(square.origin.y))")// 输出 "square.origin is now at (10.0, 10.0)” 上面这个矩形的类，通过 origin 和 size 来计算出 center。其中 setter 方法的 newCenter 由于类型推断，默认为 Point 类型，就不用再写明类型了。 这里要强调一点。计算属性的 set 方法在 init 方法中是不会被调用的。如果你在初始化方法中给计算属性赋值了，那么这个计算属性直接就等于这个值，而不是再调用 setter 方法。 便捷 setter 声明由于 setter 函数必然要传入一个新值，所以 Swift 定义了一个默认名称 newValue。所以可以采取简略的形式： 123456789101112131415struct AlternativeRect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set &#123; origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) &#125; &#125;&#125; 只读计算属性只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。 如果是只读计算属性，那么连 get 关键字都可以扔掉了： 123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")// 输出 "the volume of fourByFiveByTwo is 40.0" 属性观察器可以监听属性值的变化（可以为除了延迟存储属性之外的其他存储属性添加属性观察器，因为可以通过 setter 方法直接监控）。 提供了两个属性观察器： willSet 新值被设置前调用 didSet 新值被设置后调用 willSet 接受新的属性值作为常量传入，可以自己指定这个参数的名称。如果不指定，默认名称为 newValue。 didSet 将旧的属性值传入，不接受自定义参数名，默认参数名为 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。 12345678910111213141516171819202122class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print("About to set totalSteps to \(newTotalSteps)") &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print("Added \(totalSteps - oldValue) steps") &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// About to set totalSteps to 200// Added 200 stepsstepCounter.totalSteps = 360// About to set totalSteps to 360// Added 160 stepsstepCounter.totalSteps = 896// About to set totalSteps to 896// Added 536 steps 如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。 这个来实现 kvo 全局变量和局部变量全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。 全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。 类型属性实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。类似于静态变量或常量。 跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。 类型属性语法在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。 使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法： 123456789101112131415161718192021struct SomeStructure &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 使用了 class，子类才能知道这个计算型属性是可以重写的，重写的时候要加上 override 表示： 12345class OverridedClass: SomeClass &#123; override class var overrideableComputedTypeProperty: Int &#123; return 20 &#125;&#125; 其实计算型属性就相当于是个方法。 获取和设置类型属性的值类型属性通过类型本身访问： 123456789print(SomeStructure.storedTypeProperty)// 输出 "Some value."SomeStructure.storedTypeProperty = "Another value."print(SomeStructure.storedTypeProperty)// 输出 "Another value.”print(SomeEnumeration.computedTypeProperty)// 输出 "6"print(SomeClass.computedTypeProperty)// 输出 "27" 方法类、结构体、枚举都可以定义实例、类型方法（这和 oc 中不同，oc 只能在类中定义方法）。 实例方法实例方法的语法和函数完全一致： 123456789101112class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func incrementBy(amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125; 和调用属性一样，用点语法调用实例方法： 12345678let counter = Counter()// the initial counter value is 0counter.increment()// the counter's value is now 1counter.increment(by: 5)// the counter's value is now 6counter.reset()// the counter's value is now 0 self 属性每个实例都有一个隐式的属性叫做 self。我们可以在实例方法中，通过 self 获取当前实例。 可以改写上面的 incremnet() 方法： 123func increment() &#123; self.count += 1&#125; 实际使用中，并不太需要 self，因为没必要。那么什么时候是必须的呢？ 1234567891011struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOf(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;let somePoint = Point(x: 4.0, y: 5.0)if somePoint.isToTheRightOf(x: 1.0) &#123; print("This point is to the right of the line where x == 1.0")&#125;// Prints "This point is to the right of the line where x == 1.0" 比如上面的代码，实例方法的入参名和实例属性相同，这个时候必须要用 self 以示区分。 实例方法中修改值类型结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改（也就是说一般创建好之后，结构体和枚举一般就不让修改了）。 如果你想在该实例方法中修改结构体和枚举的属性，那么需要在该方法前加一个可变标记，就可以改变它的值了。这个方法做的任何改变都会在方法执行结束时写回到原始结构中。 要使用可变方法，将关键字mutating 放到方法的func关键字之前就可以了： 1234567891011struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y: 1.0)somePoint.moveBy(x: 2.0, y: 3.0)print("The point is now at (\(somePoint.x), \(somePoint.y))")// Prints "The point is now at (3.0, 4.0)" 注意，不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性。这一点在属性一章中已经讲过了。 可变方法中给 self 赋值可变方法还能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写： 123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; self = Point(x: x + deltaX, y: y + deltaY) &#125;&#125; 枚举的可变方法可以把self设置为同一枚举类型中不同的成员： 123456789101112131415161718enum TriStateSwitch &#123; case off, low, high mutating func next() &#123; switch self &#123; case .off: self = .low case .low: self = .high case .high: self = .off &#125; &#125;&#125;var ovenLight = TriStateSwitch.lowovenLight.next()// ovenLight is now equal to .highovenLight.next()// ovenLight is now equal to .off 上面的例子中定义了一个三态开关的枚举。每次调用next()方法时，开关在不同的电源状态（Off，Low，High）之间循环切换。 类型方法实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法（Type Methods）。在方法的func关键字之前加上关键字static，来指定类型方法。类还可以用关键字class来允许子类重写父类的方法实现。 在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。 用点语法调用类型方法： 123456class SomeClass &#123; class func someTypeMethod() &#123; // type method implementation goes here &#125;&#125;SomeClass.someTypeMethod() 类型方法和其他语言的静态方法无二，不多说了。 下标 下标是访问集合列表中元素的跨界方式。可以通过下标索引，设置和获取值，而省略调用相应的存取方法。你可以定义有多个入参的下标满足自定义类型的需求。 下标语法下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标使用subscript关键字，指定一个或多个输入参数和返回类型。下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性： 123456789subscript(index: Int) -&gt; Int &#123; get &#123; // 返回一个适当的 Int 类型的值 &#125; set(newValue) &#123; // 执行适当的赋值操作 &#125;&#125; newValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。 如同只读计算型属性，可以省略只读下标的get关键字： 123subscript(index: Int) -&gt; Int &#123; // 返回一个适当的 Int 类型的值&#125; 下面看一个例子： 123456789struct TimesTable &#123; let multiplier: Int subscript(index: Int) -&gt; Int &#123; return multiplier * index &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print("six times three is \(threeTimesTable[6])")// 输出 "six times three is 18" 下标选项一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是下标的重载。 虽然接受单一入参的下标是最常见的，但也可以根据情况定义接受多个入参的下标。例如下例定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵。Matrix结构体的下标接受两个整型参数： 12345678910111213141516171819202122struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: 0.0) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125; 使用： 123var matrix = Matrix(rows: 2, columns: 2)matrix[0, 1] = 1.5matrix[1, 0] = 3.2 其中使用了断言，断言在下标越界时触发。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（二）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%952%2F</url>
    <content type="text"><![CDATA[接着上一篇 控制流For-In 循环for-In 循环之前也接触过了。可以使用区间操作符控制循环次数： 12345678for index in 1...5 &#123; print("\(index) times 5 is \(index * 5)")&#125;// 1 times 5 is 5// 2 times 5 is 10// 3 times 5 is 15// 4 times 5 is 20// 5 times 5 is 25 上面的例子中， index 是一个自动被设置的值，不需要自己声明。 如果不需要循环的次数，可以用下划线 _ 来替代 index。 12345678let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print("\(base) to the power of \(power) is \(answer)")// Prints "3 to the power of 10 is 59049" While 循环whilewhile 的形式： while condition{ statements } 就是 condition 的时候没有括号，其他没有特别的地方。 Repeat-While和其他语言的 do-while 类似，只不过换成了 repeat： repeat { statements } while condition 条件语句ifif 之前也用到过许多次了，和其他语言一样，注意判断条件不加括号。else 以及 else if 类似。 switchswitch 基本用法也差不多，直接看个例子： 12345678910let someCharacter: Character = "z"switch someCharacter &#123;case "a": print("The first letter of the alphabet")case "z": print("The last letter of the alphabet")default: print("Some other character")&#125;// Prints "The last letter of the alphabet" 一定要注意，swift 中的 switch 一定要有 default，一定要有 default，一定要有 default。 没有隐性掉入相比而言，没有 break，匹配一个后，直接返回。也可以一条里面匹配多个，用逗号隔开： 12345678910let someCharacter: Character = "z"switch someCharacter &#123;case "a","z": print("The first letter of the alphabet")case "z": print("The last letter of the alphabet")default: print("Some other character")&#125;// Prints "The first letter of the alphabet" 这个就相当于是或操作，下面还有与操作 这样就匹配到了第一个情况。 另外，每个 case 的主干都需要至少一句可执行语句，不能只有 case： 123456789let anotherCharacter: Character = "a"switch anotherCharacter &#123;case "a": // Invalid, the case has an empty bodycase "A": print("The letter A")default: print("Not the letter A")&#125;// This will report a compile-time error. 这就引导我们，没有执行方法的条件，就不要写 范围匹配在 case 中可以写一个范围： 12345678910111213141516171819let approximateCount = 62let countedThings = "moons orbiting Saturn"var naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = "no"case 1..&lt;5: naturalCount = "a few"case 5..&lt;12: naturalCount = "several"case 12..&lt;100: naturalCount = "dozens of"case 100..&lt;1000: naturalCount = "hundreds of"default: naturalCount = "many"&#125;print("There are \(naturalCount) \(countedThings).")// Prints "There are dozens of moons orbiting Saturn." 这种方式可以一定程度上替代一些判断数值的 if…else 元组匹配的时候还可以匹配元组，用下划线 _ 来匹配任意字符。当元组完全相等时，进入 case： 1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print("(0, 0) is at the origin")case (_, 0): print("(\(somePoint.0), 0) is on the x-axis")case (0, _): print("(0, \(somePoint.1)) is on the y-axis")case (-2...2, -2...2): print("(\(somePoint.0), \(somePoint.1)) is inside the box")default: print("(\(somePoint.0), \(somePoint.1)) is outside of the box")&#125;// Prints "(1, 1) is inside the box" 元组其实相当于 if…else… 中 &amp;&amp; 的操作 值绑定在前面的基础上，前面用 _ 代替任意值。如果在 case 中需要用到这个值怎么办呢？用 let 声明一个： 12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125;// Prints "on the x-axis with an x value of 2" 这里面 let(x,y) 和 (let x,let y) 是一样的。 这种值绑定的方式，可以把函数中要用到的变量先确定下来。 最后一定要有一个 let(x,y)，表示一个 default 操作，否则编译器会抛出异常。 whereswitch 的 case 能使用 where 子句来进一步判断条件。 12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("(\(x), \(y)) is just some arbitrary point")&#125;// Prints "(1, -1) is on the line x == -y" 三个 switch 的 case 声明了占位常量 x 和 y，临时占用 point 中元组值。这些常量作为 where 子句的一部分，用来创建动态的筛选。只有当 where 子句的条件结果为 true，Switch 的 case 则会匹配现有 point 的值。 这里的 where 不仅适用于元组，也可以是普通的 case let x where x==1:但是如果不用元组就没有 if…else… 简洁。 switch 能在一定程度上代替判断相等，以及判断在某一个范围的简单 if…else 操作 控制转移声明控制转移声明包括： continue break fallthrough return throw 除了 fallthrough 其他都差不多。这里要注意一下在 switch 中使用的 break。由于 switch 中的 case 里的执行语句不能为空，所以如果匹配到一种情况不需要操作，可以直接用 break: 1234567891011121314let numberSymbol: Character = "三" // Chinese symbol for the number 3var possibleIntegerValue: Int?switch numberSymbol &#123;case "1", "١", "一", "๑": possibleIntegerValue = 1case "2", "٢", "二", "๒": possibleIntegerValue = 2case "3", "٣", "三", "๓": possibleIntegerValue = 3case "4", "٤", "四", "๔": possibleIntegerValue = 4default: break&#125; FallthroughSwift 中在匹配成功后就不会掉入下一个 case 中。如果你就想要掉入的话，那么在执行语句后加上 fallthrough 即可： 1234567891011let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;print(description)// Prints "The number 5 is a prime number, and also an integer." 特别注意：调用 fallthrough 后，不检查 case 里的条件，会直接掉入下一个 case 。所以这里面直接执行了 default 的代码。 适用于那种满足了某个条件包含其他条件的操作，即要执行 A 那么 B 也要执行。最上面的永远是执行的最多的。 标签声明主要诱因是循环与 switch 的嵌套。有时候，你需要跳出外层循环或者 switch，但是由于嵌套，你不得不 break 或者 continue 好几次。那么，标签声明为循环和 switch 提供了一个标记，这样在循环或者 switch 内部，可以轻松的终止外部的循环或 switch。 1234567891011121314151617gameLoop: while square != finalSquare &#123; diceRoll += 1 if diceRoll == 7 &#123; diceRoll = 1 &#125; switch square + diceRoll &#123; case finalSquare: // diceRoll will move us to the final square, so the game is over break gameLoop case let newSquare where newSquare &gt; finalSquare: // diceRoll will move us beyond the final square, so roll again continue gameLoop default: // this is a valid move, so find out its effect square += diceRoll square += board[square] &#125;&#125;print("Game over!") 这样，通过 break gameLoop 和 continue gameLoop 就可以方便的跳出整个循环。 Guide 声明这个是 Swift 3 的特性，和 if 类似。后面跟着一个 else，先看个例子： 123456789101112131415161718192021func greet(person: [String: String]) &#123; guard let name = person["name"] else &#123; return &#125; print("Hello \(name)!") guard let location = person["location"] else &#123; print("I hope the weather is nice near you.") return &#125; print("I hope the weather is nice in \(location).")&#125; greet(person: ["name": "John"])// Prints "Hello John!"// Prints "I hope the weather is nice near you."greet(person: ["name": "Jane", "location": "Cupertino"])// Prints "Hello Jane!"// Prints "I hope the weather is nice in Cupertino." 当 guard 满足的时候代码直接往后走，如果条件不满足，那么执行 else 内的代码。其实逻辑和 if 是一样的。但是为什么要弄出这么个东西呢？为了让代码可读性更高。 有两点和 if 不同的注意点： guard let 中必须要有 return，而 if let 则不需要 return guard let 变量的作用域是外部作用域，if let 的作用域是内部作用域。也就是说，guard 方式 let 得到的值外部还能用到，if 方式 let 到的值外部已经无法使用。 上面说到为什么作用域是外部的，这就要明白 guard 的目的。guard 是用来代替在一个函数中 if xxx 为空 return 的情况的。也就是一般都是用来做非空判断的。所以非空的情况下拿到 let 的值，在下面使用。 检查 API 是否可用Swift 3 中提供了检查 API 是否可用的方法： 12345if #available(iOS 10, macOS 10.12, *) &#123; // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS&#125; else &#123; // Fall back to earlier iOS and macOS APIs&#125; 表示在 iOS 10，macOS 10.12，以及任意其他平台可用。* 表示任意其他平台。 函数定义一个函数直接上例子： 1234func greet(person: String) -&gt; String &#123; let greeting = "Hello, " + person + "!" return greeting&#125; 这个函数名为 greet(person:)。这个函数输入一个 String 类型叫做 person 的值，输出一段字符串。函数以 func 为前缀，-&gt; 指定的返回类型。 可以调用 print(_:separator:terminator:) 方法去打印上面函数的返回值： 1234print(greet(person: "Anna"))// Prints "Hello, Anna!"print(greet(person: "Brian"))// Prints "Hello, Brian!" 这里的 print(_:separator:terminator:) 方法第一个入参没有名字，后面两个入参由于有默认值，因此可选。具体将在下面说到。 函数的参数和返回值没有参数示例： 12345func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125;print(sayHelloWorld())// Prints "hello, world" 多个参数函数可以有多个输入参数，把他们写到函数的括号内，并用逗号加以分隔： 123456789func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return greetAgain(person: person) &#125; else &#123; return greet(person: person) &#125;&#125;print(greet(person: "Tim", alreadyGreeted: true))// Prints "Hello again, Tim!" 无返回值没有 return 没有返回类型 -&gt;： 12345func greet(person: String) &#123; print("Hello, \(person)!")&#125;greet(person: "Dave")// Prints "Hello, Dave!" 严格来说，其实无返回类型的函数还是返回了一个值，即使没有返回值定义。函数没有定义返回类型但返 回了一个 void 返回类型的特殊值。它是一个空的元组，可以写为return () 多个返回值可以将返回类型设置为元组，来返回多个值： 123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 注意 -&gt; 后面的返回类型书写方式：(min: Int, max: Int) 。 由于在定义返回类型的时候，元组中的元素都已经被命名好了。所以我们通过 . 操作符就能拿到对应的元素： 123let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)")// Prints "min is -6 and max is 109" 可选的元组返回类型如果返回的元组可能没有值，那么可以使用可选的元组作为返回类型，来表示整个元组可以为 nil。在元组之后加上 ? 来表示可选类型，例如 (Int,Int)? （注意不要写成 (Int?,Int?) 这个表示元组中的元素是可选的）。 如果是可选元组，那么一定要先做非空判断。否则当你想要取出元组中元素后，就会触发运行时错误。你可以通过可选绑定来判断是否为空： 123if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125; 函数的 argument label 和 parameter name这两个词我不知道怎么翻译。每个函数都有 argument label 和 parameter name。argument label 用在调用函数的时候；parameter name 用在方法体中的参数使用。默认情况下两者是相等的。在一个方法中，所有的 parameter name 都应该是独一无二的，因为在方法体中会用到；argument label 则不必都不同。 （如果看不懂啥意思，可以看下面的几个例子就明白了）。 12345func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 上面是一个 argument laebl 和 parameter name 默认相等的例子。 明确的 argument labels现在考虑 argument labels 和 parameter name 不同的情况。可以将 argumentLabel 写在 parameterName 前面： 1234func someFunction(argumentLabel parameterName: Int) &#123; // In the function body, parameterName refers to the argument value // for that parameter.&#125; 来看一个具体实例： 12345func greet(person: String, from hometown: String) -&gt; String &#123; return "Hello \(person)! Glad you could visit from \(hometown)."&#125;print(greet(person: "Bill", from: "Cupertino"))// Prints "Hello Bill! Glad you could visit from Cupertino." 其中 from 是 argument labels，hometown 是 parameter name。注意在方法里用 hometown，在调用的时候用 from。 省略的 argument labels如果不想要 argument labels，可以用 _ 代替，调用的时候就什么都不用写了： 12345func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(1, secondParameterName: 2) 注意，参数顺序还是不能错的，否则产生异常。 默认的参数值在定义函数的时候可以在参数类型后加上默认值： 123456func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // If you omit the second argument when calling this function, then // the value of parameterWithDefault is 12 inside the function body.&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12 如果有默认值了，那么在调用的时候这个参数就可以省略了。 推荐将有默认值的参数放在入参的后面。因为没有默认值的参数一般更重要。 可变数量的入参一个可变数量的入参可以传入零个或者更多的参数，在参数类型后面加上 … 就行了。这些入参将会以一个数组的形式在方法体中使用： 1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 这里入参的数字将会以名为 numbers 的 [Double] 数组的形式传入。 这里有几个注意点： 为什么不直接传一个数组呢？因为那样不直观 上面的是省略了 argument labels 的情况。如果不省略，比如将 _ 替换成 to，那么调用的时候改为 arithmeticMean(to:1, 2, 3, 4, 5) 即可。 一个函数里最多只能有一个可变数量的入参。 如果参数是可变的那么就没法设置默认值了。 还有一种情形：func arithmeticMean(_ numbers: Double...,_ anotherNumber: Double)，这种情况下由于两个入参都是缺省的，所有传入的参数都被 numbers 接收，第二个参数无法接收参数。最好不要这样写。 输入输出参数一般函数内参数值的变化不会影响外部传入的变量的值。现在可以通过 inout 标记，使参数值的变化同步影响到外部值的变化。 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 这个示例中，该函数交换输入的两个值。在返回类型前加上 inout 标记。调用方法的时候需要在输入参数前加上 &amp;(其实就是 c 里面的引用嘛，只是多加个 inout 标记用来提示调用者)。使用示例： 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// Prints "someInt is now 107, and anotherInt is now 3" 输入输出参数需要使用变量而不是常量，因为常量不能改变。 函数类型上面有提到过，每个函数都有其函数类型，由输入参数类型和返回类型组成。比如： 123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 上面的方法的函数类型为 (Int, Int) -&gt; Int。再比如一个没有入参和返回值的函数： 123func printHelloWorld() &#123; print("hello, world")&#125; 这个函数的类型是 ()-&gt;Void 使用函数类型你可以定义一个常量或变量为一个函数类型，并指定适当的函数给该变量： 1var mathFunction: (Int, Int) -&gt; Int = addTwoInts 可以直接写成 mathFunction = addTwoInts 通过类型推断决定类型 现在就可以像使用 addTwoInts 方法一样使用 mathFunction 了： 12print("Result: \(mathFunction(2, 3))")// Prints "Result: 5" 注意，使用函数类型的地方就不能再有 argument label 以及 parameter name 了 就算 addTwoInts 的两个入参是有 argument label 的，这里调用 mathFunction 的时候也要省略。mathFunction 不能自己定义 argument label 以及 parameter name ，只能赋予函数之后直接使用。例子： 注意，只有函数类型匹配才能够将 addTwoInts 赋给 mathFunction。由于 mathFunction 和 multiplyTwoInts 类型也相同，所以可以继续对 mathFunction 赋值： 123mathFunction = multiplyTwoIntsprint("Result: \(mathFunction(2, 3))")// Prints "Result: 6" 由于类型推断的作用，定义函数变量或者常量的时候可以不用写出函数类型： 12let anotherMathFunction = addTwoInts// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int 由于传递函数不能改变 argument label 以及 parameter name，所以使用类型推断更方便一些，不要再写一遍函数类型了。 函数类型作为参数类型可以将一个函数作为参数传入另一个函数。这使你预留了一个函数的某些方面的函数实现，让调用者提供的函数时被调用： 12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// Prints "Result: 8" 这里 mathFunction 就是一个函数类型 (Int,Int)-&gt;Int。 函数类型作为返回类型函数的返回类型可以是一个函数类型，即返回一个函数。 例如有两个函数，函数类型都为 (Int)-&gt;Int: 123456func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125; 现在定义一个返回 (Int)-&gt;Int 类型的函数 chooseStepFunction(backward:)，注意返回类型的写法: 123func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 下面看看如何使用的： 123456789101112131415var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the stepBackward() functionprint("Counting to zero:")// Counting to zero:while currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// 3...// 2...// 1...// zero! 嵌套函数迄今为止碰到的所有函数都是在全局范围里的函数，我们也可以将函数定义在函数内，作为嵌套函数。嵌套函数对外是隐藏的，但仍然可以调用和使用其内部的函数。 123456789101112131415161718func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// -4...// -3...// -2...// -1...// zero! 闭包闭包表达式sort 函数Swift 提供了 sort(by:) 函数，会根据提供的闭包，将已知类型数组中的值进行排序。排序完成，函数会返回一个与原数组大小相同的新数组，该数组中包含已经正确排序的同类型元素。 sort(by:) 函数输入一个比较函数大小的方法： 1234567let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 闭包表达式语法上面是输入一个函数的方式，还可以创建一个闭包表达式。闭包表达式的语法如下： {(parameters) -&gt; returntype in statements } 所以可以将上面的排序方法改为如下： 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 根据上下文推断类型因为闭包是作为函数的参数传入的，Swift 能推断出它的参数和返回值的类型(注意，是只有作为参数传入的闭包，才能依据函数的参数类型推断，省略闭包的参数类型的定义。如果是自己单独定义的一个闭包，不能进行上下文推断类型。)，所以可以省略类型： 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着您几乎不需要利用完整格式构造任何内联闭包。然而，你也可以使用明确的类型，如果你想它避免读者阅读可能存在的歧义，这样还是值得鼓励的。 单行表达式省略单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为： 1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 参数名简写Swift 为内联函数提供了参数名称简写功能。可以直接用 $0,$1,$2 等名字来引用的闭包的参数的值。此时，in 关键字可以被省略。在这个例子中，$0 和 $1 表示闭包中第一个和第二个 String 类型的参数。 1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 尾部闭包如果定义的函数的最后一个参数是一个闭包，调用的时候可以使用尾部闭包(Trailing Closures 不知道怎么翻译好就解释为尾部闭包了)。注意书写语法： 123456789101112131415161718func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // function body goes here&#125; // 没有使用尾部闭包的情况someFunctionThatTakesAClosure(closure: &#123; // closure's body goes here&#125;) // 使用尾部闭包的情况 someFunctionThatTakesAClosure() &#123; // trailing closure's body goes here&#125;// 使用尾部闭包如果没有参数，可以省略括号someFunctionThatTakesAclosure &#123; &#125; 可以看到很明显的区别。没有使用尾部闭包的时候是非常正规的函数调用。如果是尾部闭包的情况，那么就单独拿出来放到外面。 比如上面的 sorted(by:) 方法可以改成尾部闭包的形式： 1reversedNames = names.sorted() &#123; $0 &gt; $1 &#125; 如果整个函数的参数只有这一个入参，那么还可以直接省略这个括号(虽然没有歧义，但是总感觉这种语法糖不太好)： 1reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 再举一个典型的例子：在 Swift 中的数组类型中，有一个 map(_:) 方法，这个方法输入一个处理函数，对数组中的每个元素进行处理，返回一个处理过的新数组： 1234567891011121314151617let digitNames = [ 0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"]let numbers = [16, 58, 510]let strings = numbers.map &#123; (number) -&gt; String in var number = number var output = "" repeat &#123; output = digitNames[number % 10]! + output number /= 10 &#125; while number &gt; 0 return output&#125;// strings is inferred to be of type [String]// its value is ["OneSix", "FiveEight", "FiveOneZero"] 捕获值闭包可以在捕获其所定义的上下文中的变量和常量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。 下面举一个关于嵌套函数的例子。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量： 1234567891011121314151617func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125;// 使用:let incrementByTen = makeIncrementer(forIncrement: 10)incrementByTen()// returns a value of 10incrementByTen()// returns a value of 20incrementByTen()// returns a value of 30 incrementer 函数中并没有保存 amount 和 runningTotal。incrementor 实际上捕获并存储了该变量的一个副本，而该副本随着 incrementor 一同被存储。 如果新建了一个新的 incrementer ，其会有一个属于自己的独立的 runningTotal 变量的引用： 12345let incrementBySeven = makeIncrementer(forIncrement: 7)incrementBySeven()// returns a value of 7incrementByTen()// returns a value of 40 闭包是引用类型上面的例子中，incrementBySeven 和 incrementByTen 是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。 这是因为函数和闭包都是引用类型。 无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。 上面的例子中，incrementByTen 指向闭包的引用是一个常量，而并非闭包内容本身。 这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包： 123let alsoIncrementByTen = incrementByTenalsoIncrementByTen()// returns a value of 50 逃逸闭包当一个闭包作为参数传到另一个函数中，并且这个闭包在函数返回后才调用（比如在函数中执行一个异步回调，回调时才执行这个闭包），我们称该闭包从函数中逃逸。需要在函数名前标注 @escaping，用来表示这个闭包是允许逃逸出函数的。 下面模拟一下情景：将 completionHandler 参数保存在外部的一个数组中，此时必须要标记 @escaping 否则产生编译错误： 1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 将闭包标记为逃逸闭包，就必须在闭包中显式地引用 self。看下面的示例： 1234567891011121314151617181920func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x)// 打印出 "200"completionHandlers.first?()print(instance.x)// 打印出 "100" 其中，逃逸的闭包没有立刻执行，所以 instance.x 先被设置成了 100，然后闭包执行了后，才被设置成 200。 另外，看到 completionHandlers.first?() 了么，虽然这列数组是非可选的，但是这个 first 方法返回的是一个可选类型，所以使用的时候要加上 ? 或者 ! 逃逸闭包要注意产生引用循环，需要和 oc 一样使用 weak 标记属性。 自动闭包自动闭包是一种闭包的简写方式。不接受任何参数，当他被调用时，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。 来看个例子就明白了，先看一下不用自动闭包的情况： 123456// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]func serve(customer customerProvider: () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: &#123; customersInLine.remove(at: 0) &#125; )// 打印出 "Now serving Alex!" 上面这种情况的函数调用是正常的打开方式。下面来看下自动闭包的使用： 12345func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: customersInLine.remove(at: 0))// 打印出 "Now serving Ewa!" 上面用了 autoclosure 标记后，下面的闭包可以不用括号。(这玩意会有人用？毫无意义。就当记录一下吧) 貌似只针对一句话的闭包]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 3.1 语法学习（一）]]></title>
    <url>%2F2017%2F02%2F22%2Fswift%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[开始啃 Swift 3.1 的官方文档，地址Swift 官方文档。 可以参见相关的中文文档：文档1文档2 其中有些地方翻译的不好，所以可以对照着看一看。 基础变量和常量常量设置好就不能变，变量设置好能在之后设置不同的值。 声明用 let 声明常量，用 var 声明变量： 12let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0 可以在一行里声明多个变量或常量，用逗号隔开： 1var x = 0.0, y = 0.0, z = 0.0 （变量初始化后就不能赋给其非该类型的值了，比如上面的 x，就只能接收 double 类型的值了） 变量常量都可以先声明，不用立即赋值。 但是在获取的时候，只有可选变量会被默认设置为 nil。 其余非可选变量常量，以及可选常量，在没有赋初值的情况下读取或者强制解包，都会产生异常。 类型注释声明的时候可以注明类型： 1var welcomeMessage: String 这样，该变量就只能接受字符串类型。可以以这样的方式一次定义多个变量： 1var red, green, blue: Double 如果没有值，就一定要标注类型，如果有值，就可以通过类型推断。 反正一定要在声明的时候确定类型 打印可以通过 print(_:separator:terminator:) 方法打印变量。其中 separator 表示分隔符，默认是空格，terminator 表示终止符，默认是回车。该方法接受多个需要打印的变量输入，例： 1234print("item1","item2",separator:"_",terminator:" end")// 打印结果:"item1_item2 end"print("item1",terminator:" end")// 打印结果:"item1 end" Swift 提供反斜杠 \ 来达到字符串中替换变量名的效果（可以接受非字符串）： 1234var myName = "Zachary"var myAge = 18print("My name is \(myName),and my age is \(myAge)")// 打印结果:"My name is Zachary,and my age is 18" 这里反斜杠类似于转义，所以还是要在字符串里出现的，不能是直接 print(\(myName)) 分号Swift 中不需要写分号，一句一行。但是如果一句要有多个表达式，还是要用分号隔开的： 12let cat = "🐱"; print(cat)// Prints "🐱" 类型安全与类型推断Swift 是类型安全的语言。如果代码里需要的是一个 String，那么你就不能传个 Int。不过在类型推断这个机制的作用下，你不必具体说明类型。比如： 12let age1 = 18 // 默认是 Int 类型let age2 = 18.0 // 默认是 Double 类型(Swift 默认用 Double 而不是 Float) 这里类型推断是指没有在后面写上类型的，比如 let age1: Int 就已经表示是非空的 Int 型了，就不可能再推断了 数字的表现方式(省略了不同进制，科学计数等内容) Swift 允许使用 _ 下划线来做标识，不影响数字大小： 12let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1 数字类型转换不能对两个不同类型的变量进行操作，比如： 1234let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine // 3.14159let num = three + Int(pointOneFourOneFiveNine) // 3 + 0 = 3 这里的 three 是 Int 型，pointOneFourOneFiveNine 是 Double 型。由于没有隐式转换，要对两个变量进行和操作必须先对其中一个进行显式类型转换。（数字3是可以直接和数字0.14159相加的，因为数字是没有类型的） 类型别名类型别名为现有类型定义一个别名。定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名： 12typealias AudioSample = Intvar num:AudioSample = 10 感觉没啥用，还容易让人误解 布尔类型Swift 的布尔类型叫做 Bool，两个布尔值为 true 和 false。 其它没什么特别的，有一点要说明： 1234567891011// 编译不通过let i = 1if i &#123; // this example will not compile, and will report an error&#125;// 编译通过let i = 1if i == 1 &#123; // this example will compile successfully&#125; 如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。这就不像很多其他语言，非零非空就是 true。Swift 会阻止你用一个非布尔量替换调 Bool if 条件语句必须是一个有值的表达式 条件判断不用括号，因为不会产生二意 元组元组在其它的脚本语言里用的挺多了。它把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 例如一个 HTTP 状态码： 12let http404Error = (404, "Not Found")// http404Error is of type (Int, String), and equals (404, "Not Found") 你可以把任意顺序的类型组合成一个元组，也可以将元组分解： 12345let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// Prints "The status code is 404"print("The status message is \(statusMessage)")// Prints "The status message is Not Found" 这样，对应位置的变量就被赋值了。如果只需要部分元组值，可以使用 _ 忽略，这是下划线的第二种用法，注意赋值的数量要对上： 123let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// Prints "The status code is 404" 我们还可以直接操作元组元素的下标拿到元素： 1234print("The status code is \(http404Error.0)")// Prints "The status code is 404"print("The status message is \(http404Error.1)")// Prints "The status message is Not Found" 我们也可以直接在声明的时候为元组元素命名： 123456let http200Status = (statusCode: 200, description: "OK")print("The status code is \(http200Status.statusCode)")// Prints "The status code is 200"print("The status message is \(http200Status.description)")// Prints "The status message is OK" 元组作为函数返回值的时候非常有用，适合作为临时的一组值的集合。但是不适合创建复杂的数据结构。如果要创建一个持久化的数据结构，还是建议使用类和结构体。 可选可选可以用在一个值可能缺失的情况下。其实就是可能为基本类型，也可能为空。比如在强制类型转化中: 123let possibleNumber = "123"let convertedNumber = Int(possibleNumber)// convertedNumber is inferred to be of type "Int?", or "optional Int" 这里面将 possibleNumber 强转为 Int 型，可能成功，但如果是 &quot;hello,world&quot; 就肯定失败了。所以这里 convertedNumber 就是一个可选类型，不一定是 Int。可选的 Int 类型用 Int? 表示。问号暗示包含的值是可选，也就是说可能是 Int 也可能不包含值。 上面 possibleNumber 由于类型推断，一定是不可选类型，除非将 possibleNumber 写成 let possibleNumber: String? = &quot;123&quot;，才能表示可选。 convertedNumber 是一个可选类型，在对可选类型进行赋值以外的操作的时候，需要使用 ! 或者 ? 包裹。 元组也可以被设置为可选，在元组后添加 ?： 1let a: (Int,Int)? = nil 还有一种需要区别的是元组内元素的可选，在可选的类型后添加 ?： 12let a: (String?,Int) = (nil,2) // √let a = (nil,2) // × 没有声明，那就表示是非可选 直接赋值的都能通过赋给的值进行类型推断，而不是可选类型；前面直接 var str: String 声明但没有赋值的也是非可选的。 可选变量的声明，一定要手动标明，即一定要加上 ?,即 let possibleNumber: String?，否则就是不可选的。切记切记。 nil如果一个类型是可选类型，那么你可以将其值设为 nil: 1234var serverResponseCode: Int? = 404// serverResponseCode contains an actual Int value of 404serverResponseCode = nil// serverResponseCode now contains no value 如果变量或常量的类型不是可选的，那么就不能用 nil 了。反之亦然，如果代码中的变量或者常量可能会为空的时候，总是将其设置为可选类型。 如果定义了一个没有提供默认值的可选变量，那么默认设置为 nil；定义一个没有默认值的非可选变量，如果使用那么会报错： 1234var surveyAnswer: String?print(surveyAnswer) // nilvar surveyAnswer: String print(surveyAnswer) // variable 'surveyAnswer' used before being initialized 上面是 var 类型，let 类型的常量，无论是否可选，使用前必须初始化。 可能是因为如果没有初始化，那就要被推断为 nil，且不能改变。这种不是由程序上下文设置的 nil，而是推断出的 nil 没有意义，所以索性抛出个异常。 oc 中的 nil 是一个指向不存在对象的指针。在 Swift 中 nil 不是指针，只是表示缺失值，任何类型都可以被设置为 nil（包括基本类型）。 强制解析 如果你确信你的可选类型一定是有值的，那么可以在可选的变量名后面加上 !，表示这个可选值必然有值： 1234if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).")&#125;// Prints "convertedNumber has an integer value of 123." 如果想要对一个可选类型进行赋值以外的操作，必须使用强制解析，因为只能对非空对象进行操作： 123print(convertedNumber! - 12) //√print(convertedNumber - 12) //×print(convertedNumber? - 12) //× 可选绑定可选绑定可以用在 if 和 while 语句中来对可选的值进行判断，并把值赋给一个常量或者变量，来个例子: 123456if let actualNumber = Int(possibleNumber) &#123; print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")&#125; else &#123; print("\"\(possibleNumber)\" could not be converted to an integer")&#125;// Prints ""123" has an integer value of 123" 这个表示，如果 Int(possibleNumber) 转换后有值，那么赋值给 actualNumber，走成功的分支，否则走失败的分支。注意，这里的 actualNumber 就不需要加 ! 了，因为由于可选绑定，它已经不是一个可选类型了。 这其实就是判断非空操作的语法糖 注意可选绑定的格式： if let constantName = someOptional { statements } 这里的 let 或者 var 是必须的，并且作用域为整个 if 判断如果 Int(possibleNumber) 存在，就声明了 actualNumber，如果不存在就相当于没有声明这个变量。 一条 if 可以写多个可选绑定或者条件判断，用逗号隔开就行，表示 &amp; 的关系，一个是 false 则整个判断条件是 false。 12345678910111213if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber &lt; secondNumber, secondNumber &lt; 100 &#123; print("\(firstNumber) &lt; \(secondNumber) &lt; 100")&#125;// Prints "4 &lt; 42 &lt; 100" if let firstNumber = Int("4") &#123; if let secondNumber = Int("42") &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print("\(firstNumber) &lt; \(secondNumber) &lt; 100") &#125; &#125;&#125;// Prints "4 &lt; 42 &lt; 100" 可以都用逗号，但是有可选绑定就不能用 &amp;&amp; 可选绑定的生命周期在函数内，出了函数，这个变量就回收了。 隐式解析可选搞了这么个可选后，如果确定有值，每次都要判断和解析可选值是非常低效的。因此就定义了一个隐式解析可选的方式: 123456let possibleString: String? = "An optional string."// 不能直接 let forcedString：String = possibleString 因为，一个是可选类型，一个是非可选类型let forcedString: String = possibleString! // requires an exclamation mark let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // no need for an exclamation mark 当可选被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选非常有用。隐式解析可选主要被用在 Swift 中类的构造过程中(参考无主解析) 一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。你可以把隐式解析可选当做一个可以自动解析的可选。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。其实就是本质上是可选，但是表面上(指的是写法上)当做非可选用。 如果你在隐式解析可选没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选后面加一个惊叹号一样。 如果一个变量之后可能变成 nil 的话请不要使用隐式解析可选。如果你需要在变量的生命周期中判断是否是 nil 的话，请使用普通可选类型。 基础运算符赋值运算和别的语言的赋值没什么区别。 对于元组的赋值，元组内元素会被立刻拆开成多个变量： 1let (x, y) = (1, 2) // 现在 x 等于 1, y 等于 2 补充：这里的 x 和 y 相当于被声明成为 let 类型。 另外，Swift 的赋值符号自身不会返回值，所以下面的代码在 Swift 中是不合法的： 123if x = y &#123; // This is not valid, because x = y does not return a value.&#125; 数值运算和别的语言的赋值没什么区别。 加法运算符也用于字符串的拼接。注意，不是字符串要手动转换，否则不合法： 123let myAge = 18print("my age is "+myAge) // ❎print("my age is "+String(myAge)) // ✅ 取余求余运算（a % b）是计算 b 的多少倍刚刚好可以容入 a，返回多出来的那部分，计算公式为： a = (b × 倍数) + 余数 129%4 // 1-9%4 // -1 Swift 中可以对浮点数进行取余： 18 % 2.5 // 等于 0.5 在对负数 b 求余时，b 的符号会被忽略。这意味着 a % b 和 a % -b的结果是相同的。 自增自减自增自减已被移除 由于自增自减在 for 循环中使用的多，并且 swift 中现在 for 循环已经不是 c 那种 for 循环了。所以就被干掉了 可以使用复合赋值替代 复合赋值12var a = 1a += 2 // a 现在是 3 注意，复合赋值是没有返回值的。 比较运算符和别的语言的比较没啥区别 元组也是能够比较的，从左向右比较，直到发现不同。布尔值不能被比较： 123(1, "zebra") &lt; (2, "apple") // true because 1 is less than 2; "zebra" and "apple" are not compared(3, "apple") &lt; (3, "bird") // true because 3 is equal to 3, and "apple" is less than "bird"(4, "dog") == (4, "dog") // true because 4 is equal to 4, and "dog" is equal to "dog" 空合并操作符空合并操作符 (a ?? b)，解析一个可选的 a，如果不为空，那么返回 a!，如果为空，那么返回默认值 b。等效于如下： 1a != nil ? a! : b 主要就是给可选量设置一个默认值，例子： 12345let defaultColorName = "red"var userDefinedColorName: String? // defaults to nil var colorNameToUse = userDefinedColorName ?? defaultColorName// userDefinedColorName is nil, so colorNameToUse is set to the default of "red" 三元选择操作符和其他语言的三元操作符没有任何区别 区间操作符闭区间运算符闭区间运算符 a...b，定义了一个包括 a 和 b 的所有值的区间。在 for…in 循环中非常有用： 12345678for index in 1...5 &#123; print("\(index) * 5 = \(index * 5)")&#125;// 1 * 5 = 5// 2 * 5 = 10// 3 * 5 = 15// 4 * 5 = 20// 5 * 5 = 25 半闭区间半闭区间 a..&lt;b，定义一个从 a 到 b，但不包括 b 的区间。 半闭区间的实用性在于当你使用一个 0 始的列表(如数组)时，非常方便地从 0 数到列表的长度： 123456789let names = ["Anna", "Alex", "Brian", "Jack"]let count = names.countfor i in 0..&lt;count &#123; print("第 \(i + 1) 个人叫 \(names[i])")&#125;// 第 1 个人叫 Anna// 第 2 个人叫 Alex// 第 3 个人叫 Brian// 第 4 个人叫 Jack 注意现在半闭区间必须是 ..&lt;，不是之前的 .. 逻辑操作符没什么区别 字符串与字符初始化字符串两种初始化字符串的方式： 123var emptyString = "" // empty string literalvar anotherEmptyString = String() // initializer syntax// these two strings are both empty, and are equivalent to each other 判断是否为空，用 isEmpty 方法： 1234if emptyString.isEmpty &#123; print("Nothing to see here")&#125;// Prints "Nothing to see here" 字符串可变性oc 中通过 NSString 和 NSMutableString 区别是否可以修改字符串。Swift 中只通过是常量还是变量来判断： 1234567var variableString = "Horse"variableString += " and carriage"// variableString is now "Horse and carriage" let constantString = "Highlander"constantString += " and another Highlander"// this reports a compile-time error - a constant string cannot be modified 字符串是值传递Swift 中，如果创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数/方法中传递时，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值。 let 相当于 oc 中 const 的 NSString var 相当于 oc 中可变的 NSString oc 中的 NSMutableString 是引用传递，swift 中没有和其对应的 Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值，其明确了无论该值来自于哪里，都是您独自拥有的。您可以放心您传递的字符串本身不会被更改。 使用字符可以通过 String 的 characters 属性获取字符串的字符： 12345678for character in "Dog!🐶".characters &#123; print(character)&#125;// D// o// g// !// 🐶 swift 中的字符串没有了 length 这个属性。要获取长度还得通过 characters 这个数组属性。拿到这个数组的 count 就是字符串中的长度。 可以直接创建一个字符： 1let exclamationMark: Character = "!" 也可以创建一个字符数组，再转换为字符串： 1234let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]let catString = String(catCharacters)print(catString)// Prints "Cat!🐱" 连接字符串这个其实在前面说过了，就是能通过 + 或者 += 把两个字符串连起来： 12345678let string1 = "hello"let string2 = " there"var welcome = string1 + string2// welcome now equals "hello there"var instruction = "look over"instruction += string2// instruction now equals "look over there" 需要注意，不能直接连接字符串和字符，需要通过 append 方法： 123let exclamationMark: Character = "!"welcome.append(exclamationMark)// welcome now equals "hello there!" 字符串插入这个之前也用过了，就是在字符串中添加一个占位符： 123let multiplier = 3let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"// message is "3 times 2.5 is 7.5" 括号内不能包含未转义的 \，回车或者换行。 集合类型Swift 提供 array，sets，dictionaries 来存储数据。在同一个集合中的元素的类型必须是相同的。 可变集合和 String 类似，如果你把一个集合赋给一个 var 类型的变量，那么你可以动态地对集合操作；如果你把一个集合赋给一个 let 的常量，那么这个集合就是不可变的（包括数组的长度，以及数组内的对象的地址，但是可以改变对象的属性）。 数组数组的简写语法Swift 数组的类型被写作 Array&lt;Element&gt;，另一种简写方式是 [Element]。更推荐用后一种方式： 12var nums1:Array&lt;Int&gt; = [12,34,12]var nums2:[Int] = [12,12,32] 创建一个空数组可以用以下初始化方式来创建一个确定类型的空数组： 123var someInts = [Int]()print("someInts is of type [Int] with \(someInts.count) items.")// Prints "someInts is of type [Int] with 0 items." 要注意变量 someInts 会被推断为 [Int] 类型。 上面的操作主要还是为了明确数组的类型。一个不明确的类型的数组声明，比如 var someInts = []是不合法的。但是如果数组本身的类型已经明确了，就可以直接用 [] 置空了： 123456var someInts = [Int]()someInts.append(3)// someInts now contains 1 value of type IntsomeInts = []// someInts is now an empty array, but is still of type [Int] 创建一个有默认值的数组反正就是这个语法，用处大不大我就不知道了 12var threeDoubles = Array(repeating: 0.0, count: 3)// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0] 没啥用 连接两个数组如果两个数组类型相同，那么可以用 + 连接两个数组，返回一个新数组： 12345var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5] var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 创建一个数组下面例子是创建一个保存字符串的数组： 12var shoppingList: [String] = ["Eggs", "Milk"]// shoppingList has been initialized with two initial items 由于类型推断，我们可以省略 [String]： 1var shoppingList = ["Eggs", "Milk"] array 和 String 一样，也是值引用。 var array1 = array2 在堆中开辟了两块内存空间，而不是指向同一个地址。可以分别处理 array1 和 array2 存取和更改数组通过 count 属性获得数组长度： 12print("The shopping list contains \(shoppingList.count) items.")// Prints "The shopping list contains 2 items." 通过 isEmpty 属性获得数组是否为空： 123456if shoppingList.isEmpty &#123; print("The shopping list is empty.")&#125; else &#123; print("The shopping list is not empty.")&#125;// Prints "The shopping list is not empty." 通过 append(_:) 方法添加新项： 12shoppingList.append("Flour")// shoppingList now contains 3 items, and someone is making pancakes 通过 += 添加新项： 1234shoppingList += ["Baking Powder"]// shoppingList now contains 4 itemsshoppingList += ["Chocolate Spread", "Cheese", "Butter"]// shoppingList now contains 7 items 通过下标获取数组元素: 12var firstItem = shoppingList[0]// firstItem is equal to "Eggs" 同样的方法设置数组元素（数组下标不能越界）： 1234shoppingList[0] = "Six eggs"// the first item in the list is now equal to "Six eggs" rather than "Eggs"shoppingList[4...6] = ["Bananas", "Apples"]// shoppingList now contains 6 items 这里 4…6 是闭区间运算符，表示三个值。这里只赋了两个值 [&quot;Bananas&quot;, &quot;Apples&quot;]，所以4，5被修改，6 被 remove 掉。如果赋四个值 [&quot;Bananas&quot;, &quot;Apples&quot;,&quot;Pear&quot;,&quot;Cherry&quot;] 呢？4，5，6被修改，最后一个插入数组中变为 7，原来数组中的 7 及以后顺延为 8 及以后。 通过 insert(_:at:) 在指定位置插入： 123shoppingList.insert("Maple Syrup", at: 0)// shoppingList now contains 7 items// "Maple Syrup" is now the first item in the list 通过 remove(at:) 删除指定位置数组内容，并返回删除的那个内容（如果你用不到返回值，可以忽略）： 1234let mapleSyrup = shoppingList.remove(at: 0)// the item that was at index 0 has just been removed// shoppingList now contains 6 items, and no Maple Syrup// the mapleSyrup constant is now equal to the removed "Maple Syrup" string 通过 removeLast() 删除最后一个元素： 1234let apples = shoppingList.removeLast()// the last item in the array has just been removed// shoppingList now contains 5 items, and no apples// the apples constant is now equal to the removed "Apples" string 迭代数组通过 for-in 循环取出数组元素： 12345678for item in shoppingList &#123; print(item)&#125;// Six eggs// Milk// Flour// Baking Powder// Bananas 如果还需要数组元素对应的下标，可以使用 enumerated() 方法。该方法可以返回数组元素和数组元素下标所组成的元组： 12345678for (index, value) in shoppingList.enumerated() &#123; print("Item \(index + 1): \(value)")&#125;// Item 1: Six eggs// Item 2: Milk// Item 3: Flour// Item 4: Baking Powder// Item 5: Bananas 字典和数组类似。字典的键和值的类型都应该是分别相同的。键必须不重复，且是可哈希的（Swift 的所有基本类型都是可哈希的） 字典的简写语法Swift 数组的类型被写作 Dictionary&lt;Key,Value&gt;，另一种简写方式是 [Key:Value]。更推荐用后一种方式： 12var nums1: Dictionary&lt;Int,String&gt; = [12:"123",34:"1234",13:"131"]var nums2: [Int:String] = [12:"123",34:"1234",13:"131"] 注意一个是逗号，一个是冒号。 创建一个空字典可以通过下面方法初始化一个空字典： 12var namesOfIntegers = [Int: String]()// namesOfIntegers is an empty [Int: String] dictionary 初始化后，变量的类型就确定了。即使清空字典，字典类型也不会变: 1234namesOfIntegers[16] = "sixteen"// namesOfIntegers now contains 1 key-value pairnamesOfIntegers = [:]// namesOfIntegers is once again an empty dictionary of type [Int: String] 创建一个字典通过下面方式创建一个字典，同样由于类型推断，不写明类型也是可以的： 12var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"] 存取和更改数组其他没什么区别，多了一个 updateValue(_:forKey:) 方法，在对特定键设置或更新值时，也可以使用该方法来替代下标。但与下标不同的是，该方法在更新一个值之后，会返回原来的老值。 该方法返回一个可选类型的值。如果字典里存的是 String 类型，那么该方法返回的就是 String?。这个可选值可以用来判断，这个方法的操作是更新还是设置。如果原来存在就非 nil，如果原来不存在就是 nil： 1234if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; print("The old value for DUB was \(oldValue).")&#125;// Prints "The old value for DUB was Dublin." 当然，还可以直接用下标的方式来获取值，由于可能为空，所以返回的也是可选类型： 123456if let airportName = airports["DUB"] &#123; print("The name of the airport is \(airportName).")&#125; else &#123; print("That airport is not in the airports dictionary.")&#125;// Prints "The name of the airport is Dublin Airport." 可以直接操作下标，将键对应的值设置为 nil，来删除相应键值对： 1234airports["APL"] = "Apple International"// "Apple International" is not the real airport for APL, so delete itairports["APL"] = nil// APL has now been removed from the dictionary 删除的话还可以通过专门的方法 removeValue(forKey:) 方法实现，该方法移除指定键的值后，返回移除了的值，如果本生就没有需要移除的键就返回 nil： 123456if let removedValue = airports.removeValue(forKey: "DUB") &#123; print("The removed airport's name is \(removedValue).")&#125; else &#123; print("The airports dictionary does not contain a value for DUB.")&#125;// Prints "The removed airport's name is Dublin Airport." 迭代字典通过 for-in 循环获得键值对。键值对用元组存储： 12345for (airportCode, airportName) in airports &#123; print("\(airportCode): \(airportName)")&#125;// YYZ: Toronto Pearson// LHR: London Heathrow 也可以通过 keys 和 values 属性，分别拿到对应集合： 1234567891011for airportCode in airports.keys &#123; print("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHR for airportName in airports.values &#123; print("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 如果想要得到获得字典的键或者值的数组，可以通过 keys 和 values 属性进行初始化： 12345let airportCodes = [String](airports.keys)// airportCodes is ["YYZ", "LHR"] let airportNames = [String](airports.values)// airportNames is ["Toronto Pearson", "London Heathrow"] 上面见过创建空数组的方式是 [String]()，我们也可以通过这种方式创建带值的数组，即在括号内添加数组。 数组和字典的可选数组的类型推断数组是可选的，数组内的值也是可选的，下面列举一些例子： 123456let arr1 = [1,2,3] //数组不可选，值不可选let arr2 = [1,2,nil] //数组不可选，值可选let arr3: [Int] = [1,2,3] //数组不可选，值不可选let arr4: [Int?] = [1,2,nil] //数组不可选，值可选let arr5: [Int]? = [1,2,3] //数组可选，值不可选let arr6: [Int?]? = [1,2,nil] //数组可选，值可选 我们可以看到： arr1 由于赋给的值都非空，所以数组值被类型推断为不可选。这和 arr3 同一个意思。 arr2 由于赋给的值有空，所以数组值被推断为可选。这和 arr4 同一个意思。 arr5 手动设置数组本生是可选的. arr6 手动设置数组和数组值为可选的 上面对应的调用方式如下： 123456var sum1 = arr1[0] + 2var sum2 = arr2[0]! + 2var sum3 = arr3[0] + 2var sum4 = arr4[0]! + 2var sum5 = arr5![0] + 2var sum6 = arr6![0]! + 2 arr1 中的值是非可选的，所以直接取出计算 arr2 中的值是可选的，所以取出后要强制解析然后才能计算 arr3 同 arr1,arr4 同 arr2 arr5 由于数组是可选的，所以要在 arr 后强制解析一下 arr6 由于数组和值都是可选的，所以 arr 以及 [0] 后都要强制解析 字典的类型推断字典也是可以进行类型推断的： 123let dic1 = [1:1,2:2,3:3]let dic2: [Int:Int] = [1:1,2:2,3:3]let dic3: [Int:Int]? = [1:1,2:2,3:3] 可以看到字典中只有这三种写法。这是因为 dic 中如果值为 nil，那么就会将键删除，所以不存在字典值的可选的情况。虽然字典不存在值的可选，但是使用的时候可能获取不到对应的键值对，所以使用的时候需要使用强制解析： 12var sum1 = dic1[1]! + 2var sum3 = dic3![1]! + 2 上面的例子中，可能字典中不包含键为 1 的键值对，所以取出可能为空，这就需要强制解析了。这就涉及到了一个关于可选的原则：如果要对一个可能为空的值操作，先将其强制解析。 注意字典里获取不存在的键，是能返回 nil 的，所以返回值是个可选类型，要强制解析；而如果越界访问数组，不是返回 nil，直接抛出异常。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MBProgressHUD 源码解析]]></title>
    <url>%2F2017%2F02%2F21%2FMBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[读项目工程的时候读到了 MBProgressHUD，所以仔细研究了一下它的原理，以及里面使用到的各种 api。我所看的源码是 MBProgressHUD 1.0.0 构造与显示方法首先是 MBProgressHUD 的构造显示方法： 1234567+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated &#123; MBProgressHUD *hud = [[self alloc] initWithView:view]; hud.removeFromSuperViewOnHide = YES; [view addSubview:hud]; [hud showAnimated:animated]; return hud;&#125; 该方法先创建了一个 MBProgressHUD 实例，然后将其添加到 view 上，并将其显示出来。removeFromSuperViewOnHide 是个标记，暂时不用管它。 构造方法进入上面的 initWithView: 方法，一层层进入，最终通过 commonInit 实现： 123456789101112131415161718192021222324- (void)commonInit &#123; // Set default values for properties _animationType = MBProgressHUDAnimationFade; _mode = MBProgressHUDModeIndeterminate; _margin = 20.0f; _opacity = 1.f; _defaultMotionEffectsEnabled = YES; // Default color, depending on the current iOS version BOOL isLegacy = kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_7_0; _contentColor = isLegacy ? [UIColor whiteColor] : [UIColor colorWithWhite:0.f alpha:0.7f]; // Transparent background self.opaque = NO; self.backgroundColor = [UIColor clearColor]; // Make it invisible for now self.alpha = 0.0f; self.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; //--- 父控件的透明度是否应用到子控件 self.layer.allowsGroupOpacity = NO; [self setupViews]; [self updateIndicators]; [self registerForNotifications];&#125; 这个方法构造了整个 view。上部设置了很多默认项，还是等到用到的时候再细说。后面又调用了三个方法 setupViews,updateIndicators,registerForNotifications。 创建 view进入 setupVies 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)setupViews &#123; UIColor *defaultColor = self.contentColor; //---这个的背景view MBBackgroundView *backgroundView = [[MBBackgroundView alloc] initWithFrame:self.bounds]; backgroundView.style = MBProgressHUDBackgroundStyleSolidColor; backgroundView.backgroundColor = [UIColor clearColor]; backgroundView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; backgroundView.alpha = 0.f; [self addSubview:backgroundView]; _backgroundView = backgroundView; //---容纳指示器的view MBBackgroundView *bezelView = [MBBackgroundView new]; bezelView.translatesAutoresizingMaskIntoConstraints = NO; bezelView.layer.cornerRadius = 5.f; bezelView.alpha = 0.f; [self addSubview:bezelView]; _bezelView = bezelView; //--- 这个方法让view能够跟随陀螺仪运动。 [self updateBezelMotionEffects]; ...创建各种 label，detailLabel，button for (UIView *view in @[label, detailsLabel, button]) &#123; view.translatesAutoresizingMaskIntoConstraints = NO; [view setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal]; [view setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical]; [bezelView addSubview:view]; &#125; UIView *topSpacer = [UIView new]; topSpacer.translatesAutoresizingMaskIntoConstraints = NO; topSpacer.hidden = YES; [bezelView addSubview:topSpacer]; _topSpacer = topSpacer; UIView *bottomSpacer = [UIView new]; bottomSpacer.translatesAutoresizingMaskIntoConstraints = NO; bottomSpacer.hidden = YES; [bezelView addSubview:bottomSpacer]; _bottomSpacer = bottomSpacer;&#125; 这个方法里创建了 HUD 中要显示的各个部分。首先创建了两个 MBBackgroundView，一个是整个 view 的背景，另一个则用来容纳指示器。进入它的构造方法，在 updateForBackgroundStyle 中用到了 UIBlurEffect。这是 iOS 中提供的用来实现高斯模糊的 API，不熟悉的朋友可以参见 UIVisualEffectView 实现高斯模糊 接下来是 updateBezelMotionEffects 方法。这个方法能够让 view 跟随屏幕倾斜而位移(看源码前还真没发现可以动)。这个方法里用到的是 UIInterpolatingMotionEffect 的 API，不熟悉的朋友可以参见 UIInterpolatingMotionEffect 视图运动 后面就是创建各个提示内容的 view，也就是后面经常用到的 NSMutableArray *subviews = [NSMutableArray arrayWithObjects:self.topSpacer, self.label, self.detailsLabel, self.button, self.bottomSpacer, nil];这里只是将 view 加入到 MBBackgroundView 中，约束设置在 updateConstraints 方法中，如果你对这个方法不太熟悉，可以参见图像显示过程与一些注意事项。 设置指示器现在执行到 setupViews 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (void)updateIndicators &#123; UIView *indicator = self.indicator; BOOL isActivityIndicator = [indicator isKindOfClass:[UIActivityIndicatorView class]]; BOOL isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView class]]; MBProgressHUDMode mode = self.mode; if (mode == MBProgressHUDModeIndeterminate) &#123; if (!isActivityIndicator) &#123; //--- 系统自带的旋转的菊花。 // Update to indeterminate indicator [indicator removeFromSuperview]; indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge]; [(UIActivityIndicatorView *)indicator startAnimating]; [self.bezelView addSubview:indicator]; &#125; &#125; else if (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123; // Update to bar determinate indicator //--- 自定义的一个进度条 条状的 [indicator removeFromSuperview]; indicator = [[MBBarProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; else if (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123; //--- 自定义进图条 条状的还是环状的 if (!isRoundIndicator) &#123; // Update to determinante indicator [indicator removeFromSuperview]; indicator = [[MBRoundProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; if (mode == MBProgressHUDModeAnnularDeterminate) &#123; [(MBRoundProgressView *)indicator setAnnular:YES]; &#125; &#125; else if (mode == MBProgressHUDModeCustomView &amp;&amp; self.customView != indicator) &#123; //--- 通过用户设置的 customView 设置进度条 // Update custom view indicator [indicator removeFromSuperview]; indicator = self.customView; [self.bezelView addSubview:indicator]; &#125; else if (mode == MBProgressHUDModeText) &#123; [indicator removeFromSuperview]; indicator = nil; &#125; indicator.translatesAutoresizingMaskIntoConstraints = NO; self.indicator = indicator; if ([indicator respondsToSelector:@selector(setProgress:)]) &#123; [(id)indicator setValue:@(self.progress) forKey:@"progress"]; &#125; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal]; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical]; [self updateViewsForColor:self.contentColor]; [self setNeedsUpdateConstraints];&#125; 这个方法设置指示器到底是什么样的，通过前面设置的 mode 来区别。可以是系统自带的菊花型 UIActivityIndicatorView，也可以是自定义的条状指示器 MBBarProgressView，还可以是自定义的环状的 MBRoundProgressView，当然，也可以是用户自定义的 view 作为视图指示器。 如果是自定义的指示器，外部可以随时改变 customView，这会触发内部的 set 方法，更新约束： 12345678- (void)setCustomView:(UIView *)customView &#123; if (customView != _customView) &#123; _customView = customView; if (self.mode == MBProgressHUDModeCustomView) &#123; [self updateIndicators]; &#125; &#125;&#125; 可以把 customView 设置为 UIImageView 来实现加载时的动态效果，详情看用 UIImageView 播放动图 在 MBBarProgressView 和 MBRoundProgressView 的 drawRect: 方法中实现了指示器的绘制。使用了 UIBezierPath 和 CoreGraphics 的 API，如果不熟，可以参见 绘制图形。进度显示是以 _progress 变量为准的。 注册通知这里的注册通知其实挺无关紧要的： 12345678- (void)registerForNotifications &#123;#if !TARGET_OS_TV NSNotificationCenter *nc = [NSNotificationCenter defaultCenter]; [nc addObserver:self selector:@selector(statusBarOrientationDidChange:) name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];#endif&#125; 其实就是注册一个监听屏幕旋转的通知。而且现在大部分机型都是 iOS8 之后，基本不用设置什么。 显示方法看一下显示方法 showAnimated:： 12345678910111213141516- (void)showAnimated:(BOOL)animated &#123; MBMainThreadAssert(); [self.minShowTimer invalidate]; self.useAnimation = animated; self.finished = NO; // If the grace time is set, postpone the HUD display if (self.graceTime &gt; 0.0) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:self.graceTime target:self selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.graceTimer = timer; &#125; // ... otherwise show the HUD immediately else &#123; [self showUsingAnimation:self.useAnimation]; &#125;&#125; 可以看一下 graceTime 是一个显示的延迟时间。如果设置了这个时间，就会创建一个 NSTimer 的定时器，在 graceTime 之后再执行 showUsingAnimation 方法，将 hud 显示出来。finished 就是用来监控在这段时间还没有被显示出来的时间内，hud 是否已经被设置隐藏了的标记。 接下来看 showUsingAnimation: 方法： 12345678910111213141516171819202122232425- (void)showUsingAnimation:(BOOL)animated &#123; // Cancel any previous animations [self.bezelView.layer removeAllAnimations]; [self.backgroundView.layer removeAllAnimations]; // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; //--- 记录显示的时间 self.showStarted = [NSDate date]; self.alpha = 1.f; // Needed in case we hide and re-show with the same NSProgress object attached. //--- 设置以CADisplayLink为基准的刷新，注意这里并不是所有的进度条都是以CAD来刷新的，只有设置了 progressObject 的才会使用 [self setNSProgressDisplayLinkEnabled:YES]; if (animated) &#123; [self animateIn:YES withType:self.animationType completion:NULL]; &#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" self.bezelView.alpha = self.opacity;#pragma clang diagnostic pop self.backgroundView.alpha = 1.f; &#125;&#125; 这里 showStarted 用来记录一个显示开始的时间，这个将会在后面用到，将通过这个时间来设置 hud 的最短显示时间。下面两个方法 setNSProgressDisplayLinkEnabled: 和 animateIn:withType:completion: 方法，一个用来设置 progressObject 进度（注意，不是所有进度变化都会用到这个方法），一个用来自定义展示动画。 我们来看看设置 progressObject 进度的方法： 1234567891011121314151617- (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled &#123; // We're using CADisplayLink, because NSProgress can change very quickly and observing it may starve the main thread, // so we're refreshing the progress only every frame draw if (enabled &amp;&amp; self.progressObject) &#123; // Only create if not already active. if (!self.progressObjectDisplayLink) &#123; //--- 这里要注意，重写了 progressObjectDisplayLink 的 set 方法 self.progressObjectDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateProgressFromProgressObject)]; &#125; &#125; else &#123; self.progressObjectDisplayLink = nil; &#125;&#125;- (void)updateProgressFromProgressObject &#123; self.progress = self.progressObject.fractionCompleted;&#125; 之所以说是设置 progressObject 的进度，是因为显示的进度是以 _progress 为准的。如果你仔细看上面的 drawRect: 方法，就能发现所有的图形都是以 _progress 显示的。那么这里的 progressObject 有什么用呢？ 如果使用了 progressObject，那么就会创建一个 CADisplayLink 实例。CADisplayLink 适合于高精度的定时刷新，具体使用方法可见：CADisplayLink 方式的定时器 progressObject 是一个 NSProgress 对象，如果对其不了解可以参见iOS进度指示器——NSProgress，它将进度设置给 _progress。我们可以看一下 _progress 的 set 方法： 123456789- (void)setProgress:(float)progress &#123; if (progress != _progress) &#123; _progress = progress; UIView *indicator = self.indicator; if ([indicator respondsToSelector:@selector(setProgress:)]) &#123; [(id)indicator setValue:@(self.progress) forKey:@"progress"]; &#125; &#125;&#125; 这样就会触发指示器的 progress 的 set 方法： 123456- (void)setProgress:(float)progress &#123; if (progress != _progress) &#123; _progress = progress; [self setNeedsDisplay]; &#125;&#125; 只要 progress 变化了，就会设置重绘视图。 至于动画的执行方法，没什么特别的地方，不太了解的话可以参考 核心动画 隐藏方法来看一下隐藏方法： 123456789+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated &#123; MBProgressHUD *hud = [self HUDForView:view]; if (hud != nil) &#123; hud.removeFromSuperViewOnHide = YES; [hud hideAnimated:animated]; return YES; &#125; return NO;&#125; 先找到 MBProgressHUD 类，然后调动 hideAnimated: 方法： 12345678910111213141516171819- (void)hideAnimated:(BOOL)animated &#123; MBMainThreadAssert(); [self.graceTimer invalidate]; self.useAnimation = animated; self.finished = YES; // If the minShow time is set, calculate how long the HUD was shown, // and postpone the hiding operation if necessary if (self.minShowTime &gt; 0.0 &amp;&amp; self.showStarted) &#123; NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:self.showStarted]; if (interv &lt; self.minShowTime) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:(self.minShowTime - interv) target:self selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.minShowTimer = timer; return; &#125; &#125; // ... otherwise hide the HUD immediately [self hideUsingAnimation:self.useAnimation];&#125; 这个方法的解构和上面的 show 类似，其中 minShowTime 表示最少显示的时间，避免加载太快，hud 一闪而过的情况出现。这里就用到了上面说过的 showStarted 了。往下走，来看看 hideUsingAnimation: 方法： 12345678910111213- (void)hideUsingAnimation:(BOOL)animated &#123; if (animated &amp;&amp; self.showStarted) &#123; self.showStarted = nil; [self animateIn:NO withType:self.animationType completion:^(BOOL finished) &#123; [self done]; &#125;]; &#125; else &#123; self.showStarted = nil; self.bezelView.alpha = 0.f; self.backgroundView.alpha = 1.f; [self done]; &#125;&#125; 其实也和 show 的时候差不多，有动画显示隐藏动画，没有动画直接就隐藏掉。只不过这里要做一些扫尾操作：执行 done 方法： 1234567891011121314151617181920- (void)done &#123; // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; [self setNSProgressDisplayLinkEnabled:NO]; if (self.hasFinished) &#123; self.alpha = 0.0f; if (self.removeFromSuperViewOnHide) &#123; [self removeFromSuperview]; &#125; &#125; MBProgressHUDCompletionBlock completionBlock = self.completionBlock; if (completionBlock) &#123; completionBlock(); &#125; id&lt;MBProgressHUDDelegate&gt; delegate = self.delegate; if ([delegate respondsToSelector:@selector(hudWasHidden:)]) &#123; [delegate performSelector:@selector(hudWasHidden:) withObject:self]; &#125;&#125; 这里就是执行一下外部传进来的 completionBlock 回调。如果外部设置了代理方法，并且重写了 hudWasHidden 那么就调用执行。 总结MBProgressHUD 确实是一个比较简单的框架。看的时候我还是蛮仔细的注意每一个知识点的，诸如 view 的绘制显示过程、贝塞尔曲线的绘制、UIInterpolatingMotionEffect 的使用 等等等等。所以还是花了不少时间去搞懂的。写到这里再想想，整个框架的结构还是非常清晰易懂的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[许多 iOS API 的使用方式(持续更新)]]></title>
    <url>%2F2017%2F02%2F13%2FiOS%E4%B8%ADAPI%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多不常用的简单的 API 的使用方式。分开写的话太短小，就合在一起吧。（这里都是学到的时候，东找一点西找一点拼凑起来的，一开始没有记录出处在哪，如果哪里有侵权的地方，还请尽快告知呀。我会第一时间注明出处的。谢谢啦~） NSUndoManagerNSUndoManger 是苹果对于命令模式的一种封装，用来撤销历史命令。共有两种撤销操作，简单的以 selector 为基础的撤销和复杂的以 NSInvocation 为基础的撤销。 撤销操作注册一个简单撤销操作我们可以用 registerUndoWithTarget:selector:object: 注册一个撤销操作，保存撤销时会执行的方法和参数： 12345- (void)updateScore:(NSNumber*)score &#123; [undoManager registerUndoWithTarget:self selector:@selector(updateScore:) object:myMovie.score]; [undoManager setActionName:NSLocalizedString(@"actions.update", @"Update Score")]; myMovie.score = score;&#125; 上面将改变前的 myMoview.score 通过撤销方法保存了起来。另外 setActionName: 指定撤销操作的名词。 使用 NSInvocation 注册复杂撤销操作简单撤销不能应对多参数的情况，所以要使用 NSInvocation ，调用 prepareWithInvocationTarget: 记录哪些对象会接收哪些发生改变的消息： 12345678- (void)movePiece:(ChessPiece*)piece toRow:(NSUInteger)row column:(NSUInteger)column &#123; [[undoManager prepareWithInvocationTarget:self] movePiece:piece ToRow:piece.row column:piece.column]; [undoManager setActionName:NSLocalizedString(@"actions.move-piece", @"Move Piece")]; piece.row = row; piece.column = column; [self updateChessboard];&#125; NSUndoManager 对象本身并没有上面的 movePiece:ToRow:column: 方法。是通过 forwardInvocation: 将消息转发至相应对象的。 将动作组合在一起上面只能撤消一个方法，如果要撤销多个操作呢？ 12345678910111213141516171819- (void)readAndArchiveEmail:(Email*)email &#123; [undoManager beginUndoGrouping]; [self markEmail:email asRead:YES]; [self archiveEmail:email]; [undoManager setActionName:NSLocalizedString(@"actions.read-archive", @"Mark as Read and Archive")]; [undoManager endUndoGrouping];&#125;- (void)markEmail:(Email*)email asRead:(BOOL)isRead &#123; [[undoManager prepareWithInvocationTarget:self] markEmail:email asRead:[email isRead]]; [undoManager setActionName:NSLocalizedString(@"actions.read", @"Mark as Read")]; email.read = isRead;&#125;- (void)archiveEmail:(Email*)email &#123; [[undoManager prepareWithInvocationTarget:self] moveEmail:email toFolder:@"Inbox"]; [undoManager setActionName:NSLocalizedString(@"actions.archive", @"Archive")]; [self moveEmail:email toFolder:@"All Mail"];&#125; 通过 beginUndoGrouping 和 endUndoGrouping 将多个分离的撤销操作组合在一起。 实现一次撤销iOS 摇晃手势默认情况下，用户通过摇晃设备来触发撤销操作。如果一个 view controller 需要处理一个撤销请求，那么这个 view controller 必须： 能成为 first responder 一旦页面显示(view appears)，即变成 first responder 一旦页面消失(view disappears)，即放弃 first responder 当 view controller 接收到运动事件，当撤销或重做可用时，系统会展示给用户一个会话界面。View controller 的 undoManager 属性不需要其他操作就可以响应用户的选择。 1234567891011121314151617@implementation ViewController- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; [self becomeFirstResponder];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self resignFirstResponder];&#125;- (BOOL)canBecomeFirstResponder &#123; return YES;&#125;@end 执行撤销执行撤销操作的时候，系统会将撤销栈中的对象 pop 出来，然后执行。通过 undo 方法触发： 123if ([self.undoManager canUndo]) &#123; [self.undoManager undo];&#125; 清空撤销栈有时候我们需要手动清空撤销栈。通常情况下当上下文发生戏剧性变化时，比如说 iOS 上改变了显示的 view controller 或一个打开的文档外部发生了变化。此时，撤销管理器的栈可以通过 removeAllActions 来清空或使用 removeAllActionsWithTarget: 清空某一个对象的所有撤销方法。 撤销与恢复如果有一对相反的方法需要表示既能撤销也能恢复，需要这样使用： 123456789101112131415- (void)addItem:(id)item &#123; [undoManager registerUndoWithTarget:self selector:@selector(removeItem:) object:item]; if (![undoManager isUndoing]) &#123; [undoManager setActionName:NSLocalizedString(@"actions.add-item", @"Add Item")]; &#125; [myArray addObject:item];&#125;- (void)removeItem:(id)item &#123; [undoManager registerUndoWithTarget:self selector:@selector(addItem:) object:item]; if (![undoManager isUndoing]) &#123; [undoManager setActionName:NSLocalizedString(@"actions.remove-item", @"Remove Item")]; &#125; [myArray removeObject:item];&#125; 在恢复中注册撤销，在撤销中注册恢复。这里先判断 isUndoing 其实没有太大必要，去掉也没什么问题。 NSInvocation当我们想要动态调用某一个方法的时候，我们一般会选择 performSelector:withObject:withObject 方法。但是这个方法有一个局限就是最多只能调用含有两个参数的函数: 12NSString *sample = [self performSelector:@selector(append:withStr:) withObject:@"a" withObject:@"b"];==&gt; ab 苹果提供了另外一种方法：NSInvocation。下面介绍一下使用步骤： 提供方法签名首先要获得调用方法的方法签名： 1234//NSObject的对象方法，任何继承自NSObject的对象都可以调用- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector//NSObject的类方法，任何继承自NSObject的类都可以调用+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector 12345NSString *methodNameStr = @"test:withArg2:andArg3:"SEL selector = NSSelectorFromString(methodNameStr);NSMethodSignature *signature = [self methodSignatureForSelector:selector];//或使用下面这种方式NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:selector]; 使用方法签名创建一个 NSInvocation 对象12NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];//只能使用该方法来创建，不能使用alloc init 设置调用对象和调用方法invocation 对象有两个属性，执行对象 target，执行的方法 selector： 12invocation.target = self;invocation.selector = selector; 设置参数使用 setArgument:atIndex: 方法设置参数。参数从2开始，因为0、1被 target 和 selector占用了: 123456NSString *arg1 = @"a";NSString *arg2 = @"b";NSString *arg3 = @"c";[invocation setArgument:&amp;arg1 atIndex:2];[invocation setArgument:&amp;arg2 atIndex:3];[invocation setArgument:&amp;arg3 atIndex:4]; 注意，这里是使用的是参数的引用，传递的是地址。 执行方法直接执行方法： 1[invocation invoke]; 如果方法有返回值呢？在上面的语句执行方法后，我们通过 getReturnValue: 方法拿到返回值： 123456//可以在invoke方法前添加，也可以在invoke方法后添加//通过方法签名的methodReturnLength判断是否有返回值if (signature.methodReturnLength &gt; 0) &#123; id *result = nil; [invocation getReturnValue:&amp;result];&#125; 方法签名有两个只读属性，一个是 numberOfArguments 表示方法参数的个数；还有个就是上面代码涉及的 methodReturnLength 表示方法返回值类型的长度，大于0表示有返回值。 NSJSONSerializationJSON(也就是特定类型的 NSString) 和 NSDictionary、NSArray 之间的转换可以通过 NSJSONSerialization 类进行 JSON(NSString) =&gt; NSDictionary/NSArray先将 JSON 通过 dataUSingEncoding: 转换为 NSData，然后再用通过 NSJSONSerialization 将 NSData 转换为 NSDictionary/NSArray. 12345678910#import "NSString+JSONCategories.h"@implementation NSString(JSONCategories)-(id)JSONValue &#123; NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; NSError *error = nil; id result = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error]; if (error != nil) return nil; return result;&#125;@end 使用： 1234567// 数组NSString *str = @"[&#123; \"id\": \"hu\"&#125;,&#123;\"blog\": \"damon\"&#125;]";NSArray *array = (NSArray*)[str JSONValue];// 字典NSString *str = @"&#123; \"id\": \"hu\",\"blog\": \"damon\"&#125;";NSDictionary *array = (NSDictionary *)[str JSONValue]; 数组的 JSON 是用 [] 包裹起来的。这个例子中每个元素都是单元素的 NSDictionary。字典的 JSON 就是 {} 括起来的键值对。注意由于返回时是 id 类型，不区分具体是 NSDictionary 还是 NSArray，所以要进行类型转换 NSDictionary/NSArray =&gt; JSON(NSString)在 NSObject 中添加分类，先将 NSDictionary/NSArray 转换为 NSData。注意上面使用的方法是 JSONObjectWithData:options:error: 这里是 dataWithJSONObject:options:error:。然后通过 initWithData:encoding: 将 NSData 转为 NSString: 12345678910#import "NSObject+JSONCategories.h"@implementation NSObject (JSONCategories)-(NSString *)JSONString &#123; NSError *error = nil; NSData *result = [NSJSONSerialization dataWithJSONObject:self options:kNilOptions error:&amp;error]; if (error != nil) return nil; return [[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding];&#125;@end NSString 与 NSArray 的互转上面的 JSON 是一种特殊格式的 NSString，所以要借助于 NSJSONSerialization 进行解析。但是如果直接的 NSString 和 NSArray 的互相转换就要简单许多，但是还有注意点. 一般我们把 NSArray 转为 NSString 是直接通过 stringWithFormat: 的形式： 12345NSArray *array = [NSArray arrayWithObjects:@"sss",@"mmm",@"lll",@"kkk",@"ppp",@"ooo", nil];NSString *str1 = [NSString stringWithFormat:@"%@",array];//输出 str1str1 = @"(\n sss,\n mmm,\n lll,\n kkk,\n ppp,\n ooo\n)" 可以看出，这样的转换是有问题的，中间引入了空格，并且两边还有括号没有消除。👇是正确的方式： 12345NSArray *array = [NSArray arrayWithObjects:@"sss",@"mmm",@"lll",@"kkk",@"ppp",@"ooo", nil];NSString *str2 = [array componentsJoinedByString:@","];// 输出 str2 str2 = @"sss,mmm,lll,kkk,ppp,ooo" 通过 NSArray 的方法，将数组中的元素完全拿了出来。 另一方面， NSString 转为 NSArray。通过 NSString 的 componentsSeparatedByString: 方法，识别逗号: 12NSArray *array2 = [str1 componentsSeparatedByString:@","];NSArray *array3 = [str2 componentsSeparatedByString:@","]; 比较输出结果可以发现，str1 无法重新转回最开始的数组了，所以两者互转一定要用 str2 的方式： UIView 中的坐标转换一个 View 的 frame 的起点是相当于其所在的 View，即调用 addSubView: 方法的 View。如果要判断两个 View 是否是包含关系，由于两者的起点不同，那么肯定是无法进行比较的。 123456// rect1和rect2是否有重叠CGRectContainsRect(&lt;#CGRect rect1#&gt;, &lt;#CGRect rect2#&gt;)// point是不是在rect上CGRectContainsPoint(&lt;#CGRect rect#&gt;, &lt;#CGPoint point#&gt;)// rect1是否包含了rect2CGRectIntersectsRect(&lt;#CGRect rect1#&gt;, &lt;#CGRect rect2#&gt;) 为了统一原点，我们可以使用以下代码： 12345- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view; 来举两个例子，注意不同情况下 compareView 和 outerView 的参数位置： 12CGRect newRect = [self.compareView convertRect:self.innerFrame fromView:self.outerView];CGRect newRect = [self.outerView convertRect:self.innerFrame toView:self.compareView]; 得到的就是 innerFrame 在 compareView 中的位置。 UIVisualEffectView 实现高斯模糊如果想要给一个 view 添加一个高斯模糊的效果，只要在那个 view 上添加一个 UIVisualEffectView 即可。 高斯模糊有三种效果，从浅入深的 style 依次是： UIBlurEffectStyleExtraLight UIBlurEffectStyleLight UIBlurEffectStyleDark 使用的基本实例： 123456789101112131415// 要添加模糊的viewUIImageView *imageview = [[UIImageView alloc] init];imageview.frame = CGRectMake(10, 100, 300, 300);imageview.image = [UIImage imageNamed:@"2"];imageview.contentMode = UIViewContentModeScaleAspectFit;imageview.userInteractionEnabled = YES;[self.view addSubview:imageview];// 高斯模糊的viewUIBlurEffect *blur = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];UIVisualEffectView *effectview = [[UIVisualEffectView alloc] initWithEffect:blur];effectview.frame = CGRectMake(0, 0, imageview.size.width/2, 300);// 添加高斯模糊[imageview addSubview:effectview]; UIInterpolatingMotionEffect 视图运动UIInterpolatingMotionEffect 可以通过陀螺仪监测手机的倾斜情况。我们可以通过它设置视图响应的运动。 其中有两个属性：minimumRelativeValue 和 maximumRelativeValue。这两个属性控制图像运动的最大范围。 实例： 1234567891011121314151617CGFloat effectOffset = 100.f;// 设置x方向上的移动量UIInterpolatingMotionEffect *effectX = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];effectX.maximumRelativeValue = @(effectOffset);effectX.minimumRelativeValue = @(-effectOffset);// 设置y方向上的移动量UIInterpolatingMotionEffect *effectY = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];effectY.maximumRelativeValue = @(effectOffset);effectY.minimumRelativeValue = @(-effectOffset);// 将移动量添加到数组中UIMotionEffectGroup *group = [[UIMotionEffectGroup alloc] init];group.motionEffects = @[effectX, effectY];// 设置给 view[self.view addMotionEffect:group]; UISearchController 实现搜索iOS8 之后，苹果提供了 UISearchController 统一了搜索方式。 首先，需要创建一个用来显示搜索结果的视图 SearchResultsController，它需要实现 UISearchResultsUpdating 协议，在 UISearchController 中的搜索关键字变化的时候，会回调 UISearchResultsUpdating 中的 updateSearchResultsForSearchController: 方法执行数据的筛选搜索。所以，SearchResultController 中还需要两个属性，待搜索的所有数据集合和搜索出的数据集合： 12345678910111213class SearchResultsController: UITableViewController,UISearchResultsUpdating &#123; //搜索出和待搜索的数据 var names:[String,[String]] = [String:[String]]() var keys: [String] = [] var filteredNames: [String] = [] func updateSearchResultsForSearchController(searchController: UISearchController) &#123; //搜索过程 ... //筛选出数据后刷新列表 tableView.reloadData() &#125;&#125; 现在要定义一个跳转前的页面。在某个 ViewController 中保存一个 UISearchController 的实例。在初始化 ViewController 的同时，初始化 UISearchController 并拿到 UISearchController 中的 searchBar 的实例，将其添加到 ViewController 的视图中去（为了点击后跳转时，searchBar 的动画效果）。初始化 UISearchController 的时候，将搜索结果展示页 resultsController 传入，并将其赋给 searchResultsUpdater 属性(通过这个属性调用的 updateSearchResultsForSearchController: 方法): 123456789101112131415161718class ViewController: UIViewController &#123; var searchController: UISearchController! ... override func viewDidLoad() &#123; super.viewDidLoad() ... let resultsController = SearchResultsController() resultsController.names = names resultsController.keys = keys searchController = UISearchController(searchResultsController: resultsController) let searchBar = searchController.searchBar searchBar.scopeButtonTitles = ["All","Short"] searchBar.placeholder = "Enter a search item" searchBar.sizeToFit() tableView.tableHeaderView = searchBar searchController.searchResultsUpdater = resultsController &#125;&#125; 其中 scopeButtonTitles 是可选的，在 searchBar 下显示用来进一步筛选的，可以通过 searchController.searchBar.selectedScopeButtonIndex 来获取筛选信息。另外，searchController.searchBar 要确定通过 sizeToFit() 方法确定了大小后，加入到 ViewController 中。 当然，这是最基本的一个流程，还有一些自定义的操作以及一些代理方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些 iOS 小技巧与注意点(持续更新)]]></title>
    <url>%2F2017%2F02%2F09%2FiOS%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这篇中将收集一些关于 iOS 开发中的一些小技巧以及注意事项，可能比较零散。 隐藏Xcode 对于 performSelector 方法的⚠️使用 performSelector 方法，Xcode 会提示会可能产生内存泄漏，可以添加这两句宏在方法上，就不会有⚠️了： 12#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks" 后台任务app进入后台，会停止所有线程；需要在 applicationDidEnterBackground 中调用 beginBackgroundTaskWithExpirationHandler 申请更多的app执行时间，以便结束某些任务: 123456789101112- (void)applicationDidEnterBackground:(UIApplication *)application &#123; _backtaskIdentifier = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^(void)&#123; ... 任何后台任务要做的事 // 取消后台任务，在id不是UIBackgroundTaskInvalid的情况下，通过 endbackgroundTask 停止任务，并将id设置回invalid if (_backtaskIdentifier!=UIBackgroundTaskInvalid) &#123; [[UIApplication sharedApplication] endBackgroundTask:_backtaskIdentifier]; _backtaskIdentifier = UIBackgroundTaskInvalid; &#125; &#125;]; &#125; 其中 _backtaskIdentifier 是 UIBackgroundTaskIdentifier 类型 浏览器缓存策略从浏览器的缓存中可以学到一些有关客户端缓存方案的实现方式 Cache-ControlCache-Control 提供一个 max-age 字段，用于描述过期时间。浏览器是否再次请求数据决定于: 1浏览器当前时间 &gt; 浏览器上次请求时间 + max-age Last-Modified/If-Modified-Since浏览器每次请求后，服务器会返回一个资源在服务端上次更新的时间。下次请求的时候会带上这个时间。如果服务端发现这个时间之后没有更新过资源就会返回 304，让浏览器用本地数据 但是如果碰到某些文件会被定期生成, 而内容其实并没有发生任何变化的情况，这种情况下 Last-Modified改变了, 但这种情况其实应该返回304。因此设计了 ETag 方式。 ETag 用于唯一的标识一个文件。如果两个文件 ETag 相同，那么就表示两个文件是一致的，不会重复返回。 这两种方式： 一种是用于客户端是否要去请求。 一种是用于客户端请求了服务端是否要返回数据。 atomic 与线程安全atomic的原子粒度是Getter/Setter，但对多行代码的操作不能保证原子性： 12345678910111213@property (atomic, assign) int num;// thread Afor (int i = 0; i &lt; 10000; i++) &#123; self.num = self.num + 1; NSLog(@"Thread A: %d\d ",self.num);&#125;// thread Bfor (int i = 0; i &lt; 10000; i++) &#123; self.num = self.num + 1; NSLog(@"Thread B: %d\d ",self.num);&#125; 最终的结果不一定是 20000，因为这个过程包含了，读取 num，给 num 加一，写 num 三个操作。读写是原子性的，但是这三个操作不是原子性的。 __attribute__ 的使用__attribute__ 是编译指令，一般以__attribute__(xxx)的形式出现在代码中，方便开发者向编译器表达某种要求。 constructor__attribute__((constructor)) 加上这个属性的函数会在可执行文件 load 时被调用。可以理解为在 main() 函数调用前执行： 123456789101112131415__attribute__((constructor))static void beforeMain(void) &#123; NSLog(@"beforeMain");&#125;__attribute__((destructor))static void afterMain(void) &#123; NSLog(@"afterMain");&#125;int main(int argc, const char * argv[]) &#123; NSLog(@"main"); return 0;&#125;// Console:// "beforeMain" -&gt; "main" -&gt; “afterMain" constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机： 所有Class都已经加载完成 main 函数还未执行 无需像 +load 还得挂载在一个Class中 section通常情况下，编译器会将对象放置于DATA段的data或者bss节中。但是，有时我们需要将数据放置于特殊的自定义 section 中，此时section可以达到目的。例如，BeeHive中就把module注册数据存在__DATA数据段里面的“BeehiveMods”section中。 1char * kShopModule_mod __attribute((used, section("__DATA,""BeehiveMods"""))) = """ShopModule"""; 其中 used 告诉编译器，即使它没有被使用，也不要优化掉。 nil Null Nil NSNull 区别nil 定义某实例对象为空： 1NSObject* obj = nil; Nil 定义类为空 1Class someClass = Nil; NULL 用于 c 语言数据类型的指针为空： 1char *pointerToChar = NULL; NSNull 是空对象，放在 NSArray 中 12NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];mutableDictionary[@"someKey"] = [NSNull null]; SafeAreaiOS11 提供了 safeAreaLayoutGuide 和 safeAreaInsets 来帮助刘海屏的适配。 前者你可以把它当做是一个 view。我们一般配合 Masonry 使用。Masonry 提供了 mas_safeAreaLayoutGuide，mas_safeAreaLayoutGuideRight/Left/Top/Bottom 来辅助布局： 123456789[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view.mas_safeAreaLayoutGuide).inset(10.0);&#125;];......[rightTopView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.right.equalTo(self.view.mas_safeAreaLayoutGuideRight); make.top.equalTo(self.view.mas_safeAreaLayoutGuideTop); make.width.height.equalTo(@(size));&#125;]; 后者则是一个 inset，适合在 frame 布局的时候使用。但是要注意，safeAreaInsets 是在系统方法 viewSafeAreaInsetsDidChange 之后才会变为正确的值的，所以我们需要在之后的生命周期方法，比如 viewDidLayoutSubviews 方法中设置： 123456789101112131415static inline UIEdgeInsets sgm_safeAreaInset(UIView *view) &#123; if (@available(iOS 11.0, *)) &#123; return view.safeAreaInsets; &#125; return UIEdgeInsetsZero;&#125;- (void)viewDidLayoutSubviews &#123; [super viewDidLayoutSubviews]; UIEdgeInsets safeAreaInsets = sgm_safeAreaInset(self.view); CGFloat height = 44.0; // 导航栏原本的高度，通常是44.0 height += safeAreaInsets.top &gt; 0 ? safeAreaInsets.top : 20.0; // 20.0是statusbar的高度，这里假设statusbar不消失 if (_navigationbar &amp;&amp; _navigationbar.height != height) &#123; _navigationbar.height = height;&#125; UIView 的生命周期1234- (void)didAddSubview:(UIView *)subview;- (void)willRemoveSubview:(UIView *)subview;- (void)willMoveToSuperview:(nullable UIView *)newSuperview;- (void)didMoveToSuperview; willMoveToSuperview 会在添加到父视图和从父视图移除的时候调用，移除的时候参数为 nil（类似于 willMoveToParentViewController） didMoveToSuperview 也比较重要，在这个方法中可以拿到父视图的大小，进行相应的布局 判断是否点击了某个 View123456789- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; UITouch *touch = [touches anyObject]; // 将 touch 转化到 View 的坐标系 CGPoint touchPoint = [touch locationInView:self]; if (CGRectContainsPoint(self.bounds, touchPoint)) &#123; // 点在了 View 中 &#125;&#125; 画一条一个像素的线根据当前屏幕的缩放因子计算出1 像素线对应的Point，然后设置偏移 1234#define SINGLE_LINE_WIDTH (1 / [UIScreen mainScreen].scale)#define SINGLE_LINE_ADJUST_OFFSET ((1 / [UIScreen mainScreen].scale) / 2)UIView *view = [[UIView alloc] initWithFrame:CGrect(x - SINGLE_LINE_ADJUST_OFFSET, 0, SINGLE_LINE_WIDTH, 100)]; iOS设备上，有逻辑像素（point）和 物理像素（pixel)之分。point和pixel的比例是通过[[UIScreen mainScreen] scale]来制定的。在没有视网膜屏之前，1point = 1pixel；但是2x和3x的视网膜屏出来之后，1point等于2pixel或3pixel。 在UI设计师提供的设计稿标注，和在代码中设置frame，其中x,y,width,height的单位是 逻辑像素（point）；GPU在渲染图形之前，系统会将逻辑像素（point）换算成 物理像素（pixel）。 缓存行高在cell离开屏幕后，保存行高： 1234567- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSString *key = [NSString stringWithFormat:@"%ld", (long)indexPath.row]; [self.heightDict setObject:@(cell.height) forKey:key]; DEBUG_LOG(@"第%@行的计算的最终高度是%f",key,cell.height);&#125; 如果已经缓存了行高，那么直接返回高度，否则返回预估行高： 12345678910- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *key = [NSString stringWithFormat:@"%ld",indexPath.row]; if (self.heightDict[key] != nil) &#123; NSNumber *value = _heightDict[key]; DEBUG_LOG(@"%@行的缓存下来的高度是%f",key,value.floatValue); return value.floatValue; &#125; return UITableViewAutomaticDimension;&#125; 部分页面支持旋转在一些视频应用中，播放视频的时候是支持屏幕旋转的，但是其他时候则不支持，iOS 在 UIViewController 中提供了一个方法 supportedInterfaceOrientations()。 当 iOS 设备旋转到一个新的方向时，supportedInterfaceOrientations() 方法就会被调用。如果这个方法的返回值中包含新的方向，应用程序就会旋转当前视图，否则不旋转。每个视图控制器都可以重写这个方法，对于单个试图控制器，可以在特定条件下支持特定的方向。 123override func supportedInterfaceOrientations)_ -&gt; UIInterfaceOrientationMasl &#123; return UIInterfaceOrientationMask(rawValue:(UIInterfaceOrientationMask.portait.rawValue | UIInterfaceOrientationMask.landscapeLeft.rawValue))&#125; 通过 GCD 判断是否是主队列先要明白队列和线程的关系。主线程中除了主队列还有可能运行其他的全局队列。而主队列只会在主线程中运行 关于如何判断是否是主队列，可以使用 GCD： 12345678910BOOL RCTIsMainQueue()&#123; static void *mainQueueKey = &amp;mainQueueKey; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, mainQueueKey, NULL); &#125;); return dispatch_get_specific(mainQueueKey) == mainQueueKey;&#125; 其实就是在主线程中添加了一个 key-value 映射，只有在主线程的情况下，才能拿到这个 key-value 还有一种方式，通过获取当前队列的 label 和 主队列的 label 进行比较： 1dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue()) 模拟器弹出键盘一般情况下，模拟器的输入框是不会弹出键盘的，我们可以设置其为弹出键盘：command+shift+k。其实勾掉了选项中的 connect kardware keyboard： import 尖括号和双引号的区别import “xxx.h”的路径搜索顺序： USE_HEADERMAP USER_HEADER_SEARCH_PATHS HEADER_SEARCH_PATHS import &lt;xxx.h&gt; 的路径搜索顺序： 系统路径 HEADER_SEARCH_PATHS USE_HEADERMAP 是在 Build Settings 中的 Use Header Maps 中设置，默认为 YES，表示系统会自动为编译期提供一个文件映射。我们自己 new 出来的文件就是通过它找到的。 其实就是双引号是自己创建的文件里找，尖括号是从系统的文件里找。没找到的话，都会到 HEADER_SEARCH_PATHS 中找。 Framework Search Paths 和 Header Search Paths一般情况下，直接把文件或者 framework 拖进工程里，并且勾上 copy if needed，不会出现任何问题。但是有时候，我们的头文件或者 framework 并不能直接放到工程里。比如一个 RN 应用，framework 是保存在 RN 的 src 中的某个文件夹内的。这个时候就会出现头文件找不到的问题。 因为通过 copy if needed 添加的文件会被 Xcode 自动添加到 Framework Search Paths 或者 Header Search Paths 里。但是如果不是这种情况，我们就需要手动添加 Search Paths 主工程中引入了目标库，子target没有引入目标库。由于目标库已经在工程中了，因此只要在子target只要设置头文件搜寻地址即可。 以上适用于静态库，对于动态库，主工程中需要引入目标库，子 target 中还需要将动态库通过 Link Binary With Libraries 引入，不用设置头文件搜寻地址了。 为什么不在 iOS 项目中使用 reduxredux 将所有状态组合在一起，配合 react 食用更佳，那么我们为什么不把他使用子啊 iOS 中呢？我想到了两个理由： oc 或者 swift 是强类型语言。如果把状态都放在 store 里维护，意味着 store 里需要 import 各种 model 类。产生强耦合。而 js 则是弱类型。不用在意 store 里的某个属性究竟是什么类型，也就不需要 import 那么多 model。 react 是相应式的，store 里的属性修改了就能反映到 UI 上，但是 iOS 编程不是响应式的，即使 store 里的实行改变了，你还是要使用 setText 等类似方法，刷新 UI。所以即使使用也最好配合 RxSwift 封装原则 明确目标：首先靠考虑好，封装要做什么，不要写着写着换目标。 单一功能原则：其次，要将一个大目标分解成若干步小目标分别实现。然后串联起来 外界知道最少：找出外界必须知道的，作为封装输出 重复代码复用：找出重复代码，塞到封装内 写伪代码：逻辑复杂，不要想着一步到位。先写伪代码，然后把相同的部分归类。 Image.Assets 存放图片和在文件夹里存放的区别Assets.xcassets 一般是以蓝色文件夹形式在工程中，以Image Set的形式管理。当一组图片放入的时候同时会生成描述文件Contents.json。且在打包后以Assets.car的形式存在，以此方式放入的图片并不在mainBundle中，不能使用 contentOfFile 这样的API来加载图片（因为这个方法相当于是去mainBundle里面找图片，但是这些图片都被打包进了Assets.car文件），interface builder中使用图片时不需要后缀和倍数标识（@2x这样的）优点是性能好，节省Disk。 直接拖到文件夹里的图片，都是存在 mainBundle 中的。所以可以使用 contentOfFile 来加载图片。另外我们也可以把资源文件打成一个 bundle，放在主工程下（mainBundle 下）。 copy groups 和 copy folder reference 的区别什么是 GroupGroup 其实是仅在 Xcode 中虚拟的用来组织文件的一种方式, 它对文件系统没有任何影响, 无论你创建或者删除一个 Group, 都不会导致实际的文件的增加或者移除。 两者区别打包的时候， xode 目录下的所有文件，除了 Image.Assets 以及动态库，都会保存到 mainBundle 中去（静态库是在 mainBundle 中的）。以 copy groups 引入的文件，没有文件层级，就相当于直接把 group 里的文件扔到了 mainBundle 中去，而以 copy folder reference 引入的文件会保持文件层级。 Group 在我们的工程中就是黄色的文件夹, 而 Folder 是蓝色的文件夹。 基本类型的指针我们知道，基本类型的变量作为入参传入函数产生改变时不会影响外部的变量值。所以如果不能返回的话，就需要传入一个基本类型的指针： 1234567BOOL roolback = YES;BOOL *r = &amp;roolback;---// 假设传入了某个方法，然后在其中改变了值*r = NO;---NSLog(@"%d，roolback 从1变为了0",roolback); 非基本类型的指针的赋值直接就是 p = Person() 这种地址的赋值就行了，不存在 *p 的情况。基本类型的指针必须通过 *r 拿到堆上的值 `*r = No。 为文本加上下划线基本就是用 NSMutableAttributedString 代替原来的 NSString，然后为文本长度的 range 内添加一个下划线的属性。 下面演示一个为按钮添加下划线: 1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:button.titleLabel.text];NSRange strRange = &#123;0,[string length]&#125;;[string addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInteger:NSUnderlineStyleSingle] range:strRange];[button setAttributedTitle:string forState:UIControlStateNormal]; 如何让 xib 中的两个视图平分父视图说是平分，其实就是两个视图的宽度相同。最开始的办法是设置一个空白视图居于父视图的中间，然后两个视图分别贴着这个空白视图的左右，但是这个方法非常的蠢。其实只要选中两个视图，然后设置为 equal width 就行了，就在设置约束的地方。 VC 中使用 self.view 获取屏幕宽高出错错误描述：在 viewDidLoad 中视图通过 self.view 获取屏幕宽高，但是获取数值有误。 原因：这种情况一般是使用 xib 设置页面的时候出现。使用xib设置页面的时候，选择的是iPhone7的布局，宽度是375.当从 xib 加载页面后，viewDidLoad 时，约束没有更新。所以 self.view 的宽度和高度还是 xib 设计的高宽。要等到 viewDidAppear 时页面约束就会更新。 建议不要在 viewDidLoad 中直接使用 self.view.bounds 的高宽来计算其他属性的 frame。 而是使用 [UIScreen mainScreen].bounds 获取手机屏幕的真实高宽。 如何在二级页面隐藏 tabbar一般会在 TabBarController 中设置多个 NavigationController 作为各个 tab 的 ViewController。我们只要写一个 BaseViewController，在其中重写 pushViewController:animated 方法，在其中判断是否需要隐藏就行。设置 hidesBottomBarWhenPushed 属性来控制在跳转的时候隐藏。123456- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; if (self.viewControllers.count) &#123; viewController.hidesBottomBarWhenPushed = YES; &#125; [super pushViewController:viewController animated:animated];&#125; 如何在 pop 的时候清理资源仍然是在 BaseViewController 中重写 popViewControllerAnimated: 方法。在其中调用特定方法，来做一些清理资源的善后工作。1234567- (UIViewController *)popViewControllerAnimated:(BOOL)animated&#123; if ([[self.viewControllers lastObject] isKindOfClass:[BaseViewController class]]) &#123; BaseViewController *viewController=[self.viewControllers lastObject]; [viewController willPopViewController]; &#125; return [super popViewControllerAnimated:animated];&#125; UIImage 的渲染模式 imageWithRenderingMode:该方法用来设置属性 renderingMode。它使用 UIImageRenderingMode 枚举值来设置图片的 renderingMode 属性。该枚举中包含下列值：123UIImageRenderingModeAutomatic // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。UIImageRenderingModeAlwaysOriginal // 始终绘制图片原始状态，不使用Tint Color。 UIImageRenderingModeAlwaysTemplate // 始终根据Tint Color绘制图片，忽略图片的颜色信息。 应用场景是什么呢？比如设置一个 tabbar 的 UIImage 如果不将其设置为 UIImageRenderingModeAlwaysOriginal。那么图片的选中状态的颜色就会跟随系统的 tintColor。 封装一个没有数据时显示空白页没有数据的时候通常需要显示一个空白页。空白页长得都差不多，基本上都是一段话加上一张图。我们当然不要每次都写一遍这个视图，因此就需要将这些操作放到 base 中去。 在 BaseViewController 中添加一个 reloadDataWithBlank 方法，每次从网络获取完数据后，调用即可（省去了每次都要判断数据是否为空的麻烦）：123456789101112131415161718192021222324- (void)reloadDataWithBlank&#123; //多段就看每个数组，一段就直接看元素个数 if (_isMultiSection) &#123; BOOL isCountZero=YES; for (NSArray *array in self.dataSource) &#123; if (array.count!=0) &#123; isCountZero=NO; break; &#125; &#125; if (isCountZero) &#123; [_tableView addSubview:self.blankHintView]; &#125;else&#123; [self.blankHintView removeFromSuperview]; &#125; &#125;else&#123; if (self.dataSource.count==0) &#123; [_tableView addSubview:self.blankHintView]; &#125;else&#123; [self.blankHintView removeFromSuperview]; &#125; &#125; [_tableView reloadData];&#125; 其中 blankHintView 就是空白提示视图： 1234567891011121314151617181920212223242526272829303132-(UIView *)blankHintView&#123; if (!_blankHintView) &#123; [self initBlankHintView]; &#125; return _blankHintView;&#125;-(void)initBlankHintView&#123; _blankHintView=[[UIView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(self.tableView.width/2-40,self.tableView.height/2-40-30,80,80)]; if (_blankHintImage) &#123; imageView.image = _blankHintImage; &#125;else&#123; imageView.image = [UIImage imageNamed:@&quot;nonetworkdefault&quot;]; &#125; imageView.contentMode=UIViewContentModeScaleAspectFit; UILabel *hintLabel = [[UILabel alloc]initWithFrame:CGRectMake(imageView.x-10, imageView.y+imageView.height, 200, 30)]; hintLabel.numberOfLines = 0; hintLabel.lineBreakMode = NSLineBreakByWordWrapping; hintLabel.textColor=[UIColor colorWithHexString:@&quot;9e9e9e&quot;]; hintLabel.backgroundColor = [UIColor clearColor]; hintLabel.textAlignment=NSTextAlignmentLeft; hintLabel.font=FONT(15); hintLabel.text=_blankHintString; [_blankHintView addSubview:hintLabel]; [_blankHintView addSubview:imageView]; [hintLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(imageView.mas_bottom).offset(0); make.centerX.equalTo(imageView.mas_centerX).offset(0); make.height.equalTo(@30); &#125;];&#125; 每次在 viewDidLoad 中，或者在这个方法内再创建一个功能更明确的 loadDefaultDataSource 方法，在其中中添加默认的 title 和 image 即可。 12345-(void)loadDefaultDataSource&#123; [super loadDefaultDataSource]; self.blankHintImage = [UIImage imageNamed:@&quot;default_nomessage&quot;]; self.blankHintString=@&quot;暂无通知消息&quot;;&#125; 设置手势事件关于手势，通常需要先声明一个手势，再在另一处添加这个手势的处理方法，这样设置事件和方法本身就会分隔开来，回顾代码的时候找起来会很麻烦。可以为 UIView 设置添加一个处理手势的范畴(category)，在其中通过 block 回调的方式将方法保存起来：123456789101112131415161718192021@implementation UIView (BlockGesture) - (void)addTapActionWithBlock:(GestureActionBlock)block&#123; UITapGestureRecognizer *gesture = [self associatedValueForKey:_cmd]; if (!gesture)&#123; gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleActionForTapGesture:)]; [self addGestureRecognizer:gesture]; [self setAssociateValue:gesture withKey:_cmd]; &#125; [self setAssociateCopyValue:block withKey:&amp;kActionHandlerTapBlockKey]; self.userInteractionEnabled = YES;&#125;- (void)handleActionForTapGesture:(UITapGestureRecognizer*)gesture&#123; if (gesture.state == UIGestureRecognizerStateRecognized)&#123; GestureActionBlock block = [self associatedValueForKey:&amp;kActionHandlerTapBlockKey]; if (block)&#123; block(gesture); &#125; &#125;&#125; 先把 gesture 保存起来，再把手势对应的 block 保存起来。使用的时候调用即可：123[label addTapActionWithBlock:^(UIGestureRecognizer *gestureRecoginzer) &#123; ...&#125;]; 图像显示过程与一些注意事项显示过程这里首先强调，这里说的所有都是针对 View 而不是 Controller。 自动布局将视图显示到屏幕上的步骤总共分为三步： 更新约束。它为布局准备好必要的信息，而这些布局将在实际设置视图的 frame 时被传递过去并被使用。你可以通过调用 setNeedsUpdateConstraints 来触发这个操作。谈到自定义视图，可以重写 updateConstraints 来为你的视图的本地约束进行修改（一般不会用啦），但要确保在你的实现中修改了任何你需要布局子视图的约束条件之后，调用一下 [super updateConstraints]。 布局。将约束条件应用到视图上。可以通过重写 layoutSubViews 实现，也就是在调用 [super layoutSubviews] 前修改一些约束信息。可以通过调用 setNeedsLayout 来触发一个操作请求，这并不会立刻应用布局，而是在稍后再进行处理。因为所有的布局请求将会被合并到一个布局操作中去。可以调用 layoutIfNeeded 来强制系统立即更新视图树的布局。 显示。可以通过调用 setNeedsDisplay 来触发，这将会导致所有的调用都被合并到一起推迟重绘。重写熟悉的 drawRect: ，通过这个方法我们可以在 UIView 中绘制图形，比如绘制个角标之类的。 layoutSubViews 的注意事项layoutSubViews 方法给 View 提供了一个统一设置子视图大小布局的地方，不能在 init 方法中。因为当外部创建该 view 时，如果外部调用 init 方法而不是调用 initWithFrame (即没有给这个 view 设置大小），那么 view 中子视图就无法正确初始化出大小。因此，子视图的 bounds 等属性（例如 center 等）的设置必须放在 layoutSubviews 中，即外部 view 大小已经确定，就要显示的时候。 记一个错误容易犯的错误： frame，center 都是相对于父 View 的。所以如果你要让一个子 View 在 父 View 居中，你绝对不能写 subView.center = parentView.center，因为 parentView.center 又是相对于其父 View 的。你应该通过父 View 的 bounds 计算得到: 123- (void)layoutSubViews &#123; subView.center = CGPointMake(self.bounds.size.width/2,self.bounds.size.height/2);&#125; 记另一个容易犯的错误 上面重写了 layoutSubViews 这个方法，并没有调用父类方法 [super layoutSubViews]，那么到底要不要调用呢？答案是最好调用，否则可能会出错。下面简述可能会出错的情况。 比如一个 CollectionViewCell，其中有一层图层 contentView。我们添加的视图一般都是添加在 contentView 上。当 cell 的 bounds 发生变化的时候，contentView 的大小不会立即变化，而是在调用了系统的 [super layoutSubViews] 后才会将 contentView 变为和 cell 一样大。如果你不调用父类方法，那么你就不能将你添加的子视图的位置依赖于 contentView 的 bounds 其实就是系统会在 [super layoutSubViews] 中修改系统自身添加的子视图的位置信息。如果你要用到系统的子视图，你就必须要先调用 [super layoutSubViews] 注意，不是添加子视图。子视图在 init 方法中添加。一定不要在 layoutSubviews 方法中添加子视图。因为 layoutSubviews 方法会被多次调用，不可能每次调用都添加一遍子视图吧。 另外最好不要孤立地改动在 layoutSubviews 中设置过的子视图（比如大小，位置等）。因为 layoutSubviews 会被多次调用。在被调用后，改动又会变回去了。要改动也是要先将要改动的属性保存起来，让 layoutSuibviews 调用的时候通过这个属性设置 View。 这个方法只是在要设置子视图 frame 的时候重写。如果你使用的是 autolayout 来设定位置，那么直接在 init 中设置 constraints 就可以了，因为这个方法会被调用多次，在这个方法里添加约束会导致约束重复添加。 什么时候用 autolayout 什么时候用 frame 就见仁见智了。一般来说只与父视图有关的话，那么就用 frame 设置位置，如果与兄弟视图有关的话，还是用 autolayout 教好一些。 同样的还有 ViewController 的 viewDidLayoutSubviews 方法，这个方法会在 VC 的 view 调用其 layoutSubViews 后调用（相当于调用了 [super layoutSubViews]）。如果要设置 VC 中的视图的 frame，可以考虑在这个方法里设置。但是一般我们都是在 viewDidLoad 方法里设置的无论是 frame 还是 constraint。 frame 修改 AutoLayoutAutoLayout 最后也是将约束设置为要展示的位置信息。所以我们也是可以使用 frame 来改变 autolayout 产生的位置的。但是修改的时机很重要。比如你在 xib 中设置了约束，然后你再 viewDidLoad 方法中修改了某个空间的 frame 那是没有用的。因为，autolayout 的布局，本质上还是 frame 的形式。系统会在 layout subViews 时加载约束信息，将其转换为 frame。所以如果你想改变 autolayout 的布局，你需要在 viewDidLayoutSubviews 中设置 frame 改变约束的注意事项任何地方都能够添加修改约束（包括 init 方法）。但是修改过约束后，并不能触发视图的更新，所以一般要调用 layoutIfNeeded 方法查看更新约束后的视图。更新视图的动画方法一般设置为： 123[UIView animateWithDuration:1.0f delay:0.0f usingSpringWithDamping:0.5f initialSpringVelocity:1 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; [self.view layoutIfNeeded];&#125; completion:NULL]; updateConstraints 的使用时机不要将 updateConstraints 用于视图的初始化设置。当你需要在单个布局流程（single layout pass）中添加、修改或删除大量约束的时候，用它来获得最佳性能。如果没有性能问题，直接更新约束更简单。 如果一定要用这个方法，那么在更新约束之前，请先移除之前设置的约束，否则约束重复了会编译不过的。 移除约束的方法是：[self removeConstraints:self.constraints];。 对于手撸一个 view 来说，一般不用重写 updateConstraints，只有在某些情况要大量修改约束的时候才用到，请把建立 constraints 的工作放在 init 或 viewDidLoad 階段。 关于 drawRectdrawRect 方法通过 CGContextRef context = UIGraphicsGetCurrentContext(); 拿到上下文句柄，然后将自己要画的图形添加到这个上下文上。具体可以在要用的时候看看例子。 设置 view 的一些注意事项 重写 UIView 的 initWithFrame: 而不是 init 方法。 因为当外部调用 init 的方法的时候，其内部也会默默地调用 initWithFrame：方法。 不要在构造方法里面直接取自身(self,或者说本视图)的宽高,这时候取到的宽高是不准的. 当在代码中设置视图和它们的约束条件时候，一定要记得将该视图的 translatesAutoResizingMaskIntoConstraints 属性设置为 NO。如果忘记设置这个属性几乎肯定会导致不可满足的约束条件错误。 在 initWithFrame: 方法中将子控件加到 view 而不是设置尺寸。因为 view 有可能是通过 init 方法创建的，这个时候 view 的 frame 可能是 不确定的。这种情况下各个子控件的尺寸都会是0，因为这个 view 的 frame 还没有设置。设置尺寸的工作放在 layoutSubviews 中去做。 allowsGroupOpacity 属性允许子控件的不透明度继承于其父控件，默认是开启的 yes。不过这会影响性能，自定义控件的时候最好设置为 self.layer.allowsGroupOpacity = NO; clipsToBounds 是 UIView 的属性，如果设置为 yes，则不显示超出父 View 的部分；masksToBounds 是 CALayer 的属性，如果设置为 yes，则不显示超出父 View layer 的部分. 设置视图的时候一定要先设置大小再设置 center ，center 是为了确定 CGRect 的，如果当时CGRect为0，那么此时设置 center，就像当于给 CGRect 设置了 origin。 用 UIImageView 播放动图app 中的加载等候经常需要播放一个动图，那么怎么让图片动起来呢？UIImageView 就能解决。 把所需要的 GIF 打包到一个叫做 Loading 的 Bundle 中去，加载 Bundle 中的图片： 1234567891011121314151617181920212223242526272829- (NSArray *)animationImages&#123; // 拿到所有文件的文件名的数组 NSFileManager *fielM = [NSFileManager defaultManager]; NSString *path = [[NSBundle mainBundle] pathForResource:@"Loading" ofType:@"bundle"]; NSArray *arrays = [fielM contentsOfDirectoryAtPath:path error:nil]; // 遍历文件名，拿到文件名对应的 UIImage 加入到 UIImage 的数组中 NSMutableArray *imagesArr = [NSMutableArray array]; for (NSString *name in arrays) &#123; UIImage *image = [UIImage imageNamed:[(@"Loading.bundle") stringByAppendingPathComponent:name]]; if (image) &#123; [imagesArr addObject:image]; &#125; &#125; return imagesArr;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIImageView *gifImageView = [[UIImageView alloc] initWithFrame:frame]; // 将 UIImage 数组设置给 UIImageView gifImageView.animationImages = [self animationImages]; //获取Gif图片列表 gifImageView.animationDuration = 5; //执行一次完整动画所需的时长 gifImageView.animationRepeatCount = 1; //动画重复次数 [gifImageView startAnimating]; [self.view addSubview:gifImageView];&#125; 获取一个指定的 View想要获取一个指定的 view 的方法是遍历一个 view 的所有 subview，然后判断 view 的类型是否是指定的。在 MBProgressHUD 中的方式是： 123456789+ (MBProgressHUD *)HUDForView:(UIView *)view &#123; NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator]; for (UIView *subview in subviewsEnum) &#123; if ([subview isKindOfClass:self]) &#123; return (MBProgressHUD *)subview; &#125; &#125; return nil;&#125; 这个方法是找到并隐藏相应 hud。这里面使用了 NSEnumerator 这个枚举类，通过 reverseObjectEnumerator 反向浏览集合。 获取当前 ViewController通过 View为了做到数据与视图的分离，我们一般会将一个页面的局部视图以自定义 UIView 的方式独立出来，如果在该视图中有触发事件(事件处理不需要父视图的上下文)，就会遇到在 UIView 中获取 UIViewController 的情况，可以写一个 UIView 的范畴 UIView(UIViewController)： 12345678910111213#pragma mark - 获取当前view的viewcontroller+ (UIViewController *)getCurrentViewController:(UIView *) currentView &#123; for (UIView* next = [currentView superview]; next; next = next.superview) &#123; UIResponder *nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125; 通过 rootViewController1234567891011121314151617181920212223242526- (UIViewController *)findCurrentViewController&#123; UIWindow *window = [[UIApplication sharedApplication].delegate window]; UIViewController *topViewController = [window rootViewController]; while (true) &#123; if (topViewController.presentedViewController) &#123; topViewController = topViewController.presentedViewController; &#125; else if ([topViewController isKindOfClass:[UINavigationController class]] &amp;&amp; [(UINavigationController*)topViewController topViewController]) &#123; topViewController = [(UINavigationController *)topViewController topViewController]; &#125; else if ([topViewController isKindOfClass:[UITabBarController class]]) &#123; UITabBarController *tab = (UITabBarController *)topViewController; topViewController = tab.selectedViewController; &#125; else &#123; break; &#125; &#125; return topViewController;&#125; pop 到指定 ViewControllerUINavigationController 有个 Property，是一个存储所有 push 进 navigationcontroller 的视图的集合，是一个栈结构，当我们要 POP 到某个 ViewController 的时候，直接用 for in 去遍历 viewControllers 即可: 12345for (UIViewController viewController in self.navigationController.viewControllers)&#123; if ([viewController isKindOfClass:[AccountManageViewController class]])&#123; [self.navigationController popToViewController:viewController animated:YES]; &#125;&#125; 一个规范的 ViewController 的代码结构一个 ViewController 中的代码如果不分类，那么查看起来就会非常混乱，经常需要到处跳转。因此写代码的时候按照顺序来分配代码块的位置。先是 life cycle，然后是Delegate方法实现，然后是event response，然后才是getters and setters，用 #pragma mark - 分隔开。这样后来者阅读代码时就能省力很多。 getter和setter全部都放在最后 因为一个ViewController很有可能会有非常多的view，如果getter和setter写在前面，就会把主要逻辑扯到后面去，其他人看的时候就要先划过一长串getter和setter，这样不太好。 每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去 比如UITableViewDelegate的方法集就老老实实写上#pragma mark - UITableViewDelegate。这样有个好处就是，当其他人阅读一个他并不熟悉的Delegate实现方法时，他只要按住command然后去点这个protocol名字，Xcode就能够立刻跳转到对应这个Delegate的protocol定义的那部分代码去，就省得他到处找了。 event response专门开一个代码区域 所有button、gestureRecognizer的响应事件都放在这个区域里面，不要到处乱放。 关于private methods，正常情况下ViewController里面不应该写 不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。对的，正常情况下ViewController里面一般是不会存在private methods的，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。 ViewController基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西能不放在ViewController里面就不要放。另外一点，这个private method的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。 一些宏#define为一段代码设置一个缩写，这段代码可以是一个数字，也可以是一个函数。 1#define SERVER_ONLINE_DEVELOPMENT #if DEBUG通过 Build Configuration 设置调试版本，分为 debug 和 release。正式发行的版本和 release 一致（但是真机调试的时候还是用develop证书）。可以使用预设宏来为开发环境添加一些额外的操作： 12345#if DEBUG#define HttpDefaultURL HttpFormal#else#define HttpDefaultURL HttpSimulation#endif 这样就不用自己设置环境了。 如果要设置非 debug，那么使用 #if !DEBUG #ifdef该宏判断后面的宏是否被定义过： 123#ifdef SERVER_ONLINE_DEVELOPMENT ...#endif 如何定义一个结构使用结构保存多个相关数据。 1234struct Person&#123; float height； int age；&#125;； 使用：struct Person mikey； 使用 typedef 简化。typedef 可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。 1234typedef struct &#123; float height； int age；&#125; Person； 使用，就当做一个普通类型使用： 12Person mikey；mikey.length = 1.45 extern和static我们知道在 @interface...@end,@implementation...@end 之外的是全局变量。OC 提供了两个关键字 static 和 extern 修饰。 static用 static 声明局部变量（定义在方法内），使其变为静态存储方式(静态数据区)，作用域不变（其他方法不能使用），但是延长了生命周期（程序结束才销毁） 用 static 声明外部变量（在方法外），使其只在本文件内部有效，而其他文件不可连接或引用该变量。 变量12// 方法中或者 @implementation...@end 之外static int a = 789; static 可以在任意位置声明。一般我们都将其声明在 .m 文件中。可以声明在方法中，或者 @implementation...@end 之外。 方法123static int method() &#123; return 1;&#125; static 的方法可以放在 @implementation...@end 之内，也可以放在之外。效果都是一样的。 externstatic 修饰的全局变量只能在该文件内访问，那么文件如何访问别的文件定义的全局变量呢？使用 extern 关键字。使用 extern 意味着该变量或者方法在别处实现。(你必须先用 extern 声明一下，这是为了告诉编译器进行全局变量的链接，否则直接编译的时候就会报错。) 如果全局变量和局部变量重名，则在局部变量作用域内，全局变量被屏蔽，不起作用。编程时候尽量不使用全局变量。 变量12345// 任意的某一个 .m 的 @implementation...@end 之外NSString *s = @"global";// 要用到全局变量的 .h 中extern NSString *s; 在任意的一个 .m 中定义一个全局变量。然后要用到这个全局变量的地方使用 extern关键字即可。编译的时候就会链接到这个全局变量。 extern 的变量写在任意位置都是可以的，包括 .h 的 @interface...@end 之内或之外或者.m 的 @implementation...@end 的之内之外。不过推荐写在 .h 的 @interface...@end 之外。 方法1234567// 任意的 .m 中int method() &#123; return 1;&#125;// 要用到的全局变量的 .h 中extern method(); 全局方法写在 .m 的 @implementation...@end 之内还是之外都行，因为这种方式定义的方法就已经表明它是全局方法了。 添加 UIGestureRecognizer 点击事件不响应 设置 UIView 的 userInteractionEnabled 属性值为 YES，否则 UIView 会忽略那些原本应该发生在其自身的诸如 touch 和 keyboard 等用户事件，并将这些事件从消息队列中移除出去。 循环创建对象的时候，不能只创建一个 UIGestrueRecognizer，而要在每个循环里为每个 UIView 创建并添加 UITapGestureRecognizer 。 父view 太小，子view 通过 addSubView 的方式添加到父view 外部，导致响应链无法传递到子 view 中，无法响应 UIGestureRecognizer（被这个坑过很久） 倒计时按钮（每秒触发）通过 gcd 设置一个每秒都会触发执行的队列，然后自己控制时间，何时退出。 1234567891011121314151617181920212223242526272829303132333435363738// 开启倒计时效果-(void)openCountdown&#123; __block NSInteger time = 59; //倒计时时间 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^&#123; if(time &lt;= 0)&#123; //倒计时结束，关闭 dispatch_source_cancel(_timer); dispatch_async(dispatch_get_main_queue(), ^&#123; //设置按钮的样式 [self.authCodeBtn setTitle:@"重新发送" forState:UIControlStateNormal]; [self.authCodeBtn setTitleColor:[UIColor colorFromHexCode:@"FB8557"] forState:UIControlStateNormal]; self.authCodeBtn.userInteractionEnabled = YES; &#125;); &#125;else&#123; int seconds = time % 60; dispatch_async(dispatch_get_main_queue(), ^&#123; //设置按钮显示读秒效果 [self.authCodeBtn setTitle:[NSString stringWithFormat:@"重新发送(%.2d)", seconds] forState:UIControlStateNormal]; [self.authCodeBtn setTitleColor:[UIColor colorFromHexCode:@"979797"] forState:UIControlStateNormal]; self.authCodeBtn.userInteractionEnabled = NO; &#125;); time--; &#125; &#125;); dispatch_resume(_timer);&#125; 注意： 我们在创建Button时, 要设置Button的样式:当type为: UIButtonTypeCustom时 , 是读秒的效果.当type为: 其他时, 是一闪一闪的效果. 获取float的前两位小数当我们直接把 float 转为 NSString 会发现小数点后有很多小数，可以按照需求截取几位小数： 1NSString *strDistance=[NSString stringWithFormat:@"%.xf", kilometers]; //x表示具体显示多少位 ​]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIAlertController 使用简介]]></title>
    <url>%2F2017%2F02%2F07%2FAlertController%2F</url>
    <content type="text"><![CDATA[UIAlertController 是 iOS 8 中推出的新特性，用以代替 UIAlertView 和 UIActionSheet。下面学习一下它的 api 的使用。内容很基础，只是当做备忘。 UIAlertController 定义了一个枚举类型用以区分 UIAlertView 和 UIActionSheet： 1234typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123; UIAlertControllerStyleActionSheet = 0, UIAlertControllerStyleAlert&#125; NS_ENUM_AVAILABLE_IOS(8_0); API列举一下在 UIAlertController 中使用的 API： 12345678//Create UIAlertController+ (instancetype)actionWithTitle:(NSString *)title style:(UIAlertActionStyle)style handler:(void (^)(UIAlertAction *action))handler;//Adding an action- (void)addAction:(UIAlertAction *)action; //Adding text filed to UIAlertController.This method is supported only for UIAlertControllerStyleAlert- (void)addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler; 创建一个基本的对话框1234UIAlertController * alert= [UIAlertController alertControllerWithTitle:@"My Title" message:@"Enter User Credentials" preferredStyle:UIAlertControllerStyleAlert];[self presentViewController:alert animated:YES completion:nil]; 很容易理解的方法调用。由于是一个 Controller，所以使用 presentViewController 方法将 View 显示出来。此时的 View 还没有点击按钮。 创建一个带两个选项按钮的对话框在上面的基础上，添加 OK/Cancel 按钮，并设置点击方法。这就需要我们设置一个 action ，然后把它添加到 UIAlertController 中。这里只演示了一下 OK 的情况，Cancel 同理。记得和上面合并的时候要把 presentViewController:animated:completion: 方法写在最后啊。 1234567UIAlertAction* ok = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * action)&#123; //Do some thing here [alert dismissViewControllerAnimated:YES completion:nil]; &#125;];[alert addAction:ok]; // add action to uialertcontroller 这里面的 style 是一个枚举类型： 12345typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123; UIAlertActionStyleDefault = 0, UIAlertActionStyleCancel, UIAlertActionStyleDestructive &#125; NS_ENUM_AVAILABLE_IOS(8_0); 在 AlertView 中的 UIAlertActionStyleCancel 是红色，UIAlertActionStyleDestructive 是加粗。 创建一个带 textInput 的对话框12345678[alert addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123; textField.placeholder = @"Username";&#125;];[alert addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123; textField.placeholder = @"Password"; textField.secureTextEntry = YES;&#125;]; 添加了一个输入框和一个密码输入框。可以设置 textField 的一些属性。 创建一个 ActionSheet123456789101112131415161718UIAlertController * view= [UIAlertController alertControllerWithTitle:@"My Title" message:@"Select you Choice" preferredStyle:UIAlertControllerStyleActionSheet];UIAlertAction* ok = [UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * action)&#123; //Do some thing here [view dismissViewControllerAnimated:YES completion:nil]; &#125;];UIAlertAction* cancel = [UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleDefault handler:^(UIAlertAction * action)&#123; [view dismissViewControllerAnimated:YES completion:nil]; &#125;];[view addAction:ok];[view addAction:cancel];[self presentViewController:view animated:YES completion:nil]; 这里的 style 如果是 UIUIAlertActionStyleCancel 那么就会自动放在最底下；如果是 UIAlertActionStyleDestructive 就会变成红色。 UIAlertView 和 UIAlertController 的区别 UIAlertView :iOS 系统为了保证 UIAlertView 在所有界面之上，它会临时创建一个新的 UIWindow，通过将 UIWindow 的 UIWindowLevel 设置的更高，让 UIAlertView 盖在所有应用的界面之上。 UIAlertController:继承自 UIViewController，它采用一个 UIPopoverPresentationController 类进行管理，UIPopoverPresentationController 又继承自 UIPresentationController，其中的presentingViewController 属性表示展示之前的 Controller，presentedViewController 属性表示被展示的Controller。另外这种方式，也统一了iPhone和iPad的使用方式 自定义的 UIAlertController如果系统的提示框不能满足业务需求，就需要自定义。最方便的方式还是在当前的 UIWindow 上添加视图。不过我们还是以 ViewController 的方式创建。 但是当你把 UIViewController 的背景色设为透明，然后 present 的时候，会发现页面是黑色的。这是因为 present 出来的 viewController 表面上看起来是盖在了原有界面的上面，但那其实只是个动画，最终实际上是替换掉了，所以设置透明以后会导致下面没有东西所以就变成黑色了。 我们需要设置 ViewController 的 modalPresentationStyle 属性为 UIModalPresentationOverCurrentContext，表示 present 出来的 ViewController 是盖在之前的 ViewController 上的。注意，不能再 viewDidload 中设置, 必须在初始化的时候设置好,然后再 present： 123MyAlertViewController *alertViewController = [MyAlertViewController alloc] init];modalPresentationStyle = UIModalPresentationOverCurrentContext;[self presentViewController: alertViewController animated: false]; 这种方式禁掉了动画，如果需要过渡效果，可以自定义 ViewController 的 modal 动画实现。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富文本AttributedString 使用小结]]></title>
    <url>%2F2017%2F02%2F07%2F%E5%AF%8C%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[暂时没有需要深入应用就不细写了 AttributedString可以分为 NSAttributedString 和 NSMutableAttributedString 两种。在使用中通过将 AttributedString 赋值给控件的 attributedText 属性来添加文字样式。有属性的控件有 UILabel、UITextField 和 UITextView。 使用方式方式一初始化一个 NSMutableAttributedString，然后向里面添加文字样式，将其赋给控件的 attributedText 属性。 例子： 12345678910111213141516171819202122NSString *str = @"人生若只如初见，何事悲风秋画扇。\n等闲变却故人心，却道故人心易变。\n骊山语罢清宵半，泪雨霖铃终不怨。\n何如薄幸锦衣郎，比翼连枝当日愿。";//创建NSMutableAttributedStringNSMutableAttributedString *attrStr = [[NSMutableAttributedString alloc]initWithString:str];//设置字体和设置字体的范围[attrStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30.0f] range:NSMakeRange(0, 3)];//添加文字颜色[attrStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(17, 7)];//添加文字背景颜色[attrStr addAttribute:NSBackgroundColorAttributeName value:[UIColor orangeColor] range:NSMakeRange(17, 7)];//添加下划线[attrStr addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInteger:NSUnderlineStyleSingle] range:NSMakeRange(8, 7)];UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(60, 100, 200, 0)];label.backgroundColor = [UIColor greenColor];//自动换行label.numberOfLines = 0;//设置label的富文本label.attributedText = attrStr;//label高度自适应[label sizeToFit];[self.view addSubview:label]; 方式二创建属性字典，并将各种属性初始化。赋值，并利用方法 appendAttributedString: 添加入 NSMutableAttributedString，将其赋给控件的 attributedText 属性。 例子： 1234NSString *str51 = @"\n设置删除线为细单实线,颜色为红色";NSDictionary *dictAttr51 = @&#123;NSStrikethroughStyleAttributeName:@(NSUnderlineStyleSingle),NSStrikethroughColorAttributeName:[UIColor redColor]&#125;;NSAttributedString *attr51 = [[NSAttributedString alloc]initWithString:str51 attributes:dictAttr51];[attributedString appendAttributedString:attr51]; 富文本有许多可以设置的属性，我就不一一列举了。如果用到再 google 就可以了。至于图文混排之类的也是用到再说吧。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FDFullScreenPopGesture 源码解析]]></title>
    <url>%2F2017%2F02%2F06%2FFDFullScreenPopGesture_%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FDFullScreenPopGesture 是一个非常小巧精悍，却又功能强大的开源项目。主要的功能有：全局的手势回退；部分界面的 NavigationBar 的隐藏。今天花了半天的时间搞明白了其中的原理。 iOS 原生的返回手势的起始滑动点必须靠近屏幕的左方，无法实现全屏返回。我们可以给控制器的 view 添加手势来控制它的 frame。但是那样需要自己控制动画，自己控制 NavigationBar ，非常麻烦。FDFullScreenPopGesture 通过一种优雅的方式解决了这个问题。并且顺带实现了部分控制器隐藏 NavigationBar 的功能。 总体解构整个 FDFullScreenPopGesture 总共分为四个部分： _FDFullscreenPopGestureRecognizerDelegate UIViewController (FDFullscreenPopGesturePrivate) UIViewController (FDFullscreenPopGesture) UINavigationController (FDFullscreenPopGesture) _FDFullscreenPopGestureRecognizerDelegate这个类只有一个方法，就是实现了 UIGestureRecognizerDelegate 的代理方法 gestureRecognizerShouldBegin:。用来控制是否开始手势操作。 123456789101112131415161718192021222324252627282930313233- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer&#123; // Ignore when no view controller is pushed into the navigation stack. if (self.navigationController.viewControllers.count &lt;= 1) &#123; return NO; &#125; // Ignore when the active view controller doesn't allow interactive pop. UIViewController *topViewController = self.navigationController.viewControllers.lastObject; if (topViewController.fd_interactivePopDisabled) &#123; return NO; &#125; // Ignore when the beginning location is beyond max allowed initial distance to left edge. CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view]; CGFloat maxAllowedInitialDistance = topViewController.fd_interactivePopMaxAllowedInitialDistanceToLeftEdge; if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123; return NO; &#125; // Ignore pan gesture when the navigation controller is currently in transition. if ([[self.navigationController valueForKey:@"_isTransitioning"] boolValue]) &#123; return NO; &#125; // Prevent calling the handler when the gesture begins in an opposite direction. CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view]; if (translation.x &lt;= 0) &#123; return NO; &#125; return YES;&#125; 总共在5中情况下，不能全屏幕返回： 整儿 NavigationController 中只有一个 ViewController 的时候 当前的 ViewController 禁用了 fd_interactivePopDisabled（这个在 UINavigationController (FDFullscreenPopGesture) 中设置的） 当前手势的启动点距离左边缘远过了 fd_interactivePopMaxAllowedInitialDistanceToLeftEdge（同上，也是自己设置的） 当前是否在转场过程中。这里通过 KVC 拿到了 NavigationController 中的 _isTransitioning 属性 手势运动方向是否是从右往左 UIViewController (FDFullscreenPopGesturePrivate)如果你对 runtime 比较熟悉，那么看到这个类一定非常亲切。这个方法在 load 方法的时候，通过 Method Swizzling 用 fd_viewWillAppear: 方法，替换了原来的 viewWillAppear: 方法。 123456789- (void)fd_viewWillAppear:(BOOL)animated&#123; // Forward to primary implementation. [self fd_viewWillAppear:animated]; if (self.fd_willAppearInjectBlock) &#123; self.fd_willAppearInjectBlock(self, animated); &#125;&#125; 这个替换的方法没什么特别的，就是在其中插入了自己的回调块 fd_willAppearInjectBlock ，该块在 UINavigationController (FDFullscreenPopGesture) 中定义并设置。该块用来设置 NavigationBar 的显示与隐藏。 UIViewController (FDFullscreenPopGesture)这个类中定义了3个属性，上面用到了两个 fd_interactivePopDisabled，fd_interactivePopMaxAllowedInitialDistanceToLeftEdge 还有一个 fd_prefersNavigationBarHidden 属性用于判断是否隐藏 NavigationBar 上面的 fd_willAppearInjectBlock 中用到。 12345678910111213141516@interface UIViewController (FDFullscreenPopGesture)/// Whether the interactive pop gesture is disabled when contained in a navigation/// stack.@property (nonatomic, assign) BOOL fd_interactivePopDisabled;/// Indicate this view controller prefers its navigation bar hidden or not,/// checked when view controller based navigation bar's appearance is enabled./// Default to NO, bars are more likely to show.@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;/// Max allowed initial distance to left edge when you begin the interactive pop/// gesture. 0 by default, which means it will ignore this limit.@property (nonatomic, assign) CGFloat fd_interactivePopMaxAllowedInitialDistanceToLeftEdge;@end UINavigationController (FDFullscreenPopGesture)这个方法是整个项目的逻辑的核心，首先还是在 load 方法中用 fd_pushViewController:animated: 方法替换了系统自身的 pushViewController:animated: 方法。该方法如下： 1234567891011121314151617181920212223242526- (void)fd_pushViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; if (![self.interactivePopGestureRecognizer.view.gestureRecognizers containsObject:self.fd_fullscreenPopGestureRecognizer]) &#123; // 1. [self.interactivePopGestureRecognizer.view addGestureRecognizer:self.fd_fullscreenPopGestureRecognizer]; // 2. NSArray *internalTargets = [self.interactivePopGestureRecognizer valueForKey:@"targets"]; id internalTarget = [internalTargets.firstObject valueForKey:@"target"]; SEL internalAction = NSSelectorFromString(@"handleNavigationTransition:"); self.fd_fullscreenPopGestureRecognizer.delegate = self.fd_popGestureRecognizerDelegate; [self.fd_fullscreenPopGestureRecognizer addTarget:internalTarget action:internalAction]; // 3. self.interactivePopGestureRecognizer.enabled = NO; &#125; // 4. [self fd_setupViewControllerBasedNavigationBarAppearanceIfNeeded:viewController]; // Forward to primary implementation. if (![self.viewControllers containsObject:viewController]) &#123; [self fd_pushViewController:viewController animated:animated]; &#125;&#125; 先看第一步，在 interactivePopGestureRecognizer 的 view 上添加一个 UIPanGestureRecognizer。这个 interactivePopGestureRecognizer 是什么呢？ 这是控制界面在边缘处滑动返回的手势。这是一个只读的属性，我们当然不能直接设置它，拿到它是为了通过它拿到该手势所在的 view，在 view 中保存了一个 _gestureRecognizers 的数组。试想一下，如何判断是否需要 pop 呢？就是通过拿到 view 中的 _gestureRecognizers ，再调用每个手势的 UIGestureRecognizerDelegate 中的 gestureRecognizerShouldBegin方法是否返回yes。这里苹果之所以把_gestureRecognizers` 设置为数组，可能是为了以后更易拓展吧。当然，这也方便了我们的拓展。 第二步将自己添加的手势设置成与原生手势相同，包括一个 target 和一个 action，这样两个手势的动画以及触发方法就一模一样了。 第三步将原来的手势禁用。 第四步设置上面说过的 _FDViewControllerWillAppearInjectBlock 。也就是通过 fd_prefersNavigationBarHidden 来显示和隐藏 NavigationBar。 总结主要复习了一下 method swizzling 的使用，可以很优雅地修改特定的方法。 另外，虽然苹果没开源，但还是通过获取到了系统类中的私有方法。这给我们提供了一个思路。我们也可以通过调试，来查看各个隐藏的变量。不过有一点要小心：系统类内定义的一些 property 只是定义同名的 get set 方法，但是实际存储的变量名并不和 property 名相同，变量存储的位置也不能完全确定。比如上面 UINavigationController 的 interactivePopGestureRecognizer 属性，被保存在 UINavigationController 中的 __cachedInteractionController 之下，名为 _edgePanRecognizer，如果自己找起来的话，真的困难。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 的各种定时器]]></title>
    <url>%2F2017%2F02%2F03%2FiOS%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这篇将探究一下 iOS 上的四种定时器的实现 NSTimer一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 创建有两种创建方式，方法一： 12345self.timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(showTime) userInfo:nil repeats:YES];// 必须加[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];// 如果是非主线程要调用,主线程已经自动运行 runloop 就不需要自己 run 了[[NSRunLoop currentRunLoop] run]; 这个类方法创建出来的对象如果不用 addTimer: forMode 方法手动加入循环池中，将不会循环执行。 这里如果不是用的 NSRunLoopCommonModes 而是 NSDefaultRunLoopMode 那么当界面滑动时，无法执行 showTime 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。 方法二： 123456self.timer = [NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@"abc" repeats:NO];// 下面这两句用来修改模式，如果不想修改默认模式，可以不加[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];// 如果是非主线程要调用,主线程已经自动运行 runloop 就不需要自己 run 了[[NSRunLoop currentRunLoop] run]; 这个方法会将定时器添加到当前的运行循环，运行循环的模式为默认模式。虽然指定了默认模式，但是还是允许你修改模式的。 和 CADisplayLink 一样，NSTimer 也需要手动取消定时器： 123//取消定时器 [self.timer invalidate]; self.timer = nil; NSRunLoop 会强引用 NSTimer，所以外部不需要强引用 timer。 执行N次后结束可以在外部创建一个计数器，当执行到一定次数后在内部结束： 123456789var runCount = 0Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) &#123; timer in print("Timer fired!") runCount += 1 if runCount == 3 &#123; timer.invalidate() &#125;&#125; 附加 context创建 timer 时传入的 userInfo 是一个 id 类型。所以可以直接通过 timer 拿到 userInfo 代表的值，需要强转类型： 123456789101112131415let context = ["user": "@twostraws"]Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(fireTimer), userInfo: context, repeats: true)@objc func fireTimer(timer: Timer) &#123; guard let context = timer.userInfo as? [String: String] else &#123; return &#125; let user = context["user", default: "Anonymous"] print("Timer fired by \(user)!") runCount += 1 if runCount == 3 &#123; timer.invalidate() &#125;&#125; NSTimer 不准时NSTimer 是由 RunLoop 控制执行的，当到达时间后，会触发睡眠的 RunLoop 执行定时器方法。但是如果当前 RunLoop 一直在运行，则无法立刻执行定时器方法，导致延时执行。 CADisplayLink基本用法CADisplayLink 是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink 以特定模式注册到 runloop 后， 每当屏幕显示内容刷新结束的时候， runloop 就会向 CADisplayLink 指定的 target 发送一次指定的 selector 消息， CADisplayLink 类对应的 selector 就会被调用一次。 使用方式： 1234567891011121314151617181920- (void)startDisplayLink&#123; self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; self.displayLink.frameInterval = 3; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];&#125;- (void)handleDisplayLink:(CADisplayLink *)displayLink&#123; //do something&#125;- (void)stopDisplayLink&#123; // 注意，下面两步都要做。先从 runloop 里注销 displaylink。再将 displaylink 置为 nil,防止你对已经 invalidate 的对象进行操作。 [self.displayLink invalidate]; self.displayLink = nil;&#125; 当把 CADisplayLink 对象 add 到 runloop 中后（一定要加啊，否则无效），selector就能被周期性调用，类似于 NSTimer 被启动了；执行 invalidate 操作时， CADisplayLink 对象就会从 runloop 中移除，selector 调用也随即停止，类似于 NSTimer 的 invalidate 方法。 iOS 设备的 FPS 是60Hz，因此 CADisplayLink 的 selector 默认调用周期是每秒60次，这个周期可以通过 frameInterval 属性设置， CADisplayLink的 selector 每秒调用次数为 60/ frameInterval。比如当 frameInterval 设为2，每秒调用就变成30次。因此， CADisplayLink 周期的设置方式略显不便。不过 CADisplayLink 适合于需要精度较高的定时。 NSRunLoop 会强引用 CADisplayLink，所以外部也不需要强引用 CADisplayLink 应用之查看 FPSCADisplayLink 和屏幕的刷新率是一致的，所以可以通过判断一秒钟内 CADisplayLink 执行了多少次来间接知道屏幕刷新率： 与 NSTimer 不同iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。 可以通过 CADisplayLink 和上面的绘图，完成很多动画效果 延迟调用当调用 NSObject 的 performSelector:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效（注意，这是一个考点，所以在子线程中直接调用该方法是无效的）。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。 所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 [[NSRunLoop currentRunLoop] run]; 1234// 3秒后自动调用self的run:方法，并且传递参数：@"abc"[self performSelector:@selector(run:) withObject:@"abc" afterDelay:3];// 在子线程中创建的时候，要开启子线程的 runloop[[NSRunLoop currentRunLoop] run]; 本质上就是一个 NSTimer GCD123456789101112131415161718192021222324252627282930/** 创建定时器对象 * para1: DISPATCH_SOURCE_TYPE_TIMER 为定时器类型 * para2-3: 中间两个参数对定时器无用 * para4: 最后为在什么调度队列中使用 */dispatch_source_t _gcdTimer; //(不是指针)_gcdTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));/** 设置定时器 * para2: 任务开始时间 * para3: 任务的间隔 * para4: 可接受的误差时间，设置0即不允许出现误差 * Tips: 单位均为纳秒 */dispatch_source_set_timer(_gcdTimer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);/** 设置定时器任务 * 可以通过block方式 * 也可以通过C函数方式 */dispatch_source_set_event_handler(_gcdTimer, ^&#123; static int gcdIdx = 0; NSLog(@"GCD Method: %d", gcdIdx++); NSLog(@"%@", [NSThread currentThread]); if(gcdIdx == 5) &#123; // 终止定时器 dispatch_suspend(_gcdTimer); &#125;&#125;);// 启动任务，GCD计时器创建后需要手动启动dispatch_resume(_gcdTimer); GCD 是准时的定时器 注意 dispatch_source_t 并不是一个指针 dispatch_source_t 本身需要强引用，否则会立刻回收，无法完成定时 关于 runloop我们可以观察到，除了 GCD，另外三种方法都需要把定时器加入当前 runloop 中。这里要强调一点，一般情况下，不要把定时器加到非主线程中去。因为定时器需要线程的 runloop 启动，即 [[NSRunLoop currentRunLoop] run];。对于主线程，这没有任何问题，主线程的 runloop 默认开启。但是对于子线程，我们最好不要启动它的 runloop，这会导致子线程一直处于活动状态而不被回收，从而造成内存泄漏。所以，定时器最好还是加在主线程里吧。如果一定要在子线程里设置，那么一定要在结束的时候，停止运行循环。 关于循环引用问题定时器包括 CADisplayLink 和 NSTimer 都需要手动通过 invalidate 方法来销毁。这就关系到销毁的时机。 方式一通过 dealloc 方法销毁： 错误的做法： 1234567__weak typeof(self) wself = self;self.displayLink = [CADisplayLink displayLinkWithTarget:wself selector:@selector(selector)];[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];- (void)dealloc &#123; [self.displayLink invalidate];&#125; 上面这种弱引用方式是没有用的。因为它们内部会强引用 target。所以其实不会执行 dealloc 方法。 为了打破这种强引用，我们可以新建一个 weakTarget 的类，通过转发实现： 1234567891011121314// class WeakTarget@property (nonatomic, weak) id target;- (instancetype)initWithTarget:(id)target &#123; self = [super init]; if (self) &#123; self.target = target; &#125; return self;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return self.target;&#125; 使用： 123456self.displayLink = [CADisplayLink displayLinkWithTarget:[[WeakTarget alloc] initWithTarget:self] selector:@selector(selector)];[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];- (void)dealloc &#123; [self.displayLink invalidate];&#125; 这样，timer 强引用的就不是我们业务相关的类了。 方式二通过 VC 或者 View 的生命周期销毁。虽然强引用了不会调用 dealloc ，但是生命周期还是会回调的比如在 viewWillDisappear 或者 removeFromSuperView 等方法中。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 持久化方式]]></title>
    <url>%2F2017%2F02%2F03%2FiOS%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[开发的时候总是要保存一些东西在磁盘上的，那么有哪些方式来完成持久化呢？ NSUserDefaults对于应用来说，每个用户都有自己的独特偏好设置，而好的应用会让用户根据喜好选择合适的使用方式，把这些偏好记录在应用包的 plist 文件中，通过 NSUserDefaults 类来访问，这是 NSUserDefaults 的常用姿势。如果有一些设置你希望用户即使升级后还可以继续使用，比如玩游戏时得过的最高分、喜好和通知设置、主题颜色甚至一个用户头像，那么你可以使用 NSUserDefaults 来存储这些信息。 使用方法NSUserDefaults 是 iOS 系统提供的一个单例类，通过类方法 standardUserDefaults 可以获取 NSUserDefaults 单例: 1NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSUserDefaults 单例以 key-value 的形式存储了一系列偏好设置，key 是名称，value 是相应的数据。存/取数据时可以使用方法 objectForKey: 和 setObject:forKey: 来把对象存储到相应的 plist 文件中，或者读取，既然是 plist 文件，那么对象的类型则必须是 plist 文件可以存储的类型，包括： NSData NSString NSNumber NSDate NSArray NSDictionary 而如果需要存储 plist 文件不支持的类型，比如图片，可以先将其归档为 NSData 类型，再存入 plist 文件，需要注意的是，即使对象是 NSArray 或 NSDictionary ，他们存储的类型也应该是以上范围包括的。 一些方法NSUserDefaults 提供了若干简便方法可以存储某些常用类型的值，例如： 123456- setBool:forKey:- setFloat:forKey:- setInteger:forKey:- setDouble:forKey:- setURL:forKey:- setObject:forKey: 这里只列举了几个 set 方法。诸如 NSString,NSData,NSArray,NSDictionary 等都使用 setObject:forKey: 方法设置。 123456789- boolForKey:- floatForKey:- integerForKey:- doubleForKey:- urlForKey:- stringForKey:- dataForKey:- arrayForKey:- dictionaryForKey: 需要注意，这里方法不是一一对应的，上面使用 setObject:forKey: 的，在获取的时候，都使用了具体的类型，读取的时候最好使用明确类型的方法，而不是 objectForKey:. 使用获取方法的时候一定要用明确类型的方法，否则会产生不已排查的意想不到的错误！！！ 举例存一个整数、字符串和一张图片： 123456789NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];//字符串[defaults setObject:@"jack" forKey:@"firstName"];//整数[defaults setInteger:10 forKey:@"Age"];//图片UIImage *image =[UIImage imageNamed:@"somename"];NSData *imageData = UIImageJPEGRepresentation(image, 1);//把image归档为NSData[defaults setObject:imageData forKey:@"image"]; UIImageJPEGRepresentation 有两个实参，一个是 UIImage，另一个是浮点数变量，代表压缩质量。压缩质量的值必须在0到1之间，1代表最高质量即不压缩。 对应的读取方法： 12345678NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];//字符串NSString *firstName = [defaults objectForKey:@"firstName"]//数字NSInteger age = [defaults integerForKey:@"Age"];//图片NSData *imageData = [defaults dataForKey:@"image"];UIImage *image = [UIImage imageWithData:imageData]; plist 的使用上面的 NSUserDefaults 是基于 plist 的。可以用来存储城市列表等类似数据。那么如何直接操作 plist 呢？ 写入通过 writeToFile:atomically: 上面提到的 plist 能够存储的类型都有这个方法。 123456789//获取应用程序沙盒的Documents目录 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath1 = [paths objectAtIndex:0]; //得到完整的文件名 NSString *filename=[plistPath1 stringByAppendingPathComponent:@"test.plist"]; //输入写入 data 是个 dictionary[data writeToFile:filename atomically:YES]; 读取通过 initWithContentsOfFile: 方法初始化读取，上面提到的类型都有该方法： 123//那怎么证明我的数据写入了呢？读出来看看 //这里的 filename 是完整的路径和文件名NSMutableDictionary *data1 = [[NSMutableDictionary alloc] initWithContentsOfFile:filename]; 归档协议归档可以实现对非上述类型对象的存储。但是必须遵守 NSCoding 协议。该协议有两个方法： 123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)aDecoder;@end 实现实例： 123456789101112131415161718192021222324252627282930313233343536373839//.h文件#import &lt;Foundation/Foundation.h&gt;// 给自定义类归档，首先要遵守NSCoding协议。@interface Person : NSObject&lt;NSCoding&gt;@property (nonatomic,strong) NSString *name;@property (nonatomic,assign) NSInteger age;@property (nonatomic,strong) NSString *gender;@end //.m文件#import "Person.h"@implementation Person// 归档方法- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeInteger:self.age forKey:@"age"]; [aCoder encodeObject:self.gender forKey:@"gender"];&#125;// 反归档方法- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; if (self != nil) &#123; self.name = [aDecoder decodeObjectForKey:@"name"]; self.age = [aDecoder decodeIntegerForKey:@"age"]; self.gender = [aDecoder decodeObjectForKey:@"gender"]; &#125; return self;&#125;@end 这里可以在使用的时候，通过代码提示选取合适的 encode 和 decode 方法。 如此就能对 Person 对象进行归档了。当然这种归档方法非常傻瓜。因为每一个属性都要设置一次 encode 和 decode。我们可以通过 runtime，实现自动归档。具体的实现方法在 “runtime 应用” 一篇有说明。 使用对于所有系统类型（NSString、NSDictionary、NSArray、NSNumber等）以及所有实现了上面协议的类型，通过下面两个方法编码（NSKeyedArchiver）和解码（NSKeyedUnarchiver） 12BOOL success = [NSKeyedArchiver archiveRootObject:data toFile:filePath];id data = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath]; 实现实例： 1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; Person *person = [[Person alloc]init]; person.name = @"BigBaby"; person.age = 16; person.gender = @"男"; // 归档，调用归档方法 NSString *filePath = [NSHomeDirectory() stringByAppendingString:@"person.plist"]; BOOL success = [NSKeyedArchiver archiveRootObject:person toFile:filePath]; NSLog(@"%d",success); // 反归档，调用反归档方法 Person *per = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath]; NSLog(@"%@",per); // Do any additional setup after loading the view, typically from a nib.&#125; Realm最强大的跨平台移动端数据库，但是暂时用不到，用到再说。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 iOS build]]></title>
    <url>%2F2017%2F02%2F03%2F%E5%85%B3%E4%BA%8E%20iOS%20build%2F</url>
    <content type="text"><![CDATA[关于 Xcode 是如何编译的，下面是一些较为浅显的讨论。 点击run后发生了什么点击 Run 之后 App 进行编译、汇编、链接、代码签名以及启动执行等操作 编译Clang是LLVM的前端，可以用来编译C，C++，ObjectiveC等语言。传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。Clang则是以LLVM为后端的一款高效易用，并且与IDE结合很好的编译前端。 编译器分别编译器前端（clang）和编译器后端，编译器前端负责产生机器无关的中间代码，编译器后端负责对中间代码进行优化并转化为目标机器代码，对于为什么需要 中间代码这个东西，看个图就一目了然啦（IR：intermediate representation中间表示） 汇编目标代码需要经过汇编器处理，才能变成机器上可以执行的指令。生成对应的.o文件 链接链接器（这里指的是静态链接器）将多个目标文件合并为一个可执行文件，在 OS X 和 iOS中的可执行文件是 Mach-O 。链接呢，又分为静态链接和动态链接 静态链接：在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件。 动态链接：链接过程推迟到运行时再进行。对于动态链接和静态链接，各有千秋。 代码签名我们每次 build 之后，都会发现工程目录下多了一个 .app 文件。 在 .app 目录中，有又一个叫 _CodeSignature 的子目录，这是一个 plist 文件，里面包含了程序的代码签名，你的程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名。 签名过程本身是由命令行工具 codesign 来完成的。如果你在 Xcode 中build 一个应用，这个应用构建完成之后会自动调用 codesign 命令进行签名，这也是 Link 之后的一个关键步骤。 启动在启动过程中，dyld（动态链接器） 起了很重要的作用，进行动态链接，进行符号和地址的一个绑定。 dyld 主要在启动过程中主要做了以下事情： 加载所依赖的 dylibs Fix-ups：Rebase 修正地址偏移，因为 OS X和 iOS 通过 ASLR 来做地址偏移（随机化）来避免收到攻击 Fix-ups：Binding确定 Non-Lazy Pointer 地址，进行符号地址绑定。 ObjC runtime 初始化：加载所有类 Initializers ：执行 load 方法和 __attribute__((constructor)) 修饰的函数 Build过程在选择工程后会出现下面这样的几个选项： Build PhasesBuild Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。 首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。 接着在 build phase中是一个 CocoaPods 相关的脚本 script execution 。接着在 Compile Sources section 中规定了所有必须参与编译的文件。此处列出的所有文件将根据相关的 rules 和 settings 被处理。 当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是：”Link Binary with Libraries.” 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。 当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（内部已经集成了第三方png优化工具pngcrush,它可以在编译时对png格式文件进行优化和压缩）。 虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 “Packaging”。 Build RulesBuild rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。 Build Settings至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务的详细内容。 你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 – 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。 工程文件上面我们介绍的所有内容都被保存在工程文件（.pbxproj）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。 如果用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。 首先，我们来看看文件中叫做 rootObject 的条目。在我的工程中，如下所示： 1rootObject = 1793817C17A9421F0078255E /* Project object */; 根据这个 ID（1793817C17A9421F0078255E），我们可以找到 main 工程的定义： 1234/* Begin PBXProject section */ 1793817C17A9421F0078255E /* Project object */ = &#123; isa = PBXProject;... 在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，mainGroup 指向了 root file group。如果你按照这个思路，你可以快速了解到在 .pbxproj 文件中工程的结构。 123456789101112131415161718191BC1E1511ACBEFFA0042431B = &#123; isa = PBXGroup; children = ( B62C765C1D9B71D300CB2CD4 /* OKit.framework */, 230935DA1C4F3D9C0070A5B3 /* QiNiuManager.xcodeproj */, 23D1991E1C2B8FF600E1DE8A /* Debug.xcodeproj */, 0DD10D591C28FB4900ADF8E5 /* Track.xcodeproj */, 0D106DDC1BE70BF600C49E7B /* Interface.xcodeproj */, 0D106D761BE7052800C49E7B /* Model.xcodeproj */, 0DC641041C0D427A007025D5 /* Wallet.xcodeproj */, 0DC641A41C0D997C007025D5 /* Tool.xcodeproj */, 0DC641CA1C0D9ADB007025D5 /* Location.xcodeproj */, 1BC1E1631ACBEFFA0042431B /* Mike */, 1BC1E15C1ACBEFFA0042431B /* Frameworks */, 1BC1E15B1ACBEFFA0042431B /* Products */, FF0DD481DA78D64E15039700 /* Pods */, ); sourceTree = "&lt;group&gt;";&#125;; 下面来看一些与 build 过程相关的内容。其中 target key 指向了 build target 的定义： 123targets = ( 1BC1E1591ACBEFFA0042431B /* Mike */,); 根据第一个内容，我们找到一个 target 的定义： 123456789101112131415161718192021222324252627282930313233341BC1E1591ACBEFFA0042431B /* Mike */ = &#123; isa = PBXNativeTarget; buildConfigurationList = 1BC1E1861ACBEFFA0042431B /* Build configuration list for PBXNativeTarget "Mike" */; buildPhases = ( E2E1BAED1E12657500A4F13C /* ShellScript */, D328411202E8C8A158C68A9A /* [CP] Check Pods Manifest.lock */, 32F9C08DAB34C3D77A8CD59E /* [CP] Check Pods Manifest.lock */, 1BC1E1561ACBEFFA0042431B /* Sources */, 1BC1E1571ACBEFFA0042431B /* Frameworks */, 1BC1E1581ACBEFFA0042431B /* Resources */, 7C20CC96F9690C1C11011773 /* [CP] Embed Pods Frameworks */, 1DBEA7A742BF77DA6EC31CEB /* [CP] Copy Pods Resources */, 2337E6001BCDF5EC007659ED /* ShellScript */, 2CA588C55C8E11D9779AABF0 /* 📦 Embed Pods Frameworks */, 789C695793C24ECAC7D8420E /* 📦 Copy Pods Resources */, B60684181D9924B00003E3E5 /* Embed Frameworks */, ); buildRules = ( ); dependencies = ( 230935E91C4F55B20070A5B3 /* PBXTargetDependency */, 23D199251C2B918700E1DE8A /* PBXTargetDependency */, 0DD10D601C28FB5D00ADF8E5 /* PBXTargetDependency */, 0DE3C0941C0F103000184463 /* PBXTargetDependency */, 0DE3C0921C0F102D00184463 /* PBXTargetDependency */, 2390C7521C0DB98B008C31B1 /* PBXTargetDependency */, 0D106DE41BE70C2600C49E7B /* PBXTargetDependency */, 0D106D7E1BE7060100C49E7B /* PBXTargetDependency */, ); name = Mike; productName = Mike; productReference = 1BC1E15A1ACBEFFA0042431B /* Mike.app */; productType = "com.apple.product-type.application"; &#125;; 其中 buildConfigurationList 指向了可用的配置项，一般是 Debug 和 Release。 1234567891BC1E1861ACBEFFA0042431B /* Build configuration list for PBXNativeTarget "Mike" */ = &#123; isa = XCConfigurationList; buildConfigurations = ( 1BC1E1871ACBEFFA0042431B /* Debug */, 1BC1E1881ACBEFFA0042431B /* Release */, ); defaultConfigurationIsVisible = 0; defaultConfigurationName = Release;&#125;; 根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置： 123456789101BC1E1871ACBEFFA0042431B /* Debug */ = &#123; isa = XCBuildConfiguration; baseConfigurationReference = 31FD03C25841C700BD562061 /* Pods-Mike.debug.xcconfig */; buildSettings = &#123; ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon; ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage; CLANG_CXX_LANGUAGE_STANDARD = "compiler-default"; CLANG_CXX_LIBRARY = "compiler-default"; CLANG_ENABLE_OBJC_ARC = YES; ... buildPhases 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。buildRules 属性是空的：因为在该工程中，我没有自定义 build rules。dependencies 列出了在 Xcode build phase tab 中列出的 target 依赖项。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 如何创建原生 View 源码解析]]></title>
    <url>%2F2017%2F01%2F24%2FRN%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前一篇，主要讲了 RN 如何初始化一个 BCTBatchedBridge，这一篇将进一步研究 RN 是如何通过这个 bridge 创建出真正展示出来的 View 的。 首先抛出结论：每一个 js render() 方法中的 component 都对应于 native 中的一个 RCTView。在渲染前，js 会循环取出各个 component 。然后通过 UIManager （NativeModules 中的一项） 的 createView 方法，通过 BatchedBridge 调用 native 端的 RCTUIManager 的同名方法，创建与 component 相对应的类。对于触摸事件也是类似的。native 端通过 bridge 将触摸事件传给 js，js 在找到对应 component 后，响应各个触摸事件。 下面将分几个阶段解读 RN 是如何显示出来的，依旧是 0.39 版本。最好在理解了前一篇 RN 通信原理后再看。 native 调用 js这是整个过程的第一步，从 RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:_bridge moduleName:moduleName initialProperties:param]; 方法开始。native 告诉 js 我要准备显示 view 了，快点把你这里各个 view 的信息告诉我。先来看一张调用流程图： tag1这个 setBridge 方法是初始化时候执行的方法。还记得前一篇初始化的时候其中的一步设置各个 RCTModuleData 的 instance 么？其中就会调用 setBridge 方法为每个 RCTModuleData 的 instance 设置 bridge。在 RCTUIManager 类的 setBridge 方法中还做了一些其他操作： 123456789101112- (void)setBridge:(RCTBridge *)bridge&#123; ... NSMutableDictionary *componentDataByName = [NSMutableDictionary new]; for (Class moduleClass in _bridge.moduleClasses) &#123; if ([moduleClass isSubclassOfClass:[RCTViewManager class]]) &#123; RCTComponentData *componentData = [[RCTComponentData alloc] initWithManagerClass:moduleClass bridge:_bridge]; componentDataByName[componentData.name] = componentData; &#125; &#125; _componentDataByName = [componentDataByName copy]; ...&#125; 该方法循环遍历 bridge 中的每一个暴露给 js 的模块名，判断是否是 RCTViewManager 的子类。如果是，则为其创建一个 RCTComponentData 并将其保存在 _componentDataByName 字典中。RCTViewManager 是各个 RCTView 的控制器的父类，所有 RCTView 的方法都在 RCTViewManager 的子类里实现。这样就把所有视图控制器保存在了 RCTUIManager 中。 tag2看到这个方法的名字就知道是在 bundle 加载完成后执行的。 这个方法分为两步。第一步是创建一个 _contentView 用来容纳各个 component。第二步就是通过 BatchedBridge 调用 js 的方法了。部分代码如下： 12345678910- (void)bundleFinishedLoading:(RCTBridge *)bridge&#123; ... _contentView = [[RCTRootContentView alloc] initWithFrame:self.bounds bridge:bridge reactTag:self.reactTag sizeFlexiblity:_sizeFlexibility]; [self runApplication:bridge]; ...&#125; 其中有一个地方需要说明，就是这里面的 self.reactTag。类似于 RN 通信的原理，reactTag 是 native 和 js 识别各个 component 的标记。来看一下 reactTag 的 getter 方法： 123456789101112131415- (NSNumber *)reactTag&#123; RCTAssertMainQueue(); if (!super.reactTag) &#123; self.reactTag = [_bridge.uiManager allocateRootTag]; &#125; return super.reactTag;&#125;- (NSNumber *)allocateRootTag&#123; NSNumber *rootTag = objc_getAssociatedObject(self, _cmd) ?: @1; objc_setAssociatedObject(self, _cmd, @(rootTag.integerValue + 10), OBJC_ASSOCIATION_RETAIN_NONATOMIC); return rootTag;&#125; 每一个根视图都必须有一个独一无二的 ractTag。这个 tag 从1开始，每次自增10，也就是 1，11，21，31…的形式，以此类推。 这里要吐槽一下 facebook 的程序员。没想到外国的程序员也会把单词拼错。上面方法中 sizeFlexiblity 少了个 i。这是要输入法背锅么？ tag3该方法首先为 rootView 新建了 RCTTouchHandler 实例，并设置为其 GestureRecognizer。其次执行了 registerRootView:withSizeFlexibility: 方法。这个方法将 rootView 保存在 RCTUIManager 的 _viewRegistry 字典中，其中键是 rootView 的 reactTag。此时，RCTUIManager 中设置并保存好了两个比较重要的字典：_viewRegistry,_componentDataByName。 tag4这个方法就比较直观了： 1234567891011121314- (void)runApplication:(RCTBridge *)bridge&#123; NSString *moduleName = _moduleName ?: @""; NSDictionary *appParameters = @&#123; @"rootTag": _contentView.reactTag, @"initialProps": _appProperties ?: @&#123;&#125;, &#125;; RCTLogInfo(@"Running application %@ (%@)", moduleName, appParameters); [bridge enqueueJSCall:@"AppRegistry" method:@"runApplication" args:@[moduleName, appParameters] completion:NULL];&#125; 就是调用 enqueueJSCall:method:args:completion: 方法。如果前一篇看懂了的话，就会知道，这个方法调用的是 js 端 AppRegistry.js 的 runApplication 方法，需要创建的 rootView 以 String 的方式通过 moduleName 传入。 到这一步，Native 调用 JS 就结束了，接下来就是 js 端的执行。 js 调用 nativejs 端的方法调用过程还是比较清晰的。来看一下下面的流程图： tag1在 native 调用 enqueueJSCall:method:args:completion 后，我们来看看 AppRegistry 的 runApplication 方法。 1234 runApplication: function(appKey: string, appParameters: any): void &#123;... runnables[appKey].run(appParameters); &#125;, appKey 就是上面的 moduleName，通过它拿到 runnables 字典中对应的对象，执行其 run 方法。这个字典怎么来的呢？往下看。 tag2RN 的官方文档中第一篇就说明了，在定义好一个 component 后，需要在 index.ios.js 中使用 AppRegistry.registerComponent() 方法注册: 12import HelloWorldView from './app/view/HelloWorldView';AppRegistry.registerComponent('HelloWorldView', () =&gt; HelloWorldView); 那么 registerComponent 做了什么呢？ 1234567registerComponent: function(appKey: string, getComponentFunc: ComponentProvider): string &#123; runnables[appKey] = &#123; run: (appParameters) =&gt; renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag) &#125;; return appKey;&#125; 这里就设置了前面用到的 runnables 字典，并且为字典内对象创建了 run 方法。前面执行的 run 方法，其实就是执行 renderApplication 方法。renderApplication 在 RootView 外层又嵌套了一层 AppContainer。 tag3这个方法内部就比较复杂了。其中: 1var instance = instantiateReactComponent(nextWrappedElement, false); 通过 instantiateReactComponent 方法将整个 View 的 JSX 转换为 ReactCompositeComponentWrapper 实例。这也就是 Reactjs 的精髓之一。好吧。并没有花时间去细读，臣妾做不到啊。有兴趣的话可以找找类似于 reactjs源码分析-上篇（首次渲染实现原理） 的文章学习一下。之后就是长长的调用栈了，循环递归每一个 component 执行 createView。 tag4在 ReactNativeBaseComponent.js 中调用了 UIManager.createView()，但是这个方法点不进去，UIManager.js 中没有这个方法。开始我比较迷惑，后来细读了一下发现： 1const &#123; UIManager &#125; = NativeModules; 也就是说，这个 UIManager 是 native 中的一个 module，这个 createView() 是 native 中暴露出来的一个方法。 123456UIManager.createView( tag, this.viewConfig.uiViewClassName, nativeTopRootTag, updatePayload); 这个方法会将当前 component 的标记，名字，根标记，属性方法等一起传给 native。其中 tag 是 ReactNativeTagHandles.allocateTag() 生成的。每次调用该方法，tag 都会加一（会略过1结尾的，那些是留给根 component 的）。 至此，js 调用 native 的部分就结束了。回顾一下，主要就是循环每一个 component，为每个 component 分配一个独有的 tag 然后调用 createView 方法。 Native createView 的过程来到 native，RCTUIManager 暴露出了许多方法供 js 调用。来看一下刚才 js 调用的 createView 方法： 123456789101112131415161718192021RCT_EXPORT_METHOD(createView:(nonnull NSNumber *)reactTag viewName:(NSString *)viewName rootTag:(__unused NSNumber *)rootTag props:(NSDictionary *)props)&#123; RCTComponentData *componentData = _componentDataByName[viewName]; ... __weak RCTUIManager *weakManager = self; dispatch_async(dispatch_get_main_queue(), ^&#123; RCTUIManager *uiManager = weakManager; if (!uiManager) &#123; return; &#125; UIView *view = [componentData createViewWithTag:reactTag]; if (view) &#123; [componentData setProps:props forView:view]; // Must be done before bgColor to prevent wrong default ... uiManager-&gt;_viewRegistry[reactTag] = view; &#125; &#125;);&#125; _componentDataByName 上面介绍过了，可以拿到前面保存的 js 将要创建的 view 的 RCTComponentData。然后在主线程中使用 createViewWithTag: 方法创建 View。通过 RCTComponentData 中保存的 _managerClass 可以拿到对应 View 的 manager，然后调用其 view 方法创建 view。 123456789101112131415- (UIView *)createViewWithTag:(NSNumber *)tag&#123; UIView *view = [self.manager view]; view.reactTag = tag; ... return view;&#125;- (RCTViewManager *)manager&#123; if (!_manager) &#123; _manager = [_bridge moduleForClass:_managerClass]; &#125; return _manager;&#125; 通过 setProps:forView: 方法将每个 view 的 props 保存下来。这里又要用到反射的方式，还是比较复杂的。具体就不说了。只要清楚，它会生成一个 block，每次都用这个 block，都会调用对应属性的 setter 方法将值赋给该属性即可。 最后，把设置好的 view 保存到 _viewRegistry 中。js 和 native 端都会保存好这个 tag 和 view 的映射表。这里的 _viewRegistry 就是 native 端保存的字典。 这里只是介绍了如何通过 js 传来的 tag 和 moduleName 创建出对应的 native 端的 view 的。当然，创建和展示中间还隔着 measure、layout之类的步骤，这也是 React 需要做的，这个我就不聊了，太深入了聊不动，容易聊爆。 自建组件现在我们知道 view 是如何创建出来的了。facebook 封装的组件和自建的组件原理上是一致的。现在来研究一下自建组件的创建过程。 基本设置前面说到拿到 view 的 manager 调用其 view 方法。那么 manager 是个什么呢？manager 相当于一个 Controller，负责创建和控制 view。文档上关于创建 RCTViewManager 主要有三步： 创建一个子类 添加 RCT_EXPORT_MODULE() 标记宏 实现 -(UIView *)view 方法 这三步是最基本的三步，作用也挺明显的。继承 RCTViewManager 作为一个标记，这样 RCTUIManager 在设置 bridge 的时候就能够将该 manager 放入 _componentDataByName 数组中了。添加 RCT_EXPORT_MODULE() 标记宏后才能将该类暴露给 js，才能让 js 调用该类方法。实现 -(UIView *)view 方法就是上面 [self.manager view] 调用的方法。 设置属性上面只是创建了一个 view，更复杂一点的情况就是需要控制 view 的属性。RN 提供了两个宏： RCT_EXPORT_VIEW_PROPERTY(name,type) RCT_CUSTOM_VIEW_PROPERTY(name,type,viewClass){...} 来看一下宏定义的实现： 12345678910// 常规导出#define RCT_EXPORT_VIEW_PROPERTY(name, type) \+ (NSArray&lt;NSString *&gt; *)propConfig_##name &#123; return @[@#type]; &#125;// 自定义导出#define RCT_CUSTOM_VIEW_PROPERTY(name, type, viewClass) \RCT_REMAP_VIEW_PROPERTY(name, __custom__, type) \- (void)set_##name:(id)json forView:(viewClass *)view withDefaultView:(viewClass *)defaultView#define RCT_REMAP_VIEW_PROPERTY(name, keyPath, type) \+ (NSArray&lt;NSString *&gt; *)propConfig_##name &#123; return @[@#type, @#keyPath]; &#125; 关于 ## 和 @# 前一篇也有涉及。操作符 ## 用来实现宏中 token 的连接， @# 实现将宏中的参数转化为字符串。比如 RCT_EXPORT_VIEW_PROPERTY(placeholder, NSString) 这样一个属性，将会被转化为下面这个方法： 1+ (NSArray&lt;NSString *&gt; *)propConfig_placeholder &#123; return @[@"NSString"]; &#125; 但如果要对属性进行也谢操作的话，比如： 1234RCT_CUSTOM_VIEW_PROPERTY(fontSize, NSNumber, RCTTextView)&#123; view.font = [RCTFont updateFont:view.font withSize:json ?: @(defaultView.font.pointSize)];&#125; 这样的自定义属性，则会转化为如下方法： 1234+ (NSArray&lt;NSString *&gt; *)propConfig_fontSize &#123; return @[@"NSNumber", @"__custom__"]; &#125;- (void)set_fontSize:(id)json forView:(RCTTextView *)view withDefaultView:(RCTTextView *)defaultView&#123; view.font = [RCTFont updateFont:view.font withSize:json ?: @(defaultView.font.pointSize)];&#125; 其中 json 代表了 JS 中传递的尚未解析的原始值。view 代表访问的对应的视图实例。defaultView 在 JS 发送 null 的时候，可以把视图的这个属性重置回默认值。 这里说一下这个 defaultView，这是 RCTComponentData 中的一个属性，不用在意也不用自己设置它。在 json 为空的时候，就会去自己创建一个当前 view 的实例作为 defaultView： 12345//RCTComponentData.m propBlockForKey:inDictionaryif (!json &amp;&amp; !strongSelf-&gt;_defaultView) &#123; // Only create default view if json is null strongSelf-&gt;_defaultView = [strongSelf createViewWithTag:nil];&#125; 宏定义的方法在上面说过的 setProps:forView: 方法里调用，目的是验证从 js 端传递过来的属性是否在 native 里注册过。 至于还有一些非常规的需要用到 RCTConvert 以及事件的使用方式可以参考文档，不深入了。 创建 View前面说过了如何创建 Controller，现在说一下这个 view。 1234- (UIView *)view&#123; return [[MKMapView alloc] init];&#125; 这是官方文档里的例子，在 manager 中的 view 方法里创建了一个 MKMapView 的视图。那么 RN 是如何设置 MKMapView 的 frame 的呢？不用担心，RN 实现了 UIView 的范畴 UIView(React)，其中就实现了 reactSetFrame 方法，会自己将计算好的大小设置给 view，如果你想在 view 设置好大小后做什么事，你就可以通过重写这个方法。另外，当 js 端的一些属性变化时，就会触发 native 相应 view 的相应属性的 setter 方法，可以自己实现这些 setter 方法，来做一些别的处理，比如在 RCTImageView 里，只要任意属性发生变化，都会触发 reloadImage 方法。 终总算通过这两篇将 RN 稍微梳理了一下，跟进起来不容易啊，都是泪。本来想研究一下，写一篇 “RN view 显示原理” 的。但是读着读着发现 Reactjs 并不能看懂，那还写个蛋的显示原理啊喂。最终就忽略了 view 的层次关系以及大小位置等等的转换原理，写了这么一篇。虽然写的水平不高，但是我相信如果你想更深入的了解一下 react native，读一下本篇还是能有些许帮助的。毕竟为了看懂，我也读了好久好久~~~ 也许会有下一篇，也许会挑一个 RN 封装的组件具体看看它是如何实现的~]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 初始化与通信原理源码分析]]></title>
    <url>%2F2017%2F01%2F17%2FRN%20Native%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[RN 是如何启动的，oc 与 js 是如何通信的将是本文探究的重点。虽然网上已经有不少解释 RN 原理的文章，但是到自己读起源码的时候，还是非常累人的。这里，将较为细致的梳理一下 RN 的方法调用过程，希望能对各位有所帮助。 本文主要针对 RN 0.39 版本，不同版本可能会略有不同。不多bb RN 的基本概要了，直接开始（建议读者还是先自行了解下 RN 的基本原理，有助于理解）。 Native 初始化过程先来一张完整的初始化流程图： 下面将对其中的部分方法做一些注释。 tag11234RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@"AwesomeProject" initialProperties:nil launchOptions:launchOptions]; 任何 RN 的使用者都应该对这个方法不陌生。在 js 端写的各个 component，都将在 native 转换成 RCTRootView 的形式展现出来。 这个方法分为两步，第一步创建一个 RCTBridge 的实例，它是 oc 与 js 交互的桥梁，整个初始化的过程就是创建这个 Bridge。第二步通过这个 Bridge 创建一个 RCTRootView。 这里需要注意一下。对于一个半 RN 半 native 的应用（即不是通过 RN 的 navigator 跳转，而是通过原生跳转好后，再分别创建 RN 的 view），创建页面时不应该直接调用 initWithBundleURL:moduleName:initialProperties:launchOptions: 方法。因为这样每次都要创建 RCTBridge，这是一个耗时耗资源的过程。应该事先创建好 RCTBridge，在要创建页面的时候调用 initWithBridge:moduleName:initialProperties: 方法。 tag2一番跳转来到 setUp 方法内，一些比较次要的代码比如 Logger 我就不分析了： 1234567- (void)setUp&#123; ... [self createBatchedBridge]; [self.batchedBridge start]; ...&#125; 创建并持有了其子类 RCTBatchedBridge 的实例。RCTBridge 中其实没有太多代码，初始化的大部分逻辑都在 [self.batchedBridge start] 中完成。 tag3创建 RCTBatchedBridge 中最重要的方法就是 [self.batchedBridge start] 方法。该方法主要包含以下几步: 读取 js 源码 初始化各个需要给 js 调用的模块 创建一个 JSContext，为 JSContext 设置多个回调方法 将模块信息写入一个字符串中 将字符串传递给 js 端 执行 js 源码 其中创建了两个 GCDGroup，分别为 initModulesAndLoadSource 和 setupJSExecutorAndModuleConfig。当3、4步完成后才能执行第5步，当1、2、5都完成后才会执行6。 tag4异步地读取 jsBundle，传入加载成功和正在加载中的回调方法。没有太多好说的，都是一些系统 api 的调用。 123456789101112131415 [self loadSource:^(NSError *error, NSData *source, __unused int64_t sourceLength) &#123; if (error) &#123; RCTLogWarn(@"Failed to load source: %@", error); dispatch_async(dispatch_get_main_queue(), ^&#123; [weakSelf stopLoadingWithError:error]; &#125;); &#125; sourceCode = source; dispatch_group_leave(initModulesAndLoadSource); &#125; onProgress:^(RCTLoadingProgress *progressData) &#123;#ifdef RCT_DEV RCTDevLoadingView *loadingView = [weakSelf moduleForClass:[RCTDevLoadingView class]]; [loadingView updateProgress:progressData];#endif &#125;]; 其中，[weakSelf stopLoadingWithError:error] 就是经常所见的红屏报错。onProgress 的回调方法表示，如果在真机上加载，那么在加载时页面上部显示 “Loading from XXXX” 的提示。 tag5initModulesWithDispatchGroup: 是一个比较复杂的方法，用来初始化模块信息。每一个将要暴露给 js 的模块都会保存为 RCTModuleData 的形式，然后被存储为3分配置表。 1234567NSMutableArray&lt;Class&gt; *moduleClassesByID = [NSMutableArray new];NSMutableArray&lt;RCTModuleData *&gt; *moduleDataByID = [NSMutableArray new];NSMutableDictionary&lt;NSString *, RCTModuleData *&gt; *moduleDataByName = [NSMutableDictionary new];moduleDataByName[moduleName] = moduleData;[moduleClassesByID addObject:moduleClass];[moduleDataByID addObject:moduleData]; RCTRegisterModule那么，如何找到暴露给 js 的模块呢？RN 提供了 RCTRegisterModule(); 的宏： 123456789101112131415#define RCT_EXPORT_MODULE(js_name) \RCT_EXTERN void RCTRegisterModule(Class); \+ (NSString *)moduleName &#123; return @#js_name; &#125; \+ (void)load &#123; RCTRegisterModule(self); &#125;void RCTRegisterModule(Class moduleClass)&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; RCTModuleClasses = [NSMutableArray new]; &#125;); // Register module [RCTModuleClasses addObject:moduleClass];&#125; 这样就生成了两个方法： 在类 load 的时候，就会调用 RCTRegisterModule 方法，将类自动注册到 RCTModuleClasses 数组中。只要遍历该数组，就能取出所有暴露出的模块。 moduleName 方法，返回 @#js_name。这里的 @# 的一时是把宏参数 js_name 转为字符串，啥也没有，返回的就是空。当然在 RCTBridgeModuleNameForClass() 这个获取模块名的方法里，如果 moduleName 长度为0，那么就会调用 NSStringFromClass() 方法获取类名。 tag6在所有要暴露给 js 的类中，RCTJSCExecutor 是最特殊的一个类。需要率先创建一个实例并作为instance 保存在一个 RCTModuleData 的实例中，以防其他 module 可能需要用到。 在创建 RCTJSCExecutor 实例的时候，创建了一个 JSThread，所有的 JS 通信，都是通过 RCTJSCExecutor 执行，都是在这个 JSThread 内。 tag7除了 RCTJSCExecutor 的其他模块实例化的过程都是在 prepareModulesWithDispatchGroup: 中完成。实例化每个暴露的模块，并将其设置为 RCTModuleData 的 instance 属性。在 setUpMethodQueue 方法中，为每一个模块都会创建一个自己独有的专属串行队列，保证每个模块内的通信事件都是串行执行的。 tag8gatherConstants 方法主要功能： 123RCTExecuteOnMainThread(^&#123; self-&gt;_constantsToExport = [self-&gt;_instance constantsToExport] ?: @&#123;&#125;;&#125;, YES); 将模块(instance)的一些常量设置给各自的 RCTModuleData 实例中。 tag9在 setUp 方法中，JSThread 内创建了一个 JSContext，并且为 Context 设置了不同的 block，如： 12345678910context[@"nativeFlushQueueImmediate"] = ^(NSArray&lt;NSArray *&gt; *calls)&#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid || !calls) &#123; return; &#125; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @"nativeFlushQueueImmediate", nil); [strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO]; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @"js_call");&#125;; 这些 block 会在特定的场合调用。之后将有介绍。 tag10123456789101112131415- (NSString *)moduleConfig&#123; NSMutableArray&lt;NSArray *&gt; *config = [NSMutableArray new]; for (RCTModuleData *moduleData in _moduleDataByID) &#123; if (self.executorClass == [RCTJSCExecutor class]) &#123; [config addObject:@[moduleData.name]]; &#125; else &#123; [config addObject:RCTNullIfNil(moduleData.config)]; &#125; &#125; return RCTJSONStringify(@&#123; @"remoteModuleConfig": config, &#125;, NULL);&#125; 在 moduleConfig 方法中，各个模块名将先被加入 config 数组中，然后被转换为 json 字符串的形式。这里只是写入模块名： tag11这一步将上面的 JSON 字符串通过 JSExecutor 传入 JS 作为全局变量。变量名为 __fbBatchedBridgeConfig: 12345678- (void)injectJSONConfiguration:(NSString *)configJSON onComplete:(void (^)(NSError *))onComplete&#123; ... [_javaScriptExecutor injectJSONText:configJSON asGlobalObjectNamed:@"__fbBatchedBridgeConfig" callback:onComplete];&#125; tag 12当上面所有步骤全部做完后，就开始通过 executeSourceCode 执行 js 代码了。 JS初始化过程native 端 injectJSONConfiguration 只把模块的名称组成的 JSON 字符串置入了 __fbBatchedBridgeConfig，那么 JS 端如何拿到模块的方法以及一些常量信息呢？需要我们研究一下 JS 端的初始化过程。 NativeModulejs 的打包文件如下所示： 可以看到，其中导入了 NativeModule。它就是用来接收保存 native 端暴露的模块的。 先来看一张整体的初始化流程图： tag11234567891011121314151617181920const bridgeConfig = global.__fbBatchedBridgeConfig;invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');(bridgeConfig.remoteModuleConfig || []).forEach((config: ModuleConfig, moduleID: number) =&gt; &#123; // Initially this config will only contain the module name when running in JSC. The actual // configuration of the module will be lazily loaded. const info = genModule(config, moduleID); if (!info) &#123; return; &#125; if (info.module) &#123; NativeModules[info.name] = info.module; &#125; // If there's no module config, define a lazy getter else &#123; defineLazyObjectProperty(NativeModules, info.name, &#123; get: () =&gt; loadModule(info.name, moduleID) &#125;); &#125;&#125;); 这里的 global.__fbBatchedBridgeConfig 就是 native 注入的字符串，通常情况下是各个模块名。这里说一般是因为如果打开了 Remote JS Debugging，那么这里得到的是包括方法名的全部配置信息。如下图： (注：开了 Remote JS Debugging 后 js 代码是可以断点的，但是 Xcode 经常显示 __nw_connection_get_connected_socket_block_invoke xx Connection has no connected handler 然后，Xcode 的断点就失灵了。) 关闭 Remote JS Debugging，info.module 为 nil，因此一定会运行到 get: () =&gt; loadModule(info.name, moduleID) 方法，该方法是一个懒加载方法，以此来加快 RN 的初始化速度。 经过这个方法，就将所有暴露出来的方法的执行信息保存在 NativeModule 对象（或者说字典，不是数组。键是module名，值是模块内的方法组成的对象）里了。（这里并不是全部 ModuleCinfig 都变成了 NativeModules 里的一项，比如一些关于 view 的manager，它们并没有调用各自的懒加载方法。这些 manager 的方法都在加载 RCTUIManager 的时候，作为 RCTUIManager 的 constants 设置好了。） tag2进入 loadModule 方法： 1234567function loadModule(name: string, moduleID: number): ?Object &#123; invariant(global.nativeRequireModuleConfig, 'Can\'t lazily create module without nativeRequireModuleConfig'); const config = global.nativeRequireModuleConfig(name); const info = genModule(config, moduleID); return info &amp;&amp; info.module;&#125; 可以看到调用了 global.nativeRequireModuleConfig 方法，以及 genModule 方法。 tag3global.nativeRequireModuleConfig 就是 native 流程图的 tag9，RCTJSCExecutor 的 setUp 方法中，注册的诸多回调中的一个： 1234567891011context[@"nativeRequireModuleConfig"] = ^NSArray *(NSString *moduleName) &#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid) &#123; return nil; &#125; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @"nativeRequireModuleConfig", @&#123; @"moduleName": moduleName &#125;); NSArray *result = [strongSelf-&gt;_bridge configForModuleName:moduleName]; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @"js_call,config"); return RCTNullIfNil(result);&#125;; methods 方法会拿到对应 RCTModuleData 的所有方法，然后循环找到以 __rct_export__ 开头的方法(为什么是以 __rct_export__ 开头后面再讲)。 JSMethodName 方法会拿到方法的字符串，并截取第一个冒号前的字符，作为 JS 简写方法名。 最后将各个方法常量等组成一个数组，即需要返回的 config: 1234567NSArray *config = @[ self.name, RCTNullIfNil(constants), RCTNullIfNil(methods), RCTNullIfNil(promiseMethods), RCTNullIfNil(syncMethods)]; tag4来看一下 genModule 方法： 1234567891011function genModule(config: ?ModuleConfig, moduleID: number): ?&#123;name: string, module?: Object&#125; &#123; ... methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123; const isPromise = promiseMethods &amp;&amp; arrayContains(promiseMethods, methodID); const isSync = syncMethods &amp;&amp; arrayContains(syncMethods, methodID); invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook'); const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async'; module[methodName] = genMethod(moduleID, methodID, methodType); &#125;); ...&#125; 拿到了通过 global.nativeRequireModuleConfig 方法获得的完整 config 信息。在该方法中通过一个循环，将所有 method 拿出，存入一个 module 对象中去，键是 method 名，值是通过 genMethod 方法生成的 function。 tag5再跟进到 genMethod 方法中去： 123456789101112131415161718192021222324function genMethod(moduleID: number, methodID: number, type: MethodType) &#123; let fn = null; if (type === 'promise') &#123; ... &#125; else &#123; fn = function(...args: Array&lt;any&gt;) &#123; const lastArg = args.length &gt; 0 ? args[args.length - 1] : null; const secondLastArg = args.length &gt; 1 ? args[args.length - 2] : null; const hasSuccessCallback = typeof lastArg === 'function'; const hasErrorCallback = typeof secondLastArg === 'function'; hasErrorCallback &amp;&amp; invariant( hasSuccessCallback, 'Cannot have a non-function arg after a function arg.' ); const onSuccess = hasSuccessCallback ? lastArg : null; const onFail = hasErrorCallback ? secondLastArg : null; const callbackCount = hasSuccessCallback + hasErrorCallback; args = args.slice(0, args.length - callbackCount); BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess); &#125;; &#125; fn.type = type; return fn;&#125; 我们现在只看 else 的情况。主要就是将 moduleID，methodID，参数以及失败和成功的回调函数传入 BatchedBridge 的 enqueuenativeCall 方法。这里的 moduleID，methodID， 也就是一般讨论 RN 原理时经常看到的 “通过模块、方法id找到对应模块和方法”，其实就是对应数组中的下标。 另外，关于取出成功和失败的回调方法，是通过判断最后两个参数是否是方法来得到的，默认情况下，最后一个是成功的回调方法，倒数第二个是失败的回调方法。因此，如果需要设置回调方法，那么必须放在最后，且回调方法不能超过两个。 BatchedBridgeBatchedBridge 是个啥: 123456789const MessageQueue = require('MessageQueue');const BatchedBridge = new MessageQueue();...Object.defineProperty(global, '__fbBatchedBridge', &#123; configurable: true, value: BatchedBridge,&#125;); BatchedBridge 是一个 MessageQueue 实例。其将自身写入全局变量 __fbBatchedBridge 上，这样 Native 可以通过 __fbBatchedBridge ，访问 JSBridge对象，比如在 RCTJSCExecutor.mm 的 _executeJSCall:arguments:unwrapResult:callback 方法中。 MessageQueue在前面的 tag5 中我们看到，genModule 方法中生成的 function 调用了 BatchedBridge 的 enqueuenativeCall。这个方法就定义在 MessageQueue.js 中。 代码太长我就就贴部分吧，大致分为 个部分： 首先，在 MessageQueue 中定义了一个从0开始的计数的 _callbackID，用来标识 js 端的回调函数。将 callbackID push 进参数数组 params 里。然后，将这个 callback 保存在本地的 _callbacks 数组中的对应 callbackID 位置。这样，当 native 传来回调的 callbackID 的时候，就能在 _callbacks 数组中找到并执行相应方法了。 1234onFail &amp;&amp; params.push(this._callbackID);this._callbacks[this._callbackID++] = onFail;onSucc &amp;&amp; params.push(this._callbackID);this._callbacks[this._callbackID++] = onSucc; 设置好回调之后，将 moduleID，methodID，params 分别 push 进 _queue这个数组的各个位置。下面的 MODULE_IDS，METHOD_IDS，PARAMS分别代表0，1，2。123this._queue[MODULE_IDS].push(moduleID);this._queue[METHOD_IDS].push(methodID);this._queue[PARAMS].push(params); 为什么要把方法参数放进一个 _queue 数组里呢？因为 js 不能主动调用除了上面设置 JSContext 的时候设置的那些回调方法外的 native 方法，所以 js 端想调用 native 端代码的时候，必须将想要调用的模块、方法、参数放在一个数组里，等待 native 来获取这个数组，也就是这个 _queue。什么时候 native 回来要一次这个数组呢？比如在完成 native 调用 js 方法后： 123456[_javaScriptExecutor callFunctionOnModule:module method:method arguments:args callback:^(id json, NSError *error) &#123; [weakSelf _processResponse:json error:error]; &#125;]; 上面的这个方法就是 native 调用 js 的方法，具体的调用流程在后面会说明。可以看到，在 callback 的 block 内，有一个叫做 json 的入参，这个 json 就是上面的 _queue。在 native 调用完 js 的方法后，native 就会来处理 js 是否需要调用 native 的什么方法，并且刷新 _queue 数组。 继续刚才的 enqueueNativeCall 方法往下走执行到下面的代码： 12345if (global.nativeFlushQueueImmediate &amp;&amp; now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123; global.nativeFlushQueueImmediate(this._queue); this._queue = [[], [], [], this._callID]; this._lastFlush = now;&#125; 这里的 global.nativeFlushQueueImmediate 就是 JSContext 设置的几个回调方法中的一个，供 JS 主动调用。来看一下这个方法： 12345678910context[@"nativeFlushQueueImmediate"] = ^(NSArray&lt;NSArray *&gt; *calls)&#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid || !calls) &#123; return; &#125; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @"nativeFlushQueueImmediate", nil); [strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO]; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @"js_call");&#125;; 调用了 nativeFlushQueueImmediate 方法后就会执行 handleBuffer:batcheEnded: 方法来强制 native 来执行 js 需要调用的 native 方法，并且刷新 _queue 数组。 因此，enqueueNativeCall 方法中的这段代码表示，当上次刷新 _queue 数组的时间和当前时间相比超过了 MIN_TIME_BETWEEN_FLUSHES_MS 即5ms，那么就会主动调用 native 的 nativeFlushQueueImmediate 方法，强制执行，刷新 _queue。 注意到，这里清空的操作：this._queue = [[], [], [], this._callID];，将 _queue 的第四项设置为 _callID。这个 _callID 每次 enqueueNativeCall 的时候都会自增一次，应该只是一个标记，暂时没看出有什么太特别的用处。 RCT_EXPORT_METHOD()RN 是如何将方法前加上 __rct_export__ 的呢？通过 RCT_EXPORT_METHOD() 方法。 123456789101112#define RCT_EXPORT_METHOD(method) \ RCT_REMAP_METHOD(, method)#define RCT_REMAP_METHOD(js_name, method) \ RCT_EXTERN_REMAP_METHOD(js_name, method) \ - (void)method#define RCT_EXTERN_REMAP_METHOD(js_name, method) \ + (NSArray&lt;NSString *&gt; *)RCT_CONCAT(__rct_export__, \ RCT_CONCAT(js_name, RCT_CONCAT(__LINE__, __COUNTER__))) &#123; \ return @[@#js_name, @#method]; \ &#125; 中间的宏为方法补全了 -(void) 恢复了完整 OC 方法的定义。这样才能使得 RCT_EXPORT_METHOD(xxx) 这样的写法编译器不报错。 下面的宏中 RCT_CONCAT 是一个拼接的宏。大致为每一个 RCT_EXPORT_METHOD 生成了唯一识别的数字 tag 与 js_name 拼接，然后在前面加上一个 __rct_export__，生成了一个返回一个数组的方法。 套用RN 源码解读（二）中的一个例子： 假设我们写 RCT_EXPORT_METHOD(nativeAlert:xxx) 的时候，__LINE__ 与 __COUNTER__ 组合起来的数字 tag 如果是 123456，那么这个内二层宏还会自动生成一个这样的函数： 123+ (NSArray&lt;NSString *&gt; *)__rct_export__123456&#123; return @[@"", @"nativeAlert:xxx"]; &#125; 换句话说，一行 RCT_EXPORT_METHOD(xxxx)，等于生成了2个函数的实现: -(void)nativeAlert:(NSString *)content withButton:(NSString *)name +(NSArray&lt;NSString *&gt; *)__rct_export__123456 Native 与 JS 间的通信现在开始讲到 native 和 JS 之间的通信。首先是 native 调用 JS 方法。在 RCTEventDispatcher.m 中，我们可以看到各种各样的调用方法： sendAppEventWithName:body: sendDeviceEventWithName:body: sendInputEventWithName:body: 这些方法都在内部调动了 RCTBatchedBridge 的 enqueueJSCall:method:args:completion: 方法，下面是参考了React Native通信原理解析(IOS)画的一张完整的调用流程图： tag11234567891011121314- (void)_actuallyInvokeAndProcessModule:(NSString *)module method:(NSString *)method arguments:(NSArray *)args&#123; RCTAssertJSThread(); __weak __typeof(self) weakSelf = self; [_javaScriptExecutor callFunctionOnModule:module method:method arguments:args callback:^(id json, NSError *error) &#123; [weakSelf _processResponse:json error:error]; &#125;];&#125; 这个方法其实也没什么特别的，主要看一下 callFunctionOnModule 方法的 callback，在 callback 中调用了 _processResponse 方法，用来处理执行 js 端调用 native 的方法。 tag21234567891011- (void)_callFunctionOnModule:(NSString *)module method:(NSString *)method arguments:(NSArray *)args returnValue:(BOOL)returnValue unwrapResult:(BOOL)unwrapResult callback:(RCTJavaScriptCallback)onComplete&#123; // TODO: Make this function handle first class instead of dynamically dispatching it. #9317773 NSString *bridgeMethod = returnValue ? @"callFunctionReturnFlushedQueue" : @"callFunctionReturnResultAndFlushedQueue"; [self _executeJSCall:bridgeMethod arguments:@[module, method, args] unwrapResult:unwrapResult callback:onComplete];&#125; 在这个方法中，设置了调用 js 端 batchedBridge 的 callFunctionReturnFlushedQueue 或者 callFunctionReturnResultAndFlushedQueue 方法。并将 module，method，args 作何成一个数组作为 arguments 传入。由于 native 端需要主动调用的 js 端的方法都是 native 所熟知的模块和方法，所以这里的各个参数都是 string（只有那些自定义的模块或者方法的调用才会用 id）。 tag3在执行完 js 端的方法后，回到 RCTJSCExecutor 内执行 onComplete 回调: 1234567891011- (void)_executeJSCall:(NSString *)method arguments:(NSArray *)arguments unwrapResult:(BOOL)unwrapResult callback:(RCTJavaScriptCallback)onComplete&#123; [self executeBlockOnJavaScriptQueue:^&#123; //执行js方法 ... onComplete(objcValue, error); &#125;];&#125; 这个 onComplete 就是上面 tag1 中的 callback。 tag4js 调用 oc 可以有很多个方法，但是最后方法一定会走到 handleBuffer: 方法中去。这个方法在上面的 MessageQueue 中也有提到过。入参是一个包含模块、方法、参数的数组。 现在就用到了之前保存的 _moduleDataByID 数组。 12RCTModuleData *moduleData = self-&gt;_moduleDataByID[moduleID.integerValue];dispatch_queue_t queue = moduleData.methodQueue; 通过传入的 moduleID 就可以在数组中找到对应的 RCTModuleData 实例，拿出每个 RCTModuleData 的 gcd 队列。之后就是在各自队列里执行了。由于是串行队列，同一个 RCTModuleData 的方法必须是顺序执行的。 tag5这个就是正真通过反射的方式执行 native 代码的方法。由于也是 iOS 菜鸟，对于 invocation 也不是很了解，所以这段代码不是很能看得懂，就不细聊了。各位大神可以仔细跟进。 不过要注意其中的 processMethodSignature 方法。这个方法中，RN 会对反射的 selector 进行分析，分析有几个参数，是什么类型等等。其中就在 addBlockArgument 这个 block 中，设置了一个输入参数为数组的回调方法： 123RCT_BLOCK_ARGUMENT(^(NSArray *args) &#123; [bridge enqueueCallback:json args:args];&#125;); 这个 RCT_BLOCK_ARGUMENT 宏是用来保存这个回调方法的。因为 NSInvocation 不会持有这个 block。其中的 enqueueCallback:args: 就是用来回调前面保存的 _callback 的。 后面所有的方法调用，大致过程都和 native 调用 js 一样，只不过前者传入的是 callbackID，后者传入的是各个模块方法参数名。所以我也就不再展开了。 参考文章React Native 从入门到原理 看完可以对 RN 有一个初步的认识ReactNative iOS源码解析 native 端讲解的非常详细，需要仔细地跟着走一遍React Native通信原理解析(IOS) native 和 js 都讲解的较为详细，前面那篇看懂了，再来看这篇，可以加深理解。(部分内容有一些区别)]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 setTimeout() 看js的 Event Loop 执行过程]]></title>
    <url>%2F2016%2F12%2F28%2FEventLoop%2F</url>
    <content type="text"><![CDATA[通过 setTimeout() 方法，来了解 js 中的代码执行。本文参照干货 | 原来你是这样的 setTimeout) Event LoopJs 引擎是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的，但是实际开发中我们却可以使用异步代码来解决。Js 为了引入异步的特性，引申出一个重要的东西，Event Loop（事件循环）。 当异步方法，比如 setTimeout() 执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。 第一个 setTimeout 例子例子1234567891011console.log('start');setTimeout(() =&gt; &#123; console.log('hello');&#125;,300);setTimeout(()=&gt;&#123; console.log('world');&#125;,200);console.log('end'); 运行结果为：1234startendworldhello 过程首先第一个 console.log() 入栈执行，执行完毕控制台打印 start 后出栈，紧接着执行到 setTimeout 定时器，此时 JS 引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做 Timer 模块），然后主线程继续向下执行，紧接着将第二个定时器也交给 Timer 模块，然后执行到第二个 console.log()，控制台打印 end，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer 模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中(注意，是满足触发条件了再放到任务队列中)。Timer2 延迟 200ms，所以会早于 Timer1 被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将 Timer2 回调中的 console.log() 执行，控制台打印 world，然后执行栈空闲后继续检查任务队列，将 Timer1 的代码压入执行栈中执行，控制台打印 hello，清空执行栈，此时任务队列为空，执行结束。 第二个 setTimeout 例子例子12345678910111213141516171819console.log('start');setTimeout(() =&gt; &#123; console.log('hello');&#125;,300);setTimeout(()=&gt;&#123; console.log('world');&#125;,200);for (var i=0;i&lt;100000;i++)&#123; console.log(1)&#125;setTimeout(()=&gt;&#123; console.log('i am run');&#125;,100);console.log('end'); 结果：123456start...endhelloworldI am run 过程Timer3 仅仅延迟了 100ms，反而在另外两个 Timer 之后执行了。其实这里原因很简单，因为在 Timer1 和 Timer2 加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的 Timer1 和 Timer2 并不会得以执行。当for循环结束，这时才将 Timer3 交由 Timer 模块去管理(注意，代码顺序执行，for循环的时候， Timer3 的 setTimeout() 还没有执行，所以也就还没有被 Timer 模块管理)，继续执行后续代码打印 end，清空执行栈。虽然在这里 Timer3 的延迟时间最短，但是加入任务队列后还是会排在 Timer1 和 Timer2 的后面，所以此时按顺序执行任务队列中的代码，依次打印。 需要注意的是，执行完 console.log(&#39;end&#39;); 后，立刻执行了 Timer1 和 Timer2，但是 Timer3 执行时间约在之后 100ms，这是因为for循环执行的时间超过了300ms。如果for循环在100ms以内完成，那么 console.log(&#39;i am run&#39;); 仍然是最先执行的。如果for循环在100ms到200ms之间，那么 console.log(&#39;i am run&#39;); 在 console.log(&#39;world&#39;); 之后，console.log(&#39;hello&#39;); 之间执行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP详解]]></title>
    <url>%2F2016%2F12%2F24%2FHTTP%E7%9A%84%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[网络协议这块一直没有搞透彻，趁着苹果强制 ATS（Apimp Transport Security）未果，学习一下这方面的知识。 HTTP的构成HTTP Requesthttp 请求主要分为三部分，如下图所示。request line，header 和 body，中间的CRLF为换行符。 下面将以一个实际的 http 请求来详细看看其内部构造。假设我们的请求URL为：http://www.baidu.com/res/static/thirdparty/connect.jpg?t=1480992153433 Request Line请求行的结构为： 1Request-Line = Method SP Request-URI SP HTTP-Version CRLF Method:请求类型，例如 post/get。 SP:分隔符，一般就是空格。 Request-URI:对应上述请求为：/res/static/thirdparty/connect.jpg?t=1480992153.564331。注意，Request-URI 也可以是带 host 的完整 uri。不带的话，就要在 Header 里添加 host。 HTTP-Version:代表我们当前使用的版本，例如 HTTP/1.1 CRLF:CR 对应回车键，LF对应换行键，合起来就是我们平常所说的 \r\n。 所以上述请求的 Request-Line 的文本展示： GET /res/static/thirdparty/connect.jpg?t=1480992153.564331 HTTP/1.1CRLF Headerheader 其本质上是一些文本键值对，一个典型的例子如下图所示： 结构为： 1Key:空格ValueCRLF 上面讲述 Request-URI 的时候，缺失的 Host 就以键值对的形式存在于 header 中，比如， Host： pan.baidu.com。 将若干个上述格式的键值对组合起来，就成了我们 HTTP 请求的完整 header。最后一个键值对之后再跟一个 CRLF，就表示我们的 header 结束了。 Bodybody 里面包含请求的实际数据。 对于 Method=GET 的请求来说，body 体是为空的，Header 最后的两个 CRLF 就标识着请求的结尾。我们一般调用请求的业务参数是通过 Request Line 当中的 Request-URI 来传递的，比如上述请求中的 ?t=1480992153.564331，也就是 URI 的 query string 部分。这部分同样是以键值对的形式存在，不过是位于 Request Line 当中。 对于 Method=POST 的请求来说，实际的业务数据都存放于 body 当中。POST 请求可以根据 Header 中的 Content-Type 值，以不同的形式将数据保存在 body 体中。获取到请求后，可以仍然通过 Header 中的 Content-Length 值，读取固定长度的body体，直接传递给应用层 HTTP Responseresponse 的结构和 request 大致相似，不过是将 Request Line 换成了 Status Line 。 Status Line 的结构如下：1Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF Content-TypeContent-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 text/html。 一些常见的 Content-Type: text/html text/plain text/css text/javascript application/x-www-form-urlencoded multipart/form-data application/json application/xml 前面几个都很好理解，都是 html，css，javascript 的文件类型，后面四个是POST 的发包方式。 那我们什么时候用 application/x-www-form-urlencoded，什么时候用 multipart/form-data 呢？大文件如文件图片用后者，小文件如键值对用前者。 Cache-Control 和 ETag 区别Cache-Control 表示浏览器使用缓存，不像服务器发送请求。当 Url 不变时，如果资源没有超过 Expires 时间，则不进行服务器请求，直接使用浏览器缓存。 ETag 是请求资源文件的哈希值。在客户端请求后，服务端把资源文件的 md5 值作为 ETag 返回给浏览器。当浏览器下次请求的时候将这个 ETag 的值作为请求头字段 if-none-match 传给服务端，当资源文件不变的时候，服务端返回 304，当资源文件变化的时候，服务端将新的资源文件的 md5 值作为 ETag，连同资源文件返回给浏览器。 HTTP2.0 的改进 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。HTTP2.0将文本转为二级制传输。如下图： HTTPS基本介绍HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。比如运营商可以轻易劫持你的 http 请求，在 response 中注入 js代码（如网页上弹窗广告、流量球等），甚至是重定向。为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。之后对 SSL 进行了升级为 TLS（Transport Layer Security）。我们现在的 HTTPS 都是用的 TLS 协议。 一般来说 HTTPS 也需要进行 TCP 的三次握手，但是和 HTTP 不同的是，HTTPS 还需要进行 SSL 握手。这也就是其比 HTTP 在建立连接时慢的主要原因。 工作原理总共分为以下几步： 浏览器将自己支持的一套加密规则发送给网站。 网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 获得网站证书之后浏览器要做以下工作： 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 网站接收浏览器发来的数据之后要做以下的操作： 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 使用密码加密一段握手消息，发送给浏览器。 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。 其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而 HASH 算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。 为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。 证书的验证过程证书以证书链的形式组织，在颁发证书的时候首先要有根CA机构颁发的根证书，再由根CA机构颁发一个中级CA机构的证书，最后由中级CA机构颁发具体的SSL证书。我们可以这样理解，根CA机构就是一个公司，根证书就是他的身份凭证，每个公司由不同的部门来颁发不同用途的证书，这些不同的部门就是中级CA机构，这些中级CA机构使用中级证书作为自己的身份凭证，其中有一个部门是专门颁发SSL证书，当把根证书，中级证书，以及最后申请的SSL证书连在一起就形成了证书链，也称为证书路径。在验证证书的时候，浏览器会调用系统的证书管理器接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，整个验证的结果才是受信。操作系统在安装过程中会默认安装一些受信任的CA机构的根证书。 SSL劫持SSL 劫持也就是 SSL 证书欺骗攻击，攻击者为了获得 HTTPS 传输的明文数据，需要先将自己接入到浏览器与目标网站之间（中间人），在传输数据的过程中，替换目标网站发给浏览器的证书，之后解密传输中的数据，简单的图示如下： [浏览器] &lt;======&gt; [目标网站] （正常情况）[浏览器] &lt;======&gt; 中间人 &lt;======&gt; [目标网站] （中间人攻击） 中间人攻击最好的环境是在局域网中，局域网中所有的计算机需要通过一个固定的出口（网关）来接入互联网，因此攻击者只需要在局域网中实施一次中间人攻击就可以顺利的截获所有计算机与网关之间传输的数据。 中间人攻击(Man-in-the-Middle Attack，缩写 MITM)。 参考链接:HTTPS那些事（一）HTTPS原理 抓包工具 mitmproxy 使用mitmproxy 是一款命令行抓包工具，它除了可以抓包查看 http/https 请求，还可以拦截并修改 request 或者 response。 安装1brew install mitmproxy 配置手机和电脑在同一局域网下，设置手机的 http 代理。服务器为电脑当前的 ip，如 192.168.3.10；端口可任意设置，一般设置为8080。网络环境配置好后，在终端输入 mitmproxy -p 8080，进入抓包模式。 如果想要抓取 https 的包，需要进一步配置。用 iPhone 打开 Safari 浏览器并输入 mitm.it，这时你会看到如下页面，选择对应平台并安装证书，安装完成后就可以抓 https 的包了。注意，用浏览器打开时需要已经在抓包模式，否则是无法看到上述页面的。 抓包软件相当于在用户和服务器间增加了一个中间人。安装抓包软件的证书，这样中间人就可以获得用户端生成的密钥，就能够解密用户和服务器间的信息。注意，一定不可随意下载信任不明的证书 使用随便打开一个 app，就可以看到如下的一个请求列表。 常用快捷键： enter: 查看详细请求 Tab: 切换顶部导航栏 z: 清空列表 f: 过滤请求。可以参照帮助中的 Filter expression 对过滤关键字进行编辑。删除过滤就是将过滤关键字清空。其实还可以有更多过滤方式，包括过滤指定的 header，指定的 body，过滤请求、回复等。具体参见文档 d: 删除请求 h: 显示所有帮助 m: 改变请求返回实体的类型。比如把 raw 改为 json 除了快捷键，我们可以按住 command 点击 url 来在浏览器中查看网页信息。可以按住 command+option+fn 然后选中信息 拦截输入 i 设置拦截，再输入 ~s 进入 response 拦截模式，~q 进入 request 拦截模式。如果不想拦截了。再次输入 i 将刚才设置的参数清空即可。也可以键入 I 表示暂停拦截。 设置拦截后，拦截下来的请求为红色。这时 Enter 进入后 再按 e 就可以修改 request 或者 response，会先让你选择修改哪一部分，一般都是修改返回的数据对应于里面的 raw。修改时是用 vim 进行编辑的，修改完成后按 a 将请求放行，如果要放行所有请求输入 A 即可。 中文字符无法显示中文字符无法显示其实是终端的问题。我们要修改 .zshrc，在最底部添加下面的代码： 12export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 然后重启，就可以看到中文字符了。 iOS 模拟器抓包为模拟器抓包需要设置网络代理为本机，勾选 HTTP 代理和 HTTPS 代理： 还要为模拟器配置 SSL 证书。配置证书相对麻烦。首先进入 ~/.mitmproxy目录，这个目录下有五六个证书，其中一个是符合要求的。需要下载一个 python 脚本 来导入证书。下载后执行： 1./iosCertTrustManager.py -a mitmproxy-ca-cert.pem 这个脚本只能导入 pem 格式的证书。执行时会问你是否将其添加到某个模拟器中，按 y 即可。添加成后需要重启模拟器就能够抓取 https 的包了。 模拟器抓包提示Certificate Verification Error for www.xxxx.com: unable to get local issuer certificate使用： 1mitmproxy -p 8080 --ssl-insecure --set block_global=false 忽略安全校验]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 配置遇到的一些坑]]></title>
    <url>%2F2016%2F12%2F03%2Fhexo%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[配置个人博客有时候是一件很蛋疼的事情，经常会出现一些奇奇怪怪的问题。这里我就将把我填上的一些坑总结一下。 hexo d 无法提示 fatal: could not read Username for xxx之前一直没有问题，最近突然报了这个错。原因就是没有设置好用户名密码。 打开 _config.yml，修改deploy节点: 1234567891011# 原来的设置deploy:type: gitrepo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.gitbranch: master# 修改为deploy:type: gitrepo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.gitbranch: master 更新 hexo自从把自己的博客构建起来后就没有升级过 hexo，这次要设置 apple-touch-icon，更新了 hexo，也花了小半天时间。记述一下，以后更新或者换电脑迁移就容易一些了。 下载 npmnpm 是由 node 提供的。因此，到 node 的官网下载安装 node 即可获得 npm 安装 hexo使用如下命令安装 hexo 的最新版本 1npm install hexo-cli -g 初始化 hexo如果你是更新 hexo，可能以为这步没有必要，这么想就错了。hexo 更新的时候会更新一些 node-modules，这些 node-modules 并不在 package.json 中记录，这些 module 是很重要的。所以不管是更新还是新建，你都必须要初始化 hexo。你可以在一个空文件夹中初始化好 hexo，然后把这些 module 拷贝到你当前的 node-module 文件夹内 1hexo init 下载 node-module这步就不多说了 1npm install 下载 deploy modulehexo3 开始需要借助一个 deploy module 来推送博客，但这并没有在默认的 package.json 中，要自己动手添加： 1npm install hexo-deployer-git --save 更新 nextnext 肯定要和 hexo 同步更新呀，现在 next 主题非常人性化了，现在可以添加 apple-touch-icon，而且也有了默认的本地搜索。所以记得要仔细看配置文件，不要直接把以前的配置文件直接拷贝过来。 更新 next更新 next 的话，你可以直接把原来的 next 文件夹删掉，然后使用终端拉取： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 更改图片包括 favicon，apple-touch-icon，avatar 都可以在 next 主题中随意替换。路径在 next 主题的 _config.yml 中配置，默认路径在 themes/next/source/images 内。 搜索在 _config.yml 中已经有了搜索的配置，你只要设置 enable 为 true 即可。然后就是下载搜索的 module，执行： 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 各种部署的内容和本地不一致有时候 hexo 会抽风，有些文件无论怎么 hexo g 都 deploy 不上去。这个时候可以输入 hexo clean，删除 database 和 public 文件夹，再 generate 和 deploy 就可以部署成功了。 搜索功能打不开写了一片文章后点击搜索无响应了。 这回的原因是在文章中的某一处多了一个空白字符，就是那种什么位置也不占，但是按一次 delete 才能删除的那种东西。把这个空白字符删掉就可以正常搜索了。 产生这种字符的原因不太清楚，排查起来也很麻烦。本来都是每次修改后，都要 hexo g 再 hexo s 的，很费力。不过，后来我发现如果启用本地服务器，即 hexo s，那么直接修改后，刷新 localhost 的网页(也可以不刷新)，就可以直接查看修改是否有效了。所以说本地服务器的搜索应该不走 search.xml ，而是直接拿取本地文件。这样调试起来方便许多。 排查的方法就是先删部分文件，看是否可以打开搜索功能，这样就能定位到某个文件，然后同样的方法定位到某一段，最后在这一段中不停的移动光标，如果有空白字符，那么会在某个地方移动光标的时候，光标不动。这个时候删除这个空白字符就行了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>爬坑</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 技巧与坑总结]]></title>
    <url>%2F2016%2F11%2F25%2FRN%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文将收集关于 React-Native 的各种技巧与坑，不论是摘录的还是自己遇到的。 函数式组件函数式组件即通过调用一个方法返回一个组件。比如返回一个 class： 123456789101112start (TopLevelNavigator) &#123; let store = this.getStore() return class extends Component &#123; render () &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;TopLevelNavigator /&gt; &lt;/Provider&gt; ) &#125; &#125;&#125; 上面通过调用一个 start 方法，返回一个新的组件的类。不过对于无状态的组件来说，可以有更好的写法。因为 class 也是一种 function，因此我们可以写成返回一个 function: 12345678910start (TopLevelNavigator) &#123; let store = this.getStore() return (props) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;TopLevelNavigator &#123;...props&#125;/&gt; &lt;/Provider&gt; ) &#125; &#125;&#125; 这样的写法更加直观。 PureComponent 和 ComponentPureComponent 和 Component 的不同在于前者提供了一个 shouldComponentUpdate 的默认实现。 继承于 Component 的组件没有实现默认的 shouldComponentUpdate 方法，每一个 props 的变化以及内部的 setState 方法的调用都会触发重绘。 继承于 PureComponent 的组件，默认在 shouldComponentUpdate 中比较将 props 和 state 中的每一项进行浅比较。如果有不同才重绘。所以如果在 PureComponent 内 setState 就一定要保证 setState 的对象和之前的对象的地址不同，否则比如修改对象中的某个字段这种在 PureComponent 中是不会重绘的。 震动震动使用 RN 自带的 Vibration 即可。这里主要提醒一下，如果是那种连续会触发的震动，可以使用 Vibration.cancel() 方法取消之前的震动，然后再 Vibration.vibrate(50) 继续短频震动。 获取控件的frame方式一给控件添加 onLayout 方法回调 123&lt;TouchableOpacity onLayout=&#123;(e) =&gt; this.rowlayouts= e.nativeEvent.layout&#125;/&gt; 就可以通过 this.rowlayouts 拿到组件的宽高以及起始坐标 方式二在其它点击事件触发的时候，通过 ref 获取： 12345678910111213import &#123; UIManager, findNodeHandle&#125; from 'react-native'handleClick = () =&gt; &#123; UIManager.measure(findNodeHandle(this.buttonRef),(x,y,width,height,pageX,pageY)=&gt;&#123; // todo &#125;) &#125;&lt;TouchableButton ref=&#123;(ref)=&gt;this.buttonRef=ref&#125; onPress=&#123;this.handleClick&#125;/&gt; pointerEvents=&quot;none&quot; 的使用时机pointerEvents=&quot;none&quot; 可以让设置的视图不响应点击事件。实践下来有两个应用场景： 比如有一个绝对布局的视图盖住了下面的视图，在 iOS 中可以直接将其 userInteraction 置为 false。RN 中相应的属性就是 pointerEvents 监听手势事件的时候，我们希望获取当前手势相对于父视图的位置，即 event.nativeEvent.locationY ，但是如果父视图中有子视图，并且手势作用的起始点在子视图上，那么 event.nativeEvent.locationY 是以子视图为参照的，影响我们对于坐标的计算。这时候就可以把它的子视图设置 pointerEvents=&quot;none&quot; 再记述一下遇到的坑，在 android 上，如果父视图添加 panresponser，子视图直接设置 pointerEvents=&quot;none&quot; 会让子视图的区域无法响应父视图的手势。必须在子视图上再嵌套一层 View。并且这个 View 也是有讲究的不能直接嵌套。因为在 Android 上，空的 View 会被直接移除。所以需要设置 collapsable={false} 让Android也强制渲染，才能正确响应父视图的手势 存在手势的视图中的按钮点击事件不响应这个问题主要是因为点击按钮的时候手指有略微的滑动，因此，点击事件被识别为了 Move 事件，进而相应手势而不相应按钮了。 做法是在细微移动的时候不让手势相应： 1234onMoveShouldSetPanResponder (event, gestureState) &#123; let touchCapture = Math.abs(gestureState.dx) &gt; 5 || Math.abs(gestureState.dy) &gt; 5 return touchCapture&#125; FlatList 的性能优化FlatList 的 data 中接收一个数组，作为渲染的数据源。有时候我们点击了 cell，要改变状态引起重绘，但是直接修改 data 中某一项的值，并不会引起重绘。因为 React 中是判断 data 的地址是否变化，显然，data 并没有变化地址。 如果我们 data = data.map(item =&gt; item) 这样新建一个数据源就有点费事了。FlatList 提供了一个属性 extraData，当需要重绘的时候，改变 extraData 的值就行。 我们可以将 extraData 等于某一个 state 中的布尔值，每次需要重绘的时候，让这个布尔值取反。这样 FlatList 发现这个布尔值改变了，就会引发整个 FlatList 的重绘。 整个 FlatList 的重绘也是会引发性能问题的。我们要做的是自定义一个 Cell 类，然后将数据源的某个 item 设置为一个新的对象：Object.assign({}, item, {someChange: xxx})这样在 FlatList 重绘触发每一个 cell renderItem 的时候，大部分 Cell 并没有收到新的 Props 就会阻止整个 cell 的重绘。只有数据变化的 cell 才会触发重绘 组件在动画下的隐藏和显示组件从隐藏到显示的动画是非常好想到的，就是设置组件的 opacity 透明度。 而从显示到隐藏的过程就有点坑了。如果还是设置透明度为 0，那么节点还在，无法响应后面视图的点击事件。但是如果 render 的时候返回 null，那么组件节点就直接消失了，无法达到动画的效果。 这里有两种方式设置隐藏： display这里我们应该借助一个 CSS 属性 display ,当它为 none 的时候，节点还在，但是组件从视图上移除了，不会影响后面的点击事件。 这里举一个显示头部视图的例子。示例代码如下： 1234567891011121314151617181920212223242526renderHeader () &#123; if (this.props.showHeader) &#123; this.state.showHeader = true Animated.timing(this.headerViewAlpha, &#123; toValue: 1, duration: 700 &#125;).start() &#125; else &#123; Animated.timing(this.headerViewAlpha, &#123; toValue: 0, duration: 700 &#125;).start(() =&gt; &#123; this.setState(&#123; showHeader: false &#125;) &#125;) &#125; // 外部让显示的情况下，内部也让显示的时候才显示 let display = !this.state.showHeader &amp;&amp; !this.props.showHeader ? 'none' : 'flex' return ( &lt;Animated.View style=&#123;&#123;opacity: this.headerViewAlpha, marginBottom: -20, display&#125;&#125;&gt; &#123;this.props.headerView()&#125; &lt;/Animated.View&gt; )&#125; 这个组件通过外部传进来的 showHeader 控制显示和隐藏。当外部传来的 showHeader 为 true 时，直接通过透明度的动画显示组件。当外部传来的 showHeader 为 false 时，先通过透明度动画隐藏组件，然后设置内部的 showHeader 为 false，重绘视图。重绘的时候因为内外部的 showHeader 都为 false，就将 display 设为 none 了，从而达到在动画完成后隐藏视图的效果。 这种方式在 render 方法中又设置了 state 其实是不太推荐的。 height另外一种方式就是设置视图的高度，使其高度为 0: 123456789101112131415161718192021this.headerViewHeight = new Animated.Value(deviceHeight)if (showCurrentHeader) &#123; Animated.timing(this.headerViewHeight, &#123; toValue: deviceHeight, duration: 0 &#125;).start()&#125; else &#123; Animated.timing(this.headerViewHeight, &#123; toValue: 0, duration: 700 &#125;).start()&#125;renderHeader () &#123; return ( &lt;Animated.View style=&#123;&#123;height: this.headerViewHeight&#125;&#125;&gt; &#123;this.props.headerView()&#125; &lt;/Animated.View&gt; )&#125; 这里动态修改了 headerViewHeight 这个高度。不过要注意，这里修改了高度并不是说子视图就一定会隐藏的。有些组件可能还是会展示出来，这个时候就要设置 style 的 overflow: &#39;hidden&#39; 上面这种方式你可能会有疑问，这是知道控件高度的情况下才可以设置高度。那么如果控件的高度是包裹的控件的高度，无法知道准确的 height，这种情况怎么办呢？ 思路是不进行动画之前不设置 height，在渲染完成的时候，将视图的高度保存起来，待到将要开始动画的时候，立即 setState，将 height 设置进去，在 setState 的回调中开启动画。下面是一个动画实现 Cell 删除的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243export default class CanDeleteCell extends React.PureComponent &#123; constructor (props) &#123; super(props) this.alpha = new Animated.Value(1) this.height = null this.state = &#123; isDelete: false &#125; &#125; deleteCell () &#123; return new Promise((resolve, reject) =&gt; &#123; this.setState(&#123; isDelete: true &#125;, () =&gt; &#123; Animated.timing(this.alpha, &#123; toValue: 0, duration: 500 &#125;).start() Animated.timing(this.height, &#123; toValue: 0, duration: 500 &#125;).start((finished) =&gt; &#123; if (finished) &#123; resolve(this.props.index) &#125; else &#123; reject(this.props.index) &#125; &#125;) &#125;) &#125;) &#125; render () &#123; const innerStyle = this.state.isDelete ? &#123;opacity: this.alpha, height: this.height&#125; : &#123;opacity: this.alpha&#125; return ( &lt;Animated.View onLayout=&#123;e =&gt; &#123; this.height = new Animated.Value(e.nativeEvent.layout.height) &#125;&#125; style=&#123;[...this.props.style, innerStyle]&#125; &gt; &#123;this.props.children&#125; &lt;/Animated.View&gt; ) &#125;&#125; 在最开始渲染的时候，使用 onLayout 拿到高度，待到外部调用 deleteCell 方法的时候，立即 setState 把 isDelete 置为 true。然后重绘。 带有 Gesture 的父组件会 block 子组件中 TouchableOpacity 的点击事件把按钮放到有 Move 手势的父组件的时候会经常因为响应了父组件的 Move 手势而不响应按钮的点击事件。这个时候需要给 Move 手势的添加行为做一个限制： 1onMoveShouldSetPanResponder: (evt, gestureState) =&gt; Math.abs(gestureState.dx) &gt; 5 || Math.abs(gestureState.dy) &gt; 5 当移动的距离超过5之后，才响应滚动事件。 使用绝对路径替代相对路径如果在 import 的时候使用相对路径，那么有些层级较深的时候会非常难看，可以使用devdependency 中安装 npm 插件：babel-plugin-root-import 然后在.babelrc 中加入： 12345678910&#123; "plugins": [ [ "babel-plugin-root-import", &#123; "rootPathSuffix": "src", "rootPathPrefix": "@" &#125; ] ]&#125; 这样就可以使用 @ 来代替目录 src. 消除 console.log我们可以通过 babel 插件将 console 去除。 首先在 devdependency 中安装 npm 插件：babel-plugin-transform-remove-console 然后在更目录下新建一个名为 .babelrc 的文件，在其中加入： 1234567&#123; "env": &#123; "production": &#123; "plugins": ["transform-remove-console"] &#125; &#125;&#125; 为 FlatList 设置 ListEmptyComponent如果直接设置 ListEmptyComponent 占位符你会发现，即使将 ListEmptyComponent 的 style 设置为 {flex:1} 它也并不会填充满 flatList。这是因为包裹它的外层 View 没有设置高度。这就需要我们自己将 FlatList 的高度设置给 ListEmptyComponent。可以使用 onLayout 方法： 1234567&lt;FlatList onLayout=&#123;e =&gt; &#123; this.setState(&#123; fHeight: e.nativeEvent.layout.height &#125;) &#125;&#125;/&gt; 我们在 FlatList 布局的时候获取到它的高度设置为 state 即可。 standard 进行代码校验使用 standard 进行代码规范校验： 1npm install --save-dev standard 然后在 package.json 中配置: 123456789&#123; "standard": &#123; "parser": "babel-eslint", "globals": [ "fetch" ], "ignore": [] &#125;&#125; 可以在 globals 中设置需要忽略的全局对象或者方法 husky hook git commit我们可以使用 husky hook git 的提交方法。安装方式如下： 1npm install husky --save-dev 然后在 package.json 中配置： 12345678910&#123; "scripts": &#123; "lint": "standard --verbose | snazzy", &#125;, "husky": &#123; "hooks": &#123; "pre-commit": "npm run lint", &#125; &#125;&#125; 需要注意的是，husky 安装的时候会在 .git 文件夹下生成 hook 文件夹，如果是拷贝的别人的 node_modules，不会生成 hook 文件夹，所以需要先 uninstall 再 install 一遍 清除 RN package 缓存一般情况下我们不需要清除 package 的缓存，清除缓存后再打开会非常耗时。但是我遇到了一种情况就是使用 babel-plugin-root-import 使用 @ 替代 src 目录的时候，@ 的指向总是不对。所以我怀疑可能是缓存的问题。 清除缓存使用命令： 1npm start -- --reset-cache 注意中间要加上 -- Immutable.js 的使用动机一般说到 React 性能优化就会提到 Immutable 这个库。这里介绍一下它的使用场景。 当一个页面的状态树很大的时候，我们更新叶节点的时候只希望更新与之相关的节点，比如下图： 如果改变了其他节点的引用，可能会导致用到其他节点数据的视图重绘，浪费性能。一般情况下，当节点层数较浅的时候，我们会使用展开运算符，只改变响应节点的值，其余节点都使用原来的引用。但是节点层数深的时候，也会变得很麻烦。所以就可以使用 Immutable.js 这个库。当你改变某个叶节点的值的时候，它会自动将其相关的根节点更新为新的引用，而其他无关的节点还保持原有引用。 当然，Immutable 提供的类型毕竟不是原生类型，使用起来需要注意一些地方，所以最好还是把状态树设计的扁平一些。 react-native linkreact-native link 方法可以把 node_module 中的 RN 库链接到 iOS 以及 Android 工程中。但是其中有一个坑点，就是在 iOS 端，react-native link 只会将 RN 库链接到 default target 中，而自己另外新建的 target 需要自己动手链接到 Link Binary with Libraries 中 黄色警告黄色警告以及红屏报错可以手动触发： 12console.error('红屏错误')console.warn('黄屏警告') 我们开发的时候，应该尽可能避免黄色警告。但是如果这个警告是第三方引入的呢？我们可以隐藏特别类型的警告，比如 ant-design 引入的如下警告： 我们可以通过下面的代码隐藏： 1234567import &#123;YellowBox&#125; from 'react-native'const ignoreCase = [ // ant design 引入的 'Warning: NativeButton: prop type `background` is invalid;']YellowBox.ignoreWarnings(ignoreCase) 何时重绘触发重绘有两种方式： setState 调用的时候。 props 变化的时候 现有的例子开看， setState 只是用来标记重绘的，标记了重绘后。React 的 render 方法生成的新的 JSX 对象和老的 JSX 对象比较，看看两个 JSX 对象的各个部分有哪些地方不同。然后渲染不同的部分 由于 componentWillReceiveProps 后面接着的就是 render 方法，所以 componentWillReceiveProps 中不需要使用 this.setState 。直接修改 this 上的属性也是可以的比如： 12345678910componentWillReceiveProps (nextProps) &#123; this.count = nextProps.count&#125;render () &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;this.count&#125;&lt;/Text&gt; &lt;/View&gt; )&#125; 这样也是可以正确渲染出 this.count 的。 性能优化利用 shouldComponentUpdate针对有子组件的视图，每次父组件 render 的时候，都会触发子组件的 componentWillReceiveProps 和 render 方法。所以我们创建子组件的时候，最好重写 shouldComponentUpdate 方法，去判断 props 中的各个属性是否变化。一般出于性能原因，shouldComponentUpdate 方法都是进行浅层判等，即判断之前的属性和现在的属性是否是同一个对象: 123shouldComponentUpdate(nextProps, nextState) &#123; return (nextProps.completed !== this.props.completed) || (nextProps.text !== this.props.text)&#125; style 不要写在 JSX 中这里有一个注意点，如下代码即使重写了 shouldComponentUpadate 方法也是一直会重绘的： 1&lt;Foo style=&#123;&#123;color: 'red'&#125;&#125; /&gt; 这是因为，{color: &#39;red&#39;} 相当于每次都传入了一个新的对象。所以传 style的时候，不要直接写在 JSX 中 其实任何属性，包括传一个方法都不应该直接写在 jsx 中，如果都不写在 jsx 中，就会产生很多冗余代码。所以注意 style 写在 styleSheet 中这点即可。 render 时不要使用箭头函数我们在 render 一个 button 的时候经常这么写： 12&lt;Button onClick=&#123;()=&gt; this.doClick()&#125;&gt;&lt;/Button&gt; 这样会导致组件的重绘。因为每次渲染的时候会重新创建这个箭头函数，导致传入了新的 props。正确的做法应该是把这一过程提前： 12doClick = () =&gt; &#123;&#125; 12&lt;Button onClick=&#123;this.doClick()&#125;&gt;&lt;/Button&gt; 这样 doClick 方法传递的就是一个引用了。（如果有些方法需要参数，那么把参数作为 props 传入） 并不是说使用箭头函数一定会产生重绘，有些组件内部会重写 shouldComponentUpdate 方法，会无视这种 onClick 事件。但是如果组件内部没有这么做。就需要自己注意箭头函数引起的重绘了。 使用 react-redux 的 connect 方法我们写组件的时候写 shouldComponentUpdate 判断一个个 props 是否变化其实是一个蛮烦的事。react-redux 其实帮我们做了这件事。使用它提供的 connect 方法，不需要做任何其他的事情，只要在 export 组件的时候做一些改变即可： 123export default TodoItem=&gt; 改为export default connect()(TodoItem) connect() 参数为空，表示不从 store 中获取任何状态与方法 keykey 是一个老生常谈的东西。对于一个列表的每一项，需要唯一的 key 值。新老列表，key 值不同的项，视图将会被 Unmount 以及 mount，对于 key 值相同的项，视图只会被更新。 对于一个列表，如果我们不设置 key 值，默认是使用列表数组的索引 index 作为 key。但是这样会产生性能问题。比如删除了列表的第一项，整个列表的每一项都会更新 那如果我们在列表中添加一项的时候，什么值能作为这个唯一的 key 呢？可以依靠时间：Data.now()。 比方说在 add 的时候，为添加的项创建一个 key 字段： 1234567891011121314addItem: function(e) &#123; var itemArray = this.state.items; itemArray.push( &#123; text: this._inputElement.value, key: Date.now() &#125; ); this.setState(&#123; items: itemArray &#125;);&#125; 这样每次添加的时候，key 就获得了唯一值。 Reselect使用 react-redux 的时候，还经常搭配另一个常用的库 Reselect。我们存在 redux 中的 state 可能需要经过一些处理。 比如 state.a 和 state.b 可能通过 g(a,b) 衍生出 c。这个 c 如果放在 redux 中，那么每个 state.a 和 state.b 变化的地方都要计算 g(a,b)，很容易遗漏出错。如果把 c 放在 render 方法中，即每次 render 的时候计算 g(a,b)，又会造成重复计算。 因此，比较好的做法就是在 state.a state.b 变化的时候计算 g(a,b)，并且即不把g(a,b) 放在 redux 中，也不放在 render 中。所以，我们可以通过 redux 把数据传给组件的时候添加计算属性的方式来达到目的，即通过 mapStateToProps 方法。 是不是很像 vuex 中的 getter。Vue 真是太人性化了 12345678910111213141516171819202122232425262728293031323334353637import &#123; createSelector &#125; from 'reselect'fSelector = createSelector( [state =&gt; state.a, state =&gt; state.b], (a, b) =&gt; f(a, b))hSelector = createSelector( [state =&gt; state.b, state =&gt; state.c], (b, c) =&gt; h(b, c))gSelector = createSelector( [state =&gt; state.a, state =&gt; state.c], (a, c) =&gt; g(a, c))uSelector = createSelector( [state =&gt; state.a, state =&gt; state.b, state =&gt; state.c], (a, b, c) =&gt; u(a, b, c))...function mapStateToProps(state) &#123; const &#123; a, b, c &#125; = state return &#123; a, b, c, fab: fSelector(state), hbc: hSelector(state), gac: gSelector(state), uabc: uSelector(state) &#125;&#125; 比如上面的例子，fab 是通过 ab 计算得到，通过 createSelector方法，注册了 ab，以及计算方法 f(a,b)。那么只有在 a || b 变化的时候，才会重新计算 fab setTimeout比较简单的一个 js 的方法，但是要记住，在某个组件被卸载（unmount）之后，计时器却仍然在运行，要解决这个问题，只需铭记在unmount组件时清除（clearTimeout/clearInterval）所有用到的定时器： 12345678910111213141516171819import React,&#123; Component&#125; from 'react';export default class Hello extends Component &#123; componentDidMount() &#123; this.timer = setTimeout( () =&gt; &#123; console.log('把一个定时器的引用挂在this上'); &#125;, 500 ); &#125; componentWillUnmount() &#123; // 请注意Un"m"ount的m是小写 // 如果存在this.timer，则使用clearTimeout清空。 // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear this.timer &amp;&amp; clearTimeout(this.timer); &#125;&#125;; 主线程渲染iOS 中渲染视图要在主线程中，所以 RN 中要调用原生方法，并且渲染视图的时候要通过 dispatch_async 到主线程进行。 比如 present 一个页面的时候就要在主线程中，否则 [self.retryBtn setTitle:@&quot;重试&quot; forState:UIControlStateNormal]; 这种设置按钮 title 的方法在非主线程中执行就无法渲染出 button 的 title 如何将图片字体资源自动添加到工程RN 项目中，会用到很多第三方的组件。这些组件在 react-native link 的时候会作为 library 链接到主工程下。但是存在一个问题，如果组件中包含了一些图片或者字体资源，这些资源不会在 link 的过程中被主动添加到工程中。那么我们需要手动添加。这是非常麻烦的一件事。 因此，我们需要一个自动化的将资源文件添加到工程的方法：rnpm。rnpm 是一个 RN 包管理工具，现在已经被纳入到 RN 中。 添加 将要加入到 iOS 以及 Android 的资源文件的路径确认。比方说在 ./assets 文件夹下。 在 package.json 中添加配置： 123"rnpm": &#123; “assets”: ["./assets"]&#125; 这里就是资源文件放置的路径。这里是一个路径的数组，可以放任意多个路径。 终端中输入 react-native link。通过 link 命令就把相关资源链接到工程中去了。你会看到如下提示信息： 删除没有命令可以直接删除。需要手动执行。 Android安卓直接将资源文件删除即可。（我不是十分确定） iOS在 Build Phases &gt; Copy Bundle Resources 中删除相关文件索引即可。 setState 的坑坑1setState 可以将控件刷新。但是这个操作不是立刻执行的而且在某个时间一并执行的。所以当你如果改变了 state 并且要用这个 state 作为参数进行网络请求的时候，不能直接使用 setState 给出的值，而要先将 state 改变，然后再 setState: 1234this.state.a = '1'this.setState(&#123; a: this.state.a&#125;) 坑2一定不能在 setState 的时候改变 state 的原来值。否则 state 会变成意想不到的值。比如一个数组，你不能直接在 setState 的时候往里 push值。你可以将数组复制，然后push 好之后再 setState，或者先设置好 state，然后再 setState。 坑3同一个函数中的多个 setState 不是分别调用的，而是等到某个时刻合并执行的。所以如果 setState 多次设置 state 中的某个值，前面的值的设置会被后面的覆盖掉。 比如： 123456789101112setState(&#123; obj: &#123; ...this.state.obj key1: value1 &#125;&#125;)setState(&#123; obj: &#123; ...this.state.obj key2: value2 &#125;&#125;) 注意，这里虽然设置的是不同的 key1 和 key2,看似没有问题。其实我们设置的是 obj。key1 被覆盖无法设置成功。 可以改成先改变 state，然后再 setState 刷新视图： 12345this.state.obj.key1 = value1this.state.obj.key2 = value2setState(&#123; obj&#125;) 当然最推荐的还是在设置 state 中同一个值时，在一起设置。 setState 原理在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。 为什么会这样？ 在React的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新this.state 还是放到队列中回头再说，而isBatchingUpdates默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为 true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程 setState 不会同步更新 this.state。 Text 控件对齐设置了宽高的 Text 控件只会在左上角显示。可以使用 text-align 设置文字的位置，比如 center。但是显示的时候你会发现只是水平居中。你必须再使用 line-height 设置高度为控件高度才能够竖直居中。 对于 text 控件，设置 height 是没用的，默认是 text 的高度。必须要设置 line-height 宽高Text 控件的默认宽高是正好包裹文字的，因此可以不设置宽高。但是这样的 Text 是不会折行的，如果想要 Text 折行，必须添加宽度。所以包含 Text 的控件最好不要设置 flex 来自适应，而是设置具体的宽度。 React/RCTBridgeModule.h file not found 解决方式这个问题出现在 RN 从 0.40 版本前升级到 0.40 版本后的情况下。0.40 前 react 的头文件都是以 Header Search Paths 加入的。使用 React 的组件都需要添加头文件查找路径。当组件需要使用 React 的时候，如果在组件所在的目录下没有找到，那么就会到 Header Search Paths 指定的路径中查找： 这样带来一个问题，就是每一个第三方的组件都需要设置一下 Header Search Paths 的路径。使用者会非常不方便。 所以 FB 想要把 React 头文件的链接统一起来。于是就有了 0.40 版本的变化：通过 Edit Scheme 然后添加 React 这个 Target，然后取消 Parallelize Build。 这样，在编译项目之前，就先把 React 编译好了。也就不再需要在 Header Search Paths 中设置了。 这样带来的改变就是原来引入头文件是相当于头文件在项目中了，使用： 1#import &quot;RCTBridgeModule.h&quot; 现在引入头文件是引入的外部的头文件，所以要使用尖括号： 1#import &lt;React/RCTBridgeModule.h&gt; keyboardShouldPersistTaps 的使用keyboardShouldPersistTaps 这是 scrollview 中的一个属性。 那么场景会用到这个属性呢？就是在一个 scrollview 中有两个 textinput a,b，当 a 输入完之后点击 b，这个时候如果你不设置 keyboardShouldPersistTaps 属性，那么点击 b 后，虚拟键盘消失，你需要再点一次 b 才能将虚拟键盘再打开，也就是说 scrollview 并没有相应 b 控件的点击事件。正常的需求应该是，点击 b 后，键盘仍然代开状态，只不过输入框变为 b。所以要用该属性控制。 该属性有三个枚举值： never: 默认情况，点击 TextInput 以外的子组件会使当前的软键盘收起。此时子元素不会收到点击事件。 always: 键盘不会自动收起，ScrollView 也不会捕捉点击事件，但子组件可以捕获。 handled:当点击事件被子组件捕获时，键盘不会自动收起。这样切换 TextInput 时键盘可以保持状态。多数带有TextInput的情况下你应该选择此项。 ListView 使用的问题ListView 的宽高ListView 在父视图的 flex 方向上默认是铺满的。flex 方向上设置的宽或者高是无效的，非 flex 方向上设置的宽或者高是有效的。 所以最好在 ListView 外面套一个 View，保证 ListView 填充满整个父 View renderRow 方法的坑renderRow 方法的几个参数为，rowData, sectionID, rowID 这几个值为字符串类型。 所以根据 id 采取不同行为的时候，要把 id 转化为 number 再比较。或者不要用 === ，否则肯定返回的是 false。 初始渲染数量ListView 为了保证渲染的性能，在最开始的时候只会部分渲染，所以需要设置 initialListSize 属性，设置首屏的渲染个数。否则很可能首屏需要加载的元素很多，但是实际渲染出来的元素很少。 cloneWithRows 使用的注意事项我们知道 cloneWithRows 是在 listview 中保存列表数组时使用的方法。使用的时候要注意一点：数组在 cloneWithRows 之后会变成一个特殊的数据结构，数据数组只是这个数据结构中的一个属性。 那么什么时候需要注意呢？一个父控件内的子控件里有一个 listview，那么要么传入数据在里面 cloneWithRows，要么在外面 cloneWithRows 好后直接传入，不能外部 cloneWithRows 一次后再在里面 cloneWithRows 一次。推荐是在外面 cloneWithRows 好后传入，这样更符合封装性。 View 设置宽高一个视图的显示必须要有宽高。以下是几个注意点： 父控件设置绝对宽高，子控件也设置了绝对宽高。这种情况是最简单的情况，注意子控件可能会超过父控件。 父视图设置了绝对宽高，子控件是 flex 布局： flex-direction 方向上的子视图必须设置明确的长度，即主轴必须明确设置多长。否则就默认为 0 非 flex-direction 方向上的子视图默认为填充满父视图，即 align-items 默认为 sketch。所以这里有一个坑点，如果你在父视图中设置 align-items: center 居中对齐，那么就取消了默认填充满父视图次轴这一设定，子视图一定要设置次轴上相应的长度，否则就是 0，显示不出了。 子控件设置了绝对宽高，父控件可以不设置宽高，父控件正好包裹子控件。 父子控件都是 flex 布局，都没有设置宽高。那么这种情况下很有可能显示不出。因为父控件需要一个 flex-direction 方向上的长度，但是并不能通过子控件推测出。那么就会不显示了。 布局方式一般布局如果是一个给定的布局，使用 flex 布局非常的直观。但是如果布局中的元素个数会变化的时候，就需要考虑一下了。比如下面这个图。中间的部分可能按情况不同会有增减： 一般有两种方式： 考虑父级 align-items 设置为 sketch，块1此时和父级一样高。这个然后设置块1，flex-direction 为 space-between。这样块1的子级就会均匀的分布在块1内了，不论有多少元素。所以你需要设置第一个子元素和最后一个子元素相对于块1的上边和下边的距离。 考虑父级 align-items 设置为 center，块1的高度取决于内部元素的高度，块1内的元素会居中。所以需要设置子元素之间的距离。 一般来说用 center 会比较好一些 设置 ImageImage 图片一定要设置宽高，因为如果图片默认大小是0，加载完图片后，会有个闪烁，可以设置主题的图片模式是 resizeMode = ‘contain’ 这样图片就能在指定大小内适应缩放。 另外，如果拿一个突破作为背景的时候，一定要同时设置 Image 的宽高，以及 Image 包含的 View 的宽高。注意，包含的 View 不会自动填充满 Image。 使用 JSXJSX 中的 this在 JSX 中调用外部的 js方法，如果要用到 this， 则必须 bind(this) 或者使用箭头函数，否则无法识别。 JSX 标签里一定不能有 {}，就比如你要把 View 里的 style 注释掉， 一定不能直接用 cmd+/ 这样会在 &lt;&gt;里加入 {}，产生 SyntaxError xxx.js Unexpected token,expected ...的错误 &lt;View &gt; 标签里的属性必须要要遵守如下的形式，即必须要用等号，并且要用 {} 把对象或者返回对象的方法包裹起来: 123&lt;View style = &#123;&#123;margin&#125;&#125;&gt;&lt;/View&gt; JSX 中的代码JSX 中可以通过 {} 插入代码。但是你不能直接把代码写在里面。{} 内允许你调用一个返回 JSX 节点或者以 JSX 节点为元素的数组的方法。 这里所说的方法可以是一个外部的方法，或者是一个三元运算符，或者是一个生成数组的方法，如 map 等。 如何隐藏一个组件如果让一个组件隐藏，或者根据不同情况改变组件展示。只需要在必要的时候通过 state 的变化，将原来 return 的 view 变成 return null 就可以了 12345678910_render() &#123; return( ... &#123; this.state.drawerOpen ? &lt;TouchableOpacity style=&#123;styles.modalContainer&#125; /&gt; : null &#125; ... )&#125; 注意用 {} 包裹的部分，要么就像上面那样的一个二元选择或者是直接的一个 JSX 对象，要么就是下面这样的调用一个返回 JSX 的方法： 123456789101112131415161718192021_render() &#123; return( ... &#123; this._renderContent(name, type) &#125; ... )&#125;_renderContent(name, type) &#123; if (type === 1) &#123; return( &lt;View/&gt; ) &#125; else &#123; return( &lt;Image/&gt; ) &#125;&#125; 不能直接写 js 的逻辑语句，一定会报错 padding 和 margin 使用区别这两者 android 程序员使用起来恐怕没有任何问题。iOS 程序员如果使用惯了 autoLayout 可能一时反应不过来。 style 究竟是在父控件里用 padding 还是在子控件里用 margin。其实基本没有太大差别，一般用 margin，能让子控件的布局更灵活一些。当然，如果父控件的样式需要复用多次，而子控件各不相同时，直接在父控件设置 padding，可以减少每次设置子控件 margin 的次数。 组件之间的通信子组件调用父组件方法父组件将方法以属性的方式传入子组件，子组件通过 this.props.方法名 拿到这个方法。 父组件调用子组件方法父组件调用子组件的条件是拿到子组件的实例。因此可以为子组件加上 ref 属性。比如： 1&lt;Child ref='child'&gt;haha&lt;/Child&gt; 这样父组件就可以通过 this.refs.child 来获取 Child 组件的实例，并调用其内部方法了。 比较典型的用法在于一个 View 里嵌了一个 ListView，现在要调用 ListView 的刷新方法。就可以通过 ref 的方式从外部拿到。 ref 属性上面演示的是 ref 接受一个字符串的使用方式，ref 属性还可以是一个回调函数，这个回调函数会在组件被挂载后立即执行。被引用的组件会被作为参数传递，回调函数可以用立即使用这个组件，或者保存引用以后使用： 123456render () &#123; return &lt;TextInput ref=&#123;(element) =&gt; this._input = element&#125; /&gt;;&#125;,componentDidMount () &#123; this._input.focus();&#125;, 上面的例子中，在 ref 回调方法中把节点 TextInput 保存为 _input 属性。可以在必要的时候调用。 我认为最好还是用回调函数，通过回调函数可以把要使用的组件提前声明出来，方便调用。 跨级组件通信跨级组件，如果还是一层层传递 props 非常的不优雅。React 提供了一个 context 属性。不过这并不推荐使用。一般我们使用 react-redux 库的时候，store 就是通过 context 传递的。 没有嵌套关系的组件通信没有嵌套关系可以使用 EventEmitter 实现。在一个地方注册，另一个地方监听。不过也是不推荐的。所以用法也就不细说了。 Statestate 中存放一些与视图有关的变量。与视图无关的变量，直接在构造器里作为自身属性创建。可以有两种方式便便 state： 1234// 方式一this.state.someProp = 1// 方式二this.setState(&#123; someProp : 1 &#125;) 其中，方式二能在改变 State 的同时刷新视图。 Props简介组件在创建的时候传入 Props 来完成定制，例如： 1&lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; 其中 source,style 都是传入 image 的 Props。其中 pic 表示一个js对象，类似后面的 {width: 193, height: 110}。 {pic} 外面有个括号，表示括号内是一个js变量或者表达式，需要执行后取值，以此在JSX中嵌入单条js语句。 子组件内获取 props有时候，我们想要封装一个组件，在容器组件内多定义几个 props，但是并不希望这些 props 传到子组件内，比如容器组件的 children 属性。我们可以这样做： 1234567891011121314151617181920212223242526render () &#123; const &#123; style, children, ...restProps, &#125; = this.props; // 删除多余属性 [ 'onOpenChange', 'onDrawerOpen', 'onDrawerClose', 'drawerPosition', 'renderNavigationView', ].forEach(prop =&gt; &#123; if (restProps.hasOwnProperty(prop)) &#123; delete restProps[prop]; &#125; &#125;); return ( &lt;View style=&#123;style&#125;&gt; &lt;SomeView &#123;...restProps&#125;/&gt; &#123;...children&#125; &lt;/View&gt; )&#125; 注意： 通过对象展开符，可以获取到 props 中剩余的属性。 将一个对象作为组件的属性传入的时候要通过 {...obj} 的方式 通过 hasOwnProperty 进一步删除不想传递给子组件的属性 this.props 的展开要放在 render 方法里，因为 props 可能会变化触发重绘，所以要每次重绘的时候都进行对象展开 Props 使用的注意点通常我们直接会把 props 放到 render 方法中，比如上面的例子。但是这样其实不太好，比如一个页面跳转的时候，会带一些 props 过来，我们需要修改 props 中的一些属性。但是我们并不希望把这些修改带回到其他页面。 这种时候我们就不能直接修改 props 中的属性了。我们需要在 render 的时候，深拷贝或者不浅不深的拷贝 props 的值： 1234567render () &#123; this.props1 = this.props.props1 this.props2 = this.props.props2 return ( &lt;View/&gt; )&#125; 因为多加了一层 this.props1 我们就不需要担心，到底能不能修改 props 了，如果不能修改 props，那么直接深拷贝一下即可。 更进一步，其实我们只有在不希望修改数据带到其他页面的时候才会使用 this 挂载，一般情况下，我们直接使用结构赋值即可： 123456render () &#123; const &#123;prop1, prop2&#125; = this.props return ( &lt;View/&gt; )&#125; 如果项目变化需求变化了，再转到把 props 的属性挂在到 this 下： 12345678render () &#123; this.props1 = this.props.props1 this.props2 = this.props.props2 const &#123;prop1, prop2&#125; = this return ( &lt;View/&gt; )&#125; 就不需要再更换 View 里的参数了 propTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 PropTypes 属性，就是用来验证组件实例的属性是否符合要求。我们需要引入一个 prop-types 库： 12345678910111213import PropTypes from 'prop-types';class Greeting extends React.Component &#123; render() &#123; return ( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.string&#125;; 上面例子中，如果 name 不是 string 类型，那么就会产生一个警告。还可以设置 name: PropTypes.string.isRequired 表示必须传入属性 name。 除了 string 外，还有许多类型的 PropTypes 可以设置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950MyComponent.propTypes = &#123; // 可以声明prop是特定的JS基本类型 // 默认情况下这些prop都是可选的 optionalArray:PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可以被渲染的事物：numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // 声明一个prop是某个类的实例，用到了JS的instanceof运算符 optionalMessage: PropTypes.instanceOf(Message), // 用enum来限制prop只接受特定的值 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 指定的多个对象类型中的一个 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 指定类型的属性构成的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个指定形式的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你可以用以上任何验证器链接‘isRequired’，来确保prop不为空 requiredFunc: PropTypes.func.isRequired, // 不可空的任意类型 requiredAny: PropTypes.any.isRequired, // PropTypes.element指定仅可以将单一子元素作为子节点传递给组件 children: PropTypes.element.isRequired defaultProps可以在 defaultProps 中注册设置默认属性值。 1234567891011class Greeting extends React.Component &#123; render() &#123; return ( &lt;Text&gt;&#123;this.props.name&#125;&lt;/Text&gt; ); &#125;&#125;Greeting.defaultProps = &#123; name: 'hahaha'&#125;; 结合上面这两个属性，就不必再在构造函数里设置各种值了。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。类似于 TouchableOpaque 里嵌入 Text，通过这种方式可以很方便的嵌套封装控件。 123456789101112class NewComponent extends React.Component&#123; render()&#123; return( &#123;this.props.children&#125; ); &#125;&#125;//调用：&lt;NewComponent&gt; &lt;Text&gt;haha&lt;/Text&gt;&lt;/NewComponent&gt; this.props.children 是一个数组，子节点作为数组元素传入。 TextInput 隐藏键盘Native 中的 UITextField 可以通过 resignFirstResponder 或者 endEditing 的方式取消第一响应者，从而隐藏虚拟键盘。那么，react 中如何做到隐藏键盘呢？ 可以使用 ScrollView 包装我们的 View。ScrollView 可以设置 keyboardDismissMode，keyboardShouldPersistTaps 来控制输入法的行为。 123456&lt;ScrollView contentContainerStyle=&#123;&#123;flex:1&#125;&#125;//非常重要，让ScrollView的子元素占满整个区域 keyboardDismissMode='on-drag' //拖动界面输入法退出 keyboardShouldPersistTaps=&#123;false&#125; //点击输入法意外的区域，输入法退出 &gt;....&lt;/ScrollView&gt; 生命周期回调函数总结componentWillMount()componentWillMount 会在组件 render 之前执行，并且永远都只执行一次。 componentDidMount()componentDidMount 会在组件加载完毕之后立即执行。 componentWillReceiveProps(object nextProps)在组件接收到一个新的 prop 时被执行。这个方法在初始化 render 时不会被调用。 这个方法很重要。组件内部属性的初始化设置只有一次，所以当组件初始化完成后，外部传入的属性值的变化不会直接引起组件内部属性值的变化，而是会回调这个方法。 如果你在组件内部用一个变量去接 props，那么除了在 constructor 里将 props 赋值给变量外，还需要在这个方法里将 props 赋值给变量。 boolean shouldComponentUpdate(object nextProps, object nextState)返回一个布尔值。在组件的 props 或者 state 改变时被执行。在初始化时或者使用 forceUpdate 时不被执行。 如果 shouldComponentUpdate 返回 false,render() 则会在下一个 state change 之前被完全跳过。(另外 componentWillUpdate 和 componentDidUpdate 也不会被执行)默认情况下 shouldComponentUpdate 会返回 true. componentWillUpdate(object nextProps, object nextState)组件接收到新的 props 或者 state 但还没有 render 时被执行。在初始化时不会被执行。一般用在组件发生更新之前。 componentDidUpdate(object prevProps, object prevState)在组件完成更新后立即执行。在初始化时不会被执行。一般会在组件完成更新后被使用。例如清除 notification 文字等操作。 componentWillUnmount()主要用来执行一些必要的清理任务。注意，Unmount 的大小写。写错就无法调用了！！！ 优化切换动画卡顿的问题使用API InteractionManager，它的作用就是可以使本来 JS 的一些操作在动画完成之后执行，这样就可确保动画的流程性。当然这是在延迟执行为代价上来获得帧数的提高。123456789InteractionManager.runAfterInteractions(()=&gt;&#123; //...耗时较长的同步任务... //更新state也需要时间 this.setState(&#123; ... &#125;) //获取某些数据，需要长时间等待 this.fetchData(arguements)&#125;) 一般这个方法都放在 componentDidMount 里。 React-Native 原生模块调用(iOS)在项目中遇到地图,拨打电话,清除缓存等iOS与Andiorid机制不同的功能,就需要调用原生的界面或模块。 创建原生模块，实现“RCTBridgeModule”协议123456#import &lt;UIKit/UIKit.h&gt;#import &quot;RCTBridgeModule.h&quot;@interface LoginViewController : UIViewController&lt;RCTBridgeModule&gt;@end 导出模块，导出方法不仅可以让导出 native 的方法，而且还可以在 js 中添加回调函数，供 native 调用，这样 native 就可以将前面的数据回塞给 js 了。12345678910111213141516@implementation LoginViewController//导出模块RCT_EXPORT_MODULE()- (void)viewDidLoad &#123; [super viewDidLoad];&#125;RCT_EXPORT_METHOD(showSVProgressHUDErrorWithStatus:(NSString *)state callBack:(RCTResponseSenderBlock)callback)&#123; NSLog(@&quot;state is %@&quot;,state); NSArray *events = [[NSArray alloc] initWithObjects:@&quot;hello&quot;, nil]; // 这里callback必须是数组 callback(events); [SVProgressHUD showErrorWithStatus:state];&#125;@end js文件中调用12345//创建原生模块实例let LoginViewController = NativeModules.LoginViewController;//方法调用LoginViewController.showSVProgressHUDErrorWithStatus('请输入正确的手机号',(callbackString) =&gt; &#123;console.log(callbackString);&#125;); React Native 调试首先，必须 保证调试用电脑的和你的设备处于相同的 WiFi 网络环境中下。然后修改AppDelegate.m 文件，设置 ip 为电脑 ip 即可。 然后就可以通过 Chrome 开发工具进行调试。最好不要使用 VSCode 提供的测试工具。不好用。 如果想要快速调样式，建议选上 Enable Hot Reloading 。可以在你每次保存的时候在本页面重新加载。 使用 xcode run 一遍之后，如果没有 native 代码的改动，手机就可以不用再连着电脑了，在项目地址下，使用 npm start 开启本地服务。 React Native 读取本地的json文件可以以导入的形式，来读取本地的json文件，导入的文件可以作为一个js对象使用，这样方便调试的时候加载数据。 导入json文件：1var langsData = require('./json/langs.json'); 现在你可以操作langsData对象了。 json格式1234567891011121314151617[ &#123; "path":"", "name":"123", "checked":false &#125;, &#123; "path":"aa", "name":"1234", "checked":false &#125;, &#123; "path":"ddd", "name":"123123123", "checked":true &#125;] 使用123for (var i=0,l=langsData.length;i&lt;l;i++)&#123; console.log(langsData[i]);&#125;]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>爬坑</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO 实践及 FBKVOController 原理]]></title>
    <url>%2F2016%2F11%2F17%2FKVO%2F</url>
    <content type="text"><![CDATA[本篇简单学习下如何使用 KVO KVO是什么？KVO 是 Object-C 中定义的一个通知机制，其定义了一种对象间监控对方状态的改变，并做出反应的机制。对象可以为自己的属性注册观察者，当这个属性的值发生了改变，系统会对这些注册的观察者做出通知。其用途十分广泛，比方说，你的下载进度条是根据下载百分比决定的，那么，可以通过观察下载百分比的改变，刷新进度条的样式，来直观的反应下载进度等等。 KVO的用法为对象的属性注册观察者1234- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context observer: 观察者对象. 其必须实现方法 observeValueForKeyPath:ofObject:change:context:. keyPath: 被观察的属性，其不能为 nil. options: 设定通知观察者时传递的属性值，是传改变前的呢，还是改变后的，通常设置为 NSKeyValueObservingOptionNew。 context: 一些其他的需要传递给观察者的上下文信息，通常设置为 nil。 观察者接收通知1234- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context keyPath: 被观察的属性，其不能为 nil. object: 被观察者的对象. change: 属性值，根据上面提到的 Options 设置，给出对应的属性值。 context: 上面传递的 context 对象。 清除观察者1- (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath 注意事项使用KVO消息传递机制有两个要求： 观察者必须知道被观察对象，即在同一作用域。 观察者还需要知道被观察对象的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。 KVO 原理实现原理当一个对象使用 KVO 监听，iOS 会修改对象的 isa 指针，改为指向一个由 runtime 创建的类，这个类的 superclass 为原来的 class 对象。动态创建的类拥有自己的 set 方法实现，内部会依次调用： 1231. - (void)willChangeValueForKey:(NSString *)key;2. 原来的 setter 方法3. - (void)didChangeValueForKey:(NSString *)key; 在 didChangeValueForKey 中会调用监听器的监听方法。所以直接修改成员变量不会触发 KVO。 那么 didChangeValueForKey 是如何找到观察者的呢？添加观察者的时候，会以被观察的属性名作为键，观察者的列表作为值将观察的信息保存在一个 hashMap 中，通过关联对象的方式挂载在被观察对象上。当 didChangeValueForKey 调用的时候，就会在这个 hashMap 中找到对应的观察者列表，依次调用观察者的 observeValueForKeyPath:ofObject:change:context: 方法。 那么多级 keypath 又是如何观察到的呢？添加观察者的时候，将递归创建子对象监听，子对象在将监听到的变化转发到上层。最上层则通知外部的观察者。 如何手动触发 KVO有时候为了在不改变属性值的情况下，触发监听方法，所以要手动触发 KVO。手动调用： 12- (void)willChangeValueForKey:(NSString *)key;- (void)didChangeValueForKey:(NSString *)key; KVC 触发 KVOKVC 会触发 KVO。即使成员变量没有 get set 方法，KVC 手动调用 willChangeValueForKey: 和 didChangeValueForKey:。 因为新的类内部重写了 setValue:forKey: 方法。 KVOControllerKVO 存在的问题KVO 本身写起来并不友好，存在一些问题： 需要手动移除观察者 处理观察事件需要和注册观察事件割裂开 那么如何解决呢？ 没有什么是一个中间变量不能解决的。可以创建一个实例，观察的事件由它分发，在其 dealloc 方法中移除观察者。这样就不用在外部业务方法中移除了。KVOController 也是这么做的。 使用方式使用方式很简单，首先创建一个 KVOController 实例，然后执行 observe:keyPath:options:block: 方法注册观察者： 12345678// 在 ClockView 类中FBKVOController *KVOController = [FBKVOController controllerWithObserver:self];self.KVOController = KVOController;// clock 是 ClockView 实例的一个属性，data 是 clock 实例的一个属性[self.KVOController observe:clock keyPath:@"date" options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(ClockView *clockView, Clock *clock, NSDictionary *change) &#123; clockView.date = change[NSKeyValueChangeNewKey];&#125;]; 其中， block 的第一个参数 ClockView 为 observer，第二个参数 Clock 为 target，第三个参数为变化的 keypath 的变化前后值的字典。 整体结构 整体结构如上图所示，KVOController 对象有一个观察者 observer 还有一个 NSMapTable 的 _objectInfosMap，它的键是被观察的对象 object，值是被观察对象的各个属性的封装的 NSMutableSet，Set 中的每一个元素都保存了要执行的 block 源码解析创建 KVOController 实例各个初始化方法都会来到这个方法： 12345678910111213- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved&#123; self = [super init]; if (nil != self) &#123; _observer = observer; // 创建 NSMapTable 需要提供一个选项来决定 key 以及 value 是强引用还是弱引用 NSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality; _objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0]; pthread_mutex_init(&amp;_lock, NULL); &#125; return self;&#125; 这里面的 observer 在外部会强引用这个 KVOController，所以初始化方法中的 _observer 默认是弱引用的，不用担心循环引用的问题。 由于参数 retainObserverd 默认是 YES，所以创建的 NSMapTable 的 key 的选项默认是： 1NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality 选项的具体含义在下面介绍 NSMapTable 的时候会提及。总之，这里创建的 NSMapTable 默认键和值都是强引用的，所以如果被观察的对象是观察者 observer 本身，就要注意要传入弱引用，否则会产生循环引用。 最后创建了一个 pthread_mutex_t 注册观察方法注册观察方法外部调用的方法： 1234567- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context &#123; // create info _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options context:context]; // observe object with info [self _observe:object info:info];&#125; 外部调用的时候会创建一个 FBKVOInfo 对象，这个对象保存了观察回调所需的各种要素，随后执行内部的注册方法： 1234567891011121314151617181920212223242526272829- (void)_observe:(id)object info:(_FBKVOInfo *)info &#123; // lock pthread_mutex_lock(&amp;_lock); /// 拿到 KVOController 中所有的 object 的 KVOInfo 的集合 NSMutableSet *infos = [_objectInfosMap objectForKey:object]; /// 如果存在这个 info 那么就直接返回。 Info 主要是监听的 keyPath 和要执行的 block 信息，Infos 就是所有要监听的 keyPath 的集合 _FBKVOInfo *existingInfo = [infos member:info]; if (nil != existingInfo) &#123; // unlock and return pthread_mutex_unlock(&amp;_lock); return; &#125; /// 如果没有这个 infos，那么就自己创建一个 if (nil == infos) &#123; infos = [NSMutableSet set]; [_objectInfosMap setObject:infos forKey:object]; &#125; // add info and oberve [infos addObject:info]; // unlock prior to callout pthread_mutex_unlock(&amp;_lock); [[_FBKVOSharedController sharedController] observe:object info:info];&#125; 可以看到，这里把要观察的对象 object 和刚刚创建的保存回调要素的 KVOInfo 对象保存在了 _onjectInfosMap 这个 NSMapTable 中。 所以，一个被观察的对象 object 的所有注册观察的 keyPath 都会保存在一个 NSMutableSet 中，再把 object 和 NSMutableSet 作为键值对，保存在 NSMapTable 中。 最后调用的 _FBKVOSharedController 才是真正注册观察者的地方。 真正用来注册观察者的 KVOSharedControllerKVOSharedController 中还用到了 NSHashTable，但是和 KVOController 中 NSMapTable 不同的是，这里都是通过弱引用保存的。原因是因为外部的 KVOController 都保存确保不会被回收了，这里就不需要再强引用了。 1234567891011121314151617181920212223242526@implementation _FBKVOSharedController&#123; NSHashTable&lt;_FBKVOInfo *&gt; *_infos; pthread_mutex_t _mutex;&#125;+ (instancetype)sharedController&#123; static _FBKVOSharedController *_controller = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _controller = [[_FBKVOSharedController alloc] init]; &#125;); return _controller;&#125;- (instancetype)init&#123; self = [super init]; if (nil != self) &#123; NSHashTable *infos = [NSHashTable alloc]; _infos = [infos initWithOptions:NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality capacity:0]; pthread_mutex_init(&amp;_mutex, NULL); &#125; return self;&#125; KVOSharedController 是个单例，所有的注册和回调逻辑都是通过这个实例完成的. 注册方法： 1234567891011121314- (void)observe:(id)object info:(nullable _FBKVOInfo *)info&#123; if (nil == info) &#123; return; &#125; // register info pthread_mutex_lock(&amp;_mutex); [_infos addObject:info]; pthread_mutex_unlock(&amp;_mutex); // add observer [object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];&#125; 还是能比较容易想到这个方法做了什么的。注意这里把 KVOInfo 实例作为 context 传了进去。 回调方法： 1234567891011121314151617181920212223242526272829303132333435363738- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context&#123; _FBKVOInfo *info; &#123; pthread_mutex_lock(&amp;_mutex); /// 之前 info = [_infos member:(__bridge id)context]; pthread_mutex_unlock(&amp;_mutex); &#125; if (nil != info) &#123; // take strong reference to controller FBKVOController *controller = info-&gt;_controller; if (nil != controller) &#123; // take strong reference to observer id observer = controller.observer; if (nil != observer) &#123; if (info-&gt;_block) &#123; NSDictionary&lt;NSKeyValueChangeKey, id&gt; *changeWithKeyPath = change; // add the keyPath to the change dictionary for clarity when mulitple keyPaths are being observed if (keyPath) &#123; /// 把 Keypath 也加入到了字典中去。 NSMutableDictionary&lt;NSString *, id&gt; *mChange = [NSMutableDictionary dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey]; [mChange addEntriesFromDictionary:change]; changeWithKeyPath = [mChange copy]; &#125; info-&gt;_block(observer, object, changeWithKeyPath); &#125; &#125; &#125; &#125;&#125; 也是顺利成章的，接收到回调事件后，执行 block 里面的内容。刚才通过 context 把 KVOInfo 传入，现在再通过 context，把 KVOInfo 取出来。(说实话，这里的操作，包括下面的各种判空，其实有点多余。因为本身外部是强引用的，不会出现为空的情况) 取消注册取消注册在 KVOController 中存在三种情况： 取消所有的监听 取消关于某一个 object 的所有的监听 取消某一个 object 内的某个 keypath 的监听 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 对应第三种情况- (void)_unobserve:(id)object info:(_FBKVOInfo *)info&#123; // lock pthread_mutex_lock(&amp;_lock); // get observation infos NSMutableSet *infos = [_objectInfosMap objectForKey:object]; // lookup registered info instance _FBKVOInfo *registeredInfo = [infos member:info]; if (nil != registeredInfo) &#123; [infos removeObject:registeredInfo]; // remove no longer used infos if (0 == infos.count) &#123; [_objectInfosMap removeObjectForKey:object]; &#125; &#125; // unlock pthread_mutex_unlock(&amp;_lock); // unobserve [[_FBKVOSharedController sharedController] unobserve:object info:registeredInfo];&#125;// 对应第二种情况- (void)_unobserve:(id)object&#123; // lock pthread_mutex_lock(&amp;_lock); NSMutableSet *infos = [_objectInfosMap objectForKey:object]; // remove infos [_objectInfosMap removeObjectForKey:object]; // unlock pthread_mutex_unlock(&amp;_lock); // unobserve [[_FBKVOSharedController sharedController] unobserve:object infos:infos];&#125;// 对应第一种情况- (void)_unobserveAll&#123; // lock pthread_mutex_lock(&amp;_lock); NSMapTable *objectInfoMaps = [_objectInfosMap copy]; // clear table and map [_objectInfosMap removeAllObjects]; // unlock pthread_mutex_unlock(&amp;_lock); _FBKVOSharedController *shareController = [_FBKVOSharedController sharedController]; for (id object in objectInfoMaps) &#123; // unobserve each registered object and infos NSSet *infos = [objectInfoMaps objectForKey:object]; [shareController unobserve:object infos:infos]; &#125;&#125; 这三种情况中，第一种删除所有 Object 是第二种删除某一个 Object 的特殊情况，第二种又是第一种删除某一个 Object 的某个 keyPath 的特殊情况。总的来说，都是操作 _objectInfosMap，将强引用的对象删除，然后交给 KVOSharedController 操作。 这三种情况最后都归结到 KVOSharedController 中去： 12345678910- (void)unobserve:(id)object info:(nullable _FBKVOInfo *)info &#123; if (nil == info) &#123; return; &#125; // unregister info pthread_mutex_lock(&amp;_mutex); [_infos removeObject:info]; pthread_mutex_unlock(&amp;_mutex); [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info];&#125; dealloc 时候的自动取消注册由于观察者把整个过程交给了 KVOController，所以在观察者销毁的时候，KVOController 也会一起执行 dealloc 方法，来清除所有的监听。 12345- (void)dealloc&#123; [self unobserveAll]; pthread_mutex_destroy(&amp;_lock);&#125; 总结整个库的流程是：KVOController 把观察的对象作为其 NSMapTable 属性 _objectInfomap 的键，把整个回调环境组成的对象 KVOInfo 作为值保存起来。同时通过一个单例的 KVOSharedController 执行具体的注册于监听方法。 在我看来，本身 KVOSharedController 这个单例其实是没有多大意义的，在每个 KVOController 中其实就可以处理这些监听与回调了。不过这么写可能是为了更好的职责分离吧。 最后还要强调一点，我认为 KVO 自动取消监听的核心在于让 KVOController 这类的中间类的生命周期和被监听的 object 同步，而不是和 Observer 同步。因为，只有在被监听对象回收的时候取消监听才能真正避免 crash 的危险。 事实上，我们一般在 VC 和 VM 中做监听，监听的对象是 VC 或者 VM 的属性，这种变相的把观察者 Observer 和被观察对象 object 的生命周期同步了，因而把 KVOController 作为监听者的属性也不会有问题。但是这会造成使用者的误解。 所以我认为 KVOController 这种一个 KVOController 监听多个对象的做法其实是有问题的，也是不应该被鼓励的。真正应该的是像我图上画的，给每个被观察的对象绑定一个 KVOController 实例。 NSMapTableNSMapTable 相比较 NSDictionary 的优势有： NSDictionary 必须是 key-obj 的形式，key 必须是满足 NSCopying 协议的；NSMapTable 则是 obj-obj 的形式 NSDictionary 的 obj 是强引用；NSMapTable 的 key 和 value 都可以自己决定是强引用还是弱引用。如果弱引用回收后，会自动删除。 创建创建 NSMapTable 的时候，需要指定键和值的选项： 1NSMapTable *keyToObjectMapping = [NSMapTable mapTableWithKeyOptions:NSMapTableCopyIn valueOptions:NSMapTableStrongMemory]; 上面创建的 NSMapTable 将和 NSDictionary 一模一样，复制 key，并对它的 object 引用计数 +1。 NSMapTable 的选项 NSMapTableStrongMemory (a “memory option”) NSMapTableWeakMemory (a “memory option”) NSMapTableObjectPointerPersonality (a “personality option”) NSMapTableCopyIn (a “copy option”) 其中前两个 memory option 就是控制是对 obj 进行强引用还是弱引用。 personality option 在我的理解中是针对 key 的，它决定是否使用对象的指针来进行 hash （NSDictionary 中使用 NSString 来进行 hash，决定 object 的存储位置）。如果不指定这个选项，默认是使用整个对象进行 hash，那么在存储的过程中，作为 key 的这个对象是不能被改变的（对象变了，hash 值变了，自然就找不到 object 了）。 copy option 选项表明是否执行对象的 copy 方法，深拷贝一个新的对象进行存储。 NSArray 和 NSPointerArray 的区别NSPointerArray 可以保存 NULL，因此，NSPointerArray 中的对象可以是 weak 的，销毁直接将该位置职位 null NSHashTable 和 NSSet 区别NSHashTable 是可变的，且 NSHashTable 可以放弱引用对象 参考如何优雅的使用KVO]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Objective-C 学习笔记]]></title>
    <url>%2F2016%2F11%2F11%2FEffective_oc2%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[拜读一下 Effective Objective-C 这本书，做一些笔记 熟悉OC第1条：了解Objective-C的起源对于消息结构的语言，运行时所执行的代码由运行环境来决定,在运行时才回去查找索要执行的方法;而使用函数调用的语言，则由编译器决定，只有函数是多态的，才会在运行的时候按照“虚方法表”查出到底应该执行哪个函数。 oc 的工作的实现原理是由运行期组件（runtime component）完成，而不是编译器。使用 Objective-C 的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。 运行期组件本质上是一种与开发者所编写的代码相链接的动态库（dynamic library），其代码能把开发者所编写的所有程序粘合起来。这样的话，只要更新运行期组件，就可以提升程序性能。而那种工作都在 “编译期” 完成的语言，若想获得类似的性能提升，就要重新编译应用程序代码。 第2条： 在类的头文件中尽量少引用其他头文件有时，类A需要将类B的实例变量作为它公共 API 的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring） 使用 @class 关键字，并且在 A 的实现文件引用 B 的头文件。(继承或者协议必须引入完整头文件，不能使用向前声明) 123456789101112131415// EOCPerson.h#import &lt;Foundation/Foundation.h&gt;@class EOCEmployer;@interface EOCPerson : NSObject@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性@end// EOCPerson.m#import "EOCEmployer.h" 这样做有什么优点呢： 不在A的头文件中引入B的头文件，那么A的实现文件引入A的头文件时，就不会一并引入B的全部内容，这样就减少了编译时间。只有在A的实现里需要用到B时，再在A的实现里引用B的头文件。 使用 #import 而不是 #include 可以避免死循环，但仍会导致相互引用的两个类中的一哥无法正确编译。使用 @class 可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。 第3条：多用字面量语法，少用与之等价的方法声明时多用字面量： 1234567NSNumber *intNumber = @1;NSNumber *floatNumber = @2.5f;NSArray *animals =@[@"cat", @"dog",@"mouse", @"badger"];Dictionary *dict = @&#123;@"animal":@"tiger",@"phone":@"iPhone 6"&#125;;NSString *cat = animals[0];NSString *iphone = dict[@"phone"]; 少用 alloc、init 的方式创建，以及 objectAtIndex、objectForKey 的方式取数组字典。 优点： 简洁 NSArray 以 nil 结尾，所以一般不允许数组中的元素为 nil，如果使用等价方法，那么数组元素为 nil 不报错，会出现难以排查的错误；而同样的情况，字面量语法会抛出异常。 第4条：多用类型常量，少用#define预处理命令预处理与类型常量的优缺点： 预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。 类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。 预处理命令1#define W_LABEL (W_SCREEN - 2*GAP) 这里，(W_SCREEN - 2*GAP) 替换了 W_LABEL，它不具备 W_LABEL 的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。 类型常量1static const NSTimeIntervalDuration = 0.3; const 将其设置为常量，不可更改。static 意味着该变量仅仅在定义此变量的编译单元(.m 实现文件)中可见。如果不声明 static,编译器会为它创建一个外部符号（external symbol）。会出现什么问题呢？如果在其他类中也声明了同名变量，即使没有相互引用，编译器也会抛出一个异常。 全局常量如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量，即全局常量。在头文件中声明外部常量，在实现文件中完成变量的赋值。 12345//header fileextern NSString *const NotificationString;//implementation fileNSString *const NotificationString = @"Finish Download"; 注意这里的 const, 如果在 * 前面，表示指针指向的堆上的内容不能改变，如果在 * 后面，表示指针指向的地址是不能改变的。（这里有个助记方法，以 * 为分解，const 在左边就是修饰 * NotificationString，表示不能修改值，在右边就表示修饰 NotificationString 指针对象，表示不能修改指针指向的地址。） 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只会在百年以前执行查找和替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这回导致应用程序中的常量值不一致。 第5条：用枚举表示状态，选项，状态码我们经常需要给类定义几个状态，这些状态码可以用枚举来管理： 123456789101112typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;typedef NS_OPTION(NSUInteger, EOCPermittedDirection) &#123; EOCPermittedDirectionUp = 1 &lt;&lt; 0, EOCPermittedDirectionDown = 1 &lt;&lt; 1, EOCPermittedDirectionLeft = 1 &lt;&lt; 2, EOCPermittedDirectionRight = 1 &lt;&lt; 3&#125; NS_ENUM 和 NS_OPTION 是 Foundation 框架中定义的辅助宏。需要注意这两者使用场景的不同。 这两者的差别在于一个位移枚举即是在你需要的地方可以同时存在多个枚举值。而NS_ENUM定义的枚举不能几个枚举项同时存在，只能选择其中一项。 在枚举类型的 switch 语句中不要实现 default 分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch 语句并未处理所有的枚举。否则添加了枚举却没有实现 switch 将可能导致严重的崩溃。 注意，switch 的 case中如果声明了变量，必须要用{}包住，这是编译器强制的，不然会报错，例子： 1234567891011121314- (void)startAnimationInitialWithType:(NSInteger)type&#123; switch (type) &#123; case BaseAnimation:&#123; CALayer *myLayer=[CALayer layer]; //添加layer [self.view.layer addSublayer:myLayer]; self.myLayer=myLayer; &#125; break; default: break; &#125;&#125; 对象、消息、运行期第6条：理解“属性”这一概念属性在 Java 以及 C++ 中，对象布局在编译期就已经固定了。只要访问变量的代码，编译器就会把其替换成为“偏移量”。这个偏移量是硬编码（hardcode），表示该对象距离存放对象的内存区域的起始地址有多远。这样做的问题是，如果再添加一个实例变量，那么其他实例变量的就要变化了，那么就要重新编译，否则就会出错。 Objective-C 的做法是，把实例变量当做一种存储偏移量所用的“特殊变量”（special variable），交由“类对象”（class object）保管。偏移量会在运行期查找，那么类的定义变了，存储的偏移量也就变了，这样的话，无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行期向类中新增实例变量，这就是稳固的 “应用程序二进制接口(ABI)”。ABI 定义了许多内容，其中一项就是生成代码时所应遵循的规范(这也就是 swift 所没有的东西)。 存取方法在设置完属性后，编译器会自动向类中添加适当类型的实例变量，并且为其写出一套存取方法。一般会在属性名前加一个下划线作为实例变量名。 如果不想令编辑器自动合成存取方法，可以自己实现，也可以使用 @dynamic 关键字。它会告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法，需要自己实现存取方法。而且，在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。 访问属性，可以使用点语法，编译器会把点语法转换为对存取方法的调用；也可直接使用实例变量，使用实例变量的方式更快。 1234//存取方法设置属性self.firstName = @"Zachary";//实例变量设置属性_firstName = @"Zachary"; @synthesize 与 @dynamic@dynamic 是相对于 @synthesize 的，它们同样用于修饰 @property。 @property 用于声明属性的 get/set 方法。而 @synthesize 则可以用来创建实例变量，并且实现属性的 get/set 方法。使用如下： 1234567891011//.h@interface CYLPerson : NSObject @property NSString *firstName; @property NSString *lastName; @end //.m@implementation CYLPerson @synthesize firstName = _myFirstName; @synthesize lastName = _myLastName; @end @property 将会自动合成 setFirstName: 和 firstName,setLastName,lastName 这几个方法的声明。@synthesize 为 @property 生成两个实例变量，名为 _myFirstName 与 _myLastName ，并且在你没有实现 get/set 方法的时候，默认实现了这两个变量的 get/set 方法： 1234567- (NSString *)getFirstName() &#123; return _firstName;&#125;- (void)firstName:(NSString *)firstName &#123; _firstName = firstName;&#125;// lastName 类似 如果是 @synthesize foo;，等效于 @synthesize foo = foo，相当于生成名为 foo 的实例变量，生成的 get/set 方法里使用到的实例变量也相应改变。 上述语法是 Xcode 6 前的使用方式。在那之后，Xcode 会默认添加 @synthesize foo = _foo; 的语句。也就是说默认情况是会帮你生成 get/set 方法以及实例变量的。但是有一种情况@synthesize 不会自动添加，那就是如果自己同时实现了 get/set 方法的时候。因为自己实现了存取方法就违背了 @synthesize 自动合成的初衷。所以这个时候，你需要自己添加实例变量，或者手动添加 @synthesize foo = _foo; @dynamic 的使用方式形如 @dynamic foo;，它和 @synthesize 正好相反，它告诉编译器，不自动生成getter/setter方法，然后由自己实现存取方法或在运行时动态绑定。也就是说 @dynamic 存在就不会自动插入 @synthesize，也就不会自动生成实例变量 _foo。 属相特质原子性： nonatomic：不使用同步锁 atomic：加同步锁，确保其原子性 读写: readwrite:同时存在存取方法 readonly:只有获取方法 内存管理: assign:纯量类型(scalar type)的简单赋值操作 strong:拥有关系保留新值，释放旧值，再设置新值 weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空 copy：当赋给其可变对象，返回不可变对象；当赋给其不可变对象，返回原对象。 块要用 copy 最好不要用 strong。 可能出现的 retain 关键字一般情况下等同于 strong weak的实现这里插一条 weak 是如何实现的。一般内存是通过 ARC 管理的。使用 weak 不增加对象的引用次数。当栈中的变量不指向堆中的对象时，堆中对象销毁。这个时候要把 weak 指向的地址置为 nil，因为如果不这么做，那么就会产生野指针。那么这是如何做到的？ 内存中存在一种数据结构胶 SideTable，它总共有64个。它内部包含对象的引用计数表，和 weak 表。引用计数表键是对象的地址，值是引用计数数量。当引用计数为0的时候就把对象释放。 weak 表键是对象的地址，值是弱引用对象的指针数组。如果对象释放了，就要遍历指针数组把所有的指针置为 nil。 第7条： 在对象内部尽量直接访问实例变量关于实例变量的访问，可以直接访问 _firstName，也可以通过属性的方式(点语法) self.firstName 来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。（这部分比较重要） 直接访问实例变量的特点： 不经过“方法派发”(method dispatch)，会直接访问保存对象实例变量的那块内存，速度快。 通过属性访问实例变量的特点： 不会绕过属性定义的内存管理语义。其实也就是说，编译期在设置 set 方法的时候，会根据属性特质做一些操作。比如一个声明为 copy 的属性，如果直接访问实例变量，那么这个实例变量就会直接指向堆中的对象；而如果通过属性来操作，就会先将堆中的对象 copy 一份，然后将实例变量指向 copy 出来的对象。 可以触发KVO( KVO 是通过 aop 在设置方法中加的通知 ) 不过有两个特例： init 方法和 dealloc 方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作(比如上面说的内存管理语义所要进行的操作)。 如果使用懒加载的获取方法要用属性的方式获取。 其实，到底用什么很简单，如果 get，set 方法里没有其他的乱七八糟的东西，比如: 1234567- (NSString *)firstName&#123; return _firstName;&#125;- (void) setFirstName:(NSString *)firstName&#123; _firstName = firstName;&#125; 上面这种，那就直接用实例变量操作了，用属性就是多此一举；如果有乱七八糟的东西，那么就要用属性的方式。 第8条：理解“对象等同性”这一概念NSObject 类中有两个用于判断等同性的方法： - (BOOL)isEqual:(id)object; - (NSUInteger)hash; NSObject 类中默认的实现是：当且仅当其内存地址完全相等时，两个对象才相等。自定义对象中可以覆写这两个方法（其实好像没必要重写 hash 方法，因为我们重写的 isEqual: 方法里根本没有用到 hash 方法，重写了也没啥用），完成自己的相等判断。如果 isEqual: 方法判断对象相等，那么其 hash 方法也必须返回同一个值；反之，如果 hash 方法返回了同一个值，isEqual: 方法未必认为两者相等。 如果已知两个对象是字符串，最好通过 isEqualToString: 方法来比较。对于数组和字典，也有 isEqualToArray: 方法和 isEqualToDictionary:方法。 如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的 isEqual: 方法：12345678910111213141516171819202122- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson &#123; //先比较对象类型，然后比较每个属性 if (self == object) return YES; if (![_firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES;&#125;- (BOOL)isEqual:(id)object &#123; //如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法 if ([self class] == [object class]) &#123; return [self isEqualToPerson:(EOCPerson*)object]; &#125; else &#123; return [super isEqual:object]; &#125;&#125; 第9条 以“类族模式“隐藏实现细节其实就是通过抽象类完成工厂模式。 例如,对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得： 123456789101112131415161718192021//EOCEmployee.htypedef NS_ENUM(NSUInteger, EOCEmployeeType) &#123; EOCEmployeeTypeDeveloper, EOCEmployeeTypeDesigner, EOCEmployeeTypeFinance,&#125;;@interface EOCEmployee : NSObject@property (copy) NSString *name;@property NSUInteger salary;// Helper for creating Employee objects+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;// Make Employees do their respective day's work- (void)doADaysWork;@end 12345678910111213141516171819202122232425//EOCEmployee.m@implementation EOCEmployee+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123; switch (type) &#123; case EOCEmployeeTypeDeveloper: return [EOCEmployeeDeveloper new]; break; case EOCEmployeeTypeDesigner: return [EOCEmployeeDesigner new]; break; case EOCEmployeeTypeFinance: return [EOCEmployeeFinance new]; break; &#125;&#125;- (void)doADaysWork &#123; // 需要子类来实现&#125;@end 12345678910@interface EOCEmployeeDeveloper : EOCEmployee@end@implementation EOCEmployeeDeveloper- (void)doADaysWork &#123; [self writeCode];&#125;@end 这样，表面上对象是 EOCEmployee，但是实际上操作的是 EOCEmployeeDeveloper。 这里需要注意一点：对于这种类族，不能通过以下方式判断： 123if ([employeeDeveloper class] == [EOCEmployee class])&#123; // will do&#125; 因为 employeeDeveloper 对象是 EOCEmployee 类的一个子集，需要使用 isKindOfClass: 方法： 123if ([employeeDeveloper isKindOfClass:[EOCEmployee class]])&#123; // will do&#125; 第10条：在既有类中使用关联对象存放自定义数据这一条和 runtime 息息相关。背景是，我们可以通过 category 为系统类添加方法，但是无法添加属性。当需要为系统类添加属性时，可以使用下面的方法： 12345678//为某个对象设置关联对象的值，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)//根据给定的键从某对象中获取相应的关联对象值id objc_getAssociatedObject(id object, void *key)//移除指定对象的关联对象void objc_removeAssociatedObjects(id object) 对象关联类型 objec_AssociationPolicy 包括： 12345OBJC_ASSOCIATION_ASSIGN //assignOBJC_ASSOCIATION_RETAIN_NONATOMIC //nonatomic,retainOBJC_ASSOCIATION_COPY_NONATOMIC //nonatomic,copyOBJC_ASSOCIATION_RETAIN //retain OBJC_ASSOCIATION_COPY //copy 这里强调一个地方，第二个参数类型为 void * 这是一个可以指向任意类型的指针，类似于 oc 中的 id。但是这两者并不相等，需要进行转换。我们看代码的时候经常会看到以下几种: 1234567891011121314151617181920212223// 方式1static const void * const s = @"type1";objc_setAssociatedObject(self, s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC);// 方式2static const NSString * const s = @"type2";objc_setAssociatedObject(self, (__bridge void *)s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC);// 方式3static const NSString * const s = @"type3";objc_setAssociatedObject(self, &amp;s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC);// 方式4static const void * const s;objc_setAssociatedObject(self, &amp;s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC);// 方式5static const void * const s;objc_setAssociatedObject(self, s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC);// 方式6static const void * const s = &amp;s;objc_setAssociatedObject(self, s, @"value", OBJC_ASSOCIATION_COPY_NONATOMIC); 由于需要的是 void * 类型，所以方式1是最正常的了。 方式2使用了字符串类型，所以需要将字符串转换为 void *，就要使用 __bridge void *。 除了使用 bridge，还可以使用 &amp; 取得指针的地址，这就是方式3的处理方式。注意 &amp;s 和 s 还是有很大的区别的，前者表示指针在栈中的地址，后者表示指针指向的值在堆中地址。所以其实方式3是以 s 的地址为索引的，而不是以赋的值为索引的。所以和 @&quot;type3&quot; 没有太大关系了，也就不用考虑 __bridge 转换了。 根据前一条可知，去掉 @type3 也是没有问题的。也就是说，方式4也是对的。 一定注意，方式5是错误的，我们不能这么写。因为我们没有对 s 赋值，所以 s 指向的是空地址，如果我们要在定义一个关联属性，又创建了一个 static const void * const j;，这个 j 也指向空地址，就会覆盖 s 关联的属性了。因为 s 和 j 不具有唯一性。 方式4每次使用的使用都要输入 &amp;s，方式6是其改进的方法。 void *s = &amp;s 表示的意思是指针 s 指向自己，这样 s 就和其它指针区分开了，就不需要具体考虑赋个什么值，也不需要在每次使用的时候用 &amp; 获取自己的地址了。 所以相比较来说，方式4，6会简单些，方式6 尤为简便。 关于 *s, &amp;s, s 之间的关系： s 表示的是当前指向的地址上的值 *s 可以拆分为两部分，s 取当前指向的地址上的值，* 取后面跟着的地址上的值。所以 *s 就是以当前指向的地址上的值为地址，再取值 &amp;s 取当前指针的地址值 关于二级指针的指向问题演示如下： 第11条：理解objc_msgSend的作用这部分包括下面几个在runtime中已经写得很详细了。 第12条：理解消息转发机制第13条：用“方法调配技术”调试“黑盒方法”第14条：理解“类对象”的用意接口与API设计第15条：用前缀 避免命名空间冲突Apple 宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。 自己开发的程序库用到了第三方库，则应为其中的名称加上前缀。(用 cocoapods 可以自动加上前缀，自己开发的库的话要手动改名。) 第16条：提供”全能初始化方法”所谓全能初始化方法，就是所有初始化方法都要调用的初始化方法。这个初始化方法初始化方法是初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。 算是一种写代码的技巧吧。平时写代码的时候也都是这样的，不具体说明了。 第17条：实现description方法自定义的类调用 NSLog(); 的时候，往往不能返回想要的结果。需要重写 NSObject 类中的 description 方法，返回需要的字符串。123- (NSString*)description &#123; return [NSString stringWithFormat:@"&lt;%@: %p, %@ %@&gt;", [self class], self, firstName, lastName];&#125; 其中，%p 表示对象的内存地址。 第18条：尽量使用不可变对象尽量使用不可变对象。没啥可说的。里面推荐的方法没用过，感觉并不好，就不写了。 第19条：使用清晰而协调的命名方式没啥好说的，注意就好 第20条：为私有方法名加前缀建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface EOCObject : NSObject- (void)publicMethod;@end@implementation EOCObject- (void)publicMethod &#123; /* ... */&#125;- (void)p_privateMethod &#123; /* ... */&#125;@end 很有用的建议，就像上面一样在私有方法前面加上 p_ 挺好的。注意不要单用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。 第21条：理解Objective-C错误类型OC 中仅在及其严重的错误情况下抛出异常。比如一个抽象基类。由于 OC 中没办法将某个类标识为抽象类。如果想要实现抽象类的功能，那么就要在必须要覆写的方法里抛出异常： 123456- (void)mustOverrideMethod&#123; NSString *reason = [NSString stringWithFormat:@"%@ must be overridden", NSStringFromeSelector(_cmd)]; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];&#125; 对于不严重的异常，可以使用回调块的方式返回 nil 或者 NSError 抛给方法的调用者处理，比如各种网络库都是这么做的，输入一个成功回调，和一个失败回调。 第22条：理解NSCopying协议自定义拷贝如果我们想令自己的类支持拷贝操作，那就要实现 NSCopying 协议，该协议只有一个方法： 1- (id)copyWithZone:(NSZone*)zone 比如要拷贝一个 EOCPerson 对象： 12345- (id)copyWithZone:(NSZone*)zone &#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125; 这里面的 NSZone *zone 对象是以前开发程序时，会根据此吧内存分成不同的区(zone)，对象会被创建在某个区里面。现在不用了，每个程序都只有一个区：”默认区”，所以现在不必在意这个对象。这个方法就是新建一个 EOCPerson 对象，然后调用它的构造函数把东西全都塞进去。这里的 -&gt; 用箭头是因为定义的时候这个 _friends 不是一个属性(代码没有贴出来，详见书)，而只是在实现文件中定义的一个实例变量，没有 get/set 方法，所以不能用 .，一般情况用点语法就行了。 这里的 mutableCopy 方法也可以自定义，就是下面方法的实现： 1-(id)mutableCopyWithZone:(NSZone*)zone； 浅拷贝与深拷贝浅拷贝和深拷贝应该并不陌生。浅拷贝只增加引用计数，深拷贝将创建另一个一模一样的对象。 不可变对象的 copy 是浅拷贝。 可变对象的 copy 是深拷贝，返回不可变对象。 不可变对象的 mutableCopy 是深拷贝，返回可变对象。 可变对象的 mutableCopy 是深拷贝。 容器对象(NSArray)本身也遵循上面的规则。但是需要注意的是，容器对象内的元素是浅拷贝（你可能通过深拷贝新建了一个 NSArray，但是 NSArray 里面存的还是对象的指针，还是可以修改 NSArray 里的对象的，两个 NSArray 里的对象都会被修改）。因此上面的自定义 copy 方法如果想让 _friends 内的元素深拷贝，就不能用 [_friends mutableCopy] 方法，需要新建一个 Set: 12345- (id)deepCopy &#123; EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;&#125; 协议与分类第23条：通过委托与数据源协议进行对象间通信其实也是老生常谈的东西了，不过也有一些注意点。 受代理对象内持有代理对象的实例时要写成这样： 1@property (nonatomic, weak) id &lt;NetworkDelegate&gt; delegate; 这里书中指明了要用 weak，不能用 strong，否则会引起引用循环。比如系统中的 TableViewCellDelegate，在 TableViewController 作为代理类确实拥有被代理对象 TableViewCell，用 weak 确实是合理的，但是所有情况都这样吗？不知道，不过确实基本上的代理对象都是 ViewController，所以用 weak 肯定是不会有问题的。 实现委托对象的方法是声明某个类遵从委托协议： 12345@implementation EOCDataModel () &lt;EOCNetworkFetcherDelegate&gt;@end@implementation EOCDataModel// 各个实现方法@end 基本所有的 Delegate 都在 .m 文件中的类拓展中声明，之前一直没有留意，看了书后才问自己，为什么不在 .h 中声明？两者有什么差别吗？其实也没什么差别，在实现文件中声明的好处是能隐藏细节。如果只是自己用可能没什么区别，但是如果打包给别人用，那么就不应该让别人看到你的实现细节了，因此，就把这个 Delegate 的声明放到了实现文件中。 另外说说通过 delegate 传值和直接传值的区别。直接传值是一种自己的主动的行为，delegate 传值是一种被动的别人向你讨要的行为。一般我们设置某个类的 delegate 的时候，要么是设置其他类的 delegate 为自己 xxx.delegate = self，要么是设置其他类的 delegate 为其他类 xxx.delegate = xxxx，绝不会将自己的 delegate 设置为其他类的，即没有这样的 self.delegate = xxx。因为你已经知道那个类是什么的，为什么不直接调用那个类的方法呢？ 第24条：将类的实现代码分散到便于管理的数个分类中当一个类越来越大时，就变得不利于管理，因此需要将类代码按照逻辑划分入几个分区中，可以通过范畴的方式实现。书中有一个例子： 无分类:123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;/* Friendship methods */- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;/* Work methods */- (void)performDaysWork;- (void)takeVacationFromWork;/* Play methods */- (void)goToTheCinema;- (void)goToSportsGame;@end 分类后:123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject@property (nonatomic, copy, readonly) NSString *firstName;@property (nonatomic, copy, readonly) NSString *lastName;@property (nonatomic, strong, readonly) NSArray *friends;- (id)initWithFirstName:(NSString*)firstNameandLastName:(NSString*)lastName;@end@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end@interface EOCPerson (Work)- (void)performDaysWork;- (void)takeVacationFromWork;@end@interface EOCPerson (Play)- (void)goToTheCinema;- (void)goToSportsGame;@end 如果觉得写在一个实现文件中太长了，可以拆开，比如将其中的 Friendship 拆开。 1234567891011121314151617181920212223242526272829303132// EOCPerson+Friendship.h#import "EOCPerson.h"@interface EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person;- (void)removeFriend:(EOCPerson*)person;- (BOOL)isFriendsWith:(EOCPerson*)person;@end// EOCPerson+Friendship.m#import "EOCPerson+Friendship.h"@implementation EOCPerson (Friendship)- (void)addFriend:(EOCPerson*)person &#123; /* ... */&#125;- (void)removeFriend:(EOCPerson*)person &#123; /* ... */&#125;- (BOOL)isFriendsWith:(EOCPerson*)person &#123; /* ... */&#125;@end 不过要注意，在新建分类文件时，一定要引入被分类的类文件。 这是一个很有用的将大文件拆分的技巧啊。 分类和协议都可以用 @property 定义属性，但是都只是声明了方法，没有定义成员变量 第25条：总是为第三方类的分类名称加前缀如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。否则可能会替换掉系统的方法。 第26条:勿在分类中声明属性这本书要是早点看到就好了，当时纠结这个很久，走了很多弯路。 分类机制，目标在于扩展类的功能，而不是封装数据。 第27条：使用class-continuation分类 隐藏实现细节通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用 class-continuation 分类的特性来补偿： 可以在 class-continuation 分类中增加实例变量。 可以在 class-continuation 分类中将公共接口的只读属性设置为读写。(这个看起来也挺有用的，外部无法修改，内部却能更改) 可以在 class-continuation 分类中遵循协议，使其不为人知。 例子一： 123@interface EOCPerson()&lt;EOCPersonDelegate&gt;// method@end 例子二： 1234567891011//.h@interface EOCPerson:NSObject@property (nonatomic,copy,readonly) NSString *firstName;@property (nonatomic,copy,readonly) NSString *lastName;- (id)initWithFirstName:(NSString *)firstName lastName:(NSString *)lastName;//.m@interface EOCPerson()@property (nonatomic,copy,readwrite) NSString *firstName;@property (nonatomic,copy,readwrite) NSString *lastName; 第28条:通过协议提供匿名对象OC 里的匿名对象和 Java 里的匿名对象不同，这里的匿名对象没有类型。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。它的表示方法为：id&lt;protocol&gt;。 通过协议提供匿名对象的主要使用场景有两个： 作为属性 作为方法参数 匿名对象作为属性在设定某个类为自己的代理属性时，可以不声明代理的类，而是用 id&lt;protocol&gt;，因为成为代理的终点并不是某个类的实例，而是遵循了某个协议。 1@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate; 在这里使用匿名对象的原因有两个： 将来可能会有很多不同类的实例对象作为该类的代理。 我们不想指明具体要使用哪个类来作为这个类的代理。 也就是说，能作为该类的代理的条件只有一个：它遵从了 &lt;EOCDelegate&gt; 协议。 匿名对象作为方法参数有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。 1- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key; 这个方法是 NSDictionary 的设值方法，它的参数只要遵从了 &lt;NSCopying&gt; 协议，就可以作为参数传进去,作为 NSDictionary 的键。 内存管理第29条：理解引用计数NSObject 协议声明了下面三个方法用于操作计数器，以递增或递减其值： retain: 递增保留计数 release： 递减保留计数 autorelease： 待稍后清理“自动释放池”时，再递减保留计数。 对象创建出来时，其保留计数至少为1。若想令其继续存活，则调用 retaion 方法。要是某部分代码不在使用该对象，则调用 release 或 autorelease。最终当保留计数归零时，对象就回收了(dealloced)。 如果按照引用树回溯，那么最终会发现一个根对象。在 iOS 中是 UIApplication 。两者都是应用程序启动时创建的单例。 调用 autorelease 会在稍后递减计数，通常是下一个事件循环。这个特性可以在方法返回对象时用到： 1234- (NSString *)stringValue&#123; NSString *str = [[NSString alloc] initWithFormat:@"I am this: %@",self]; return [str autorelease];&#125; 在 alloc 的时候，引用计数加一，返回的时候要将这次引用抵消，所以使用 autorelease。修改后，stringValue 方法把 NSString 对象返回给调用者的时候，此对象必然存活。所以我们能用下面这样使用： 12NSString *str = [self stringValue];NSLog(@"The string is: %@",str); 由于返回的 str 将于稍后自动释放，所以多出来的那一次保留操作到时候会自然抵消，无须执行任何内存管理操作。因为自动释放池中的释放操作要等到下一个事件循环才能执行，所以 NSLog 语句在使用 str 对象前不需要手动执行保留操作。但是如果要持有此对象的话，那就需要保留，然后手动释放了： 123_instanceVariable = [[self stringValue] retain];//...[_instanceVariable release]; 由此可见，autorelease 可以延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。 第30条：以ARC简化引用计数引用计数还是要执行的，只不过保留和释放操作现在由 ARC 自动添加，可以省略对于引用计数的操作。由于 ARC 会执行 retain release autorelease dealloc，所以直接调用这些方法是非法的。 需要了解一个修饰符 __weak。块内引用外部变量时，会自动保留其所捕获的全部对象，如果这其中有某个对象保留了块本身（如将 ViewController 传入），将会形成“保留环”。所以要用 __weak 局部变量来打破这种保留环。 1EOCNetwork * __weak weakFetcher = fetcher; 我们在使用 block 的过程中，经常会需要引用 self，为了打破引用循环，我们需要这么做： 1234567// block 外__weak typeof(self) wself = self;// block 内// 先判断 self 是否已被回收，然后再强引用 wself，使之不会在 block 执行的时候被回收if (!wself) return;__strong typeof(wself) sself = wself 第31条：在dealloc方法中只释放引用并解除监听对象在经历生命期后，最终会被系统回收，这里就是执行 dealloc 方法了。永远不要自己调用 dealloc 方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在 dealloc 方法中做一些操作。那么我们可以在 dealloc 方法里做什么呢？ 释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。 对象拥有的其他非OC对象也要释放（CoreFoundation 对象就必须手动释放） 释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。 例如：1234- (void)dealloc &#123; CFRelease(coreFoundationObject); [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 除了释放引用和注销通知，不要在 dealloc 中做其他任何事（比如调用属性的存取方法，以及异步操作）。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放该资源。这样的类要和使用者约定，用完资源后必须调用 close 方法。 第32条：编写“异常安全代码”时留意内存管理问题在发生异常时的内存管理需要仔细考虑内存管理的问题：在 try 块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在 catch 块中能处理此问题，否则对象所占内存就将泄漏。 1234567@try &#123; EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow];&#125;@catch (...) &#123; NSLog(@"Whoops, there was an error. Oh well...");&#125; 所以一定要注意将 try 块内所创建的对象处理干净。 第33条：以弱引用避免保留环对象之间都用强指针引用对方的话会造成保留环。如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。不像 Java 那种处理方式，OC 中孤立的保留环不能被自动释放。 那么就要用弱引用的方式： 1234567//EOCClassB.m//第一种弱引用：unsafe_unretained@property (nonatomic, unsafe_unretained) EOCClassA *other;//第二种弱引用：weak@property (nonatomic, weak) EOCClassA *other; 这两种弱引用有什么区别呢？当指向 EOCClassA 实例的引用移除后，unsafe_unretained 属性仍然指向那个已经回收的实例，而 weak 指向 nil。显然，用 weak 字段应该是更安全的，因为不再使用的对象按理说应该设置为 nil,而不应该产生依赖。 所以只要用 weak 就行了。 第34条：以“自动释放池快”降低内存峰值这个部分在 runloop 相关文章中有学习过。主要用的是这样一个例子： 123for (int i = 0; i &lt; 100000; i++) &#123; [self doSomethingWithInt:i];&#125; 由于线程自动释放池在 event loop 时，进行清空，上面的代码将可能造成内存峰值。因此，可以手动添加一个自动释放池，把循环内的代码包裹在内，那么循环中自动释放的独享就会在这个池中，而不是在线程的主池中。 12345678NSArray *databaseRecords = /* ... */;NSMutableArray *people = [NSMutableArray new];for (NSDictionary *record in databaseRecords) &#123; @autoreleasepool &#123; EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; [people addObject:person]; &#125;&#125; 第35条：用“僵尸对象”调试内存管理问题某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。如果程序没有崩溃，可能是因为： 该内存的部分原数据没有被覆写。 该内存恰好被另一个对象占据，而这个对象可以应答这个方法。 如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。因此，我们希望可以通过一种方法捕捉到对象被释放后收到消息的情况。这种方法就是利用僵尸对象！ Cocoa 提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改 isa 指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。 (感觉好像用处不太大的样子。) 第36条：不要使用retainCountARC 后，这个 retainCount 方法就废弃了。反正从来没用过，也就没啥好看的了。 块与大小枢派发第37条：理解“块”这一概念基本概念无需多说，这里强调一下块的种类。 块分为三类： 栈块 堆块 全局块 栈块这是比较容易被忽略的一块。定义块的时候，其所占内存区域是分配在栈中的，而且只在定义它的那个范围内有效： 1234567891011121314void (^block)();if ( /* some condition */ ) &#123; block = ^&#123; NSLog(@"Block A"); &#125;;&#125; else &#123; block = ^&#123; NSLog(@"Block B"); &#125;;&#125;block(); 上面定义的两个块只在 if else 语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。 并不明白把块保存在栈上是个什么机制。应该可以这么理解吧:block 是一个指向栈上内存的指针，栈和堆的引用机制不同，在代码块运行结束后就会将代码块中的局部变量出栈，这个时候 block 指向的地方就被回收，block 就成了野指针，因此就会 crash 了。 一般情况下，我们平时要么就定义完就传出去了，要么就把 block 定义成了类的属性，所以就没有发生过这种情况。 堆块平时对块的操作肯定不能以栈块的形式来存储啊。堆块，要在原来的基础上执行 copy，让代码保存在堆上。 12345678910111213void (^block)();if ( /* some condition */ ) &#123; block = [^&#123; NSLog(@"Block A"); &#125; copy];&#125; else &#123; block = [^&#123; NSLog(@"Block B"); &#125; copy];&#125;block(); 然后 block 就能指向堆上的地址了。 平时我们用属性方式保存块的时候都是这样声明的： 1@property (nonatomic,copy) Block block; 这个属性里暗含了 copy 操作了。 block 会捕获外部的变量的值，然后将其复制为自己私有的 const 变量。所以一般不让在 block 内部改变外部变量的值。但是可以在外部变量前加上 __block 修饰，这样就会将外部变量的内存捕获，进而不管在 block 内部还是外部都可以修改变量的值。 全局块在全局内存里声明的就是全局块，没用过。不知道有什么好处。 第38条：为常用的块类型创建typedef如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型： 123456int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123; // Implementation return someInt;&#125;- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError *error))completion; 这个块有一个 bool 参数和一个 int 参数，并返回 int 类型。我们可以给它定义类型： 12345678typedef int(^EOCSomeBlock)(BOOL flag, int value);typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);EOCSomeBlock block = ^(BOOL flag, int value)&#123; // Implementation&#125;;- (void)startWithCompletionHandler:(EOCCompletionHandler)completion; 第39条：用handler块降低代码分散程度可以通过块的方式代替代理模式。 代理模式主要是为了让其他类在必要时候调用自己类的方法。而使用块的方式可以直接将方法内容作为参数或者属性传入调用块。这样设计业务逻辑更加直观清晰。 第40条：用块引用其所属对象时不要出现保留环注意使用块的时候不要产生保留环，要在块执行完成后，将块置为 nil。 一种是传入 weak 对象，一种是执行完置 nil。我觉得还是传入 weak 对象比较好。因为我不知道这个块会不会执行。如果不执行，那不是一直释放不了了？ 第41条：多用派发队列，少用同步锁多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用 GCD 来为代码加锁的方式解决这个问题。 方案一：使用串行同步队列来将读写操作都安排到同一个队列里：1234567891011121314151617_syncQueue = dispatch_queue_create("com.effectiveobjectivec.syncQueue", NULL);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这里，用了一个串行队列，保证了读写操作都加了锁，是一种解决方式。但是，我们要明确一点，数据的正确性主要取决于写入操作，只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。因此，我们要加以改进，读操作并行，写操作串行。可以通过 dispatch_barrier_async、dispatch_barrier_sync 完成。 将写操作放入栅栏块中，让他们单独执行；将读取操作并发执行在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按照顺序逐个执行。并发队列如果发现接下来要处理的块是个栅栏块，那么就一直等到当前所有并发块都执行完毕，才会单独执行这个栅栏块。待栅栏块执行过后，再按正常方式继续向下处理。相当于给并行队列里加个锁 123456789101112131415161718_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//读取字符串- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;//设置字符串- (void)setSomeString:(NSString*)someString &#123; dispatch_barrier_async(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; 这里解释下为什么读取用的是 sync，写入用的是 async，因为读取是要有返回值的，要将值返回给调用的对象，总不能还没有拿到值，就已经 return 了吧；而写入操作没有返回值，那么就让它立即 return 执行后面的代码，另开线程写入。 第42条：多用GCD，少用performSelector系列方法在iOS开发中，有时会使用 performSelector 来执行某个方法，但是 performSelector 系列的方法能处理的选择子很局限，最好使用 GCD： 它无法处理带有多个参数的选择子（有最多支持两个选择子的方法） 返回值只能是void或者对象类型 会引起内存泄露 但是如果将方法放在块中，通过 GCD 来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给 GCD 来实现，而不是通过 performSelector 方法。 延后执行某个任务的方法123456789// 使用 performSelector:withObject:afterDelay:[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];// 使用 dispatch_afterdispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123; [self doSomething];&#125;); 将任务放在主线程执行123456789// 使用 performSelectorOnMainThread:withObject:waitUntilDone:[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];// 使用 dispatch_async// (or if waitUntilDone is YES, then dispatch_sync)dispatch_async(dispatch_get_main_queue(), ^&#123; [self doSomething];&#125;); 如果 waitUntilDone 的参数是 Yes，那么就对应 GCD 的 dispatch_sync 方法。我们可以看到，使用 GCD 的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。 第43条：掌握GCD及操作队列的使用时机除了 GCD，操作队列（NSOperationQueue）也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用 GCD 好些，有时则是使用操作队列更加合理。（并不清楚操作队列怎么用的，反正就抄一下哪里好） 可以取消操作：在运行任务前，可以在NSOperation对象调用 cancel 方法，标明此任务不需要执行。但是 GCD 队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。 可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。 监控 NSOperation 对象的属性：可以通过 KVO 来监听 NSOperation 的属性：可以通过 isCancelled 属性来判断任务是否已取消；通过 isFinished 属性来判断任务是否已经完成。 可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。 第44条：通过Dispath Group机制，根据系统资源状况来执行任务有时需要等待多个并行任务结束的那一刻执行某个任务，这个时候就可以使用 dispath group 函数来实现这个需求： 通过 dispath group 函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。 123456789101112131415161718192021222324//一个优先级低的并发队列dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);//一个优先级高的并发队列dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);//创建dispatch_groupdispatch_group_t dispatchGroup = dispatch_group_create();//将优先级低的队列放入dispatch_groupfor (id object in lowPriorityObjects) &#123; dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);&#125;//将优先级高的队列放入dispatch_groupfor (id object in highPriorityObjects) &#123; dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;);&#125;//dispatch_group里的任务都结束后调用块中的代码dispatch_queue_t notifyQueue = dispatch_get_main_queue();dispatch_group_notify(dispatchGroup,notifyQueue,^&#123; // Continue processing after completing tasks&#125;); 想要更详细的了解，还是看之前的 GCD 介绍文章吧。 第45条：使用dispatch_once来执行只需运行一次的线程安全代码有时我们可能只需要将某段代码执行一次，这时可以通过 dispatch_once 函数来解决。 dispatch_once 函数比较重要的使用例子是单例模式：我们在创建单例模式的实例时，可以使用 dispatch_once 函数来令初始化代码只执行一次，并且内部是线程安全的。 而且，对于执行一次的 block 来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在 static 或 global 作用域里。 12345678+ (id)sharedInstance &#123; static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; 第46条：不要使用dispatch_get_current_queue因为如果是同步操作的时候再使用 dispatch_get_current_queue 会造成死锁。所以 iOS 已经废除了这个 API。 一般我们用其判断当前线程是否为特定线程。比如： 12345678void func(dispatch_queue_t queue, dispatch_block_t block) &#123; if (dispatch_get_current_queue() == queue) &#123; block(); &#125;else&#123; dispatch_sync(queue, block); &#125; &#125; 但是这样是错误的。因为如果 queue 就是 current_queue 的时候，并不是执行 block，而是发生死锁。 那么我们如何获取当前队列呢？使用 dispatch_queue_set_specific 及 dispatch_queue_set_specific。比如你在某一个类中的某一个方法里需要判断当前队列是不是队列，举一个 FMDB 中的例子: 123456789static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;// FMDatabaseQueue 某个方法内_queue = dispatch_queue_create(@"someQueue", NULL);dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);// 另一个方法内FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);assert(currentSyncQueue == nil); 先创建了一个 queue 然后通过 dispatch_queue_set_specific 将第一个入参 queue 和第二个关键字 kDispatchQueueSpecificKey 进行关联。整个过程的上下文 context 是 self，也就是说将这个队列和字符串的关联绑定给了第三个参数，这个上下文实例上了。注意是绑定给实例，而不是给类的，不同的 context 可以使用相同的关键字绑定队列。 然后在要判断的时候，在原先的 context 下，使用 dispatch_get_specific，入参为之前设置的关键字。如果当前队列为绑定的队列，那么将上面的第三个参数 context 实例返回，否则返回 nil。 系统框架第47条：熟悉系统框架主要的系统框架： Foundation :NSObject,NSArray,NSDictionary 等 CFoundation :C 语言 API，Foundation 框架中的许多功能，都可以在这里找到对应的 C 语言 API CFNetwork :C 语言 API，提供了 C 语言级别的网络通信能力 CoreAudio :C 语言 API，操作设备上的音频硬件 AVFoundation:提供的 OC 对象可以回放并录制音频和视频 CoreData :OC 的 API，将对象写入数据库 CoreText :C 语言 API，高效执行文字排版和渲染操作 第48条：多用块枚举，少用for循环传统的for遍历1234567891011121314151617181920212223242526NSArray *anArray = /* ... */;for (int i = 0; i &lt; anArray.count; i++) &#123; id object = anArray[i]; // Do something with 'object'&#125;// DictionaryNSDictionary *aDictionary = /* ... */;NSArray *keys = [aDictionary allKeys];for (int i = 0; i &lt; keys.count; i++) &#123; id key = keys[i]; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125;// SetNSSet *aSet = /* ... */;NSArray *objects = [aSet allObjects];for (int i = 0; i &lt; objects.count; i++) &#123; id object = objects[i]; // Do something with 'object'&#125; 我们可以看到，在遍历 NSDictionary,和 NSet 时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。 利用快速遍历123456789101112131415161718NSArray *anArray = /* ... */;for (id object in anArray) &#123; // Do something with 'object'&#125;// DictionaryNSDictionary *aDictionary = /* ... */;for (id key in aDictionary) &#123; id value = aDictionary[key]; // Do something with 'key' and 'value'&#125;NSSet *aSet = /* ... */;for (id object in aSet) &#123; // Do something with 'object'&#125; 这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。 利用基于块（block）的遍历oc 提供了新的遍历方式，与 for 循环相比，能够优雅的获得元素的下标： 123456// array- (void)enumerateObjectsUsingBlock:(void(^)(id object,NSUInteger idx,BOOL *stop))block// set- (void)enumerateObjectsUsingBlock:(void(^)(id object,BOOL *stop))block// dic- (void)enumerateObjectsUsingBlock:(void(^)(id key,id object,BOOL *stop))block 其中可以通过 *stop = YES 来中途终止遍历。注意一定要带 *。 后面几个没啥意思。用的不多，不写了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的多线程学习笔记]]></title>
    <url>%2F2016%2F11%2F01%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。 可以通过三种方式实现 iOS 的多线程： NSThread GCD NSOperation&amp;NSOperationQueue NSThread创建并启动先创建线程类，再启动1234// 创建NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];// 启动[thread start]; 其中，run: 是即将执行的方法，object 是 run: 方法的参数。规定 run: 方法最多可有一个参数，且返回类型必须是 void。 创建并自动启动1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil]; 使用 NSObject 的方法创建并自动启动1[self performSelectorInBackground:@selector(run:) withObject:nil]; 其他方法除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。 123456789101112131415161718192021222324//取消线程- (void)cancel;//启动线程- (void)start;//判断某个线程的状态的属性@property (readonly, getter=isExecuting) BOOL executing;@property (readonly, getter=isFinished) BOOL finished;@property (readonly, getter=isCancelled) BOOL cancelled;//设置和获取线程名字-(void)setName:(NSString *)n;-(NSString *)name;//获取当前线程信息+ (NSThread *)currentThread;//获取主线程信息+ (NSThread *)mainThread;//使当前线程暂停一段时间，或者暂停到某个时刻+ (void)sleepForTimeInterval:(NSTimeInterval)time;+ (void)sleepUntilDate:(NSDate *)date; GCD该部分前一篇关于 GCD 的文章已经较为详细的研究过了。 NSOperation创建NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。 使用子类 NSInvocationOperation 使用子类 NSBlockOperation 自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的两种创建方式。 NSOperation 一大优点就是可以通过 cancel 方法取消 NSOperation 还可以通过 KVO 监听 finished 以及 executing 状态 NSInvocationOperation 123456789101112131415161718192021/** * 使用子类 NSInvocationOperation */- (void)useInvocationOperation &#123; // 1.创建 NSInvocationOperation 对象 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 2.调用 start 方法开始执行操作 [op start];&#125;/** * 任务1 */- (void)task1 &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125;&#125; 在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 NSBlockOperation12345678910111213141516/** * 使用子类 NSBlockOperation */- (void)useBlockOperation &#123; // 1.创建 NSBlockOperation 对象 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 2.调用 start 方法开始执行操作 [op start];&#125; 在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。 使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。 创建队列NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列 凡是添加到主队列中的操作，都会放到主线程中执行。 12// 主队列获取方法NSOperationQueue *queue = [NSOperationQueue mainQueue]; 自定义队列（非主队列） 添加到这种队列中的操作，就会自动放到子线程中执行。 同时包含了：串行、并发功能。 12// 自定义队列创建方法NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 将操作加入到队列中上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。 那么我们需要将创建好的操作加入到队列中去。总共有两种方法。 - (void)addOperation:(NSOperation *)op;需要先创建操作，再将创建好的操作加入到创建好的队列中去。 12345678910111213141516171819202122232425262728293031323334/** * 使用 addOperation: 将操作加入到操作队列中 */- (void)addOperationToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 // 使用 NSInvocationOperation 创建操作1 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 使用 NSInvocationOperation 创建操作2 NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; // 使用 NSBlockOperation 创建操作3 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] [queue addOperation:op3]; // [op3 start]&#125; 使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。 - (void)addOperationWithBlock:(void (^)(void))block;无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中 12345678910111213141516171819202122232425262728/** * 使用 addOperationWithBlock: 将操作加入到操作队列中 */- (void)addOperationWithBlockToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行. NSOperationQueue 控制串行执行、并发执行这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 最大并发操作数： 1maxConcurrentOperationCount maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。 maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。 NSOperation操作依赖NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。 - (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 - (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。 如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下： 123456789101112131415161718192021222324252627282930/** * 操作依赖 * 使用方法：addDependency: */- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125; 通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。 NSOperation 优先级NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。 其他NSNotification 与 多线程NSNotification 在哪个线程 post，最终就会在哪个线程执行。如果我们不是在主线程 post 的，但是却在主线程接收的，而且我们期望 selector 在主线程执行。这时候我们需要注意下，在 selector 需要 dispatch 到主线程才可以 12345678910111213141516171819202122232425@implementation BLPostNotification- (void)postNotification &#123; dispatch_queue_t queue = dispatch_queue_create("com.bool.post.notification", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 从非主线程发送通知 （通知名字最好定义成一个常量） [[NSNotificationCenter defaultCenter] postNotificationName:@"downloadImage" object:nil]; &#125;);&#125;@end@implementation ImageViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(show) name:@"downloadImage" object:nil];&#125;- (void)showImage &#123; // 需要 dispatch 到主线程更新 UI dispatch_async(dispatch_get_main_queue(), ^&#123; // update UI &#125;);&#125;@end 线程同步互斥锁使用 @synchronized: 123@synchronized(self) &#123; //需要执行的代码块&#125; 同步执行把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。 从其他线程回到主线程的方法在其他线程操作完成后必须到主线程更新UI NSThread1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO]; GCD123dispatch_async(dispatch_get_main_queue(), ^&#123; ...&#125;); NSOperation1234567891011121314151617181920212223242526/** * 线程间通信 */- (void)communication &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; // 2.添加操作 [queue addOperationWithBlock:^&#123; // 异步进行耗时操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 进行一些 UI 刷新等操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; &#125;];&#125; 锁自旋锁定义自旋锁不会引起调用者睡眠，而是不停的循环，直到锁被释放。适用于多核。 OSSpinLockiOS 中的自旋锁为 OSSpinLock。但是不建议使用。因为会产生优先级反转的现象。 优先级反转由于线程存在优先级，即根据优先级来分配 CPU 执行时间。但是会产生问题：如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。 特点由于不停循环，避免了线程上下文切换的时间损耗。在能快速获取资源的多线程环境中速度最快。 互斥锁定义顾名思义，等待锁的线程会处于休眠状态。 常见类型 iOS 使用以 pthread_mutex 为基础的各种封装。常见三种类型： PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_RECURSIVE NSLock针对第二种类型，iOS 封装了 NSLock。它会损失一定性能换来错误提示。并简化直接使用 pthread_mutex 的定义。 1234567891011121314151617181920212223//主线程中NSLock *lock = [[NSLock alloc] init]; //线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lock]; NSLog(@"线程1"); sleep(2); [lock unlock]; NSLog(@"线程1解锁成功"); &#125;); //线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1);//以保证让线程2的代码后执行 [lock lock]; NSLog(@"线程2"); [lock unlock]; &#125;);2016-08-19 14:23:09.659 ThreadLockControlDemo[1754:129663] 线程12016-08-19 14:23:11.663 ThreadLockControlDemo[1754:129663] 线程1解锁成功2016-08-19 14:23:11.665 ThreadLockControlDemo[1754:129659] 线程2 NSReursiveLock 和 @synchronized针对第三种类型，iOS 封装了 NSRecursiveLock 和 @synchronized。它们是递归锁，也就是说同一个线程可以重复获取递归锁，不会死锁。NSRecursiveLock 和 NSLock 使用类似。 @synchronized 实现原理@synchronized 中传入的object的内存地址，被用作key，系统创建了一个递归锁，作为值，保存在一个 hash map 中。每当再次遇到 @synchronized 关键字的时候，就会到 hash map 中得到这个锁，并且尝试获取这个锁，失败则挂起。 所以，如果object 被外部访问变化，@synchronized 就失去了锁的作用。因此一定要注意，不能改变 object 的地址。 这是一个考点，@synchronized 如何实现的 NSConditionLock另外还有一种条件锁NSConditionLock。基于 pthread_cond_t 实现。只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。 123456789101112131415161718192021//主线程中NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:0];//线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [lock lockWhenCondition:1]; NSLog(@"线程1"); sleep(2); [lock unlock];&#125;);//线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([lock lockWhenCondition:0]) &#123; NSLog(@"线程2"); [lock unlockWithCondition:1]; NSLog(@"线程2解锁成功"); &#125; else &#123; NSLog(@"线程2尝试加锁失败"); &#125;&#125;); NSConditionLock 就针对于多个线程在复制场景下的同步。 信号量定义信号量的初始值，可以用来控制线程并发访问的最大数量。信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步。 信号量是负几，就表示有几个线程在等待资源。 dispatch_semaphore123456dispatch_semaphore_t signal = dispatch_semaphore_create(1);// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);// 让信号量的值+1dispatch_semaphore_signal(signal); 信号量和互斥锁的区别虽然 Semaphore=1时可以看成互斥锁，但是它们真正的使用场景是有差别的。 锁是服务于共享资源的；而semaphore是服务于多个线程间的执行的逻辑顺序的。比如，a 和 b 执行完了再执行 c，就可以通过信号量实现，但是无法通过互斥锁实现。 二元信号量和互斥锁的区别在《程序员的自我修养》中提及，信号量作为 IPC 的一种方式，可以在非当前进程释放，而互斥锁只能在当前进程中释放。 以上说法是关于进程的，在线程中的试验结果是都可以释放。 条件变量和信号量区别每个信号量有一个与之关联的值，发出时+1，等待时-1，任何线程都可以发出一个信号，即使没有线程在等待该信号量的值。 可是对于条件变量，例如 pthread_cond_signal 发出信号后，没有任何线程阻塞在 pthread_cond_wait 上，那这个条件变量上的信号会直接丢失掉。 速度比较OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; NSLock &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized 如何使用互斥锁实现读写锁？1234567891011121314151617181920212223242526272829303132333435363738394041class readwrite_lock&#123;public: readwrite_lock() : read_cnt(0) &#123; &#125; void readLock() &#123; read_mtx.lock(); if (++read_cnt == 1) write_mtx.lock(); read_mtx.unlock(); &#125; void readUnlock() &#123; read_mtx.lock(); if (--read_cnt == 0) write_mtx.unlock(); read_mtx.unlock(); &#125; void writeLock() &#123; write_mtx.lock(); &#125; void writeUnlock() &#123; write_mtx.unlock(); &#125;private: mutex read_mtx; mutex write_mtx; int read_cnt; // 已加读锁个数&#125;; 其他问题 i++ 在两个线程中分别执行100次，不加锁，最后 i 的取值范围？ 2-200，200 的情况不用多说，2 的情况是： 两个线程同时读取了初始值 0。 线程1执行了 99 次，写回。此时内存为 99。 线程2执行了一次，写回。此时内存为 1。 两个线程同时读取值 1。 线程2执行 99 次，写回。此时内存为 99 线程1执行1次，写回。此时内存为 2 问题的关键在于，一个线程的写入与读取这两个操作之间，可以穿插别的线程的写入操作。 参考谈 iOS 的锁 iOS多线程：『NSOperation、NSOperationQueue』详尽总结]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runLoop学习笔记]]></title>
    <url>%2F2016%2F11%2F01%2Frunloop%2F</url>
    <content type="text"><![CDATA[runLoop 虽然平时很少用到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。 概念什么是RunLoop以下是一个 iOS 程序的 main 函数： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; main 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 上面代码中 UIApplicationMain() 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示： 在 OS X/iOS 系统中，提供了两个这样的对象： CFRunLoopRef：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 先来一张 RunLoop 机制关系图总览： RunLoop与线程的关系苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 CFRunLoopGetMain()， CFRunLoopGetCurrent()。NSRunLoop 的获取方法是 currentRunLoop,mainRunLoop。NSRunLoop 对象可以通过 getCFRunLoop 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 Run Loop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个1的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有，所以一个子线程，你想要它有 RunLoop 就必须在该线程内调用 NSRunLoop *runLoop =[NSRunLoop currentRunLoop]。如果你想启动这个 RunLoop，则要继续调用 [runLoop run]。但是注意，一般不需要开启子线程的 runLoop，因为这会让子线程一直存在，不会回收。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop对外接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef 其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 接口类型RunLoop的SourceRunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）： Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：performSelector:onThread: Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：[NSTimer scheduledTimerWithTimeInterval:target:selector:] 下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源 Input SourceInput Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)： Source0 只包含了一个回调（函数指针），非基于Port的，它并不能主动触发事件。主要处理触摸事件，performSelectors 等 Source1 包含了一个 mach_port 和一个回调（函数指针），基于Port的，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。 Time Source基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。 Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 scheduledTimerWithTimeInterval 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（scheduledTimerWithTimeInterval 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。） RunLoop的ModeRunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。 系统默认定了一下几个 mode： kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有） GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。 Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); RunLoop的Observers对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件： 进入 RunLoop 的时候 RunLoop 将要处理一个 Timer source 的时候 RunLoop 将要处理一个 Input source 的时候 RunLoop 将要休眠的时候 RunLoop 被唤醒，并准备处理唤醒它的事件的时候 RunLoop 将要退出的时候 使用方式Input SourceTimer SourceObservers这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。RunLoop深度探究（五）RunLoop走进Run Loop的世界 (一)：什么是Run Loop？iOS多线程编程指南（三）Run Loop相关使用 Demo 也放到 github 上了。 实现处理过程 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： RunLoop 的核心就是一个 mach_msg()，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。 应用苹果使用 RunLoop 实现了诸多功能 AutoreleasePoolAutorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时或者线程销毁时释放的，当有 runloop 的情况下，系统在每个 runloop 循环中都加入了自动释放池 Push 和 Pop。 什么情况下会自动创建 autoreleasepool？ 手动调用了 autorelease 方法的对象，比如 __autorelease Person *p = [[Person alloc] init]，会在当前线程插入创建一个 AutoreleasePool。 调用非 alloc，new 开头方法的时候，比如 NSString *str = [NSString stringwithForamt:@&quot;&amp;ld&quot;, 123123123123123],会将对象加入 AutoreleasePool 如果是 ARC 下编译器自动插入的 [person release]，则会直接减少引用计数。而不会延迟释放 原理ARC下，我们使用 @autoreleasepool{} 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子： 123void *context = objc_autoreleasePoolPush();&#123;&#125;中的代码objc_autoreleasePoolPop(context); 而这两个函数都是对 AutoreleasePoolPage 的简单封装，所以自动释放机制的核心就在于这个类。 AutoreleasePoolPage 是一个 C++ 实现的类 AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针） AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程） AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址 上面的 id *next 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置 一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入 所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图： 图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 autorelease 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。 每当进行一次 objc_autoreleasePoolPush 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子： objc_autoreleasePoolPush 的返回值正是这个哨兵对象的地址，被 objc_autoreleasePoolPop (哨兵对象)作为入参，于是： 根据传入的哨兵对象地址找到哨兵对象所处的 page 在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 - release 消息，并向回移动 next 指针到正确位置 补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page 刚才的 objc_autoreleasePoolPop 执行后，最终变成了下面的样子： 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发__IOHIDEventSystemClientQueueCallback() 回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器参见 iOS 定时器 这一篇。几乎所有定时器都要求 runloop 开启，且将自身加入到 runloop 中。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: CFSocket CFNetwork -&gt;ASIHttpRequest NSURLConnection -&gt;AFNetworking NSURLSession -&gt;AFNetworking2, Alamofire NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"AFNetworking"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 RN 中的线程保活RN 会开启一个 jsThread，用于通过 performSelector:onThread:withObject:waitUntilDone: 方法将异步执行任务。 RN 中开启runloop的方式和 AF 中的不同： 123456789101112131415161718192021222324252627282930// in some func_jsThread = [[NSThread alloc] initWithTarget:[self class] selector:@selector(runRunLoop) object:nil];_jsThread.name = RCTJSThreadName;_jsThread.qualityOfService = NSOperationQualityOfServiceUserInteractive;[_jsThread start];+ (void)runRunLoop&#123; @autoreleasepool &#123; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @"-[RCTCxxBridge runJSRunLoop] setup", nil); // copy thread name to pthread name pthread_setname_np([NSThread currentThread].name.UTF8String); // Set up a dummy runloop source to avoid spinning CFRunLoopSourceContext noSpinCtx = &#123;0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL&#125;; CFRunLoopSourceRef noSpinSource = CFRunLoopSourceCreate(NULL, 0, &amp;noSpinCtx); CFRunLoopAddSource(CFRunLoopGetCurrent(), noSpinSource, kCFRunLoopDefaultMode); CFRelease(noSpinSource); RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @""); // run the run loop while (kCFRunLoopRunStopped != CFRunLoopRunInMode(kCFRunLoopDefaultMode, ((NSDate *)[NSDate distantFuture]).timeIntervalSinceReferenceDate, NO)) &#123; RCTAssert(NO, @"not reached assertion"); // runloop spun. that's bad. &#125; &#125;&#125; 通过添加 source 给 runloop 的方式使线程保活。通过 CFRunLoopRunInMode() 方法开启 runloop 循环。runloop 开启后，之后的代码时不会执行的，所以只有当 runloop 停下来之后才会进行 while 判断。 RN 这种方式是可以取消 runloop 循环的，而 AF 的则不行，因为 RN 为 Runloop 设置了一个无穷大的过期时间，而 AF 的 runloop 则是会循环调用，取消一次下次还会开启。具体可见深入研究 Runloop 与线程保活 检测卡顿卡顿的发生可以通过一次 runloop 从开始到结束的时间间隔来间接判断。 注册 observer 记录 runloop 开启的时间，并且在 runloop 结束的时候清空，然后创建一个子线程，每隔一定时间去检测当前时间和 runloop 开启时记录的时间是否大于某一个阈值。 当大于某个阈值的时候表明产生了卡顿，记录下卡顿时候的堆栈 问题 runloop 有什么用？ runloop 和 线程的关系是什么？runloop 是如何获取的？ runloop 与其 mode 、Source/Timer/Observer 的关系？ runloop 有哪几种source？ runloop 的 input Source 有什么用？有哪两个版本？区别是什么？ runloop 有哪几种 mode？区别是什么？ runloop 的 observer 是干嘛的？ runloop 的处理过程是什么？ autoreleasepool 与 线程的关系？ autoreleasepool 的实现原理？ 手势识别、界面更新的基本过程是什么？ 参考黑幕背后的Autorelease 初识 Run Loop 深入理解RunLoop runloop退出]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios中库的介绍与使用]]></title>
    <url>%2F2016%2F10%2F17%2F%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。 先来看一张思维导图： 概念什么是库库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。 库的分类静态库存在 .a 和 .framework 两种形式。 .a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件。 .a ，要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用.framework的形式。 对于静态库而言，类似于一个编译好的 .o 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图： 动态库存在.framework和.tbd两种形式。 在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。 动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 PLT 直接跳转了。 优劣静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。 动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。 库的创建.a静态库的创建创建一个 .a 静态库项目，如下图所示：静态库的文件列表如下，在 products 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。现在新建自己的类PrintString.h，声明和实现一个第三方库的方法。现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：打包生成了静态库在 products 文件夹内：打开 products 文件夹， 但是此时暴露出来的头文件并没有PrintString.h。需要对暴露的头文件进行设置。如下图，在 Build Phase ，的 Copy Files 目录下加入想要公开的头文件：现在再 run 一次，就得到了正确的静态库。 实践证明，即使不在 CopyFiles 中设置，只要把想暴露的头文件提供给使用者，照样能够使用。这里只是把你想要暴露的头文件单独汇集在一个目录中 现在，可以测试一下这个静态库。可以再创建一个工程，把库连同要暴露的头文件一起拖进去。这里我新建了一个 target ：先要在工程和库间建立关联。如下图所示，在 Link Binary With Libraries 中添加库：在 ViewController.m 中调用库的方法：现在可以运行了，不过运行前要选择对 target ：可以在控制台看到库中的方法被调用了： .framework的创建动态framework创建一个framework：创建后的文件列表如下，可以看到只有一个 framework.h 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合： 实践证明，即使你不按照他的要求这样 #import &lt;Frameworks/PublicHeader.h&gt; 而是 #import &quot;PublicHeader.h&quot; 也是没问题的 将前面创建的 PrintString.h 和 PrintString.m 导入，并且 import 到 framework.h 中去：设置需要暴露的头文件，头文件默认在 project header 中，将需要暴露出来的拖到 public header 中去。 实践证明，不想暴露的头文件不要多次一举的放到 Private 中去。如果在 Private 中添加了文件，生成的 Framework 中是会有一个 PrivateHeaders 文件夹的，并且这些 PrivateHeaders 是能被应用方使用的。所以 Private 的直接不理，让它们留在 Project 中就行了。 我们可以看到此处有三种头文件，分别是 project header ， public header ， private header 。区别如下，不想让别人知道的放在 Project 下就行了： Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction. Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they’re not supposed to use them. Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you. 切记切记 要暴露的头文件一定要放在 Public 下，否则到时候引入的时候会出现如下错误(反正我是老是忘记这个)： 这个错误是因为，我在 DynamicWithStatic.h 中 import 的头文件并没有被被设置为 Public 导致的。 生成的 framework 文件目录如下： 将生成的 framework 放入工程中测试。和 .a直接 #import &quot;文件名.h&quot; 不同，framework 引入头文件的时候要按照 #import &lt;framework名/头文件名.h&gt; 的方式引入，静态的 Framework 也要如此。 现在编译可以通过，运行时出现如下错误： 需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 Embedded Binary 一项中加入相应动态库： 现在就可以正确运行了 静态framework静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 Mach-O Type 为 Static Library ： Bundle 的创建与使用有时候，我们需要自己创建一个 Bundle，包含一些图片或者 xib 文件。那么如何创建以及使用 Bundle 呢？ 新建 Target，在 iOS 选项中找不到 Bundle，那么我们就在 macOS 下选取创建 Bundle： 这个创建的是 macOS 使用的 Bundle，需要修改其 Base SDK 为 iOS 使用： 我们在这个 Bundle 里添加一张图片，现在运行生成 Bundle。将生成好的 Bundle放到测试工程中，可以看到图片添加了进去。 使用的时候由于不是直接在 mainBundle 下，所以不能直接使用 [UIImage imageNamed:@&quot;author&quot;]。需要找到 Bundle 所在的路径： 1[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@"NewBundle" ofType:@"bundle"] stringByAppendingString:@"/author.png"]] 通过路径拼接就能找到正确的图片路径。（对于有些不在 mainBundle 中的 bundle，比如动态库的 bundle，将在用 Cocoapods 创建一个库中介绍） 静态库与动态库的引用一个库的开发经常会需要用到其他的库(如 AFNetWorking )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库，以及如何配合使用 cocoapods 是我比较困惑的点。下面我就对其进行探。 网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。 准备本次我将使用 SVProgressHUD 作为测试的第三方库。我下载了其 2.1.2 的代码，并手动分别打成了静态库 StaticSVProgressHUD以及动态库 DynamicSVProgressHUD 这里强调一点：静态库无论是 .a 还是 .framework，都是无法把图片等资源文件打进去的（包括在工程中引入其他的 xcodeproj 最后也是生成一个 .a 的静态库）。如果有与静态库相匹配的资源文件，需要打一个 bundle 和静态库一起添加到工程中，然后就可以用代码到 mainBundle 中获取。动态库没有这个问题。 动态库引用静态库创建首先创建一个动态库 DynamicWithStatic，然后链接刚才生成的 StaticSVProgressHUD ： 向其中添加自己的显示 HUD 的类 DWSShowPic，并且将资源文件 SVProgressHUD.bundle 加入库中。之后设置好头文件就可以直接运行了。因为动态库引用静态库就相当于将代码直接添加在了动态库里，所以和普通动态库没有什么差别，具体可以看我的 Demo。记得一定要在测试工程中 Embedded Binaries 这个动态库。 引入 Cocoapods现在模拟上面创建的库是工作中要引入的，然后你本身使用 Cocoapods 管理第三方库的，并且也用到了 SVProgressHUD。那么这会产生什么冲突吗？我们实验一下。 我们将测试工程中引入 Cocoapods： 好的，运行项目，看看会发生什么： 运行时没有问题的，但是出现了一些警告。这是因为你在动态库中引入了静态库 SVProgressHUD，并且又用 Cocoapods 引入了一遍静态库 SVProgressHUD。这就产生了冲突，执行的时候会选择其中一个执行。我们需要对动态库中引入的静态库的文件进行改名，比如加上前缀。 如果在 Cocoapods 中引入的是动态库 SVProgressHUD 呢？结果也是一样的。会出现上面的警告，但是不影响运行。 动态库引用动态库创建创建一个动态库 DynamicWithDynamic，然后链接之前的动态库 DynamicSVProgressHUD: 和之前一样的，添加自己的显示类 DWDShowPic。由于 DynamicSVProgressHUD 中自带了资源 bundle，所以这里就不需要再添加了。没有什么特别的直接运行生成动态库。现在放到测试工程里运行。同样的，要 Embedded Binaries 中添加这个动态库。 不出意外的，程序崩了： 这个问题上面看到过。是因为没有链接上动态库。不过这里不是没有链接上 DynamicWithDynamic 而是没有链接上 DynamicSVProgressHUD。动态库不会被打包进动态库中，它只会创建一个引用，需要在项目中手动添加被引用的动态库。现在我们在测试工程的 Embedded Binaries 中添加所需的动态库： 可以顺利运行。 引入 Cocoapods现在模拟的是你的工程里使用 Cocoapods 使用了某个动态库，比如 DynamicSVProgressHUD，然后 SDK 提供者给你提供了一个使用 DynamicSVProgressHUD 的动态库 DynamicWithDynamic。那么引入会有什么问题吗？ 由于我之前用的都是对 SVProgressHUD 的封装 DynamicSVProgressHUD，现在看来是多此一举了，因为我还得自己创建一个能被 Cocoapods 引入的 DynamicSVprogressHUD。如果直接用 SVProgressHUD 就很开心了。现在修改 Podfile： 通过 use_frameworks 使 Cocoapods 创建动态库，然后自己创建了一个本地的 DynamicSVProgressHUD。 现在我们把刚才手动加入的 DynamicSVProgressHUD 删去，然后 pod install ，运行。结果正常，运行没有问题。 如果我们 pod 加载的是个静态的 DynamicSVProgressHUD，但是需要的是个动态的 DynamicSVProgressHUD 会这样？会产生和上面没有在 Embedded Binaries 中添加动态库相同原因的崩溃。 现在还有一个问题，如果我不将之前加入的 DynamicSVProgressHUD 删去呢？即工程中保留了两个同名的动态库 DynamicSVProgressHUD。会发生什么样的情况？ 运行，没有任何问题，也不会产生任何 warning。为了区分到底是哪个被执行了，我在 pod 添加的库的代码中添加了 log。运行时打印出了 log，证明运行的是 pod 的库。当然这不绝对，也有可能不执行 pod 的库的方法。问题的核心在于你在 Linked Frameworks and Libraries 时哪个库是先被添加的。上面的之所以总是执行 pod 的库，就是因为在 Linked Frameworks and Libraries 中，先添加的是 pod 的库。pod 的库执行时被加载后，手动添加的同名库就不会被加载了。 动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是和静态库一样完全写入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 SVProgressHUD 动态库时，那么仅需导入一份，就不会产生重复代码了。 静态库引用静态库创建现在来到静态库引用静态库的实验环节。我们还是先创建一个 StaticWithStatic 的静态库，在其中引入 StaticSVProgressHUD。然后创建一个类 SWSShowPic 用来调用静态库。由于上面说到静态库的资源文件无法打包在静态库中，因此，资源文件将直接放到测试工程中去： 把生成的静态库放到测试工程中去执行。编译时产生错误： 这个错误说明静态库 StaticWithStatic 并没有把 StaticSVProgressHUD 嵌入其中，即静态库无法嵌入静态库中。动态库确实是把静态库打在了自己的库中，但是静态库无法做到这一点。我想这应该和资源文件无法打进静态库类似。 所以，为了解决这个问题。我们需要在测试工程中添加所需的静态库 StaticSVProgressHUD: 现在再编译运行，一切正常。 引入 Cocoapods同样用 Cocoapods 模拟一下通过 Cocoapods 是否可以为静态库提供静态库的链接。按照上面的方式，创建一个供静态库引入的 StaticSVProgressHUD。注意要修改 Podfile，把 use_frameworks! 注释掉： 将原来手动引入的 StaticSVProgressHUD 删除，然后直接运行，没有任何问题。 那么再来思考一个问题，如果我不把手动引入的库删除，即有两个相同的静态库会怎样？ 可以看到，编译的时候直接报 duplicate symbol 的错。其实就是两个静态库中，不能有相同的文件名，否则编译不通过。不过之前对于动态库包含静态库中的文件和工程中文件重名的情况就只报了个 warning。（特指不能有同名文件，和库同名没有关系 -.-） 静态库引用动态库创建最后我们试验一下静态库如何引用动态库。还是如法炮制。创建一个静态库 StaticWithDynamic，然后在 Link FrameWorks and Libraries 中添加动态库 DynamicSVProgressHUD。现在把生成的静态库拖到测试工程中，运行，编译时出错。还是那个由于没有链接动态库产生的 image not found 错误，我就不贴图片了。 解决方式也是上面说的，要把动态库 DynamicSVProgressHUD 单独添加到 EMbedded Binaries中去。这样运行一切正常。 引入 Cocoapods通过之前的学习，到这里，不用试也应该知道会发生什么了。运行正常，如果项目里有多个同名动态库，先添加的会被执行。 总结到这里静态库动态库相互引用，以及配合 Cocoapods 的所有情况我都已经列举完毕了。累。应该所有接入 SDK 时候会遇到的情况都已经枚举过一遍了。 一些需要知道的点debug与release库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。 debug :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。 release : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。 debug 与 release 的设置方式如下图： 对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。 多架构编译库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。 框架分类： 模拟器架构: i386 : 32位架构 4S ~ 5 x86_64 : 64位架构 5S ~ 现在的机型 真机架构: arm7: 在最老的支持iOS7的设备上使用 arm7s: 在iPhone5和5C上使用 arm64: 运行于iPhone5S的64位 ARM 处理器 上 修改框架的方式如下图： debug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内： lipolipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。 -info查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。 -create上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式： 1lipo -create 库1 库2 -output 新库 使用结果如下图： -thin如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式： 1lipo 旧库 -thin 需拆分框架 -output 新库 使用结果如下图： 参考链接WWDC2014之iOS使用动态库手把手教你使用CocoaPods打包静态库iOS 静态库开发使用CocoaPods开发并打包静态库使用Cocoapods创建私有podspeciOS静态库 【.a 和framework】【超详细】创建一个 iOS Framework 项目iOS开发——创建你自己的FrameworkiOS中workspace与静态库Cocoapods 应用第一部分 - Xcode 创建 .framework 相关ios打包–打包静态库(五) 呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才写完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库~ 我的demo地址，欢迎参考]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storyboard 使用方法]]></title>
    <url>%2F2016%2F10%2F13%2Fstoryboard%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Storyboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。 先来看一下思维导图 storyboard基础storyboard优势storyboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点： storyboard能将nib汇总统一管理 storyboard可以描述各种场景之间的过渡，这种过渡被称作segue，storyboard 把 view controller叫做：scene，可以通过拖拽实现过度，减少代码 支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量 storyboard的基本使用启动storyboard加载storyboard肯定是需要一个主入口的，这个主入口在info.plist中： 初始化ViewController确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选Is Initial View Controller此时，对应ViewController前出现一个箭头 创建relationship segue对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。 如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：连接后的图标如下图，表示relationship segue 命名tabbar controller的tabbar并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：navigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。 设置ViewController对应的类选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。 获取视图控制器就是通过UITableViewController和UINavigationController中的viewControllers获取： 123UITabBarController *tabBarController = (UITabBarController *)self.window.rootViewController;UINavigationController *navigationController = [tabBarController viewControllers][0];PlayersViewController *playersViewController = [navigationController viewControllers][0]; Prototype cells选中tableview，设置tableview的 cotent 为 Dynamic Propotype一般在tableView: cellForRowAtIndexPath:方法中都像下面： 123456789101112- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *CellIdentifier = @"Cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]; &#125; // Configure the cell... return cell;&#125; 但是，由于在storyboard中已经创建了cell，那么就可以直接使用了： 12345678- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"PlayerCell"]; // Configure the cell... return cell;&#125; 当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：设置不同的 identifier 来标识不同的cell。 除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。 Static cells使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。 那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：此时右边栏出现如图所示 Table View Section可以设置数量，表头表尾的title 和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。 所以，方便起见，static cell 直接在viewController中连线设置就可以了。 使用segue简介什么是SegueStoryboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue） Segue的属性每一个Segue对象，都有3个属性 123456// 唯一标识@property (nonatomic, readonly) NSString *identifier;// 来源控制器@property (nonatomic, readonly) id sourceViewController;// 目标控制器@property (nonatomic, readonly) id destinationViewController; Segue的类型根据Segue的执行（跳转）时刻，Segue可以分为2大类型: 自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。 手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。 segue执行过程手动调用performSegueWithIdentifier:sender:方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。 根据identifier去storyboard中找到对应的线，新建UIStoryboardSegue对象 1- (instancetype)initWithIdentifier:(NSString *)identifier source:(UIViewController *)source destination:(UIViewController *)destination; // Designated initializer 其实就是执行了UIStoryboardSegue中initWithIdentifier:source:destination:方法,并且identifier就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾 调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象 1- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender; 所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。 调用Segue对象的perform方法开始执行界面跳转操作。 页面跳转segue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。 跳进使用storyboardAction segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。Manual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。 首先，先对两个viewController进行连线：之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：其中参数 identifier 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。 接下来就可以调用方法，在合适的时机加载了 12//根据 segue Identifier跳转界面[self performSegueWithIdentifier:@"GotoTwo" sender:self]; 其中的identifer自然不用多说，那么sender是什么呢？sender是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置sender区分了。引申开来，在设置button点击事件时的-(IBAction)click:(id)sender;方法中的sender和这里的sender是一个作用。 使用纯代码上面的方法实现效果和平时用的下面两个方法相同： 1234//以modal 方式跳转[self presentViewController:ViewController animated:YES completion:nil];//压进一个viewcontroller[self.navigationController pushViewController:ViewController animated:YES completion:nil]; 不过，既然用了storyboard了，那么实例化viewController时就不能用initWithNibName了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：那个use storyboardId的勾不打也行，不知道干什么用的， 现在就可以在代码中找到特定storyboard的viewcontroller了： 12345678- (IBAction)tapButton:(id)sender &#123; //获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard, UIStoryboard *story = [UIStoryboard storyboardWithName:@"Main" bundle:nil]; //由storyboard根据myView的storyBoardID来获取我们要切换的视图 UIViewController *myView = [story instantiateViewControllerWithIdentifier:@"myView"]; //显示ViewController [self presentViewController:myView animated:YES completion:nil];&#125; 跳出能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。 exit segue跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1： 先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是IBAction，参数类型一定是UIStoryboardSegue，名称随便（这个方法一定要加，返回时调用的） 123//其他界面返回到此界面调用的方法- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue &#123;&#125; 右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择manual，这里连接自己表示要在当前viewcontroller中用代码的方式回退。 给2视图的unwind segue取一个名字叫from2to1的identifier如下图: 现在就可以在界面2中的任意时候调用方法回退了： 1234- (IBAction)back:(id)sender &#123; //执行segue跳页的方法 [self performSegueWithIdentifier:@"from2to1" sender:nil];&#125; 使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法： 12345678//其他界面返回到此界面调用的方法- (IBAction)ViewController1UnwindSegue:(UIStoryboardSegue *)unwindSegue &#123; if ([unwindSegue.identifier isEqualToString:@"from2to1"]) &#123; _lbShowMessage.text = @"从2退到1"; &#125; else if ([unwindSegue.identifier isEqualToString:@"from3to1"]) &#123; _lbShowMessage.text = @"从3退到1"; &#125;&#125; 这里就看出上面为什么说类型一定是UIStoryboardSegue了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。 使用 exit segue 的好处是可以跳转到任意打开过的界面比如从3-&gt;1，而不是只能返回上级界面从2-&gt;1。 一般跳出方法也可以使用代码根据是model类型还是push类型选择： 1234//弹出一个viewcontroller 相当与返回上一个界面[self.navigationController popViewControllerAnimated:YES]; // 以 modal跳转的返回方法[self dismissViewControllerAnimated:YES]; 跳转的方式在进行跳转连线后会出现如下窗口：共有三种跳转方式，也就是上面右边栏的Kind属性 pushPush类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。 model最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的Presentation选择需要展示的动画效果。 custom自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。这段代码的作用是创建从中心渐变充满屏幕的动画: 12345678910111213141516-(void)perform&#123; UIViewController * svc = self.sourceViewController; UIViewController * dvc = self.destinationViewController; [svc.view addSubview:dvc.view]; [dvc.view setFrame:svc.view.frame]; [dvc.view setTransform:CGAffineTransformMakeScale(0.5, 0.5)]; [dvc.view setAlpha:0.0]; [UIView animateWithDuration:1.0 animations:^&#123; [dvc.view setTransform:CGAffineTransformMakeScale(1.0, 1.0)]; [dvc.view setAlpha:1.0]; &#125; completion:^(BOOL finished) &#123; [svc presentViewController:dvc animated:NO completion:nil]; &#125;];&#125; 其实实质还是presentViewController，但是不用系统带的animation，而是先将destinationViewController的页面用动画加载后，直接present。 跳转传值前面说到，- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender方法会在跳转时自动触发。跳转传值就在这个方法内完成。 我们可以对Segue的标识进行判断，一般有以下两种方法： 123456- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; if ([segue.identifier isEqual: @"login2index"]) &#123; // 需要执行的代码 &#125;&#125; 123456- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; if ([segue.destinationViewController isKindOfClass:[IndexTableViewController class]]) &#123; // 执行代码 &#125;&#125; 第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。 接下来就可以对destination进行赋值了： 12345678910111213- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&#123; NSLog(@"触发该场景切换的sender对象的类型是:%@",[sender class]); //方法一,使用KVC给B 也就是目标场景传值 UIViewController *destinationController=[segue destinationViewController]; [destinationController setValue:@"119" forKey:@"number"]; //方法2,使用属性传值,需导入相关的类.h //BViewController *bController=[segue destinationViewController]; //bController.number=@188;&#125; 跳转传值不仅可以用prepareForSegue:sender:实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见使用storyboard实现页面跳转，简单的数据传递 storyboard referenceiOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。 简化现有storyboard如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。 做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor-&gt;Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。 加载storyboard中一个特定viewController和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上： 然后设置storyboard：这里面storyboard填的是目标storboard的文件名；Reference ID是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的Storyboard ID，具体在哪设，上面也说过。 这样，一个简洁的storyboard就能创建出来了。 参考链接【Storyboard】Storyboard介绍及使用 UIStoryboardSegue讲解; iOS-prepareForSegue场景切换,KVC传值; (4.4.1)使用storyboard实现页面跳转，简单的数据传递; 【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递 iOS9 Day-by-Day :: Day 3 :: Storyboard References; 基于Storyboard的创建多分支NavigationController的方法; iOS 9 Storyboard 教程(一下); 10 Practical Tips for iOS Developers Using Storyboards; 还有一些看完随手就关了，没有记录。 水平有限，如有错误，多多指正~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oc 中的泛型与nullability]]></title>
    <url>%2F2016%2F09%2F28%2Foc%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[oc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合Objective—C语言的新魅力——Nullability、泛型集合与类型延拓对oc的这些新特性进行研究。 Nullability检测的支持可以使用nullable关键字，表明该对象可以是空值;使用nonnull关键字表明不可以是空对象。 12@property (nullable, nonatomic, strong) ObjectType firstObject;@property (nullable, nonatomic, strong) ObjectType lastObject; 这是NSArray中的两个属性，其中nullable关键字说明了这里可能返回空的值。 如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如： 123-(void)setValue:(NSNumber * _Nonnull )number&#123; &#125; 如果传入了空值，编译器会警告： 泛型的使用这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。 有类型约定的集合在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下： 1NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; 声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如： 在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来: 如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告： 类型通配符iOS的系统类中，大量使用了ObjectType关键字，如下是系统的NSMutableArray的头文件： 12345678910@interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt;- (void)addObject:(ObjectType)anObject;- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;- (void)removeLastObject;- (void)removeObjectAtIndex:(NSUInteger)index;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@end 这个ObjectType就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray： 1234@interface MyArray&lt;Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 实现如下： 1234567891011- (instancetype)init&#123; self = [super init]; if (self) &#123; _array = [[NSMutableArray alloc]init]; &#125; return self;&#125;- (void)addObject:(id)obj&#123; [_array addObject:obj];&#125; 注意： 这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。 实现时，对于定义的Type类型的参数，使用id代替。 泛型Type不用写成Type *。 对于多参的集合，将参数类型用“,”隔开即可，如NSMultableDictionary&lt;NSString * ,NSString *&gt; *dic = [[NSMultableDictionary alloc] init]; 泛型和协议声明泛型和协议都是用尖括号括起来的，可能会很困扰，编译器如何知道哪个是泛型哪个是协议。其实它们是有规则的。简单看一下例子： 123456@protocol proc@end// .h@interface Test&lt;ObjectClass&gt; : NSObject&lt;Proc&gt;@property (nonatomic,strong) ObjectClass param;@end 我们看到，所有的类都是要有一个基类，所以泛型的尖括号是在基类之前的，基类之后可以写上协议，使用的时候就可以 Test&lt;SomeType *&gt; test 这样用啦。那如果基类也有泛型需要声明呢？比如 NSMutableArray: 1@interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt; 类似于这种的泛型，我们就不能直接申明协议了。但是我们可以变通一下，可以为这个类创建一个分类，在分类中声明协议啊。 另外还有一点，协议中是不能使用泛型的，如果实在想用，拥抱 Swift 吧。 使用使用的时候一般情况下都是表示泛型，比如： 1Test&lt;NSString *&gt; test = [[Test alloc] init]; 但是也有表示协议的，不过局限在 id 类型，比如： 1id&lt;SomeProtocol&gt; prop; 表示任意一个实现了某个协议的类型。 __kindof在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如UIView的实例view和UIButton的实例button,可以view = button，但是最好不要button = view。如果想要使用，又不希望产生警告怎么办？使用__kindof。123UIButton *b = [[UIButton alloc] init];__kindof UIView *view = [[UIButton alloc]init];b = view; 这里，由于view使用__kindof表示UIView的子类，不会产生警告。否则要进行强转b = (UIButton *)view;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发工具应用中的坑]]></title>
    <url>%2F2016%2F09%2F23%2FXcode%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这里主要总结一下开发 iOS 使用工具上遇到的一些问题。 如何为一个 workspace 中的多个 project 使用 cocoapods一般一个 app 只有一个 project（也可以有多个，其实 project 不是关键，它只是包含了一些配置信息，真正起作用的是 target，project 只是 target 的容器，有相互依赖关系的是 target），在这个 project 中可以有多个 target 比如 Myapp、Myapptest 等，如下图： 这些 target 可以相互依赖，也可以依赖许多子 target，需要在 Target Dependencied 中注册： 那么如何为多个 project 中的各个 target 集成 pod 呢？就像上面说的 project 不重要，我们只要在设置target 的时候，引入 project 的路径即可： 1234567891011121314151617181920212223242526272829303132333435# 指定 workspace # 指定后不会生成默认的 workspace 文件workspace 'TheApp.xcworkspace'# 指定 xcodeprojxcodeproj 'TheApp.xcodeproj'# cocoapods 会用在 swift 项目use_frameworks!# 指定 targettarget 'aProject' do # 由于 Podfile 和 .xcodeproj 不在同一文件夹下 # 需要指定路径 # xcode 项目可以存在任何的子路路径中，只需要指定正确的路径就可以 project ‘aProject/aProject.xcodeproj’ # 在每一个 project 下都导入 SnapKit 进行测试 pod "SnapKit"endtarget 'bProject' do project 'bProject/bProject.xcodeproj’ pod "SnapKit"endtarget 'aFramework' do project ‘aFramework/aFramework.xcodeproj’ pod "SnapKit"endtarget 'bFramework' do project ‘bFramework/bFramework.xcodeproj’ pod "SnapKit"end 可以看到，对于不同 project 中的 target，只要指定其与 Podfile 的相对位置就可以了。 假如 target aProject 下还有其他子 target，这些子 target 是可以直接引用父 target 引入的 SnapKit 组件的。 CocoaPods 使用 iOS 如何在一个存在多个project的workspace中引入cocoapods管理第三方类库 安装 XVim慕名下载了XVim，但是安装起来有点曲折。 现在统一使用 XVim2 了 注意，创建自签名证书的时候要选对证书类型，要选为”代码签名” 创建好自签名证书后，要对 Xcode 进行重新签名： 1$ sudo codesign -f -s zachary /Applications/Xcode.app 每次更新 Xcode 后，都要先对 Xcode 进行重新签名！ 这个要等一段蛮长一段时间，这段时间可以先把代码码起来。 重新签名后，就可以在 clone 下来的 XVim 文件夹下编译了，需要 cd XVim/： 1$ make 至于安装指南上的这个指令，其实不用太在意: 1$ xcode-select -p 这个指令主要是看看 Xcode 的版本是否指定在 /Applications/Xcode.app/Contents/Developer 目录下，不是的话要手动指定。 重启xcode，会提示是否使用Xvim，选择load就OK了。 使用除了Vim自身的命令外,XVim还有几个Xcode命令: 附带Vim使用详解： Podfile.lock在协同开发时，经常会遇到，Podfile.lock 不一致，导致编译失败，需要重新 pod install 的情况。这里将简单介绍下 Podfile.lock Podfile.lock的作用Podfile.lockPodfile.lock 是在第一次运行 pod install 时候自动生成的。Podfile.lock 中会标注项目当前依赖库的准确版本，其中包括了项目在 Podfile 中直接标注使用的库，以及这些库依赖的其他库。这样的好处是当你跟小伙伴协同开发时，你的小伙伴同步了你的 Podfile.lock 文件后，他执行 pod install 会安装 Podfile.lock 指定版本的依赖库，这样就可以防止大家的依赖库不一致而造成问题。因此，CocoaPods 官方强烈推荐把 Podfile.lock 纳入版本控制之下。 但是，Podfile.lock 并不是一成不变的，当你修改了 Podfile 文件里使用的依赖库或者运行 pod update 命令时，就会生成新的 Podfile.lock 文件。所以，协同开发时需要注意使用 pod install 和 pod update 的区别: 使用 pod install，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。 使用 pod update，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件。 Manifest.lock那么是如何知道拉取的 Podfile.lock 和 Pod 内，库的版本不一致的呢？在每次生成 Podfile.lock 的时候，都会在 Pod内生成一个 Podfile.lock 的副本Manifest.lock。由于 Pod 一般不会上传版本控制，Manifest.lock 就代表了本地的 Pod 版本。如果拉取了别人的 Podfile.lock，那么 Podfile.lock 和 Manifest.lock 就会产生不一致，就会导致编译失败。 目的有了这个检查机制就能保证开发团队的各个小伙伴能在运行项目前更新他们的依赖库，并保持这些依赖库的版本一致，从而防止在依赖库的版本不统一造成程序在一些不明显的地方编译失败或运行崩溃。 Podfile.lock 不同的可能原因有时可能 Podfile 是相同的，但是你们的 Podfile.lock 还会不同。下面 Podfile.lock 的引号问题就是其中之一。 除了 gem，ruby等库的版本不同导致之外，还有可能是因为本地的 Podspec 文件不同导致的。所有的项目的 Podspec 文件都托管在 https://github.com/CocoaPods/Specs。第一次执行时，CocoaPods 会将这些 podspec 索引文件更新到本地的 ~/.cocoapods/ 目录下。如果长时间不更新 podspec，那么所要下载的直接依赖库或间接依赖库的最新版本可能发生了变化，就会导致安装了不一样的依赖版本，那么 Podfile.lock 的记录就不一样了。建议可以执行 pod repo update 更新一下 spec repo(一般情况下，执行 pod install 时会先自动更新 spec 的，除非向上面说的使用 pod install --no-repo-update，当然，现在只是记录下可能导致 Podfile.lock 不一致的原因，万一真的发生了呢？) Podfile.lock 的引号问题最近在协作的时候遇到了这样的问题，我的 pod lock 总是和同事的不一致，差别在于是否有引号。这就导致了每次拉取别人的代码我都要 pod install 一遍，别人也是一样。 查了一些资料Inconsistent Podfile.lock files between Ruby versions,Strange quotes in Podfile.lock?! 发现大致是因为 gem 的一个 YAML 解析工具 psych 版本不同导致的。所以，解决问题的关键不是更新 cocoapods 而是更新 psych (更新 psych 前，先把 ruby，gem也先更新了，以防有什么差错). 注释方法和属性的快捷注释在 Xcode8 之前，想要一键为属性和方法注释都需要通过插件完成。现在 Xcode8 中有了内置的注释方式： alt+command+/，只要将光标移动到想要注释的方法上，就会自动识别方法的参数和返回值，提供注释模板，非常方便。 Xcode断点调试值都为nil的问题在Build Settings中 Optimization Level 设置成 None： #pragma mark好的习惯从#pragma mark开始。就像这样： 1234567891011121314151617181920212223242526272829@implementation ViewController- (id)init &#123; ...&#125;#pragma mark - UIViewController- (void)viewDidLoad &#123; ...&#125;#pragma mark - IBAction- (IBAction)cancel:(id)sender &#123; ...&#125;#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; ...&#125;#pragma mark - UITableViewDelegate- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; ...&#125; 在你的 @implementation 中使用 #pragma mark 来将代码分割成逻辑区块。这些逻辑区块不仅仅使得阅读代码本身容易许多，也为Xcode源导航增加了视觉线索（#pragma mark 声明前有一个水平分割并由破折号（－）开始）。 Xcode 并排查看代码如果想要单纯分为左右两屏，按住 alt 再点击文件，即可在辅助窗口查看。 可以点击副主窗口右上角的 “+”，添加更多辅助窗口，此时按住 alt 就会让你选择在哪个辅助窗口查看文件代码。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>爬坑</tag>
        <tag>Cocoapods</tag>
        <tag>Vim</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lldb 调试方法]]></title>
    <url>%2F2016%2F09%2F21%2Flldb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章与调试器共舞 - LLDB 的华尔兹这篇文章帮助最大。 Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。 LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种： 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序 不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。 expressionexpression的几个命令是最常用的，能提升debug效率的命令。 print打印一个对象:可以直接缩写p达到同样的效果。 结果中有个$0，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以$开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如： expression使用如果想要改变一个值，或者执行一个方法。可以使用expression或者e： print其实是特殊的expression，比如p count =18其结果和expression count = 18结果一样。事实上，print是 expression -- 的缩写。 应用由于expression可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：1234// 改变颜色(lldb) expression self.view.backgroundColor = [UIColor redColor]// 刷新界面(lldb) expression [CATransaction flush] 不只是改变颜色，frame，animation等都能改变，非常有用。 如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。 poprint输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：123(lldb) p @[ @"foo", @"bar" ](NSArray *) $8 = 0x00007fdb9b71b3e0 @"2 objects" 这个时候可以使用po(print object 的缩写)，相当于调用对象的description方法。1234567(lldb) po $8&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(foo,bar)(lldb) po @"lunar"lunar threadbt可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame: thread return这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。 它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。 比如下图所示：正常通过isOdd方法，一定是return NO的，但是通过(lldb) thread return YES，跳过了isOdd方法里的方法块，直接return YES 正如上面所述，必须要在断点进行到如图所示的地方才可以使用thread return，因为: 此时当前栈帧是isOdd 不会造成引用问题 breakpoint断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧. 流程控制当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:意义都很明确，不多说了，列举下对应的命令： continue按钮 =&gt; continue,缩写c step over按钮 =&gt; next，缩写n step in按钮 =&gt; step,缩写s step out按钮 =&gt; finish 设置断点在断点处右击，选择Edit Breakpoint弹出如下设置框： 蓝色的勾表示enable和disable断点。 Condition指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法）。 Ignore忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。 Action它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的： Debugger Command：默认的选项，可以让断点执行LLDB调试命令。 Log Message：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用@exp@形式。 Options一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。 断点类型异常断点异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图： 符号断点他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框: 它比普通断点的自定义设置界面多出了两个内容 Symbol：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如: 12-[MyViewController viewDidAppear:]+[MyViewController sharedInstance] Module：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。 需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。 watchpoint一般情况下可以在属性的 set 方法中添加断点，这样就能监控属性的设置。但是有时候，由于不涉及到方法，而是直接操作内存，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用watchpoint来监视。 当指针指向变化时，watchpoint会触发: set添加watchpoint的方式如上图所示1(lldb) watchpoint set variable xxx 注意，貌似不能用 self-&gt;xxx 的形式，而要直接用 _xxx 的形式，否则一直都是下面的错误： watchpoint 不只是监听指针变化，还能监听变量变化。只要该指针或变量进行了赋值，无论是否改变了值，都会使 watchpoint 命中。 disable/delete/enablewatchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可： 其他技巧run这是我比较喜欢的方法，所以单独列出来。 调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入run就能直接让程序重新加载了。 代替NSLog看NSLog的文档，第一句话就说：Logs an error message to the Apple System Log facility.，所以首先，NSLog就不是设计作为普通的debug log的，而是error log；每次NSLog都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView详细介绍]]></title>
    <url>%2F2016%2F09%2F18%2FScrollview%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本次将参考iOS 性能优化之 UIScrollView 实践经验对UIScrollView的使用方式进行详细介绍 ScrollView和Auto LayoutUIScrollView 在 Auto Layout 是一个很特殊的 view，对于 UIScrollView 的 subview 来说，它的 leading/trailing/top/bottom space 是相对于 UIScrollView的 contentSize 而不是 bounds (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。 所以，一般的做法是在UIScrollVIew和它的subViews之间增加一个content view。这样可以方便地给 subview 提供 leading/trailing/top/bottom，方便 subview 的布局，并且可以 通过调整content view 的 size（调整constraint 的 IBOutlet）来调整 contentSize。 添加ContentView的注意点scrollview中添加的contentview和添加一般的视图不同，一般的视图只要提供leading/trailing/top/bottom space就能唯一确定长宽，位置。而ScrollView的contentView除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。 所以整个scrollview的contentSize的等式应该是：1scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant） 另外一点需要强调两点： ScrollView的bounds早就确定了下来，在设置contentview的宽度的时候，如果设置contentview.width = superview.width + constant这里的superview.width是指ScrollView.bounds而不是contentSize 在设置contentview的上下左右约束的时候，如果设置contentview.trailing = superview.trailing + constant,这里的superview.trailing指的是contentSize.trailing而不是bounds。此时就可以通过上面的公式计算contentSize的宽度了。 Demo参见AutoLayout UIScrollView部分属性contentSize、contentInset和contentOffset contentSize: 就是scrollview可以滚动的区域.比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。 contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 / 上拉刷新一般实现代码如下 /123456789- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView]; float offset=scrollView.contentOffset.y; float contentHeight=scrollView.contentSize.height; float sub=contentHeight-offset; if ((scrollView.height-sub)&gt;20) &#123;//如果上拉距离超过20p，则加载更多数据 //[self loadMoreData];//此处在view底部加载更多数据 &#125; &#125; UIScrollViewDelegateUIScrollViewDelegate 是 UIScrollView 的 delegate protocol，UIScrollView 有意思的功能都是通过它的 delegate 方法实现的。 - (void)scrollViewDidScroll:(UIScrollView *)scrollView这个方法在任何方式触发 contentOffset 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。 - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView用户开始拖动 scroll view 的时候被调用。 - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，减速直到 targetContentOffset。值得注意的是，这里的 targetContentOffset 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。 - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate在用户结束拖动后被调用，decelerate 为 YES 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，所以这个 dragging 属性的实际语义更接近 scrolling。 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView减速动画开始前被调用。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView减速动画结束时被调用。 这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。 Demo参见Delegate 实例Table View 中图片加载逻辑的优化优化目的：滑动时不加载图片，在滑动停止时加载图片 优化难点：前面提到，刚开始拖动的时候，dragging 为 YES，decelerating 为 NO；decelerate 过程中，dragging 和 decelerating 都为 YES；decelerate 未结束时开始下一次拖动，dragging 和 decelerating 依然都为 YES。所以无法简单通过 table view 的 dragging 和 decelerating 判断是在用户拖动还是减速过程。 所以不能仅通过decelerating来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看原文比较好） 优化方法： 每次开始拖动时scrollViewWillBeginDragging，通过NSArray *cells = [self.tableView visibleCells];获取屏幕上所有显示的Cell，全部加载一遍图片（解决问题三） 利用scrollViewWillEndDragging: withVelocity: targetContentOffset:方法，将targetContentOffset即最后减速结束后在屏幕上显示的位置，转换为一个CGRect，在CGRect范围里的Cell才在CellForRowAtIndex中加载。 Demo详见LazyLoad 分页的几种实现方法分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。 pagingEnabled系统提供的分页方式，实现简单，只需要_scrollView.pagingEnabled = YES即可，但是有局限性： 只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。 需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容） Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是： 让 scroll view 的宽度为 page 宽度 + padding，并且设置 clipsToBounds 为 NO,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图: 这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能 适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。 Snap核心算法是在 didEndDragging 方法中，通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。 修改targetContentOffset通过修改 scrollViewWillEndDragging: withVelocity: targetContentOffset: 方法中的 targetContentOffset 直接修改目标 offset 为整数页位置。其中核心代码：123456789- (CGPoint)nearestTargetOffsetForOffset:(CGPoint)offset&#123; CGFloat pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING; NSInteger page = roundf(offset.x / pageSize); CGFloat targetX = pageSize * page; return CGPointMake(targetX, offset.y);&#125;- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; CGPoint targetOffset = [self nearestTargetOffsetForOffset:*targetContentOffset]; targetContentOffset-&gt;x = targetOffset.x; targetContentOffset-&gt;y = targetOffset.y;&#125; 适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。 Demo详见Pagination UIPageControl首先声明这个和 ScrollView 如何设置分页没有关系。这个组件是 iOS 在分页中经常用的表示页数的小白点。简单记录一下怎么使用。 使用起来其实蛮简单的，就当一个 View 来使用就行了： 123456_pageControl = [[UIPageControl alloc]initWithFrame:CGRectMake(SCREEN_WIDTH/2-75, SCREEN_HEIGHT-30-20, 150, 20)];_pageControl.numberOfPages = 3;_pageControl.currentPage = 0;_pageControl.pageIndicatorTintColor = [UIColor colorWithHexString:@"E1E1E1"];_pageControl.currentPageIndicatorTintColor = COLOR_MAINRED;[self.view addSubview:_pageControl]; 几个属性也比较易懂，基本上就设置好了，当然这里还没有设置和 Scrollview 的联动： 12345//监听scrollView滚动事件- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; int page = scrollView.contentOffset.x / SCREEN_WIDTH; _pageControl.currentPage = page;&#125; 监听 Scrollview 的滚动事件就可以了。 重用大部分的 iOS 开发应该都清楚 UITableView 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，UIScrollView 作为 UITableView 的父类，在很多场景中也很适合应用重用机制。 可以参照 UITableView 的 cell 重用机制，总结重用机制如下： 维护一个重用队列 当元素离开可见范围时，removeFromSuperview 并加入重用队列（enqueue） 当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除 如果队列为空，新建元素 将新建元素的view通过addSubView添加至 contentView上 这些一般都在 scrollViewDidScroll: 方法中完成 Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo 这里要说明一下Demo中用到的addChildViewController。 苹果在iOS 5 添加了一系列的方法，希望我们在使用addSubView时，同时调用[self addChildViewController:child]方法将sub view对应的viewController也加到当前ViewController的管理中。 对于那些当前暂时不需要显示的subview，只通过addChildViewController把subViewController加进去；需要显示时再调用transitionFromViewController方法。将其添加进入底层的ViewController中。 这样做的好处： 对页面中的逻辑更加分明了。相应的View对应相应的ViewController。 当某个子View没有显示时，将不会被Load，减少了内存的使用。 当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。 可以调用transitionFromViewController等系统方法，ios对于显示以及动画做了比较好的封装 相当于对于 ViewController 实例的保存。实例都保存在self.childViewControllers中，需要使用的时候从中取出即可。 当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。 其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候[self.contentView addSubview:vc.view];,不需要显示的时候[vc.view removeFromSuperview];，就可以达到显示和相应事件的需求了。 Demo详见Reuse 联动所谓联动，就是当 A 滚动的时候，在 scrollViewDidScroll: 里根据 A 的 contentOffset 动态计算 B 的 contentOffset 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。 Demo中的核心代码:12345678910- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView == self.titleScrollView) &#123; CGFloat contentX = self.titleScrollView.contentOffset.x / self.titleScrollView.frame.size.width * self.contentScrollView.frame.size.width; self.contentScrollView.contentOffset = CGPointMake(contentX, 0.0); CGFloat transX = self.titleScrollView.contentOffset.x / (self.titleScrollView.contentSize.width - self.titleScrollView.frame.size.width) * (self.backgroundImage.frame.size.width - self.view.frame.size.width); transX = MAX(0.0, transX); transX = MIN(self.backgroundImage.frame.size.width - self.view.frame.size.width, transX); self.backgroundImage.transform = CGAffineTransformMakeTranslation(-transX, 0.0); &#125;&#125; 通过titleScrollView计算contentX和transX来分别控制contentScrollView以及backgroundImage这两个View的位置变化。 Demo参见Parallax 总结ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用. 上述所有Demo均在UIScrollViewDemo文件夹中]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSNotification的使用]]></title>
    <url>%2F2016%2F09%2F13%2FNSNotification%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇是对ios的通知使用方法的一个简单罗列。 NSNotificationCenterNSNotificationCenter就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个NSNotificationCenter，让我们可以很方便的进行通知的注册和移除。 注册addObserver:selector:name:object:1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@"test" object:nil]; 参数： addObserver:貌似都是controller因为还需要selector来执行 name:通知名。当发送该通知名的通知是，观察者收到消息。 object:缩小接受通知的范围，只接受相对应的object对象发来的通知。nil则全部接收。 addObserverForName:object:queue:usingBlock:NSNotificationCenter消息的接受线程是基于发送消息的线程的,也就是同步的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。1id observer = [[NSNotificationCenter defaultCenter] addObserverForName:notification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note)&#123;...&#125;]; 参数： queue:block执行所在的线程。如果是nil那么就在当前线程(posting thread) block:该种方式不用selector而使用block回调。 删除只要往NSNotificationCenter注册了，就必须有remove的存在。 removeObserver:1- (void)removeObserver:(id)notificationObserver 对应addObserverForName方式，直接把上面的id observer作为参数传入即可。对应addObserver方式，删除controller中全部通知. removeObserver:name:object:1[[NSNotificationCenter defaultCenter] removeObserver:self name:NotificationCitySelect object:nil] 删除指定name的通知。 发送有三种发送方式： 123- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 其中 aUserInfo 是发送的通知需要传递给接受者的信息。那么这个信息怎么取得呢？我们看一下 NSNotification 的数据结构： 12345@interface NSNotification : NSObject @property (readonly, copy) NSNotificationName name;@property (nullable, readonly, retain) id object;@property (nullable, readonly, copy) NSDictionary *userInfo; 上面 addObserver 的时候，无论是用 selector 还是 block，都将 NSNotification 实例传入了，可以直接获取 userInfo 信息。 1[[NSNotificationCenter defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(YES)&#125;] 发送指定objcet的通知，只有注册时注册了该对象的通知才可以接收（即注册的时候的 object 要写的和这里的一样。name 和 object 都是用来取区分通知的）。 关于 Notification 在哪设置Notification 最好在 viewDidAppear 中注册，在 viewDidDisappear 中移除，即在页面显示的时候接收通知。实在需要页面不显示的时候也能接到通知的话就只能在 init 和 dealloc 中做添加删除了（dealloc 中 remove 不会造成内存泄漏，Notification 中的 Observer 不是 strong，所以不会让引用+1，但是必须 remove 不然会产生野指针导致崩溃）由于 viewDidAppear 和 viewDidDisappear 不是成对出现的，需要在 viewDidAppear 注册通知前先移除一下该通知。 通过手势操作 VC 可以让 viewDidAppear 调用无数次，但 viewDidDisappear 一次也不触发。 NSNotificationCenter的实现NSNotificationCenter 的实现原理是观察者模式，用于监听操作。我们可以简单地认为 NSNotificationCenter 就是维护一个 NSMutableDictionary，key 是由 name 和 sender 生成的 notification object，比如 NSNotification，value 是向 observer 发送的 selector。发送通知就是在字典中找到相应方法执行。 这就解释了为什么一定要在对象回收时 removeObserver。因为在 notificationCenter 中，对象都是弱引用的。当对象回收后，notificationCenter 中保存的引用就会置为 nil，就会发生通知发向一个 nil 类的情况，导致 App 崩溃。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSNotification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UILabel高度控制]]></title>
    <url>%2F2016%2F09%2F12%2FUILabel%E7%9A%84%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[在tableview自适应高度一篇中学习了如何用systemLayoutSizeFittingSize:方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。 sizeThatFits的使用sizeThatFits是UIView中的方法：1- (CGSize)sizeThatFits:(CGSize)size; 官方文档的注释： return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size也就是说，该方法将会根据传入的size,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。 UILabel会根据传入的size的width自动换行，得到height后，将这两个值作为估算出的CGSize返回。如果传入的是CGSizeZero相当于不设置换行宽度，一行到底。 由于SizeThatFits只估算，不修改。在得到估算值后，需要手动设置UILabel的frame或者constraint：1234567891011- (void) useSizeThatFitsZeroWithLabel:(UILabel *)label&#123; //使用CGSizeZero相当于不设置换行宽度，一行到底 CGSize size = [label sizeThatFits:CGSizeZero]; label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);&#125;- (void) useSizeThatFitsCustomWithLabel:(UILabel *)label&#123; //使用自定义的CGSize，会根据size的宽度进行换行 CGSize size = [label sizeThatFits:CGSizeMake(50, 50)]; label.frame = CGRectMake(label.frame.origin.x, label.frame.origin.y, size.width, size.height);&#125; SizeToFitSizeToFit的方法：1- (void)sizeToFit; SizeToFit的文档注释： calls sizeThatFits: with current view bounds and changes bounds size.也就是说，它会调用SizeThatFits,并且直接设置View的bounds。 既然要调用sizeThatFits那就需要传入一个CGSize。这个CGSize就是设置View的frame时传入的height,width。 boundingRectWithSizeboundingRectWithSize 其实和上面的方法差不多，但是前面的方法需要拿到 label 的实例。下面这个方法则是通过 String 直接计算的： 1234NSString *text = @"Today is a fine day";UIFont *font = [UIFont systemFontOfSize:30];CGRect suggestedRect = [text boundingRectWithSize:CGSizeMake(800, MAXFLOAT) options:NSStringDrawingUsesFontLeading attributes:@&#123; NSFontAttributeName : font &#125; context:nil];NSLog(@"size = %@", NSStringFromCGSize(suggestedRect.size));]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本语法]]></title>
    <url>%2F2016%2F09%2F09%2FJavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JS 的语法，参考了廖雪峰的博客以及阮一峰的ES6 基础语法数据类型和变量NumberJS不区分整数浮点数，统一用Number表示：1231.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接运算：12345(1 + 2) * 5 / 2; // 7.52 / 0; // Infinity0 / 0; // NaN10 % 3; // 1 (取余)10.5 % 3; // 1.5 字符串以单引号&#39;或双引号&quot;括起来的任意文本.如&#39;abc&#39; 布尔值用true和false表示。 比较运算符JavaScript在设计时，有两种比较运算符：第一种是==比较，它会自动转换数据类型再比较.第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 如果是比较类对象，就是比较两者的地址。如果地址不同，== 和 === 都返回 false。 NaN这个特殊的Number与所有其他值都不相等，包括它自己：12NaN == NaN; // falseNaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数：1isNaN(NaN); // true 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 数组JavaScript的数组可以包括任意数据类型。例如：1[1, 2, 3.14, 'Hello', null, true]; 另一种创建数组的方法是通过Array()函数实现：1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。索引的起始值为0：1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 对象JavaScript的对象是一组由键-值组成的无序集合，例如：12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。 要获取一个对象的属性，可以用一下两种方式：1234567person.name; // 'Bob'person.zipcode; // nullfunction getName() &#123; return 'name'&#125;person[getName()] 变量与常量ES6 之前，变量用 var 修饰，但是会引起问题，包括作用域问题与变量提升问题。使用 let 代替。1let b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1 ES6 之后，常量用 const 修饰，表示不会再改变的值： 1const b = '234' Swift 中变量为 var 常量为 let 略有不同。 字符串模板字符串要把多个字符串连接起来，可以用+号连接：1234var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 注意这里不只是 ${} 外边的不再是单引号了，而是 ` `。 在 Swift 中有类似的模板字符串：\(要打印的对象)，类似于这里的${}。不过 Swift 写起来比这个好简单好记多了。 操作字符串字符串常见的操作如下：1234var s = 'Hello, world!';s.length; // 13s[7]; // 'w's[12]; // '!' 字符串相当于是一个不能改变的数组。 indexOfindexOf()会搜索指定字符串出现的位置:123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 substringsubstring()返回指定索引区间的子串：123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 数组展开运算符展开运算符使用 ... 将一个数组转为用逗号分隔的参数序列： 123console.log(1, ...[2, 3, 4], 5)// 相当于 =&gt;// console.log(1, 2, 3, 4, 5) length要取得Array的长度，直接访问length属性：12var arr = [1, 2, 3.14, 'Hello', null, true];arr.length; // 6 indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 万能方法 splice为数组添加和删除元素有很多方法，包括 push，pop，unshift，shift，slice，concat。这些都可以使用 splice 代替： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] 第一个元素是起始索引(从0开始)，第二个参数是删除元素个数。后面的参数是要添加的元素。 joinjoin 方法是一个非常实用的方法，用于当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 数组的高阶函数mapmap()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： 123456function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] map()将传入的函数一一作用在数组的每一个元素上。 reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比如对Array求和： 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 filter用于把Array的某些元素过滤掉，然后返回剩下的元素Array的filter()接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写： 12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] sort可以接收一个比较函数来实现自定义的排序要按数字大小排序，我们可以这么写： 12345678910var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20] 注意：sort()方法会直接对Array进行修改，它返回的结果仍是当前Array 对象基本使用现在 ES6 中有了 class，我觉得现在对象更像是结构体。 定义方式如下： 123var xiaohong = &#123; name: '小红',&#125;; 获取分为两种形式，点语法和[]语法：12xiaohong.name; // '小红'xiaohong['name']; // '小红' 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符，自己的和继承的都会返回 true：12'name' in xiaoming; // true'toString' in xiaoming; // true 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 对象的属性名属性名为方法返回值JS 中属性必须要是字符串型的，不过你也可以使用方法的返回值动态的设置属性名： 123456789101112131415const Birth = &#123; birth: 'birth'&#125;const Person = &#123; name: '张三', //等同于birth: birth [Birth.birth]: '94-4-15', // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 属性的简写ES6 中允许创建对象的时候，简写属性，直接以变量名称作为属性名。比如： 12345678910111213let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; prototype在 ES6 之前，没有类的概念，只有一个个函数，通过 prototype实现。 prototype 是函数的属性，这个属性是指向一个对象的引用，这个对象称为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作构造函数调用（使用new操作符调用）的时候，新创建的对象会从原型对象上继承属性和方法。 所以，如果我们想要 new 出来的对象能够使用的属性或者方法，就将它们赋给 prototype。 另一方面，有一些属性和方法应该是属于类的，ES6 中用 static 标识，ES6 之前则直接将其赋值给函数，它会被加载到 constructor 中。constructor 本身也是 prototype 的一个默认属性。具体例子如下： new Person() 后的实例对象，都可以获得 prototype 上的属性，但是其中一个对象改变其值的时候，另一个对象相应属性值不变。 prototype 中的属性能随着原型链被继承下去。 Object.assign()这个方法是非常有用的一个方法。用于为对象添加属性，方法，克隆对象，合并对象。第一个是目标对象，我们可以使用空对象，后面对象的属性会覆盖前面对象的属性： 1234567const target = &#123;&#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;b:2, c:3&#125; 这个和闭包一样，也是指针传递，生成的 target 对象或者源 source 对象，两者任一改动都会触发另外对象的改动。 除了方法是基本类型是值传递，对象类型是引用传递。其他都是指针传递。 （网上纠结的什么传递地址也是值传递，就当是扯淡吧，理解意思就行） Object.entries()返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组： 123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ ["foo", "bar"], ["baz", 42] ] 配合 for...of... 可以拿到所有键值。 可以用它来将对象转化为 Map JSON.stringify()一个对象你在打印log的时候，可能会给你返回 [object object]。此时，你需要将对象展开，可以使用 JSON.stringify() 方法。 Map和SetJS中默认对象表达方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。 MapMap 可以接受一个数组，数组元素是键值对的数组： 1234var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.delete('Adam'); // 删除key 'Adam'm.get('Michael'); // 95m.set('Zachary', 100); 这个结构是不是很熟悉？Object.entries() 返回的就是这样的数组中包含了键值对数组的形式。所以说，可以用 Object.entries() 创建 Map。因为直接把返回值作为参数传入 Map 即可。 对象可以变为 Map，但是 Map 不一定能变为对象。所以创建 Map 的时候的入参不能以对象的形式。 方法 size 属性返回 Map 结构的成员总数，类似数组的 length set(key, value)：设置键名key对应的键值为value，然后返回整个 Map 结构 get(key): 读取key对应的键值，如果找不到key，返回undefined。 has(key):返回一个布尔值，表示某个键是否在当前 Map 对象之中。 delete(key):delete方法删除某个键，返回true。如果删除失败，返回false。 clear():清除所有成员，没有返回值。 entries():返回所有成员的遍历器。配合 for...of... WeakMapWeakMap 的键是对象类型。如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 注意弱引用的是键，而不是值 Set重复元素在Set中自动被过滤：12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, "3"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 方法 add(value)：添加某个值。 delete(value)：删除某个值，返回一个布尔值 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员。 WeakSetWeakSet 中只能存对象。并且都是弱引用。 WeakSet 不能遍历。因为所有对象都是弱引用，随时可能消失。 iterableES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。iterable 类型其实就是 具有iterable类型的集合可以通过新的for ... of循环来遍历。用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array alert(x);&#125;for (var x of s) &#123; // 遍历Set alert(x);&#125;for (var x of m) &#123; // 遍历Map alert(x[0] + '=' + x[1]);&#125; for ... of循环和for ... in循环有何区别？for ... in实际上是对象的属性名称(注意，是键，不是值)。不要用在Array,Set,Map上，会出现奇怪的问题。for ... of循环则完全修复了这些问题，它只循环得到集合内该出现的元素(注意，是值，不是键)，例如：1234567891011121314var a = ['A', 'B', 'C'];a.name = 'Hello';a['4'] = 'D';console.log(a);for (var num of a)&#123; console.log(num)&#125;输出：[ 'A', 'B', 'C', , 'D', name: 'Hello' ]ABCundefinedD name由于不是正常Array该有的，所以在for ... of循环时，其对应的值不会被输出。 变量的解构赋值有两种解构赋值，分别为数组的解构赋值和对象的解构赋值 数组的解构赋值多出的部分为 undefined，可以使用展开运算符。 12let [a, b, c] = [1, 2]; // a = 1, b = 2, c = undefinedlet [x, ...y] = [1, 2, 3, 4]; // x = 1, y = [2, 3, 4] 解构赋值允许指定默认值，当对应的值为 undefined 时，等于默认值： 1let [x, y = 'b'] = ['a']; // x='a', y='b' 对象的解构赋值1let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 想要改变变量的名字也是可以的，上面其实等效于： 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 所以如果我们要改变变量名，可以这样： 12let &#123; foo: param1, bar: param2 &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;// param1 = aaa, param2 = bbb 对象也是可以指定默认值的： 123var &#123;x, y: z = 5&#125; = &#123;x: 1&#125;;x // 1z // 5 函数函数定义和调用定义函数方式一：1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 方式二：1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 Swift 中使用 func 定义函数 调用函数由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：12abs(10, 'blablabla'); // 返回10abs(-9, 'haha', 'hehe', null); // 返回9 传入的参数比定义的少也没有问题：1abs(); // 返回NaN 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查：12345678910function abs(x) &#123; if ((typeof x) !== 'number') &#123; throw 'Not a number'; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; rest参数由于JavaScript函数允许接收任意个参数，ES6标准引入了rest参数，可以将剩余的参数放在rest中，rest 是个数组（不是一定要叫 rest，任何名称都可以）：1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 其实相当于把 rest 展开，然后和入参对应 如果传入的参数连正常定义的参数都没填满，rest参数会接收一个空数组（注意不是undefined）。 参数默认值ES6 给 js 的函数提供了默认值： 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 带默认值的参数需要写在末尾。 特性name 属性函数的 name属性，返回函数的函数名： 12function foo() &#123;&#125;foo.name // "foo" 箭头函数ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 1x =&gt; x*x 相当于一个输入为x输出为x*x的匿名函数 123function (x) &#123; return x * x;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 语法糖，类似于python中的lambda函数 当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。试做比较： 123456789101112131415161718192021//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;;//箭头函数完全修复了this的指向，this总是和函数外部的 this 指代相同的东西：var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this 和 this.birth 指的是一个东西 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数,以前 var that = this; 以及 .apply() 和 .call() 这种写法就不需要了。 箭头函数并不创建它自身执行的上下文，使得 this 取决于它在定义时的外部函数。 箭头函数用在嵌套函数里，不能作为某一个属性的值，比如用成这样： 1234567&gt; var obj = &#123;&gt; birth: 1990,&gt; getAge: () =&gt; &#123;&gt; var b = this.birth; // this 是 undefined&gt; &#125;&gt; &#125;&gt; 这里并没有外部函数，所以箭头函数里的 this 永远是 undefined 装饰器利用apply()，我们可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：12345678910111213var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;;// 测试:parseInt('10');parseInt('20');parseInt('30');count; // 3 apply() 接收两个参数，第一个参数表示调用的对象，第二个参数是入参数组。此处的 arguments 表示的是外部 function 的入参，是 js 提供的一个参数。 闭包这是因为 JS 中的闭包对外部变量都是指针传递，而不是引用传递。。 iOS 中的闭包都是引用传递，外部变量相当于是以参数的形式传入的，也就是说，闭包内改变外部变量的值，外部变量不会变化。 js 中的闭包，相当于外部变量的地址都获得了。闭包内改变外部变量的值，外部变量的值相应改变。 PromiseES6 提供了原生的 Promise 对象。可以将异步操作以同步的形式表达出来。 基本用法123456789const promise = new Promise(function(resolve, reject) &#123; asyncFunc((success) =&gt; &#123; if (success)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;)&#125;); 如上所示，Promise 接受一个函数，入参为成功和失败回调，函数内执行异步操作，在必要时执行成功和失败回调。Promise 不需要返回值。 Promise 实例生成后，可以使用 then 方法指定 resolve 和 reject 的回调函数： 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise 的大致原理是通过 then 在 Promise 里注册回调，然后创建 Promise 时传入的函数会调用注册的回调函数。 注意，创建 Promise 的时候，函数就被执行了。但是执行到 resolve 或者 reject 方法时并不立刻执行，而是等到最后： 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 这是因为，Promise 将 then 注册的回调函数都包裹上了 setTimeout（resolved，0），将回调函数放置到 JS 任务队列末尾。 链式调用then()每一个 promise 就是一个异步调用。多个异步调用串行可以使用链式 .then() 的方式。 这个时候 then 方法向调用的 Promise 注入成功回调的时候需要返回一个新的 Promise 123456789101112131415new Promise((resolve, reject) =&gt; &#123; ...异步操作回调 &#123; let data = xxx resolve(data) &#125;&#125;.then((res) =&gt; &#123; return Promise((resolve, reject) =&gt; &#123; ...异步操作回调 &#123; let data = xxx resolve(data) &#125; &#125;)&#125;).then((res) =&gt; &#123; ...最终对 res 处理。&#125;) 并不是说 .then 返回一个 promise，使用者就必须要自己创建一个 promise。如果 .then 返回的是某个值 someObject，那么会被默认包装为一个 promise，并且立刻调用 resolve(someObject)，即执行后一个 .then 的而方法。 ###失败调用 catch() catch() 方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数： 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 注意，Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。也就是说，本例中，无论是 getJSON 还是 .then() 生成的 Promise 产生的错误都会被 catch() 捕获。 一般来说不要在 then() 方法中定义失败回调。总是使用 catch() 方法。 catch() 方法返回的还是 Promise 对象，会接着运行后面的 then() 方法。 永远执行 finally()1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 合并多个Promise all()Promise.all方法接受一个 Promise 数组，用于将多个 Promise 实例，包装成一个新的 Promise 实例： 123456const p = Promise.all([p1, p2, p3]);p.then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 合并多个Promise race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例： 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 async 函数async 函数式 Generator 函数的语法糖. async函数返回一个 Promise 对象，可以使用then方法添加回调函数。 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句: 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象不是说 stockPrice 是一个 Promise 而是说 async 修饰的这个方法最终返回一个 Promise，stockPrice 只是作为 resolve 的 input 而已。 如果确实希望多个请求并发执行，可以使用Promise.all方法: 1234567async function dbFuc(db) &#123; let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results);&#125; async 相当于告诉外界，这个方法会返回一个 promise await 必须在 async 中才能使用 await 后面的方法会延迟到 await 方法执行完后执行，相当于 then 操作 await 的错误捕获需要使用 try…catch 的方式 ProxyProxy 就如字面所说的，是 ES6 提供的代理模式的封装。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例: 1var proxy = new Proxy(target, handler); 第一个参数是被代理对象，第二个参数是要拦截的行为对象。当调用代理对象的被拦截行为时，触发代理方法。常用的拦截行为有以下几种： get(),set()1234567891011121314151617var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 其中，代理对象是 obj，被代理的对象是 {} 空对象，拦截的行为是 get，set 方法。也就是说，任何对于 obj 的读取写入操作都将执行代理方法。 get，set 方法的参数也很好理解。target 表示被代理对象，key 表示要进行读写操作的属性，value 就是写操作的值。receiver 就是代理对象 obj。（先不用关 Reflect）。 如果handler没有设置任何拦截，那就等同于直接通向原对象： 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // "b" apply()apply 方法拦截函数的调用、call和 apply 操作。可以接受三个参数：目标对象(函数）、目标对象上下文对象(this)、目标对象的参数数组。 123456789101112var twice = &#123; apply (target, context, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum (left, right) &#123; return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30 注意这里的 ...arguments 表示的是 target,context以及args的全部。 construct()construct 方法用于拦截 new 命令。接受两个参数：目标对象(类对象)，构建函数的参数对象。 1234567891011121314class A &#123; constructor() &#123; this.a = 1 &#125;&#125;let Aproxy = new Proxy(A, &#123; construct: function(target, args)&#123; return new target(...args) &#125;&#125;);let a = new Aproxy()console.log(a.a) //1 注意，拦截的是 new 命令，不是拦截的 constructor 命令，所以，拦截方法要返回一个 target 创建的新对象。 class基本用法创建和使用新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 如果用新的class关键字来编写Student，可以这样写：123456789101112class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.hello(); name 属性上面说到，函数有 name 属性，可以返回函数的名字。ES6 的 class 其实就是 ES5 函数的包装。所以 Class 也包含 name 属性： 12class Point &#123;&#125;Point.name // "Point" get set 方法在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为： 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' static 方法如果在一个方法前，加上static关键字，表示类方法: 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function ES6 明确规定，Class 内部只有静态方法，没有静态属性。 new.target 属性ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。需要注意的是，子类继承父类时，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的接口： 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 class继承用class定义对象的另一个巨大的好处是继承更方便了,直接通过extends来实现：12345678910class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 通过super(name)来调用父类的构造函数。PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 export 与 import基本用法123456export let name = 'zachary'export function getName() &#123; return 'zachary'&#125;等价于=&gt; export &#123;name, getName&#125; 注意，不能直接写export name,要写也要写成 export {name}。为什么呢？其实就相当于给 export 的对象起一个名字，export name 就相当于 export &#39;zachary&#39; ，这样别人就无法知道如何引入了，所以就需要起一个名字：export let name = &#39;zachary&#39; .引入方式如下： 1import &#123;name, getName&#125; from './myName' import 和 require 都不需要写 .js 后缀！！！ 重命名 as导出导入的名字有时候可能需要改变，所以提供了 as 这个关键字： 12export &#123;name as yourName, getName as getYourName&#125;import &#123;yourName as myName, getYourName as getMyName&#125; from './myName' 导出的时候用 yourName 作为内部 name 的别名。导入的时候用 myName 作为 youName 的别名。 default有时候，我们不需要知道导出的叫什么，可以使用 default ： 123456export default nameimport myName from './myName'相当于 =&gt;export &#123;name as default&#125;import &#123;default as myName&#125; from './myName' 其实就是 as 的语法糖。注意，import 的时候就不需要大括号了。 ES6 和 CommonJs 在引用方式的差异CommonJS的一个模块，就是一个脚本文件。require命令第一次执行的时候，加载该脚本，然后执行整个脚本 ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，直接执行相应的文件 require 的好处是可以在代码中使用，而 import 只能在头部。这样 require 就可以在执行到当前代码的时候，根据代码的上下文动态的引入想要的模块。 而 import 是强制静态化的 混用产生的问题export 和 module.exports 都是导出模块，但是最好不要在一个文件中一起使用。混用会产生一定的问题。 首先，ES6 的 export 在 webpack 打包后都会变成 CommonJS 的语法。因此 export 最终会变为 CommonJS 的 exports。当 exports 和 module.exports 同时存在的时候，最终导出的将会是 module.exports 的对象。exports 导出的对象会被覆盖。 这个结论非常重要。牢记这个结论在混用的时候就能明白为什么很多时候 import 的时候是 undefined 的了。 归类… 的使用场景… 一般用在数组前，把数组转为用逗号隔开的一个个值。可以正用逆用都是等价的： 12...[a, b, c] =&gt; a, b, ca, b, c =&gt; ...[a, b, c] 一般用于： 将数组拆开作为入参 将入参合并为数组 数组解构赋值 123456// 1. 做入参someFunc(1, ...[2, 3, 4]) =&gt; someFunc(1, 2, 3, 4)// 2. 合并入参function someFunc(1, ...args) &#123;&#125; =&gt; args = [2, 3, 4]// 3. 数组解构 类似于合并入参let [1, ...args] = [1, 2, 3, 4] =&gt; args = [2, 3, 4] 另外，在 JSX 中，... 可以把对象中的键值对拿出来，以等号连接。 对象和 Map对象和 Map 初步的不同就在于键是否是字符串。 创建与增减键值对对象： 123let obj = &#123;&#125;obj.haha = '123'delete obj.haha Map： 1234let map = new Map()map.set('haha','123')map.get('haha')map.delete('haha') 遍历对象： 1Object.entries(obj) =&gt; [['haha', '123'], ['lala', '234']] Map： 1map.entries() =&gt; [['haha', '123'], ['lala', '234']] 没有看的 symbol 部分 reflect 部分(感觉可以直接调用，不需要使用 reflect) generator 部分(习惯于用promise的回调写法，不习惯这种写法) async 部分(同 generator) port]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS手势与响应机制]]></title>
    <url>%2F2016%2F09%2F03%2Fios%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。 UIResponder点击事件响应流程 系统响应阶段 手指触碰屏幕，事件交由 IOKit 处理 IOKit 将触摸事件封装为一个 Event 对象，通过 march port 传递给 SpringBoard 桌面进程。 SpringBoard 进程因接收到触摸事件，触发了其主线程 runloop 的 source1 事件源的回调。若前台无应用，则触发 SpringBoard 本身主线程 runloop 的 source0 事件源的回调，将事件交由桌面系统去消耗；若前台有应用，则将触摸事件通过IPC传递给前台APP进程。 APP响应阶段 APP进程的 mach port 接受到 SpringBoard 进程传递来的触摸事件，主线程的 runloop 被唤醒，触发了 source1 回调。 source1 回调又触发了一个 source0 回调，将接收到的 Event 对象封装成 UIEvent 对象，此时APP将正式开始对于触摸事件的响应。 source0 回调内部将触摸事件添加到 UIApplication 对象的事件队列中。事件出队后，UIApplication 开始通过不断 hit-testing 寻找最佳响应者。 找到响应者后，事件便在响应链上传播。事实上，事件除了被响应者消耗，还能被手势识别器或是 target-action 模式捕捉并消耗掉。 事件处理完毕后，runloop 进入休眠。等待再次被唤醒。 几个名词：响应者、触摸、事件UIResponder在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。 以下都是继承自UIResponder的，所以都能接收并处理事件: UIApplication UIViewController UIView 那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; UITouch 一个手指一次触摸屏幕，就对应生成一个UITouch对象。多个手指同时触摸，生成多个UITouch对象。 每个UITouch对象记录了触摸的一些信息，包括触摸时间、位置、阶段、所处的视图、窗口等信息。 UITouch 提供了获取相对于视图的坐标的方法： 1- (CGPoint)locationInView:(UIView *)view; UIEvent 触摸的目的是生成触摸事件供响应者响应，一个触摸事件对应一个UIEvent对象 UIEvent对象中包含了触发该事件的触摸对象的集合，可以通过allTouches 属性获取。 例1：使用 UITouch 实现 UIView 的拖拽通过 UIResponder 和 UITouch 的视图定位，可以实现拖拽 UI 的功能 1234567891011121314151617181920- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 想让控件随着手指移动而移动,监听手指移动 // 获取UITouch对象 UITouch *touch = [touches anyObject]; // 获取当前点的位置 CGPoint curP = [touch locationInView:self]; // 获取上一个点的位置 CGPoint preP = [touch previousLocationInView:self]; // 获取它们x轴的偏移量,每次都是相对上一次 CGFloat offsetX = curP.x - preP.x; // 获取y轴的偏移量 CGFloat offsetY = curP.y - preP.y; // 修改控件的形变或者frame,center,就可以控制控件的位置 // 形变也是相对上一次形变(平移) // CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 // make:相对于最原始的位置形变 // CGAffineTransform t:相对这个t的形变的基础上再去形变 // 如果相对哪个形变再次形变,就传入它的形变 self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);&#125; 例2：配合 CAShapeLayer 实现一个画板简单说就是记录下收拾的贝塞尔曲线，然后将这个曲线的 path 设置给 CAShapeLayer： 1234567891011121314151617181920212223242526272829303132333435363738- (CAShapeLayer *)shapeLayer&#123; if (_shapeLayer == nil) &#123; _shapeLayer = [CAShapeLayer layer]; _shapeLayer.strokeColor = [UIColor blackColor].CGColor; _shapeLayer.fillColor = [UIColor clearColor].CGColor; _shapeLayer.lineJoin = kCALineJoinRound; _shapeLayer.lineCap = kCALineCapRound; _shapeLayer.lineWidth = 10; [self.layer addSublayer:_shapeLayer]; &#125; return _shapeLayer; &#125;- (UIBezierPath *)path&#123; if (_path == nil) &#123; _path = [UIBezierPath bezierPath]; _path.lineWidth = 10; &#125; return _path;&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self]; [self.path addLineToPoint:point]; self.shapeLayer.path = self.path.CGPath;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self]; [self.path moveToPoint:point];&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.shapeLayer = nil; self.path = nil;&#125; 向下寻找响应者的过程自上而下的寻找过程 UIApplication首先将事件传递给 UIWindow，多个窗口优先最上层的窗口。 调用 hitTest 方法，询问是否可以响应。视图若不能响应，则将事件传递给上一个同级子视图；若能响应，则从后往前询问当前视图的子视图。 重复步骤2。视图若没有能响应的子视图了，则自身就是最合适的响应者。 无法响应的情况 不允许交互：userInteractionEnabled = NO 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 注意: 默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO，所以如果希望UIImageView可以交互，需要userInteractionEnabled = YES。 判断是否可以响应的逻辑12345678910111213141516171819202122- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //3种状态无法响应事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; //触摸点若不在当前视图上则无法响应事件 if ([self pointInside:point withEvent:event] == NO) return nil; //从后往前遍历子视图数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子视图 UIView *childView = self.subviews[i]; // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标 CGPoint childP = [self convertPoint:point toView:childView]; //询问子视图层级中的最佳响应视图 UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; //如果子视图中有更合适的就返回 return fitView; &#125; &#125; //没有在子视图中找到更合适的响应视图，那么自身就是最合适的 return self;&#125; pointInside:withEvent: 这个方法，用于判断触摸点是否在自身坐标范围内 例1：超出父视图区域的点击响应开发中可能会遇到一种情况：Tabbar 中的一个按钮超出了 tabbar 显示的区域。默认情况下，点击超出部分是无法响应点击事件的。 因为触摸点不在TabBar的坐标范围内，因此TabBar无法响应该触摸事件，hitTest:withEvent: 直接返回了nil。整个过程，事件根本没有传递到圆形按钮。所以我们需要做的是扩大 tabbar 的点击范围。 我们需要重写 tabbar 的 pointInside:withEvent: 方法，先把位置转换到按钮上判断一下是否点击了按钮： 1234567891011//TabBar- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; //将触摸点坐标转换到在CircleButton上的坐标 CGPoint pointTemp = [self convertPoint:point toView:_CircleButton]; //若触摸点在CricleButton上则返回YES if ([_CircleButton pointInside:pointTemp withEvent:event]) &#123; return YES; &#125; //否则返回默认的操作 return [super pointInside:point withEvent:event];&#125; 例2：按钮扩大响应区域和上面类似，还是重写 pointInside:withEvent: 方法： 12345- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; // 将一个 100*100 的按钮扩大为 300*300 的按钮 CGRect rect = CGRectMake(-100, -100, 300, 300); return CGRectContainsPoint(rect, point) ? YES : NO;&#125; 事件响应的向上传递在找到最佳响应者之后，UIApplication将事件通过 sendEvent: 传递给事件所属的window，window同样通过 sendEvent: 再将事件传递给最佳响应者： 1UIApplication ——&gt; UIWindow ——&gt; hit-tested view 响应者接收到时间之后，会回调 UIResponder 中的 touchesBegan:withEvent: 方法。响应者对于接收到的事件有3种操作： 不拦截，默认操作事件会自动沿着默认的响应链往下传递 拦截，不再往下分发事件。重写 touchesBegan:withEvent: 进行事件处理，不调用父类的 touchesBegan:withEvent: 拦截，继续往下分发事件。重写 touchesBegan:withEvent: 进行事件处理，同时调用父类的 touchesBegan:withEvent: 将事件往下传递 每一个响应者对象（UIResponder对象）都有一个 nextResponder 方法，用于获取响应链中当前对象的下一个响应者。调用父类的 touchesBegan:withEvent: 会默认调用 nextResponder 的 touchesBegan:withEvent:。因此，就把响应事件向上传递了。 我们可以通过响应链 nextResponder 找到下一级响应者，直到找到 UIViewController 的子类 UIGestureRecognizer手势简介UIGestureRecognizer 是手势的基类，可以创建其派生类实例来满足不同需求。 初始化方法UIGestureRecognizer类为其子类准备好了一个统一的初始化方法： 1- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action; 手势状态UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态: 1@property(nonatomic,readonly) UIGestureRecognizerState state; 枚举值如下： 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, // 默认的状态，这个时候的手势并没有具体的情形状态 UIGestureRecognizerStateBegan, // 手势开始被识别的状态 UIGestureRecognizerStateChanged, // 手势识别发生改变的状态(手势正在移动的状态) UIGestureRecognizerStateEnded, // 手势识别结束，将会执行触发的方法 UIGestureRecognizerStateCancelled, // 手势识别取消 UIGestureRecognizerStateFailed, // 识别失败，方法将不会被调用 UIGestureRecognizerStateRecognized&#125;; 可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。 常用属性和方法123456789101112//设置代理，具体的协议后面会说@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; //设置手势是否有效@property(nonatomic, getter=isEnabled) BOOL enabled;//获取手势所在的view@property(nullable, nonatomic,readonly) UIView *view; //获取触发触摸的点- (CGPoint)locationInView:(nullable UIView*)view; //设置触摸点数- (NSUInteger)numberOfTouches; //获取某一个触摸点的触摸位置- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view; 其中，UITouch也有一个方法是locationInView:可以获取触摸点在view中的位置。 代理方法 UIGestureRecognizerDelegate1234567891011//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;//下面这个两个方法也是用来控制手势的互斥执行的//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer//这个方法返回YES，第一个和第二个互斥时，第二个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer 手势互斥同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，并且触发是随机的，一个手势触发了就会默认屏蔽其他相似的手势动作。 如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法： 1[ges requireGestureRecognizerToFail:ges2]; 表示如果ges2匹配，那么不会执行ges。只有当ges2不匹配的时候，才会执行ges。这个方法还适用于识别双击手势时屏蔽单击手势。只有确定不是双击手势后再识别为单击手势 UIGestureRecoginzer 子类点击手势——UITapGestureRecognizer1234//设置点击次数，默认为单击@property (nonatomic) NSUInteger numberOfTapsRequired; //设置同时点击的手指数@property (nonatomic) NSUInteger numberOfTouchesRequired; 捏合手势——UIPinchGestureRecognizer1234//设置缩放比例@property (nonatomic) CGFloat scale; //设置捏合速度@property (nonatomic,readonly) CGFloat velocity; 在设置完缩放后，一定要把recognizer.scale设置为1 123456- (void)handlePinch:(UIPinchGestureRecognizer*)recognizer&#123; NSLog(@"缩放操作");//处理缩放操作 //对imageview缩放 _imageView.transform = CGAffineTransformScale(_imageView.transform, recognizer.scale, recognizer.scale); recognizer.scale = 1;&#125; 拖拽手势——UIPanGestureRecognzer12345678//设置触发拖拽的最少触摸点，默认为1@property (nonatomic) NSUInteger minimumNumberOfTouches; //设置触发拖拽的最多触摸点@property (nonatomic) NSUInteger maximumNumberOfTouches; //获取手势的当前位置- (CGPoint)translationInView:(nullable UIView *)view; //设置手势的当前位置- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view; 拖动过程中处理方法会被多次调用，但是在一次拖拽结前，translationInView: 方法参照的点都是最开始按下的点。这就导致增量的拖动，越拖越快。所以我们必须使用setTranslation设置为CGPointZero，就能将手指的当前位置设置为拖移手势的起始位置： 12345678910-(void)handlePan:(UIPanGestureRecognizer*)recognizer&#123; NSLog(@"拖动操作"); //处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右 // 拖动过程中可以判断是否为 UIGestureRecognizerStateChanged if (recognizer.state == UIGestureRecognizerStateChanged)&#123; CGPoint translation = [recognizer translationInView:_imageView]; recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x, recognizer.view.center.y + translation.y); [recognizer setTranslation:CGPointZero inView:_imageView]; &#125;&#125; 滑动手势——UISwipeGestureRecognizer滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢 1234//设置触发滑动手势的触摸点数@property(nonatomic) NSUInteger numberOfTouchesRequired; //设置滑动方向@property(nonatomic) UISwipeGestureRecognizerDirection direction; 旋转手势——UIRotationGestureRecognizer1234//设置旋转角度@property (nonatomic) CGFloat rotation;//设置旋转速度 @property (nonatomic,readonly) CGFloat velocity; 在设置完旋转后，recognizer.rotation一定要清零. 123456- (void)handleRotate:(UIRotationGestureRecognizer*) recognizer&#123; NSLog(@"旋转操作");//处理旋转操作 //对imageview旋转 _imageView.transform = CGAffineTransformRotate(_imageView.transform, recognizer.rotation); recognizer.rotation = 0; //一定要清零&#125; 长按手势——UILongPressGestureRecognizer12345678//设置触发前的点击次数@property (nonatomic) NSUInteger numberOfTapsRequired; //设置触发的触摸点数@property (nonatomic) NSUInteger numberOfTouchesRequired; //设置最短的长按时间@property (nonatomic) CFTimeInterval minimumPressDuration; //设置在按触时时允许移动的最大距离 默认为10像素@property (nonatomic) CGFloat allowableMovemen 手势与响应链结论event 绑定的 touch 对象上维护了一个手势识别器数组。在响应链通过 hit-test 寻找最佳响应视图的时候，会收集响应链上每一个视图上施加的手势： Window先将事件传递给这些手势识别器，再传给hit-tested view。一旦有手势识别器成功识别了手势，Application就会取消hit-tested view对事件的响应。因此可以理解为手势识别器比UIResponder具有更高的事件响应优先级。 但是，识别手势是需要时间的，所以具体的表现就是当有点击事件的时候，会先触发 touchBegan:withEvent: 方法，然后当手势识别到的时候，就会触发 touchCancelled:withEvent: 比如在视图上添加一个 UIPanGestureRecognizer 手势。打印日志可以看到，会先触发 UIResponder 的回调，直到 UIPanGestureRecognizer 识别成功： 手势识别器的两个属性12@property(nonatomic) BOOL cancelsTouchesInView;@property(nonatomic) BOOL delaysTouchesBegan; cancelsTouchesInView默认为YES。表示当手势识别器成功识别了手势之后，会通知Application取消响应链对事件的响应，并不再传递事件给hit-test view。若设置成NO，表示手势识别成功后不取消响应链对事件的响应，事件依旧会传递给hit-test view。 如果设置 pan.cancelsTouchesInView = NO，那么上面的 UIPanGestureRecognizer 的日志会变为： delaysTouchesBegan默认为NO。默认情况下手势识别器在识别手势期间，当触摸状态发生改变时，Application都会将事件传递给手势识别器和hit-tested view；若设置成YES，则表示手势识别器在识别手势期间，截断事件，即不会将事件发送给hit-tested view。 如果设置 pan.delaysTouchesBegan = NO，那么上面的 UIPanGestureRecognizer 的日志会变为： UITableView 的点击和手势的冲突UIScrollView 的滑动其实是因为系统加了一个 UIPanGesture的缘故。UITableView 点击 Cell 其实是调用了 touchBegan:withEvent: 方法。 因此，当有这样一个需求：cell 支持左滑，并且当一个 cell 左滑固定的时候，点击 UITableView 任意位置会关闭 cell。这种时候，需要给 UITableView 添加一个 UITapGesture。而这个 UITapGesture 就会导致 UITableView 本身 Cell 点击的不响应。 因此，我们需要在通常情况下设置这个 tapGesture.enabled = NO;。只有在 Cell 展开的情况下，设置 tapGesture.enabled = YES 手势与UIControlUIControl 继承于 UIResponder。像 UIButton 就是继承于 UIControl 结论系统派生于 UIControl 的类像 UIButton 之类，处理事件的优先级比父视图上的 UIGestureRecognizer高。UIControl会阻止父视图上的手势识别器行为。 注意，自己继承于 UIControl 实现的类不存在优先级比手势高的情况。 另外，UIControl 的优先级是比父视图上的手势高，如果当前视图也有手势，那么 UIControl 无法阻止手势响应。 一些技巧几个坐标转换的方法UITouch123456// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置- (CGPoint)locationInView:(UIView *)view; // 该方法记录了前一个触摸点的位置- (CGPoint)previousLocationInView:(UIView *)view; UIGestureRecognizer12345// 返回坐标点,第一个参数为tauch数组的索引CGPoint point= [pan locationOfTouch:0 inView:self.view];// 手指移动了多少，上面是相对于坐标原点，这个是相对于拖拽的起始点，用于 拖拽 View 时候修改 View 位置的// 配合 [pan setTranslation:CGPointZero inView: someView] 使用，每次拖拽方法回调的时候，都要将上次的拖拽位移清零CGPoint point = [pan translationInView:self.view]; UIView12// UIView 转换到另一个 UIView 坐标系，在 hittest 中判断子控件是否是 responder 的时候会使用- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view; 参考iOS触摸事件全家桶 史上最详细的iOS之事件的传递和响应机制]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIResponder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block 的使用]]></title>
    <url>%2F2016%2F09%2F01%2FBlock%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[类似于匿名函数，oc中提供block,可以将一段代码块像对象一样作为参数传递、执行。 Block的使用Block实例1234^(double dividend)&#123; double quotient = dividend / divisor; return quotient;&#125; Block对象可以被当做一个实参来传递给可以接收block的方法。 声明block变量:1void (^devowelizer)(id, NSUInteger, BOOL*); void 表示返回类型^ 表示是一个block对象devowelizer 表示block变量的名称后面的是实参类型方法的调用参数类型为^(id string, NSUInteger i, BOOL *stop)block 编写Block对象123devowelizer = ^(id string,NSUInteger i, BOOL *stop)&#123; ……&#125;; 调用block变量1devowelizer(string,i,stop); typedef不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。1typedef void(^ArrayEnumerationBlock)(id,NSUInteger,BOOL *); 需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。1ArrayEnumerationBlock devowelizer； 外部变量在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。 当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址. 修改外部变量如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。 在Block中使用self如果要写一个使用self的Block对象，需要避免强引用循环。在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。1234_weak typeof(self) weakSelf = self; //弱引用指针 myBlock = ^&#123; NSLog(@“Employee:%@”,weakSelf); &#125;; block的实现block 结构block本质上也是一个oc对象，他内部也有一个isa指针。block是封装了函数调用以及函数调用环境的OC对象。 将上图和下图做对照，可以发现，两者的结构基本一致： 注意看上面的 block 结构体，在结构体内部也创建了一个同名的变量 age，它的值和外部的 age 相同。因此，内部 age 修改了并不会影响外部 age。 block 变量捕获变量有五种形式，auto 局部变量、static 局部变量、auto 全局变量、static 全局变量、成员变量。 为什么要有变量的捕获因为如果是引用外部局部变量，局部变量会在作用域结束后回收。局部变量回收了，闭包肯定就 crash 了。因此需要进行变量的捕获。 变量如何捕获的捕获方式是在内部创建一个同名的变量，赋给它相同的值或者指向相同的地址。这样虽然代码上看起来是同一个变量，但是其实是两个变量。 为什么不让使用者直接修改使用到的外部变量上面说到，block 中使用的外部变量其实不是正真的外部变量，而是新创建的和外部同名的变量。因此，就算可以改，改的也只是内部的同名变量的指向。因此，编译器索性就不让改了。 局部变量对于局部变量来说，auto 局部变量捕获的是值，static 局部变量捕获的是地址。这是因为 auto 局部变量可能会销毁，所以要捕获值，否则会访问已回收的地址。而 static 局部变量则不用担心变量回收，所以捕获的是地址。所以，在block调用之前修改地址中保存的值，block中的 static 变量会随之改变。例： 全局变量block不需要捕获全局变量，因为全局变量无论在哪里都可以访问。局部变量因为跨函数访问所以需要捕获，全局变量在哪里都可以访问 ，所以不用捕获。 成员变量成员变量是比较特殊的，即使block中使用的是实例对象的属性，block中捕获的仍然是实例对象，并通过实例对象 get 方法去获取使用到的属性 因为点语法实质是调用方法，所以捕获的是 self block 的类型三种类型block 存在三种类型： 123__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）__NSStackBlock__ （ _NSConcreteStackBlock ）__NSMallocBlock__ （ _NSConcreteMallocBlock ） 我们可以通过代码查看他们的类型： 三种类型的定义没有访问auto变量的block是__NSGlobalBlock__类型的，存放在数据段中。访问了auto变量的block是__NSStackBlock__类型的，存放在栈中。__NSStackBlock__类型的block调用copy成为*__NSMallocBlock__类型并被复制存放在堆中。 栈 block 相当于一个局部变量，当超出作用域，就面临着被回收的风险。ARC 下，很多情况中，会自动帮我们执行一次 copy，比如赋值。 因此，block 的属性修饰词需要使用 copy。当然 ARC 环境下，使用 strong，编译器也会自动帮我们 copy。 __weak 关键字__weak 关键字修饰的变量会对引用对象进行弱引用。在 block 中使用被弱引用的变量，block 内部也会捕获弱引用的对象： __block 关键字上面说到，block 内部会创建一个和外部同名的变量具有相同的值，或者指向相同的地址。那么这样就无法做到外部修改外部变量的值，block 内部做相应的变化；block 内部修改变量的值，外部变量做相应的变化。 那么如何才能做到内外的修改能够同步呢？见下图： 赋值操作都会引起外部变量和内部变量的表示的值或地址的不同。要解决这种不同只有通过一层中间层来解决。外部变量和内部变量都指向相同的地址。而对于外部变量或者内部变量的修改都转为对包裹的对象的修改，而不是切换外部变量或者内部变量的指向。 iOS 提供了 __block 来达到这个目的。__block 修饰的变量，编译器会自动将其包装为一个对象，原本被修饰的变量会作为对象的一个属性。 只有要修改变量的值或者地址的时候才使用__block，比如修改 NSMutableArray 这种则不需要使用 __block block 的嵌套对于 block 的嵌套，比如以下场景，blockB会捕获self，这是大家都了解的，但是blockA会捕获self么？为什么？ 12345678- (void)embeddedBlock&#123; void (^blockA)() = ^&#123; void (^blockB)() = ^&#123; NSLog(@"%@",self); &#125;; &#125;;&#125; 答案是会，先将self从外界传入到blockA中。再从blockA的中传入到blockB中。blockB只能从blockA的作用域里捕获变量。因此blockB中捕获的任何东西，blockA必须也捕获一份。 参考iOS底层原理总结 - 探寻block的本质（一） iOS底层原理总结 - 探寻block的本质（二）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView 基础]]></title>
    <url>%2F2016%2F08%2F30%2FUITableView%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[UITableView是最常用的基本控件。此处对其一般用法进行总结。 UITableView基础UITableView 的样式 UITableViewStylePlain 将会保持在顶部直到被顶掉 UITableViewStyleGrouped将会随着cell一起滚动 1UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStyle]; 其中CGRectZero表示equivalent to CGRectMake(0, 0, 0, 0).之后代码会改UITableView的Frame，所以暂且都是0。 UITableView对象提供数据UITableView不包含任何数据，需要提供一个数据源.我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议1234@interface BNRAppDelegate: UIResponder &lt;UIApplicationDelegate,UITableViewDataSource&gt;@property (nonatomic) UITableView *taskTable;@property (nonatomic) NSMutable Array *tasks;@end 在.m中向UITableView发送setDataSource消息，将BNRAPPDelegate实例设置为数据源 1self.taskTable.dataSource = self; UITableViewDataSource设置了两个必须方法： 根据指定的表格索引给出相应表格段包含的行数（tableView：numberOfRowsInSection：） 根据指定表格段索引和行索引给出相应的UITableViewCell对象（tableView：cellForRowAtIndexPath：）1234567891011@implementation BNRAppDelegate-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return [self.tasks count];&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *c = [self.taskTable dequeueReusableCellWithIdentifier:@“cell” forIndexPath:indexPath]; //重用cell NSString *item = [self.tasks objectAtIndex:indexPath.row]; c.textLabel.text = item; return c;&#125; 刷新表格：[self.taskTable reloadData]; 使用 dequeueReuseableCellWithIdentifier:forIndexPath: 必须要注册 registerClass ，但是不用判断是否非空以及手动创建。 使用 dequeueReuseableCellWithIdentifier: 可以免去注册，但是需要手动判断是否为空，为空的话还要手动创建 重用UITableViewCell对象需要将自定义的cell类和identifier进行关联。在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell1234-(void)viewDidLoad&#123; [super viewDidLoad]; [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@“UITableViewCell”];&#125; 这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联1[self.tableView registerNib:[UINib nibWithNibName:@"MineUserInfoCell" bundle:nil] forCellReuseIdentifier:@"MineUserInfoCellIdentifier"]; 纯代码用 registerClass，有 xib 用 registerNib. 代码创建，使用 registerClass: 注册, dequeue时会调用 cell 的 - (id)initWithStyle:withReuseableCellIdentifier: 若使用nib，使用 registerNib: 注册，dequeue时会调用 cell 的-(void)awakeFromNib 使用UIViewController创建tabeView需要自己创建tableview属性：1@property (nonatomic, strong) UITableView *tableView; 这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。 创建多个section的tableview创建多个section的tableview需要实现方法numberOfSectionsInTableView:返回tableview中section的个数。其余使用和单个section一样。 在cellForRowAtIndexPath:方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数(NSIndexPath *)indexPath。 NSIndexPath是一个结构体，具有两个属性row和section。表示所在section和section内row。NSIndexPath中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。创建方式:1NSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:1]; TableView表头视图表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。1UIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@"HotelReviewsHeaderView" owner:nil options:nil]lastObject]; loadNibNamed:owner:options:返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。initWithNibName的实现和该方法类似，其中也会用到该方法。不过initWithNibName用在获取Controller的xib中。 1234- (void)viewDidLoad&#123; UIView *header = self.headerView; [self.tableView setTableHeaderView:header];&#125; 加载完headerView后，将其设置为UITableView对象的表头视图。也可以在 (UIView *)tableView:viewForHeaderInSection:方法中设置，当只有一个section时效果相同。1234- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123; UIView *view = [[[NSBundle mainBundle] loadNibNamed:@"HeaderView" owner:nil options:nil] lastObject]; return view;&#125; tableview的字母索引实现sectionIndexTitlesForTableView方法，返回一个字符串数组：123456- (NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123; NSMutableArray *indexs = [[NSMutableArray alloc]init]; [indexs addObject:@"我"]; [indexs addObject:@"是"]; return indexs;&#125; 这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。 点击cell中button获取所属indexpathbutton点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。12345678910111213[cell.btn addTarget:self action:@selector(cellBtnClicked:event:) forControlEvents:UIControlEventTouchUpInside];- (void)cellBtnClicked:(id)sender event:(id)event&#123; NSSet *touches =[event allTouches]; UITouch *touch =[touches anyObject]; CGPoint currentTouchPosition = [touch locationInView:_tableView]; NSIndexPath *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition]; if (indexPath!= nil) &#123; // do something &#125;&#125; 可以通过event拿到在tableView中的位置cure，再通过indexPathForRowAtPoint:方法获取NSIndexPath。 另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：12345678910111213//cell.h中的声明- (IBAction)buttonPressed :(id)；//cell.m中的实现，设置代理- (void)buttonPressed:(id)sender&#123; [self.delegate buttonPressed:self event:event];&#125;//viewcontroller中的实现- (void)buttonPressed:(TableViewCell1 *)cell&#123; NSIndexPath *indexPath2 = [_tableView indexPathForCell:cell]; NSLog(@"所属行数：%ld",(long)indexPath2.row+1);&#125; 通过设置delegate，将button的点击事件交给viewController完成。 注意，如果是那种点击 button 后删除的需求，在调用 deleteItemsAtIndexPaths: 之前，一定要先删除数据源里的数据，因为deleteItemsAtIndexPaths: 调用后，会刷新部分数据。 iOS高级开发——CollectionView的动态增删cell及使用模型重构 编辑UITableView编辑模式下的UITableView进入编辑模式通过调用[_tableView setEditing:!_tableView.isEditing animated:true]进入编辑模式,可实现添加，删除，移动操作。默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。 设置可以编辑的行使用setEditing:animated:方法让tableView进入编辑模式.可以使用tableView:canEditRowAtIndexPath方法筛选能进入编辑模式的行：1234567- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath &#123; if(indexPath.row == (10 | 12 | 14))&#123; return NO; &#125;else&#123; return YES; &#125;&#125; 如果不实现该方法，默认为YES。 设置编辑模式通过设置UITableViewCellEditingStyle可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的commitEditingStyle:forRowAtIndexPath:方法的入参传入。1234567-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; if (具体情况) &#123; return UITableViewCellEditingStyleInsert; &#125;else&#123; return UITableViewCellEditingStyleDelete; &#125;&#125; 设置编辑模式下的操作实现tableView:commitEditingStyle:forRowAtIndexPath:这个统一的回调方法，无论是添加还是删除都会执行，需要自己根据入参区分开。第二个实参是UITableViewCellEditingStyle类型的常数(删除表格行时，传入的是UITableViewCellEditingStyleDelete;插入表格行时，传入的是UITableViewCellEditingStyleInsert)。123456789- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; [self.dataSource removeObjectAtIndex:indexPath.row]; [self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade]; &#125;else if (editingStyle == UITableViewCellEditingStyleInsert)&#123; [self.dataSource insertObject:@"我是新来的" atIndex:indexPath.row]; [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom]; &#125;&#125; 使用deleteRowsAtIndexPaths和insertRowsAtIndexPaths可以进行局部刷新，节省资源，并且还能添加指定动画。 cell的移动进入编辑模式后实现tableView:moveRowAtIndexPath:方法123456789- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath&#123; if(sourceIndexPath == destinationIndexPath)&#123; return ; &#125;else&#123; Comment *comment = [self.dataSource objectAtIndex:sourceIndexPath.row]; [self.dataSource removeObjectAtIndex:sourceIndexPath.row]; [self.dataSource insertObject:comment atIndex:destinationIndexPath.row]; &#125;&#125; 一定要对数据源进行正确操作。 侧滑菜单许多 app 提供侧滑某一栏展示菜单的功能。这在 iOS8 中有了默认的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//设置cell可编辑状态-(BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath&#123; return YES;&#125;//定义编辑样式为删除样式-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return UITableViewCellEditingStyleDelete;&#125;//设置返回存放侧滑按钮数组-(NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //这是iOS8以后的方法 UITableViewRowAction *deleBtn = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@"删除" handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; [_messageData removeObjectAtIndex:indexPath.row]; [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationBottom]; &#125;]; UITableViewRowAction *moreBtn = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@"更多更多" handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; NSLog(@"更多，，点了"); &#125;]; UITableViewRowAction *upBtn = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@"置顶" handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123; [_messageData exchangeObjectAtIndex:indexPath.row withObjectAtIndex:0]; NSIndexPath *firstIndexPath = [NSIndexPath indexPathForRow:0 inSection:indexPath.section]; [tableView moveRowAtIndexPath:indexPath toIndexPath:firstIndexPath]; &#125;]; //设置背景颜色，他们的大小会分局文字内容自适应，所以不用担心 deleBtn.backgroundColor = [UIColor redColor]; moreBtn.backgroundColor = [UIColor orangeColor]; upBtn.backgroundColor = [UIColor grayColor]; return @[deleBtn,moreBtn,upBtn]; &#125; 还是设置为可编辑，然后设置编辑样式为删除样式。不同的是，需要实现一个侧滑的专用回调方法。需要创建多个 UITableViewRowAction 对象，你可以像 button 一样设置它们，不过在初始化的时候需要事先设置好毁掉方法。 代码控制的编辑方式上面说的都是交互情况下的编辑方式。我们可以自己通过代码控制刷新视图，不需要交互。 刷新方式简单总结一些UITableView的刷新方法： reloadData 刷新整个表格 reloadRowsAtIndexPaths:withRowAnimation:刷新indexPath指向的cell reloadSections:withRowAnimation: 刷新NSIndexSet内包含的Section 这三个分别刷新tableview的各个部分第一个没有动画效果。第二个可以传入一个数组1[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationTop]; 第三个可以传入一个NSIndexSet集合12[self.tableView reloadSections:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, 2)] withRowAnimation:UITableViewRowAnimationFade];[_tableView reloadSections:[NSIndexSet indexSetWithIndex:indexPath.section]withRowAnimation:UITableViewRowAnimationLeft]; 插入删除在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。 deleteRowsAtIndexPaths:withRowAnimation: insertRowsAtIndexPaths:withRowAnimation: 就不举例了。同上面一样。 beginUpdates和endUpdates如果要同时进行刷新或者插入删除移动等操作，需要使用 beginUpdates 和 endUpdates 包裹，作为一个动画组进行。 如果要自己控制动画的时间可以通过动画的方式： 123456789101112131415[UIView animateKeyframesWithDuration:1 delay:0 options:UIViewKeyframeAnimationOptionAutoreverse animations:^&#123; &#125; completion:^(BOOL finished) &#123; // 添加Transaction事务 [CATransaction begin]; [CATransaction setCompletionBlock:^&#123; NSLog(@"动画完成") &#125;]; [self.tableView beginUpdates]; [self.tableView moveRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:0] toIndexPath:[NSIndexPath indexPathForRow:2 inSection:0]]; NSString *str = self.arrayData[0]; [self.arrayData removeObjectAtIndex:0]; [self.arrayData insertObject:str atIndex:2]; [self.tableView endUpdates]; [CATransaction commit]; &#125;]; beginUpdates 和 endUpdates 有一个好处就是会调用 heightForRow 改变高度，但是不会调用 cellForRow 刷新视图。所以，当 tableView 的某一项高度改变的时候，可以直接使用该方法刷新高度。 123// 刷新 tableView 中 cell 的高度self.tableView.beginUpdates()self.tableView.endUpdates() 小技巧当cell未能填满tableview时，怎么响应空白部分点击事件当 tableview 太大，cell 太少，以至于不能填满tableview的时候，那么空白部分的点击事件该怎么设置呢？只要给 tableview 添加一个 footerview，这个 footerview 的大小是整个 tableview 的大小，然后设置这个 footerview 的点击事件即可。 为什么能这样呢？因为 cell 没有填充满的部分都用 footerview 填充了。 UITableView 取消点击cell的选中背景颜色方法一在选中的回调方法中取消选中： 123- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:NO];&#125; 方法二设置 cell 的选中属性： 12345-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; ... cell.selectionStyle = UITableViewCellSelectionStyleNone; ...&#125; cell 的点击事件不响应有可能是在 cell 里设置了 UIButton，由于响应机制，先响应 UIButton 的点击事件。所以就忽略了 cell 的 didSelect 方法。 所以要做的就是将 UIButton 的 UserInteractionEnabled 设置为 No。 使用 UILocalizedIndexedCollation 对数据源分组比如一个联系人的 tableView，我们需要把联系人按照首字母分组显示。iOS 就提供了一个 UILocalizedIndexedCollation 帮助我们进行分组。 属性与方法UILocalizedIndexedCollation 需要被记住的属性和方法就这么几个： 12345678// 获得单例 UILocalizedIndexedCollation 的实例+ (instancetype)currentCollation;// 字符索引数组(其实内容是固定的就是 A-Z,加上一个代表其他的 #)@property(nonatomic, readonly) NSArray&lt;NSString *&gt; * sectionTitles;// 输入对象以及一个返回字符串的对象方法，根据返回的 int 判断字符串要加入哪个分组- (NSInteger)sectionForObject:(id)object collationStringSelector:(SEL)selector;// 数组内对象排序- (NSArray *)sortedArrayFromArray:(NSArray *)array collationStringSelector:(SEL)selector; 除了上面的属性和方法还有一个属性和一个方法用不到，不用管它。 实例比如要实现一个需求是对联系人进行归类，然后以 tableView 的形式展示。特殊的地方时，只展示有值的分组。 初始化数组12345678910111213// 单例对象 UILocalizedIndexedCollation *localIndex = [UILocalizedIndexedCollation curre ntCollation]; // 获得当前语言下的所有的indexTitles _allIndexTitles = localIndex.sectionTitles; // 初始化所有数据的数组 (之后的所有进过分组的数据都保存在这个 _data 里)_data = [NSMutableArray arrayWithCapacity:_allIndexTitles.count]; // 为每一个indexTitle 生成一个可变的数组 for (int i = 0; i&lt;_allIndexTitles.count; i++) &#123; // 初始化数组 (_data 里的元素是各个分组，所以也是数组) [_data addObject:[NSMutableArray array]]; &#125; // 初始化有效的sectionIndexs (之后有值的分组的索引会被保存在这里)_sectionIndexs = [NSMutableArray arrayWithCapacity:_allIndexTitles.count]; 这里要强调的是 _data 是不管分组有没有数据，都创建并保存到其中了。而 _sectionIndexs 只保存有数据的分组的索引。 分组1234567891011121314151617SEL nameSelector = @selector(name); for (Person *person in persons) &#123; if (person == nil) continue; // 获取到这个contact的name的首字母对应的indexTitle // 注意这里必须使用对象，这个selector也是有要求的 // 必须是这个对象中的selector, 并且不能有参数，必须返回字符串 // 所以这里直接使用 name 属性的get方法就可以 NSInteger index = [localIndex sectionForObject:person collationStringSe lector:nameSelector]; // 处理多音字 例如 "曾" --&gt;&gt; 会被当做 ceng 来处理，其他需要处理的多音字类似 if ([person.name hasPrefix:@"曾"]) &#123; index = [_allIndexTitles indexOfObject:@"Z"]; &#125; // 将这个contact添加到对应indexTitle的数组中去 [_data[index] addObject:person];&#125; 这里就通过 UILocalizedIndexedCollation 提供的方法将数据源分组了。上面的注释也写到了，传入一个对象以及对象的方法，通过方法返回的字符串获取所在分组的索引。获取到的索引你可以做进一步判断修改。然后通过这个索引将其放到 _data 的对应分组内。 遍历分组123456789for (int i=0; i&lt;_data.count; i++) &#123; NSArray *temp = _data[i]; if (temp.count != 0) &#123; // 取出不为空的部分对应的indexTitle [_sectionIndexs addObject:[NSNumber numberWithInt:i]]; &#125; // 排序每一个数组 _data[i] = [localIndex sortedArrayFromArray:temp collationStringSelecto r:nameSelector]; &#125; 上一节将数据源全都塞到了对应的分组里。现在就要将分组里的数据排序，并且剔除没有数据的分组了。 判断 _data 中有数据的分组的索引保存到 _sectionIndexs 中。这样以后拿着 _sectionIndexs 中保存的索引就可以到 sectionTitles 中，找到索引对应的值。 结合字母索引展示现在我们已经获得了完整的 _data 和 _sectionIndexs。只需要通过 _sectionIndexs 中保存的索引找到 _data 中相应的分组即可完成展示。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIButton 简介]]></title>
    <url>%2F2016%2F08%2F29%2FUIButton%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[从最基础的控件开始一点点学习。先来总结下UIButton。 基础创建创建一个自定义类型的 button 1234UIButton *btn1 = [[UIButton buttonWithType:UIButtonTypeCustom];CGRect btn1Frame = CGRectMake(50, 50, 200, 100);btn1.frame = btn1Frame;[self.view addSubview:btn1]; 点击事件通过xib关联123- (IBAction)btn2Pressed:(id)sender&#123; NSLog(@"点击操作");&#125; 与xib关联即可，其中(id)sender就表示的是这个Button 通过代码1234//添加[btn1 addTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside];//移除[btn1 removeTarget:self action:@selector(btn1Pressed:) forControlEvents:UIControlEventTouchUpInside]; 为btn1添加和删除一个btn1Pressed的点击事件。 设置title和imagebutton有imageView和titleLabel两个属性，默认image在左，label在右。 添加title和image12[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal]; 这里forState常用的有一下几种： UIControlStateNormal 常态 UIControlStateHighlighted 高亮 UIControlStateDisabled 禁用 UIControlStateSelected 选中 其中需要说明的是，高亮就是点击时的状态。其实还有一种UIControlStateSelected | UIControlStateHighlighted这个组合是选中时候的高亮状态，也是比较有用的。 设置button选中图片button选中与否是由UIControlStateSelected控制的。 可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于点赞。一般情况我们实现方式是这样的：12345678- (void)buttonClick:(UIButton *)button &#123; if ([button.currentImage isEqual:[UIImage imageNamed:@"like"]]) &#123; [button setImage:[UIImage imageNamed:@"like_selected"] forState:UIControlStateNormal]; &#125; else &#123; [button setImage:[UIImage imageNamed:@"like"] forState:UIControlStateNormal]; &#125;&#125; 但是最好不要这样实现。可以使用UIControlStateSelected来控制：12345678[btn1 setImage:[UIImage imageNamed:@"Image"] forState:UIControlStateNormal];[btn1 setImage:[UIImage imageNamed:@"Image2"] forState:UIControlStateSelected];//点击事件- (void)btn1Pressed:(UIButton *)button&#123; //button.enabled 设置是否可点击。 button.selected = !button.selected;&#125; 这样，每次点击的时候切换选中状态达到效果。 但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。 因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:1234//normal-&gt;selected[btn1 setImage:[UIImage imageNamed:@"Image"] forState:UIControlStateHighlighted];//selected-&gt;normal[btn1 setImage:[UIImage imageNamed:@"Image2"] forState:UIControlStateSelected | UIControlStateHighlighted]; 好的，这样就完成了切换状态的过程。（上面说的是两种高亮状态下的设置。完整的代码应该是这样的： 12345678// 未选中状态[button setImage:[UIImage imageNamed:@"like"] forState:UIControlStateNormal];// 选中状态[button setImage:[UIImage imageNamed:@"like"] forState: UIControlStateHighlighted];// 从未选中到选中的高亮状态[button setImage:[UIImage imageNamed:@"like_selected"] forState:UIControlStateSelected];// 从选中到未选中的高亮状态[button setImage:[UIImage imageNamed:@"like_selected"] forState:UIControlStateSelected | UIControlStateHighlighted]; 取消图片的点击高亮图片的点击会有一个高亮状态，如果你不想要有这个状态，那么需要取消点击高亮，可以： 1btn.adjustsImageWhenHighlighted = NO; 设置title 和 image 的位置我们可以通过 UIEdgeInserts 的方式修改位置，但是这种方式经常会压缩拉长 image，所以更好的方式是通过继承 UIButton，并且重写 layoutSubViews 方法的方式： 12345override func layoutSubviews() &#123; super.layoutSubviews() imageView?.bounds = CGRect(x: 0, y: 0, width: 50, height: 50) titleLabel?.bounds = CGRect(x: 0, y: 0, width: 50, height: 50)&#125; 设置 button 圆角普通的使用 cornerRadius 的方式设置圆角会产生离屏渲染。可以使用CAShapeLayer和UIBezierPath设置圆角： 12345678910let w = button.frame.size.widthlet h = button.frame.size.heightlet rect = CGRect(x: 0, y: 0, width: w, height: h)let path = UIBezierPath(roundedRect: rect, cornerRadius: 15)let layer = CAShapeLayer()layer.frame = rectlayer.path = path.cgPathbutton.layer.mask = layerbutton.backgroundColor = UIColor.red 就是这样O(∩_∩)O]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>基本控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git技巧]]></title>
    <url>%2F2016%2F08%2F27%2Fgit%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。 自定义 git config给自己的项目提交代码的时候，有些时候虽然提交成功，但是 github 提交记录的小绿块上并没有记录。这是因为你的项目可能有很多人能提交代码，github 区分不同的人需要靠提交代码的人的邮箱，而这个邮箱你可能没有配置或者配置错了。 比如 sourcetree 会有一个统一的配置： 也就是说所有使用 sourcetree 的提交，用户名和邮箱都是这个。但是如果你公司有另外一个 gitlab 的账号呢？还是使用这个账号的邮箱提交就不会记入你 gitlab 账号的提交记录上。所以你需要配置 git config。 配置非常简单： 12$ git config user.name "zachary"$ git config user.email 759740844@qq.com git rmios中pod的第三方库经常会被gitignore掉，让使用者自己下载。 想要达到一个效果：使文件脱离git的版本管理，但不是会删除它. 使用命令行可以使用git rm --cached fileGit 将不再跟踪此文件，尽管它仍然是在您的硬盘上.对于文件夹，可以使用git rm -r --cached file取消关联整个文件夹。 使用sourcetree在sourcetree中操作要麻烦一些。在添加完gitignore后，将想要ignore的文件移出git目录，然后commit该操作，再将文件移回来。这个时候文件就被ignore了。 需要注意的是，一定要先执行commit操作。因为，在.git中存在了pod的版本控制的文件关联，添加了gitignore后，git并不会主动将pod文件关联删掉。因此，需要先用commit将该文件关联删除，才能正确ignore该文件夹。 总结这里的移除相当于执行了 rm 文件的操作，因而需要使用commit,而使用命令行的git rm 文件则是通过git指令，直接移除了关联。 git add不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有.git的缘故吧。 因此，如果当git不能自动添加文件关联的时候，需要使用git add 文件的方式手动添加。 使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的.git不会被复制，文件也就能添加进sourcetree了。 mergemerge可以说是很常用的一个功能，用于代码合并。只要是关乎于不同branch的代码进行合并都可以用merge啊。 合并分支merge 有一个名词叫“快进式合并”，合并的时候会直接将会直接将一个分支分支指向另一个分支：但是有的时候，为了保证版本演进的清晰，我们希望在合并的分支上生成一个新节点表示做过合并操作，就要采用“非快进式合并”：那么在 sourcetree 怎么做呢？勾选“无论是否可以快进更新都创建新的提交”最后提交合并的记录即可： 临时性分支除了Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： 功能（feature）分支 预发布（release）分支 修补bug（fixbug）分支 这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。 软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。 几种分支的命名方式分别为 feature-*,release-*,fixbug-* 的形式。 rebase变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。 变基操作的一条准则是：不要对在你的仓库外有副本的分支执行变基。 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。 如下图所示，C5是其他分支的合并。先将master重置到C1的提交，然后rebaseC5所在分支，得到新的提交C4&#39;。一般情况下，git是不允许这样的提交到remote的，但是可以使用git push --force强制覆盖remote的仓库。这样C4 C6就不复存在了。 话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交C6到C7，如下图所示： 由于别人的本地git并不知道C4 C6已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交C4&#39;，于是就拉取，但是本地git一看远端提交C4&#39;和本地提交C4 C6都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示： 这样就比较尴尬了，因为当时使用rebase就是为了删掉C4 C6，但是别人这么一合并一提交，C4 C6又全回来了。 如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。 sourcetree 无法看到提交记录点击 sourcetree 中提交记录，可以看到详细的提交信息。但是有些时候点击提交项的时候看不到详细的提交信息。 可以在终端内输入以下命令，然后重启 sourcetree 解决： 1defaults delete com.torusknot.SourceTreeNotMAS &quot;NSSplitView Subview Frames repowindow_LogViewDescSplitter&quot; commit message 规范基本规范第一行为对改动的简要总结，建议长度不超过 50 个字符，用语采用命令式而非过去式。第一行结尾不要留句号。第一个单词的第一个字母要大写。 第二行为空行。 第三行开始，是对改动的详细介绍，可以是多行内容，建议每行长度不超过 72 个字符。主要用来写明白为什么要这样改 避免注释不清晰。比如只有「修正 BUG」、「改错」、「升级」、「添加某文件」等，没有其他内容，等于没说。 6.「提交」的概念是具有独立的功能、修正等作用。小可以小到只修改一行，大可以到改动很多文件，但划分的标准不变，一个提交就是解决一个问题的。 注意，每次提交之后一定是要能正常运行的。不能把不能通过编译的代码提交上去。 主要前缀 Add 新加入的需求 Fix 修正bug Change 修改功能 Update 完成任务或者模块后的更新 Remove 移除功能 Refactor 重构功能 思路有些时候发现不知道该如何写。那么遵循 what-why-how 的形式。写第一行的时候问自己这个 commit 是做了什么事，后面详细写清楚为什么这么做和怎么做到的。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Provisioning Profile]]></title>
    <url>%2F2016%2F08%2F26%2F%E5%88%9D%E8%AF%86Provisioning_Profile%2F</url>
    <content type="text"><![CDATA[真机调试的时候遇到了provisioning profile即将过期的警告，于是搜索并对provisioning profile作了一定了解。结合关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系进行梳理。 基本概念Certificate证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。 众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用） APP IDApp ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种： Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。 Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。 每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。 DeviceDevice最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。 每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。 Provisioning Profile一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。 试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。 例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。 如上所述，在一台设备上运行应用程序的过程如下： 与证书一样，Provisioning Profile也分为Development和Distribution两种 Xcode 7+ 免证书真机调试在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app 使用方法 打开自己已有的工程或者打开Xcode新建一个简单工程 菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , ) 在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。 将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。 Xcode报错如下图所示，直接点击Fix Issue。 警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime应用笔记]]></title>
    <url>%2F2016%2F08%2F23%2Fruntime%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考Runtime全方位装逼指南，总结了以下几点应用场景。 给category添加属性原理对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性： 1OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); object 是源对象. value 是被关联的对象. key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象. policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：1objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC); objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象. 关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中。其中管理着一个 AssociationsHashMap。键是设置关联对象的 object，值是保存这个 object 的所有关联对象的另一个 hashMap 示例：新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):12345typedef void(^clickBlock)(void);@interface UIButton (ClickBlock)@property (nonatomic,copy) clickBlock click;@end 在.m中设置click的set，get方法(UIButton+ClickBlock.m):12345678910111213141516171819202122232425262728#import "UIButton+ClickBlock.h"#import &lt;objc/runtime.h&gt;static const void *associatedKey = "associatedKey";@implementation UIButton (ClickBlock)//Category中的属性，只会生成setter和getter方法，不会生成成员变量-(void)setClick:(clickBlock)click&#123; objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC); [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; if (click) &#123; [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; &#125;&#125;-(clickBlock)click&#123; return objc_getAssociatedObject(self, associatedKey);&#125;-(void)buttonClick&#123; if (self.click) &#123; self.click(); &#125;&#125;@end Category中的属性，只会生成setter和getter方法的声明，不会生成成员变量，而且需要自己实现方法。 其中，在set方法中使用addTarget:action:forControlEvents:给button设置了点击事件。 self.click()表示使用self.click获得block，再通过block()执行块。 为什么不直接给click赋值，而是通过runtime的objc_setAssociatedObject方法呢？@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。 @property在本例中只是为了在.h里声明一个getset方法。可替换成：1234567typedef void(^clickBlock)(void);@interface UIButton (ClickBlock)//@property (nonatomic,copy) clickBlock click;- (clickBlock)click;- (void)setClick:(clickBlock)click;@end 关联对象相当于把一个对象关联到另外一个对象上。在关联后可以随时获取该关联的对象，在对象被销毁时会移除所有关联的对象。 字典与模型转换原理字典转模型的时候： 根据字典的 key 生成 setter 方法. 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）. 模型转字典的时候： 调用 class_copyPropertyList 方法获取当前 Model 的所有属性. 调用 property_getName 获取属性名称. 根据属性名称生成 getter 方法. 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）. 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@interface NSObject (KeyValues)+(id)objectWithKeyValues:(NSDictionary *)aDictionary;-(NSDictionary *)keyValuesWithObject;@end#import "NSObject+KeyValues.h"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation NSObject (KeyValues)//字典转模型+(id)objectWithKeyValues:(NSDictionary *)aDictionary&#123; id objc = [[self alloc] init]; for (NSString *key in aDictionary.allKeys) &#123; id value = aDictionary[key]; /*判断当前属性是不是Model*/ objc_property_t property = class_getProperty(self, key.UTF8String); unsigned int outCount = 0; objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount); objc_property_attribute_t attribute = attributeList[0]; NSString *typeString = [NSString stringWithUTF8String:attribute.value]; if ([typeString isEqualToString:@"@\"TestModel\""]) &#123; value = [self objectWithKeyValues:value]; &#125; /**********************/ //生成setter方法，并用objc_msgSend调用 NSString *methodName = [NSString stringWithFormat:@"set%@%@:",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]]; SEL setter = sel_registerName(methodName.UTF8String); if ([objc respondsToSelector:setter]) &#123; ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value); &#125; free(attributeList); &#125; return objc;&#125;//模型转字典-(NSDictionary *)keyValuesWithObject&#123; unsigned int outCount = 0; objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount); NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = propertyList[i]; //生成getter方法，并用objc_msgSend调用 const char *propertyName = property_getName(property); SEL getter = sel_registerName(propertyName); if ([self respondsToSelector:getter]) &#123; id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter); /*判断当前属性是不是Model*/ if ([value isKindOfClass:[self class]] &amp;&amp; value) &#123; value = [value keyValuesWithObject]; &#125; /**********************/ if (value) &#123; NSString *key = [NSString stringWithUTF8String:propertyName]; [dict setObject:value forKey:key]; &#125; &#125; &#125; free(propertyList); return dict;&#125;@end 使用：123456789-(void)keyValuesTest&#123; TestModel *model = [TestModel objectWithKeyValues:dictionary]; NSLog(@"name is %@",model.name); NSLog(@"son name is %@",model.son.name); NSDictionary *dict = [model keyValuesWithObject]; NSLog(@"dict is %@",dict);&#125; 注意： 在NSObject中添加类方法，其中的self指的是TestModel这个类。 objc_property_t具有两个属性，name和attribute。调用property_getAttribute将返回attribute的字符串。调用property_copyAttributeList则将字符串切分，返回一个objc_property_attribute_t类型的指针，outCount返回了属性的数量。 outCount使用了指向指针的指针的方式，使没有返回outCount的情况下，修改了outCount的值。 例：1234567891011121314151617181920- (NSArray *)scanBeginStr:(NSString *)beginstr endStr:(NSString *)endstr inText:(NSMutableString * *)textPointer&#123; NSRange range1,range2; NSUInteger location =0,length=0; range1.location = 0; NSMutableString *text = *textPointer; NSMutableArray *rangeArray = [NSMutableArray array]; while (range1.location != NSNotFound) &#123; range1 = [text rangeOfString:beginstr]; range2 = [text rangeOfString:endstr]; if (range1.location != NSNotFound) &#123; location = range1.location; length = range2.location - range1.location - 1; if (length &gt; 5000)break; [text replaceOccurrencesOfString:beginstr withString:@"" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)]; [text replaceOccurrencesOfString:endstr withString:@"" options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)]; &#125; [rangeArray addObject:@&#123;@"location":@(location),@"length":@(length)&#125;]; &#125; return rangeArray;&#125; 使用：通过&amp;取指针的地址1NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText]; 自动归档原理归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：123456789101112- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeObject:self.ID forKey:@"ID"];&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; self.ID = [aDecoder decodeObjectForKey:@"ID"]; self.name = [aDecoder decodeObjectForKey:@"name"]; &#125; return self;&#125; 如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题： 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量. 使用 ivar_getName 方法获取成员变量的名称. 通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）. 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// TestModel 头文件@interface TestModel : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) NSNumber *age;@property (nonatomic, copy) NSNumber *phoneNumber;@property (nonatomic, copy) NSNumber *height;@property (nonatomic, strong) NSDictionary *info;@property (nonatomic, strong) TestModel *son;@end#import "TestModel.h"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation TestModel- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; // 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法 // 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值 // 所以这里不需要再另外处理成员变量名称的“_”前缀 id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125; free(vars);&#125;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; free(vars); &#125; return self;&#125;@end 注意自动归档由于用到的都是与 object 有关的 encode ,decode 方法。因此 model 中就不能存在非 object 类型，比如 int 就要变为 NSNumber （注意，NSNumber 类型不能直接做加减运算）。 使用： 123456789101112-(void)keyedArchiverTest&#123; TestModel *model = [TestModel objectWithKeyValues:dictionary]; NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject; path = [path stringByAppendingPathComponent:@"test"]; [NSKeyedArchiver archiveRootObject:model toFile:path]; TestModel *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; NSLog(@"m.name is %@",m.name); NSLog(@"m.son name is %@",m.son.name);&#125; 动态方法解析与消息转发原理消息转发的大致过程如图： 当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过 class_addMethod 函数动态地添加方法，消息得到处理，此流程完毕. resolveInstanceMethod: 方法返回 NO 时，就会进入 forwardingTargetForSelector: 方法，这是 Runtime 给我们的第二次机会，用于指定响应这个 selector 的对象。返回nil，进入下一步；返回某个对象，则会调用该对象的方法. 若 forwardingTargetForSelector: 返回的是nil，则我们首先要通过 methodSignatureForSelector: 来指定方法签名。 methodSignatureForSelector 方法返回nil，表示不处理，若返回方法签名，则会进入下一步. 当 methodSignatureForSelector: 方法返回方法签名后，就会调用 forwardInvocation: 方法，我们可以通过 NSInvocation 对象做很多处理，比如修改实现方法，修改响应对象等. 如果到最后，消息还是没有得到响应，程序就会crash. 三步的流程为 增加这个方法 使用其他对象调用这个方法 任意对象调用任意方法 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#import "Monkey.h"#import "Bird.h"#import &lt;objc/runtime.h&gt;@implementation Monkey-(void)jump&#123; NSLog(@"monkey can not fly, but! monkey can jump");&#125;+(BOOL)resolveInstanceMethod:(SEL)sel&#123; /* 如果当前对象调用了一个不存在的方法 Runtime会调用resolveInstanceMethod:来进行动态方法解析 我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作 返回NO，则进入下一步forwardingTargetForSelector: */ if(sel == @selector(fly))&#123; class_addMethod(self, sel, class_getMethodImplementation(self, sel_registerName("jump")), "v@:"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;-(id)forwardingTargetForSelector:(SEL)aSelector&#123; /* 在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会 通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象 返回nil则进步下一步forwardInvocation: */ #if 0 return nil;#else return [[Bird alloc] init];#endif&#125;-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; /* 获取方法签名进入下一步，进行消息转发 */ return [NSMethodSignature signatureWithObjCTypes:"v@:"];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; /* 消息转发 */ return [anInvocation invokeWithTarget:[[Bird alloc] init]];&#125;@end 其中 &quot;v@:&quot; 表示返回值和参数,这个符号涉及Type Encoding以及关于type encodings的理解–runtime programming guide。其中 class_addMethod 具体的使用方式可以参见下面一节。 一般来说可以使用method_getTypeEncoding()获取更详细的Type_Encoding，代替手动的 输入的 v@:。下面例子中也会用到。 其中v表示void返回类型，@表示参数id(self)，：表示SEL(_cmd)。@:是必须要有的。后面可以接入参类型。 举个例子：&quot;i@:@&quot;i表示返回值类型int@：和上面意义相同@最后一个@表示有一个入参，是id类型。 NSInvocation 使用详见 API使用 转发与多继承转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。 这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。 消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。 Runtime-动态创建类添加属性和方法12345678910111213141516171819202122232425262728293031323334353637- (void)createClass&#123; Class MyClass = objc_allocateClassPair([NSObject class], "myclass", 0); //添加一个NSString的变量，第四个参数是对齐方式，第五个参数是参数类型 if (class_addIvar(MyClass, "itest", sizeof(NSString *), log2(sizeof(NSString *)), @encode(NSString *))) &#123; NSLog(@"add ivar success"); &#125; //myclasstest是已经实现的函数，"v@:"这种写法见type encoding class_addMethod(MyClass, @selector(myclasstest:), (IMP)myclasstest, "v@:"); //注册这个类到runtime系统中就可以使用他了 objc_registerClassPair(MyClass); //生成了一个实例化对象 id myobj = [[MyClass alloc] init]; NSString *str = @"asdb"; //给刚刚添加的变量赋值 // object_setInstanceVariable(myobj, "itest", (void *)&amp;str);在ARC下不允许使用 [myobj setValue:str forKey:@"itest"]; //调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息 [myobj myclasstest:10];&#125;//这个方法实际上没有被调用,但是必须实现否则编译都不能通过- (void)myclasstest:(int)a&#123; &#125;//调用的是这个方法static void myclasstest(id self, SEL _cmd, int a) //self和_cmd是必须的，在之后可以随意添加其他参数&#123; Ivar v = class_getInstanceVariable([self class], "itest"); //返回名为itest的ivar的变量的值 id o = object_getIvar(self, v); //成功打印出结果 NSLog(@"%@", o); NSLog(@"int a is %d", a);&#125; Method Swizzling此部分参考自Objective-C的方法替换、Objective-C Runtime等系列文章 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;objc/runtime.h&gt; @implementation UIViewController (Tracking) + (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aClass = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); // When swizzling a class method, use the following: // Class aClass = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(aClass, originalSelector); // Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;); &#125; #pragma mark - Method Swizzling - (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", self); &#125; @end 原理概述在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图 通过Swizzling需要实现的是偷换selector的IMP，如下图所示： 实现过程上面的代码通过添加一个Tracking类别到UIViewController类中，将UIViewController类的viewWillAppear:方法和Tracking类别中xxx_viewWillAppear:方法的实现相互调换。Swizzling 应该在+load方法中实现，因为+load是在一个类最开始加载时调用。dispatch_once是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。 实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉UIViewController中的viewWillAppear:方法。这两种情况要区别对待。 对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(xxx_viewWillAppear:)，然后将复写的方法替换为原先的实现(viewWillAppear:). 12345BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); class_addMethod将本来不存在于被操作的Class里的swizzledMethod的实现添加在被操作的Class里,并使用originalSelector作为其选择子。如果发现方法已经存在，会失败返回。 通过上一篇runtime原理的分析，class_addMethod应该是先在类的method数组里找是否有这个SEL,如果没有就添加一个method_t。 如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:12345if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); addMethod会让当前类的方法(IMP)指向新的实现(SEL)，使用replaceMethod再将新的方法(IMP)指向原先的实现(SEL)。现在通过旧方法SEL来调用，就会实现新方法的IMP，通过新方法的SEL来调用，就会实现旧方法的IMP。 如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过method_exchangeImplementations直接交换两个method_t的IMP:123else &#123; method_exchangeImplementations(originalMethod, overrideMethod);&#125; 所以本例中由于viewWillAppear:已经在UIViewController中实现过了，所以，class_addMethod失败，通过method_exchangeImplementations达到交换实现。如果要通过class_addMethod添加，需要自定义一个View继承UIViewController，再在这个类中替换viewWillAppear:。 如果类中没有想被替换实现的原方法时，class_replaceMethod相当于直接调用class_addMethod向类中添加该方法的实现。 method_exchangeImplementations方法做的事情与如下的原子操作等价：1234IMP imp1 = method_getImplementation(m1);IMP imp2 = method_getImplementation(m2);method_setImplementation(m1, imp2);method_setImplementation(m2, imp1); 直接设置了method:m1,m2的IMP，简单暴力。 对于注释了的这几行:12345// When swizzling a class method, use the following:// Class aClass = object_getClass((id)self);// ...// Method originalMethod = class_getClassMethod(aClass, originalSelector);// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector); object_getClass((id)self) 与 [self class] 返回的结果类型都是 Class,但前者为元类,后者为其本身,因为此时 self 为 Class 而不是实例.注意 [NSObject class] 与 [object实例 class] 的区别： 1234567+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125; object_getClass()方法返回对象的isa。 最后，xxx_viewWillAppear:方法的定义看似是递归调用引发死循环，其实不会的。因为[self xxx_viewWillAppear:animated]消息会动态找到xxx_viewWillAppear:方法的实现，而它的实现已经被我们与viewWillAppear:方法实现进行了互换，所以这段代码不仅不会死循环，如果你把[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]反而会引发死循环。 Demo 详见RuntimeLearn 危险性要在 load 方法中Method swizzling不是原子性操作。如果在+load方法里面写，是没有问题的，但是如果写在+initialize方法中就会出现一些奇怪的问题。并且在 +initialize 中写也有可能被覆盖。 如果不写在 +load 中可能会因为多线程难以保证另一个线程中不会同时调用交换方法，从而导致程序不按预期执行。 Copy父类的方法带来 hook 父类失效的问题如果 hook 了为重写父类方法的子类的方法。那么会添加父类的方法到子类中。如果父类中也hook了该方法，就可能会产生问题。 如果父类的分类的 load 方法的先执行的时候，先发生替换，子类再替换，那么没有问题。 但是如果子类的分类的 load 方法先执行的时候，那么子类先 hook 了父类方法，父类再 hook 自己的方法。那么子类调用的时候就不会走父类实现 hook 添加的各种处理了。 主要原因就是我们能保证父类的 load 方法先于子类的 load 方法执行。但是不能保证父类的分类的 load 方法先于子类的分类的 load 方法先执行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime原理笔记]]></title>
    <url>%2F2016%2F08%2F22%2Fruntime%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：Objective-C Runtime Runtime基础在Objective-C中，使用[receiver message]语法并不会马上执行receiver对象的message方法的代码，而是向receiver发送一条message消息。其实[receiver message]被编译器转化为: 1id objc_msgSend ( id self, SEL op, ... ); 现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。 idobjc_msgSend第一个参数类型为id,它是一个指向objc_object结构体指针,它包含一个Class isa指针(完整的定义在objc_private.h中)：12345typedef struct objc_object *id;struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 所有对象都是继承于 objc_object 的，所以所有对象都有 isa 指针，即都有一个 objc_class 结构体的指针。（注意，这和 superclass 是不同的） SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型.selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1typedef struct objc_selector *SEL; Class之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：1typedef struct objc_class *Class; 这个结构体在runtime.h中有定义:1234567891011121314struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 其中OBJC2_UNAVAILABLE表示：在objc2中这些属性已经不在此定义。 在objc2中，objc_class的完整定义在objc-runtime-new.h中：12345678910111213struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;struct objc_class : objc_object &#123; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;&#125;; 和runtime.h中的定义对比，少了许多属性，多出一个bits属性。这些属性都包含在了class_rw_t的data对象中。 注意到objc_class中也有一个isa对象(继承自objc_object)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 元类 (Meta Class)的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似[NSObject alloc]的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class)的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc]这条消息发给类对象的时候，objc_msgSend()会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 看明白这个图上面就都明白了。 class_rw_tbits 中包含了一个指向 class_rw_t 结构体的指针，它的定义如下:12345678910struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols;&#125; 其中，const class_ro_t *ro包含了所有成员变量的一维数组以及各个基础的(base)属性、方法和协议method_array_t methods、property_array_t properties、protocol_array_t protocols则包含了所有拓展的属性方法和协议。注意：这里的属性只是getset方法，不包含成员变量。 基础的属性和方法和拓展的方法没有存在一个对象中，所以不能在 category 中添加成员变量。但是完全用 runtime 创建的类是可以动态添加的。 具体如何应用可看下一篇。 部分类的声明这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。 class_ro_t:12345678struct class_ro_t &#123; ... method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; property_list_t *baseProperties; ...&#125;; method_tmethod_list_t和method_array_t内都是method_t类型: 12345struct method_t &#123; SEL name; const char *types; IMP imp;&#125; 方法名类型为SEL 方法类型types是个char指针，其实存储着方法的参数类型和返回值类型。 imp指向了方法的实现，本质上是一个函数指针 ivar_tivar_list_t 内是ivar_t类型: 12345struct ivar_t &#123; int32_t *offset; const char *name; const char *type;&#125; 访问私有变量可以通过 kvc 和 runtime 的 class_getInstanceVariable，两种方式获取。 property_tproperty_list_t和property_array_t内都是property_t类型: 1234struct property_t &#123; const char *name; const char *attributes;&#125;; protocol_tprotocol_list_t和protocol_array_t内都是protocol_t类型:1234567891011struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags;&#125;; Ivar,Method,Category,objc_property_t外部可以通过一系列的方法获得类的信息，诸如：class_copyIvarList,class_copyPropertyList等方法，可以获得类的实例变量和属性，对应的类型是Ivar、objc_property_t，它们分别是ivar_t,property_t类型的指针。 1234typedef struct method_t *Method;typedef struct ivar_t *Ivar;typedef struct category_t *Category;typedef struct property_t *objc_property_t; 消息几种函数派发方式函数的派发方式，常见的有三种： 直接派发 函数表派发 消息派发 直接派发速度最快，例如 c++ 中的函数调用，编译时直接拿到函数的地址。 函数表派发回味每一个类维护一个函数表，大部分语言称之为虚函数表，里面记录着所有的函数，如果父类函数被 override 的话，表里面只保存被 override 之后的函数。运行时会根据这个表去决定要调用的函数。如 Java。 c++ 中要在父类方法中用 virtual 修饰，才会将直接派发转为函数表派发，实现多态。Java 可以通过 final 修饰指定为直接派发。 消息派发就是 OC 的实现方式。 objc_msgSend函数看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤： 检测这个 selector 是不是要忽略的。比如有了垃圾回收就不理会 retain, release 这些函数了。 检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil对象执行任何一个方法不会 Crash，因为会被忽略掉。 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。 如果 cache 找不到就找一下方法分发表。 如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。 如果还找不到就要开始进入动态方法解析了. 编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有Super的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有stret的函数。 当我们调用[super selector] 时，Runtime 会调用 objc_msgSendSuper方法，objc_msgSendSuper 方法有两个参数，super 和 op，Runtime 会把 selector 方法选择器赋值给 op。而 super 是一个 objc_super 结构体指针，objc_super 结构体定义如下：1struct objc_super &#123; id receiver; Class class; &#125;; 需要注意的是：这里的receiver仍然是self本身。当我们想通过[super class]获取超类时，编译器只是将指向self的id指针和class的SEL传递给了objc_msgSendSuper函数，因为只有在NSObject类才能找到class方法，然后class方法调用object_getClass()，接着调用objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向self的id指针，与调用[self class]相同，所以我们得到的永远都是self的类型。 举个栗子，问下面的代码输出什么： 123456789101112@implementation Son : Father- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); &#125; return self;&#125;@end 答案是全部输出 Son. 当调用 [super class] 时，会转换成 objc_msgSendSuper 函数： 先构造 objc_super 结构体，结构体第一个成员就是 self。第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)). 去 Father 这个类里去找 - (Class)class，没有，然后去 NSObject 类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用，此时已经和 [self class] 调用相同了，所以两个输出结果都是 Son。 这里调用class只是举例，所有调用super的方法，最后都变成了self的调用。 其实就是即使是 [super class] 调用的是父类的 class 方法，但是接收对象永远还是 self objc_super -&gt; receiver 永远是子类 Category 的实现原理概述runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:123456void _objc_init(void)└──const char \*map_2_images(...) └──const char \*map_images_nolock(...) └──void _read_images(header_info **hList, uint32_t hCount) └──static void remethodizeClass(Class cls) └──static void attachCategories(Class cls, category_list *cats, bool flush_caches) Category 相关的数据结构首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125;; 从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。 处理 Category对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:123456789101112131415161718192021222324static void attachCategories(Class cls, category_list *cats, bool flush_caches) &#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls);&#125; 首先，通过 while 循环，我们遍历所有的 category，也就是参数 cats 中的 list 属性。对于每一个 category，得到它的方法列表 mlist 并存入 mlists 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。 编译好之后 ivar 的结构就已经固定了，可以通过偏移地址来直接获取成员变量。但是对于方法，它在 Macho-O 中只保存了 class_ro_t 的部分，在 runtime 初始化的时候，会通过 runtime 到 mach-o 中的 __data,_objc_catlist 中取出所有的分类信息，然后将分类中的方法属性和协议插到 class_rw_t 的数组中（class_rw_t 应该是保存在堆上的），它的各个属性是指向 data 段的。 因为 class_rw_t 是堆上的，它的属性方法列表是一个二维数组，可以将 data 段中的各个方法数组添加到这个二维数组中，并且 class_addMethod 也可以用相同的方法添加到二维数组里，所以方法是可以动态添加的。 但是成员变量是保存在 class_ro_t 中的，它是保存在 data 段中有固定的空间的，无法扩大。因此成员变量无法动态添加。 另外需要注意一点，不是所有分类都是放到 __data,_objc_catlist 中的。如果是自己的类的分类，编译后直接就把方法和原始类的方法丢在一起了。如果是其他动态库的分类，比如给 UIViewController 创建一个分类，那么是会保存在 __data,_objc_catlist 段中，通过 runtime 动态添加给 UIViewController的。 在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:12auto rw = cls-&gt;data();rw-&gt;methods.attachLists(mlists, mcount); rw 是一个 class_rw_t类型的结构体指针。根据 runtime 中的数据结构，它有一个 methods 结构体成员，并从父类继承了 attachLists 方法，用来合并 category 中的方法:123456789void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0]));&#125; 需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。 load 方法的执行+load 方法在 Class 和 Category 中都会有一个数组保存。在 runtime load_image 的时候，会一次调用 Class 和 Category 的 load 方法。 load 方法的调用顺序是先调用父类的再调用子类的，先调用 Class 的，再调用 Category 的。 和 +initialize 方法的异同 +load 方法会被特殊对待全部执行，而 +initialize 方法则只会像普通方法一样会被分类覆盖。 +initialize 方法在类传递第一个消息之前执行。+load 在分类添加到 runtime 时执行。 +initialize 方法先执行父类方法，再执行子类方法。+load 也是这样 问题 什么是消息机制？ id 是个什么类型？ isa 是个什么类型？ objc_class 中的 isa 指向什么？有什么用？ 子类，父类，NSObject，之间 super class 与 isa 指向的关系图是怎样？ objc_msgSend 的执行过程？ 为什么调用 [super class] 还是返回的还是 self 的类名？ category 为什么只能存方法，不能存实例变量？ category 会替换原来的方法吗？ 动态方法解析与消息转发的三步各是什么作用？ 转发和多继承有什么关系？ runtime的一篇较好的参考资料]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios核心动画]]></title>
    <url>%2F2016%2F08%2F16%2Fios%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画相关的总结 视图动画UIView动画首尾式动画执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在 [UIView beginAnimations:nil context:nil] 和 [UIView commitAnimations] 之间。 常见方法： 1234567891011121314// 动画开始时调用+ (void)setAnimationWillStartSelector:(SEL)selector// 动画结束时调用+ (void)setAnimationDidStopSelector:(SEL)selector// 动画的持续时间+ (void)setAnimationDuration:(NSTimeInterval)duration// 动画延迟delay秒后再开始+ (void)setAnimationDelay:(NSTimeInterval)delay// 动画加速减速效果+ (void)setAnimationCurve:(UIViewAnimationCurve)curve// 动画自动反向回到原来位置+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses// 动画重复次数+ (void)setAnimationRepeatCount:(float)repeatCount block 动画1234// 普通的动画+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;// 带阻尼的动画+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 示例12345678//首尾式动画[UIView beginAnimations:nil context:nil];//设置动画执行时间[UIView setAnimationDuration:2.0];//设置动画执行完毕调用的事件[UIView setAnimationDidStopSelector:@selector(didStopAnimation)];self.customView.center=CGPointMake(200, 300);[UIView commitAnimations]; 注意点： UIView 的动画在开始的时候，它的 frame 就已经到了目的位置，运动的只是 UIView 的 layer。因此，在 UIView 执行动画的时候，运动中的视图是无法相应点击事件的。因此，如果要视图能够相应点击事件，就需要在寻找点击响应者的时候，判断点击的点是否在 UIView 的 layer 的 frame 里。代码如下： 123456789101112131415161718// 设置动画[UIView animateKeyframesWithDuration:20 delay:0 options:UIViewKeyframeAnimationOptionAllowUserInteraction animations:^&#123; self.btn.frame = CGRectMake(100, 300, 100, 100); &#125; completion:^(BOOL finished) &#123; NSLog(@"xly--%@",@"finished"); ret = YES; &#125;];// 点击事件寻找第一响应者的方法。判断点击坐标 p 是否在 self.layer.presentationLayer 中- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; if (self.animationAllowUserInteraction) &#123; CGPoint p = [self convertPoint:point toView:self.superview]; if ([self.layer.presentationLayer hitTest:p]) &#123; return YES; &#125; &#125; return [super pointInside:point withEvent:event];&#125; UIView 关键帧动画关键帧动画使用 block 执行。包含了几个必要属性： 12345[UIView animateKeyframesWithDuration:1 delay:0.5 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^&#123; self.imageView.frame = CGRectMake(0, 0, 100, 100);&#125; completion:^(BOOL finished) &#123; NSLog(@"结束了");&#125;]; 既然是关键帧动画，那么肯定是能增加帧的。在原本执行动画的方法中通过增加帧： 12345678910111213[UIView animateKeyframesWithDuration:1 delay:0.5 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^&#123; [UIView addKeyframeWithRelativeStartTime:0.3 relativeDuration:0.3 animations:^&#123; self.imageView.frame = CGRectMake(0, 0, 100, 100); &#125;]; [UIView addKeyframeWithRelativeStartTime:0.3 relativeDuration:0.3 animations:^&#123; self.imageView.frame = CGRectMake(100, 100, 200, 200); &#125;]; &#125; completion:^(BOOL finished) &#123; NSLog(@"结束了");&#125;]; CALayer 关键帧动画CALayer 的动画其实可以用 UIView 的动画来代替。不过 CALayer 的关键帧动画可以让视图沿着指定路径移动 参数形式123456789101112131415//根据values移动的动画CAKeyframeAnimation *catKeyAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"];CGPoint originalPoint = self.catImageView.layer.frame.origin;CGFloat distance = 50;NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(originalPoint.x + distance, originalPoint.y + distance)];NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(originalPoint.x + 2 * distance, originalPoint.y + distance)];NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(originalPoint.x + 2 * distance, originalPoint.y + 2 * distance)];NSValue *value4 = [NSValue valueWithCGPoint:originalPoint];catKeyAnimation.values = @[value4, value1, value2, value3, value4];catKeyAnimation.duration = 2;catKeyAnimation.repeatCount = MAXFLOAT;catKeyAnimation.removedOnCompletion = NO;[self.catImageView.layer addAnimation:catKeyAnimation forKey:nil]; 路径形式1234567891011121314151617181920212223242526-(void)pathAnimation2 &#123; //创建path UIBezierPath *path = [UIBezierPath bezierPath]; //设置线宽 path.lineWidth = 3; //线条拐角 path.lineCapStyle = kCGLineCapRound; //终点处理 path.lineJoinStyle = kCGLineJoinRound; //多条直线 [path moveToPoint:(CGPoint)&#123;0, SCREEN_HEIGHT/2-50&#125;]; [path addLineToPoint:(CGPoint)&#123;SCREEN_WIDTH/3, SCREEN_HEIGHT/2-50&#125;]; [path addLineToPoint:(CGPoint)&#123;SCREEN_WIDTH/3, SCREEN_HEIGHT/2+50&#125;]; [path addLineToPoint:(CGPoint)&#123;SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2+50&#125;]; [path addLineToPoint:(CGPoint)&#123;SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2-50&#125;]; [path addLineToPoint:(CGPoint)&#123;SCREEN_WIDTH, SCREEN_HEIGHT/2-50&#125;];// [path closePath]; CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@"position"]; anima.path = path.CGPath; anima.duration = 2.0f; anima.fillMode = kCAFillModeForwards; anima.removedOnCompletion = NO; anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; [_demoView.layer addAnimation:anima forKey:@"pathAnimation"];&#125; 转场动画 转场动画就是就是把下一个显示的时刻的界面截了个图，然后做转场。 示例： 1234567891011121314// 先设置下一个场景self.iconView.image=[UIImage imageNamed: [NSString stringWithFormat:@"%d.jpg",self.index]];//创建核心动画CATransition *ca=[CATransition animation];//告诉要执行什么动画//设置过度效果ca.type=@"cube";//设置动画的过度方向（向左）ca.subtype=kCATransitionFromLeft;//设置动画的时间ca.duration=2.0;//添加动画[self.iconView.layer addAnimation:ca forKey:nil];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer学习小结]]></title>
    <url>%2F2016%2F08%2F12%2FCALayer%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这两天想大致学习下animation的使用方法。看了文顶顶的ios开发UI篇专题，写的很好，学习了很多。再摘录部分，以作备忘。 CALayer简介简介UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。 基本属性通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。1234567891011121314151617181920212223242526//设置边框的宽度为20self.customView.layer.borderWidth=20;//设置边框的颜色(borderColor是CGColor类型)self.customView.layer.borderColor=[UIColor greenColor].CGColor;//设置layer的圆角self.customView.layer.cornerRadius=20;//设置超过子图层的部分裁减掉self.iconView.layer.masksToBounds=YES;//在view的图层上添加一个image，contents表示接受内容self.customView.layer.contents=(id)[UIImage imageNamed:@"cat"].CGImage;//设置阴影的颜色self.customView.layer.shadowColor=[UIColor blackColor].CGColor;//设置阴影的偏移量，如果为正数，则代表为往右边偏移self.customView.layer.shadowOffset=CGSizeMake(15, 5);//设置阴影的透明度(0~1之间，0表示完全透明)self.customView.layer.shadowOpacity=0.6;//通过uiview设置（2D效果）self.customView.transform=CGAffineTransformMakeTranslation(0, -100);//通过layer来设置（3D效果,x，y，z三个方向）self.iconView.layer.transform=CATransform3DMakeTranslation(100, 20, 0);//旋转self.iconView.layer.transform=CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5); 注意，这里的颜色不是 UIColor 类型，而是 CGColor 类型。需要使用 [UIColor redColor].CGColor 的方式获取，而不是使用强制转型把 UIColor 转为 CGColor。 position，anchorPoint，bounds 以及 frame 的概念 frame: 用来描述自己在父视图的位置，即 x y 是相对于父视图的起点的。 bounds: 描述当前视图的左上角的相对子视图的坐标，以及视图大小的。一般 bounds.origin 为 (0, 0) ，如果把它改为 (-50, 0)，就表示左上角的坐标为 (-50, 0)，现在子视图相对的原点坐标就在左上角右边 50 的地方。所以相当于把所有子视图向右移动 50. position:设置CALayer在父层中的位置，这个位置会和锚点重合。 anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5）。layer 的缩放和旋转，都是以 anchorPoint 为原点的。 position，anchorpoint 和 bounds 共同决定了视图的 frame。一般情况下，frame 的大小等于 bounds 的大小，但是如果视图旋转了，frame 会变为旋转视图的外界矩形的大小。 如果我们想移动一个视图的所有子视图，可以修改 bonuds.orgin。不过我们也可以在视图上添加一个 contentView，然后移动它的 frame。 隐式动画每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。 常见的动画属性： bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画 backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画 position：用于设置CALayer的位置。修改这个属性会产生平移动画 创建图层12345678910111213141516171819202122- (void)viewDidLoad&#123; [super viewDidLoad]; //创建一个layer CALayer *Mylayer=[CALayer layer]; //设置layer的属性 Mylayer.bounds=CGRectMake(100, 100, 100, 100); Mylayer.position=CGPointMake(100, 100); //设置需要显示的图片 Mylayer.contents=(id)[UIImage imageNamed:@"me"].CGImage; //设置圆角半径为10 Mylayer.cornerRadius=10; //如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果 Mylayer.masksToBounds=YES; //设置边框 Mylayer.borderWidth=3; Mylayer.borderColor=[UIColor brownColor].CGColor; //把layer添加到界面上 [self.view.layer addSublayer:Mylayer];&#125; 总结对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以 UIView的transform属性transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是CGAffineTransform类型的。 transform结构transform是一个CGAffineTransform类型，结构如下： 1234struct CGAffineTransform &#123; CGFloat a, b, c, d; CGFloat tx, ty;&#125;; CGAffineTransform实际上是一个矩阵 123| a, b, 0 || c, d, 0 || tx, ty, 1 | 由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。 坐标变换过程： 12345678 | a, b, 0 |&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c, d, 0 | | tx, ty, 1 | ==&gt;xn=ax+cy+tx;yn=bx+dy+ty; 这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。 transform方法在CGAffineTransform的生成函数中，大多是两两对应的，一个带make字样，一个不带。带make字样的是直接生成一个新的CGAffineTransform，不带make字样的则是在一个CGAffineTransform的基础上生成新的。函数返回值均是CGAffineTransform类型。 多个CGAffineTransform对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。 scale实现的是放大和缩小: 123CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)；CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)； 生成新的transform相当于将t&#39; = [sx ，0 ，0，sy ，0， 0]这六个参数代入矩阵中,即改变a和d。 rotate实现的是旋转： 123CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)CGAffineTransformMakeRotation(CGFloat angle)； angle为角度，angle=π则旋转180度。矩阵的六个参数为t&#39; = [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]； translate实现的是平移： 1234CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)；CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)； 矩阵的六个参数为t&#39; = [1，0，0，1，tx，ty] ；代入公式，xn=x+tx,yn=y+ty 复原1view.transform＝CGAffineTransformIdentity; 上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。CGAffineTransformIdentity将view从当前状态复原回view最初始的状态。 一个技巧。如果使用 AutoLayout 的视图要添加动画，一般我们会把约束拖到代码中，然后在动画前修改约束，在动画的 block 中调用其父控件的 layoutIfNeeded。 还有一种更好的办法，在动画的 block 中直接用 view 的 transform 属性。 设置 transform 进行动画和 设置 frame 动画的区别视图的 frame 其实是由视图的 bounds，position，anchorpoint 以及 transform 共同决定的。修改 frame 其实就是修改 bounds 和 position 的值。 一般而言，最好使用 transform 进行动画，因为有一种情况是，如果该视图具有子视图，并且要进行缩放动画。那么执行动画的时候，动画虽然有一个过程，但其实从动画一开始，frame就已经修改了。如果直接设置frame，那么开始的时候，子视图就会按变化后的frame来重新布局，而不是跟随父视图一起慢慢变化。 而 transform 动画的话，不会调用控件的 layoutsubview 方法，整个过程更像是把整个视图按比例缩放，子视图会跟着父视图一起缩放。 CALayer的transform属性transform结构CALayer的transform是一个CATransform3D结构： 1234567struct CATransform3D&#123; CGFloat m11, m12, m13, m14; CGFloat m21, m22, m23, m24; CGFloat m31, m32, m33, m34; CGFloat m41, m42, m43, m44;&#125;; 有别于CGAffineTransform,CATransform3D是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。 transform方法CALayer的transform方法和View的transform基本一致。举几点不同： CALayer由于有z轴，因此对不同图层使用CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。 由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变m34(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。m34的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。 如果想要直接改变矩阵里的值，可以先使用CATransform3DIdentity的方式，初始化一个CATransform3D实例，然后再赋值。 CAShapeLayerCAShapeLayer继承自CALayer。CAShapeLayer是在坐标系内绘制贝塞尔曲线的，通过绘制贝塞尔曲线，设置shape(形状)的path(路径)，从而绘制各种各样的图形以及不规则图形。因此，使用CAShapeLayer需要与UIBezierPath一起使用。 创建1CAShapeLayer *layer = [CAShapeLayer layer]; 属性12345678910111213141516// 要呈现的路径@property(nullable) CGPathRef path;// 填充色@property(nullable) CGColorRef fillColor;// 填充规则。值有两种，非零和奇偶数，但默认是非零值。@property(copy) NSString *fillRule;// 设置描边色@property(nullable) CGColorRef strokeColor;// 绘制边线轮廓路径的子区域。该值必须在[0,1]范围，0代表路径的开始，1代表路径的结束。在0和1之间的值沿路径长度进行线性插值。strokestart默认为0，strokeend默认为1。@property CGFloat strokeStart;@property CGFloat strokeEnd;// 线的宽度@property CGFloat lineWidth;// 端点和交点的显示类型@property(copy) NSString *lineCap;@property(copy) NSString *lineJoin; 创建贝塞尔曲线这里只是给了几个图形的基本画法，还有更多图形的画法可以稍后查看 12345678910//绘制矩形UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 100, 100)];//绘制圆形路径UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 100, 100)];//绘制自带圆角的路径UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, 100, 100) cornerRadius:30];//指定矩形某一个角加圆角（代码示例为左上角）UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, 100, 100) byRoundingCorners:UIRectCornerTopLeft cornerRadii:CGSizeMake(50, 50)];self.layer.path = path.CGPath; 曲线动画曲线动画的主要思想是对 layer 的 strokeEnd 属性做 CABasicAnimation 动画： 12345678910111213141516UIBezierPath *path = [UIBezierPath bezierPath];//起始点[path moveToPoint:CGPointMake(50, 667/2)];//结束点、两个控制点[path addCurveToPoint:CGPointMake(330, 667/2) controlPoint1:CGPointMake(125, 200) controlPoint2:CGPointMake(185, 450)];CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];animation.duration = 5;animation.fromValue = @(0);animation.toValue = @(1);animation.repeatCount = 100;CAShapeLayer *layer = [self createShapeLayerNoFrame:[UIColor clearColor]];layer.path = path.CGPath;layer.lineWidth = 2.0;[layer addAnimation:animation forKey:@"strokeEndAnimation"]; Mask属性基本使用layer的大小和形状是受到mask遮罩层的影响的，可以通过赋给mask层一个新layer，来实现改变layer形状的效果。mask图层的 Color 属性是无关紧要的（mask不是透明的部分，layer能显示出原来的颜色），真正重要的是图层的轮廓。 下面的例子中，为一个图片设置了圆形的蒙版。蒙版外的部分是透明的，该部分图片不予显示。 123456789- (CALayer *)maskRadiusCorner:(UIImageView *)imageView&#123; //CAShapeLayer 是 CALayer 的子类，通过UIBezierPath来绘制它的形状 CAShapeLayer *masklayer = [CAShapeLayer layer]; //获取宽度 masklayer.frame = imageView.bounds; //注意bezierPathWithArcCenter的设置 masklayer.path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(imageView.frame.size.width/2, imageView.frame.size.height/2) radius:imageView.frame.size.width/2 startAngle:0 endAngle:2*M_PI clockwise:YES].CGPath; return masklayer;&#125; 效果图如下： 再举一个例子，观察下图的实现方式： 原理是将彩色的图片添加在灰色的图片上，对彩色的图片添加一个圆形的蒙版。圆形蒙版外的部分由于是透明的所以就不予显示，也就是下面的灰色图片。圆形蒙版内的部分由于设置了颜色，就能够显示彩色图片。 1234567891011121314151617181920212223242526272829303132/** 添加一个圆形蒙版 */- (void)addMaskLayer&#123; //创建蒙版的layer self.maskLayer = [CALayer layer]; //蒙版大小 self.maskLayer.frame = CGRectMake(0, 0, 100, 100); //随便取个颜色，只要不是透明的就行 self.maskLayer.backgroundColor = [UIColor whiteColor].CGColor; //圆形蒙版 self.maskLayer.cornerRadius = 50; //将蒙版赋给View self.colorImageView.layer.mask = self.maskLayer;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; //添加两个image self.colorImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"pic"]]; self.grayImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"gray"]]; //设置frame self.colorImageView.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height); self.grayImageView.frame = CGRectMake(0, 0, 300, 300); [self.view addSubview:self.colorImageView]; [self.view addSubview:self.grayImageView]; [self addMaskLayer];&#125; 绘制只有两个圆角的视图有些情况下，一个 button 或者 label，只要右边的两个角圆角，或者只要一个圆角。该怎么办呢？ 12345678CGRect rect = CGRectMake(0, 0, 100, 50);CGSize radio = CGSizeMake(5, 5); // 圆角尺寸UIRectCorner corner = UIRectCornerTopLeft | UIRectCornerTopRight; // 这只圆角位置UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];CAShapeLayer *masklayer = [[CAShapeLayer alloc] init]; // 创建shapelayermasklayer.frame = button.bounds;masklayer.path = path.CGPath; // 设置路径button.layer.mask = masklayer; 关于离屏渲染渲染机制CPU 计算内容交由 GPU 渲染，GPU 渲染完成后放入帧缓冲区。随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 GPU 渲染方式 On-Screen Rendering：意为当前屏幕渲染。GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering：意为离屏渲染。GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 其实非当前屏幕缓冲区的渲染都叫做离屏渲染，CPU 渲染得到 bitmap 然后交由 GPU 显示也是一种特殊的离屏渲染，此举会消耗一定的 CPU 资源。但是如果 GPU 资源紧张，同时 CPU 空闲，可以考虑如此优化，以消除 GPU 不能及时渲染导致的丢帧的影响。 所以离屏渲染不一定就是影响性能的。只是渲染方式的一种。 离屏渲染的触发 shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 其中，光栅化是把GPU的操作转到CPU上，严格意义上是”软件渲染”，将图转化为一个个栅格组成的图象。并且缓存起来，减少渲染的频度。对于基本不会变化的视图，开启光栅化有助于性能优化，但是如果内容经常变化，那么就会造成性能浪费。 为什么会产生离屏渲染当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制。 这是因为 GPU 无法在某一层渲染完成之后，再回过头来擦除/改变其中的某个部分。因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着，对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作。 视图圆角设置视图的 cornerRadius本身并不会触发离屏渲染，需要和 maskToBounds 一起设置才会产生。 一般情况下，直接设置圆角即可。 123UIView *view = [[UIView alloc] init];view.backgroundColor = [UIColor blackColor];view.layer.cornerRadius = 3.f; 但是 UILabel 例外，UILabel 如果有背景色需要设置 layer 的背景色： 1234UILabel *label = [[UILabel alloc] init];// 重点在此！！设置视图的图层背景色，千万不要直接设置 label.backgroundColorlabel.layer.backgroundColor = [UIColor grayColor].CGColor;label.layer.cornerRadius = cornerRadius; UIImageView 无法做到直接隐藏图片圆角。所以需要自己绘制出一个带圆角的图片： 123456789101112131415161718extension UIImage &#123; func kt_drawRectWithRoundedCorner(radius radius: CGFloat, _ sizetoFit: CGSize) -&gt; UIImage &#123; let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: sizetoFit) UIGraphicsBeginImageContextWithOptions(rect.size, false, UIScreen.mainScreen().scale) CGContextAddPath(UIGraphicsGetCurrentContext(), UIBezierPath(roundedRect: rect, byRoundingCorners: UIRectCorner.AllCorners, cornerRadii: CGSize(width: radius, height: radius)).CGPath) CGContextClip(UIGraphicsGetCurrentContext()) self.drawInRect(rect) CGContextDrawPath(UIGraphicsGetCurrentContext(), .FillStroke) let output = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return output &#125;&#125; 这种方式如果不做缓存，每次都会创建新的 UIImage，加重 CPU 的负担。 另外，还有一种使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View 的方式达到圆角效果的。不过这种方式也是操作 mask，会产生离屏渲染，但是效果会比直接设置圆角要好很多。 这样是把 GPU 的任务转给了 CPU 去完成。那么如果还是掉帧怎么办？ 直接让 UI 将图片切为圆角 在原来的视图上添加一个四个角有颜色中间透明的图片,遮盖到原来图片上。这样是通过混合图层的方式实现。损耗的性能会好很多。 将上面绘制圆角图片的过程放到子线程中去，绘制完成后回到主线程中。 针对上面第二点：添加一个四个角有颜色中间透明的图片。相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738@implementation UIImage (XWAddForRoundedCorner)/**提供一个在一个指定的size中绘制图片的便捷方法*/+ (UIImage *)xw_imageWithSize:(CGSize)size drawBlock:(void (^)(CGContextRef context))drawBlock &#123; if (!drawBlock) return nil; UIGraphicsBeginImageContextWithOptions(size, NO, 0); CGContextRef context = UIGraphicsGetCurrentContext(); if (!context) return nil; drawBlock(context); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;/**绘制方法的具体逻辑，遮罩图片的逻辑是绘制一个矩形，然后在绘制一个相应的圆角矩形，然后填充矩形和圆角矩形的中间部分为父视图的背景色*/+ (UIImage *)xw_maskRoundCornerRadiusImageWithColor:(UIColor *)color cornerRadii:(CGSize)cornerRadii size:(CGSize)size corners:(UIRectCorner)corners borderColor:(UIColor *)borderColor borderWidth:(CGFloat)borderWidth&#123; return [UIImage xw_imageWithSize:size drawBlock:^(CGContextRef _Nonnull context) &#123; CGContextSetLineWidth(context, 0); [color set]; CGRect rect = CGRectMake(0, 0, size.width, size.height); //绘制一个矩形，这里发-0.3是为了防止边缘的锯齿， UIBezierPath *rectPath = [UIBezierPath bezierPathWithRect:CGRectInset(rect, -0.3, -0.3)]; //绘制圆角矩形，这里的0.3是为了防止内边框的锯齿 UIBezierPath *roundPath = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, 0.3, 0.3) byRoundingCorners:corners cornerRadii:cornerRadii]; [rectPath appendPath:roundPath]; CGContextAddPath(context, rectPath.CGPath); //注意要用EOFill方式进行填充而非Fill方式 CGContextEOFillPath(context); //如下是绘制边框，原理依旧是绘制一个外边框然后根据边框宽度绘制一个内边框同样采取EOFill的方式进行填充即可 if (!borderColor || !borderWidth) return; [borderColor set]; UIBezierPath *borderOutterPath = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:cornerRadii]; UIBezierPath *borderInnerPath = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:cornerRadii]; [borderOutterPath appendPath:borderInnerPath]; CGContextAddPath(context, borderOutterPath.CGPath); CGContextEOFillPath(context); &#125;];&#125; 添加shadow的离屏渲染我们直接设置 shadow 相关属性会产生离屏渲染： 12345let layer = view.layerlayer.shadowColor = UIColor.black.cgColorlayer.shadowOpacity = 0.3layer.shadowRadius = radiuslayer.shadowOffset = CGSize(width: 0, height: -3) 只要你提前告诉CoreAnimation你要渲染的View的形状Shape,就会减少离屏渲染计算。因此，我们需要加上设置 shadowPath 的一行： 123456let layer = view.layerlayer.shadowColor = UIColor.black.cgColorlayer.shadowOpacity = 0.3layer.shadowRadius = radiuslayer.shadowOffset = CGSize(width: 0, height: -3)layer.shadowPath = [[UIBezierPathbezierPathWithRect：myView.bounds] CGPath]; 参考文档离屏渲染优化详解：实例示范+性能测试]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD队列 学习与整理]]></title>
    <url>%2F2016%2F08%2F02%2FGCD%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。 基本概念 Serial vs. Concurrent 串行 vs. 并发这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。 Synchronous vs. Asynchronous 同步 vs. 异步在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。 同步异步是对线程说的 串行并行是对队列说的 队列分类 Serial Queues 串行队列这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。 Concurrent Queues 并发队列在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。 队列类型 The main queue与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。 Global queues全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。 用户队列用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。 队列创建方式 dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。 dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);生成一个并发执行队列。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);获得全局队列(系统的队列，与并行队列类似，可以直接使用，不能指定名字)。 dispatch_queue_t queue = dispatch_get_main_queue()获得主线程队列。 提交 Job向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。 dispatch_asyncdispatch_async 函数会立即返回, block会在后台异步执行。 1234dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self goDoSomethingLongAndInvolved]; NSLog(@"Done doing something long and involved");&#125;); 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue： 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self goDoSomethingLongAndInvolved]; dispatch_async(dispatch_get_main_queue(), ^&#123; [textField setStringValue:@"Done doing something long and involved"]; &#125;);&#125;); dispatch_syncdispatch_sync 同步执行 block，函数不返回，一直等到 block 执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。 执行到 dispatch_sync 的时候，表示这个 block 必须要在当前线程立刻执行完 实际编程经验告诉我们，尽可能避免使用 dispatch_sync，嵌套使用一个串行队列时极易产生程序死锁，比如嵌套调用主线程： 注意这里死锁的很重要一个条件也因为主队列是一个串行的队列(主队列中只有一条主线程)。如果我们如下例，在并行队列中提交，则不会造成死锁： 123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"任务一"); &#125;); NSLog(@"任务二");&#125;); 原因是并行队列中任务一虽被提交仍然是在queue的队尾，在任务二之后，但是因为是并行的，所以任务一并不会一直等任务二结束才去执行，而是直接执行完。此时任务二因为任务一的结束，sync阻塞也就消除，任务二得以执行。 总结队列是串行或并发的，操作队列的函数是同步或者异步执行的（也就是在当前线程执行完返回和立即返回另开线程执行的区别）。串行队列其实就相当于加了一个资源锁，无论在多少个线程里，只有当队列中前一个元素执行完，后一个元素的代码块才能继续执行，并行队列则没有任何要求，有需要执行就立即执行。 所以： 串行队列要求队列前的必须先执行完，才能执行后面。并行队列无要求 dispatch_sync 要求当前代码块必须先执行完，才能执行后面。dispatch_async 无要求 因此，dispatch_sync 和 串行队列在一起嵌套使用时，会容易产生死锁。 示例1在主线程里的示例的四种组合的输出： 1234567for (int i = 1; i &lt; 10; i++) &#123; dispatch_(a)sync(queue, ^&#123; NSLog(@"%d___%@",i, [NSThread currentThread]); &#125;); &#125; NSLog(@"over"); 结果: 串行同步队列：运行在主线程里，先依次打印 i 后，再打印 over。 串行异步队列：先打印 over，再依次打印 i。由于是异步的，over 执行在主线程里毋庸置疑，打印 i 时，新建了一个线程。为什么是一个呢？因为串行队列，代码块依次执行。创建新线程，执行，销毁，再创建新线程的操作太耗时。所以编译器优化后，仅创建了一个新线程。 并行同步队列：运行在主线程里，先依次打印 i 后，再打印 over。现在看起来和串行同步队列一样对不对？那么什么时候才不同呢？假如你手动开了一个线程，并且在那个线程里，又运行了一遍上面的代码。串行同步队列由于有锁，执行当前代码块的时候，另一个线程处于阻塞状态，只能等到当前代码块执行完毕才能跳到另一个线程；并行同步队列没有锁，可能代码块没有执行完，由于线程的时间片用完了，就立即跳到另外一个线程上去执行了。 并行异步队列：先打印 over，然后瞎JB打印i。 示例21234567891011dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSLog(@"1");dispatch_sync(queue, ^&#123; NSLog(@"2"); NSLog(@"thread = %@", [NSThread currentThread]); dispatch_sync(queue, ^&#123; NSLog(@"3"); NSLog(@"thread = %@", [NSThread currentThread]); &#125;); NSLog(@"4");&#125;); 结果： 12345612main thread3main thread4 因为线程和 dispatch_async 以及 dispatch_sync 有关。因此，在上例中 dispatch_sync 时在主线程中，所以打印的也是主线程。虽然都是在主线程中，但是是并行队列，并不会发生死锁。只有 dispatch_sync 获取串行队列的时候才会发生死锁。 示例3123456789dispatch_async(global_queue, ^&#123; NSLog(@"1"); [self performSelector:@selector(printLog) withObject:nil afterDelay:0]; NSLog(@"3");&#125;&#125; - (void)printLog &#123; NSLog(@"2");&#125; 结果： 1213 这个例题不会出现打印2。在GCD生成的子线程中是没有 runloop 的，如果 performSelector:withObject:afterDelaty: 想要执行成功，必须要有 runloop。因此不打印 2 常用方法dispatch_apply重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。 12345dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply([array count], queue, ^(size_t index)&#123; [self doSomethingIntensiveWith:[array objectAtIndex:index]];&#125;);[self doSomethingWith:array]; 如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。 dispatch_after延迟提交 block： 12345double delayInSeconds = 1.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; // code to be executed on the main queue after delay&#125;); 其中 NSEC_PER_SEC 表示一秒钟有多少纳秒。 dispatch_after 是延迟提交，不是延迟运行，不是在特定的时间后立即运行！： 1234567891011121314151617//创建串行队列dispatch_queue_t queue = dispatch_queue_create("me.tutuge.test.gcd", DISPATCH_QUEUE_SERIAL);//立即打印一条信息NSLog(@"Begin add block...");//提交一个blockdispatch_async(queue, ^&#123; //Sleep 10秒 [NSThread sleepForTimeInterval:10]; NSLog(@"First block done...");&#125;);//5 秒以后提交blockdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), queue, ^&#123; NSLog(@"After...");&#125;); 结果如下: 1232015-03-31 20:57:27.122 GCDTest[45633:1812016] Begin add block...2015-03-31 20:57:37.127 GCDTest[45633:1812041] First block done...2015-03-31 20:57:37.127 GCDTest[45633:1812041] After... 对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。 dispatch_once保证在APP运行期间，block中的代码只执行一次1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // code to be executed once&#125;); 一定要注意的是 dispatch_once_t 必须是全局或 static 变量。否则使用时会导致非常不好排查的 bug。 dispatch_once 递归调用会产生死锁。 dispatch_group一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。 dispatch_group_create创建一个调度任务组 dispatch_group_async 把一个任务异步提交到任务组里 dispatch_group_notify 用来监听任务组事件的执行完毕 dispatch_group_wait 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败123456789dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();for(id obj in array) dispatch_group_async(group, queue, ^&#123; [self doSomethingIntensiveWith:obj]; &#125;);dispatch_group_notify(group, queue, ^&#123; [self doSomethingWith:array];&#125;); 除了 dispatch_group_async 直接发起一个异步队列，我们还可以配合使用下面两个方法： dispatch_group_enter(group); dispatch_group_leave(group); 这两个方法最好配合异步请求使用： 123456789101112131415161718192021222324// 创建 dispatch 组dispatch_group_t group = dispatch_group_create();// 第一个请求：dispatch_group_enter(group);[self sendGetAddressByPinWithURLs:REQUEST(@"getAddressByPin.json") completionHandler:^(NSDictionary * _Nullable data, NSError * _Nullable error) &#123; NSArray *addressList = [TXAddressModel mj_objectArrayWithKeyValuesArray:data[@"addressList"]]; self.addressList = addressList; dispatch_group_leave(group);&#125;];// 第二个请求dispatch_group_enter(group);[self sendCurrentOrderWithURLs:REQUEST(@"currentOrder.json") completionHandler:^(NSDictionary * _Nullable data, NSError * _Nullable error) &#123; TXCurrentOrderModel *currentOrderModel = [TXCurrentOrderModel mj_objectWithKeyValues:data]; self.currentOrderModel = currentOrderModel; dispatch_group_leave(group);&#125;];// 当上面两个请求都结束后，回调此 Blockdispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"OVER:%@", [NSThread currentThread]); [self setupOrderDataSource];&#125;); 这个例子的使用场景是，在两个请求都返回完毕后，才回调一个 block。因为两个请求本生就是异步的，所以不能使用 dispatch_group_async。 dispatch_barrier_async在访问数据库文件时，使用 Serial Dispatch Queue 可避免数据竞争的问题，但是效率较低。比如写入处理不能喝其他写入处理以及读取处理等并行执行。但是如果读取处理只和读取处理并行执行，那么多个并行执行不会发生问题。 为了高效率的进行访问，读取处理追加到 Concurrent Dispatch Queue 中，写入处理在任一个读取处理没有执行的情况下，追加到 Serial Dispatch Queue 中即可(写入处理结束前，读取处理不可执行）。 GCD 提供了 dispatch_barrier_async 函数。该函数同 Concurrent Dispatch Queue 一起使用。dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束之后，再将指定的处理追加到该 Concurrent Dispatch Queue中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。 一定要注意，官方提示：在使用栅栏函数时.使用自定义队列才有意义,如果用的是串行队列或者系统提供的全局并发队列,这个栅栏函数的作用等同于一个同步函数的作用 12345678910dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, blk0_for_reading);dispatch_async(queue, blk1_for_reading);dispatch_async(queue, blk2_for_reading);dispatch_async(queue, blk3_for_reading);dispatch_barrier_async(queue, blk_for_writing);dispatch_async(queue, blk4_for_reading);dispatch_async(queue, blk5_for_reading);dispatch_async(queue, blk6_for_reading);dispatch_async(queue, blk7_for_reading); 处理流程如图： 使用 dispatch_barrier_async 可提高数据库访问和文件访问的效率。 除了 dispatch_barrier_async 还有一个 dispatch_barrier_sync，两者有什么区别呢？两者都能达到等待在它前面插入队列的任务先执行完，等待他们自己的任务执行完再执行后面的任务的目的。但是不同的是，dispatch_barrier_async 将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务；dispatch_barrier_sync 将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。也就是说前者不会阻塞当前线程，而后者会阻塞当前线程。 dispatch_barrier_sync 和dispatch_barrier_async的区别 dispatch_semaphoredispatch_semaphore 主要用来实现锁的操作。可用于请求同步等处理。 dispatch_semaphore_t semaphore = dispatch_semaphore_create(value); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_semaphore_signal(semaphore); value 可以理解为资源数量，以 value = 0 为例，调用 dispatch_semaphore_wait 操作成功后，当资源数量 value 等于 0 时，就会阻塞当前线程（反之，value 就会减 1），直到有 dispatch_semaphore_signal 通知信号发出，当 value 大于 0 时，当前线程就会被唤醒继续执行其他操作。 例子:模拟同步请求，阻塞当前线程：12345678910111213141516// 1.创建信号量dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);NSLog(@"0");// 开始异步请求操作（部分代码略）dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"1"); // This function returns non-zero if a thread is woken. Otherwise, zero is returned. // 2.在网络请求结束后发送通知信号 dispatch_semaphore_signal(semaphore);&#125;);// Returns zero on success, or non-zero if the timeout occurred.// 3.发送等待信号dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);NSLog(@"2");// print 0、1、2 由于 dispatch_semaphore_wait，线程阻塞。只有等待异步请求返回后执行 dispatch_semaphore_signal 后，才会继续执行下面的代码。所以先打印 1，后打印 2. 例子：加锁，阻塞其他线程：123456789101112dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);for (int i = 0; i &lt; 100; i++) &#123; dispatch_async(queue, ^&#123; // 相当于加锁 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@"i = %zd semaphore = %@", i, semaphore); // 相当于解锁 dispatch_semaphore_signal(semaphore); &#125;);&#125; 问题 串行并行，同步异步的区别？ 什么情况下会造成死锁？ 如何使用 dispatch_time_t？如何使用 dispatch_after? dispatch_after 作为倒计时准确么？什么情况下会不准？ 如何使用 dispatch_once？ 如何创建和使用 dispatch_group? 什么时候使用 dispatch_group_enter(group)和dispatch_group_leave(group)?怎么使用？ dispatch_barrier_async和dispatch_barrier_sync 怎么用？需要注意什么？用在什么情况下？两者有什么差别？ dispatch_semaphore 有什么用？如何使用？如何用它模拟同步请求？如何加锁以及阻塞其他线程？ 还有一个参考文章：GCD使用经验与技巧浅谈]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解TCP-IP学习笔记]]></title>
    <url>%2F2016%2F07%2F31%2F%E5%9B%BE%E8%A7%A3TCP_IP%2F</url>
    <content type="text"><![CDATA[本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙ TCP/IP基础知识TCP/IP模型 硬件(物理层) 网络接口层(数据链路层) 互联网层(网络层) IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。 ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的 ARP：从分组数据包解析出物理地址(MAC地址)的一种协议。 传输层 TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。 UDP：面向无连接的传输层协议。 应用层(会话层以上的分层) WWW 电子邮件(E-Mail) 文件传输(FTP) 远程登录(TELNET,SSH) 网络管理(SNMP) 物理层协议物理层是五层模型中的最底层，物理层为计算机之间的数据通信提供了传输媒体和互连设备，为数据传输提供了可靠的环境，媒体包括电缆、光纤、无线信道等，互连设备指是计算机和调制解调器之间的互连设备，如各种插头、插座等。该层的作用是透明的传输比特流（即二进制流），为数据链路层提供一个传输原始比特流的物理连接 数据链路层数据链路层是模型中的第2层，该层对接受到物理层传输过来的比特流进行分组，一组电信号构成的数据包，就叫做”帧”，数据链链路层就是来传输以”帧”(frame)为单位的数据包，把数据传递给上一层（网络层），帧数据由两部分组成：帧头和帧数据，帧头包括接受方物理地址（就是下一级的网卡地址）和其他的网络信息，帧数据就是要传输的数据体。数据帧的最长为1500字节，如果数据很长，就必须分割成多个帧进行发送。 网络层该层通过寻址（寻址地址）来建立两个节点之间的连接，大家都知道我们的电脑连接上网络后都有一个IP地址，我们可以通过IP地址来确定不同的计算机是否在同一个子网路。如果我们的电脑连接上网络后就有两种地址：物理地址和网络地址（IP地址），网络上的计算机要通信，必须要知道通信的计算机“在哪里”， 首先通过网络地址来判断是否处于同一个子网络，然后再对物理地址（MAC）地址进行处理，从而准确确定要通信计算机的位置。 在网络层中有我们熟悉的IP协议（即规定网络地址的协议），目前广泛采用的是IPv4,这个版本规定，网络地址由32位二进制位组成。我们可以自己配置IP地址也可以自动获得的方式得到IP地址，IP地址分成两部分，前24位代表网络，后8位代表主机号， 如192.168.254.1和192.168.254.2就处于同一个子网络里，因为这两个IP地址的前24位相同。 帧数据区含有一个数据体。为确保计算机能够解释数据帧中的数据，这两台计算机使用一种公用的通讯协议。互联网使用的通讯协议简称IP，即互联网协议。IP数据包也包括两部分：头（Head）和数据(Data)，IP数据包(Packet)放进数据帧中的数据部分进行传输。 Mac地址在帧头中，IP地址在帧数据中的IP数据包头中，这样交换机可以快速读取Mac地址进行转发，而不需要像路由器一样需要解包将IP地址取出，才能进行转发，影响效率。 传输层通过MAC和IP地址，我们可以找到互联网上任意两台主机来建立通信。然而这里有一个问题，找到主机后，主机上有很多程序都需要用到网络，比如说你在一边听歌和好用QQ聊天， 当网络上发送来一个数据包时， 是怎么知道它是表示聊天的内容还是歌曲的内容的， 这时候就需要一个参数来表示这个数据包是发送给那个程序（进程）来使用的，这个参数我们就叫做端口号，主机上用端口号来标识不同的程序（进程），端口是0到65535之间的一个整数，0到1023的端口被系统占用，用户只能选择大于1023的端口。 传输层的功能就是建立端口到端口的通信，网络层就是建立主机与主机的通信，这样如果我们确定了主机和端口，这样就可以实现程序之间的通信了。我们所说的Socket编程就是通过代码来实现传输层之间的通信。因为初始化Socket类对象要指定IP地址和端口号。 在传输层有两个非常重要的协议：UDP 协议和TCP协议 采用UDP协议话传输的就是UDP数据段，同样UDP数据段也由头和数据两部分组成，头部分主要标识了发送端口和接受端口，数据部分就是具体的内容信息。同样UDP数据段(segment)是放入IP数据包中的”数据”部分，IP数据包再放入数据帧中在网络上传输。 由于UDP协议的可靠性差（数据发送后无法确定对方是否收到），所以又定义了一个可靠性高的协议——TCP协议，TCP协议采取了握手的方式要确保对方收到了数据。 TCP 协议的三次握手主要的目的是为了确定客户端要和服务器建立链接，以防服务器一直等待造成的性能损失。客户端先发一个同步信息告诉服务器要建立链接，服务器返回一个确认信息，客户端接收到之后再返回一个确认信息。如果不这样做，可能因为网络延迟，客户端的信息再一段时候后才被服务器接收，服务器等待客户端数据，但是由于过了一段时间，客户端可能已经停止了请求操作，这就导致了服务器性能的浪费。 应用层应用层是模型中的最顶层，是用户与网络的接口，该层通过应用程序来完成网络用户的应用需求。该层的数据放在TCP数据包的数据部分，该层定义了一个很重要的协议——Http协议，我们一般的Web开发都是基于应用层的开发。 数据包如何在网络中传输当我们向目标站点发送数据包时(比如 ping 一个地址)，就生成了一个包含 ICMP 协议域的数据包，我们暂且称之为“小德”。 “小德”已经将ICMP协议打包到数据段里了，可是还不能发送，因为一个数据要想向外面传送，还得经过“有关部门”的批准——IP协议。IP要将你的“写信人地址”和“收信人地址”写到数据段上面，即：将数据的源IP地址和目的IP地址分别打包在“小德”的头部和尾部，这样一来，大家才知道你的数据是要送到哪里。 准备工作还没有完。接下来还有部门要审核——ARP。ARP主要负责把IP地址对应到硬件地址。直接说吧，都怪二层交换机太“傻”，不能根据IP地址直接找到相应的计算机，只能根据硬件地址来找。于是，主机或者三层交换机(不是指交换机啊，ARP 是工作在网络层的，不是数据链路层啊)就经常保留一张IP地址与硬件地址的对应表以便其查找目的地。而ARP就是用来生成这张表的。比如：当“小德”被送到ARP手里之后，ARP就要在表里面查找，看看“小德”的IP地址与交换机的哪个端口对应，然后转发过去。如果没找到，则发一个广播给所有其他的交换机端口，问这是谁的IP地址，如果有人回答，就转发给它。如果没有，就准备由二层交换机转发到路由器（这之前都是在主机里查询 ARP 表），走出局域网了。（其实就是我们要发送信息，我们只知道要发给的主机的ip地址，但是不可能知道主机的MAC地址。但是交换机要通过MAC地址转发，所以就有了这么一个ARP表，放在主机或者三层交换机里） 经过一番折腾，“小德”终于要走出这个倒霉的局域网了。可在此之前，它们还没忘给“小德”屁股后面盖个“戳”，说是什么CRC校验值，怕“小德”在旅行途中缺胳膊少腿，还得麻烦它们重新发送。。。。。我靠~~~~注：很多人弄不清FCS和CRC。所谓的CRC是一种校验方法，用来确保数据在传输过程中不会丢包，损坏等等，FCS是数据包（准确的说是frame）里的一个区域，用来存放CRC的计算结果的。到了目的地之后，目的计算机要检查FCS里的CRC值，如果与原来的相同，则说明数据在途中没有损坏。 在走出去之前，那些家伙最后折磨了一次“小德”——把小德身上众多的0和1，弄成了什么“高电压”“低电压”，在双绞线上传送了出去。晕~~出趟门就这么麻烦吗？ 坐着双绞线旅游，爽！可当看到很多人坐着同轴电缆，还有坐光纤的时候，小德又感觉不是那么爽了。就在这时，来到了旅途的中转站——路由器。这地方可是高级场所，人家直接查看IP地址！剩下的一概不管，交给下面的人去做。够牛吧？路由器的内部也有一张表，叫做路由表，里面标识着哪一个网络的IP对应着路由器的哪一个端口。这个表也不是天生就有的，而是靠路由器之间互相“学习”之后生成的，当然也可以由管理员手工设定。这个“学习”的过程是依靠路由协议来完成的，比如RIP，EIGRP，OSPF等等。 当路由器查看了“小德”的IP地址以后，根据路由表知道了小德要去的网络，接着就把小德转到了相应的端口了。至此，路由器的主要工作完成，下面又是打包，封装成frame，转换成电压信号等一系列“折腾”的活，就由数据链路层和物理层的模块去干吧。 小德从路由器的出口出来，便来到了目的地—-电脑B—-所属的网络的默认网关。默认网关可以是路由器的一个端口，也可以是局域网里的各种服务器。不管怎样，下面的过程还是一样的：到三层交换机里的ARP表查询“小德”的IP地址，看看属于哪个局域网段或端口，然后就转发到B了。 进了B的网卡之后，还要层层“剥皮”，基本上和从A出来的程序是一样的——电脑B先校验一下CRC值，看看数据是否完整；然后检查一下frame的封装，看到是IP协议之后，就把“小德”交给IP“部门”了；IP协议一看目的地址，正确，再看看应用协议，是ICMP。于是知道了该怎么做了——产生一个回应数据包，（可以命名为“回应小德”），并准备以同样的顺序向远端的A发送。。至于刚刚收到的那个数据包就丢弃了。 一个出口多个入口的是交换机，每个入口都对应着一个终端，是网络传输开始的部分，通过 MAC 地址转发 多个出口多个入口的是路由器，会解析 IP 头，找到适合的出口将数据传输出去。 家用路由器=交换机+NAT。如果用交换机相当于每台家用设备需要一个 IP，但是如果使用家用路由器，那么通过 NAT 只需要给一个 IP 即可。 IP协议IP网络协议网络层的下一层——数据链路层主要作用是在互连同一种数据链路节点之间进行包传递(局域网)。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。 配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。 网络层与数据链路层关系：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于是个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。 IP基础知识IP大致分为三大模块，IP寻址，路由，IP分包和组包。 为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。 路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。 IP地址的基础知识IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。 广播地址用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。 多播用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。 网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”子网掩码“的识别码通过子网网络地址细分出比ABC更小粒度的网络。子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0。比如A类网络的子网掩码就是255.0.0.0(前8位全是1)，B类网络的子网掩码就是255.255.0.0(前16位全是1)。 由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，192.168.0.0-192.168.255.255。包含在这个范围内的IP都属于私有IP，在此之外的IP称为全局IP。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。 对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。 路由控制仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。 路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。 路由算法距离向量算法采用Bellman-Ford算法，保存网络中的所有路由器及网络的拓扑图。比较费时费性能。 链路状态算法采用Dijkstra 算法。 当一个路由器启动的时候，向邻居发送消息，邻居立刻回复，从而计算和邻居的距离。然后将自己和邻居的链路状态广播出去，发送到整个网络的所有路由器。因此，每一个路由器都可以在本地构建一个完整的图，然后使用 Dijkstra 算法，找到两点的最短路径。 IP协议相关ICMPICMP 主要用来确认 IP 包是否成功到达目标地址。使用 UDP 协议。一般所说的 ping 一个 IP 就是使用 ICMP 协议。 NATNAT 用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址。NAT 主要解决的是 IPv4 IP 地址枯竭的问题。 NAT 内部的机器通过 NAT 路由器将内部 IP 转化为外部 IP，与外部机器通信。 NAT 内部维护了一个 NAT 转化表。将内部不同的机器映射为不同的端口号。比如内部 10.0.0.10 映射为外部IP 202.244.174.37:1025，将 10.0.0.11映射为外部 IP 202.244.174.37:1026 其实就是虽然只有一个外网IP，但是可以通过端口号拓展很多的内部机器。 对于第四层是TCP或UDP的数据包，NAT通过更改源端口号，来实现多对少的映射。 对于ICMP包，NAT通过更改ICMP的ID，来实现多对少的映射。 （NAT违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第N层是不能修改第N+1层的报头内容的。NAT破坏了这种各层独立的原则。） DNSDNS帮助用户在互联网上寻找路径。在互联网上的每一个计算机都拥有一个唯一的地址，称作“IP地址”（即互联网协议地址）。由于IP地址（为一串数字）不方便记忆，DNS允许用户使用一串常见的字母（即“域名”）取代。在每次 TCP/IP 通信前，都会先通过 UDP 协议，向 DNS 服务器请求 IP 地址。 其实dns系统是一个典型的树状架构，我们设置的dns服务器其实应该叫dns缓存查询服务器，它是为了减轻互联网上dns查询的负载所设计的。如果你的请求没有命中缓存，那么这个缓存服务器就会自己进行一次标准查询，然后再把结果缓存起来，简单来说就是从根服务器开始一级一级的问。我们以前经常谈到根服务器的重要性其实就体现在这里了，它保留了对所有域名的起始解释权。 上面讲到根服务器拥有一切域名的起始解释权，但是如果你去问根服务器它是不会直接告诉你最终答案的。因为如果它要存储所有的记录，那它也太累了，这个负载和开销是惊人的。那它会告诉你什么呢？它会告诉你应该去问谁，也就是它授权下一级服务器来解答你的问题。所以可见，dns系统本身是一个分布式的网络。 DNS 劫持 DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。 对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。 DNS 污染DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。 对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。 HTTPDNSHTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。 其实就是就近找 DNS 总结DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。 DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。 修改DNS可以手动修改本机的 DNS，也可以不修改使用路由器的 DNS，路由器可以手动修改 DNS，也可以不修改使用运营商的 DNS。 附： GFW 的实现GFW 就是所说的墙，有三种方式屏蔽网络上传播的内容： 内容审查GFW的内容审查针对HTTP传输协议的默认端口的80端口，HTTP传播的内容是明文的内容，没有经过加密，GFW是一个IDS[Intrusion detection system(入侵检测系统)]，GFW有一个敏感字名单，若在中国大陆访问境外的主机的HTTP的数据流里发现敏感字眼，就在两台主机间伪造一个”reset”信号，导致双方主机以为对方中止了请求。 DNS劫持和污染DNS劫持：通过网络服务提供商(Internet ServiceProvider/ISP)提供的DNS服务器进行DNS欺骗，当人们访问某个网站时，需要要把域名转换为一个IP地址，DNS服务器负责将域名转换为IP地址，中国大陆的ISP接受通信管理局的屏蔽网站的指令后在DNS服务器里加入某些特定域名的虚假A记录，当使用此DNS服务器的网络用户访问此特定网站时，DNS服务便给出假的IP地址，导致访问网站失败，甚至返回ISP运营商提供的出错页面和广告页面。 DNS污染：GFW在DNS查询使用的UDP53端口上根据黑名单进行过滤，遇到通往国外的使用UDP的53端口进行查询的DNS请求，就返回一个虚假的IP地址（即使用国外的服务器查询就会返回一个虚假的地址）。 屏蔽IP有些人改了 hosts，直接将谷歌的域名映射到 ip，但是GFW可以通过路由器(router)来控制的，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往某些被屏蔽的网站的所有IP数据包无法到达。路由器的正常工作方式是学习别的路由器广播的路由规则，遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。GFW的路由器按黑名单(blacklist)来转发特定的IP数据包，则可屏蔽特定的网站的IP，此IP黑名单不是固定的，会更新。 TCP与UDPTCP概述tcp采取全双工(full-duplex)传输，也就是传输过程中，同一连接可以传输双向的数据流，发送方可以传给接收方，接收方也可以传给发送方。 tcp是面向连接的协议。其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。 TCP 发送信息过程 连接过程 client 发送一个同步消息 SYN ，同时发送随机 seq 为 x，告诉server 发送的包序号从 x 开始。 server 收到同步消息后，也返回一个 SYN 信号，同时返回一个 ACK 信号为 x+1，表示知道了你的序号，还返回了 server 的随机 seq 为 y，告诉 client，server 端序号从 y 开始。 client 收到后，返回一个 ACK 为 y+1，表示 client 知道 server 的开始序号了。 断开连接过程 client 发送一个断连消息 FIN ，以及随机 seq server 收到同步消息后，返回一个 ACK 信号 之后，在 server 端决定的任意时刻，发起一个断连信号 FIN，以及随机 seq client 收到后，返回一个 ACK 最后要注意的是，客户端需要在收到服务端的 FIN 并且发送 ACK 之后要等两个时间窗再关。因为客户端发送的 ACK 可能没有到达服务端。服务端会不停的发送 FIN，所以要等待一段时间，确认服务端已经关闭了，客户端再关闭。 TCP 如何实现可靠传输 确认和重传 数据校验 数据合理分片与排序 流量控制 拥塞控制 TCP 确认与重传机制一种方式是超时重传，就是对每一个没有 ACK 的包都设置一个定时器，超过一定时间后尝试重传。超时重传的周期不宜过短也不宜过长，过短别人可能真的没有接收到，过长又会阻塞信息传输。一般的策略是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。 针对超时重传周期可能过长的问题，采取快速重传的机制。当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，接收方还是发送期望报文段之前的报文的 ACK。当客户端连续收到三个这样的 ACK 时，就在定时器过期之前，重传丢失的报文段。 快速重传解决了重传周期长的问题，但是没解决重传一个还是重传多个的问题。因此还出现了选择确认机制，TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。这样一下子就能知道丢失了什么。 TCP 流量控制本质上就是在发送方维持一个滑动窗，窗的大小由接收端控制。 TCP 拥塞控制滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口是怕把网络塞满。 TCP 使用滑动窗的方式发送数据，收发主机之间不再以数据段为单位发送确认应答。这个时候可能产生拥堵。TCP 为了防止这样的问题，一般采用如下做法： 慢启动：主要做法就是试探，首先在一个单位时间里发送一个报文。如果收到了确认回执，那么翻倍发送，直到拥塞，数据丢失，这一阶段报文的数量是以指数级增长。 拥塞避免：慢启动的时候是指数增长的，但是增长是有个门限ssthresh的，到达门限后进入拥塞避免阶段。拥塞避免状态，每次增长一个报文。 快速恢复：当出现丢包，并且实施了快速重传的时候，就表明网路还是较为畅通的，此时此时就不会直接进入慢启动状态，而是将传输的报文数量减半，然后继续拥塞避免。 只有在快速重传的时候才会进入快速恢复。如果是超时重传，那么就要重新进行又一轮的慢启动。 三次握手为什么要三次握手不是两次？主要是为了节约 server 端的 socket 资源。如果两次握手，服务端在第二次握手后维护了一个连接。但是客户端没有收到服务端的ACK，这时候客户端以为服务端没有建立连接就会重新发送 SYN 请求建立连接。服务端前一个建立的连接就是死连接了。一个进程打开的socket是有限度的， 维护这些死连接非常耗费资源。 为什么是三次握手不是四次？其实本身，client 发送同步信号 SYN 以及 seq，server 回复 ACK，随后 server 发送同步信号 SYN 以及 seq，client 回复 ACK 是四次。但是 server 发送 seq 和 ACK 可以合并为一次，因此就只需要三次了。 四次挥手本质上和握手时client 通知，server 回复。server 通知，client 回复一样是四次。但是在客户端请求结束的时候，服务端可能在发数据，所以不能把 ACK 和 FIN 像握手的时候一起发送。所以一般情况下要四次。但是如果当时服务端没有再发送数据，那么也可以三次挥手。 四次挥手能否变成三次挥手？可以，如果Server在收到Client的FIN包后，在也没数据需要发送给Client了，那么对Client的ACK包和Server自己的FIN包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了。 UDPUDP 如何保证可靠性为什么要在 UDP 之上做可靠保证，究其原因就是在保证通信的时延和质量的条件下尽量降低成本。 那么在 UDP 之上怎么实现可靠呢？答案就是重传。 就是把 TCP 的这几个可靠性机制能搬多少搬多少。 几张表MAC地址转发表说到MAC地址表，就不得不说一下交换机的工作原理了，因为交换机是根据MAC地址表转发数据帧的。在交换机中有一张记录着局域网主机MAC地址与交换机接口的对应关系的表，交换机就是根据这张表负责将数据帧传输到指定的主机上的。 交换机在接收到数据帧以后，首先、会记录数据帧中的源MAC地址和对应的接口到MAC表中，接着、会检查自己的MAC表中是否有数据帧中目标MAC地址的信息，如果有则会根据MAC表中记录的对应接口将数据帧发送出去(也就是单播)，如果没有，则会将该数据帧从非接受接口发送出去(也就是广播)。 上面说的交换机指的是二层交换机 这张表存在于交换机中，记录的是 MAC地址 -&gt; 端口的映射 ARP缓存表上面我们讲解了交换机的工作原理，知道交换机是通过MAC地址通信的，但是我们是如何获得目标主机的MAC地址呢？这时我们就需要使用ARP协议了，在每台主机中都有一张ARP表，它记录着主机的IP地址和MAC地址的对应关系。ARP协议是工作在网络层的协议，它负责将IP地址解析为MAC地址。 知道下一跳的 IP，但是不知道下一跳的 MAC 地址是无法传输的。所以当知道 IP 但不知道 MAC 地址的时候，就要通过 ARP 发送一个广播包，问这个 IP 是谁的？MAC 地址是多少？ 上面指的是局域网中的数据传递。除了主机中，三层交换机或者路由中也是有 ARP 表的，数据最终转发依靠的都是ARP表，他是数据转发最基础的依据，ARP直接将硬件地址和网络地址相互映射。 这张表记录的是 IP -&gt; MAC 地址的映射。 路由表路由器负责不同网络之间的通信，它是当今网络中的重要设备，可以说没有路由器就没有当今的互联网。在路由器中也有一张表，这张表叫路由表，记录着到不同网段的信息。 路由器是工作在网络层的，在网络层可以识别逻辑地址。当路由器的某个接口收到一个包时，路由器会读取包中相应的目标的逻辑地址的网络部分，然后在路由表中进行查找。如果在路由表中找到目标地址的路由条目，则指定下一跳 ip，然后把包转发到路由器的相应接口，如果在路由表中没有找到目标地址的路由条目，那么，如果路由配置默认路由，就按照默认路由的配置转发到路由器的相应接口；如果没有配置默认路由，则将该包丢弃，并返回不可到达的信息。这就是数据路由的过程。 这张表记录的是 目标IP -&gt; 下一跳路由 IP 的映射 三张表是有一个层次关系的。每次 IP 的跳转都要结合三张表，从目标 IP 到 目标 MAC 所在端口的转换。 问题 为什么不把MAC地址和IP地址统一成一个地址而用两个地址？ 什么是中继器/网桥/路由器/三层交换机/二层交换机/网关？ TCP/IP 五层模型各指什么？各自的作用是什么？ IP/ARP/TCP/UDP/HTTP/FTP 这些协议分别处于哪一层？作用是什么？ 什么是帧？IP 地址和 MAC 地址分别放在帧的哪一部分，这样有什么好处？ 为什么 TCP 协议要进行三次握手，四次挥手？ 简述数据包如何在网络中传输？ ARP缓存表，MAC地址表，路由表的作用分别是什么？ 什么是DNS？基本原理是什么？为什么说它是分布式的网络？ 什么是DNS劫持？什么是DNS污染？]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《iOS UI 开发捷径》读书笔记]]></title>
    <url>%2F2016%2F07%2F31%2FUI%E5%BC%80%E5%8F%91%E6%8D%B7%E5%BE%84%2F</url>
    <content type="text"><![CDATA[读了 《iOS UI 开发捷径》，书上的东西比较简单，也比较零碎。所以做个大致的整理。 xib 加载 Cell有一个特殊的 View 是 cell: 12// 平时使用 loadNibNamed:owner:options 方法会先把 xib 加载到内存生成相应的 nib，再通过 nib 转化为 View 实例。对于 UITableView 来说，重复加载 xib 是一个耗时操作，所以 UITableView 通过注册 UINib 来缓存 nib[_tableView registerNib:[Nib nibWithNibNamed:@"SomeView"] bundle:nil]; xib 加载 VC可以通过以下方式创建于 xib 关联的 VC: 1234// 有同名的 xib 文件let homeVC = HomeViewController()// 没有同名的 xib 文件let homeVC = HomeViewController.init(nibName:"HomeViewController", bundle:nil) 加载 bundle 中的资源应用的代码和资源都放在应用所在的 main bundle 中，不过有一些第三方的 sdk 会把自己的资源文件打包成一个 bundle。这些 bundle 也会保存在 main bundle 中，我们可以先拿到其 bundle 再拿资源文件： 12let subBundle = Bundle.init(path: Bundle.main.path(forResource: "myBundle" ofType:"bundle")!)let image = subBundle?.path(forResource: "myImage" ofType:"png")!) 加载 image 方式有两种方式加载 image： 12let image = UIImage.init(named:"someImage")let image = UIImage.init(contentsOfFile:(Bundle.main.path(forResource:"someImage", ofType:"png"))!) 第一种默认加载 mainbundle 中的图片，Assets.xcassets 中的图片只能通过第一种方式加载 第二种可以加载任意位置的图片。第一种加载的图片会被系统缓存。所以显示 icon 的时候通过第一种方式加载比较好，图片资源较大时，用第二种方式 如何删除 storyboardstoryboard的入口在targets-&gt;General-&gt;Deployment Info-&gt;Main Interface，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。 使用storyboard的时候 application:didFinishWithOptions: 方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; ViewController *uv = [[ViewController alloc] initWithNibName:@"ViewController" bundle:nil]; [self.window setRootViewController:uv]; [self.window makeKeyAndVisible]; return YES;&#125; 拉伸图片聊天的气泡图可以通过代码的方式设置，也可以直接在 Assets.xcassets 文件夹内直接设置。选中相应图片，找到面板中的 show slicing 点击，会出现相应的设置相关项（用到时候查一下，使用起来非常简单）。 使用 @IBOutlet 设置约束代码中声明约束变量： 1@IBOutlet weak var widthConstraint: NSLayoutConstraint! 在 xib 中右键然后和代码中声明的变量连线。必要的时候，使用动画改变约束： 1234UIView.animated(withDuration:0.5, animations:&#123; self.widthConstraint.constant = 300 self.view.layoutIfNeeded()&#125;) User Defined Runtime Atrributes使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。比如写一个button的时候经常会需要设置其 cornerRadious，borderWidth 和 borderColor 三个属性: 1234Key.Path Typelayer.cornerRadius Numberlayer.borderWidth Numberlayer.borderColor Color 但是，进过设置后会发现 borderColor 属性设置并不成功。这是因为这里设置的颜色类型是 UIColor 而 borderColor 是 CGColor 因此显示不出来。 需要定义一个 CALayer 的分类: 1234567#import "CALayer+Additions.h"#import &lt;UIKit/UIKit.h&gt;@implementation CALayer (Additions)- (void)setBorderColorFromUIColor:(UIColor *)color&#123; self.borderColor = color.CGColor;&#125;@end xib中的Key.Path 改为此属性 layer.borderColorFromUIColor 即可通过 runtime 动态设置。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios编程(第四版) 学习笔记]]></title>
    <url>%2F2016%2F07%2F31%2Fios%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%2F</url>
    <content type="text"><![CDATA[本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。 视图与视图层次结构视图层次结构视图层次结构中的每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个 UIView 对象都有一个 layer 属性，指向一个 CALayer 类的对象。 layer 只负责显示，layer 可以不和 View 重叠的放在任何位置，但是关于视图的响应还是要靠 UIView，即看 View 的位置。 创建 UIView 子类每个 UIView 对象都有一个 superview 属性。将一个视图作为子视图加入另一个视图时，会自动创建相应的反向关联。 在 drawRect: 方法中自定义绘图视图根据 drawRect: 方法将自己绘制到图层上。每个 UIView 的子类可以覆盖 drawRect:，完成自定义的绘图任务。例如 UIButton 的 drawRect: 方法默认会在 frame 表示的矩形区域中心画一行浅蓝色的文字。 可以使用 UIBezeierPath 绘制直线或者曲线来组成各种形状，例如画一个同心圆的一个略伪的代码： 1234567891011121314151617181920- (void)drawRect:(CGRect)rect&#123; UIBezierPath *path = [[UIBezierPath alloc] init]; // 画同心圆 for (float currentRadius = maxRadius; currentRadius &gt;0; currentRadius -= 20)&#123; // 每一次一个 path 的 stroke 都相当于是一笔画，绘制完一个圆后必须要抬笔让起始点移动到另一个地方 [path moveToPoint:CGPointMake(center.x + currentRadius, center.y)]; // 画弧 [path addArcWithCenter:center radius:currentRadius startAngle:0.0 endAngle:M_PI*2 clockwise:YES]; &#125; // 设置线条宽度为10 path.lineWidth = 10; // 设置画笔颜色为浅灰色 [[UIColor lightGrayColor] setStroke]; // 绘制路径 [path stroke];&#125; 深入学习: Core Graphics Core Graphics 中最重要的对象是图形上下文，图形上下文是 CGContextRef 的对象，负责存储回话状态(例如画笔颜色和线条粗细)和挥之内容所处的内存空间。 参与绘图操作的类都定义了改变绘图状态和执行绘图操作的方法，这些方法其实调用了对应的 Core Graphics 函数。有时候我们不得不用到其中的一些属性，但是一般情况下，我们没有必要直接使用 Core Graphics。 视图:重绘与 UIScrollView运行循环和重绘视图iOS 应用启动会开始一个运行循环。运行循环的工作是处理事件，例如触摸。运行循环会为相应的事件找到合适的处理方法。当这些方法执行完毕后，控制权会再次回到运行循环。 当应用将控制权交回给运行循环时，运行循环首先会检查是否有等待重绘的视图(即当前循环收到过 setNeedDisplay 消息的视图)，然后向所有等待重绘的视图发送 drawRect: 在事件处理周期中，视图的属性可能会多次改变，如果经常重绘自己，会减慢界面的响应速度。iOS 会在运行循环的最后阶段集中处理所有需要重绘的视图，尤其是对于属性多次发生改变的视图，在每次时间处理周期中只重绘一次。 为了标记视图要重绘，必须向其发送 setNeedsDisplay 消息。系统中的视图对象会在显示的内容发生改变时向自身发送 setNeedsDisplay 消息，例如 UILabel 对象收到 setText: 消息后，会自动标记为需要重绘。而自定义的 UIView 子类，必须手动向其发送 setNeedsDisplay 消息。 1234- (void)setCircleColor:(UIColor *)circleColor&#123; circleColor = circleColor; [self setNeedsDisplay]; // 重绘&#125; 使用 UIScrollView另一篇专门讲 UIScrollView 的文章已经说了，UIScrollView 有两个 size，一个控制显示的框框的大小，就是指 frame，一个是实际内部图像的大小，就是其中的 contentSize 属性： 1234567891011// 外部大小设置为屏幕大小UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:screenRect];// 添加一个 ContentView，在这个 View 上添加更多要显示的图形UIView *contentView = [[UIView alloc] initWithFrame:bigRect];[scrollView addSubview:contentView];// 告诉 UIScrollView 取景范围多大scrollView.contentSize = bigRect.size;// 可以在 contentView 中添加各种 subview[contentView addSubview:xx1View];[contentView addSubview:xx2View]; UIScrollView 中有一个分页的属性 pagingEnabled，如果将其设置为 YES，会一页一页地显示视图，其实现原理是： UIScrollView 对象会根据其 bounds 的尺寸，将 contentSize 分割为尺寸相同的多个区域。拖动结束后， UIScrollView 会自动滚动并值显示其中一个区域。 视图控制器创建 UIViewController子类UIViewController有一个重要属性 view，它是视图层次结构的根视图，所有视图都添加在这个 view 上: 1@property (nonatomic, strong) UIView *view; 视图控制器可以通过两种方式创建视图层次结构: 代码方式:覆盖 UIViewController 中的 loadView NIB 文件方式:不覆盖 UIViewController 中的 loadView loadView 方法会在 ViewController 的 view 被请求并且当前view为nil时调用这个方法。所以你调用 [[UIViewController alloc] init] 并且将这个 ViewController 显示出来的时候，会自动触发 loadView 方法。 系统的 loadView 方法的默认实现是：寻找有关的 nib 文件的信息，根据这个信息来加载 nib 文件。如果没有相关nib文件的信息，默认创建一个空白的 UIView 对象，然后把对象成赋值给 ViewController 的主 view。 这个nib文件的信息是 initWithNibName:Bundle: 方法提供的，你可以在创建 VC 的时候直接手动调用：[[UIViewController alloc] initWithNibName:@&quot;xxxx&quot; Bundle:[UIBundle mainBundle]]。如果是使用 init 方法初始化的，init 方法会默认调用该方法，其中的 nibName 默认是同名文件。 通过 Nib 文件方式加载视图就是不要重写 loadView 方法 自定义重载 loadView 的时候注意不需要调用上面所说的系统实现方法 [super loadView]; 因为你想自定义 view 的话，就需要自己给 view 属性赋值。 12345678- (void)loadView&#123; // 创建一个view UIView *view = [[UIView alloc] init]; // 将 view 赋给控制器的 view 属性 self.view = view; // 添加其他的view ...&#125; 重写 loadView 来实现代码方式自定义视图 无论 XIB 还是代码创建都会调用 viewDidLoad 方法。如果你需要对 view 及添加在其上的视图做一些其他的定制操作，在 viewDidLoad 里面去做。 另一个视图控制器通过 initWithNibName:Bundle: 方法可以指定加载的 NIB 文件，bundle 用于指定所在的程序包，默认是主程序包 [NSBundle mainBundle];，对应于文件系统中的根目录，包含代码文件和资源文件。 在加载前，我们要确保 nib 对象和 ViewController 已关联起来(尤其是 view 属性要关联起来，不关联就会抛出异常)，需要使用 File’s Owner 对象。File’s Owner 对象是一个占位符，当某个视图控制器将 Xib 文件加载为 NIB 文件时，首先会创建 XIB 文件中所有视图对象，然后会将自己填入相应的 File’s Owner 空洞，并建立之前在 Interface Builder 中设置的关联。 关联 view 属性，首先选中 Files’s Owner 然后打开检视面板，将 Class 设置为目标 ViewController 的 Class： 设置 File’s Owner 是在 initWithNibName:bundle: 方法里设置的，那么上图的设置意义是什么呢？只有正确的设置了 Class，下面关联插座的时候才能将 ViewController 中的插座变量展示出来，提供给使用者连线： 比如在 NavigationController 中的一堆 ViewController，在内存偏少时，会释放其视图并在显示的时候再创建出来。所以 ViewController 中的插座变量一般声明为 weak，防止 ViewController 强引用 Xib，导致系统不能释放 Xib。 插播一：File‘s Owner 和 View 的 custom class 的区别用于 ViewController 上的区别除了 File’s Owner 可以设置 custom class，xib 中的 view 也可以设置 custom class。但是前者可以是任意对象即 NSObject 而后者只能是 UIView 的子类。我们在对 ViewController 设置 xib 的时候只可以设置 File’s Owner 的 custom class，并通过 initWithNibName:bundle: 初始化，而不能设置 xib 中 view 的 custom class。 因为 UIViewController 继承于 NSObject，本质上是一个控制器，而不是一个 View。所以这个 xib 所代表的 View 是 custom class 也就是 VC 的一部分。从连线上就可以作证，因为如果创建 VC 的时候连同创建了 xib 的话，Xcode 会默认将 VC 的 View 属性和 xib 连接。 而 View 则表示 custom class 就是这个 view。所以不能将其用在 VC 上。 用于 View 上的区别那对于一个自定义的 View，我们是该设置哪个的 custom class 呢？答案是：两者都可以实现，但是使用场景和方式都略有区别。 对于自定义 view，两者都可以使用下面的方法表示。前者需要将 owner 设置为现在的 owner，一般是 self；后者将其置为 nil 即可： 1NSArray *nibViews = [[NSBundle mainBundle] loadNibNamed:@"NibName" owner:owner options:nil]; 如果是设置 view 的 custom class。例如一个 TestView 视图，直接就可以将这个 View 赋给了 TestView 对象。这里设置 owner 为 nil： 1234// 在某个 ViewController 中添加 TestView 视图NSArray* nibView = [[NSBundle mainBundle] loadNibNamed:@"TestView" owner:nil options:nil];TestView *testView = [nibView firstObject];[self.view addSubview:testView]; 设置 Files’s Owner 的 custom class 的方式则需要通过 addSubView: 方法手动添加到其 owner 类中： 12345678910// 自定义的 TestView 的某个实例化方法- (instancetype)initFromNibWithFrame:(CGRect)frame&#123; UIView *nibView = [[[NSBundle mainBundle] loadNibNamed:@"TestView" owner:self options:nil] firstObject]; nibView.frame = frame; self = [super initWithFrame:nibView.frame]; [self addSubview:nibView]; // 这个自定义的方法用来自定义设置 View [self nib_viewDidLoad]; return self;&#125; 一般我们如果自定义 View 都是直接采用设置 View 的 custom class 的方式，比如 TableView 中加载头视图，设置 TableViewCell 等： 12345// 设置头视图UIView *headerView = [[[NSBundle mainBundle] loadNibNamed:@"HotelReviewsHeaderView" owner:nil options:nil]lastObject];// 设置 Cell[self.tableView registerNib:[UINib nibWithNibName:@"MineUserInfoCell" bundle:nil] forCellReuseIdentifier:@"MineUserInfoCellIdentifier"]; 设置 File‘s owner 就表示这个 xib 是我 Custom class 的马仔，所以要 addSubview 的方式添加进去。设置 View 的custom class 表示这个 xib 就是我自己呀。 参考：通过 XIB 加载 UIView 插播二：在 xib 中使用自定义的view上面演示了如何用代码的方式对设置了 File’s owner 或 View 的 custom view 的自定义视图进行实例化。那么一直有一个疑惑，如何在 xib 中直接添加自定义view 的 xib？ 在 ViewController 的 xib 中，我们拖入一个 UIView 的控件，然后将这个 UIView 的 Custom Class 设置为自定义的 view 的类名。此刻你觉得大功告成了么？非也，如果运行就会发现，刚刚拖入并设置了 Custom Class 的控件并没有显示出来，只是一片空白。那么我们要如何修改呢？ 其实为什么是一片空白很好理解，因为你拖的这个 UIView 就是空白的，Xcode 就认为你将类和这个空白的 UIView 关联了起来。 虽然你还将另外的一个 xib 和这个类关联起来了，但是你显示的并不是那个 xib。其实就相当于一个类关联了多个 xib 的视图。 当指定了类的那个 UIView 随着 ViewController 的 xib 被加载的时候，会调用 initWithCoder: 以及 awakeFromeNib 方法（只要是从文件(即 xib)中加载的，就都会调用其类的该方法。其实就相当于在加载 VC 的 xib 的时候，递归的调用了其内部所有 View 的 initWithCoder 方法）。我们可以重写 initWithCoder: 方法将我们要展示的 UIView 添加上去。 initWithCoder 是文件方式创建 UIView 的时候就会调用的，调用 [super initWithCoder:aDecoder] 就完成了 UIView 的创建。你可以添加自己的代码，在 UIView 中添加视图。 initWithFrame 就是以代码方式创建 UIView 的了。 awakeFromNib 是在 initWithCoder 成功从文件创建好 UIView 之后调用的。 这里就不能像前面一样可以设置 File’s Owner 和 View 的 custom class 都可以加载自定义视图对象了。这里只能设置 File’s Owner 的 custom class，然后在 initWithCoder: 方法中添加 subView。最后注意由于是添加的 subView，那么需要设置 frame。 123456789101112- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super initWithCoder:aDecoder]; if (self) &#123; NSString *className = NSStringFromClass([self class]); UIView *view = [[[NSBundle mainBundle] loadNibNamed:className owner:self options:nil] firstObject]; view.frame = self.bounds; [self addSubview:view]; return self; &#125; return nil;&#125; 通过设置 View 的 custom class 将会产生无线递归，最终导致栈溢出崩溃。为什么？因为 如果你在 xib 中将 View 的 custom class 设置为自定义view 的类，那么你在 initWithCoder 中调用 UIView *view = [[[NSBundle mainBundle] loadNibNamed:className owner:self options:nil] firstObject]; 的时候会触发 initWithCoder:。所以这个过程相当于不停的在加载自己。只有当你将其设置为 File’s Owner 的时候，在 initWithCoder 中加载视图，就是加载子视图，就相当于加载自己的儿子。 参考：Nested Xib Views - 使用XIB实现嵌套自定义视图 UITabBarControllerUITabBarController 的 view 属性指向一个包含两个子视图的 UIView 对象，分别是标签栏和当前选中的视图控制器的视图。其 viewControllers 属性保存一组视图控制器，每一个视图控制器对应一个 tabItem： 123456789101112131415- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; UIImage *mainImage = [UIImage imageNamed:@"tab_home"]; UIImage *mainImageSel = [UIImage imageNamed:@"tab_home_active"]; //设置图片的渲染模式 mainImage = [mainImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; mainImageSel = [mainImageSel imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; //设置tabBarItem UITabBarItem *mainTabBarItem = [[UITabBarItem alloc] initWithTitle:@"首页" image:mainImage selectedImage:mainImageSel]; mainNav.tabBarItem = mainTabBarItem; //初始化tabBar UITabBarController *tabBarController = [[UITabBarController alloc] init]; tabBarController.viewControllers = @[mainNav,nextNav]; // 设为根ViewController self.window.rootViewController = tabBarController;&#125; 为tabbar添加subview: 123UIView *backview = [[UIView alloc] initWithFrame:self.tabBar.bounds];[backview setBackgroundColor:[UIColor whiteColor]];[self.tabBar addSubview:backview]; 与视图控制器及其视图交互application:didFinishLaunchingWithOptions: 该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。initWithNibName：bundle：该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。loadView：覆盖该方法，使用代码方式设置视图控制的的view属性。viewDidLoad：该方法会在视图控制器加载完视图后被调用。viewWillAppear：该方法会在视图控制器的view显示在屏幕上时被调用。 文本框与文本输入文本框UIResponder 是 UIKit框架中的一个抽象类。诸如 UIView，UIViewController，UIApplication 都是它的子类。 UIResponder 定义了一系列方法，用于接收和处理用户事件，例如触摸事件，运动时间(如摇晃)和功能控制事件(如编辑文本和播放音乐)等。 在上面的事件中，触摸事件应该由被触摸的视图负责处理，其他类型的事件会由第一响应者负责处理。 UIWindow 有一个 firstResponder 属性指向第一响应者。 main() 与 UIApplication用 c 写的程序，入口都是 main(): 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; UIApplicationMain 函数会创建一个 UIApplication 对象。每个 iOS 应用都有且只有一个 UIApplication 对象，该对象作用是维护运行循环。一旦程序创建了某个 UIApplication 对象，该对象就会一直循环下去， main() 的执行也会因此堵塞。 UIApplicationMain 函数还会创建某个指定类的对象，并将其设置为 UIApplication 对象的 delegate。该对象的类由 UIApplicationMain 的最后一个参数指定。 应用启动运行循环并开始接收事件前， UIApplication 对象会像其委托发送一个特定的消息，使应用完成相应的初始化工作。这个消息的名称是 application:didFinishLaunchingWithOptions: UIMenuControlleriOS SDK 提供一个名为 UIMenuController 的类，可以用来显示菜单。例如在单击手势的实现方法中弹出一个菜单： 123456789101112131415- (void)tap:(UIGestureRecognizer *)gr&#123; // 获取手势的坐标 CGPoint point = [gr locationInView:self]; // 让视图变成 UIMenuItem 动作消息的目标 [self becomeFirstResponder]; // 获取 UIMenuController 对象 UIMenuController *menu = [UIMenuController sharedMenuController]; // 创建一个新的标题为"delete"的UIMenuItem对象 UIMenuItem *deleteItem = [[UIMenuItem alloc] initWithTitle:@"Delete" action:@selector(deleteLine:)]; menu.menuItems = @[deleteItem]; // 先为 UIMenuController 对象设置显示区域，然后将其设置为可见 [menu setTargetRect:CGRectMake(point.x,point.y,2,2) inView:self]; [menu setMenuVisible:YES animated:YES];&#125; 要显示 UIMenuController 对象，还要满足一个条件：显示 UIMenuController 对象的 UIView 对象必须是当前 UIWindow 对象的第一响应对象。如果要将某个自定义的 UIView 子类对象设置为第一响应对象，就必须覆盖该对象的 canBecomeFirstResponder 方法： 123- (BOOL)canBecomeFirstResponder&#123; return YES;&#125; 问题： 什么情况下会进行重绘，重绘的时机是什么时候？ loadView 什么时候会被调用？ 系统的 loadView 做了什么事？什么情况下要自定义 loadView ？要注意什么？ 为什么要在 xib 中设置 Files’s Owner 的 Custom Class 为目标 ViewController？ 插座变量为什么要设置为 weak？ 为什么不能将 ViewController 设置为 View 的 Custom Class ？ 将某个 View 设置为 Files’s Owner 的 Custom Class 或者设置为 View 的 Custom Class 在创建方式上有什么不同？ initWithCoder 何时会被调用？怎么使用？ 如何将 ViewController 的 xib 中拖拽出的一个 view 和自定义的 View 关联？此时怎么用这个自定义的 View 加载另一个 nib 文件？有什么注意点？ 如何设置一个 UITabBarController，包括 tabbar、tabBarItem 属性？ 如何给一个 View 设置一个 UIMenuController？对这个 View 有什么要求？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 使用技巧]]></title>
    <url>%2F2016%2F07%2F31%2Fmac%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[使用 Mac 用到的一些方法 取消Mac工作区切换之后自动重排工作区切换后自动重排真是一个非常sb的功能。可能我原本将Xcode，Chrome，微信排好的顺序在切换了一次程序之后就变了。这是一直困扰我的一个问题。 解决方法其实很简单，在“偏好设置”中选择“调度中心”，取消“勾选根据最近的使用情况自动重新排列 Spaces ”即可。 隐藏 dockerdocker 非常占用桌面空间，如果你为常用应用设置了快捷键，并且使用 Alfred，那么你就可以摆脱 docker，将其隐藏。方式是将 docker 设置为不用时隐藏，然后通过命令行设置显示时间： 1234-- 设置鼠标到对应位置停顿十秒才会显示$ defaults write com.apple.dock autohide-delay -int 10-- 设置立刻重启docker$ killall Dock 搜索目录下的文件使用 grep12-- 搜索当前目录下名字带有 zachary 的文件。文件名使用正则表达式$ ls -R | grep zachary 不过这样不带子文件夹的路径。只适合在当前文件夹下。 使用 find12-- 搜索当前目录下名字带有 zachary 的文件。文件名使用通配符$ find ./ -name '*zachary*' 拷贝文件到目标机器通过 scp 将文件拷贝到目标机器的根目录下 1scp ./xxx.js 10.26.5.145:~ ssh免密登录在目标机器的 .ssh 文件夹下新建一个 authorized_keys 文件，在其中加入自己的 ssh_pub 即可 登录的时候输入： 1ssh zachary@10.26.5.145 退出使用 1exit 应用程序弹窗选择有时候应用程序会弹窗，如下图，你只能按回车确定，否则必须使用鼠标选择取消： 可以通过在命令行下敲如下命令提供键盘的控制方式： 1defaults write NSGlobalDomain AppleKeyboardUIMode -int 3 就可以通过 tab 切换选中项，space 选中选中项(enter 还是表示默认确定) 装机必备安装 homebrew1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 cocoapods修改 ruby 源123456//删除默认源$gem sources --remove https://rubygems.org///添加新源$gem sources -a http://gems.ruby-china.org///查看$ gem sources -l 安装 cocoapods1$ sudo gem install cocoapods 安装 node1brew install node 安装好node自然就安装好 npm 了。 使用 iterm2iterm2 最强大的功能就是可以分屏。还有就是可以选中即复制，以及按住 command 点击就可以直接跳转到文件夹或者网页。 下载主题官方的颜色默认是黑色的，可以去Iterm2-color-schemes下载主题，下载 tar.gz 或者 zip 的压缩包，然后会下载非常多的配色。然后按照如下图操作配色： 。 推荐使用 Solarized Dark Higher Contrast 下载 zshzsh 可以提供一个很强的命令补全的功能，反正不太记得的命令或者参数，只要按 tab 就行了。下载也比较简单： 1curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh curl 是利用URL语法在命令行方式下工作的开源文件传输工具。 另外，下载之后终端会变得比较好看。 下载字体 Fira字体 Fira 非常圆润，适合作为代码编辑器的字体，下载也非常简单。但是比较字体包有点大： 12brew tap caskroom/fontsbrew cask install font-fira-code brew 表示 homebrew VSCode 同步方案VSCode 的插件 Setting Sync 提供了通过 github 的 Gist 完成配置同步的功能。但是由于它的教程不完整，导致同步起来会产生省问题。最常见的问题是无法下载配置，提示信息为：Sync : Invalid / Expired GitHub Token. Please generate new token with scopes mentioned in readme. Exception Logged in Console. Gist 可以保存上传的配置文件。拉取配置文件需要配置两个 id，一个是 Gist Id，一个是 Token Id。这两个 Id 前者标识配置文件，后者用于身份验证。我们无法下载的原因就是我们使用单单在 Sync:Download Settings 命令中使用了 Gist id，所以错误提示才是无效的 token。 那么该怎么进行身份验证呢？还是在 VSCode 中输入命令：Sync:Advanced Options，然后选择 Sync:Edit Extension Local Settings，编辑 syncLocalSettings.json 这个配置文件。这个文件中有一项 token 没有设置，这里就需要设置为 Token Id。你可以用之前上传配置文件时设置的 Token，也可以再新建一个 Token。 sudo 仍然无法获得权限有些时候使用 sudo 命令仍然会失败，提示 Operation not permitted。这是因为开启了 sip 的缘故。我们需要关闭 sip： 重启OSX系统，然后按住Command+R，进入恢复模式 出现界面之后，选择屏幕左上角菜单栏中的实用工具中的Terminal，打开终端 在Terminal中输入csrutil disable 关闭SIP 重启reboot OSX npm 全局安装无权限有时候我们使用 sudo npm install -g xxx 的时候仍然提示 Error: EACCES: permission denied。 这个时候可以增加一些选项： 1sudo npm install -g xxx --unsafe-perm=true --allow-root shell 脚本 sudo 命令不输入密码expectexpect 可以在需要密码的时候输入密码。安装 expect 非常简单： 1brew install expect 123456789#!/usr/bin/expectset timeout 30spawn bash "./Untitled-1.sh"expect &#123; Password: &#123; send xxxx\r &#125; Password: &#123; send xxxx\r &#125; Password: &#123; send xxxx\r &#125;&#125;interact #!/usr/bin/expect 表示到 interact 为止，都使用 expect 执行 spawn 该命令用于启动一个子进程，执行后续命令. expect 从进程接受字符串，如果接受的字符串和期待的字符串不匹配，则一直阻塞，直到匹配上或者等待超时才继续往下执行。上面的 Password： 就是执行 sudo 命令是会出现的。 这里模拟了三个会出现 Password: 输入密码的场景。 send 向进程发送字符串，与手动输入内容等效，通常字符串需要以’\r’结尾。 interact 该命令将控制权交给控制台，之后就可以进行人工操作了。通常用于使用脚本进行自动化登录之后再手动执行某些命令。如果脚本中没有这一条语句，脚本执行完将自动退出。 sudo 不要密码除了用 expect 在需要密码的时候输入外，还可以设置 sudo 不需要密码。虽然不安全，但是一般个人使用也不会有什么问题。 输入 sudo visudo 会打开 /etc/sudoers 文件，这就是要修改的配置文件。 然后再最后输入： 1zachary ALL=(ALL) NOPASSWD: ALL 保存并推出。此时 sudo 就不会再需要密码了。 那么这句话是什么意思呢？ 第一个字段 zachary 表示使用 sudo 命令的用户为 zachary 第二个字段，等号左边的 ALL 表示允许使用 sudo 的主机。这里是所有主机。 第三个字段，等号右边的 (ALL) 表示使用 sudo 后一什么身份来执行命令。 最后一个字段 NOPASSWD: ALL 表示所有命令，都不需要密码。 管道与 xargs管道管道的作用就是把前一个命令的标准输出作为后一个命令的标准输入，比如： 1ls -a | grep myfile 上面的命令就是把列出所有文件的输出，作为正则匹配查找的输入。 但是很多程序是不处理标准输入的，例如 kill , rm 这些程序如果命令行参数中没有指定要处理的内容则不会默认从标准输入中读取，所以： 1ls -a | grep myfile | rm -f 这个命令是无法删除 myfile 相关的文件的。这时候就需要使用 xargs xargsxargs 和管道有什么不同可以看下面这个例子： 123456echo '--help' | cat 输出：--helpecho '--help' | xargs cat 输出同 cat --help 可以发现，xargs 将其接受的字符串 —help 做成cat的一个命令参数来运行cat命令。 所以上面的删除方法要改成如下，就是可以达到目的的： 1ls -a | grep myfile | xargs rm -f xargs 还有许多参数，可以用在需要多个参数的情况，如果有需求，可以查阅使用。 使用 npmrc 登录 npm我们要发布自己的 npm 包的时候，需要先登录到 npm。那么，npm 怎么验证发布的是本人呢？当我们在 shell 里登录到 npm 的时候，在 home 目录下会生成一个 .npmrc 文件。这个文件里有个 authToken ，同时，你的 npm 账户里的 token 列表里也会产生一个相应的 token。当你要发布代码的时候，npm 就会比较账户里的 token 是否包含这个 authToken。如果你手动删除了 npm 账户里的 token，那么之后也就无法通过该 authToken 登录了。 另外，每个项目里都可以有一个 .npmrc 使用不同的 token。项目里没有 token 的情况下才回去 home 下查找 .npmrc 自制一个搜索 Markdown 文件的 workflow可以自制一个 workflow 而不是使用 open 打开 markdown 文件。 主要步骤就是新建一个 workflow，然后 右键→Inputs→File Filter。这里的重点就是选择 File Filter，这样系统会自动进行文件搜索。然后在弹出的设置界面设置关键字，以及搜索的文件类型。你也可以在第二个选项卡中设置搜索路径： 然后设置这个操作的动作：拉线→Actions→Open File。Open File 出现的设置界面不用任何操作，直接点完成即可： 一般我们使用的打开 Xcode 工程也可以这样设置。 Alfred3 开机访问通讯录破解的 Alfred3 每次开机都要访问通讯录，解决办法是在终端中进行签名: 1sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework 安装的Mac应用显示已损坏无法打开设置 =&gt; 安全性与隐私 =&gt; 通用 =&gt; 允许从以下位置下载的应用 =&gt; 任何来源 如果没有 任何来源 这个选项，需要执行命令： 1sudo spctl --master-disable 如何显示/不显示隐藏文件在终端中执行如下代码并重启动Finder。 1234显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool TRUE停止显示隐藏文件：defaults write com.apple.finder AppleShowAllFiles -bool FALSE 新系统中更好的方式： 可以使用快捷键 shift+command+. handoff 无法使用handoff 是一个能在电脑和手机间共享信息的东西，但是有的时候就是识别不到。如果已经明确自己开启了 handoff 但是任然无法使用，那么可以先关闭电脑的蓝牙功能，然后再打开。这样就可以使用了。 如何破解欧路的使用次数限制非注册用户只能使用 Xcode 50次，为了省这 98块钱就在网上找破解版，无意中搜到了修改使用次数的方法。 在 ~/library/preferences/ 文件夹里，找到 com.eusoft.eudic.plist 文件。用 Xcode 打开它，然后找到并修改 MAIN_TimeLeft 的值： 1&lt;key&gt;MAIN_TimeLeft&lt;/key&gt; &lt;integer&gt;50&lt;/integer&gt;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新开始]]></title>
    <url>%2F2016%2F07%2F30%2F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。 不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。 今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！]]></content>
      <categories>
        <category>无处置放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>无处置放</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
