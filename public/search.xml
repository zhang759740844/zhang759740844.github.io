<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS中的多线程学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/11/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>在学习 RunLoop 的时候，碰到了一些不太理解的东西，查阅资料后发现是多线程的相关方法。因此在完成 RunLoop 的笔记前，先学习下多线程的使用方法。<br><a id="more"></a></p>
<p>可以通过三种方式实现 iOS 的多线程：</p>
<ul>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation&amp;NSOperationQueue</li>
</ul>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><h3 id="创建并启动"><a href="#创建并启动" class="headerlink" title="创建并启动"></a>创建并启动</h3><h4 id="先创建线程类，再启动"><a href="#先创建线程类，再启动" class="headerlink" title="先创建线程类，再启动"></a>先创建线程类，再启动</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建</span></div><div class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="literal">nil</span>];</div><div class="line"><span class="comment">// 启动</span></div><div class="line">[thread start];</div></pre></td></tr></table></figure>
<p>其中，<code>run:</code> 是即将执行的方法，<code>object</code> 是 <code>run:</code> 方法的参数。规定 <code>run:</code> 方法最多可有一个参数，且返回类型必须是 <code>void</code>。</p>
<h4 id="创建并自动启动"><a href="#创建并自动启动" class="headerlink" title="创建并自动启动"></a>创建并自动启动</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run:) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<h4 id="使用-NSObject-的方法创建并自动启动"><a href="#使用-NSObject-的方法创建并自动启动" class="headerlink" title="使用 NSObject 的方法创建并自动启动"></a>使用 NSObject 的方法创建并自动启动</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run:) withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法可以去类的定义里去看。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取消线程</span></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"></div><div class="line"><span class="comment">//启动线程</span></div><div class="line">- (<span class="keyword">void</span>)start;</div><div class="line"></div><div class="line"><span class="comment">//判断某个线程的状态的属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="built_in">BOOL</span> finished;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"></div><div class="line"><span class="comment">//设置和获取线程名字</span></div><div class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n;</div><div class="line">-(<span class="built_in">NSString</span> *)name;</div><div class="line"></div><div class="line"><span class="comment">//获取当前线程信息</span></div><div class="line">+ (<span class="built_in">NSThread</span> *)currentThread;</div><div class="line"></div><div class="line"><span class="comment">//获取主线程信息</span></div><div class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</div><div class="line"></div><div class="line"><span class="comment">//使当前线程暂停一段时间，或者暂停到某个时刻</span></div><div class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)time;</div><div class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</div></pre></td></tr></table></figure>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>该部分前一篇关于 GCD 的文章已经较为详细的研究过了。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>暂时没有时间看，先占个坑</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>使用 <code>@synchronized</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">    <span class="comment">//需要执行的代码块</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h4><p>把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。</p>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><h4 id="perform"><a href="#perform" class="headerlink" title="perform"></a>perform</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3秒后自动调用self的run:方法，并且传递参数：@"abc"</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"abc"</span> afterDelay:<span class="number">3</span>];</div></pre></td></tr></table></figure>
<h4 id="GCD-1"><a href="#GCD-1" class="headerlink" title="GCD"></a>GCD</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">// 设置延时，单位秒</span></div><div class="line"><span class="keyword">double</span> delay = <span class="number">3</span>; </div><div class="line"></div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class="line">    <span class="comment">// 3秒后需要执行的任务</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="string">@"abc"</span> repeats:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
<h3 id="从其他线程回到主线程的方法"><a href="#从其他线程回到主线程的方法" class="headerlink" title="从其他线程回到主线程的方法"></a>从其他线程回到主线程的方法</h3><p>在其他线程操作完成后必须到主线程更新UI</p>
<h4 id="NSThread-1"><a href="#NSThread-1" class="headerlink" title="NSThread"></a>NSThread</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
<h4 id="GCD-2"><a href="#GCD-2" class="headerlink" title="GCD"></a>GCD</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">  ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runLoop学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/11/01/runloop/</url>
      <content type="html"><![CDATA[<p>runLoop 虽然平时用不到，但是面试的时候问的多啊。那我也就来了解一下 runLoop 的原理。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h3><p>以下是一个 iOS 程序的 main 函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main 函数是程序的入口，那么为什么程序执行完毕后没有退出呢？因为 RunLoop，使线程循环，能够随时处理事件但并不退出。这种方式在各个框架中都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>上面代码中 <code>UIApplicationMain()</code> 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 RunLoop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。流程图如下所示：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_1.png?raw=true" alt="runloop_1"></p>
<p>在 OS X/iOS 系统中，提供了两个这样的对象：</p>
<ul>
<li><strong>CFRunLoopRef</strong>：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</li>
<li><strong>NSRunLoop</strong>：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</li>
</ul>
<p>先来一张 RunLoop 机制关系图总览：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_2.png?raw=true" alt="runloop_2"></p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>苹果不允许直接创建 RunLoop，提供了两个获取函数，CFRunLoopRef 的获取方法为 <code>CFRunLoopGetMain()</code>， <code>CFRunLoopGetCurrent()</code>。NSRunLoop 的获取方法是 <code>currentRunLoop</code>,<code>mainRunLoop</code>。NSRunLoop 对象可以通过 <code>getCFRunLoop</code> 方法获得 CFRunLoopRef 对象。CFRunLoopRef 的内部逻辑如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</div><div class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</div><div class="line"> </div><div class="line"><span class="comment">/// 获取一个 pthread 对应的 Run Loop。</span></div><div class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</div><div class="line">    OSSpinLockLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</div><div class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。</span></div><div class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</div><div class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></div><div class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">        <span class="comment">/// 取不到时，创建一个</span></div><div class="line">        loop = _CFRunLoopCreate();</div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</div><div class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。</span></div><div class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    OSSpinLockUnLock(&amp;loopsLock);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的(这也就解释了前面关系图中 CFRunLoop 和 Thread 连线中的两个<code>1</code>的意义)，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop对外接口"><a href="#RunLoop对外接口" class="headerlink" title="RunLoop对外接口"></a>RunLoop对外接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中，CFRunLoopModeRef 类并没有对外暴露，不能直接得到其对象，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_3.png?raw=true" alt="runloop_3"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><h4 id="RunLoop的Source"><a href="#RunLoop的Source" class="headerlink" title="RunLoop的Source"></a>RunLoop的Source</h4><p>RunLoop 对象处理的事件源分为两种：Input sources 和 Timer sources（分别对应上面的 CFRunLoopSourceRef 和 CFRunLoopTimerRef，统称为事件源）：</p>
<ul>
<li>Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：<code>performSelector:onThread:</code></li>
<li>Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：<code>[NSTimer scheduledTimerWithTimeInterval:target:selector:]</code></li>
</ul>
<p>下图是苹果官方的一张图，展示了 RunLoop 的概念结构及各种事件源<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_4.png?raw=true" alt="runloop_4"></p>
<h5 id="Input-Source"><a href="#Input-Source" class="headerlink" title="Input Source"></a>Input Source</h5><p>Input Source 也就是 CFRunLoopSourceRef 有两个版本:Source0(Custom Input Sources)和 Source1(Port-Based Sources)：</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>
</ul>
<h5 id="Time-Source"><a href="#Time-Source" class="headerlink" title="Time Source"></a>Time Source</h5><p>基于时间的触发器，它和 NSTimer 是 Toll-Free Bridging 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒以执行那个回调。</p>
<p>Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 <code>scheduledTimerWithTimeInterval</code> 开头的方法创建的 Timer 都需要手动添加到当前 RunLoop 中。（<code>scheduledTimerWithTimeInterval</code> 创建的 Timer 会自动以 Default Mode 加载到当前 RunLoop中。）</p>
<h4 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h4><p>RunLoop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 RunLoop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 RunLoop Mode 后，你的 RunLoop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，RunLoop 都是运行在系统定义的默认模式上。</p>
<p>系统默认定了一下几个 mode：</p>
<ul>
<li>kCFRunLoopDefaultMode：App：App的默认 Mode，通常主线程是在这个 Mode 下运行的</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）</li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes：这是一个占位的 Mode，包含上面的 kCFRunLoopDefaultMode 以及 UITrackingRunLoopMode</li>
</ul>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入 CommonModes 中。</p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</div><div class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</div></pre></td></tr></table></figure>
<h4 id="RunLoop的Observers"><a href="#RunLoop的Observers" class="headerlink" title="RunLoop的Observers"></a>RunLoop的Observers</h4><p>对比上面说的事件源，它们是在特定的同步事件或异步事件发生时被触发，RunLoop Observers 就不一样了，它是在 RunLoop 执行自己的代码到某一个指定位置时被触发。我们可以用 RunLoop Observers 来跟踪到这些事件：</p>
<ul>
<li>进入 RunLoop 的时候</li>
<li>RunLoop 将要处理一个 Timer source 的时候</li>
<li>RunLoop 将要处理一个 Input source 的时候</li>
<li>RunLoop 将要休眠的时候</li>
<li>RunLoop 被唤醒，并准备处理唤醒它的事件的时候</li>
<li>RunLoop 将要退出的时候</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="Input-Source-1"><a href="#Input-Source-1" class="headerlink" title="Input Source"></a>Input Source</h4><h4 id="Timer-Source"><a href="#Timer-Source" class="headerlink" title="Timer Source"></a>Timer Source</h4><h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><p>这几个方面看起来太麻烦了，而且真的用不到，所以不想看了。=。=55555。贴几个介绍如何使用的博客吧，如果真的要用到了再看。<br><a href="http://yangchao0033.github.io/blog/2016/01/18/runloop-5/" target="_blank" rel="external">RunLoop深度探究（五）</a><br><a href="http://blog.imemo8.com/2016/04/17/RunLoop/" target="_blank" rel="external">RunLoop</a><br><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/" target="_blank" rel="external">走进Run Loop的世界 (一)：什么是Run Loop？</a><br><a href="https://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html" target="_blank" rel="external">iOS多线程编程指南（三）Run Loop</a><br>相关使用 Demo 也放到 github 上了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_5.png?raw=true" alt="runloop_5"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 用DefaultMode启动</span></div><div class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// RunLoop的实现</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</div><div class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">/// 内部函数，进入loop</span></div><div class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class="line">        </div><div class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"> </div><div class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</div><div class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></div><div class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></div><div class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></div><div class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class="line">            </div><div class="line">            <span class="comment">/// 收到消息，处理消息。</span></div><div class="line">            handle_msg:</div><div class="line"> </div><div class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</div><div class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</div><div class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 执行加入到Loop的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></div><div class="line">                retVal = kCFRunLoopRunHandledSource;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></div><div class="line">                retVal = kCFRunLoopRunTimedOut;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class="line">                <span class="comment">/// 被外部调用者强制停止了</span></div><div class="line">                retVal = kCFRunLoopRunStopped;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></div><div class="line">                retVal = kCFRunLoopRunFinished;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h3 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h3><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 <code>mach_msg_trap()</code>，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 <code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_6.png?raw=true" alt="runloop_6"></p>
<p><strong>RunLoop 的核心就是一个 <code>mach_msg()</code>，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</strong></p>
<p>关于具体的如何利用 mach port 发送信息，哈哈，这个就不是我研究的东西了。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>苹果使用 RunLoop 实现了诸多功能</p>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>Autorelease 对象什么时候释放？答案当然不是“当前作用域大括号结束时释放”。在没有手加 Autorelease Pool 的情况下，Autorelease 对象是在当前的 runloop 迭代结束时释放的，而它能够释放的原因是系统在每个 runloop 迭代中都加入了自动释放池 Push 和 Pop。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> reference = <span class="literal">nil</span>;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</div><div class="line">    <span class="comment">// str是一个autorelease对象，设置一个weak的引用来观察它</span></div><div class="line">    reference = str;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: sunnyxx</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: (null)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在 <code>viewDidLoad</code> 方法后，一直到 <code>viewWillAppear</code> 字符串 reference 都没有被销毁，直到 <code>viewDidAppear</code> 方法后，才置为 <code>null</code>(这里创建字符串用的是 <code>stringWithFormat</code>，是在堆中创建一个对象，而不是在常量区)。由于这个 vc 在 <code>loadView</code> 之后便 add 到了 window 层级上，所以 <code>viewDidLoad</code> 和 <code>viewWillAppear</code> 是在同一个 <code>runloop</code> 调用的，因此在 <code>viewWillAppear</code> 中，这个 autorelease 的变量依然有值。</p>
<p>当然，我们也可以手动干预Autorelease对象的释放时机：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str); <span class="comment">// Console: (null)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="AutoreleasePool-原理"><a href="#AutoreleasePool-原理" class="headerlink" title="AutoreleasePool 原理"></a>AutoreleasePool 原理</h4><p>ARC下，我们使用 <code>@autoreleasepool{}</code> 来使用一个 AutoreleasePool，随后编译器将其改写成下面的样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</div><div class="line"><span class="comment">// &#123;&#125;中的代码</span></div><div class="line">objc_autoreleasePoolPop(context);</div></pre></td></tr></table></figure>
<p>而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类。</p>
<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_7.png?raw=true" alt="runloop_7"></p>
<ul>
<li>AutoreleasePool 并没有单独的结构，而是由若干个 AutoreleasePoolPage 以双向链表的形式组合而成（分别对应结构中的 parent 指针和 child 指针）</li>
<li>AutoreleasePool 是按线程一一对应的（结构中的 thread 指针指向当前线程）</li>
<li>AutoreleasePoolPage 每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址</li>
<li>上面的 <code>id *next</code> 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置</li>
<li>一个 AutoreleasePoolPage 的空间被占满时，会新建一个 AutoreleasePoolPage 对象，连接链表，后来的 autorelease 对象在新的 page 加入</li>
</ul>
<p>所以，若当前线程中只有一个 AutoreleasePoolPage 对象，并记录了很多 autorelease 对象地址时内存如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_8.png?raw=true" alt="runloop_8"></p>
<p>图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 page 对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。所以，向一个对象发送 <code>autorelease</code> 消息，就是将这个对象加入到当前 AutoreleasePoolPage 的栈顶 next 指针指向的位置。</p>
<p>每当进行一次 <code>objc_autoreleasePoolPush</code> 调用时，runtime 向当前的 AutoreleasePoolPage 中 add 进一个哨兵对象，值为0（也就是个 nil），那么这一个 page 就变成了下面的样子：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_9.png?raw=true" alt="runloop_9"></p>
<p><code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code> (哨兵对象)作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的 page</li>
<li>在当前 page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 <code>- release</code> 消息，并向回移动 next 指针到正确位置</li>
<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个 page，直到哨兵所在的 page</li>
</ol>
<p>刚才的 <code>objc_autoreleasePoolPop</code> 执行后，最终变成了下面的样子：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_10.png?raw=true" alt="runloop_10"></p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。 SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的  <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback:</div><div class="line">        CA::Transaction::commit();</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</div><div class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [<span class="built_in">CALayer</span> display];</div><div class="line">                            [<span class="built_in">UIView</span> drawRect];</div></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>定时器使用方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(showTime) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure>
<p>这里如果不是用的 <code>NSRunLoopCommonModes</code> 而是 <code>NSDefaultRunLoopMode</code> 那么当界面滑动时，无法执行 <code>showTime</code> 方法回调。当滑动停止时，立刻执行最初的注册的定时事件，之后由于滑动导致未能注册的事件的回调一律忽略。</p>
<h3 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h3><p>当调用 NSObject 的 <code>performSelector:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>
<p>所以一般还是在主线程调用这些方法，如果实在要在子线程里调用，那么记得在其后调用 <code>[[NSRunLoop currentRunLoop] run];</code></p>
<h3 id="关于-GCD"><a href="#关于-GCD" class="headerlink" title="关于 GCD"></a>关于 GCD</h3><p>GCD 提供的某些接口也用到了 Run Loop， 例如 <code>dispatch_async()</code>。</p>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<ul>
<li>CFSocket</li>
<li>CFNetwork       -&gt;ASIHttpRequest</li>
<li>NSURLConnection -&gt;AFNetworking</li>
<li>NSURLSession    -&gt;AFNetworking2, Alamofire</li>
</ul>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runloop_11.png?raw=true" alt="runloop_11"></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</div><div class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">        [runLoop run];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</div><div class="line">        [_networkRequestThread start];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _networkRequestThread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 <code>[runLoop run]</code> 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 <code>NSMachPort (mach_port)</code> 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</div><div class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 <code>[NSObject performSelector:onThread:..]</code> 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a><br><a href="http://itangqi.me/2016/04/14/the-first-meet-with-runloop/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">初识 Run Loop</a><br><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios中库的介绍与使用]]></title>
      <url>http://zhang759740844.github.io/2016/10/17/%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>最近由于要接入第三方库，因此想要了解库的相关知识。网上查阅了许多资料，仍然比较疑惑。比如，静态库能否以及如何引入动态库？动态库能否以及如何引入静态库？自建动态库(非系统动态库)的好处体现在哪，怎么实现？等等。在一番探索之后，总结了一篇较为详尽全面的库的使用方法。</p>
<a id="more"></a>
<p>先来看一张思维导图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/库.png?raw=true" alt="库"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是共享程序代码的方式。库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。在开发过程中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成库，只暴露出头文件以供使用。库分静态库和动态库两种。</p>
<h3 id="库的分类"><a href="#库的分类" class="headerlink" title="库的分类"></a>库的分类</h3><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>存在 <code>.a</code> 和 <code>.framework</code> 两种形式。 <code>.a</code> 是一个纯二进制文件，<code>.framework</code> 中除了有二进制文件之外还有资源文件。 <code>.a</code> ，要有 <code>.h</code> 文件以及资源文件配合， <code>.framework</code> 文件可以直接使用。总的来说，<code>.a + .h + sourceFile = .framework</code>。所以创建静态库最好还是用<code>.framework</code>的形式。</p>
<p>对于静态库而言，类似于一个编译好的 <code>.o</code> 的集合。在build的过程中，只会参与链接的操作，链接器会将静态库中被使用的部分合并到可执行文件中去，用函数的实际地址来代替函数引用。链接流程如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_1.jpg?raw=true" alt="静态库的链接过程"></p>
<h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>存在<code>.framework</code>和<code>.tbd</code>两种形式。</p>
<p>在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 <strong>App Extension</strong> 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p>
<p>动态链接是使用了 <strong>Procedure Linkage Table (PLT)</strong>。首先这个 <strong>PLT</strong> 列出了程序中每一个函数的调用，<strong>当程序开始运行</strong>，如果动态库被加载到内存中，<strong>PLT</strong> 会去寻找动态的地址并记录下来，如果函数被调用过的话，下一次调用就可以通过 <strong>PLT</strong> 直接跳转了。</p>
<h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>静态库，在链接时会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝。<br>好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<p>动态库，与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。<br>系统的动态库不需要拷贝到目标程序中，自建的动态库可以由工程内的多个库共享，因此可以减小目标程序的体积。但是，由于其把静态链接做的事情都搬到运行时来做，程序的启动会变慢。</p>
<h2 id="库的创建"><a href="#库的创建" class="headerlink" title="库的创建"></a>库的创建</h2><h3 id="a静态库的创建"><a href="#a静态库的创建" class="headerlink" title=".a静态库的创建"></a>.a静态库的创建</h3><p>创建一个 <code>.a</code> 静态库项目，如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_2.png?raw=true" alt="lib_2"><br>静态库的文件列表如下，在 <strong>products</strong> 文件夹内的就是要生成的静态库。此刻是红色的，等到生成成功就会变成黑色。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_3.png?raw=true" alt="lib_3"><br>现在新建自己的类<code>PrintString.h</code>，声明和实现一个第三方库的方法。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_4.png?raw=true" alt="lib_4"><br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_5.png?raw=true" alt="lib_5"><br>现在可以打包这个静态库了。由于模拟器和真机架构不同，需要选择该包将运行在哪个环境下，如下图所示，选择运行在真机上：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_6.png?raw=true" alt="lib_6"><br>打包生成了静态库在 <strong>products</strong> 文件夹内：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_7.png?raw=true" alt="lib_7"><br>打开 <strong>products</strong> 文件夹， 但是此时暴露出来的头文件并没有<code>PrintString.h</code>。需要对暴露的头文件进行设置。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_8.png?raw=true" alt="lib_8"><br>如下图，在 <strong>Build Phase</strong> ，的 <strong>Copy Files</strong> 目录下加入想要公开的头文件：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_9.png?raw=true" alt="lib_9"><br>现在再 run 一次，就得到了正确的静态库。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_10.png?raw=true" alt="lib_10"><br>现在，可以测试一下这个静态库。可以再创建一个工程，把库拖进去。不过更推荐如下图所示，新建一个 <strong>target</strong> ：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_11.png?raw=true" alt="lib_11"><br>先要在工程和库间建立关联。如下图所示，在 <strong>Link Binary With Libraries</strong> 中添加库：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_12.png?raw=true" alt="lib_12"><br>在 <code>ViewController.m</code> 中调用库的方法：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_13.png?raw=true" alt="lib_13"><br>现在可以运行了，不过运行前要选择对 <strong>target</strong> ：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_14.png?raw=true" alt="lib_14"><br>可以在控制台看到库中的方法被调用了：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lib_15.png?raw=true" alt="lib_15"></p>
<h3 id="framework的创建"><a href="#framework的创建" class="headerlink" title=".framework的创建"></a>.framework的创建</h3><h4 id="动态framework"><a href="#动态framework" class="headerlink" title="动态framework"></a>动态framework</h4><p>创建一个framework：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_1.png?raw=true" alt="frame_1"><br>创建后的文件列表如下，可以看到只有一个 <code>framework.h</code> 头文件。通过注释，我们可以理解，这个头文件是所有 public 头文件的集合：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_2.png?raw=true" alt="frame_2"><br>将前面创建的 <code>PrintString.h</code> 和 <code>PrintString.m</code> 导入，并且 import 到 <code>framework.h</code> 中去：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_3.png?raw=true" alt="frame_3"><br>设置需要暴露的头文件，头文件默认在 <strong>project header</strong> 中，将需要暴露出来的拖到 <strong>public header</strong> 中去。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_4.png?raw=true" alt="frame_4"><br>我们可以看到此处有三种头文件，分别是 <strong>project header</strong> ， <strong>public header</strong> ， <strong>private header</strong> 。区别如下：</p>
<blockquote>
<p>Public: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.</p>
<p>Private: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they’re not supposed to use them.</p>
<p>Project: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.</p>
</blockquote>
<p>生成的 framework 文件目录如下：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_5.png?raw=true" alt="frame_5"></p>
<p>将生成的 framework 放入工程中测试，编译通过，运行时出现如下错误：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_6.png?raw=true" alt="frame_6"></p>
<p>需要将动态库嵌入工程的 bundle 中。因此，需要在 General 中的 <strong>Embedded Binary</strong> 一项中加入相应动态库：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_7.png?raw=true" alt="frame_7"></p>
<p>现在就可以正确运行了</p>
<h4 id="静态framework"><a href="#静态framework" class="headerlink" title="静态framework"></a>静态framework</h4><p>静态framework和动态framework创建的基本流程一致，唯一的区别需要设置 <strong>Mach-O Type</strong> 为 <code>Static Library</code> ：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/fram_8.png?raw=true" alt="frame_8"></p>
<h3 id="静态库与动态库的引用"><a href="#静态库与动态库的引用" class="headerlink" title="静态库与动态库的引用"></a>静态库与动态库的引用</h3><p>一个库的开发经常会需要用到其他的库(如 <code>AFNetWorking</code> )的配合，因此，需要在库中嵌入其他的库。如何在自己的静态/动态库中集成第三方的静态/动态库是我比较困惑的点。</p>
<p><em>网上没有找到相关教程，以下是我不断尝试后得出的结论，如果有错误还请指正。</em></p>
<h4 id="动态库引用静态库"><a href="#动态库引用静态库" class="headerlink" title="动态库引用静态库"></a>动态库引用静态库</h4><p>创建一个动态库 <code>DynamicWithStatic</code>。</p>
<p>使用 <strong>cocoapods</strong> 的方式为动态库引入静态库。在工程目录下新建 <code>podfile</code>,写入:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target <span class="string">'DynamicWithStatic'</span> <span class="keyword">do</span></div><div class="line">pod <span class="string">'SVProgressHUD'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这里引入<code>SVProgressHUD</code>，因为调试起来比较简单。</p>
<p>在执行完 <code>pod install</code> 后，打开 <code>Frameworks.xcworkspace</code> ,在其中添加<code>SVProgress</code>类。现在的工程目录如下：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_1.png?raw=true" alt="动静库引用"></p>
<p>在<code>SVProgress.h</code>中添加代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SVProgresshud)();</div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SVProgress</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (SVProgresshud)getBlock;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在<code>SVProgress.m</code>中添加代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SVProgress.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SVProgressHUD.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SVProgress</span></span></div><div class="line">+(SVProgresshud)getBlock&#123;</div><div class="line">    <span class="keyword">return</span> ^()&#123;</div><div class="line">        [SVProgressHUD showSuccessWithStatus:<span class="string">@"成功！"</span>];</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>SVProgress</code>类的目的是提供一个 block 以供调用。将 <code>SVProgress.h</code> 头文件暴露出来后， run 生成动态库。</p>
<p>动态库内引用静态库相当于直接把代码写入动态库中，非常的简单。现在思考一个问题，如果工程中引用了这个动态库，并且工程本身也用到了 <code>SVProgressHUD</code> 库，那么会发生什么？尝试一下，在 Pod 中为 <code>FrameworkTest</code> 添加 <code>SVProgressHUD</code> ,会产生如下的警告：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_2.png?raw=true" alt="重复实现"></p>
<p><code>SVProgressHUD</code> 库中的各个类在工程和库中都进行了实现，但是没有指明使用哪一个实现。不过这个警告，并不影响运行，非强迫症可以选择无视，那么对于强迫症患者，如何消除掉这些警告呢？修改库中 <code>SVProgressHUD</code> 中各个类的命名。有两种方式：手动和自动，将在下面介绍。</p>
<h4 id="动态库引用动态库"><a href="#动态库引用动态库" class="headerlink" title="动态库引用动态库"></a>动态库引用动态库</h4><p>这次被引用的动态库还是 <code>SVProgressHUD</code> 库。先用 pod 下载 <code>SVProgressHUD</code> 的源码，然后打包成动态库，这里就不多做说明了。</p>
<p>将动态库 <code>SVProgressHUD</code> 拖入工程中，新建 <code>DynamicWithDynamic</code> 动态库。将上面的 <code>SVProgress.h</code> 和 <code>SVProgress.m</code> 拖入 <code>DynamicWithDynamic</code> 中，设置暴露出 <code>SVProgress.h</code>。</p>
<p>记得注意一定要在 <code>DynamicWithDynamic</code> 中引入 <code>SVProgressHUD</code> ,如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_3.png?raw=true" alt="引入SVProgressHUD"></p>
<p>现在 run 一下，就可以成功生成了。</p>
<p>下面在 <code>FrameworkTest</code> 中测试，使其 embed <code>DynamicWithDynamic</code> 。微调一下 <code>ViewController.m</code> 使其引入目标库，运行。</p>
<p>在运行中出现如下错误：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_4.png?raw=true" alt="错误原因"></p>
<p>这个错误上面也提到过了，是因为必要的动态库没有 embed 进工程中。但是明明已经将 <code>DynamicWithDynamic</code> embed 了啊。好吧，由于 <code>SVProgressHUD</code> 现在是动态库了，还需要将 <code>SVProgressHUD</code> 库 embed 进 <code>FrameworkTest</code> 中。</p>
<p>动态库引入动态库，不会将要引入的动态库打包到自身中，即只是 link 产生关联，而不是 embed 嵌入。 需要在外部使用该动态库时，手动 embed 动态库内要使用的动态库。这样的做法很麻烦，那么有什么意义呢？正如动态库本身的作用，如果工程本身也要用到该 <code>SVProgressHUD</code> 动态库时，那么仅需导入一份，就不会产生重复代码了。</p>
<h4 id="静态库引用静态库"><a href="#静态库引用静态库" class="headerlink" title="静态库引用静态库"></a>静态库引用静态库</h4><p>新建一个 <code>target</code> 命名为 <code>StaticWithStatic</code> ，使用 cocoapods 管理 <code>SVProgressHUD</code> 。基本方法和上面一样，唯一需要改变的地方是 <strong>Mach-O</strong> 需要改为 <strong>Static Library</strong> ，运行。 </p>
<p>然而运行失败，报错如下：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/dynamicstatic_5.png?raw=true" alt="错误原因"></p>
<p>大概意思是在对 <code>ViewController.h</code> 进行链接的时候没有找到 <code>SVProgressHUD.m</code> 。这就很奇怪了，明明已经在 <code>StaticWithStatic</code> 中通过 cocoapods 管理了，怎么会没有 <code>SVProgressHUD.m</code> 呢？我想可能是因为cocoapods只是起到 Link 作用，并没有把第三方库也打进去，那么为什么动态库引入静态库的时候是可行的呢？这就不太清楚了。虽然不知道原因，但是解决方法是有的。需要在工程里，即 <code>FrameworkTest</code> 的 cocoapods 中添加 <code>SVProgressHUD</code>：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">target <span class="string">'DynamicWithStatic'</span> <span class="keyword">do</span></div><div class="line">pod <span class="string">'SVProgressHUD'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target <span class="string">'StaticWithStatic'</span> <span class="keyword">do</span></div><div class="line">pod <span class="string">'SVProgressHUD'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target <span class="string">'FrameworksTest'</span> <span class="keyword">do</span></div><div class="line">    pod <span class="string">'SVProgressHUD'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">target <span class="string">'DynamicWithDynamic'</span> <span class="keyword">do</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>再次 build ，错误消除，可以使用。</p>
<h4 id="静态库引用动态库"><a href="#静态库引用动态库" class="headerlink" title="静态库引用动态库"></a>静态库引用动态库</h4><p>静态库貌似不能引用动态库。如果尝试一下，会发现，即使将动态库 <strong>Link Binary With Libraries</strong> 入静态库，也是找不到 <code>SVProgressHUD.h</code> 头文件的。</p>
<h2 id="一些需要知道的点"><a href="#一些需要知道的点" class="headerlink" title="一些需要知道的点"></a>一些需要知道的点</h2><h3 id="debug与release"><a href="#debug与release" class="headerlink" title="debug与release"></a>debug与release</h3><p>库分为 debug 和 release 两种版本。一般来说, 我们应该发布的是 release 版本。</p>
<ul>
<li><strong>debug</strong> :调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。</li>
<li><strong>release</strong> : 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。</li>
</ul>
<p>debug 与 release 的设置方式如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_1.png?raw=true" alt="debug与release设置"></p>
<p>对于别人给的库，貌似并不能区分是 debug 还是 release 版本的。</p>
<h3 id="多架构编译"><a href="#多架构编译" class="headerlink" title="多架构编译"></a>多架构编译</h3><p>库不仅按 debug 和 release 分类，还会因为运行系统的不同而编译出不同框架的版本。上面的例子都是在真机下的编译，为 arm64 版本，在其他的框架下不能正确运行。</p>
<p>框架分类：</p>
<ul>
<li>模拟器架构: <ul>
<li>i386   : 32位架构  4S ~ 5</li>
<li>x86_64 : 64位架构  5S ~ 现在的机型</li>
</ul>
</li>
<li>真机架构:<ul>
<li>arm7: 在最老的支持iOS7的设备上使用</li>
<li>arm7s: 在iPhone5和5C上使用 </li>
<li>arm64: 运行于iPhone5S的64位 ARM 处理器 上</li>
</ul>
</li>
</ul>
<p>修改框架的方式如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_2.png?raw=true" alt="修改框架设置"></p>
<p>debug 项默认为 YES ，表示仅生成当前选择的框架的库； release 项默认为 NO ，表示生成支持所有模拟器或真机的库。生成的库将会保存在 products 目录下的不同分类目录内：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_3.png?raw=true" alt="库所在目录"></p>
<h3 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h3><p>lipo 是个很有用的命令，主要用来查看库支持的架构以及合并拆分库。</p>
<h4 id="info"><a href="#info" class="headerlink" title="-info"></a>-info</h4><p>查看刚才编译的 Framework 库在 debug 和 release 下支持的框架：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_4.png?raw=true" alt="查看库"><br>可以看到正如上面所说 debug 下不是 fat file ，只支持 arm64 ， release 下是 fat file ， 支持 arm7 和 arm64。</p>
<h4 id="create"><a href="#create" class="headerlink" title="-create"></a>-create</h4><p>上面生成的库，要么是只支持模拟器的，要么是只支持真机的，那么如何才能又能兼顾真机和模拟器呢？ -create 使用方式：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -create 库<span class="number">1</span> 库<span class="number">2</span> -output 新库</div></pre></td></tr></table></figure>
<p>使用结果如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_5.png?raw=true" alt="合并"></p>
<h4 id="thin"><a href="#thin" class="headerlink" title="-thin"></a>-thin</h4><p>如果有一个 fat file 但是你不需要支持那么多框架，也可以通过拆分，为库瘦身， -thin 使用方式：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo 旧库 -thin 需拆分框架 -output 新库</div></pre></td></tr></table></figure>
<p>使用结果如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_6.png?raw=true" alt="拆分"></p>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p>在 framework 中使用 storyboard/xib 创建的页面，可以直接访问 framework 中图片资源。但是 framework 中通过<code>imageNamed：</code>方式加载的照片都会丢失。这是因为 <code>imageNamed:</code>的方法默认是从 <code>mainBundle</code> 中查找资源的，而 framework 中的照片是从 framework 内部加载的，这是的 bundle 并不是 <code>mainBundle</code> ，而是存在于主程序的 docment 文件中的 framework 包，图片加载的路径发生了变化，自然找不到图片资源，所以需要修改加载图片的方法！</p>
<p>一般的方法是创建一个 bundle ：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_7.png?raw=true" alt="创建bundle"></p>
<p>bundle 一般和库命名相同。需要注意的是， bundle 并不会被打包进库中的，而是添加要单独添加到工程中，和 framework 相独立的两部分。向 bundle 中直接添加图片：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_9.png?raw=true" alt="添加图片"></p>
<p>先在主工程的 <strong>Copy Bundle Resources</strong> 中添加 bundle ，如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_point_8.png?raw=true" alt="添加bundle"></p>
<p>现在就可以通过<code>[NSBundle mainBundle]</code>获取图片，一下两种方式皆可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIImage</span> imageNamed:[[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"Frameworks"</span> ofType:<span class="string">@"bundle"</span>] stringByAppendingString:<span class="string">@"/Images/author.png"</span>]]</div><div class="line"></div><div class="line">[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Frameworks.bundle/Images/author.png"</span>]</div></pre></td></tr></table></figure>
<h2 id="cocoapods打包库"><a href="#cocoapods打包库" class="headerlink" title="cocoapods打包库"></a>cocoapods打包库</h2><p>好了，终于到最后一部分了。前面已经介绍了手动创建库的方式，那么如何自动创建一个库？另外一点，前面提到过，在动态库内引入静态库，会和项目本身由 cocoapods 引入的库同名冲突，如何消除这一冲突？以上问题都可以通过 cocoapods 打包库实现</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>只需要输入 pod 的 <code>lib</code> 命令即可完成初始项目的搭建:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib create StaticWithCocoapods</div></pre></td></tr></table></figure>
<p>输出指令后，会提示确认五个问题，按需求回答即可：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_1.png?raw=true" alt="创建库"></p>
<p>稍等片刻，就会自动生成一个工程。</p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>在项目目录下有一个 <code>xxx.podspec</code> 配置文件，需要进行修改，摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line">  s.name             = &apos;StaticWithCocoapods&apos;</div><div class="line">  s.version          = &apos;0.1.0&apos;</div><div class="line">  s.summary          = &apos;A short description of StaticWithCocoapods.&apos;</div><div class="line"></div><div class="line"># This description is used to generate tags and improve search results.</div><div class="line">#   * Think: What does it do? Why did you write it? What is the focus?</div><div class="line">#   * Try to keep it short, snappy and to the point.</div><div class="line">#   * Write the description between the DESC delimiters below.</div><div class="line">#   * Finally, don&apos;t worry about the indent, CocoaPods strips it!</div><div class="line"></div><div class="line">  s.description      = &lt;&lt;-DESC</div><div class="line">TODO: Add long description of the pod here.</div><div class="line">                       DESC</div><div class="line"></div><div class="line">  s.homepage         = &apos;https://github.com/zhang759740844&apos;</div><div class="line">  s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;</div><div class="line">  s.author           = &#123; &apos;Zachary&apos; =&gt; &apos;759740844@qq.com&apos; &#125;</div><div class="line">  s.source           = &#123; :git =&gt; &apos;/Users/zachary/Desktop/StaticWithCocoapods&apos;, :tag =&gt; s.version.to_s &#125;</div><div class="line"></div><div class="line">  s.ios.deployment_target = &apos;8.0&apos;</div><div class="line"></div><div class="line">  s.source_files = &apos;StaticWithCocoapods/Classes/**/*&apos;</div><div class="line">  </div><div class="line">  s.resource_bundles = &#123;</div><div class="line">    &apos;StaticWithCocoapods&apos; =&gt; [&apos;StaticWithCocoapods/Assets/*.png&apos;]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;StaticWithCocoapods/Classes/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;</div><div class="line">  s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">  s.denpendency &apos;SVProgressHUD&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li>s.version 表示的是当前类库的版本号</li>
<li>s.source 表示当前类库源</li>
<li>s.sources_files 表示类库的源文件存放目录</li>
<li>s.resource_bundles 表示资源文件存放目录</li>
<li>s.frameworks 表示类库依赖的framework</li>
<li>s.dependency 表示依赖的第三方类库</li>
</ul>
<p>其中要说明的是： </p>
<ol>
<li>source 可以填写远端 git 仓库，也可以是像我写的那样的本地 git 仓库。</li>
<li>依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成 .a 或 .framework 时才能让其他项目正常使用。</li>
<li>source_file 路径中出现的通配符 <code>*</code> 表示匹配任意字符， <code>**</code> 表示匹配所有当前文件夹和子文件夹。</li>
<li>source_bundles 中花括号内的 <code>&#39;StaticWithCocoapods&#39;</code> 就表示一个 <code>StaticWithCocoapods</code> bundle。</li>
</ol>
<h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><p>向 <strong>sources_files</strong> 和 <strong>public_header_files</strong> 以及 <strong>resource_bundle</strong> 中添加图片和类文件。在 demo 的文件夹下执行 <code>pod install</code>。现在打开 demo 工程，可以看到创建的 <code>StaticWithCocoapods</code> 库的文件结构如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_2.png?raw=true" alt="文件结构"></p>
<p>到这里一切正常，也可以使用 <code>SVProgressHUD</code> ，但是当我想用 <code>[UIImage imageNamed:[[[NSBundle mainBundle] pathForResource:@&quot;StaticWithCocoapods&quot; ofType:@&quot;bundle&quot;] stringByAppendingString:@&quot;/author.png&quot;]]</code> 加载图片资源文件时，一直返回 <code>nil</code> 。</p>
<p>好吧。虽然网上cocoapods打包教程不少，但是真正试过添加图片的人应该不多，最后在 Stackoverflow 的一个评论里总算找到了解决方法<a href="http://stackoverflow.com/questions/25402782/cocoapodsresource-bundle-not-accessbile" target="_blank" rel="external">[Cocoapods]:Resource Bundle not accessbile</a></p>
<p>原先 demo 中 profile 的内容如下：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">use_frameworks!</div><div class="line"></div><div class="line">target <span class="string">'StaticWithCocoapods_Example'</span> <span class="keyword">do</span></div><div class="line">  pod <span class="string">'StaticW'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../'</span></div><div class="line"></div><div class="line">  target <span class="string">'StaticWithCocoapods_Tests'</span> <span class="keyword">do</span></div><div class="line">    inherit! <span class="symbol">:search_paths</span></div><div class="line"></div><div class="line">    pod <span class="string">'FBSnapshotTestCase'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>现在要删除 <code>use_frameworks!</code> 以及其相关内容，变成这样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target <span class="string">'StaticWithCocoapods_Example'</span> <span class="keyword">do</span></div><div class="line">  pod <span class="string">'StaticWithCocoapods'</span>, <span class="symbol">:path</span> =&gt; ‘../‘</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>再次尝试加载图片，可以得到正确结果. ^_^</p>
<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><ol>
<li>使用 sourcetree 添加本地仓库</li>
<li>提交上面的所有改动</li>
<li>为改动添加 tag 为 <code>0.1.0</code></li>
</ol>
<p>设置好后如图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_3.png?raw=true" alt="提交代码"></p>
<p>这里要注意，tag 一定要打上，版本控制的时候就是以 tag 来辨别的。</p>
<h3 id="验证类库"><a href="#验证类库" class="headerlink" title="验证类库"></a>验证类库</h3><p>开发完成静态类库之后，需要运行pod lib lint验证一下类库是否符合pod的要求。添加 <code>--allow-warnings</code> 忽略警告：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_4.png?raw=true" alt="验证类库"></p>
<h3 id="打包库"><a href="#打包库" class="headerlink" title="打包库"></a>打包库</h3><p>打包库需要一个 cocoapods 的插件 <strong>cocoapods-packager</strong>来完成类库的打包。</p>
<p>在终端执行以下命令，安装插件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods-packager</div></pre></td></tr></table></figure>
<p>在目标文件夹内执行以下命令，完成打包：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod package StaticWithCocoapods.podspec --force</div></pre></td></tr></table></figure>
<p>打包成 <code>.framework</code> ，也可以用 <code>--library</code> 打包成 <code>.a</code> 。不过 cocoapods 之前有过打包成 <code>.a</code> 但是没有暴露出头文件的bug，懒得试有没有修复了，所以还是都打成 <code>.framework</code> 吧。</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/framework_cocoapods_5.png?raw=true" alt="打包过程"></p>
<p>现在在目标文件夹下就会多出一个 <code>StaticWithCocoapods-0.2.0</code> 目录，里面是打包好的 framework 。</p>
<p>至于如何将打包好的库添加到 cocoapods 的官方库内，这个就没有研究了，因为，在很长的一段时间内我都不会用到。有兴趣的可以看看 cocoapods 的官方文档，自行研究下。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://foggry.com/blog/2014/06/12/wwdc2014zhi-iosshi-yong-dong-tai-ku/" target="_blank" rel="external">WWDC2014之iOS使用动态库</a><br><a href="http://blog.csdn.net/lijuan3203/article/details/52105911" target="_blank" rel="external">手把手教你使用CocoaPods打包静态库</a><br><a href="http://www.jianshu.com/p/8f5b9855efb8" target="_blank" rel="external">iOS 静态库开发</a><br><a href="http://www.cnblogs.com/brycezhang/p/4117180.html" target="_blank" rel="external">使用CocoaPods开发并打包静态库</a><br><a href="http://www.cocoachina.com/ios/20150228/11206.html" target="_blank" rel="external">使用Cocoapods创建私有podspec</a><br><a href="https://my.oschina.net/kaqijiang/blog/649632" target="_blank" rel="external">iOS静态库 【.a 和framework】【超详细】</a><br><a href="http://www.samirchen.com/create-a-framework/" target="_blank" rel="external">创建一个 iOS Framework 项目</a><br><a href="http://blog.csdn.net/u013604612/article/details/43197465" target="_blank" rel="external">iOS开发——创建你自己的Framework</a><br><a href="http://chenhuaizhe.com/jekyll/update/2015/12/13/iOS中的workspace与静态库.html" target="_blank" rel="external">iOS中workspace与静态库</a><br><a href="http://www.cocoachina.com/ios/20150906/13323.html" target="_blank" rel="external">Cocoapods 应用第一部分 - Xcode 创建 .framework 相关</a><br><a href="http://www.lhjzzu.com/2016/05/06/static-lib/" target="_blank" rel="external">ios打包–打包静态库(五)</a></p>
<p>呼~总算把库的相关知识看完了，写成这第二篇。花了半个月才总结完。期间各种问题，各种错误不知道怎么解决，真的累。以后还是研究些经常能用得到的东西吧。自己基本不需要打包库<del>~</del></p>
<p><a href="https://github.com/zhang759740844/MyOCDemo/tree/develop/Framework" target="_blank" rel="external">我的demo地址，欢迎参考</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Storyboard 使用方法]]></title>
      <url>http://zhang759740844.github.io/2016/10/13/storyboard%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>Storyboard是苹果官方主推的一个代替xib的策略。有必要详细学习下它的使用方法。</p>
<a id="more"></a>
<p>先来看一下思维导图<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_28.png?raw=true" alt="storyboard_28"></p>
<h2 id="storyboard基础"><a href="#storyboard基础" class="headerlink" title="storyboard基础"></a>storyboard基础</h2><h3 id="storyboard优势"><a href="#storyboard优势" class="headerlink" title="storyboard优势"></a>storyboard优势</h3><p>storyboard能代替nib自然有其优势，一般来说storyboard具有以下几种优点：</p>
<ul>
<li>storyboard能将nib汇总统一管理</li>
<li>storyboard可以描述各种场景之间的过渡，这种过渡被称作<code>segue</code>，storyboard 把 view controller叫做：<code>scene</code>，可以通过拖拽实现过度，减少代码</li>
<li>支持tableview的prototype cell，可以在storyboard中编辑cell，减少代码量</li>
</ul>
<h3 id="storyboard的基本使用"><a href="#storyboard的基本使用" class="headerlink" title="storyboard的基本使用"></a>storyboard的基本使用</h3><h4 id="启动storyboard"><a href="#启动storyboard" class="headerlink" title="启动storyboard"></a>启动storyboard</h4><p>加载storyboard肯定是需要一个主入口的，这个主入口在<code>info.plist</code>中：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_1.png?raw=true" alt="storyboard_1"></p>
<h4 id="初始化ViewController"><a href="#初始化ViewController" class="headerlink" title="初始化ViewController"></a>初始化ViewController</h4><p>确定了哪个storyboard是主入口，那显然也要确定哪个ViewController是storyboard的主入口。需要选中相应ViewController，勾选<code>Is Initial View Controller</code><br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_2.png?raw=true" alt="storyboard_2"><br>此时，对应ViewController前出现一个箭头<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_3.png?raw=true" alt="storyboard_3"></p>
<h4 id="创建relationship-segue"><a href="#创建relationship-segue" class="headerlink" title="创建relationship segue"></a>创建relationship segue</h4><p>对于三大container view controller，即Tab Bar Controller，Navigation Controller，Split View Controller ，可以通过拖拽创建设置relationship segue。</p>
<p>如下图的 popup menu 是从tab bar controller 连到navigation controller,松手后的弹出：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_4.png?raw=true" alt="storyboard_4"><br>连接后的图标如下图，表示relationship segue<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_5.png?raw=true" alt="storyboard_5"></p>
<h4 id="命名tabbar-controller的tabbar"><a href="#命名tabbar-controller的tabbar" class="headerlink" title="命名tabbar controller的tabbar"></a>命名tabbar controller的tabbar</h4><p>并非在tabbar controller里，而是在与其相连、对应的controller里改动，如图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_6.png?raw=true" alt="storyboard_6"><br>navigation bar 的 title 也是同理。但是，强烈不建议在storyboard里设置navigationbar，因为storyboard是为了简化操作的，但是设置navigationbar太麻烦了，还不如代码方便实用。</p>
<h4 id="设置ViewController对应的类"><a href="#设置ViewController对应的类" class="headerlink" title="设置ViewController对应的类"></a>设置ViewController对应的类</h4><p>选中相应ViewController，然后在 Custom Class 内写上相应类名即可。注意，要选中 ViewController 而不是其中的 View，要点击图中的黄色圆形按钮。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_7.png?raw=true" alt="storyboard_7"></p>
<h4 id="获取视图控制器"><a href="#获取视图控制器" class="headerlink" title="获取视图控制器"></a>获取视图控制器</h4><p>就是通过<code>UITableViewController</code>和<code>UINavigationController</code>中的<code>viewControllers</code>获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITabBarController</span> *tabBarController = (<span class="built_in">UITabBarController</span> *)<span class="keyword">self</span>.window.rootViewController;</div><div class="line"><span class="built_in">UINavigationController</span> *navigationController = [tabBarController viewControllers][<span class="number">0</span>];</div><div class="line">PlayersViewController *playersViewController = [navigationController viewControllers][<span class="number">0</span>];</div></pre></td></tr></table></figure>
<h4 id="Prototype-cells"><a href="#Prototype-cells" class="headerlink" title="Prototype cells"></a>Prototype cells</h4><p>选中tableview，设置tableview的 cotent 为 Dynamic Propotype<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_8.png?raw=true" alt="storyboard_8"><br>一般在<code>tableView: cellForRowAtIndexPath:</code>方法中都像下面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"Cell"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</div><div class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</div><div class="line">        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></div><div class="line">                                      reuseIdentifier:CellIdentifier];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Configure the cell...</span></div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，由于在storyboard中已经创建了cell，那么就可以直接使用了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"PlayerCell"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// Configure the cell...</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，一个tableview里肯定不应该只有一个，可以把上面的 Content 下面的 Prototype Cells 增加cell，然后选择任意cell，如图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_9.png?raw=true" alt="storyboard_9"><br>设置不同的 identifier 来标识不同的cell。</p>
<p>除了在viewcontroller里直接创建cell，不需要另一个cell的xib的区别外，其他方面和xib无异。也可以选中cell，在右边栏指定对应的Controller的custom class用来控制cell。同样的，也不能直接把cell中的view连线到cell所属的viewController中。</p>
<h4 id="Static-cells"><a href="#Static-cells" class="headerlink" title="Static cells"></a>Static cells</h4><p>使用静态的cell，适用在仅有几个确定cell的tableview中，不能重用，设置了几个cell，就显示几个cell。static cells的设置如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_10.png?raw=true" alt="storyboard_10"><br>因为prototype cells究竟怎么显示可以在代码中设置，所以只需要设置有几个可重用的cell就行了，而static cells因为不可重用，那么这里的设置选项就变成了 Sections 设置多少段。</p>
<p>那么怎么设置每个section有多少个cell呢？选中如下图所示的只有static cells才有的蓝色立方体：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_11.png?raw=true" alt="storyboard_11"><br>此时右边栏出现如图所示 Table View Section<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_12.png?raw=true" alt="storyboard_12"><br>可以设置数量，表头表尾的title</p>
<p>和 prototype cell 一样，static cell可以指定一个专门的Controller。但是不同的是，static cell 的cell以及cell中的控件都相当于确定的view，因此，static cell可以把cell以及cell中的控件连线到cell所属的viewController中。<br>也就是说，如果在cell的Controller中设置了一个button的点击事件，然后又在cell所属viewController中又设置了一次该button的点击事件，不会报错，两个点击事件都会触发。</p>
<p>所以，方便起见，static cell 直接在viewController中连线设置就可以了。</p>
<h2 id="使用segue"><a href="#使用segue" class="headerlink" title="使用segue"></a>使用segue</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="什么是Segue"><a href="#什么是Segue" class="headerlink" title="什么是Segue"></a>什么是Segue</h4><p>Storyboard上每一根用来界面跳转的线，都是一个UIStoryboardSegue对象（简称Segue）</p>
<h4 id="Segue的属性"><a href="#Segue的属性" class="headerlink" title="Segue的属性"></a>Segue的属性</h4><p>每一个Segue对象，都有3个属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一标识</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *identifier;</div><div class="line"><span class="comment">// 来源控制器</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> sourceViewController;</div><div class="line"><span class="comment">// 目标控制器</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> destinationViewController;</div></pre></td></tr></table></figure>
<h4 id="Segue的类型"><a href="#Segue的类型" class="headerlink" title="Segue的类型"></a>Segue的类型</h4><p>根据Segue的执行（跳转）时刻，Segue可以分为2大类型:</p>
<ul>
<li>自动型(Action segue)：点击某个控件后（比如按钮），自动执行Segue，自动完成界面跳转。</li>
<li>手动型(Manual segue)：需要通过写代码手动执行Segue，才能完成界面跳转。</li>
</ul>
<h4 id="segue执行过程"><a href="#segue执行过程" class="headerlink" title="segue执行过程"></a>segue执行过程</h4><p>手动调用<code>performSegueWithIdentifier:sender:</code>方法实现跳转。那么这期间发生了什么呢？大致分为三个部分。</p>
<ol>
<li>根据<code>identifier</code>去storyboard中找到对应的线，新建UIStoryboardSegue对象</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithIdentifier:(<span class="built_in">NSString</span> *)identifier source:(<span class="built_in">UIViewController</span> *)source destination:(<span class="built_in">UIViewController</span> *)destination; <span class="comment">// Designated initializer</span></div></pre></td></tr></table></figure>
<p>其实就是执行了UIStoryboardSegue中<code>initWithIdentifier:source:destination:</code>方法,并且<code>identifier</code>就是在Storyboard中Segue属性设置的标识. 来源就是连线的头部. 目标就是连线尾</p>
<ol>
<li>调用sourceViewController的下面方法，做一些跳转前的准备工作并且传入创建好的Segue对象</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender;</div></pre></td></tr></table></figure>
<p>所谓跳转前的准备，因为可以拿到Segue(来源控制器,目标控制器)，所以就可以在这里给下一个控制器传递数据。这个方法是系统默认调用，所以只需要实现即可。另外，只能由来源控制器调用,来拿到目标控制器。</p>
<ol>
<li>调用Segue对象的<code>perform</code>方法开始执行界面跳转操作。</li>
</ol>
<h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>segue可以实现页面间跳转，除了上面的 relationship segue 还有 Action segue 和 Manual segue，分别对应button跳转和viewController跳转。</p>
<h4 id="跳进"><a href="#跳进" class="headerlink" title="跳进"></a>跳进</h4><h5 id="使用storyboard"><a href="#使用storyboard" class="headerlink" title="使用storyboard"></a>使用storyboard</h5><p>Action segue 比较简单，就是将button连到要展示的viewController上，当点击时，就会触发。<br>Manual segue 相对比较麻烦，但是比较灵活。它设置了两个viewController的跳转关系，在你需要的时候出发跳转。</p>
<p>首先，先对两个viewController进行连线：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_14.png?raw=true" alt="storyboard_14"><br>之后点击连线后两个viewController之间产生的箭头，在右边栏可以看到如下：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_15.png?raw=true" alt="storyboard_15"><br>其中参数 <code>identifier</code> 就是跳转的标识符，根据这个标识符来确定跳转到是那个页面。下面几个参数，下面再说。</p>
<p>接下来就可以调用方法，在合适的时机加载了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据 segue Identifier跳转界面</span></div><div class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"GotoTwo"</span> sender:<span class="keyword">self</span>];</div></pre></td></tr></table></figure>
<p>其中的<code>identifer</code>自然不用多说，那么<code>sender</code>是什么呢？<code>sender</code>是参数名称，理论上可以指代任何对象，用来区分是哪个控件触发了segue。比如有两个button都跳转到一个页面，那么这时就可以设置<code>sender</code>区分了。引申开来，在设置button点击事件时的<code>-(IBAction)click:(id)sender;</code>方法中的<code>sender</code>和这里的<code>sender</code>是一个作用。</p>
<h5 id="使用纯代码"><a href="#使用纯代码" class="headerlink" title="使用纯代码"></a>使用纯代码</h5><p>上面的方法实现效果和平时用的下面两个方法相同：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以modal 方式跳转</span></div><div class="line">[<span class="keyword">self</span> presentViewController:ViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line"><span class="comment">//压进一个viewcontroller</span></div><div class="line">[<span class="keyword">self</span>.navigationController pushViewController:ViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>不过，既然用了storyboard了，那么实例化viewController时就不能用<code>initWithNibName</code>了。在storyboard中，要通过storyboard找到viewController的布局。首先要设置viewcontroller的 storyboardID：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_19.png?raw=true" alt="storyboard_19"><br>那个<code>use storyboardId</code>的勾不打也行，不知道干什么用的，</p>
<p>现在就可以在代码中找到特定storyboard的viewcontroller了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)tapButton:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="comment">//获取storyboard: 通过bundle根据storyboard的名字来获取我们的storyboard,</span></div><div class="line">    <span class="built_in">UIStoryboard</span> *story = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">//由storyboard根据myView的storyBoardID来获取我们要切换的视图</span></div><div class="line">    <span class="built_in">UIViewController</span> *myView = [story instantiateViewControllerWithIdentifier:<span class="string">@"myView"</span>];</div><div class="line">    <span class="comment">//显示ViewController</span></div><div class="line">    [<span class="keyword">self</span> presentViewController:myView animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="跳出"><a href="#跳出" class="headerlink" title="跳出"></a>跳出</h4><p>能跳进当然也要能跳出，可以使用 exit segue 跳转至任意连线的位置，也可以使用代码跳转。</p>
<h5 id="exit-segue"><a href="#exit-segue" class="headerlink" title="exit segue"></a>exit segue</h5><p>跳出和跳进的方法类似，略有区别，比如要从界面2跳转回界面1：</p>
<p>先打开需要返回到的界面ViewController1.m,加上下面方法，返回类型一定是<code>IBAction</code>，参数类型<strong>一定</strong>是<code>UIStoryboardSegue</code>，名称随便（这个方法一定要加，返回时调用的）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//其他界面返回到此界面调用的方法</span></div><div class="line">- (<span class="keyword">IBAction</span>)ViewController1UnwindSegue:(<span class="built_in">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>右键2界面上方的Exit（下图中画绿圈的）弹出菜单中可以看到刚才在1界面中加的那个方法的名称（下图中红色圈里），然后如下图一样连线，弹出菜单选择<code>manual</code>，这里连接自己表示要在当前viewcontroller中用代码的方式回退。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_17.png?raw=true" alt="storyboard_17"></p>
<p>给2视图的unwind segue取一个名字叫<code>from2to1</code>的identifier如下图:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_18.png?raw=true" alt="storyboard_18"></p>
<p>现在就可以在界面2中的任意时候调用方法回退了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)back:(<span class="keyword">id</span>)sender &#123;</div><div class="line">　　<span class="comment">//执行segue跳页的方法</span></div><div class="line">    [<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"from2to1"</span> sender:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的仍是跳进时用的方法，不过第一步的操作已经告诉xcode这是一个回退操作了。可以从上图看到，这个 Unwind Segue 绑定了回退到的界面的一个方法，因此，执行跳转后会执行绑定的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//其他界面返回到此界面调用的方法</span></div><div class="line">- (<span class="keyword">IBAction</span>)ViewController1UnwindSegue:(<span class="built_in">UIStoryboardSegue</span> *)unwindSegue &#123;</div><div class="line">    <span class="keyword">if</span> ([unwindSegue.identifier isEqualToString:<span class="string">@"from2to1"</span>]) &#123;</div><div class="line">        _lbShowMessage.text = <span class="string">@"从2退到1"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([unwindSegue.identifier isEqualToString:<span class="string">@"from3to1"</span>]) &#123;</div><div class="line">        _lbShowMessage.text = <span class="string">@"从3退到1"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就看出上面为什么说类型一定是<code>UIStoryboardSegue</code>了，因为可以接收一个该类型的对象，以此判断是从哪个页面的回退。</p>
<p>使用 exit segue 的<strong>好处</strong>是可以跳转到任意打开过的界面比如从3-&gt;1，而不是只能返回上级界面从2-&gt;1。</p>
<h5 id="一般跳出方法"><a href="#一般跳出方法" class="headerlink" title="一般跳出方法"></a>一般跳出方法</h5><p>也可以使用代码根据是model类型还是push类型选择：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//弹出一个viewcontroller  相当与返回上一个界面</span></div><div class="line">[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];   </div><div class="line"><span class="comment">// 以 modal跳转的返回方法</span></div><div class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
<h3 id="跳转的方式"><a href="#跳转的方式" class="headerlink" title="跳转的方式"></a>跳转的方式</h3><p>在进行跳转连线后会出现如下窗口：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_13.png?raw=true" alt="storyboard_13"><br>共有三种跳转方式，也就是上面右边栏的<code>Kind</code>属性</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>Push类型必须用在NavigationController中，否则报错。是在navigation View Controller中下一级时使用的那种从右侧划入的方式。</p>
<h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><p>最常用的场景，新的场景完全盖住了旧的那个。用户无法再与上一个场景交互，除非他们先关闭这个场景。可以在右边栏的<code>Presentation</code>选择需要展示的动画效果。</p>
<h4 id="custom"><a href="#custom" class="headerlink" title="custom"></a>custom</h4><p>自定义类型，需要继承UIStoryboardSegue类，然后重写Perform方法,然后在Storyboard上将类设置为自定义的类。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_16.png?raw=true" alt="storyboard_16"><br>这段代码的作用是创建从中心渐变充满屏幕的动画:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)perform&#123;</div><div class="line">    <span class="built_in">UIViewController</span> * svc = <span class="keyword">self</span>.sourceViewController;</div><div class="line">    <span class="built_in">UIViewController</span> * dvc = <span class="keyword">self</span>.destinationViewController;</div><div class="line">    [svc.view addSubview:dvc.view];</div><div class="line">    [dvc.view setFrame:svc.view.frame];</div><div class="line">    [dvc.view setTransform:<span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>)];</div><div class="line">    [dvc.view setAlpha:<span class="number">0.0</span>];</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></div><div class="line">                     animations:^&#123;</div><div class="line">                         [dvc.view setTransform:<span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">1.0</span>)];</div><div class="line">                         [dvc.view setAlpha:<span class="number">1.0</span>];</div><div class="line">                     &#125;</div><div class="line">                     completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                         [svc presentViewController:dvc animated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</div><div class="line">                     &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实实质还是<code>presentViewController</code>，但是不用系统带的<code>animation</code>，而是先将<code>destinationViewController</code>的页面用动画加载后，直接<code>present</code>。</p>
<h3 id="跳转传值"><a href="#跳转传值" class="headerlink" title="跳转传值"></a>跳转传值</h3><p>前面说到，<code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</code>方法会在跳转时自动触发。跳转传值就在这个方法内完成。</p>
<p>我们可以对Segue的标识进行判断，一般有以下两种方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([segue.identifier  isEqual: <span class="string">@"login2index"</span>]) &#123;</div><div class="line">        <span class="comment">// 需要执行的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([segue.destinationViewController isKindOfClass:[IndexTableViewController <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="comment">//  执行代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一种需要在设置标识的值,并且匹配。第二种却是通过目标控制器判断。个人感觉还是第一种靠谱一些。</p>
<p>接下来就可以对<code>destination</code>进行赋值了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"触发该场景切换的sender对象的类型是:%@"</span>,[sender <span class="keyword">class</span>]);</div><div class="line">    </div><div class="line">    <span class="comment">//方法一,使用KVC给B 也就是目标场景传值</span></div><div class="line">    <span class="built_in">UIViewController</span> *destinationController=[segue destinationViewController];</div><div class="line">    [destinationController setValue:<span class="string">@"119"</span> forKey:<span class="string">@"number"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//方法2,使用属性传值,需导入相关的类.h</span></div><div class="line">    <span class="comment">//BViewController *bController=[segue destinationViewController];</span></div><div class="line">    <span class="comment">//bController.number=@188;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跳转传值不仅可以用<code>prepareForSegue:sender:</code>实现，也可以通过代理、通知的方式，不过这样挺麻烦的，不推荐。具体参见<a href="http://blog.csdn.net/mad1989/article/details/7919504#comments" target="_blank" rel="external">使用storyboard实现页面跳转，简单的数据传递</a></p>
<h3 id="多分支NavigationController"><a href="#多分支NavigationController" class="headerlink" title="多分支NavigationController"></a>多分支NavigationController</h3><p>主要应用在下面这种情况：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_20.png?raw=true" alt="storyboard_20"><br>navigationController要分情况跳转到界面A或者界面B，但是navigationController只能有一个<code>rootViewController</code>啊。所以，通过一个空的<code>ParentViewController</code>在<code>viewWillAppear:</code>方法中加载任意一个<code>ChildViewController</code>。如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_22.png?raw=true" alt="storyboard_22"></p>
<p>注意，上图红框中的分支，其实<strong>表现的只是一个页面的两种形态</strong>，本质上还是一个页面。所以加载<code>childViewController</code>的segue都要用不带任何动画的<code>custome</code>类型。因为如果<code>ChildViewController</code>有动画，那么就会暴露出<code>ParentViewController</code>中的空白部分，就表现为两个页面了。</p>
<p>可以看出，这个方法的优点是可以通过<code>parent</code>，从<code>C1</code>直接跳到<code>C2</code>，如果不用这种父子ViewController的方式，那么不可避免的就得先从<code>C1</code>跳回前一级页面，然后再从前一级页面跳到<code>C2</code>。不过缺点就是<code>C1</code>到<code>C2</code>的跳转没有任何跳转动画。</p>
<p>不过，思考了一段时间后，觉得多分支NavigationController本身并不是一个问题，用父子ViewController的方式虽然能解决，但是把问题复杂化了。比如应用在登录跳转上，我完全可以不用在加载NavigationController后再判断是否要登录，而是把这一过程放到加载NavigationController之前。至于可以直接跳转的这一好处，一般情况下，产品也不会这么设计，而且它的弊端也是很明显的。</p>
<p>具体实现的过程参见<a href="http://www.cnblogs.com/shanpow/p/4149462.html" target="_blank" rel="external">基于Storyboard的创建多分支NavigationController的方法</a>。记得如果使用这种方法的话，一定要清除<code>Parent</code>中上次显示的<code>ChildViewController</code>，文中在<code>prepareForSegue:sender:</code>方法中清除，是个很好的时机。 </p>
<h2 id="storyboard-reference"><a href="#storyboard-reference" class="headerlink" title="storyboard reference"></a>storyboard reference</h2><p>iOS9中，苹果引入了 storyboard reference 用以减小storyboard的体积，方便管理（并不知道iOS9之前怎么用多个storyboard）。</p>
<h3 id="简化现有storyboard"><a href="#简化现有storyboard" class="headerlink" title="简化现有storyboard"></a>简化现有storyboard</h3><p>如下图，是做上面练习时创建的一个storyboard，界面已经有点多了。可以使用storyboard reference简化，将一部分viewcontroller拆分到其他storyboard里。</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_23.png?raw=true" alt="storyboard_23"></p>
<p>做法其实很简单，选中想要拆分的viewcontroller，然后在菜单栏干中“Editor-&gt;Refactor to Storyboard”，如下图所示。然后命名新的storyboard即可。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_24.png?raw=true" alt="storyboard_24"></p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_25.png?raw=true" alt="storyboard_25"></p>
<h3 id="加载storyboard中一个特定viewController"><a href="#加载storyboard中一个特定viewController" class="headerlink" title="加载storyboard中一个特定viewController"></a>加载storyboard中一个特定viewController</h3><p>和拖拽其他控件一样，找到storyboard控件，拖拽到storyboard上：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_26.png?raw=true" alt="storyboard_26"></p>
<p>然后设置storyboard：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/storyboard_27.png?raw=true" alt="storyboard_27"><br>这里面<code>storyboard</code>填的是目标storboard的文件名；<code>Reference ID</code>是啥？从它的提示也就才出来了，用来确定联结的是那个viewController，填的是目标storyboard中目标viewController的<code>Storyboard ID</code>，具体在哪设，上面也说过。</p>
<p>这样，一个简洁的storyboard就能创建出来了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.jianshu.com/p/2ec2c19f183e" target="_blank" rel="external">【Storyboard】Storyboard介绍及使用</a></p>
<p><a href="http://birdmichael.com/?p=180" target="_blank" rel="external">UIStoryboardSegue讲解</a>;</p>
<p><a href="http://blog.csdn.net/yangbingbinga/article/details/43704269" target="_blank" rel="external">iOS-prepareForSegue场景切换,KVC传值</a>;</p>
<p><a href="http://blog.csdn.net/mad1989/article/details/7919504#comments" target="_blank" rel="external">(4.4.1)使用storyboard实现页面跳转，简单的数据传递</a>;</p>
<p><a href="http://blog.csdn.net/xuqiang918/article/details/17023737" target="_blank" rel="external">【iOS界面处理】使用storyboard实现页面跳转，简单的数据传递</a></p>
<p><a href="https://www.shinobicontrols.com/blog/ios9-day-by-day-day3-storyboard-references" target="_blank" rel="external">iOS9 Day-by-Day :: Day 3 :: Storyboard References</a>;</p>
<p><a href="http://www.cnblogs.com/shanpow/p/4149462.html" target="_blank" rel="external">基于Storyboard的创建多分支NavigationController的方法</a>;</p>
<p><a href="http://blog.csdn.net/yangmeng13930719363/article/details/49886901" target="_blank" rel="external">iOS 9 Storyboard 教程(一下)</a>;</p>
<p><a href="http://www.xmcgraw.com/10-practical-tips-for-ios-developers-using-storyboards/" target="_blank" rel="external">10 Practical Tips for iOS Developers Using Storyboards</a>;</p>
<p>还有一些看完随手就关了，没有记录。</p>
<p>水平有限，如有错误，多多指正~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[oc 中的泛型与nullability]]></title>
      <url>http://zhang759740844.github.io/2016/09/28/oc%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>oc中添加了一些关键字，主要作用于编译期，对程序没有任何影响，相当于是一个提示。下面将结合<a href="https://my.oschina.net/u/2340880/blog/514804" target="_blank" rel="external">Objective—C语言的新魅力——Nullability、泛型集合与类型延拓</a>对oc的这些新特性进行研究。</p>
<a id="more"></a>
<h2 id="Nullability检测的支持"><a href="#Nullability检测的支持" class="headerlink" title="Nullability检测的支持"></a>Nullability检测的支持</h2><p>可以使用<code>nullable</code>关键字，表明该对象可以是空值;使用<code>nonnull</code>关键字表明不可以是空对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ObjectType firstObject;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ObjectType lastObject;</div></pre></td></tr></table></figure>
<p>这是NSArray中的两个属性，其中<code>nullable</code>关键字说明了这里可能返回空的值。</p>
<p>如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的,例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setValue:(<span class="built_in">NSNumber</span> * _Nonnull )number&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果传入了空值，编译器会警告：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_1.png?raw=true" alt="oc_new_1"></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。</p>
<h3 id="有类型约定的集合"><a href="#有类型约定的集合" class="headerlink" title="有类型约定的集合"></a>有类型约定的集合</h3><p>在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *array = [[<span class="built_in">NSMutableArray</span> alloc]init];</div></pre></td></tr></table></figure>
<p>声明了这样一个数组后，就告诉了编译器，这个数组中的数据类型都是NSString*类型的，可以使用该类型的方法，如：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_2.png?raw=true" alt="oc_new_2"></p>
<p>在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来:</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_3.png?raw=true" alt="oc_new_3"></p>
<p>如果我们向这个数组中追加类型不匹配的元素,编译器会给我们一个这样的警告：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/oc_new_4.png?raw=true" alt="oc_new_4"></p>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>iOS的系统类中，大量使用了<code>ObjectType</code>关键字，如下是系统的<code>NSMutableArray</code>的头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableArray</span>&lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSArray</span>&lt;<span class="title">ObjectType</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)addObject:(ObjectType)anObject;</div><div class="line">- (<span class="keyword">void</span>)insertObject:(ObjectType)anObject atIndex:(<span class="built_in">NSUInteger</span>)index;</div><div class="line">- (<span class="keyword">void</span>)removeLastObject;</div><div class="line">- (<span class="keyword">void</span>)removeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index;</div><div class="line">- (<span class="keyword">void</span>)replaceObjectAtIndex:(<span class="built_in">NSUInteger</span>)index withObject:(ObjectType)anObject;</div><div class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)numItems <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这个<code>ObjectType</code>就是泛型的类型标识符,我们可以用它自己定义一个集合类，如包装一个NSSarray：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyArray</span>&lt;<span class="title">Type</span>&gt; : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">nonnull</span>)<span class="built_in">NSMutableArray</span>&lt;Type&gt; *array;</div><div class="line">-(<span class="keyword">void</span>)addObject:(<span class="keyword">nonnull</span> Type)obj;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _array = [[<span class="built_in">NSMutableArray</span> alloc]init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)obj&#123;</div><div class="line">    [_array addObject:obj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>这个类型通配符只能在interfave里使用，作用域为@interface到@end之间。</li>
<li>实现时，对于定义的<code>Type</code>类型的参数，使用<code>id</code>代替。</li>
<li>泛型<code>Type</code>不用写成<code>Type *</code>。</li>
<li>对于多参的集合，将参数类型用“,”隔开即可，如<code>NSMultableDictionary&lt;NSString * ,NSString *&gt; *dic = [[NSMultableDictionary alloc] init];</code></li>
</ul>
<h3 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h3><p>在小类向大类赋值时，往往没有任何问题。但是大类向小类赋值时，就会产生警告。譬如<code>UIView</code>的实例<code>view</code>和<code>UIButton</code>的实例<code>button</code>,可以<code>view = button</code>，但是最好不要<code>button = view</code>。如果想要使用，又不希望产生警告怎么办？使用<code>__kindof</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *b = [[<span class="built_in">UIButton</span> alloc] init];</div><div class="line">__kindof <span class="built_in">UIView</span> *view = [[<span class="built_in">UIButton</span> alloc]init];</div><div class="line">b = view;</div></pre></td></tr></table></figure></p>
<p>这里，由于<code>view</code>使用<code>__kindof</code>表示<code>UIView</code>的子类，不会产生警告。否则要进行强转<code>b = (UIButton *)view;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode插件XVim安装与使用]]></title>
      <url>http://zhang759740844.github.io/2016/09/23/XVim%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>XVim是Xcode中支持Vim的插件，尝试安装和使用</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>慕名下载了<a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">Xcode</a>，但是安装起来有点曲折。</p>
<p>先用SourceTree创建了本地仓库，<code>clone</code>了代码。貌似Xcode8和Xcode7安装起来有点区别。由于我的版本还是7.3.1，就省略了Xcode8的步骤。</p>
<p>Xcode7不能用最新的版本，需要使用<code>commit</code>在<code>809527b</code>之前的版本。(MD，就不能加个tag!)需要自己创建一个本地branch。</p>
<p>打开xcode，编译XVim。</p>
<p>接下来这部最坑，由于没有Linux经验，文档上直接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make</div></pre></td></tr></table></figure></p>
<p>但是没说路径，我也不知道在哪里执行，一直都是报没有<code>makefile</code>的错。而且文档上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ xcode-select -p</div></pre></td></tr></table></figure></p>
<p>也误导了我。</p>
<p>网上搜了半天，google到了(Baidu这个垃圾)，在<code>clone</code>下来的XVim目录中执行，进入目录果然有<code>MakeFile</code>，好的，直接<code>make</code>。</p>
<p>重启xcode，会提示是否使用Xvim，选择<code>load</code>就OK了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>除了Vim自身的命令外,XVim还有几个Xcode命令:</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_1.png?raw=true" alt="XVim_1"></p>
<p>附带Vim使用详解：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/XVim_2.png?raw=true" alt="XVim_2"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NodeJs学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/09/22/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇是NodeJs的学习笔记</p>
<a id="more"></a>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>模块化的好处不多说，下面看看Node中如何模块化.我们编写了一个<code>hello.js</code>文件，这个<code>hello.js</code>文件就是一个模块，模块的名字就是文件名（去掉<code>.js</code>后缀），所以<code>hello.js</code>文件就是名为<code>hello</code>的模块:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(s + <span class="string">', '</span> + name + <span class="string">'!'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = greet;</div></pre></td></tr></table></figure>
<p>上面定义了一个函数<code>greet()</code>，<code>module.exports = greet</code>的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。</p>
<p>其他模块怎么使用<code>hello</code>模块的这个<code>greet</code>函数呢？我们再编写一个<code>main.js</code>文件，调用<code>hello</code>模块的<code>greet</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入hello模块:</span></div><div class="line"><span class="keyword">var</span> greet = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">'Michael'</span>;</div><div class="line"></div><div class="line">greet(s); <span class="comment">// Hello, Michael!</span></div></pre></td></tr></table></figure>
<p><code>greet</code>变量就是上面<code>module.exports = greet</code>输出的<code>greet</code>。在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。</p>
<p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模块化保证不同模块可以使用相同的变量名，那么这是如何实现的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 准备module对象,require就是根据id获得相应module的exports:</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</div><div class="line">    id: <span class="string">'hello'</span>,</div><div class="line">    exports: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">    <span class="comment">// 读取的hello.js代码:</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name + <span class="string">'!'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.exports = greet;</div><div class="line">    <span class="comment">// hello.js代码结束</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> exported = load(<span class="built_in">module</span>);</div><div class="line"><span class="comment">// 保存module:</span></div><div class="line">save(<span class="built_in">module</span>, exported);</div></pre></td></tr></table></figure>
<p>全局变量现在变成了匿名函数内部的局部变量，所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>变量<code>module</code>是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在<code>hello.js</code>中可以直接使用变量<code>module</code>原因就在于它实际上是函数的一个参数.</p>
<p>通过把参数<code>module</code>传递给<code>load()</code>函数，<code>hello.js</code>就顺利地把一个变量传递给了Node执行环境，Node会把<code>module</code>变量保存到某个地方。</p>
<p>由于Node保存了所有导入的<code>module</code>，当我们用<code>require()</code>获取<code>module</code>时，Node找到对应的<code>module</code>，把这个<code>module</code>的<code>exports</code>变量返回，这样，另一个模块就顺利拿到了模块的输出。</p>
<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><h3 id="基本模块-1"><a href="#基本模块-1" class="headerlink" title="基本模块"></a>基本模块</h3><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><p>JavaScript有且仅有一个全局对象，在浏览器中，叫<code>window</code>对象。而在Node.js环境中，也有唯一的全局对象，叫<code>global</code>。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; process === global.process;</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; process.version;</div><div class="line"><span class="string">'v4.5.0'</span></div><div class="line">&gt; process.platform;</div><div class="line"><span class="string">'darwin'</span></div><div class="line">&gt; process.arch;</div><div class="line"><span class="string">'x64'</span></div><div class="line">&gt; process.cwd(); <span class="comment">//返回当前工作目录</span></div><div class="line"><span class="string">'/Users/michael'</span></div><div class="line">&gt; process.chdir(<span class="string">'/private/tmp'</span>); <span class="comment">// 切换当前工作目录</span></div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; process.cwd();</div><div class="line"><span class="string">'/private/tmp'</span></div></pre></td></tr></table></figure>
<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// process.nextTick()将在下一轮事件循环中调用:</div><div class="line">process.nextTick(function () &#123;</div><div class="line">    console.log(&apos;nextTick callback!&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;nextTick was set!&apos;);</div></pre></td></tr></table></figure>
<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nextTick was set!</div><div class="line">nextTick callback!</div></pre></td></tr></table></figure>
<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>
<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 程序即将退出时的回调函数:</span></div><div class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'about to exit with code: '</span> + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="判断JavaScript执行环境"><a href="#判断JavaScript执行环境" class="headerlink" title="判断JavaScript执行环境"></a>判断JavaScript执行环境</h4><p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof(window) === &apos;undefined&apos;) &#123;</div><div class="line">    console.log(&apos;node.js&apos;);</div><div class="line">&#125; else &#123;</div><div class="line">    console.log(&apos;browser&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><h4 id="异步读取文件"><a href="#异步读取文件" class="headerlink" title="异步读取文件"></a>异步读取文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的<code>String</code>。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。</p>
<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和<code>Array</code>不同）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'sample.png'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">        <span class="built_in">console</span>.log(data.length + <span class="string">' bytes'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Buffer</code>对象可以和<code>String</code>作转换，例如，把一个<code>Buffer</code>对象转换成<code>String</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Buffer -&gt; String</span></div><div class="line"><span class="keyword">var</span> text = data.toString(<span class="string">'utf-8'</span>);</div><div class="line"><span class="built_in">console</span>.log(text);</div></pre></td></tr></table></figure>
<p>或者把一个<code>String</code>转换成<code>Buffer</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// String -&gt; Buffer</span></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(text, <span class="string">'utf-8'</span>);</div><div class="line"><span class="built_in">console</span>.log(buf);</div></pre></td></tr></table></figure>
<h4 id="同步读取文件"><a href="#同步读取文件" class="headerlink" title="同步读取文件"></a>同步读取文件</h4><p>fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>);</div><div class="line"><span class="built_in">console</span>.log(data);</div></pre></td></tr></table></figure>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = <span class="string">'Hello, Node.js'</span>;</div><div class="line">fs.writeFile(<span class="string">'output.txt'</span>, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'ok.'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = <span class="string">'Hello, Node.js'</span>;</div><div class="line">fs.writeFileSync(<span class="string">'output.txt'</span>, data);</div></pre></td></tr></table></figure>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.stat(<span class="string">'sample.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 是否是文件:</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'isFile: '</span> + stat.isFile());</div><div class="line">        <span class="comment">// 是否是目录:</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'isDirectory: '</span> + stat.isDirectory());</div><div class="line">        <span class="keyword">if</span> (stat.isFile()) &#123;</div><div class="line">            <span class="comment">// 文件大小:</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'size: '</span> + stat.size);</div><div class="line">            <span class="comment">// 创建时间, Date对象:</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'birth time: '</span> + stat.birthtime);</div><div class="line">            <span class="comment">// 修改时间, Date对象:</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'modified time: '</span> + stat.mtime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="同步还是异步"><a href="#同步还是异步" class="headerlink" title="同步还是异步"></a>同步还是异步</h4><p>同步方法是为了方便使用,但是一般情况下还是使用异步的方式。服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次。</p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>
<h4 id="流读取文件"><a href="#流读取文件" class="headerlink" title="流读取文件"></a>流读取文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 打开一个流:</span></div><div class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'sample.txt'</span>, <span class="string">'utf-8'</span>);</div><div class="line"></div><div class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'DATA:'</span>)</div><div class="line">    <span class="built_in">console</span>.log(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'END'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ERROR: '</span> + err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="流写入文件"><a href="#流写入文件" class="headerlink" title="流写入文件"></a>流写入文件</h4><p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> ws1 = fs.createWriteStream(<span class="string">'output1.txt'</span>, <span class="string">'utf-8'</span>);</div><div class="line">ws1.write(<span class="string">'使用Stream写入文本数据...\n'</span>);</div><div class="line">ws1.write(<span class="string">'END.'</span>);</div><div class="line">ws1.end();</div><div class="line"></div><div class="line"><span class="keyword">var</span> ws2 = fs.createWriteStream(<span class="string">'output2.txt'</span>);</div><div class="line">ws2.write(<span class="keyword">new</span> Buffer(<span class="string">'使用Stream写入二进制数据...\n'</span>, <span class="string">'utf-8'</span>));</div><div class="line">ws2.write(<span class="keyword">new</span> Buffer(<span class="string">'END.'</span>, <span class="string">'utf-8'</span>));</div><div class="line">ws2.end();</div></pre></td></tr></table></figure>
<h4 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h4><p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>
<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'sample.txt'</span>);</div><div class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'copied.txt'</span>);</div><div class="line"></div><div class="line">rs.pipe(ws);</div></pre></td></tr></table></figure>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><h4 id="Http服务器"><a href="#Http服务器" class="headerlink" title="Http服务器"></a>Http服务器</h4><p>Node.js自带的<code>http</code>模块完成了对http协议的解析。直接操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>
<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；<br><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>
<p>我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入http模块:</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建http server，并传入回调函数:</span></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="comment">// 回调函数接收request和response对象,</span></div><div class="line">    <span class="comment">// 获得HTTP请求的method和url:</span></div><div class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">': '</span> + request.url);</div><div class="line">    <span class="comment">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">    <span class="comment">// 将HTTP响应的HTML内容写入response:</span></div><div class="line">    response.end(<span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 让服务器监听8080端口:</span></div><div class="line">server.listen(<span class="number">8080</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>
<p>可以看到以下输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node hello.js </div><div class="line">Server is running at http:<span class="comment">//127.0.0.1:8080/</span></div></pre></td></tr></table></figure>
<p>打开浏览器，输入<code>http://localhost:8080</code>即可看到输出。</p>
<h4 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h4><p>我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>
<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(url.parse(<span class="string">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span>));</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Url &#123;</div><div class="line">  protocol: <span class="string">'http:'</span>,</div><div class="line">  slashes: <span class="literal">true</span>,</div><div class="line">  auth: <span class="string">'user:pass'</span>,</div><div class="line">  host: <span class="string">'host.com:8080'</span>,</div><div class="line">  port: <span class="string">'8080'</span>,</div><div class="line">  hostname: <span class="string">'host.com'</span>,</div><div class="line">  hash: <span class="string">'#hash'</span>,</div><div class="line">  search: <span class="string">'?query=string'</span>,</div><div class="line">  query: <span class="string">'query=string'</span>,</div><div class="line">  pathname: <span class="string">'/path/to/file'</span>,</div><div class="line">  path: <span class="string">'/path/to/file?query=string'</span>,</div><div class="line">  href: <span class="string">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span> &#125;</div></pre></td></tr></table></figure>
<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">// 解析当前目录:</div><div class="line">var workDir = path.resolve(&apos;.&apos;); // &apos;/Users/michael&apos;</div><div class="line"></div><div class="line">// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:</div><div class="line">var filePath = path.join(workDir, &apos;pub&apos;, &apos;index.html&apos;);</div><div class="line">// &apos;/Users/michael/pub/index.html&apos;</div></pre></td></tr></table></figure>
<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</div><div class="line">    url = <span class="built_in">require</span>(<span class="string">'url'</span>),</div><div class="line">    path = <span class="built_in">require</span>(<span class="string">'path'</span>),</div><div class="line">    http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 从命令行参数获取root目录，默认是当前目录:</span></div><div class="line"><span class="comment">//process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径，因此第一个命令行参数从argv[2]这个位置开始。</span></div><div class="line"><span class="keyword">var</span> root = path.resolve(process.argv[<span class="number">2</span>] || <span class="string">'.'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Static root dir: '</span> + root);</div><div class="line"></div><div class="line"><span class="comment">// 创建服务器:</span></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="comment">// 获得URL的path，类似 '/css/bootstrap.css':</span></div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="comment">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></div><div class="line">    <span class="keyword">var</span> filepath = path.join(root, pathname);</div><div class="line">    <span class="comment">// 获取文件状态:</span></div><div class="line">    fs.stat(filepath, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!err &amp;&amp; stats.isFile()) &#123;</div><div class="line">            <span class="comment">// 没有出错并且文件存在:</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'200 '</span> + request.url);</div><div class="line">            <span class="comment">// 发送200响应:</span></div><div class="line">            response.writeHead(<span class="number">200</span>);</div><div class="line">            <span class="comment">// 将文件流导向response:</span></div><div class="line">            fs.createReadStream(filepath).pipe(response);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 出错了或者文件不存在:</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'404 '</span> + request.url);</div><div class="line">            <span class="comment">// 发送404响应:</span></div><div class="line">            response.writeHead(<span class="number">404</span>);</div><div class="line">            response.end(<span class="string">'404 Not Found'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">8080</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at http://127.0.0.1:8080/'</span>);</div></pre></td></tr></table></figure>
<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>
<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>。只要当前目录下存在文件<code>index.html</code>，服务器就可以把文件内容发送给浏览器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[lldb 调试方法]]></title>
      <url>http://zhang759740844.github.io/2016/09/21/lldb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>偶然看到使用 lldb 里的 watchpoint 调试，感觉很神奇，就详细了解了下 lldb 调试的使用方法。 查阅了许多文章<a href="https://objccn.io/issue-19-2/" target="_blank" rel="external">与调试器共舞 - LLDB 的华尔兹</a>这篇文章帮助最大。</p>
<a id="more"></a>
<p>Xcode中内嵌了LLDB控制台，在Xcode中代码的下方，我们可以看到LLDB控制台。</p>
<p>LLDB控制台平时会输出一些log信息(Debugger output中)。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种：</p>
<ol>
<li>断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态</li>
<li>直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序</li>
</ol>
<p>不过最好还是不要直接暂停，因为这种情况下的当前作用域没有任何变量，即使进入了 lldb 也做不了什么事。</p>
<h2 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h2><p>expression的几个命令是最常用的，能提升debug效率的命令。</p>
<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>打印一个对象:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_1.png?raw=true" alt="print"><br>可以直接缩写<code>p</code>达到同样的效果。</p>
<p>结果中有个<code>$0</code>，可以使用它指向这个结果。lldb 中可以创建对象，但是这个对象的命名必须要以<code>$</code>开头,表示命名空间是lldb，以免和外部代码中的名字冲突，如：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_2.png?raw=true" alt="print2"></p>
<h3 id="expression-1"><a href="#expression-1" class="headerlink" title="expression"></a>expression</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>如果想要改变一个值，或者执行一个方法。可以使用<code>expression</code>或者<code>e</code>：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_3.png?raw=true" alt="expression"></p>
<p>print其实是特殊的expression，比如<code>p count =18</code>其结果和<code>expression count = 18</code>结果一样。事实上，<code>print</code>是 <code>expression --</code> 的缩写。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>由于<code>expression</code>可以改变值，我们可以动态的改变View的颜色，而不需要重新编译：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 改变颜色</span></div><div class="line">(lldb) expression <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor]</div><div class="line"><span class="comment">// 刷新界面</span></div><div class="line">(lldb) expression [<span class="built_in">CATransaction</span> flush]</div></pre></td></tr></table></figure></p>
<p>不只是改变颜色，frame，animation等都能改变，非常有用。</p>
<p>如最开始所说，不能直接暂停，必须要在当前界面中触发断点，比如重写touch方法添加断点等。</p>
<h3 id="po"><a href="#po" class="headerlink" title="po"></a>po</h3><p><code>print</code>输出比较啰嗦，而且当尝试打印复杂对象的时候，有时候会很蛋疼：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) p @[ <span class="string">@"foo"</span>, <span class="string">@"bar"</span> ]</div><div class="line"></div><div class="line">(<span class="built_in">NSArray</span> *) $<span class="number">8</span> = <span class="number">0x00007fdb9b71b3e0</span> <span class="string">@"2 objects"</span></div></pre></td></tr></table></figure></p>
<p>这个时候可以使用<code>po</code>(print object 的缩写)，相当于调用对象的<code>description</code>方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) po $<span class="number">8</span></div><div class="line">&lt;__NSArrayI <span class="number">0x7fdb9b71b3e0</span>&gt;(</div><div class="line">foo,</div><div class="line">bar</div><div class="line">)</div><div class="line">(lldb) po <span class="string">@"lunar"</span></div><div class="line">lunar</div></pre></td></tr></table></figure></p>
<h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><h3 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h3><p>可以打栈中的所有帧(frame)。这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_4.png?raw=true" alt="frame"></p>
<h3 id="thread-return"><a href="#thread-return" class="headerlink" title="thread return"></a>thread return</h3><p>这也是比较有用的一个命令。Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。</p>
<p>它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后<strong>立刻执行返回命令，跳出当前栈帧</strong>。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是<strong>在函数的开头执行这个命令</strong>，是个非常好的隔离这个函数，伪造返回值的方式 。</p>
<p>比如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_5.png?raw=true" alt="return"><br>正常通过<code>isOdd</code>方法，一定是<code>return NO</code>的，但是通过<code>(lldb) thread return YES</code>，跳过了<code>isOdd</code>方法里的方法块，直接<code>return YES</code></p>
<p>正如上面所述，必须要在断点进行到如图所示的地方才可以使用<code>thread return</code>，因为:</p>
<ol>
<li>此时当前栈帧是<code>isOdd</code></li>
<li>不会造成引用问题</li>
</ol>
<h2 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint"></a>breakpoint</h2><p>断点当然是调试必不可少的东西，下面不会说明怎样添加断点，而是将列举一些断点的使用技巧.</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>当插入断点后，程序到达断点时会就会停止运行。调试条上会出现如下四个按钮:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_6.png?raw=true" alt="debug"><br>意义都很明确，不多说了，列举下对应的命令：</p>
<ol>
<li>continue按钮 =&gt; <code>continue</code>,缩写<code>c</code></li>
<li>step over按钮 =&gt; <code>next</code>，缩写<code>n</code></li>
<li>step in按钮 =&gt; <code>step</code>,缩写<code>s</code></li>
<li>step out按钮 =&gt; <code>finish</code></li>
</ol>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>在断点处右击，选择<code>Edit Breakpoint</code>弹出如下设置框：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_7.png?raw=true" alt="breakpoint"></p>
<h4 id="蓝色的勾"><a href="#蓝色的勾" class="headerlink" title="蓝色的勾"></a>蓝色的勾</h4><p>表示enable和disable断点。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>指的是条件表达式，该项允许我们对断点生效设置条件，表示当满足某一特定条件的前提下，该断点才生效。（该条件的录入，<strong>不能够识别预处理的宏定义，也不能识别断点作用域之外的变量和方法</strong>）。</p>
<h4 id="Ignore"><a href="#Ignore" class="headerlink" title="Ignore"></a>Ignore</h4><p>忽略次数。它指定了在断点生效，应用暂停之前，代码忽略断点的次数。你如果希望应用运行一段时间后断点才生效，那么就可以使用这个选项。比如说在调试某一循环体的时候。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>它表示当断点生效时，Xcode作出反应后的行为动作。点击右边的Add Action选项会弹出如下菜单：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_8.jpg?raw=true" alt="menu"><br>默认的是Debugger Command。还有以下几种动作供选择，下面将介绍两个常用的：</p>
<ol>
<li><strong>Debugger Command</strong>：默认的选项，可以让断点执行LLDB调试命令。</li>
<li><strong>Log Message</strong>：可以生成消息队列，将相关的消息输出到控制台上.随便写什么都能输出，输出的对象需要使用<code>@exp@</code>形式。</li>
</ol>
<h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><p>一个选项，勾上可以在运行到断点后不暂停，自动向下运行，配合Action相当于打了断点。</p>
<h3 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h3><h4 id="异常断点"><a href="#异常断点" class="headerlink" title="异常断点"></a>异常断点</h4><p>异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_9.png?raw=true" alt="exception"></p>
<h4 id="符号断点"><a href="#符号断点" class="headerlink" title="符号断点"></a>符号断点</h4><p>他可以中断某个方法的调用，可谓是异常强大，在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项，然后会弹出如图所示的对话框:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_10.png?raw=true" alt="exception"></p>
<p>它比普通断点的自定义设置界面多出了两个内容</p>
<ul>
<li><p><strong>Symbol</strong>：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法）例如:</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[MyViewController viewDidAppear:]</div><div class="line">+[MyViewController sharedInstance]</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Module</strong>：模组的意思，用来限制满足符号的方法，编译器将只会在断点满足这个模组的符号的时候才回暂停。</p>
</li>
</ul>
<p>需要注意的是，如果一个子类没有重写父类的方法，那么设置子类这个方法的符号断点是不会被触发的。</p>
<h3 id="watchpoint"><a href="#watchpoint" class="headerlink" title="watchpoint"></a>watchpoint</h3><p>有时候，由于不涉及到方法，无法使用断点，但是我们仍要监视某一个值是否变化，这个时候就可以用<code>watchpoin</code>t来监视一个指针的指向。</p>
<p>当指针指向变化时，<code>watchpoint</code>会触发:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_11.png?raw=true" alt="watchpoint"></p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>添加watchpoint的方式如上图所示<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) watchpoint set variable xxx</div></pre></td></tr></table></figure></p>
<p>这里要说明一下，watchpoint要监听的对象必须是<strong>当前类的对象</strong>：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_12.png?raw=true" alt="watchpoint2"><br>由于<code>self.view</code>是从<code>UIViewController</code>中继承过来的，因此无法监听。</p>
<p>另外，上面的<code>addr = 0x1556747f0</code><strong>不是指<code>_myView</code>在栈中的索引</strong>，而是指这个Watchpoint在堆中的地址。</p>
<p>Watchpoint的<strong>原理</strong>应该是在这个地址中写入了原来<code>_myView</code>指向的地址，然后对新<code>_myView</code>指向的地址和Watchpoint指向的地址是否相同来做出判断的。</p>
<h4 id="disable-delete-enable"><a href="#disable-delete-enable" class="headerlink" title="disable/delete/enable"></a>disable/delete/enable</h4><p>watchpoint资源也是比较有限的，对于不需要监听的对象要及时释放。每个watchpoint都有一个序号，操作对应的需要即可：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/lldb_13.png?raw=true" alt="watchpoint3"></p>
<h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>这是我比较喜欢的方法，所以单独列出来。</p>
<p>调试的时候经常需要重新启动程序。但是如果重新Run程序，需要重新编译，非常浪费时间。可以在 lldb 中输入<code>run</code>就能直接让程序重新加载了。</p>
<h3 id="通过地址操作"><a href="#通过地址操作" class="headerlink" title="通过地址操作"></a>通过地址操作</h3><p>比如expression,print都可以通过地址来访问对象，但是实验下来，感觉没有太大用处。</p>
<p>本来想要监控<code>self.view.backgroundColor</code>的改变情况，但是不能通过变量名，就尝试能否通过地址，结果发现也不行。</p>
<p>因此，可以大体上认为，能通过地址访问的，那也能通过变量名访问，并且通过变量名访问更清晰迅速，通过地址访问没有优势，故不推荐使用。</p>
<h3 id="代替NSLog"><a href="#代替NSLog" class="headerlink" title="代替NSLog"></a>代替NSLog</h3><p>看<code>NSLog</code>的文档，第一句话就说：<code>Logs an error message to the Apple System Log facility.</code>，所以首先，<code>NSLog</code>就不是设计作为普通的<code>debug log</code>的，而是<code>error log</code>；每次<code>NSLog</code>都会进行很多耗时工作，因此，非重要参数尽量不要用，使用调试代替。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIScrollView详细介绍]]></title>
      <url>http://zhang759740844.github.io/2016/09/18/Scrollview%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本次将参考<a href="https://my.oschina.net/zhxx/blog/620969#OSC_h3_11" target="_blank" rel="external">iOS 性能优化之 UIScrollView 实践经验</a>对UIScrollView的使用方式进行详细介绍<br><a id="more"></a></p>
<h2 id="ScrollView和Auto-Layout"><a href="#ScrollView和Auto-Layout" class="headerlink" title="ScrollView和Auto Layout"></a>ScrollView和Auto Layout</h2><p><code>UIScrollView</code> 在 <code>Auto Layout</code> 是一个很特殊的 <code>view</code>，对于 <code>UIScrollView</code> 的 <code>subview</code> 来说，它的 <code>leading/trailing/top/bottom space</code> 是<strong>相对于 <code>UIScrollView</code>的 <code>contentSize</code> 而不是 <code>bounds</code> (自身在屏幕上显示的边界，不明白的可以查一下 bounds 和 frame 的区别)来确定的。</strong></p>
<p>所以，一般的做法是在<code>UIScrollVIew</code>和它的<code>subViews</code>之间增加一个<code>content view</code>。这样可以方便地给 <code>subview</code> 提供 <code>leading/trailing/top/bottom</code>，方便 <code>subview</code> 的布局，并且可以 通过调整<code>content view</code> 的 <code>size</code>（调整<code>constraint</code> 的 <code>IBOutlet</code>）来调整 <code>contentSize</code>。</p>
<h3 id="添加ContentView的注意点"><a href="#添加ContentView的注意点" class="headerlink" title="添加ContentView的注意点"></a>添加ContentView的注意点</h3><p><code>scrollview</code>中添加的<code>contentview</code>和添加一般的视图不同，一般的视图只要只要提供<code>leading/trailing/top/bottom space</code>就能唯一确定长宽，位置。<br>而<code>ScrollView</code>的<code>contentView</code>除了上述四个约束，还需要设置长宽，作为滚动的范围的一部分。</p>
<p>所以整个<code>scrollview</code>的<code>contentSize</code>的等式应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrollView.contentSize.width = (scrollview与contentview之间leading的constant)+（contentView的width）+（scrollview与contentview之间trailing的constant）</div></pre></td></tr></table></figure></p>
<p><strong>另外一点需要强调两点：</strong></p>
<ol>
<li><code>ScrollView</code>的<code>bounds</code>早就确定了下来，在设置<code>contentview</code>的宽度的时候，如果设置<code>contentview.width = superview.width + constant</code>这里的<code>superview.width</code>是指<code>ScrollView.bounds</code>而不是<code>contentSize</code></li>
<li>在设置<code>contentview</code>的上下左右约束的时候，如果设置<code>contentview.trailing = superview.trailing + constant</code>,这里的<code>superview.trailing</code>指的是<code>contentSize.trailing</code>而不是<code>bounds</code>。此时就可以通过上面的公式计算<code>contentSize</code>的宽度了。</li>
</ol>
<blockquote>
<p>Demo参见AutoLayout</p>
</blockquote>
<h2 id="UIScrollView部分属性"><a href="#UIScrollView部分属性" class="headerlink" title="UIScrollView部分属性"></a>UIScrollView部分属性</h2><h3 id="contentSize、contentInset和contentOffset"><a href="#contentSize、contentInset和contentOffset" class="headerlink" title="contentSize、contentInset和contentOffset"></a><strong>contentSize</strong>、<strong>contentInset</strong>和<strong>contentOffset</strong></h3><ul>
<li>contentSize: 就是scrollview可以滚动的区域.<br>比如frame = (0 ,0 ,320 ,480) contentSize = (320 ,960)，代表你的scrollview可以上下滚动，滚动区域为frame大小的两倍。</li>
<li>contentOffset:就是scrollview当前显示区域顶点相对于frame顶点的偏移量。<br>比如上个例子你拉到最下面，contentoffset就是(0 ,480)，也就是y偏移了480 </li>
<li>contentInset:就是scrollview的contentview的顶点相对于scrollview的位置。<br>例如你的contentInset = (0 ,100)，那么你的contentview就是从scrollview的(0 ,100)开始显示 </li>
</ul>
<p>/<em> 上拉刷新一般实现代码如下 </em>/<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate&#123;     </div><div class="line">    [_refreshHeaderView egoRefreshScrollViewDidEndDragging:scrollView];  </div><div class="line">    <span class="keyword">float</span> offset=scrollView.contentOffset.y;  </div><div class="line">    <span class="keyword">float</span> contentHeight=scrollView.contentSize.height;  </div><div class="line">    <span class="keyword">float</span> sub=contentHeight-offset;  </div><div class="line">    <span class="keyword">if</span> ((scrollView.height-sub)&gt;<span class="number">20</span>) &#123;<span class="comment">//如果上拉距离超过20p，则加载更多数据  </span></div><div class="line">        <span class="comment">//[self loadMoreData];//此处在view底部加载更多数据  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UIScrollViewDelegate"><a href="#UIScrollViewDelegate" class="headerlink" title="UIScrollViewDelegate"></a>UIScrollViewDelegate</h2><p><code>UIScrollViewDelegate</code> 是 <code>UIScrollView</code> 的 <code>delegate protocol</code>，<code>UIScrollView</code> 有意思的功能都是通过它的 delegate 方法实现的。</p>
<h3 id="void-scrollViewDidScroll-UIScrollView-scrollView"><a href="#void-scrollViewDidScroll-UIScrollView-scrollView" class="headerlink" title="- (void)scrollViewDidScroll:(UIScrollView *)scrollView"></a>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</h3><p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>
<h3 id="void-scrollViewWillBeginDragging-UIScrollView-scrollView"><a href="#void-scrollViewWillBeginDragging-UIScrollView-scrollView" class="headerlink" title="- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView"></a>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</h3><p>用户开始拖动 scroll view 的时候被调用。</p>
<h3 id="void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset"><a href="#void-scrollViewWillEndDragging-UIScrollView-scrollView-withVelocity-CGPoint-velocity-targetContentOffset-inout-CGPoint-targetContentOffset" class="headerlink" title="- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset"></a>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset</h3><p>在 didEndDragging 前被调用，当 willEndDragging 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，didEndDragging 中的 <code>decelerate</code> 为 <code>NO</code>，即没有减速过程，willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，可以改变减速运动的目的地，这在一些效果的实现时十分有用。</p>
<h3 id="void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate"><a href="#void-scrollViewDidEndDragging-UIScrollView-scrollView-willDecelerate-BOOL-decelerate" class="headerlink" title="- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate"></a>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</h3><p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，scroll view 的 dragging 并不会立即置为 <code>NO</code>，而是要等到减速结束之后，所以<strong>这个 dragging 属性的实际语义更接近 scrolling</strong>。</p>
<h3 id="void-scrollViewWillBeginDecelerating-UIScrollView-scrollView"><a href="#void-scrollViewWillBeginDecelerating-UIScrollView-scrollView" class="headerlink" title="- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView"></a>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView</h3><p>减速动画开始前被调用。</p>
<h3 id="void-scrollViewDidEndDecelerating-UIScrollView-scrollView"><a href="#void-scrollViewDidEndDecelerating-UIScrollView-scrollView" class="headerlink" title="- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView"></a>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</h3><p>减速动画结束时被调用。</p>
<p>这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，didEndDecelerating 不会被调用，<strong>并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 <code>YES</code></strong>(因为，此时ScrollView还在滚动，并且还在减速)。新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用。</p>
<blockquote>
<p>Demo参见Delegate</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Table-View-中图片加载逻辑的优化"><a href="#Table-View-中图片加载逻辑的优化" class="headerlink" title="Table View 中图片加载逻辑的优化"></a>Table View 中图片加载逻辑的优化</h3><p><strong>优化目的</strong>：滑动时不加载图片，在滑动停止时加载图片</p>
<p><strong>优化难点</strong>：前面提到，刚开始拖动的时候，<code>dragging</code> 为 <code>YES</code>，<code>decelerating</code> 为 <code>NO</code>；<code>decelerate</code> 过程中，<code>dragging</code> 和 <code>decelerating</code> 都为 <code>YES</code>；decelerate 未结束时开始下一次拖动，<code>dragging</code> 和 <code>decelerating</code> 依然都为 <code>YES</code>。所以无法简单通过 table view 的 <code>dragging</code> 和 <code>decelerating</code> 判断是在用户拖动还是减速过程。</p>
<p>所以不能仅通过<code>decelerating</code>来判断是否加载图片，还需要自己记录用户拖动状态，在拖动时也要加载图片。（涉及到需要注意的点很多，还是直接看<a href="https://my.oschina.net/zhxx/blog/620969#OSC_h3_11" target="_blank" rel="external">原文</a>比较好）</p>
<p><strong>优化方法</strong>：</p>
<ol>
<li>每次开始拖动时scrollViewWillBeginDragging，通过<code>NSArray *cells = [self.tableView visibleCells];</code>获取屏幕上所有显示的<code>Cell</code>，全部加载一遍图片（解决问题三）</li>
<li>利用<code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code>方法，将<code>targetContentOffset</code>即最后减速结束后在屏幕上显示的位置，转换为一个<code>CGRect</code>，在<code>CGRect</code>范围里的<code>Cell</code>才在<code>CellForRowAtIndex</code>中加载。</li>
</ol>
<blockquote>
<p>Demo详见LazyLoad</p>
</blockquote>
<h3 id="分页的几种实现方法"><a href="#分页的几种实现方法" class="headerlink" title="分页的几种实现方法"></a>分页的几种实现方法</h3><p>分页类似于 android 中的 viewpager ，利用 UIScrollView 有多种方法实现分页，但是各自的效果和用途不尽相同。</p>
<h4 id="pagingEnabled"><a href="#pagingEnabled" class="headerlink" title="pagingEnabled"></a>pagingEnabled</h4><p>系统提供的分页方式，实现简单，只需要<code>_scrollView.pagingEnabled = YES</code>即可，但是有局限性：</p>
<ul>
<li>只能以 ScrollView 的 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页。</li>
<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>
</ul>
<p>Sample 中 Pagination 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>
<ul>
<li>让 scroll view 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 <code>NO</code>,这样前后不在 scrollView 中的部分就能显示一部分出来。见下图:</li>
<li>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 touch bridging 的功能</li>
</ul>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIScrollView_pagingEnabled.png?raw=true" alt="UIScrollView_pagingEnabled"></p>
<p>适用场景：上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>
<h4 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h4><p>核心算法是通过当前 contentOffset 计算最近的整数页及其对应的 contentOffset，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 decelerate 结束以后才发生，总感觉很突兀。使用体验不如下面的方法。</p>
<h4 id="修改targetContentOffset"><a href="#修改targetContentOffset" class="headerlink" title="修改targetContentOffset"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 <code>offset</code> 为整数页位置。其中核心代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGPoint</span>)nearestTargetOffsetForOffset:(<span class="built_in">CGPoint</span>)offset</div><div class="line">&#123;    <span class="built_in">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;    <span class="built_in">NSInteger</span> page = roundf(offset.x / pageSize);    <span class="built_in">CGFloat</span> targetX = pageSize * page;    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(targetX, offset.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset</div><div class="line">&#123;    <span class="built_in">CGPoint</span> targetOffset = [<span class="keyword">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class="line">    targetContentOffset-&gt;x = targetOffset.x;</div><div class="line">    targetContentOffset-&gt;y = targetOffset.y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适用场景：方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>
<blockquote>
<p>Demo详见Pagination</p>
</blockquote>
<h3 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h3><p>大部分的 iOS 开发应该都清楚 <code>UITableView</code> 的 cell 重用机制，这种重用机制减少了内存开销也提高了 performance，<code>UIScrollView</code> 作为 <code>UITableView</code> 的父类，在很多场景中也很适合应用重用机制。</p>
<p>可以参照 <code>UITableView</code> 的 cell 重用机制，总结重用机制如下：</p>
<ul>
<li>维护一个重用队列</li>
<li>当元素离开可见范围时，<code>removeFromSuperview</code> 并加入重用队列（enqueue）</li>
<li>当需要加入新的元素时，先尝试从重用队列获取可重用元素（dequeue）并且从重用队列移除</li>
<li>如果队列为空，新建元素</li>
<li>将新建元素的view通过<code>addSubView</code>添加至 <code>contentView</code>上</li>
<li>这些一般都在 <code>scrollViewDidScroll:</code> 方法中完成</li>
</ul>
<p>Demo中演示了一个在scrollView中添加多个重用ViewController的场景，具体重用方法参见Demo</p>
<hr>
<p>这里要说明一下Demo中用到的<code>addChildViewController</code>。</p>
<p>苹果在iOS 5 添加了一系列的方法，希望我们在使用<code>addSubView</code>时，同时调用<code>[self addChildViewController:child]</code>方法将sub view对应的viewController也加到当前ViewController的管理中。</p>
<p>对于那些当前暂时不需要显示的subview，只通过<code>addChildViewController</code>把subViewController加进去；需要显示时再调用<code>transitionFromViewController</code>方法。将其添加进入底层的ViewController中。</p>
<p>这样做的好处：</p>
<ol>
<li>对页面中的逻辑更加分明了。相应的View对应相应的ViewController。</li>
<li>当某个子View没有显示时，将不会被Load，减少了内存的使用。</li>
<li>当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。</li>
<li>可以调用<code>transitionFromViewController</code>等系统方法，ios对于显示以及动画做了比较好的封装</li>
<li>相当于对于 ViewController 实例的保存。实例都保存在<code>self.childViewControllers</code>中，需要使用的时候从中取出即可。</li>
</ol>
<p>当然，像本例中在 ScrollView 中添加 ViewController ，只需要对 ViewController 进行复用，但是用不到其提供的系统方法时，其实只要使用一个数组将各个 ViewController 保存起来就可以了。</p>
<p>其实这些都不重要，如果不需要对 ViewController 做复用或者一些其他操作，我们连ViewController的实例都不必保存。我们只需要在需要显示的时候<code>[self.contentView addSubview:vc.view];</code>,不需要显示的时候<code>[vc.view removeFromSuperview];</code>，就可以达到显示和相应事件的需求了。</p>
<hr>
<blockquote>
<p>Demo详见Reuse</p>
</blockquote>
<h3 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h3><p>所谓联动，就是当 A 滚动的时候，在 <strong><code>scrollViewDidScroll:</code></strong> 里根据 A 的 <code>contentOffset</code> 动态计算 B 的 <code>contentOffset</code> 并设给 B。同样对于非 scroll view 的 C，也可以动态计算 C 的 frame 或是 transform实现视差滚动或者其他高级动画，这在现在许多应用的引导页面里会被用到。</p>
<p>Demo中的核心代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    <span class="keyword">if</span> (scrollView == <span class="keyword">self</span>.titleScrollView) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> contentX = <span class="keyword">self</span>.titleScrollView.contentOffset.x / <span class="keyword">self</span>.titleScrollView.frame.size.width * <span class="keyword">self</span>.contentScrollView.frame.size.width;</div><div class="line">        <span class="keyword">self</span>.contentScrollView.contentOffset = <span class="built_in">CGPointMake</span>(contentX, <span class="number">0.0</span>);</div><div class="line">        <span class="built_in">CGFloat</span> transX = <span class="keyword">self</span>.titleScrollView.contentOffset.x / (<span class="keyword">self</span>.titleScrollView.contentSize.width - <span class="keyword">self</span>.titleScrollView.frame.size.width) * (<span class="keyword">self</span>.backgroundImage.frame.size.width - <span class="keyword">self</span>.view.frame.size.width);</div><div class="line">        transX = MAX(<span class="number">0.0</span>, transX);</div><div class="line">        transX = MIN(<span class="keyword">self</span>.backgroundImage.frame.size.width - <span class="keyword">self</span>.view.frame.size.width, transX);</div><div class="line">        <span class="keyword">self</span>.backgroundImage.transform = <span class="built_in">CGAffineTransformMakeTranslation</span>(-transX, <span class="number">0.0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>titleScrollView</code>计算<code>contentX</code>和<code>transX</code>来分别控制<code>contentScrollView</code>以及<code>backgroundImage</code>这两个View的位置变化。</p>
<blockquote>
<p>Demo参见Parallax</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ScrollView看似简单，其实还是有非常多的地方值得去挖掘的。使用好，能够实现很多非常酷炫的效果。上面的原理和应用涉及到的点很多，还需要细细琢磨，学以致用.</p>
<blockquote>
<p>上述所有Demo均在UIScrollViewDemo文件夹中</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSNotification的使用]]></title>
      <url>http://zhang759740844.github.io/2016/09/13/NSNotification%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本篇是对ios的通知使用方法的一个简单罗列。</p>
<a id="more"></a>
<h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p><code>NSNotificationCenter</code>就是一个消息通知机制，类似广播。观察者只需要向消息中心注册感兴趣的东西，当有地方发出这个消息的时候，通知中心会发送给注册这个消息的对象。这样也起到了多个对象之间解耦的作用。苹果给我们封装了这个<code>NSNotificationCenter</code>，让我们可以很方便的进行通知的注册和移除。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="addObserver-selector-name-object"><a href="#addObserver-selector-name-object" class="headerlink" title="addObserver:selector:name:object:"></a>addObserver:selector:name:object:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) name:<span class="string">@"test"</span> object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>addObserver</code>:貌似都是<code>controller</code>因为还需要<code>selector</code>来执行</li>
<li><code>name</code>:通知名。当发送该通知名的通知是，观察者收到消息。</li>
<li><code>object</code>:缩小接受通知的范围，只接受相对应的<code>object</code>对象发来的通知。<code>nil</code>则全部接收。</li>
</ul>
<h3 id="addObserverForName-object-queue-usingBlock"><a href="#addObserverForName-object-queue-usingBlock" class="headerlink" title="addObserverForName:object:queue:usingBlock:"></a>addObserverForName:object:queue:usingBlock:</h3><p><code>NSNotificationCenter</code>消息的接受线程是基于发送消息的线程的,也就是<strong>同步</strong>的，因此，有时候，你发送的消息可能不在主线程，而大家都知道操作UI必须在主线程，不然会出现不响应的情况。所以，在你收到消息通知的时候，注意选择你要执行的线程。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:notification object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^()&#123;...&#125;];</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li><code>queue</code>:<code>block</code>执行所在的线程。如果是<code>nil</code>那么就在当前线程(posting thread)</li>
<li><code>block</code>:该种方式不用<code>selector</code>而使用<code>block</code>回调。</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>只要往<code>NSNotificationCenter</code>注册了，就必须有<code>remove</code>的存在。</p>
<h3 id="removeObserver"><a href="#removeObserver" class="headerlink" title="removeObserver:"></a>removeObserver:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)notificationObserver</div></pre></td></tr></table></figure>
<p>对应<code>addObserverForName</code>方式，直接把上面的<code>id observer</code>作为参数传入即可。<br>对应<code>addObserver</code>方式，删除<code>controller</code>中全部通知.</p>
<h3 id="removeObserver-name-object"><a href="#removeObserver-name-object" class="headerlink" title="removeObserver:name:object:"></a>removeObserver:name:object:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:NotificationCitySelect object:<span class="literal">nil</span>]</div></pre></td></tr></table></figure>
<p>删除指定<code>name</code>的通知。</p>
<h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:NotificationCitySelectChanged object:@&#123;NotificationCitySelect_ObjectLocationChange:@(<span class="literal">YES</span>)&#125;]</div></pre></td></tr></table></figure>
<p>发送指定<code>objcet</code>的通知，只有注册时注册了该对象的通知才可以接收。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UILabel高度控制]]></title>
      <url>http://zhang759740844.github.io/2016/09/12/UILabel%E7%9A%84%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>在<a href="https://zhang759740844.github.io/2016/08/26/UITableview自适应高度/">tableview自适应高度</a>一篇中学习了如何用<code>systemLayoutSizeFittingSize:</code>方法得到UITableView的Cell的高度。本文将探究一般情况下如何得到UILabel的高度。</p>
<a id="more"></a>
<h2 id="sizeThatFits的使用"><a href="#sizeThatFits的使用" class="headerlink" title="sizeThatFits的使用"></a>sizeThatFits的使用</h2><p><code>sizeThatFits</code>是UIView中的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)sizeThatFits:(<span class="built_in">CGSize</span>)size;</div></pre></td></tr></table></figure></p>
<p>官方文档的注释：</p>
<blockquote>
<p>return ‘best’ size to fit given size. does not actually resize view. Default is return existing view size<br>也就是说，该方法将会根据传入的<code>size</code>,计算得到最佳的UIView的宽高，直接返回，不对View做任何修改。</p>
</blockquote>
<p>UILabel会根据传入的<code>size</code>的<code>width</code>自动换行，得到<code>height</code>后，将这两个值作为估算出的<code>CGSize</code>返回。<br>如果传入的是<code>CGSizeZero</code>相当于不设置换行宽度，一行到底。</p>
<p>由于<code>SizeThatFits</code>只估算，不修改。在得到估算值后，需要手动设置UILabel的<code>frame</code>或者<code>constraint</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) useSizeThatFitsZeroWithLabel:(<span class="built_in">UILabel</span> *)label&#123;</div><div class="line">    <span class="comment">//使用CGSizeZero相当于不设置换行宽度，一行到底</span></div><div class="line">    <span class="built_in">CGSize</span> size = [label sizeThatFits:<span class="built_in">CGSizeZero</span>];</div><div class="line">    label.frame = <span class="built_in">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) useSizeThatFitsCustomWithLabel:(<span class="built_in">UILabel</span> *)label&#123;</div><div class="line">    <span class="comment">//使用自定义的CGSize，会根据size的宽度进行换行</span></div><div class="line">    <span class="built_in">CGSize</span> size = [label sizeThatFits:<span class="built_in">CGSizeMake</span>(<span class="number">50</span>, <span class="number">50</span>)];</div><div class="line">    label.frame = <span class="built_in">CGRectMake</span>(label.frame.origin.x, label.frame.origin.y, size.width, size.height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SizeToFit"><a href="#SizeToFit" class="headerlink" title="SizeToFit"></a>SizeToFit</h2><p><code>SizeToFit</code>的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sizeToFit;</div></pre></td></tr></table></figure></p>
<p><code>SizeToFit</code>的文档注释：</p>
<blockquote>
<p>calls sizeThatFits: with current view bounds and changes bounds size.<br>也就是说，它会调用<code>SizeThatFits</code>,并且直接设置View的<code>bounds</code>。</p>
</blockquote>
<p>既然要调用<code>sizeThatFits</code>那就需要传入一个<code>CGSize</code>。这个<code>CGSize</code>就是设置View的<code>frame</code>时传入的<code>height</code>,<code>width</code>。</p>
<h2 id="frame与constraint"><a href="#frame与constraint" class="headerlink" title="frame与constraint"></a>frame与constraint</h2><p>在代码添加View时，init都会使用<code>initWithFrame:</code>方法。在AutoLayout后，<code>constraint</code>被使用，是为了适配不同屏幕的机器。</p>
<ul>
<li>设置好View之间的<code>constraint</code>后，一个View的约束改变，将会联动改变其他View的位置、大小。</li>
<li>设置好View的<code>frame</code>或者<code>bound</code>后，改变View的<code>frame</code>，不会对其它View造成任何影响。</li>
<li>在设置好<code>constraint</code>后，显示的View就以约束为准。修改<code>frame</code>，View的显示没有任何改变，虽然<code>frame</code>确实变了。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"改变前%f,%f,%f,%f"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class="line">_label.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"改变后%f,%f,%f,%f"</span>,_label.frame.size.height,_label.frame.size.width,_label.frame.origin.x,_label.frame.origin.y);</div><div class="line"></div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">44.458</span> Parallax[<span class="number">2126</span>:<span class="number">578089</span>] <span class="number">66.000000</span>,<span class="number">147.000000</span>,<span class="number">180.000000</span>,<span class="number">117.000000</span></div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">44.459</span> Parallax[<span class="number">2126</span>:<span class="number">578089</span>] 改变后<span class="number">200.000000</span>,<span class="number">200.000000</span>,<span class="number">0.000000</span>,<span class="number">0.000000</span></div></pre></td></tr></table></figure>
<h2 id="与systemLayoutSizeFittingSize的比较"><a href="#与systemLayoutSizeFittingSize的比较" class="headerlink" title="与systemLayoutSizeFittingSize的比较"></a>与systemLayoutSizeFittingSize的比较</h2><p><code>systemLayoutSizeFittingSize</code>方法是在整个view的约束已经确定，通过计算UILabel的高度(或许其中也调用了<code>sizeThatFits</code>吧)，得到最适合的supview的高度。</p>
<p><code>sizetofit</code>和<code>sizethatfits</code>则是在supview的高度确定的情况下，计算得到UILabel的高度，然后通过手动设置frame或者约束条件，将其添加到supview上。</p>
<blockquote>
<p>Demo 详见 UIScrollViewDemo/Parallax</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript基本语法]]></title>
      <url>http://zhang759740844.github.io/2016/09/09/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>参考自<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰的JavaScript教程</a></p>
<a id="more"></a>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>JS不区分整数浮点数，统一用<code>Number</code>表示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class="line"><span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class="line"><span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure></p>
<p><code>Number</code>可以直接运算：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></div><div class="line"><span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></div><div class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></div><div class="line"><span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1 (取余)</span></div><div class="line"><span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></div></pre></td></tr></table></figure></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本.如<code>&#39;abc&#39;</code> </p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>用<code>true</code>和<code>false</code>表示。</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>JavaScript在设计时，有两种比较运算符：<br>第一种是<code>==</code>比较，它会自动转换数据类型再比较.<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>
<p><code>NaN</code>这个特殊的<code>Number</code>与所有其他值都不相等，包括它自己：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>JavaScript的数组可以包括任意数据类型。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div></pre></td></tr></table></figure></p>
<p>另一种创建数组的方法是通过Array()函数实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为0：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">arr[<span class="number">0</span>]; <span class="comment">// 返回索引为0的元素，即1</span></div><div class="line">arr[<span class="number">5</span>]; <span class="comment">// 返回索引为5的元素，即true</span></div><div class="line">arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">'Bob'</span>,</div><div class="line">    age: <span class="number">20</span>,</div><div class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</div><div class="line">    city: <span class="string">'Beijing'</span>,</div><div class="line">    hasCar: <span class="literal">true</span>,</div><div class="line">    zipcode: <span class="literal">null</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript对象的键都是<strong>字符串类型</strong>，值可以是任意数据类型。</p>
<p>要获取一个对象的属性，我们用对象变量.属性名的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person.name; <span class="comment">// 'Bob'</span></div><div class="line">person.zipcode; <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>申明一个变量用var语句，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></div><div class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class="line"><span class="keyword">var</span> s_007 = <span class="string">'007'</span>; <span class="comment">// s_007是一个字符串</span></div><div class="line"><span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></div><div class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></div></pre></td></tr></table></figure></p>
<p>注意只能用var申明一次。</p>
<h4 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h4><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div></pre></td></tr></table></figure></p>
<p>不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p>
<h3 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h3><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用<code>+</code>号连接：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> message = <span class="string">'你好, '</span> + name + <span class="string">', 你今年'</span> + age + <span class="string">'岁了!'</span>;</div><div class="line">alert(message);</div></pre></td></tr></table></figure></p>
<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</div><div class="line">alert(message);</div></pre></td></tr></table></figure></p>
<h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>字符串常见的操作如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line">s.length; <span class="comment">// 13</span></div></pre></td></tr></table></figure></p>
<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line"></div><div class="line">s[<span class="number">0</span>]; <span class="comment">// 'H'</span></div><div class="line">s[<span class="number">6</span>]; <span class="comment">// ' '</span></div><div class="line">s[<span class="number">7</span>]; <span class="comment">// 'w'</span></div><div class="line">s[<span class="number">12</span>]; <span class="comment">// '!'</span></div><div class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure></p>
<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果.</p>
<h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase"></a>toUpperCase</h4><p><code>toUpperCase()</code>返回一个全大写的字符串</p>
<h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase"></a>toLowerCase</h4><p><code>toLowerCase()</code>f返回一个全小写的字符串</p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p><code>indexOf()</code>会搜索指定字符串出现的位置:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span>;</div><div class="line">s.indexOf(<span class="string">'world'</span>); <span class="comment">// 返回7</span></div><div class="line">s.indexOf(<span class="string">'World'</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure></p>
<h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><p><code>substring()</code>返回指定索引区间的子串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span></div><div class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure></p>
<h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">arr.length; <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">arr.length; <span class="comment">// 3</span></div><div class="line">arr.length = <span class="number">6</span>;</div><div class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class="line">arr.length = <span class="number">2</span>;</div><div class="line">arr; <span class="comment">// arr变为[1, 2]</span></div></pre></td></tr></table></figure></p>
<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">arr[<span class="number">5</span>] = <span class="string">'x'</span>;</div><div class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure></p>
<p><strong>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>
<h4 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf"></a>indexOf</h4><p>与<code>String</code>类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</div><div class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></div><div class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></div><div class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></div><div class="line">arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure></p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p><code>slice()</code>就是对应<code>String</code>的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure></p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code></p>
<h4 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h4><p><code>push()</code>向<code>Array</code>的末尾添加<strong>若干</strong>元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">arr; <span class="comment">// [1, 2, 'A', 'B']</span></div><div class="line">arr.pop(); <span class="comment">// pop()返回'B'</span></div><div class="line">arr; <span class="comment">// [1, 2, 'A']</span></div><div class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></div><div class="line">arr; <span class="comment">// []</span></div><div class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></div><div class="line">arr; <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<h4 id="unshift和shift"><a href="#unshift和shift" class="headerlink" title="unshift和shift"></a>unshift和shift</h4><p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">arr; <span class="comment">// ['A', 'B', 1, 2]</span></div><div class="line">arr.shift(); <span class="comment">// 'A'</span></div><div class="line">arr; <span class="comment">// ['B', 1, 2]</span></div><div class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></div><div class="line">arr; <span class="comment">// []</span></div><div class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></div><div class="line">arr; <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：</p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>reverse()把整个Array的元素给掉个个，也就是反转.</p>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</div><div class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</div><div class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div><div class="line">// 只删除,不添加:</div><div class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</div><div class="line">// 只添加,不删除:</div><div class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</div><div class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</div></pre></td></tr></table></figure></p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>
<p>请注意，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。<br>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure></p>
<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaohong = &#123;</div><div class="line">    name: <span class="string">'小红'</span>,</div><div class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></div><div class="line">xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></div><div class="line">xiaohong.name; <span class="comment">// '小红'</span></div></pre></td></tr></table></figure></p>
<p>如果属性名是其他对象，那么需要用<code>[]</code>将其括起来，表示对外部对象执行<code>toString()</code>操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> weight = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"1weight"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name :  <span class="string">"小明"</span>,</div><div class="line">    [weight()] :<span class="string">"属性名是返回值1weight"</span>,</div><div class="line">    [weight]:<span class="string">"属性名是整个function"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(xiaoming)</div><div class="line">返回：</div><div class="line">&#123; name: <span class="string">'小明'</span>,</div><div class="line">  <span class="string">'1weight'</span>: <span class="string">'属性名是返回值1weight'</span>,</div><div class="line">  <span class="string">'function () &#123;\n    return "1weight"\n&#125;'</span>: <span class="string">'属性名是整个function'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span></div><div class="line">&#125;;</div><div class="line">xiaoming.age; <span class="comment">// undefined</span></div><div class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></div><div class="line">xiaoming.age; <span class="comment">// 18</span></div><div class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></div><div class="line">xiaoming.age; <span class="comment">// undefined</span></div><div class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></div><div class="line">xiaoming.name; <span class="comment">// undefined</span></div><div class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure></p>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符,不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div><div class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span></div><div class="line">&#125;;</div><div class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p>JS中默认对象表达方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。<br>但是JavaScript的对象有个小问题，就是<strong>键必须是字符串</strong>。但实际上Number或者其他数据类型作为键也是非常合理的。<br>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</div><div class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></div><div class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></div><div class="line">m.set(<span class="string">'Zachary'</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>重复元素在Set中自动被过滤：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</div><div class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></div></pre></td></tr></table></figure></p>
<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">&gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">&gt;&gt;&gt; s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div></pre></td></tr></table></figure></p>
<p>通过delete(key)方法可以删除元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></div><div class="line">s.delete(<span class="number">3</span>);</div><div class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h3><p>ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p>用<code>for ... of</code>循环遍历集合，用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></div><div class="line">    alert(x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></div><div class="line">    alert(x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></div><div class="line">    alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</strong><br><code>for ... in</code>实际上是<strong>对象的属性名称(注意，是键，不是值)</strong>。不要用在<code>Array</code>,<code>Set</code>,<code>Map</code>上，会出现奇怪的问题。<br><code>for ... of</code>循环则完全修复了这些问题，它<strong>只循环得到集合内该出现的元素(注意，是值，不是键)</strong>，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.name = <span class="string">'Hello'</span>;</div><div class="line">a[<span class="string">'4'</span>] = <span class="string">'D'</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> num <span class="keyword">of</span> a)&#123;</div><div class="line">    <span class="built_in">console</span>.log(num)</div><div class="line">&#125;</div><div class="line">输出：</div><div class="line">[ <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, , <span class="string">'D'</span>, name: <span class="string">'Hello'</span> ]</div><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line"><span class="literal">undefined</span></div><div class="line">D</div></pre></td></tr></table></figure></p>
<p><code>name</code>由于不是正常<code>Array</code>该有的，所以在<code>for ... of</code>循环时，其对应的值不会被输出。</p>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">    <span class="comment">// element: 指向当前元素的值</span></div><div class="line">    <span class="comment">// index: 指向当前索引</span></div><div class="line">    <span class="comment">// array: 指向Array对象本身</span></div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于<code>Set</code>来说，由于没有索引，<code>index</code>也是指当前元素。<br>对于<code>Map</code>来说，<code>element</code>和<code>index</code>分别对应<code>Value</code>和<code>Key</code>.</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h3><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>方式一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> -x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于JavaScript的函数也是一个对象，上述定义的<code>abs()</code>函数实际上是一个函数对象，而函数名<code>abs</code>可以视为指向该函数的变量。</p>
<p>方式二：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> -x;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。</p>
<p>上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个<code>;</code>，表示赋值语句结束。</p>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abs(<span class="number">10</span>, <span class="string">'blablabla'</span>); <span class="comment">// 返回10</span></div><div class="line">abs(<span class="number">-9</span>, <span class="string">'haha'</span>, <span class="string">'hehe'</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></div></pre></td></tr></table></figure></p>
<p>传入的参数比定义的少也没有问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abs(); <span class="comment">// 返回NaN</span></div></pre></td></tr></table></figure></p>
<p>此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。</p>
<p>要避免收到undefined，可以对参数进行检查：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x) !== <span class="string">'number'</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> -x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>JavaScript还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<code>arguments</code>类似<code>Array</code>但它不是一个<code>Array</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    alert(x); <span class="comment">// 10</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">        alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</div></pre></td></tr></table></figure></p>
<p>利用<code>arguments</code>，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值.实际上arguments最常用于判断传入参数的个数。</p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>由于JavaScript函数允许接收任意个参数，于是我们就不得不用<code>arguments</code>来获取所有参数.<br>ES6标准引入了<code>rest</code>参数，可以将剩余的参数放在<code>rest</code>中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</div><div class="line">    <span class="built_in">console</span>.log(rest);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// 结果:</span></div><div class="line"><span class="comment">// a = 1</span></div><div class="line"><span class="comment">// b = 2</span></div><div class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></div><div class="line"></div><div class="line">foo(<span class="number">1</span>);</div><div class="line"><span class="comment">// 结果:</span></div><div class="line"><span class="comment">// a = 1</span></div><div class="line"><span class="comment">// b = undefined</span></div><div class="line"><span class="comment">// Array []</span></div></pre></td></tr></table></figure></p>
<p><code>rest</code>参数只能写在最后，前面用<code>...</code>标识，从运行结果可知，传入的参数先绑定<code>a</code>、<code>b</code>，多余的参数以数组形式交给变量<code>rest</code>，所以，不再需要<code>arguments</code>我们就获取了全部参数。<br>如果传入的参数连正常定义的参数都没填满，也不要紧，<code>rest</code>参数会接收一个空数组（注意不是<code>undefined</code>）。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>
<ul>
<li>如果一个变量在函数体内部申明，则该变量的作用域为整个<strong>函数体</strong>(注意，var的作用域是函数体，不是语句块)，在函数体外不可引用该变量。</li>
<li>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量</li>
<li>如果内部函数和外部函数的变量名重名怎么办？JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>
</ul>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">    alert(x);</div><div class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>虽然是<code>strict</code>模式，但语句<code>var x = &#39;Hello, &#39; + y;</code>并不报错，原因是变量<code>y</code>在稍后申明了。但是<code>alert</code>显示<code>Hello, undefined</code>，说明变量<code>y</code>的值为<code>undefined</code>。这正是因为JavaScript引擎自动提升了变量<code>y</code>的声明，但不会提升变量<code>y</code>的赋值。</p>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。</p>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><p>不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突.减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">    i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">        sum += i;</div><div class="line">    &#125;</div><div class="line">    i += <span class="number">1</span>; <span class="comment">// SyntaxError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”.</p>
<p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>与<code>let</code>都具有块级作用域：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</div><div class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></div><div class="line">PI; <span class="comment">// 3.14</span></div></pre></td></tr></table></figure></p>
<p>注意，一定要加上<code>use strict</code>,否则会报错。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>绑定到对象上的函数称为方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></div><div class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure></p>
<p>和普通函数也没啥区别，但是它在内部使用了一个<code>this</code>关键字.<br>在一个方法内部，<code>this</code>是一个特殊变量，<strong>它始终指向当前对象</strong>，也就是<code>xiaoming</code>这个变量。所以，<code>this.birth</code>可以拿到<code>xiaoming</code>的<code>birth</code>属性。</p>
<p>让我们拆开写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></div><div class="line">getAge(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure></p>
<p>单独调用函数<code>getAge()</code>怎么返回了<code>NaN</code>？请注意，我们已经进入到了JavaScript的一个大坑里。<br>JavaScript的函数内部如果调用了<code>this</code>，那么这个<code>this</code>到底指向谁？<br>答案是，视情况而定！<br>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>，这是符合我们预期的。<br>如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向<strong>全局对象</strong>.</p>
<p>更坑爹的是，如果这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></div><div class="line">fn(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure></p>
<p>也是不行的！要保证<code>this</code>指向正确，必须要给出明确的上下文，必须用<code>obj.xxx()</code>的形式调用！谁调用，<code>this</code>就是指谁。上面仅仅相当于将<code>age</code>方法赋给<code>fn</code>.</p>
<p>如果是这种情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age();</div></pre></td></tr></table></figure></p>
<p>又不对了。原因是<code>this</code>指针只在<code>age</code>方法的函数内指向<code>xiaoming</code>，在函数内部定义的函数，<code>this</code>又指向<code>undefined</code>了！需要这样修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div></pre></td></tr></table></figure></p>
<p>用<code>var that = this</code>;将<code>age</code>中的<code>this</code>捕获，就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>我们还是可以控制<code>this</code>的指向的！</p>
<p>要指定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p>
<p>用<code>apply</code>修复<code>getAge()</code>调用:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p>
<p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><code>call()</code>把参数按顺序传入。 </li>
</ul>
<p>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新指向新的函数</strong>。</p>
<p>现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    count += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 测试:</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'20'</span>);</div><div class="line"><span class="built_in">parseInt</span>(<span class="string">'30'</span>);</div><div class="line">count; <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>一个可以接收另一个函数作为参的函数，称为高阶函数。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure></p>
<p><code>map()</code>将传入的函数一一作用在数组的每一个元素上。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>Array</code>的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>
<p>比如对<code>Array</code>求和：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;); <span class="comment">// 25</span></div></pre></td></tr></table></figure></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素<br><code>Array</code>的<code>filter()</code>接收一个函数,把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个<code>Array</code>中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line">r; <span class="comment">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>
<h4 id="sort-1"><a href="#sort-1" class="headerlink" title="sort"></a>sort</h4><p>可以接收一个比较函数来实现自定义的排序<br>要按数字大小排序，我们可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); <span class="comment">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：<code>sort()</code>方法会直接对<code>Array</code>进行修改，它返回的结果仍是当前<code>Array</code></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<p>比如返回一个求和的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> x + y;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></div></pre></td></tr></table></figure></p>
<p>调用函数f时，才真正计算求和的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(); <span class="comment">// 15</span></div></pre></td></tr></table></figure></p>
<p>当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”(但是JS中<code>this</code>不遵循闭包)</p>
<h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> i * i;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> results = count();</div><div class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</div></pre></td></tr></table></figure></p>
<p>上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了，<strong>或者说返回了三个闭包</strong>.<br>调用的结果全是<code>16</code>,因为返回函数都引用了变量<code>i</code>，由于闭包性，等到3个函数都返回时，它们所引用的变量i已经变成了<code>4</code>。</p>
<p><strong>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如何一定要引用循环变量？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> n * n;</div><div class="line">            &#125;</div><div class="line">        &#125;)(i));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> results = count();</div><div class="line"><span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> f3 = results[<span class="number">2</span>];</div><div class="line"></div><div class="line">f1(); <span class="comment">// 1</span></div><div class="line">f2(); <span class="comment">// 4</span></div><div class="line">f3(); <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p>注意这里用了一个“创建一个匿名函数并立刻执行”的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(function (x) &#123;</div><div class="line">    return x * x;</div><div class="line">&#125;)(3); // 9</div><div class="line">``` </div><div class="line"></div><div class="line">**实际上，上面的代码相当于在外层函数拿了一个变量`n`截取了`i`,由于外层函数是立刻执行了的匿名函数(即立刻执行了`var n = i;`)，那么`n`就固定了下来**：</div><div class="line">```javascript</div><div class="line">function count() &#123;</div><div class="line">    var arr = [];</div><div class="line">    for (var i=1; i&lt;=3; i++) &#123;</div><div class="line">        arr.push((function () &#123;</div><div class="line">            var n =i</div><div class="line">            return function () &#123;</div><div class="line">                return n*n;</div><div class="line">            &#125;</div><div class="line">        &#125;)());</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相反的，如果内存函数还是用的<code>i</code>，那么结果就会全是<code>16</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">        arr.push((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// var n =i</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> i*i;</div><div class="line">            &#125;</div><div class="line">        &#125;)());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x =&gt; x*x</div></pre></td></tr></table></figure></p>
<p>相当于一个输入为<code>x</code>输出为<code>x*x</code>的匿名函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function (x) &#123;</div><div class="line">    return x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果参数不是一个，就需要用括号()括起来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个参数:</span></div><div class="line">(x, y) =&gt; x * x + y * y</div><div class="line"></div><div class="line"><span class="comment">// 无参数:</span></div><div class="line">() =&gt; <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="comment">// 可变参数:</span></div><div class="line">(x, y, ...rest) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> i, sum = x + y;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</div><div class="line">        sum += rest[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>语法糖，类似于python中的lambda函数</p>
<p>当然，箭头函数还是有点用处的，由于是es6的新特性，箭头函数内部的this是词法作用域，由上下文确定。<br>试做比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果</div><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = function () &#123;</div><div class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</div><div class="line">        &#125;;</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</div><div class="line">var obj = &#123;</div><div class="line">    birth: 1990,</div><div class="line">    getAge: function () &#123;</div><div class="line">        var b = this.birth; // 1990</div><div class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</div><div class="line">        return fn();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.getAge(); // 25</div></pre></td></tr></table></figure></p>
<p>如果使用箭头函数,以前<code>var that = this;</code>这种写法就不需要了。</p>
<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>generator（生成器）是ES6标准引入的新的数据类型，类似于Python的generator的概念和语法。一个generator看上去像一个函数，但可以返回多次。</p>
<p>定义如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> x + <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且，除了<code>return</code>语句，还可以用<code>yield</code>返回多次。好处就是<strong>函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。</strong>(其实这东西很像调试函数时候的断点！)</p>
<p>执行generator和调用函数不一样，调用generator对象有两个方法，一是不断地调用generator对象的<code>next()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = fib(<span class="number">5</span>);</div><div class="line">f.next(); <span class="comment">// &#123;value: 0, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">f.next(); <span class="comment">// &#123;value: 1, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>next()</code>方法会执行generator的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个generator是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</p>
<p>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> fib(<span class="number">5</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 依次输出0, 1, 1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<strong>看起来蛮有用的</strong></p>
<p>举个例子，要生成一个自增的ID，可以编写一个next_id()函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> current_id = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next_id</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    current_id ++;</div><div class="line">    <span class="keyword">return</span> current_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于函数无法保存状态，故需要一个全局变量<code>current_id</code>来保存数字。现在改用generator：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">next_id</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</div><div class="line">    	<span class="keyword">yield</span> ++i;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><p>一些原则：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
</ul>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></div><div class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></div><div class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></div><div class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></div><div class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></div><div class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></div><div class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></div><div class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>
<p>如果要创建一个指定日期和时间的Date对象，可以用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</div><div class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>
<p>一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是<code>0~11</code>，<code>0</code>表示一月，<code>1</code>表示二月……，所以要表示<code>6</code>月，我们传入的是<code>5</code>！</p>
<p>第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>);</div><div class="line">d; <span class="comment">// 1435146562875</span></div></pre></td></tr></table></figure></p>
<p>但它返回的不是<code>Date</code>对象，而是一个<strong>时间戳</strong>。不过有时间戳就可以很容易地把它转换为一个<code>Date</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</div><div class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div></pre></td></tr></table></figure></p>
<p>时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。</p>
<p>要获取当前时间戳，可以用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">Date</span>.now) &#123;</div><div class="line">    alert(<span class="built_in">Date</span>.now()); <span class="comment">// 老版本IE没有now()方法</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>JSON（JavaScript Object Notation）实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p>
<ul>
<li>number：和JavaScript的<code>number</code>完全一致；</li>
<li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li>
<li>string：就是JavaScript的<code>string</code>；</li>
<li>null：就是JavaScript的<code>null</code>；</li>
<li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li>
<li>object：就是JavaScript的<code>{ ... }</code>表示方式。</li>
</ul>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>先把小明这个对象序列化成JSON格式的字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    age: <span class="number">14</span>,</div><div class="line">    gender: <span class="literal">true</span>,</div><div class="line">    height: <span class="number">1.65</span>,</div><div class="line">    grade: <span class="literal">null</span>,</div><div class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</div><div class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// '&#123;"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]&#125;'</span></div></pre></td></tr></table></figure></p>
<p>要输出得好看一些，可以加上参数，按缩进输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">'  '</span>);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"小明"</span>,</div><div class="line">  <span class="string">"age"</span>: <span class="number">14</span>,</div><div class="line">  <span class="string">"gender"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"height"</span>: <span class="number">1.65</span>,</div><div class="line">  <span class="string">"grade"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"middle-school"</span>: <span class="string">"\"W3C\" Middle School"</span>,</div><div class="line">  <span class="string">"skills"</span>: [</div><div class="line">    <span class="string">"JavaScript"</span>,</div><div class="line">    <span class="string">"Java"</span>,</div><div class="line">    <span class="string">"Python"</span>,</div><div class="line">    <span class="string">"Lisp"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div></pre></td></tr></table></figure></p>
<p>结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"小明"</span>,</div><div class="line">  <span class="string">"skills"</span>: [</div><div class="line">    <span class="string">"JavaScript"</span>,</div><div class="line">    <span class="string">"Java"</span>,</div><div class="line">    <span class="string">"Python"</span>,</div><div class="line">    <span class="string">"Lisp"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value.toUpperCase();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</div></pre></td></tr></table></figure></p>
<p>上面的代码把所有属性值都变成大写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"小明"</span>,</div><div class="line">  <span class="string">"age"</span>: <span class="number">14</span>,</div><div class="line">  <span class="string">"gender"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"height"</span>: <span class="number">1.65</span>,</div><div class="line">  <span class="string">"grade"</span>: <span class="literal">null</span>,</div><div class="line">  <span class="string">"middle-school"</span>: <span class="string">"\"W3C\" MIDDLE SCHOOL"</span>,</div><div class="line">  <span class="string">"skills"</span>: [</div><div class="line">    <span class="string">"JAVASCRIPT"</span>,</div><div class="line">    <span class="string">"JAVA"</span>,</div><div class="line">    <span class="string">"PYTHON"</span>,</div><div class="line">    <span class="string">"LISP"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们还想要精确控制如何序列化小明，可以给<code>xiaoming</code>定义一个<code>toJSON()</code>的方法，直接返回JSON应该序列化的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    age: <span class="number">14</span>,</div><div class="line">    gender: <span class="literal">true</span>,</div><div class="line">    height: <span class="number">1.65</span>,</div><div class="line">    grade: <span class="literal">null</span>,</div><div class="line">    <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</div><div class="line">    skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>],</div><div class="line">    toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123; <span class="comment">// 只输出name和age，并且改变了key：</span></div><div class="line">            <span class="string">'Name'</span>: <span class="keyword">this</span>.name,</div><div class="line">            <span class="string">'Age'</span>: <span class="keyword">this</span>.age</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// '&#123;"Name":"小明","Age":14&#125;'</span></div></pre></td></tr></table></figure></p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></div></pre></td></tr></table></figure></p>
<p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="comment">// 把number * 2:</span></div><div class="line">    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;); <span class="comment">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>
<p>prototype有点类似于继承，<code>A</code>的原型是<code>B</code>，意味着，<code>A</code>拥有<code>B</code>的全部属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型对象:</span></div><div class="line"><span class="keyword">var</span> Student = &#123;</div><div class="line">    name: <span class="string">'Robot'</span>,</div><div class="line">    height: <span class="number">1.2</span>,</div><div class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">    <span class="comment">// 初始化新对象:</span></div><div class="line">    s.name = name;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'小明'</span>);</div><div class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p>
<p>例如，创建一个<code>Array</code>对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>其原型链是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。</p>
<p>当我们创建一个函数时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数也是一个对象，它的原型链是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在JavaScript中，可以用关键字<code>new</code>来调用这个函数，并返回一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">xiaoming.hello(); <span class="comment">// Hello, 小明!</span></div></pre></td></tr></table></figure></p>
<p>注意，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。</p>
<p>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xiaoming.constructor === Student.prototype.constructor; <span class="comment">// true</span></div><div class="line">Student.prototype.constructor === Student; <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(xiaoming) === Student.prototype; <span class="comment">// true</span></div><div class="line"></div><div class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>他们之间的关系就是:<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor.png?raw=true" alt="constructor"></p>
<p>红色箭头是原型链。注意，<code>Student.prototype</code>指向的对象就是<code>xiaoming</code>、<code>xiaohong</code>的原型对象，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。</p>
<p>另外，函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。</p>
<p>不过还有一个小问题，注意观察：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">xiaohong.name; <span class="comment">// '小红'</span></div><div class="line">xiaoming.hello; <span class="comment">// function: Student.hello()</span></div><div class="line">xiaohong.hello; <span class="comment">// function: Student.hello()</span></div><div class="line">xiaoming.hello === xiaohong.hello; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p><code>xiaoming</code>和<code>xiaohong</code>各自的<code>hello</code>是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！</p>
<p>如果我们通过<code>new Student()</code>创建了很多对象，这些对象的<code>hello</code>函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。<br>要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/js_constructor2.png?raw=true" alt="constructor2"><br>修改代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h3><p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>
<p>我们先回顾用函数实现<code>Student</code>的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Student(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype.hello = function () &#123;</div><div class="line">    alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果用新的<code>class</code>关键字来编写<code>Student</code>，可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hello() &#123;</div><div class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比较一下就可以发现，<code>class</code>的定义包含了<strong>构造函数</strong><code>constructor</code>和定义在原型对象上的函数<code>hello()</code>（注意没有<code>function</code>关键字），这样就避免了<code>Student.prototype.hello = function () {...}</code>这样分散的代码。</p>
<p>最后，创建一个Student对象代码和前面章节完全一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">xiaoming.hello();</div></pre></td></tr></table></figure></p>
<h4 id="class继承-1"><a href="#class继承-1" class="headerlink" title="class继承"></a>class继承</h4><p>用<code>class</code>定义对象的另一个巨大的好处是继承更方便了,直接通过<code>extends</code>来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">        <span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    myGrade() &#123;</div><div class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过<code>super(name)</code>来调用父类的构造函数。<code>PrimaryStudent</code>已经自动获得了父类<code>Student</code>的<code>hello</code>方法，我们又在子类中定义了新的<code>myGrade</code>方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSLayoutConstraint 学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/09/08/NSLayoutConstraint/</url>
      <content type="html"><![CDATA[<p><code>AutoLayout</code>是一种基于约束的，描述性的布局系统。参考了网上的许多文章，进行总结。基本还是以ios6为主，ios8的一些特性并没有仔细研究。以后需要用到再说。<br>参考与<a href="http://www.jianshu.com/p/79f92139ffdf" target="_blank" rel="external">AutoLayout详解</a></p>
<a id="more"></a>
<h2 id="代码添加AutoLayout"><a href="#代码添加AutoLayout" class="headerlink" title="代码添加AutoLayout"></a>代码添加AutoLayout</h2><h3 id="关闭Autoresizing"><a href="#关闭Autoresizing" class="headerlink" title="关闭Autoresizing"></a>关闭Autoresizing</h3><p><code>AutoLayout</code>旨在替代<code>Autoresizing</code>，所以在同一个项目中，<code>AutoLayout</code>和<code>Autoresizing</code>是不能共存的。要实现自动布局，必须关掉view的<code>AutoresizeingMask</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<p>这里的view指的是需要添加约束的view。</p>
<h3 id="NSLayoutConstraint相关"><a href="#NSLayoutConstraint相关" class="headerlink" title="NSLayoutConstraint相关"></a>NSLayoutConstraint相关</h3><h4 id="约束方法"><a href="#约束方法" class="headerlink" title="约束方法"></a>约束方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">instancetype</span>)constraintWithItem:(<span class="keyword">id</span>)view1                  <span class="comment">//被约束的视图一</span></div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1   <span class="comment">//view1的属性</span></div><div class="line">                        relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation <span class="comment">//左右视图的关系</span></div><div class="line">                           toItem:(<span class="keyword">id</span>)view2                  <span class="comment">//被约束的视图二</span></div><div class="line">                        attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2   <span class="comment">//view2的属性</span></div><div class="line">                       multiplier:(<span class="built_in">CGFloat</span>)multiplier        <span class="comment">//乘数</span></div><div class="line">                         constant:(<span class="built_in">CGFloat</span>)c;                <span class="comment">//常量</span></div></pre></td></tr></table></figure>
<p>公式是这样的：<code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>
<h4 id="NSLayoutAttribute属性"><a href="#NSLayoutAttribute属性" class="headerlink" title="NSLayoutAttribute属性"></a>NSLayoutAttribute属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutAttribute</span>) &#123;</div><div class="line">    <span class="built_in">NSLayoutAttributeLeft</span> = <span class="number">1</span>, <span class="comment">//左边</span></div><div class="line">    <span class="built_in">NSLayoutAttributeRight</span>,    <span class="comment">//右边</span></div><div class="line">    <span class="built_in">NSLayoutAttributeTop</span>,      <span class="comment">//顶部</span></div><div class="line">    <span class="built_in">NSLayoutAttributeBottom</span>,   <span class="comment">//底部</span></div><div class="line">    <span class="built_in">NSLayoutAttributeLeading</span>,  <span class="comment">//首部</span></div><div class="line">    <span class="built_in">NSLayoutAttributeTrailing</span>, <span class="comment">//尾部</span></div><div class="line">    <span class="built_in">NSLayoutAttributeWidth</span>,    <span class="comment">//宽度</span></div><div class="line">    <span class="built_in">NSLayoutAttributeHeight</span>,   <span class="comment">//高度</span></div><div class="line">    <span class="built_in">NSLayoutAttributeCenterX</span>,  <span class="comment">//X轴中心</span></div><div class="line">    <span class="built_in">NSLayoutAttributeCenterY</span>,  <span class="comment">//Y轴中心</span></div><div class="line">    <span class="built_in">NSLayoutAttributeBaseline</span>, <span class="comment">//基线</span></div><div class="line">    <span class="built_in">NSLayoutAttributeLastBaseline</span> = <span class="built_in">NSLayoutAttributeBaseline</span>,</div><div class="line">    <span class="built_in">NSLayoutAttributeFirstBaseline</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"></div><div class="line">    <span class="comment">//iOS8的暂时没有研究</span></div><div class="line">    <span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">    <span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line"></div><div class="line">    <span class="built_in">NSLayoutAttributeNotAnAttribute</span> = <span class="number">0</span> <span class="comment">//无属性</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="NSLayoutRelation关系"><a href="#NSLayoutRelation关系" class="headerlink" title="NSLayoutRelation关系"></a>NSLayoutRelation关系</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutRelation</span>) &#123;</div><div class="line">    <span class="built_in">NSLayoutRelationLessThanOrEqual</span> = <span class="number">-1</span>,   <span class="comment">//小于等于</span></div><div class="line">    <span class="built_in">NSLayoutRelationEqual</span> = <span class="number">0</span>,              <span class="comment">//等于</span></div><div class="line">    <span class="built_in">NSLayoutRelationGreaterThanOrEqual</span> = <span class="number">1</span>, <span class="comment">//大于等于</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="创建view"><a href="#创建view" class="headerlink" title="创建view"></a>创建view</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建view</span></div><div class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init]; <span class="comment">//这里不需要设置frame</span></div><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">view.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>; <span class="comment">//要实现自动布局，必须把该属性设置为NO</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:view];</div><div class="line"></div><div class="line"><span class="comment">//添加约束</span></div><div class="line">[<span class="keyword">self</span>.view addConstraint:</div><div class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                 toItem:<span class="keyword">self</span>.view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeLeft</span></div><div class="line">                             multiplier:<span class="number">1</span></div><div class="line">                               constant:<span class="number">20</span>]];</div><div class="line">[<span class="keyword">self</span>.view addConstraint:</div><div class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeRight</span></div><div class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                 toItem:<span class="keyword">self</span>.view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeRight</span></div><div class="line">                             multiplier:<span class="number">1</span></div><div class="line">                               constant:<span class="number">-10</span>]];</div><div class="line">[<span class="keyword">self</span>.view addConstraint:</div><div class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                 toItem:<span class="keyword">self</span>.view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeTop</span></div><div class="line">                             multiplier:<span class="number">1</span></div><div class="line">                               constant:<span class="number">30</span>]];</div><div class="line">[<span class="keyword">self</span>.view addConstraint:</div><div class="line"> [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                              relatedBy:<span class="built_in">NSLayoutRelationEqual</span></div><div class="line">                                 toItem:<span class="keyword">self</span>.view</div><div class="line">                              attribute:<span class="built_in">NSLayoutAttributeBottom</span></div><div class="line">                             multiplier:<span class="number">1</span></div><div class="line">                               constant:<span class="number">-20</span>]];</div></pre></td></tr></table></figure>
<h3 id="添加约束的规则"><a href="#添加约束的规则" class="headerlink" title="添加约束的规则"></a>添加约束的规则</h3><ul>
<li>对于两个同层级view之间的约束关系，添加到它们的父view上</li>
<li>对于两个不同层级view之间的约束关系，添加到他们最近的共同父view上</li>
<li>对于有层次关系的两个view之间的约束关系，添加到层次较高的父view上</li>
</ul>
<h3 id="Autolayout来实现动画功能"><a href="#Autolayout来实现动画功能" class="headerlink" title="Autolayout来实现动画功能"></a>Autolayout来实现动画功能</h3><p>在执行动画时记得调用一下方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在修改了约束之后，只要执行下面代码，就能做动画效果</span></div><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</div><div class="line">      [<span class="keyword">self</span>.view layoutIfNeeded];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h2 id="第三方框架实现AutoLayout"><a href="#第三方框架实现AutoLayout" class="headerlink" title="第三方框架实现AutoLayout"></a>第三方框架实现AutoLayout</h2><p>Masonry框架是目前最流行的Autolayout第三方框架，用优雅的代码方式编写Autolayout，省去了苹果官方恶心的Autolayout代码，大大提高了开发效率。</p>
<h3 id="框架导入"><a href="#框架导入" class="headerlink" title="框架导入"></a>框架导入</h3><p>这里先介绍下ios的包管理工具cocoaPods，如何下载安装就不说了，介绍下如何使用。</p>
<h4 id="创建Podfile"><a href="#创建Podfile" class="headerlink" title="创建Podfile"></a>创建Podfile</h4><p>在工程的目录下新建Podfile文件，写入我们需要的第三方库：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">target 'NSLayoutConstraintDemo' do</div><div class="line">pod 'Masonry'</div><div class="line">end</div></pre></td></tr></table></figure></p>
<h4 id="导入第三方库"><a href="#导入第三方库" class="headerlink" title="导入第三方库"></a>导入第三方库</h4><p>进入终端，运行命令<code>pod install</code>,导入第三方库。</p>
<h3 id="Masonry基本使用"><a href="#Masonry基本使用" class="headerlink" title="Masonry基本使用"></a>Masonry基本使用</h3><p>最基本的使用方式：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.属性.equalTo(另一个view).with.insets(差值);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="Masonry属性"><a href="#Masonry属性" class="headerlink" title="Masonry属性"></a>Masonry属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline;</div></pre></td></tr></table></figure>
<p>其中leading与left trailing与right 在正常情况下是等价的。</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>居中显示一个view：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从此以后基本可以抛弃CGRectMake了</span></div><div class="line"><span class="built_in">UIView</span> *sv = [<span class="built_in">UIView</span> new];</div><div class="line"></div><div class="line"><span class="comment">//在做autoLayout之前 一定要先将view添加到superview上 否则会报错</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:sv];</div><div class="line"></div><div class="line"><span class="comment">//mas_makeConstraints就是Masonry的autolayout添加函数 将所需的约束添加到block中行了</span></div><div class="line">[sv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line"></div><div class="line">    <span class="comment">//将sv居中(很容易理解吧?)</span></div><div class="line">    make.center.equalTo(<span class="keyword">self</span>.view);</div><div class="line">    </div><div class="line">    <span class="comment">//将size设置成(300,300)</span></div><div class="line">    make.size.mas_equalTo(<span class="built_in">CGSizeMake</span>(<span class="number">300</span>, <span class="number">300</span>));</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="方法简析"><a href="#方法简析" class="headerlink" title="方法简析"></a>方法简析</h3><h4 id="添加autolayout约束"><a href="#添加autolayout约束" class="headerlink" title="添加autolayout约束"></a>添加autolayout约束</h4><p>有三个可以添加约束的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</div><div class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</div><div class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">    mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 </div><div class="line">    mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况</div><div class="line">    mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束</div><div class="line">    </div><div class="line">    三种函数善加利用 就可以应对各种情况了</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h4 id="equalTo-和-mas-equalTo的区别"><a href="#equalTo-和-mas-equalTo的区别" class="headerlink" title="equalTo 和 mas_equalTo的区别"></a>equalTo 和 mas_equalTo的区别</h4><p><code>mas_equalTo</code>只是对其参数进行了一个BOX操作(装箱)。所支持的类型 除了<code>NSNumber</code>支持的那些数值类型之外 就只支持<code>CGPoint</code> <code>CGSize</code> <code>UIEdgeInsets</code></p>
<h3 id="另一个示例"><a href="#另一个示例" class="headerlink" title="另一个示例"></a>另一个示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *sv1 = [<span class="built_in">UIView</span> new];</div><div class="line">[sv1 showPlaceHolder];</div><div class="line">sv1.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">[sv addSubview:sv1];</div><div class="line">[sv1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.edges.equalTo(sv).with.insets(<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</div><div class="line">    </div><div class="line">    <span class="comment">/* 等价于</span></div><div class="line">    make.top.equalTo(sv).with.offset(10);</div><div class="line">    make.left.equalTo(sv).with.offset(10);</div><div class="line">    make.bottom.equalTo(sv).with.offset(-10);</div><div class="line">    make.right.equalTo(sv).with.offset(-10);</div><div class="line">    */</div><div class="line">    </div><div class="line">    <span class="comment">/* 也等价于</span></div><div class="line">    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));</div><div class="line">    */</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>可以看到 edges 其实就是top,left,bottom,right的一个简化 分开写也可以 一句话更省事.</p>
<p>这里and和with 两个函数什么事情都没做.</p>
<h3 id="还有一个示例"><a href="#还有一个示例" class="headerlink" title="还有一个示例"></a>还有一个示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *lastView = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= count ; ++i )&#123;</div><div class="line">    <span class="built_in">UIView</span> *subv = [<span class="built_in">UIView</span> new];</div><div class="line">    [container addSubview:subv];</div><div class="line">    subv.backgroundColor = [<span class="built_in">UIColor</span> colorWithHue:( arc4random() % <span class="number">256</span> / <span class="number">256.0</span> )</div><div class="line">                                      saturation:( arc4random() % <span class="number">128</span> / <span class="number">256.0</span> ) + <span class="number">0.5</span></div><div class="line">                                      brightness:( arc4random() % <span class="number">128</span> / <span class="number">256.0</span> ) + <span class="number">0.5</span></div><div class="line">                                           alpha:<span class="number">1</span>];</div><div class="line">        </div><div class="line">    [subv mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.and.right.equalTo(container);</div><div class="line">        make.height.mas_equalTo(@(<span class="number">20</span>*i));</div><div class="line">           </div><div class="line">        <span class="keyword">if</span> ( lastView )&#123;</div><div class="line">            make.top.mas_equalTo(lastView.mas_bottom);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            make.top.mas_equalTo(container.mas_top);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">       </div><div class="line">    lastView = subv;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">    </div><div class="line">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.bottom.equalTo(lastView.mas_bottom);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>框架通过范畴为UIView添加了<code>mas_bottom</code>、<code>mas_top</code>等属性，用来表示view的上下左右的位置。这样，有利于<strong>在view之间的约束条件的建立</strong>，之前的示例都是view与父view的约束关系。</p>
<p>还有一些其他的示例，可以参见<a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践</a></p>
<blockquote>
<p>Demo 详见NSLayoutConstraintDemo</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移位与枚举]]></title>
      <url>http://zhang759740844.github.io/2016/09/07/oc%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>oc中的枚举使用enum，iOS本身定义的枚举里面经常会使用左移（&lt;&lt;）来定义枚举的值，其原因是什么呢？</p>
<a id="more"></a>
<h2 id="enum的基本用法使用"><a href="#enum的基本用法使用" class="headerlink" title="enum的基本用法使用"></a>enum的基本用法使用</h2><p>定义一组常量。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">	BlenderSpeedStir=<span class="number">1</span>，</div><div class="line">	BlenderSpeedChop=<span class="number">1</span>&lt;&lt;<span class="number">1</span>，</div><div class="line">&#125; BlenderSpeed；</div></pre></td></tr></table></figure></p>
<p>还可以写成这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, BlenderSpeed) &#123;</div><div class="line"><span class="comment">//以下是枚举成员</span></div><div class="line">    Test1A = <span class="number">1</span>,</div><div class="line">    Test1B = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    Test1C = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    Test1D = <span class="number">1</span>&lt;&lt;<span class="number">3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BlenderSpeed speed = Test1A；</div></pre></td></tr></table></figure></p>
<p>使用<code>BlenderSpeed</code>代替<code>NSInteger</code>。</p>
<h2 id="移位定义enum"><a href="#移位定义enum" class="headerlink" title="移位定义enum"></a>移位定义enum</h2><h3 id="使用移位定义enum的好处"><a href="#使用移位定义enum的好处" class="headerlink" title="使用移位定义enum的好处"></a>使用移位定义enum的好处</h3><p>enum一般的枚举数值都用移位表示，一般和数字没有太大差别。不过，比起使用数字的一个显著的好处就是：<strong>用移位来定义枚举能把1的位置错开，可以使用<code>按位或</code>将几个枚举值表示成一个数，而不会互相影响</strong>。如果用数字就要使用一个数组。</p>
<p>比如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> delay:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span> |<span class="built_in">UIViewAnimationOptionRepeat</span> animations:^&#123;</div><div class="line">	<span class="literal">nil</span></div><div class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">	<span class="literal">nil</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>其中<code>options</code>只能传入一个数值，使用数字就不能传入多个枚举值，但是当enum使用了移位，那么久可以传入<code>UIViewAnimationOptionTransitionFlipFromRight |UIViewAnimationOptionRepeat</code>表示既<code>FlipFromRight</code>又<code>repeat</code>。</p>
<h3 id="取出enum值"><a href="#取出enum值" class="headerlink" title="取出enum值"></a>取出enum值</h3><p>将几个枚举值放入一个数中，方法处理的时候总的取出来吧。那么怎么取呢？先来看一下<code>按位与&amp;</code>操作符的特性：</p>
<blockquote>
<p>数b与已知数a进行按位与操作。a中为0的位，结果必为0，a中为1的位，结果为b中相应的位。<br>所以，若要判断某一个数中的某一位是否为1，只要将这个数与一个该位为1其余位为0的数进行按位与，结果不为0表示该位为1，反之为0。</p>
</blockquote>
<p>因此，我们可以这样取出枚举值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    a = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    b = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    c = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    d = <span class="number">1</span> &lt;&lt; <span class="number">3</span></div><div class="line">&#125;testEnum;</div><div class="line"></div><div class="line">testEnum e = a | b;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (e &amp; a) &#123;</div><div class="line">    printf(<span class="string">"满足条件a"</span>);</div><div class="line">    <span class="comment">//满足a要做的事</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (e &amp; b) &#123;</div><div class="line">    printf(<span class="string">"满足条件b"</span>);</div><div class="line">    <span class="comment">//满足b要做的事</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (e &amp; c) &#123;</div><div class="line">    printf(<span class="string">"满足条件c"</span>);</div><div class="line">    <span class="comment">//满足c要做的事</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将数值与各个枚举值按位与，非零即包含该枚举值。</p>
<p>也可以通过一个for循环，再通过switch-case处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AnimationType) &#123;</div><div class="line">    <span class="comment">//以下是枚举成员</span></div><div class="line">    BaseAnimation = <span class="number">1</span>,</div><div class="line">    KeyFrameAnimation_Value = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    KeyFrameAnimation_Path = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    KeyFrameAnimation_shake = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</div><div class="line">    Transition = <span class="number">1</span>&lt;&lt;<span class="number">4</span>,</div><div class="line">    AnimationGroup = <span class="number">1</span>&lt;&lt;<span class="number">5</span>,</div><div class="line">    ViewAnimation = <span class="number">1</span>&lt;&lt;<span class="number">6</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)initAnimationWithType:(<span class="built_in">NSInteger</span>)type&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> animationType = <span class="number">1</span>; animationType&lt;(ViewAnimation&lt;&lt;<span class="number">1</span>); animationType = animationType&lt;&lt;<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (type &amp; animationType) &#123;</div><div class="line">            [<span class="keyword">self</span> startAnimationInitialWithType:animationType];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startAnimationInitialWithType:(<span class="built_in">NSInteger</span>)type&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> BaseAnimation:&#123;</div><div class="line">            <span class="built_in">CALayer</span> *myLayer=[<span class="built_in">CALayer</span> layer];</div><div class="line">            myLayer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">80</span>);</div><div class="line">            myLayer.backgroundColor=[<span class="built_in">UIColor</span> yellowColor].CGColor;</div><div class="line">            myLayer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">50</span>);</div><div class="line">            myLayer.anchorPoint=<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            myLayer.cornerRadius=<span class="number">20</span>;</div><div class="line">            <span class="comment">//添加layer</span></div><div class="line">            [<span class="keyword">self</span>.view.layer addSublayer:myLayer];</div><div class="line">            <span class="keyword">self</span>.myLayer=myLayer;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> Transition:</div><div class="line">            _index = <span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>需要注意的是</strong>：<code>case</code>中如果声明了变量，必须要用<code>{}</code>包住，这是编译器强制的，不然会报错，应该是为了避免<a href="http://blog.csdn.net/fanjunxi1990/article/details/9162945" target="_blank" rel="external">switch case语句里面不能定义对象，有语法错误，除非加一个花括号</a>这个问题。</p>
<h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>上面是使用了2进制来错开，保留每个位，其实其他进制也可以,但位数是2的n次方。<br>比如0000 0000 8个位，可以前4个位存储一个值，后4个位存储一个值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    a = <span class="number">0</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    b = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    c = <span class="number">2</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    d = <span class="number">3</span> &lt;&lt; <span class="number">0</span>,</div><div class="line"></div><div class="line">    e = <span class="number">0</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    f = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    g = <span class="number">2</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    h = <span class="number">3</span> &lt;&lt; <span class="number">4</span></div><div class="line">&#125;testEnum;</div></pre></td></tr></table></figure></p>
<p>a b c d的前4为都是0，值的变化在后4位，而e f g h正好相反。a,b,c,d之间无法通过按位与区分，但是a,b,c,d可以和e,f,g,h区分。这样，整个枚举值被分成了两组。如何判断值是哪个组的枚举值呢？很简单，和<code>00001111</code>按位与，后四位中有一个数为1，那么整个按位与的值就不为0。同理，与<code>11110000</code>按位与得到另外一组。</p>
<blockquote>
<p>Demo详见CALayer_Transform</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIGestureRecognizer]]></title>
      <url>http://zhang759740844.github.io/2016/09/05/UIGestureRecognizer/</url>
      <content type="html"><![CDATA[<p>在iOS系统中，手势是进行用户交互的重要方式，通过<code>UIGestureRecognizer</code>类，我们可以轻松的创建出各种手势应用于app中。关于<code>UIGestureRecognizer</code>类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的讨论，在上一篇中已经讨论过了。</p>
<a id="more"></a>
<h2 id="手势的抽象类——UIGestureRecognizer"><a href="#手势的抽象类——UIGestureRecognizer" class="headerlink" title="手势的抽象类——UIGestureRecognizer"></a>手势的抽象类——UIGestureRecognizer</h2><p><code>UIGestureRecognizer</code>将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用<code>UIGestureRecognizer</code>的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，<code>UIGestureRecognizer</code>中抽象出了哪些方法。</p>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><p><code>UIGestureRecognizer</code>类为其子类准备好了一个统一的初始化方法，可以使用下面的方法进行统一的初始化：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">nullable</span> <span class="keyword">id</span>)target action:(<span class="keyword">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>
<p>如果我们使用<code>alloc-init</code>的方式，也是可以的，下面的方法可以为手势添加触发的<code>selector</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addTarget:(<span class="keyword">id</span>)target action:(SEL)action;</div></pre></td></tr></table></figure></p>
<p>与之相对应的，我们也可以将一个<code>selector</code>从其手势对象上移除：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeTarget:(<span class="keyword">nullable</span> <span class="keyword">id</span>)target action:(<span class="keyword">nullable</span> SEL)action;</div></pre></td></tr></table></figure></p>
<p>这里的<code>target</code>一般都是<code>self</code>,因为<code>selector</code>一般都是在<code>self</code>中定义。</p>
<p>因为<code>addTarget</code>方式的存在，iOS系统允许一个手势对象可以添加多个<code>selector</code>触发方法，并且触发的时候，所有添加的<code>selector</code>都会被执行，我们以点击手势示例如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">     <span class="built_in">UITapGestureRecognizer</span> * ges = [[<span class="built_in">UITapGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(click:)];</div><div class="line">    [ges addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(haha)];</div><div class="line">     [<span class="keyword">self</span>.view addGestureRecognizer:ges];</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)click:(<span class="built_in">UIGestureRecognizer</span> *)ges&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个手势的触发方法"</span>);</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)haha&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"haha"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>点击屏幕后，两个方法都会触发。</p>
<h3 id="手势状态"><a href="#手势状态" class="headerlink" title="手势状态"></a>手势状态</h3><p>UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIGestureRecognizerState</span> state;</div></pre></td></tr></table></figure></p>
<p>枚举值如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</div><div class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,   <span class="comment">// 默认的状态，这个时候的手势并没有具体的情形状态</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,      <span class="comment">// 手势开始被识别的状态</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,    <span class="comment">// 手势识别发生改变的状态</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,      <span class="comment">// 手势识别结束，将会执行触发的方法</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>,  <span class="comment">// 手势识别取消</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,     <span class="comment">// 识别失败，方法将不会被调用</span></div><div class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以在手势的处理方法中，判断手势的状态，区分不同的处理方式。</p>
<h3 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置代理，具体的协议后面会说</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIGestureRecognizerDelegate</span>&gt; delegate; </div><div class="line"><span class="comment">//设置手势是否有效</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</div><div class="line"><span class="comment">//获取手势所在的view</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIView</span> *view; </div><div class="line"><span class="comment">//获取触发触摸的点</span></div><div class="line">- (<span class="built_in">CGPoint</span>)locationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span>*)view; </div><div class="line"><span class="comment">//设置触摸点数</span></div><div class="line">- (<span class="built_in">NSUInteger</span>)numberOfTouches; </div><div class="line"><span class="comment">//获取某一个触摸点的触摸位置</span></div><div class="line">- (<span class="built_in">CGPoint</span>)locationOfTouch:(<span class="built_in">NSUInteger</span>)touchIndex inView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span>*)view;</div></pre></td></tr></table></figure>
<p>其中，<code>UITouch</code>也有一个方法是<code>locationInView:</code>可以获取触摸点在view中的位置。<br>可以通过设置<code>numberOfTapsRequired</code>来区分单击双击：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITapGestureRecognizer</span> *doubleTap = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(DoubleTap:)];</div><div class="line">doubleTap.numberOfTapsRequired = <span class="number">2</span>; <span class="comment">//点击的次数 ＝2 双击</span></div><div class="line">[_imageView addGestureRecognizer:doubleTap];<span class="comment">//给对象添加一个手势监测；</span></div></pre></td></tr></table></figure></p>
<p>另外还有三个属性用来控制触摸事件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cancelsTouchesInView;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> delaysTouchesBegan;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> delaysTouchesEnded;</div></pre></td></tr></table></figure></p>
<p><strong>cancelsTouchesInView</strong><br>默认为YES,这种情况下当手势识别器识别到touch之后，会发送<code>touchesCancelled:withEvent:</code>消息,终止触摸事件的传递,以取消 <code>UIResponder</code>对touch的响应，这个时候只有手势识别器响应touch。<br>当设置成NO时，手势识别器识别到touch之后不会发送<code>touchesCancelled:withEvent:</code>消息，这个时候手势识别器和<code>UIResponder</code>均响应touch。<br><strong>注意：</strong>发送<code>touchesCancelled:withEvent:</code>消息也是需要时间的。在每次手势操作的时候都会先触发1-2次touch操作，然后<code>touchesCancelled:withEvent:</code>消息才会生效，屏蔽touch操作。</p>
<p><strong>delaysTouchesBegan</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给<code>UIResponder</code>，两者各自做出响应。<br>如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给<code>UIResponder</code>，即<code>UIResponder</code>不会有任何触摸事件。只有在识别失败之后才会将touch发给<code>UIResponder</code>，这种情况下<code>UIResponder</code>的响应会延迟约0.15ms。</p>
<p><strong>delaysTouchesEnded</strong><br>在前面<code>cancelsTouchesInView</code>属性为NO的基础上.<br>默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给<code>touchesCancelled:withEvent:</code>消息给<code>UIResponder</code>，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送<code>touchesEnded:withEvent:</code>。<br>如果设置为NO，则不会延迟，即会立即发送<code>touchesEnded:withEvent:</code>以结束当前触摸。</p>
<h3 id="手势间的互斥"><a href="#手势间的互斥" class="headerlink" title="手势间的互斥"></a>手势间的互斥</h3><p>有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">     <span class="built_in">UITapGestureRecognizer</span> * ges = [[<span class="built_in">UITapGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(click:)];;</div><div class="line">    </div><div class="line">    <span class="comment">//view.backgroundColor = [UIColor redColor];</span></div><div class="line">   </div><div class="line">    <span class="comment">//ges.delegate=self;</span></div><div class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:ges];</div><div class="line">    </div><div class="line">    <span class="built_in">UITapGestureRecognizer</span> * ges2 = [[<span class="built_in">UITapGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(click1:)];</div><div class="line"><span class="comment">//    ges2.delegate=self;</span></div><div class="line">        [<span class="keyword">self</span>.view addGestureRecognizer:ges2];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)click:(<span class="built_in">UIGestureRecognizer</span> *)ges&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个手势的触发方法"</span>);</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)click1:(<span class="built_in">UIGestureRecognizer</span> *)ges1&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个手势的触发方法"</span>);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ges requireGestureRecognizerToFail:ges2];</div></pre></td></tr></table></figure></p>
<p>表示如果<code>ges2</code>匹配，那么不会执行<code>ges</code>。只有当<code>ges2</code>不匹配的时候，才会执行<code>ges</code>。</p>
<h3 id="UIGestureRecognizerDelegate"><a href="#UIGestureRecognizerDelegate" class="headerlink" title="UIGestureRecognizerDelegate"></a>UIGestureRecognizerDelegate</h3><p>前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch;</div><div class="line"><span class="comment">//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer;</div><div class="line"><span class="comment">//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;</div><div class="line"><span class="comment">//下面这个两个方法也是用来控制手势的互斥执行的</span></div><div class="line"><span class="comment">//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"><span class="comment">//这个方法返回YES，第一个和第二个互斥时，第二个会失效</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div></pre></td></tr></table></figure></p>
<p>最下面两个方法用起来还挺麻烦的，因为你不知道哪个是<code>gestureRecognizer</code>哪个是<code>otherGestureRecognizer</code>,因此，只能笼统的设置。</p>
<h3 id="手势和触摸的区别"><a href="#手势和触摸的区别" class="headerlink" title="手势和触摸的区别"></a>手势和触摸的区别</h3><p>前一篇我们学习了<code>UITouch</code>,可以通过重写<code>UIResponder</code>的几个<code>touch</code>方法来处理触摸事件。<br><code>UIGestureRecognizer</code>和触摸事件是两个独立的事,手势和<code>UITouch</code>本身关系不大。不过手势可以通过<code>cancelsTouchesInView</code>,<code>delaysTouchesBegan</code>,<code>delaysTouchesEnded</code>这三个属性来影响触摸事件。</p>
<h2 id="UIGestureRecognizer的子类"><a href="#UIGestureRecognizer的子类" class="headerlink" title="UIGestureRecognizer的子类"></a>UIGestureRecognizer的子类</h2><h3 id="点击手势——UITapGestureRecognizer"><a href="#点击手势——UITapGestureRecognizer" class="headerlink" title="点击手势——UITapGestureRecognizer"></a>点击手势——UITapGestureRecognizer</h3><p>点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置点击次数，默认为单击</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span>  numberOfTapsRequired; </div><div class="line"><span class="comment">//设置同时点击的手指数</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span>  numberOfTouchesRequired;</div></pre></td></tr></table></figure></p>
<h3 id="捏合手势——UIPinchGestureRecognizer"><a href="#捏合手势——UIPinchGestureRecognizer" class="headerlink" title="捏合手势——UIPinchGestureRecognizer"></a>捏合手势——UIPinchGestureRecognizer</h3><p>捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置缩放比例</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>)          <span class="built_in">CGFloat</span> scale; </div><div class="line"><span class="comment">//设置捏合速度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>
<p>在设置完缩放后，一定要把<code>recognizer.scale</code>设置为1<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)handlePinch:(<span class="built_in">UIPinchGestureRecognizer</span>*)recognizer&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"缩放操作"</span>);<span class="comment">//处理缩放操作</span></div><div class="line">    <span class="comment">//对imageview缩放</span></div><div class="line">    _imageView.transform = <span class="built_in">CGAffineTransformScale</span>(_imageView.transform, recognizer.scale, recognizer.scale);</div><div class="line">    recognizer.scale = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="拖拽手势——UIPanGestureRecognzer"><a href="#拖拽手势——UIPanGestureRecognzer" class="headerlink" title="拖拽手势——UIPanGestureRecognzer"></a>拖拽手势——UIPanGestureRecognzer</h3><p>当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置触发拖拽的最少触摸点，默认为1</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>)          <span class="built_in">NSUInteger</span> minimumNumberOfTouches; </div><div class="line"><span class="comment">//设置触发拖拽的最多触摸点</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>)          <span class="built_in">NSUInteger</span> maximumNumberOfTouches;  </div><div class="line"><span class="comment">//获取当前位置</span></div><div class="line">- (<span class="built_in">CGPoint</span>)translationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;            </div><div class="line"><span class="comment">//设置当前位置</span></div><div class="line">- (<span class="keyword">void</span>)setTranslation:(<span class="built_in">CGPoint</span>)translation inView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">//设置拖拽速度</span></div><div class="line">- (<span class="built_in">CGPoint</span>)velocityInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure></p>
<p>代码示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)handlePan:(<span class="built_in">UIPanGestureRecognizer</span>*)recognizer&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"拖动操作"</span>);</div><div class="line">    <span class="comment">//处理拖动操作,拖动是基于imageview，如果经过旋转，拖动方向也是相对imageview上下左右移动，而不是屏幕对上下左右</span></div><div class="line">    <span class="built_in">CGPoint</span> translation = [recognizer translationInView:_imageView];</div><div class="line">    recognizer.view.center = <span class="built_in">CGPointMake</span>(recognizer.view.center.x + translation.x,</div><div class="line">                                         recognizer.view.center.y + translation.y);</div><div class="line">    [recognizer setTranslation:<span class="built_in">CGPointZero</span> inView:_imageView];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>必须使用<code>setTranslation</code>设置为<code>CGPointZero</code>,不知道为什么</p>
<h3 id="滑动手势——UISwipeGestureRecognizer"><a href="#滑动手势——UISwipeGestureRecognizer" class="headerlink" title="滑动手势——UISwipeGestureRecognizer"></a>滑动手势——UISwipeGestureRecognizer</h3><p>滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置触发滑动手势的触摸点数</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span>                        numberOfTouchesRequired; </div><div class="line"><span class="comment">//设置滑动方向</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">UISwipeGestureRecognizerDirection</span> direction;  </div><div class="line"><span class="comment">//枚举如下</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UISwipeGestureRecognizerDirection</span>) &#123;</div><div class="line">    <span class="built_in">UISwipeGestureRecognizerDirectionRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>  = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="built_in">UISwipeGestureRecognizerDirectionDown</span>  = <span class="number">1</span> &lt;&lt; <span class="number">3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="旋转手势——UIRotationGestureRecognizer"><a href="#旋转手势——UIRotationGestureRecognizer" class="headerlink" title="旋转手势——UIRotationGestureRecognizer"></a>旋转手势——UIRotationGestureRecognizer</h3><p>进行旋转动作时触发手势方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置旋转角度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>)          <span class="built_in">CGFloat</span> rotation;</div><div class="line"><span class="comment">//设置旋转速度 </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> velocity;</div></pre></td></tr></table></figure></p>
<p>在设置完旋转后，<code>recognizer.rotation</code>一定要清零.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)handleRotate:(<span class="built_in">UIRotationGestureRecognizer</span>*) recognizer&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"旋转操作"</span>);<span class="comment">//处理旋转操作</span></div><div class="line">    <span class="comment">//对imageview旋转</span></div><div class="line">    _imageView.transform = <span class="built_in">CGAffineTransformRotate</span>(_imageView.transform, recognizer.rotation);</div><div class="line">    recognizer.rotation = <span class="number">0</span>;    <span class="comment">//一定要清零</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="长按手势——UILongPressGestureRecognizer"><a href="#长按手势——UILongPressGestureRecognizer" class="headerlink" title="长按手势——UILongPressGestureRecognizer"></a>长按手势——UILongPressGestureRecognizer</h3><p>进行长按的时候触发的手势方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置触发前的点击次数</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> numberOfTapsRequired;    </div><div class="line"><span class="comment">//设置触发的触摸点数</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> numberOfTouchesRequired; </div><div class="line"><span class="comment">//设置最短的长按时间</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CFTimeInterval</span> minimumPressDuration; </div><div class="line"><span class="comment">//设置在按触时时允许移动的最大距离 默认为10像素</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> allowableMovement;</div></pre></td></tr></table></figure></p>
<h3 id="手势组合的问题"><a href="#手势组合的问题" class="headerlink" title="手势组合的问题"></a>手势组合的问题</h3><p>这么多手势可以组合使用。但是使用的时候会产生如图所示的问题：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/UIGestureRecognizer.gif?raw=true" alt="手势组合"><br>当图片正常大小时，拖动正常。当图片变小或者变大时，拖动距离变大以及变小。比如缩小图片后，相当于背景也缩小了，在手指滑动相同的距离下，相对来说移动的距离就变大了。</p>
<blockquote>
<p>Demo 详见UIGestureRecognizer</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IPhone6全屏黑边处理]]></title>
      <url>http://zhang759740844.github.io/2016/09/05/IPhone6%E5%85%A8%E5%B1%8F%E9%BB%91%E8%BE%B9%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>写ios小demo的时候，真机调试出现View不能满屏显示的情况。屏幕上下都有一条粗粗的黑条。</p>
<a id="more"></a>
<p>检查了许久，代码里都是直接设置的<code>UIScreen</code>的<code>bounds</code>。因此，不可能是代码的问题。那么需要在设置中找原因。</p>
<p>通过和正确的demo进行对比，发现了差异所在。</p>
<p>这是有黑边情况下的设置：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage2.png?raw=true" alt="错误设置"></p>
<p>这是没有黑边情况下的设置：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/SetLaunchImage1.png?raw=true" alt="正确设置"></p>
<p>通过比较可以发现：<br>出现黑边的原因是在设置里设置了<code>Launch Images Source</code>为<code>LaunchImage</code>,但是在Images.xcassets中并没有<code>LaunchImage</code>资源。所以，需要给<code>LaunchImage</code>设置图片资源。<br>也可以像上面的那样设置<code>Launch Images Source</code>为<code>Use Asset Catalog</code>,并且将<code>Launch Screen File</code>设置为<code>LaunchImage</code>即可解决。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios响应机制]]></title>
      <url>http://zhang759740844.github.io/2016/09/03/ios%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>从点击屏幕到系统做出响应，经历了哪些过程？需要详细探究下ios的响应机制。本文参考自<a href="http://www.jianshu.com/p/2e074db792ba" target="_blank" rel="external">史上最详细的iOS之事件的传递和响应机制
</a></p>
<a id="more"></a>
<h2 id="iOS中的事件"><a href="#iOS中的事件" class="headerlink" title="iOS中的事件"></a>iOS中的事件</h2><p>ios中的事件可以被分为三类：<strong>触摸事件</strong>，<strong>加速计事件</strong>，<strong>远程控制事件</strong>。本文讨论的是触摸事件。</p>
<h3 id="响应者对象-UIResponder"><a href="#响应者对象-UIResponder" class="headerlink" title="响应者对象(UIResponder)"></a>响应者对象(UIResponder)</h3><p>在iOS中不是任何对象都能处理事件，只有继承了<code>UIResponder</code>的对象才能接受并处理事件，我们称之为“响应者对象”。</p>
<p>以下都是继承自<code>UIResponder</code>的，所以都能接收并处理事件:</p>
<ul>
<li>UIApplication</li>
<li>UIViewController</li>
<li>UIView</li>
</ul>
<p>那么为什么继承自UIResponder的类就能够接收并处理事件呢？因为UIResponder中提供了以下4个对象方法来处理触摸事件。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIResponder</span>内部提供了以下方法来处理事件触摸事件</div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">加速计事件</div><div class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</div><div class="line">远程控制事件</div><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>
<h2 id="事件的处理"><a href="#事件的处理" class="headerlink" title="事件的处理"></a>事件的处理</h2><h3 id="触摸事件："><a href="#触摸事件：" class="headerlink" title="触摸事件："></a>触摸事件：</h3><p>下面以UIView为例来说明触摸事件的处理:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></div><div class="line"><span class="comment">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 一根或者多根手指离开view，系统会自动调用view的下面方法- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</span></div><div class="line"><span class="comment">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line"><span class="comment">// 提示：touches中存放的都是UITouch对象</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ul>
<li>以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。很重要的一点：<strong>如果想处理UIView的触摸事件，那么就在UIView中重写；如果想处理UIViewController的触摸事件，那么就在UIViewController中重写。</strong></li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次<code>touchesBegan:withEvent:</code>方法，<code>touches</code>参数中装着2个<code>UITouch</code>对象.</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次<code>touchesBegan:withEvent:</code>方法，并且每次调用时的<code>touches</code>参数中只包含一个<code>UITouch</code>对象.</li>
</ul>
<h3 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h3><p>当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。</p>
<h4 id="UITouch作用"><a href="#UITouch作用" class="headerlink" title="UITouch作用"></a>UITouch作用</h4><ul>
<li>保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象</li>
</ul>
<h4 id="UITouch属性"><a href="#UITouch属性" class="headerlink" title="UITouch属性"></a>UITouch属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">触摸产生时所处的窗口</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIWindow</span> *window;</div><div class="line"></div><div class="line">触摸产生时所处的视图</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span> *view</div><div class="line">;</div><div class="line"></div><div class="line">短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> tapCount;</div><div class="line"></div><div class="line">记录了触摸事件产生或变化时的时间，单位是秒</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span> timestamp;</div><div class="line"></div><div class="line">当前触摸事件所处的状态</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span> phase;</div></pre></td></tr></table></figure>
<h4 id="UITouch方法"><a href="#UITouch方法" class="headerlink" title="UITouch方法"></a>UITouch方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="built_in">CGPoint</span>)locationInView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">// 返回值表示触摸在view上的位置</span></div><div class="line"><span class="comment">// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</span></div><div class="line"><span class="comment">// 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</span></div><div class="line"></div><div class="line">(<span class="built_in">CGPoint</span>)previousLocationInView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">// 该方法记录了前一个触摸点的位置</span></div></pre></td></tr></table></figure>
<h4 id="使用UITouch实现UIView的拖拽"><a href="#使用UITouch实现UIView的拖拽" class="headerlink" title="使用UITouch实现UIView的拖拽"></a>使用UITouch实现UIView的拖拽</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </div><div class="line">    <span class="comment">// 想让控件随着手指移动而移动,监听手指移动 </span></div><div class="line">    <span class="comment">// 获取UITouch对象 </span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject]; </div><div class="line">    <span class="comment">// 获取当前点的位置 </span></div><div class="line">    <span class="built_in">CGPoint</span> curP = [touch locationInView:<span class="keyword">self</span>]; </div><div class="line">    <span class="comment">// 获取上一个点的位置 </span></div><div class="line">    <span class="built_in">CGPoint</span> preP = [touch previousLocationInView:<span class="keyword">self</span>]; </div><div class="line">    <span class="comment">// 获取它们x轴的偏移量,每次都是相对上一次 </span></div><div class="line">    <span class="built_in">CGFloat</span> offsetX = curP.x - preP.x; </div><div class="line">    <span class="comment">// 获取y轴的偏移量 </span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = curP.y - preP.y; </div><div class="line">    <span class="comment">// 修改控件的形变或者frame,center,就可以控制控件的位置 </span></div><div class="line">    <span class="comment">// 形变也是相对上一次形变(平移) </span></div><div class="line">    <span class="comment">// CGAffineTransformMakeTranslation:会把之前形变给清空,重新开始设置形变参数 </span></div><div class="line">    <span class="comment">// make:相对于最原始的位置形变 </span></div><div class="line">    <span class="comment">// CGAffineTransform t:相对这个t的形变的基础上再去形变 </span></div><div class="line">    <span class="comment">// 如果相对哪个形变再次形变,就传入它的形变 </span></div><div class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformTranslate</span>(<span class="keyword">self</span>.transform, offsetX, offsetY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过UITouch对象获得当前点和上一个点的位置，求得偏移量</p>
<h2 id="iOS中的事件的产生和传递"><a href="#iOS中的事件的产生和传递" class="headerlink" title="iOS中的事件的产生和传递"></a>iOS中的事件的产生和传递</h2><h3 id="事件的产生过程"><a href="#事件的产生过程" class="headerlink" title="事件的产生过程"></a>事件的产生过程</h3><ol>
<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中。</li>
<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>
<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<ol>
<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件。</li>
<li>判断触摸点是否在自己身上。</li>
<li>子控件数组中从后往前遍历子控件(后添加的view在上面，降低循环次数)，重复前面的两个步骤。</li>
<li>如果触摸点在子控件上，那么重复3</li>
<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li>
</ol>
</li>
<li>找到最合适的view后，<strong>将这个view层层返回给viewController,viewcontroller就会自动调用该view的touches方法处理具体的事件</strong>。</li>
</ol>
<p>触摸事件的传递是从父控件传递到子控件,也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view。注意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件。</p>
<h3 id="UIView不能接受触摸事件的三种情况"><a href="#UIView不能接受触摸事件的三种情况" class="headerlink" title="UIView不能接受触摸事件的三种情况"></a>UIView不能接受触摸事件的三种情况</h3><ul>
<li>不允许交互：<code>userInteractionEnabled = NO</code></li>
<li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>
<li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>
</ul>
<p><strong>注 意</strong>:</p>
<ul>
<li>默认UIImageView不能接受触摸事件，因为不允许交互，即<code>userInteractionEnabled = NO</code>，所以如果希望UIImageView可以交互，需要<code>userInteractionEnabled = YES</code>。</li>
<li>不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已！</li>
</ul>
<h3 id="找到最合适控件的方法"><a href="#找到最合适控件的方法" class="headerlink" title="找到最合适控件的方法"></a>找到最合适控件的方法</h3><h4 id="hitTest：withEvent："><a href="#hitTest：withEvent：" class="headerlink" title="hitTest：withEvent："></a>hitTest：withEvent：</h4><p>只要事件一传递给一个控件,这个控件就会调用他自己的<code>hitTest：withEvent：</code>方法.用来寻找并返回最合适的view(能够响应事件的那个最合适的view)</p>
<h4 id="拦截事件"><a href="#拦截事件" class="headerlink" title="拦截事件"></a>拦截事件</h4><p>不管点击哪里，最合适的view都是<code>hitTest：withEvent：</code>方法中返回的那个view。因此，可以通过重写<code>hitTest：withEvent：</code>方法，返回指定的view作为最合适的view，这样就完成了事件的拦截。如果不想拦截，就调用<code>[super touchesMoved:touches withEvent:event];</code></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong><code>hitTest：withEvent：</code>是UIView的方法，不是UIResponse的方法！所以Controller里不能用。这点很重要！这说明只能控制UIView里的子View</strong></li>
<li>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用<code>hitTest:withEvent:</code>方法。<code>hitTest</code>的这个<code>CGPoint point</code>表示当前手指触摸的点，其值是以方法调用者的左上角(0,0)为基准的(就是touch的<code>locationInView:</code>方法的返回值)。也就是说，不同的控件调用这个方法，这个point都是经过计算而产生的不同的值。</li>
<li><code>hitTest：withEvent：</code>找到最佳View后，会一层层返回，将这个View返回给ViewController。如<code>hitTest:withEvent:</code>方法中返回<code>nil</code>，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</li>
</ul>
<h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的<code>hitTest:withEvent:</code>方法返回指定的子控件。这里又要注意，最好不要在子控件内<code>return self</code>。因为，在遍历子控件的时候，很有可能没有遍历到你真正想要返回的那个控件，就在其他控件已经return了。</p>
<p>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的<code>hitTest:withEvent:</code>方法中<code>return self.subViews[0]</code>;这种情况下在redView的<code>hitTest:withEvent:</code>方法中<code>return self;</code>是不好使的！</p>
<h4 id="hitTest-withEvent：的底层实现"><a href="#hitTest-withEvent：的底层实现" class="headerlink" title="hitTest:withEvent：的底层实现"></a>hitTest:withEvent：的底层实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"WSWindow.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WSWindow</span></span></div><div class="line"><span class="comment">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span></div><div class="line"><span class="comment">// 作用:寻找并返回最合适的view</span></div><div class="line"><span class="comment">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span></div><div class="line"><span class="comment">// point:当前手指触摸的点</span></div><div class="line"><span class="comment">// point:是方法调用者坐标系上的点</span></div><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">// 1.判断下窗口能否接收事件</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> ||  <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>; </div><div class="line">    <span class="comment">// 2.判断下点在不在窗口上 </span></div><div class="line">    <span class="comment">// 不在窗口上 </span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>; </div><div class="line">    <span class="comment">// 3.从后往前遍历子控件数组 </span></div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.subviews.count; </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </div><div class="line">    	<span class="comment">// 获取子控件</span></div><div class="line">    	<span class="built_in">UIView</span> *childView = <span class="keyword">self</span>.subviews[i]; </div><div class="line">    	<span class="comment">// 坐标系的转换,把窗口上的点转换为子控件上的点 </span></div><div class="line">    	<span class="comment">// 把自己控件上的点转换成子控件上的点 </span></div><div class="line">    	<span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:childView]; </div><div class="line">    	<span class="built_in">UIView</span> *fitView = [childView hitTest:childP withEvent:event]; </div><div class="line">    	<span class="keyword">if</span> (fitView) &#123;</div><div class="line">    		<span class="comment">// 如果能找到最合适的view </span></div><div class="line">    		<span class="keyword">return</span> fitView; </div><div class="line">    	&#125;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// 4.没有找到更合适的view，也就是没有比自己更合适的view </span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 作用:判断下传入过来的点在不在方法调用者的坐标系上</span></div><div class="line"><span class="comment">// point:是方法调用者坐标系上的点</span></div><div class="line"><span class="comment">//- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span></div><div class="line"><span class="comment">//		return NO;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>hit:withEvent:</code>方法底层会调用<code>pointInside:withEvent:</code>方法判断点在不在方法调用者的坐标系上。</p>
<h4 id="pointInside-withEvent-方法"><a href="#pointInside-withEvent-方法" class="headerlink" title="pointInside:withEvent:方法"></a>pointInside:withEvent:方法</h4><p><code>pointInside:withEvent:</code>方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>
<h2 id="事件的响应"><a href="#事件的响应" class="headerlink" title="事件的响应"></a>事件的响应</h2><h3 id="事件的传递与响应区别"><a href="#事件的传递与响应区别" class="headerlink" title="事件的传递与响应区别"></a>事件的传递与响应区别</h3><p>前面说到了，当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>
<p>在找到了最合适的view后，接下来就是事件的响应过程。响应过程是传递过程的逆过程。在事件的响应中，如果某个控件实现了<code>touches...</code>方法，则这个事件将由该控件来接受，如果调用了<code>[super touches….]</code>;就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的<code>touches….</code>方法。</p>
<p>touches默认做法是把事件顺着响应者链条向上抛：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"WSView.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WSView</span> </span></div><div class="line"><span class="comment">//只要点击控件,就会调用touchBegin,如果没有重写这个方法,自己处理不了触摸事件</span></div><div class="line"><span class="comment">// 上一个响应者可能是父控件</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </div><div class="line">	<span class="comment">// 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span></div><div class="line">	[<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </div><div class="line">	<span class="comment">// 注意不是调用父控件的touches方法，而是调用父类的touches方法</span></div><div class="line">	<span class="comment">// super是父类 superview是父控件 </span></div><div class="line">	<span class="comment">// 不过super内还是要调用superview的touch的方法来交给上一个响应者的。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>
<p><strong>注意：</strong>ViewController中如果自定义了<code>touchesBegan:withEvent:</code>方法，任何情况都会执行。只有在UIView中定义的<code>touchesBegan:withEvent:</code>方法，才会根据<code>hitTest：withEvent：</code>的不同返回，执行返回View的<code>touchesBegan:withEvent:</code>方法。估计是因为UIViewController中没有<code>hitTest：withEvent：</code>方法的缘故。</p>
<h3 id="一个事件多个对象处理"><a href="#一个事件多个对象处理" class="headerlink" title="一个事件多个对象处理"></a>一个事件多个对象处理</h3><p>因为系统默认做法(super方法)是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123; </div><div class="line">	<span class="comment">// 1.自己先处理事件...</span></div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"do somthing..."</span>);</div><div class="line">	<span class="comment">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</span></div><div class="line">	[<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Demo 请看UIGestureRecognizer</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CALayer的transform]]></title>
      <url>http://zhang759740844.github.io/2016/09/02/CALayer%E7%9A%84transform%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>在<a href="https://zhang759740844.github.io/2016/08/05/UICollectionView/">CollectionView的使用</a>中，有为cell添加transform属性，实现自定义动画。现在，详细了解下View及其Layer的transform属性。</p>
<a id="more"></a>
<h2 id="UIView的transform属性"><a href="#UIView的transform属性" class="headerlink" title="UIView的transform属性"></a>UIView的transform属性</h2><p>transform是view的一个重要属性,它在矩阵层面上改变view的显⽰状态,能实现view的缩放、旋转、平移等功能。transform是<code>CGAffineTransform</code>类型的。</p>
<h3 id="transform结构"><a href="#transform结构" class="headerlink" title="transform结构"></a>transform结构</h3><p>transform是一个<code>CGAffineTransform</code>类型，结构如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="built_in">CGAffineTransform</span> &#123;</div><div class="line">  <span class="built_in">CGFloat</span> a, b, c, d;</div><div class="line">  <span class="built_in">CGFloat</span> tx, ty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CGAffineTransform实际上是一个矩阵<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">| a,  b,  <span class="number">0</span> |</div><div class="line">| c,  d,  <span class="number">0</span> |</div><div class="line">| tx, ty, <span class="number">1</span> |</div></pre></td></tr></table></figure></p>
<p>由于transform只有两维，需要一个3阶矩阵来表示其缩放以及平移的变化。</p>
<p>坐标变换过程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                    | a,  b,  0 |</div><div class="line">&#123;x',y',1&#125;=&#123;x,y,1&#125; x | c,  d,  0 |</div><div class="line">                    | tx, ty, 1 |</div><div class="line">                    </div><div class="line">==&gt;</div><div class="line"></div><div class="line">xn=ax+cy+tx;</div><div class="line">yn=bx+dy+ty;</div></pre></td></tr></table></figure></p>
<p>这个矩阵的第三列是固定的，所以每次变换时，只需传入前两列的六个参数[a,b,c,d,tx,ty]即可。</p>
<h3 id="transform方法"><a href="#transform方法" class="headerlink" title="transform方法"></a>transform方法</h3><p>在<code>CGAffineTransform</code>的生成函数中，大多是两两对应的，一个带<br>make字样，一个不带。带make字样的是直接生成一个新的<code>CGAffineTransform</code>，不带make字样的则是在一个<code>CGAffineTransform</code>的基础上生成新的。函数返回值均是<code>CGAffineTransform</code>类型。</p>
<p>多个<code>CGAffineTransform</code>对象赋给view，最终只执行最后一个动画，多个动画需要组合在一起。</p>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p>实现的是放大和缩小:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t,</div><div class="line">  <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)；</div><div class="line"><span class="built_in">CGAffineTransformMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)；</div></pre></td></tr></table></figure></p>
<p>生成新的transform相当于将<code>t&#39; = [sx ，0 ，0，sy ，0， 0]</code>这六个参数代入矩阵中,即改变a和d。</p>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p>实现的是旋转：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t,</div><div class="line">  <span class="built_in">CGFloat</span> angle)</div><div class="line"><span class="built_in">CGAffineTransformMakeRotation</span>(<span class="built_in">CGFloat</span> angle)；</div></pre></td></tr></table></figure></p>
<p>angle为角度，angle=π则旋转180度。矩阵的六个参数为<code>t&#39; =  [ cos(angle)，sin(angle)，-sin(angle)，cos(angle) 0，0]；</code></p>
<h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><p>实现的是平移：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t,</div><div class="line">  <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)；</div><div class="line"><span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="built_in">CGFloat</span> tx,</div><div class="line">  <span class="built_in">CGFloat</span> ty)；</div></pre></td></tr></table></figure></p>
<p>矩阵的六个参数为<code>t&#39; = [1，0，0，1，tx，ty] ；</code>代入公式，<code>xn=x+tx,yn=y+ty</code></p>
<h4 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.transform＝<span class="built_in">CGAffineTransformIdentity</span>;</div></pre></td></tr></table></figure>
<p>上述的各种动画的变化都是以原始图像为基准的，而不是在变化后继续变化。<code>CGAffineTransformIdentity</code>将view从当前状态复原回view最初始的状态。</p>
<h2 id="CALayer的transform属性"><a href="#CALayer的transform属性" class="headerlink" title="CALayer的transform属性"></a>CALayer的transform属性</h2><h3 id="transform结构-1"><a href="#transform结构-1" class="headerlink" title="transform结构"></a>transform结构</h3><p>CALayer的transform是一个<code>CATransform3D</code>结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="built_in">CATransform3D</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">CGFloat</span> m11, m12, m13, m14;</div><div class="line">  <span class="built_in">CGFloat</span> m21, m22, m23, m24;</div><div class="line">  <span class="built_in">CGFloat</span> m31, m32, m33, m34;</div><div class="line">  <span class="built_in">CGFloat</span> m41, m42, m43, m44;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>有别于<code>CGAffineTransform</code>,<code>CATransform3D</code>是一个三维变化，需要一个4阶矩阵表示。其他类似，再次不表。</p>
<h3 id="transform方法-1"><a href="#transform方法-1" class="headerlink" title="transform方法"></a>transform方法</h3><p>CALayer的transform方法和View的transform基本一致。举几点不同：</p>
<ul>
<li><p>CALayer由于有z轴，因此对不同图层使用<code>CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</code>方法的时候可以通过改变tz的值，来实现图层的覆盖。对于tz来说，值越大，那么图层就越往外（接近屏幕），值越小，图层越往里（屏幕里）。</p>
</li>
<li><p>由于图像是从正面投影，直接绕着x或y轴旋转达不到透视的效果，如果要达到透视效果，需要改变<code>m34</code>(其实改变m14，m24也能达到效果，可以自行通过行列式推导。)，再对图层进行旋转。<code>m34</code>的值可以根据需要实现的效果推导得到，不直接的方法还是直接试。</p>
</li>
<li><p>如果想要直接改变矩阵里的值，可以先使用<code>CATransform3DIdentity</code>的方式，初始化一个<code>CATransform3D</code>实例，然后再赋值。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Block 的使用]]></title>
      <url>http://zhang759740844.github.io/2016/09/01/Block%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>类似于匿名函数，oc中提供<code>block</code>,可以将一段代码块像对象一样作为参数传递、执行。</p>
<a id="more"></a>
<h2 id="Block的使用"><a href="#Block的使用" class="headerlink" title="Block的使用"></a>Block的使用</h2><h3 id="Block实例"><a href="#Block实例" class="headerlink" title="Block实例"></a>Block实例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">^(<span class="keyword">double</span> dividend)&#123;</div><div class="line">	<span class="keyword">double</span> quotient = dividend / divisor;</div><div class="line">	<span class="keyword">return</span> quotient;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Block对象可以被当做一个实参来传递给可以接收block的方法。</p>
<h3 id="声明block变量"><a href="#声明block变量" class="headerlink" title="声明block变量:"></a>声明block变量:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^devowelizer)(<span class="keyword">id</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">BOOL</span>*);</div></pre></td></tr></table></figure>
<p><code>void</code> 表示返回类型<br><code>^</code> 表示是一个block对象<br><code>devowelizer</code> 表示block变量的名称<br>后面的是实参类型<br>方法的调用参数类型为<code>^(id  string, NSUInteger i, BOOL *stop)block</code></p>
<h3 id="编写Block对象"><a href="#编写Block对象" class="headerlink" title="编写Block对象"></a>编写Block对象</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">devowelizer = ^(<span class="keyword">id</span> string,<span class="built_in">NSUInteger</span> i, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">	……</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="调用block变量"><a href="#调用block变量" class="headerlink" title="调用block变量"></a>调用block变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devowelizer(string,i,stop);</div></pre></td></tr></table></figure>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>不能在方法的实现代码中使用typedef，需要在实现文件的顶部，或者头文件内使用typedef。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^ArrayEnumerationBlock)(<span class="keyword">id</span>,<span class="built_in">NSUInteger</span>,<span class="built_in">BOOL</span> *);</div></pre></td></tr></table></figure></p>
<p>需要注意的是，这里定义的是一个新的类型，不是变量。跟在^后面的是类型名称。创建这个新类型后，可以简化相应Block的声明。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayEnumerationBlock devowelizer；</div></pre></td></tr></table></figure></p>
<h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><p>在执行Block对象时，为了确保其下的外部变量能够始终存在，相应的Block对象会捕获这些变量，意味着程序会拷贝变量的值。</p>
<p><strong>当外部对象是引用时，block会复制其引用的地址(指针指向的堆上的地址)，只能改变地址指向的对象的属性，不能将外部对象指向新的地址，类似于Java的引用机制。</strong></p>
<h3 id="修改外部变量"><a href="#修改外部变量" class="headerlink" title="修改外部变量"></a>修改外部变量</h3><p>如果需要在Block对象内修改某个外部变量，则可以声明相应的外部变量时，在前面加上__block关键字。</p>
<p><strong>__block关键字让block内部拿到外部对象的指针。这样就可以改变地址上指向实例对象地址的指针的指向，从而达到改变外部对象的结果。</strong></p>
<h3 id="在Block中使用self"><a href="#在Block中使用self" class="headerlink" title="在Block中使用self"></a>在Block中使用self</h3><p>如果要写一个使用self的Block对象，需要避免强引用循环。<br>在Block外声明一个_weak指正，然后将这个指针指向Block对象使用的self，最后在Block对象中使用这个新的指针。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_<span class="keyword">weak</span> BNREmployee *weakSelf = <span class="keyword">self</span>;	<span class="comment">//弱引用指针</span></div><div class="line">	myBlock = ^&#123;</div><div class="line">		<span class="built_in">NSLog</span>(@“Employee:%@”,weakSelf);</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="block的实现"><a href="#block的实现" class="headerlink" title="block的实现"></a>block的实现</h2><p>block的实现主要参考<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/#" target="_blank" rel="external">唐巧谈Objective-C block的实现</a></p>
<h3 id="block的结构"><a href="#block的结构" class="headerlink" title="block的结构"></a>block的结构</h3><p>block的结构如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Block_descriptor &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</div><div class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Block_layout &#123;</div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">int</span> flags;</div><div class="line">    <span class="keyword">int</span> reserved;</div><div class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</div><div class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor;</div><div class="line">    <span class="comment">/* Imported variables. */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>结构图如下：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/block_struct.jpg?raw=true" alt="block结构图"></p>
<p>通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成：</p>
<ol>
<li><code>isa</code> 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li><code>flags</code>，用于按 bit 位表示一些 block 的附加信息。</li>
<li><code>reserved</code>，保留变量。</li>
<li><code>invoke</code>，函数指针，指向具体的 block 实现的函数调用地址。</li>
<li><code>descriptor</code>， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</li>
<li>各种从外部复制过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ol>
<h3 id="block种类"><a href="#block种类" class="headerlink" title="block种类"></a>block种类</h3><p>block的isa是以下三个的一种：</p>
<ol>
<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量。</li>
<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁。</li>
<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>
</ol>
<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和 <code>NSConcreteMallocBlock</code>类型的 block。原本的 <code>NSConcreteStackBlock</code> 的 block 会被 <code>NSConcreteMallocBlock</code> 类型的 block 替代。</p>
<h3 id="研究工具：clang"><a href="#研究工具：clang" class="headerlink" title="研究工具：clang"></a>研究工具：clang</h3><p>clang 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究各种结构的源码实现方式。该命令是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc xxxx</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UITableView 基础]]></title>
      <url>http://zhang759740844.github.io/2016/08/30/UITableView%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>UITableView是最常用的基本控件。此处对其一般用法进行总结。</p>
<a id="more"></a>
<h2 id="UITableView基础"><a href="#UITableView基础" class="headerlink" title="UITableView基础"></a>UITableView基础</h2><h3 id="UITableView-的样式"><a href="#UITableView-的样式" class="headerlink" title="UITableView 的样式"></a>UITableView 的样式</h3><ol>
<li>UITableViewStylePlain        将会保持在顶部直到被顶掉</li>
<li>UITableViewStyleGrouped        将会随着cell一起滚动</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableView</span> *tableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span> style:<span class="built_in">UITableViewStyle</span>];</div></pre></td></tr></table></figure>
<p>其中<code>CGRectZero</code>表示<code>equivalent to CGRectMake(0, 0, 0, 0)</code>.之后代码会改UITableView的Frame，所以暂且都是0。</p>
<h3 id="UITableView对象提供数据"><a href="#UITableView对象提供数据" class="headerlink" title="UITableView对象提供数据"></a>UITableView对象提供数据</h3><p>UITableView不包含任何数据，需要提供一个数据源.<br>我们将BNRAppDelegate实例设置为UITableView对象的数据源。BNRAPPDelegate必须遵循UITableViewDataSource协议。<br>在BNRAPPDelegate.h文件中，声明BNRAPPDelegate遵循UITableViewDataSource协议<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BNRAppDelegate</span>: <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>,<span class="title">UITableViewDataSource</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UITableView</span> *taskTable;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutable</span> Array *tasks;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在.m中向UITableView发送<code>setDataSource</code>消息，将BNRAPPDelegate实例设置为数据源</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.taskTable.dataSource = <span class="keyword">self</span>;</div></pre></td></tr></table></figure>
<p>UITableViewDataSource设置了两个必须方法：</p>
<ol>
<li>根据指定的表格索引给出相应表格段包含的行数（<code>tableView：numberOfRowsInSection：</code>）</li>
<li>根据指定表格段索引和行索引给出相应的UITableViewCell对象（<code>tableView：cellForRowAtIndexPath：</code>）<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BNRAppDelegate</span></span></div><div class="line">-(<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">	    <span class="keyword">return</span> [<span class="keyword">self</span>.tasks count];</div><div class="line">&#125;</div><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">        <span class="built_in">UITableViewCell</span> *c = [<span class="keyword">self</span>.taskTable dequeueReusableCellWithIdentifier:@“cell”];</div><div class="line">	    <span class="comment">//重用cell</span></div><div class="line">	    <span class="built_in">NSString</span> *item = [<span class="keyword">self</span>.tasks objectAtIndex:indexPath.row];</div><div class="line">	    c.textLabel.text = item;</div><div class="line">	    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>刷新表格：<code>[self.taskTable reloadData];</code></p>
<h3 id="重用UITableViewCell对象"><a href="#重用UITableViewCell对象" class="headerlink" title="重用UITableViewCell对象"></a>重用UITableViewCell对象</h3><p>需要将自定义的cell类和identifier进行关联。<br>在ViewController.m中覆盖viewDidLoad方法，向表视图注册应该使用的UITabeViewCell<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">	[<span class="keyword">super</span> viewDidLoad];</div><div class="line">	[<span class="keyword">self</span>.tableView registerClass:[<span class="built_in">UITableViewCell</span> <span class="keyword">class</span>] forCellReuseIdentifier:@“<span class="built_in">UITableViewCell</span>”];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样UITableViewCell类就和这个string关联起来了。也可以使用nib文件关联<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.tableView registerNib:[<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MineUserInfoCell"</span> bundle:<span class="literal">nil</span>]  forCellReuseIdentifier:<span class="string">@"MineUserInfoCellIdentifier"</span>];</div></pre></td></tr></table></figure></p>
<h3 id="使用UIViewController创建tabeView"><a href="#使用UIViewController创建tabeView" class="headerlink" title="使用UIViewController创建tabeView"></a>使用UIViewController创建tabeView</h3><p>需要自己创建tableview属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITableView</span> *tableView;</div></pre></td></tr></table></figure></p>
<p>这里要用strong ，因为这个tableview是自己创建的。如果是weak那么指向的地方在创建后就被ARC回收了,那么这个tableview指针就成了野指针了。<br>如果是连线的就可以用weak，weak属性一般用在当前属性是其他类创建，只存一个该属性的引用的时候，为了强引用那个类。</p>
<h3 id="创建多个section的tableview"><a href="#创建多个section的tableview" class="headerlink" title="创建多个section的tableview"></a>创建多个section的tableview</h3><p>创建多个section的tableview需要实现方法<code>numberOfSectionsInTableView:</code>返回tableview中section的个数。其余使用和单个section一样。</p>
<p>在<code>cellForRowAtIndexPath:</code>方法中，需要区分不同section返回不同cell。区分section的方式在于该方法传入的参数<code>(NSIndexPath *)indexPath</code>。</p>
<p><code>NSIndexPath</code>是一个结构体，具有两个属性<code>row</code>和<code>section</code>。表示所在section和section内row。<br><code>NSIndexPath</code>中的属性是只读的，不能直接修改。只能通过重新创建的形式，达到修改属性的目的。<br>创建方式:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">1</span> inSection:<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<h3 id="TableView表头视图"><a href="#TableView表头视图" class="headerlink" title="TableView表头视图"></a>TableView表头视图</h3><p>表头视图是指UITableView对象可以在其表格上方显示的特定视图，是和放置针对某个表格段或整张表格的标题和控件。表头视图可以是任意UIView对象。表格视图有两种，分别针对表格段和表格。类似的，还有表尾视图。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *headerView = [[[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"HotelReviewsHeaderView"</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>]lastObject];</div></pre></td></tr></table></figure></p>
<p><strong>loadNibNamed:owner:options:</strong>返回的是个数组，保存了xib中的各个view。xib中有几个view，数组元素就是几。因此，可以将多个自定义的view或者cell放在一个xib中，通过数组的方式获取想要的view。<code>initWithNibName</code>的实现和该方法类似，其中也会用到该方法。不过<code>initWithNibName</code>用在获取Controller的xib中。</p>
<hr>
<p>差个题外话，这里我们来介绍下<code>loaNibNamed</code>方法和<code>initWithNibName</code>方法的异同。</p>
<p>首先明确一点：<code>loadNibNamed</code>、<code>initWithNibName</code>以及<code>nibWithNibName</code>后面跟的都是<strong>文件名</strong>，那么，怎么确定该xib文件下对应的是哪个view呢？</p>
<p>先介绍下xib文件中的<code>File&#39;s Owner</code>:<br><code>File&#39;s Owner</code> 表示视图控制器。UIViewController(或其子类)在生成的时候，首先会寻找相应的<code>.xib</code>去生成，于是controller的实例(instance)就把<code>.xib</code>载入内存，并成为<code>FIle&#39;s Owner</code>（也就是说明了为什么叫做占位符）。<strong>所以我们定义的controller是这个<code>.xib</code>的<code>custom class</code>。</strong>并且需要把这个<code>FIle Owner</code>上的<code>outlet</code>连到某个控件上去。（Action也同样道理）换个角度，如果我们看<code>.xib</code>文件，发现它有个<code>File
 Owner</code>,其实就是我们用来设定，究竟是那个Object来读取并载入这个<code>.xib</code>文件，也就是说，谁own这个文件。</p>
<p>那么，也就是说，对于<code>initWithNibName</code>方法而言，它加载的必须是设置了<code>File&#39;s Owner</code>为自身的xib，<strong>设置了<code>File&#39;s Owner</code>就说明，这个xib被这个Controller承包了，别的Controller用不了。</strong><code>File&#39;s Owner</code>会和文件中需要加载的view关联(也就是连线，<code>File&#39;s Owner</code>的view属性会联结要显示的view)，从而从众多view中确定要显示的view是哪一个。这就说明了两点：第一，一个Controller可以有多个xib，只要xib的<code>File&#39;s Owner</code>都指向那个Controller就行。第二，不用担心一个xib中有多个并列的view导致机器不知道要加载哪个的情况，因为<code>File&#39;s Owner</code>的<code>view</code>只会联结这些view中的一个。</p>
<p>对于自定义的view，任何Controller都能获得该view，因此，不能设置其xib文件的<code>File&#39;s Owner</code>。上面也说了，通过<code>loadNibNamed</code>方法会返回各个view的数组，需要自己手动选择要加载哪个。</p>
<p><code>loadNibNamed</code>方法也可以获得<code>initWithNibName</code>的view。<code>loadNibNamed:owner:options:</code>方法中有一个<code>owner</code>参数，就是用来传<code>File&#39;s Owner</code>的。<br>对于自定义的view所属的xib文件，由于没有<code>File&#39;s Owner</code>，因此加载的时候<code>owner</code>传入<code>nil</code>。<br>对于有<code>File&#39;s Owner</code>的Controller的xib，<code>owner</code>需要传入该xib文件相应<code>File&#39;s Owner</code>的实例，否则无法加载，返回该xib内所有view的数组。在lldb中可以验证Controller的view属性就是通过<code>loadNibNamed</code>拿到的view：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p [[[<span class="built_in">NSBundle</span> mainBundle]loadNibNamed:<span class="string">@"xxxController"</span> owner:<span class="keyword">self</span> options:<span class="literal">nil</span>] firstObject] == <span class="keyword">self</span>.view</div><div class="line">(<span class="keyword">bool</span>) $<span class="number">1</span> = <span class="literal">true</span></div></pre></td></tr></table></figure>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">	<span class="built_in">UIView</span> *header = <span class="keyword">self</span>.headerView;</div><div class="line">	[<span class="keyword">self</span>.tableView setTableHeaderView:header];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载完headerView后，将其设置为UITableView对象的表头视图。<br>也可以在 <strong>(UIView *)tableView:viewForHeaderInSection:</strong>方法中设置，当只有一个section时效果相同。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView viewForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    <span class="built_in">UIView</span> *view = [[[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"HeaderView"</span> owner:<span class="literal">nil</span> options:<span class="literal">nil</span>] lastObject];</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="tableview的字母索引"><a href="#tableview的字母索引" class="headerlink" title="tableview的字母索引"></a>tableview的字母索引</h3><p>实现<code>sectionIndexTitlesForTableView</code>方法，返回一个字符串数组：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)sectionIndexTitlesForTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *indexs = [[<span class="built_in">NSMutableArray</span> alloc]init];</div><div class="line">    [indexs addObject:<span class="string">@"我"</span>];</div><div class="line">    [indexs addObject:<span class="string">@"是"</span>];</div><div class="line">    <span class="keyword">return</span> indexs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个返回数组的内容和各个section对应，点击索引，就能跳转到对应section。</p>
<h3 id="点击cell中button获取所属indexpath"><a href="#点击cell中button获取所属indexpath" class="headerlink" title="点击cell中button获取所属indexpath"></a>点击cell中button获取所属indexpath</h3><p>button点击事件中有一个event对象，记录了当前点击坐标，然后通过坐标能够找到所属的cell。可以在cell中为点击事件设置代理，然后在viewcontroller中实现。当然，更推荐的是直接在viewcontroller中添加和实现点击事件。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[cell.btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(cellBtnClicked:event:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cellBtnClicked:(<span class="keyword">id</span>)sender event:(<span class="keyword">id</span>)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSSet</span> *touches =[event allTouches];</div><div class="line">    <span class="built_in">UITouch</span> *touch =[touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> currentTouchPosition = [touch locationInView:_tableView];</div><div class="line">    <span class="built_in">NSIndexPath</span> *indexPath= [_tableView indexPathForRowAtPoint:currentTouchPosition];</div><div class="line">    <span class="keyword">if</span> (indexPath!= <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过<code>event</code>拿到在tableView中的位置<code>cure</code>，再通过<code>indexPathForRowAtPoint:</code>方法获取<code>NSIndexPath</code>。</p>
<p>另外一种方法是，在cell中使用代理，直接将cell传给viewcontroller：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//cell.h中的声明</span></div><div class="line">- (<span class="keyword">IBAction</span>)buttonPressed :(<span class="keyword">id</span>)；</div><div class="line"></div><div class="line"><span class="comment">//cell.m中的实现，设置代理</span></div><div class="line">- (<span class="keyword">void</span>)buttonPressed:(<span class="keyword">id</span>)sender&#123;</div><div class="line">    [<span class="keyword">self</span>.delegate buttonPressed:<span class="keyword">self</span> event:event];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//viewcontroller中的实现</span></div><div class="line">- (<span class="keyword">void</span>)buttonPressed:(TableViewCell1 *)cell&#123;</div><div class="line">    <span class="built_in">NSIndexPath</span> *indexPath2 = [_tableView indexPathForCell:cell];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"所属行数：%ld"</span>,(<span class="keyword">long</span>)indexPath2.row+<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过设置delegate，将button的点击事件交给viewController完成。</p>
<h2 id="编辑UITableView"><a href="#编辑UITableView" class="headerlink" title="编辑UITableView"></a>编辑UITableView</h2><h3 id="编辑模式下的UITableView"><a href="#编辑模式下的UITableView" class="headerlink" title="编辑模式下的UITableView"></a>编辑模式下的UITableView</h3><h4 id="进入编辑模式"><a href="#进入编辑模式" class="headerlink" title="进入编辑模式"></a>进入编辑模式</h4><p>通过调用<code>[_tableView setEditing:!_tableView.isEditing animated:true]</code>进入编辑模式,可实现添加，删除，移动操作。<br>默认是删除，即cell左边出现一个红色的减号，点击可以删除该行。</p>
<h4 id="TableView-编辑行"><a href="#TableView-编辑行" class="headerlink" title="TableView 编辑行"></a>TableView 编辑行</h4><p>使用<strong>setEditing:animated:</strong>方法让tableView进入编辑模式.可以使用<strong>tableView:canEditRowAtIndexPath</strong>方法筛选能进入编辑模式的行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)tableView:(<span class="built_in">UITableView</span> *)tableView canEditRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">if</span>(indexPath.row == (<span class="number">10</span> | <span class="number">12</span> | <span class="number">14</span>))&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果不实现该方法，默认为YES。</p>
<h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>通过设置<code>UITableViewCellEditingStyle</code>可以切换进入的编辑模式是实现插入还是删除操作。这个返回值将作为下面的<code>commitEditingStyle:forRowAtIndexPath:</code>方法的入参传入。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCellEditingStyle</span>)tableView:(<span class="built_in">UITableView</span> *)tableView editingStyleForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UITableViewCellEditingStyleInsert</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">   		<span class="keyword">return</span> <span class="built_in">UITableViewCellEditingStyleDelete</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="编辑模式下的插入和删除行"><a href="#编辑模式下的插入和删除行" class="headerlink" title="编辑模式下的插入和删除行"></a>编辑模式下的插入和删除行</h4><p>实现<code>tableView:commitEditingStyle:forRowAtIndexPath:</code>方法。传入三个参数。<br>第一个实参是发送该消息的UITableView对象。<br>第二个实参是<code>UITableViewCellEditingStyle</code>类型的常数(删除表格行时，传入的是<code>UITableViewCellEditingStyleDelete</code>;插入表格行时，传入的是<code>UITableViewCellEditingStyleInsert</code>)。<br>第三个实参是一个NSIndexPath对象。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView commitEditingStyle:(<span class="built_in">UITableViewCellEditingStyle</span>)editingStyle forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">if</span> (editingStyle == <span class="built_in">UITableViewCellEditingStyleDelete</span>) &#123;</div><div class="line">        [<span class="keyword">self</span>.dataSource removeObjectAtIndex:indexPath.row];</div><div class="line">        [<span class="keyword">self</span>.tableView deleteRowsAtIndexPaths:[<span class="built_in">NSArray</span> arrayWithObject:indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (editingStyle == <span class="built_in">UITableViewCellEditingStyleInsert</span>)&#123;</div><div class="line">    	[<span class="keyword">self</span>.dataSource insertObject:<span class="string">@"我是新来的"</span> atIndex:indexPath.row];</div><div class="line">        [_tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationBottom</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<code>deleteRowsAtIndexPaths</code>和<code>insertRowsAtIndexPaths</code>可以进行局部刷新，节省资源，并且还能添加指定动画。<br>delete操作可以不在编辑模式的情况下，通过左滑cell直接触发。插入则必须进入编辑模式。</p>
<h4 id="cell的移动"><a href="#cell的移动" class="headerlink" title="cell的移动"></a>cell的移动</h4><p>进入编辑模式后<br>实现<code>tableView:moveRowAtIndexPath:</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView moveRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class="built_in">NSIndexPath</span> *)destinationIndexPath&#123;</div><div class="line">    <span class="keyword">if</span>(sourceIndexPath == destinationIndexPath)&#123;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        Comment *comment = [<span class="keyword">self</span>.dataSource objectAtIndex:sourceIndexPath.row];</div><div class="line">        [<span class="keyword">self</span>.dataSource removeObjectAtIndex:sourceIndexPath.row];</div><div class="line">        [<span class="keyword">self</span>.dataSource insertObject:comment atIndex:destinationIndexPath.row];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一定要对数据源进行正确操作。</p>
<h4 id="TableView-修改删除按钮"><a href="#TableView-修改删除按钮" class="headerlink" title="TableView 修改删除按钮"></a>TableView 修改删除按钮</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"删除"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不在编辑模式下的编辑方式"><a href="#不在编辑模式下的编辑方式" class="headerlink" title="不在编辑模式下的编辑方式"></a>不在编辑模式下的编辑方式</h3><h4 id="刷新方式"><a href="#刷新方式" class="headerlink" title="刷新方式"></a>刷新方式</h4><p>简单总结一些UITableView的刷新方法：</p>
<ul>
<li>reloadData                                    刷新整个表格</li>
<li>reloadRowsAtIndexPaths:withRowAnimation:        刷新indexPath指向的cell</li>
<li>reloadSections:withRowAnimation:                刷新NSIndexSet内包含的Section</li>
</ul>
<p>这三个分别刷新tableview的各个部分<br>第一个没有动画效果。<br>第二个可以传入一个数组<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[_tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationTop</span>];</div></pre></td></tr></table></figure></p>
<p>第三个可以传入一个NSIndexSet集合<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.tableView reloadSections:[<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">2</span>)] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</div><div class="line">[_tableView reloadSections:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:indexPath.section]withRowAnimation:<span class="built_in">UITableViewRowAnimationLeft</span>];</div></pre></td></tr></table></figure></p>
<h4 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h4><p>在编辑模式下的插入删除方式，可以直接用在任何想用的场景下，只需要调用一下方法，并且保持dataSource正确即可。</p>
<ul>
<li>deleteRowsAtIndexPaths:withRowAnimation:</li>
<li>insertRowsAtIndexPaths:withRowAnimation:</li>
</ul>
<p>就不举例了。同上面一样。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIButton 简介]]></title>
      <url>http://zhang759740844.github.io/2016/08/29/UIButton%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>从最基础的控件开始一点点学习。先来总结下UIButton。</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *btn1 = [[<span class="built_in">UIButton</span> alloc] init];</div><div class="line"><span class="built_in">CGRect</span> btn1Frame = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>);</div><div class="line">btn1.frame = btn1Frame;</div><div class="line">[<span class="keyword">self</span>.view addSubview:btn1];</div></pre></td></tr></table></figure>
<p>通过<code>init</code>和设置<code>frame</code>以及<code>addSubView</code>就可以将button添加到Voew上。</p>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><h4 id="通过xib关联"><a href="#通过xib关联" class="headerlink" title="通过xib关联"></a>通过xib关联</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)btn2Pressed:(<span class="keyword">id</span>)sender&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击操作"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与xib关联即可，其中<code>(id)sender</code>就表示的是这个Button</p>
<h4 id="通过代码"><a href="#通过代码" class="headerlink" title="通过代码"></a>通过代码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加</span></div><div class="line">[btn1 addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btn1Pressed:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"><span class="comment">//移除</span></div><div class="line">[btn1 removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btn1Pressed:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>为<code>btn1</code>添加和删除一个<code>btn1Pressed</code>的点击事件。</p>
<h2 id="设置title和image"><a href="#设置title和image" class="headerlink" title="设置title和image"></a>设置title和image</h2><p>button有<code>imageView</code>和<code>titleLabel</code>两个属性，默认image在左，label在右。</p>
<h3 id="添加title和image"><a href="#添加title和image" class="headerlink" title="添加title和image"></a>添加title和image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[btn1 setImage:[UIImage imageNamed:@&quot;Image&quot;] forState:UIControlStateNormal];</div><div class="line">[btn1 setTitle:@&quot;BTN1&quot; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>
<p>这里<code>forState</code>常用的有一下几种：</p>
<ul>
<li>UIControlStateNormal          常态</li>
<li>UIControlStateHighlighted     高亮</li>
<li>UIControlStateDisabled        禁用</li>
<li>UIControlStateSelected        选中</li>
</ul>
<p>其中需要说明的是，高亮就是点击时的状态。其实还有一种<code>UIControlStateSelected | UIControlStateHighlighted</code>这个组合是选中时候的高亮状态，也是比较有用的。</p>
<h3 id="设置button选中"><a href="#设置button选中" class="headerlink" title="设置button选中"></a>设置button选中</h3><p>button选中与否是由<code>UIControlStateSelected</code>控制的。</p>
<p>可能会遇到这样的情景：点击一下button切换成另外一个图，再点一下切换回去，实际上就是类似于<em>点赞</em>。一般情况我们实现方式是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)buttonClick:(<span class="built_in">UIButton</span> *)button &#123;</div><div class="line">    <span class="keyword">if</span> ([button.currentImage isEqual:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"like"</span>]]) &#123;</div><div class="line">        [button setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"like_selected"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [button setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"like"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是最好不要这样实现。可以使用<code>UIControlStateSelected</code>来控制：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[btn1 setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Image"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">[btn1 setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Image2"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</div><div class="line"></div><div class="line"><span class="comment">//点击事件</span></div><div class="line">- (<span class="keyword">void</span>)btn1Pressed:(<span class="built_in">UIButton</span> *)button&#123;</div><div class="line">    <span class="comment">//button.enabled 设置是否可点击。</span></div><div class="line">    button.selected = !button.selected;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，每次点击的时候切换选中状态达到效果。</p>
<p>但是，这样处理会遇到这样一个问题:不管按钮从normal状态转为selected状态,还是反过来,中间都会经历一个highLighted状态,这就导致在状态切换的过程中有一次图片的跳变。</p>
<p>因此，需要将normal-&gt;selected以及selected-&gt;normal之间的highlight都设置一下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//normal-&gt;selected</span></div><div class="line">[btn1 setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Image"</span>] forState:<span class="built_in">UIControlStateHighlighted</span>];</div><div class="line"><span class="comment">//selected-&gt;normal</span></div><div class="line">[btn1 setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Image2"</span>] forState:<span class="built_in">UIControlStateSelected</span> | <span class="built_in">UIControlStateHighlighted</span>];</div></pre></td></tr></table></figure></p>
<p>好的，这样就完成了切换状态的过程。</p>
<h3 id="设置image和title位置"><a href="#设置image和title位置" class="headerlink" title="设置image和title位置"></a>设置image和title位置</h3><p>image和title默认image在左，title紧贴在其右边。不过这个位置其实是可以改变的。</p>
<h4 id="image和title位置互换"><a href="#image和title位置互换" class="headerlink" title="image和title位置互换"></a>image和title位置互换</h4><p>先看代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[btn1 setTitleEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, -btn1.imageView.bounds.size.width, <span class="number">0</span>, btn1.imageView.bounds.size.width)];</div><div class="line">[btn1 setImageEdgeInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, btn1.titleLabel.bounds.size.width, <span class="number">0</span>, -btn1.titleLabel.bounds.size.width)];</div></pre></td></tr></table></figure></p>
<p>这里需要强调的是一定要先设置<code>title</code>再设置<code>image</code>。因为<code>title</code>是依赖于<code>image</code>的，在如果先设置<code>image</code>，这个时候<code>title</code>还没有确定，于是<code>titleLabel.bounds.size.width</code>一定是<code>0</code>，即<code>image</code>没有变。</p>
<p>这里的<code>UIEdgeInsetsMake</code>里的四个参数分别是<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>四个方向的<code>inset</code>,默认是<code>0</code>，也就是说，所有变化都是针对当前位置的。<code>-btn1.imageView.bounds.size.width</code>表示让<code>title</code>的左边距<strong>减少</strong><code>image</code>的宽度，同理<code>btn1.imageView.bounds.size.width</code>表示让右边距<strong>增加</strong><code>image</code>的宽度。</p>
<h4 id="控制image的大小"><a href="#控制image的大小" class="headerlink" title="控制image的大小"></a>控制image的大小</h4><p>交换了image的位置后，我就想怎么控制image的大小。尝试改变了<code>UIEdgeInsetsMake</code>的参数，发现改变<code>top</code>和<code>bottom</code>可以将图片压缩，但是改变<code>left</code> <code>right</code>图片始终不动。</p>
<p>经过我不断尝试后终于得出了结论：<br>以横轴为例，只有当<strong>左边距+右边距+图片宽度=button宽度</strong>时，继续增加边距，才会导致图片的压缩。当<strong>左边距+右边距+图片宽度&lt;button宽度</strong>时，增加一边会让图像像另一边移动；同时增加两边，两边抵消，在原处不动。</p>
<p>因此，为什么改变<code>top</code>和<code>bottom</code>可以将图片压缩呢？因为由于button高度较小，image在纵轴将button填满，此时<code>top</code>和<code>bottom</code>都为0，但是由于<strong>image高度=button高度</strong>，此时增加<code>top</code>和<code>bottom</code>就会将图片压缩。当然，如果一个增加，一个等量减小，图片就会像减少那边移动。</p>
<p>而在横轴方面，开始时，<strong>左边距+右边距+图片宽度&lt;button宽度</strong>。图片只会平移直到边距增加到使等式相等才会进行压缩。</p>
<p>就是这样<del>O(∩_∩)O</del></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git技巧]]></title>
      <url>http://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>虽然一直使用sourcetree，还是应该对git指令做一些了解的。本篇将列举使用中遇到的关于git的一些使用技巧。不定期更新。</p>
<a id="more"></a>
<h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>ios中pod的第三方库经常会被<code>gitignore</code>掉，让使用者自己下载。</p>
<p>想要达到一个效果：使文件脱离git的版本管理，但不是会删除它.</p>
<h3 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h3><p>可以使用<code>git rm --cached file</code><br>Git 将不再跟踪此文件，尽管它仍然是在您的硬盘上.<br>对于文件夹，可以使用<code>git rm -r --cached file</code>取消关联整个文件夹。</p>
<h3 id="使用sourcetree"><a href="#使用sourcetree" class="headerlink" title="使用sourcetree"></a>使用sourcetree</h3><p>在sourcetree中操作要麻烦一些。在添加完<code>gitignore</code>后，将想要ignore的文件移出git目录，然后<code>commit</code>该操作，再将文件移回来。这个时候文件就被ignore了。</p>
<p>需要注意的是，一定要先执行<code>commit</code>操作。因为，在<code>.git</code>中存在了pod的版本控制的文件关联，添加了<code>gitignore</code>后，git并不会主动将pod文件关联删掉。<br>因此，需要先用<code>commit</code>将该文件关联删除，才能正确ignore该文件夹。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里的移除相当于执行了 <code>rm 文件</code>的操作，因而需要使用<code>commit</code>,而使用命令行的<code>git rm 文件</code>则是通过git指令，直接移除了关联。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>不管是什么项目总是需要添加新文件的。添加新文件即add，但是从github上clone的框架总是不能自动添加到本地的git版本里。可能是由于clone的框架本生带有<code>.git</code>的缘故吧。</p>
<p>因此，如果当git不能自动添加文件关联的时候，需要使用<code>git add 文件</code>的方式手动添加。</p>
<p>使用sourcetree时，也可以将要添加的部分先保存在其他地方，然后将文件夹内的文件复制到想要放的地方。这样隐藏的<code>.git</code>不会被复制，文件也就能添加进sourcetree了。</p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>merge可以说是很常用的一个功能，用于代码合并。</p>
<p>不过由于之前没真正用过，用起来还比较死板。比如，学的时候留下刻板印象就是，将feature branch合并进develop用merge，但是刚刚遇到要把develop合并到feature branch的时候就忘掉merge这个功能了。<strong>只要是关乎于不同branch的代码进行合并都可以用merge啊</strong>。</p>
<p>好吧。可能只是我蠢而已。稍微做个记录，证明自己曾蠢过。但愿不要一直蠢下去。</p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>变基操作是git常用的一个功能，这里不再说明其作用，而是强调一下他的风险。</p>
<p>变基操作的一条准则是：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>
<blockquote>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>
</blockquote>
<p>也就是说：变基操作将强行改变仓库的提交情况。注意，是丢弃不是删除，git对于这种丢弃没有任何记录。</p>
<p>如下图所示，<code>C5</code>是其他分支的合并。先将master重置到<code>C1</code>的提交，然后rebase<code>C5</code>所在分支，得到新的提交<code>C4&#39;</code>。一般情况下，git是不允许这样的提交到remote的，但是可以使用<code>git push --force</code>强制覆盖remote的仓库。这样<code>C4``C6</code>就不复存在了。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_1.png?raw=true" alt="git_rebase_1"></p>
<p>话分两头，别人也有自己的本地master，并且别人已经合并了之前的提交<code>C6</code>到<code>C7</code>，如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_2.png?raw=true" alt="git_rebase_2"></p>
<p>由于别人的本地git并不知道<code>C4``C6</code>已经由于rebase被删除。比对仓库信息后，在它看来，就是remote的master有了一个新的提交<code>C4&#39;</code>，于是就拉取，但是本地git一看远端提交<code>C4&#39;</code>和本地提交<code>C4``C6</code>都修改了相同的文件，那就产生冲突了啊。那么别人就必须要合并这两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/git_rebase_3.png?raw=true" alt="git_rebase_3"></p>
<p>这样就比较尴尬了，因为当时使用rebase就是为了删掉<code>C4``C6</code>，但是别人这么一合并一提交，<code>C4``C6</code>又全回来了。</p>
<p>如果只是单人开发，变基操作没有任何危险，想怎么变怎么变。但是在多人开发，切记<strong>只把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令</strong>。假如你在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那么问题就大了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识Provisioning Profile]]></title>
      <url>http://zhang759740844.github.io/2016/08/26/%E5%88%9D%E8%AF%86Provisioning_Profile/</url>
      <content type="html"><![CDATA[<p>真机调试的时候遇到了<em>provisioning profile即将过期</em>的警告，于是搜索并对provisioning profile作了一定了解。结合<a href="http://www.cnblogs.com/cywin888/p/3263027.html" target="_blank" rel="external">关于Certificate、Provisioning Profile、App ID的介绍及其之间的关系</a>进行梳理。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。在Xcode Build Setting(点击工程文件)的Code Signing Identity中，你可以设置用于为代码签名的证书。</p>
<p>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。 </p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/profile_certificate.png?raw=true" alt="证书的私钥和公钥"></p>
<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发（生产，上架Appstore）应用程序（根据证书种类有不同作用）</p>
<h3 id="APP-ID"><a href="#APP-ID" class="headerlink" title="APP ID"></a>APP ID</h3><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>
<ul>
<li>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。</li>
<li>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</li>
</ul>
<p>每创建一个App ID，我们都可以设置该App ID所使用的APP Services，也就是其所使用的额外服务。每种额外服务都有着不同的要求，例如，如果要使用Apple Push Notification Services，则必须是一个explicit App ID，以便能唯一标识一个应用程序。</p>
<h3 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h3><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>
<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>
<h3 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h3><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。</p>
<p>试想一下，如果我们要打包或者在真机上运行一个应用程序，我们首先需要证书来进行签名，用来标识这个应用程序是合法的、安全的、完整的等等；然后需要指明它的App ID，并且验证Bundle ID是否与其一致；再次，如果是真机调试，需要确认这台设备能否用来运行程序。而Provisioning Profile就把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样我们只要在不同的情况下选择不同的profile文件就可以了。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>
<p>例如，如下图所示，一个用于Development的Provisioning Profile中包含了该Provisioning Profile对应的App ID，可使用的证书和设备。这意味着使用这个Provisioning Profile打包程序必须拥有相应的证书，并且是将App ID对应的程序运行到Devices中包含的设备上去。</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_consist.png?raw=true" alt="Provisioning Profile组成"></p>
<p>如上所述，在一台设备上运行应用程序的过程如下：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Provisioning_Profile_Confirm.png?raw=true" alt="Provisioning Profile验证"></p>
<p>与证书一样，Provisioning Profile也分为Development和Distribution两种</p>
<h2 id="Xcode-7-免证书真机调试"><a href="#Xcode-7-免证书真机调试" class="headerlink" title="Xcode 7+ 免证书真机调试"></a>Xcode 7+ 免证书真机调试</h2><p>在Xcode 7+ 中，苹果改变了自己在许可权限上的策略，此前Xcode只开放给注册开发者下载，但Xcode 7改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。此前开发者需每年支付99美元的费用成为注册开发者才能在iPhone、iPad、Apple Watch等真机上运行代码，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在真机设备上测试app</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>打开自己已有的工程或者打开Xcode新建一个简单工程</li>
<li>菜单栏选择Xcode,下拉菜单中选择Preferences…(快捷键 command + , )<br> <img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebug.png?raw=true" alt="1"></li>
<li>在Accounts选项卡添加自己的Apple ID。添加完成后你会看到这样的信息。可以看到下面显示了iOS和Mac的Free标记了，在这之前是没有这些标记的。<br> <img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg2.png?raw=true" alt="2"></li>
<li>将测试的iPhone或者其他真机测试设备连接Mac，Xcode选中真机测试设备，直接点击运行。<br> <img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg3.png?raw=true" alt="3"></li>
<li>Xcode报错如下图所示，直接点击Fix Issue。<br> <img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg4.png?raw=true" alt="4"></li>
<li>警告也没了，证书也生成了，重新点击run按钮，可以开始愉快的玩耍了😁。<br> <img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/NoCertificateDebg5.png?raw=true" alt="5"></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tableview自适应高度]]></title>
      <url>http://zhang759740844.github.io/2016/08/26/UITableview%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>由于tableview的cell的高度会随着内部label以及textview字符长度的变化而变化，因此不能一味的设置heightForRowAtIndexPath为定值。</p>
<a id="more"></a>
<h2 id="设置布局约束"><a href="#设置布局约束" class="headerlink" title="设置布局约束"></a>设置布局约束</h2><p>在UITableViewCell子类中，添加约束，使子视图的边缘与contentView的边缘固定。确保每个子视图在垂直方向上的内容压缩阻力(compression resistance)和内容吸附性约束(content hugging constraints)没有被你添加的更高优先级的约束覆盖，以使得这些子视图的固有内容尺寸(intrinsic content size)来推动contentView的高度。</p>
<p>记住，重点是cell的子视图与contentView要有垂直方向上的连结，让它们能够对contentView“施加压力”，使contentView扩张以适合它们的尺寸。</p>
<p>下面用一个带有一些子视图的cell作为示例，展示了一些必要的约束（没有展示全部的约束）：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/tableviewautolayout1.png?raw=true" alt="布局示例"></p>
<p>可以想象，当更多的文本被添加到“Multi-line body”那个label上面后，它就需要垂直地增高以适应文本，这实际上将强迫cell增加高度。</p>
<p><strong>需要注意的是：</strong></p>
<ol>
<li>如果没有设置好约束，比如:缺失了“Multi-line body”那个label到底部的约束，那么高度极有可能变成0；</li>
<li>label要显示多行，需要将其<code>Lines</code>设置为0。</li>
<li>题外话，如果不是在cell里的label要设置高度包含文字的话，可以少设置一个约束，这样布局的时候会自动撑满整个label。</li>
</ol>
<h2 id="cell的自适应"><a href="#cell的自适应" class="headerlink" title="cell的自适应"></a>cell的自适应</h2><h3 id="label的ios8实现"><a href="#label的ios8实现" class="headerlink" title="label的ios8实现"></a>label的ios8实现</h3><p>在iOS8上，苹果将许多在之前你比较难实现的东西都内置实现了。为了让cell实现自适应（self-sizing），必须先将tableView的<code>rowHeight</code>属性设置为常量<code>UITableViewAutomaticDimension</code>。然后，只需将tableView的<code>estimatedRowHeight</code>属性设置为一个非零值即可开启行高估算功能,如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</div><div class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">44.0</span>; <span class="comment">// 设置为一个接近于行高“平均值”的数值</span></div></pre></td></tr></table></figure></p>
<p>这样就为tableView提供了一个还没有被显示在屏幕上的cell的临时估算的行高。当cell即将滚入屏幕范围内的时候，会计算出真实的高度。为了确定每一行的实际高度，tableView会自动让每个cell基于其contentView的已知固定宽度（tableView的宽度减去其他额外的，像section index或accessoryView这些宽度）和被添加到contentView及其子视图上的布局约束来计算<code>contentView</code>的高度。真实的行高被计算出来之后，旧的估算的行高会被更新为这个真实的行高（并且其他任何需要对tableView的contentSize或contentOffset的更改都自动替你完成）。</p>
<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在<code>viewDidLoad</code>或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>
<h3 id="label的ios7实现"><a href="#label的ios7实现" class="headerlink" title="label的ios7实现"></a>label的ios7实现</h3><p>首先，实例化一个离屏(offscreen)的cell实例，为每个重用标示符实例化一个与之对应的cell实例，这些cell实例严格的仅用于高度计算。（离屏表示cell的引用被存储在view controller的一个属性或实例变量之中，并且这个cell绝对不会被用作<code>tableView:cellForRowAtIndexPath:</code>方法的返回值显示在屏幕上。）接下来，这个cell的内容（例如，文本、图片等等）还必须被配置为与显示在table view中的内容完全一样。<br><strong>因为要在<code>heightForRowAtIndexPath</code>中计算高度，需要一个cell实例，这个离屏cell就是为了这个用的。</strong></p>
<p>然后，强制cell立即更新子视图的布局，再在cell的<code>contentView</code>上调用<code>systemLayoutSizeFittingSize:</code>方法以计算出cell所需的高度。使用<code>UILayoutFittingCompressedSize</code>参数得到适合cell中所有内容所需的最小尺寸。然后将其高度作为<code>tableView:heightForRowAtIndexPath:</code>方法的返回值返回给table view。</p>
<p>通过<code>systemLayoutSizeFittingSize:</code>方法计算出的高度还需要加1才是真正的高度，这个1pt高度是cell分割线的高度。</p>
<p>iOS7中，你可以（也绝对应当）使用table view的<code>estimatedRowHeight</code>属性。这样会为还不在屏幕范围内的cell提供一个临时估算的行高值。然后，当这些cell即将要滚入屏幕范围内的时候，真实的行高值会被计算出来（通过<code>tableView:heightForRowAtIndexPath:</code>方法），估算的行高会被替换掉。</p>
<p>一般来说，行高的估算值不需要太精确——它只是用来修正tableView中滚动条的尺寸的，当你在屏幕上滑动cell的时候，即使估算值不准确，tableView还是能很好地调节滚动条。将tableView的<code>estimatedRowHeight</code>属性设置成（在viewDidLoad或类似的方法中）一个接近于行高“平均值”的常量值即可。仅在行高极端变化的时候（比如相差一个数量级），滚动过程中才会产生滚动条的“跳跃”现象。这个时候，你才需要考虑实现<code>tableView:estimatedHeightForRowAtIndexPath:</code>方法，为每一行返回一个更精确的估算值。</p>
<p>这样就是将第一次加载时时间消耗降低，但是在加载每个view的时候都要动态计算每一个cell的高度，即滑动时比较耗时，需要使用一个缓存将高度存取，同时这个缓存要能应对cell高度的变化进行修改。</p>
<p>示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    _cell.label.text = [_data objectAtIndex:indexPath.row];</div><div class="line">    <span class="built_in">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>];</div><div class="line">    <span class="built_in">CGFloat</span> height = textHeight.height+<span class="number">1</span>&gt;<span class="number">90</span>?textHeight.height+<span class="number">1</span>:<span class="number">90</span>;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="textView的自适应"><a href="#textView的自适应" class="headerlink" title="textView的自适应"></a>textView的自适应</h3><p>textViewz在tableview中用的不多，但是其自适应高度方式和label有所不同。因为调用<code>systemLayoutSizeFittingSize</code>方法返回的高度并不包含textview的高度，需要调用<code>sizeThatFits</code>方法获得textview的完整高度，然后将两个高度相加才能得到cell真正的高度。</p>
<p>示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    _cell.textView.text = [_data objectAtIndex:indexPath.row];</div><div class="line">    <span class="built_in">CGSize</span> textHeight = [_cell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>];</div><div class="line">    <span class="built_in">CGSize</span> textViewSize = [_cell.textView sizeThatFits:<span class="built_in">CGSizeMake</span>(_cell.textView.frame.size.width, FLT_MAX)];</div><div class="line">    <span class="built_in">CGFloat</span> h  = textHeight.height + textViewSize.height;</div><div class="line">    <span class="built_in">CGFloat</span> height = h+<span class="number">1</span>&gt;<span class="number">90</span>?h+<span class="number">1</span>:<span class="number">90</span>;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UITableView-FDTemplateLayoutCell使用简介"><a href="#UITableView-FDTemplateLayoutCell使用简介" class="headerlink" title="UITableView+FDTemplateLayoutCell使用简介"></a>UITableView+FDTemplateLayoutCell使用简介</h2><p>这是一个由国人团队开发的优化计算 UITableViewCell 高度的轻量级框架。主要也是通过<code>systemLayoutSizeFittingSize</code>方法计算高度，但是该框架通过<strong>缓存</strong>及<strong>预加载</strong>将效率大幅的地提高。</p>
<p>这里就不具体分析该框架的实现原理了。可以参考<a href="http://blog.qiji.tech/archives/9538?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">框架学习</a>跟进。</p>
<p>这里主要列举下使用方法,其实在<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">forkingdog的github</a>上都有，我这里只是摘录下。</p>
<h3 id="基本使用-不带cache"><a href="#基本使用-不带cache" class="headerlink" title="基本使用(不带cache)"></a>基本使用(不带cache)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UITableView+FDTemplateLayoutCell.h"</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [tableView fd_heightForCellWithIdentifier:<span class="string">@"reuse identifer"</span> configuration:^(<span class="keyword">id</span> cell) &#123;</div><div class="line">        <span class="comment">// Configure this cell with data, same as what you've done in "-tableView:cellForRowAtIndexPath:"</span></div><div class="line">        <span class="comment">// Like:</span></div><div class="line">        <span class="comment">//    cell.entity = self.feedEntities[indexPath.row];</span></div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候需要将一个实例化后的cell作为block传入。如之前讲到的，<code>systemLayoutSizeFittingSize:</code>所必须的。</p>
<h3 id="带cache的方法"><a href="#带cache的方法" class="headerlink" title="带cache的方法"></a>带cache的方法</h3><h4 id="以indexPath区分"><a href="#以indexPath区分" class="headerlink" title="以indexPath区分"></a>以indexPath区分</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="keyword">return</span> [tableView fd_heightForCellWithIdentifier:<span class="string">@"identifer"</span> cacheByIndexPath:indexPath configuration:^(<span class="keyword">id</span> cell) &#123;</div><div class="line">        <span class="comment">// configurations</span></div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缓存下每个indexPath对应的高度。</p>
<h4 id="以key区分"><a href="#以key区分" class="headerlink" title="以key区分"></a>以key区分</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    Entity *entity = <span class="keyword">self</span>.entities[indexPath.row];</div><div class="line">    <span class="keyword">return</span> [tableView fd_heightForCellWithIdentifier:<span class="string">@"identifer"</span> cacheByKey:entity.uid configuration:^(<span class="keyword">id</span> cell) &#123;</div><div class="line">        <span class="comment">// configurations</span></div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户将要展示的cell分类，然后将分类的key传入。</p>
<h3 id="Frame-layout-mode"><a href="#Frame-layout-mode" class="headerlink" title="Frame layout mode"></a>Frame layout mode</h3><p>对于<code>Auto layout mode</code>和<code>Frame layout mode</code>。框架提供了两种方式，默认是自动布局。 </p>
<h3 id="再次注意"><a href="#再次注意" class="headerlink" title="再次注意"></a>再次注意</h3><p>需要再次提醒的是，如上文所说，一个好的自适应cell，一定要将cell内subview的上下左右约束设置好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime应用笔记]]></title>
      <url>http://zhang759740844.github.io/2016/08/23/runtime%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>了解了runtime的基本原理，那么runtime究竟有什么用处呢？参考<a href="http://www.jianshu.com/p/efeb33712445" target="_blank" rel="external">Runtime全方位装逼指南</a>，总结了以下几点应用场景。</p>
<a id="more"></a>
<h2 id="给category添加属性"><a href="#给category添加属性" class="headerlink" title="给category添加属性"></a>给category添加属性</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>对象关联</strong>允许开发者对已经存在的类在 Category 中添加自定义的属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</div></pre></td></tr></table></figure></p>
<ul>
<li>object 是源对象.</li>
<li>value 是被关联的对象.</li>
<li>key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.</li>
<li>policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, associatedKey, <span class="literal">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>
<p>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>新建 UIButton 的 Category，在其中设置clickBlock属性(UIButton+ClickBlock.h):<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^clickBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">ClickBlock</span>)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) clickBlock click;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在.m中设置click的set，get方法(UIButton+ClickBlock.m):<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIButton+ClickBlock.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *associatedKey = <span class="string">"associatedKey"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">ClickBlock</span>)</span></div><div class="line"></div><div class="line"><span class="comment">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setClick:(clickBlock)click&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    [<span class="keyword">self</span> removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">    <span class="keyword">if</span> (click) &#123;</div><div class="line">        [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(clickBlock)click&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, associatedKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)buttonClick&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.click) &#123;</div><div class="line">        <span class="keyword">self</span>.click();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>其中，在set方法中使用<code>addTarget:action:forControlEvents:</code>给button设置了点击事件。</p>
<p><code>self.click()</code>表示使用<code>self.click</code>获得block，再通过<code>block()</code>执行块。</p>
<p>为什么不直接给click赋值，而是通过runtime的<code>objc_setAssociatedObject</code>方法呢？<br>@property属性会在编译时自动生成一个实例变量_click以及其set，get方法。但是由于runtime只能添加方法，不能添加实例变量。因此，_click并没有添加进UIButton的ivar中，因而不能使用。只能通过runtime的方法，添加对应键值对。</p>
<p>@property在本例中只是为了在.h里声明一个getset方法。可替换成：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^clickBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">ClickBlock</span>)</span></div><div class="line"><span class="comment">//@property (nonatomic,copy) clickBlock click;</span></div><div class="line">- (clickBlock)click;</div><div class="line">- (<span class="keyword">void</span>)setClick:(clickBlock)click;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h2 id="字典与模型转换"><a href="#字典与模型转换" class="headerlink" title="字典与模型转换"></a>字典与模型转换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>字典转模型的时候：</p>
<ol>
<li>根据字典的 key 生成 setter 方法.</li>
<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>
</ol>
<p>模型转字典的时候：</p>
<ol>
<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>
<li>调用 property_getName 获取属性名称.</li>
<li>根据属性名称生成 getter 方法.</li>
<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">KeyValues</span>)</span></div><div class="line"></div><div class="line">+(<span class="keyword">id</span>)objectWithKeyValues:(<span class="built_in">NSDictionary</span> *)aDictionary;</div><div class="line"></div><div class="line">-(<span class="built_in">NSDictionary</span> *)keyValuesWithObject;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"NSObject+KeyValues.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KeyValues</span>)</span></div><div class="line"></div><div class="line"><span class="comment">//字典转模型</span></div><div class="line">+(<span class="keyword">id</span>)objectWithKeyValues:(<span class="built_in">NSDictionary</span> *)aDictionary&#123;</div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> aDictionary.allKeys) &#123;</div><div class="line">        <span class="keyword">id</span> value = aDictionary[key];</div><div class="line">        </div><div class="line">        <span class="comment">/*判断当前属性是不是Model*/</span></div><div class="line">        objc_property_t property = class_getProperty(<span class="keyword">self</span>, key.UTF8String);</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class="line">        objc_property_attribute_t attribute = attributeList[<span class="number">0</span>];</div><div class="line">        <span class="built_in">NSString</span> *typeString = [<span class="built_in">NSString</span> stringWithUTF8String:attribute.value];</div><div class="line">        <span class="keyword">if</span> ([typeString isEqualToString:<span class="string">@"@\"TestModel\""</span>]) &#123;</div><div class="line">            value = [<span class="keyword">self</span> objectWithKeyValues:value];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**********************/</span></div><div class="line">        </div><div class="line">        <span class="comment">//生成setter方法，并用objc_msgSend调用</span></div><div class="line">        <span class="built_in">NSString</span> *methodName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>,[key substringToIndex:<span class="number">1</span>].uppercaseString,[key substringFromIndex:<span class="number">1</span>]];</div><div class="line">        SEL <span class="keyword">setter</span> = sel_registerName(methodName.UTF8String);</div><div class="line">        <span class="keyword">if</span> ([objc respondsToSelector:<span class="keyword">setter</span>]) &#123;</div><div class="line">            ((<span class="keyword">void</span> (*) (<span class="keyword">id</span>,SEL,<span class="keyword">id</span>)) objc_msgSend) (objc,<span class="keyword">setter</span>,value);</div><div class="line">        &#125;</div><div class="line">        free(attributeList);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//模型转字典</span></div><div class="line">-(<span class="built_in">NSDictionary</span> *)keyValuesWithObject&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">    objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">        objc_property_t property = propertyList[i];</div><div class="line">        </div><div class="line">        <span class="comment">//生成getter方法，并用objc_msgSend调用</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</div><div class="line">        SEL <span class="keyword">getter</span> = sel_registerName(propertyName);</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>]) &#123;</div><div class="line">            <span class="keyword">id</span> value = ((<span class="keyword">id</span> (*) (<span class="keyword">id</span>,SEL)) objc_msgSend) (<span class="keyword">self</span>,<span class="keyword">getter</span>);</div><div class="line">            </div><div class="line">            <span class="comment">/*判断当前属性是不是Model*/</span></div><div class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] &amp;&amp; value) &#123;</div><div class="line">                value = [value keyValuesWithObject];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**********************/</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (value) &#123;</div><div class="line">                <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:propertyName];</div><div class="line">                [dict setObject:value forKey:key];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    free(propertyList);</div><div class="line">    <span class="keyword">return</span> dict;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)keyValuesTest&#123;</div><div class="line">    </div><div class="line">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name is %@"</span>,model.name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"son name is %@"</span>,model.son.name);</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *dict = [model keyValuesWithObject];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dict is %@"</span>,dict);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>在NSObject中添加类方法，其中的<code>self</code>指的是<code>TestModel</code>这个类。</li>
<li><code>objc_property_t</code>具有两个属性，name和attribute。调用<code>property_getAttribute</code>将返回attribute的字符串。调用<code>property_copyAttributeList</code>则将字符串切分，返回一个<code>objc_property_attribute_t</code>类型的指针，<code>outCount</code>返回了属性的数量。</li>
</ol>
<hr>
<p>outCount使用了<strong>指向指针的指针</strong>的方式，使没有返回outCount的情况下，修改了outCount的值。</p>
<p>例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)scanBeginStr:(<span class="built_in">NSString</span> *)beginstr endStr:(<span class="built_in">NSString</span> *)endstr inText:(<span class="built_in">NSMutableString</span> * *)textPointer&#123;</div><div class="line">    <span class="built_in">NSRange</span> range1,range2;</div><div class="line">    <span class="built_in">NSUInteger</span> location =<span class="number">0</span>,length=<span class="number">0</span>;</div><div class="line">    range1.location = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSMutableString</span> *text = *textPointer;</div><div class="line">    <span class="built_in">NSMutableArray</span> *rangeArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">while</span> (range1.location != <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        range1 = [text rangeOfString:beginstr];</div><div class="line">        range2 = [text rangeOfString:endstr];</div><div class="line">        <span class="keyword">if</span> (range1.location != <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">            location = range1.location;</div><div class="line">            length = range2.location - range1.location - <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (length &gt; <span class="number">5000</span>)<span class="keyword">break</span>;</div><div class="line">            [text replaceOccurrencesOfString:beginstr withString:<span class="string">@""</span> options:<span class="built_in">NSCaseInsensitiveSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, range1.location + range1.length)];</div><div class="line">            [text replaceOccurrencesOfString:endstr withString:<span class="string">@""</span> options:<span class="built_in">NSCaseInsensitiveSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, range2.location + range2.length - <span class="number">1</span>)];</div><div class="line">        &#125;</div><div class="line">        [rangeArray addObject:@&#123;<span class="string">@"location"</span>:@(location),<span class="string">@"length"</span>:@(length)&#125;];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rangeArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用：通过&amp;取指针的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *rangeArray = [self scanBegin3Str:@&quot;&lt;&quot; endStr:@&quot;&gt;&quot; inText:&amp;mutableText];</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="自动归档"><a href="#自动归档" class="headerlink" title="自动归档"></a>自动归档</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>归档是一种很常用的文件储存方法，几乎任何类型的对象都能够被归档储存。自动归档就是动态获取model的各个属性，进行保存：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.ID forKey:<span class="string">@"ID"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.ID = [aDecoder decodeObjectForKey:<span class="string">@"ID"</span>];</div><div class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果当前 Model 有100个属性的话，就需要写100行这种代码.通过 Runtime 我们就可以轻松解决这个问题：</p>
<ol>
<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>
<li>使用 ivar_getName 方法获取成员变量的名称.</li>
<li>通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"TestModel.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestModel</span></span></div><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">    Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">        Ivar var = vars[i];</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</div><div class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</div><div class="line">        </div><div class="line">        <span class="comment">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></div><div class="line">        <span class="comment">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></div><div class="line">        <span class="comment">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></div><div class="line">        <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];</div><div class="line">        [aCoder encodeObject:value forKey:key];</div><div class="line">    &#125;</div><div class="line">    free(vars);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">        Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">            Ivar var = vars[i];</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</div><div class="line">            <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</div><div class="line">            <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];</div><div class="line">            [<span class="keyword">self</span> setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(vars);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)keyedArchiverTest&#123;</div><div class="line">    </div><div class="line">    TestModel *model = [TestModel objectWithKeyValues:dictionary];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</div><div class="line">    path = [path stringByAppendingPathComponent:<span class="string">@"test"</span>];</div><div class="line">    [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:model toFile:path];</div><div class="line">    </div><div class="line">    TestModel *m = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"m.name is %@"</span>,m.name);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"m.son name is %@"</span>,m.son.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="动态方法解析与消息转发"><a href="#动态方法解析与消息转发" class="headerlink" title="动态方法解析与消息转发"></a>动态方法解析与消息转发</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>消息转发的大致过程如图：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_dynamicMethod.jpg?raw=true" alt="消息转发流程"></p>
<ol>
<li>当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>(添加实例方法实现和类方法实现)来给程序员一次动态添加方法实现的机会，指定是否动态添加方法。若返回<code>NO</code>，则进入下一步，若返回<code>YES</code>，则通过 <code>class_addMethod</code> 函数动态地添加方法，消息得到处理，此流程完毕.</li>
<li><code>resolveInstanceMethod:</code> 方法返回 <code>NO</code> 时，就会进入 <code>forwardingTargetForSelector:</code> 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 <code>selector</code>。返回<code>nil</code>，进入下一步，返回某个对象，则会调用该对象的方法.</li>
<li>若 <code>forwardingTargetForSelector:</code> 返回的是<code>nil</code>，则我们首先要通过 <code>methodSignatureForSelector:</code> 来指定方法签名，返回<code>nil</code>，表示不处理，若返回方法签名，则会进入下一步.</li>
<li>当第 <code>methodSignatureForSelector:</code> 方法返回方法签名后，就会调用 <code>forwardInvocation:</code> 方法，我们可以通过 <code>anInvocation</code> 对象做很多处理，比如修改实现方法，修改响应对象等.</li>
<li>如果到最后，消息还是没有得到响应，程序就会crash.</li>
</ol>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Monkey.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Monkey</span></span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)jump&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"monkey can not fly, but! monkey can jump"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     如果当前对象调用了一个不存在的方法</div><div class="line">     Runtime会调用resolveInstanceMethod:来进行动态方法解析</div><div class="line">     我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作</div><div class="line">     返回NO，则进入下一步forwardingTargetForSelector:</div><div class="line">     */</div><div class="line">    </div><div class="line">	<span class="keyword">if</span>(sel == <span class="keyword">@selector</span>(fly))&#123;</div><div class="line">    	class_addMethod(<span class="keyword">self</span>, sel, class_getMethodImplementation(<span class="keyword">self</span>, sel_registerName(<span class="string">"jump"</span>)), <span class="string">"v@:"</span>);</div><div class="line">    	<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     在消息转发机制执行前，Runtime 系统会再给我们一次重定向的机会</div><div class="line">     通过重载forwardingTargetForSelector:方法来替换消息的接受者为其他对象</div><div class="line">     返回nil则进步下一步forwardInvocation:</div><div class="line">     */</div><div class="line">    </div><div class="line"><span class="meta">#if 0</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"><span class="meta">#else</span></div><div class="line">    <span class="keyword">return</span> [[Bird alloc] init];</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     获取方法签名进入下一步，进行消息转发</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     消息转发</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [anInvocation invokeWithTarget:[[Bird alloc] init]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其中 <code>&quot;v@:&quot;</code> 表示返回值和参数,这个符号涉及<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="external">Type Encoding</a>以及<a href="http://www.jianshu.com/p/f4129b5194c0" target="_blank" rel="external">关于type encodings的理解–runtime programming guide</a>。</p>
<hr>
<p>其中<strong>v</strong>表示返回<code>void</code>类型，<strong>@</strong>表示参数<code>id(self)</code>，<strong>：</strong>表示<code>SEL(_cmd)</code>这几个是必须要有的，后面可以接入参类型。</p>
<p>举个例子：<code>&quot;i@:@&quot;</code><br><strong>i</strong>表示返回值类型<code>int</code><br><strong>@：</strong>和上面意义相同<br><strong>@</strong>最后一个@表示有一个入参，是<code>id</code>类型。</p>
<p>不过，实际上，这个东西好像没什么用，因为在<code>class_addMethod</code>上试验过，随便传任何字符串都一样能正常运行。</p>
<hr>
<p>一般来说可以使用<code>method_getTypeEncoding()</code>获取更详细的Type_Encoding,下面例子中也会用到。</p>
<h3 id="转发与多继承"><a href="#转发与多继承" class="headerlink" title="转发与多继承"></a>转发与多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_transmit.png?raw=true" alt="runtime_transmit"></p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>
<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>
<h2 id="Runtime-动态创建类添加属性和方法"><a href="#Runtime-动态创建类添加属性和方法" class="headerlink" title="Runtime-动态创建类添加属性和方法"></a>Runtime-动态创建类添加属性和方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)createClass</div><div class="line">&#123;</div><div class="line">    Class MyClass = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">"myclass"</span>, <span class="number">0</span>);</div><div class="line">    <span class="comment">//添加一个NSString的变量，第四个参数是对其方式，第五个参数是参数类型</span></div><div class="line">    <span class="keyword">if</span> (class_addIvar(MyClass, <span class="string">"itest"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="string">"@"</span>)) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"add ivar success"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//myclasstest是已经实现的函数，"v@:"这种写法见type encoding</span></div><div class="line">    class_addMethod(MyClass, <span class="keyword">@selector</span>(myclasstest:), (IMP)myclasstest, <span class="string">"v@:"</span>);</div><div class="line">    <span class="comment">//注册这个类到runtime系统中就可以使用他了</span></div><div class="line">    objc_registerClassPair(MyClass);</div><div class="line">    <span class="comment">//生成了一个实例化对象</span></div><div class="line">    <span class="keyword">id</span> myobj = [[MyClass alloc] init];</div><div class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"asdb"</span>;</div><div class="line">    <span class="comment">//给刚刚添加的变量赋值</span></div><div class="line">    <span class="comment">//    object_setInstanceVariable(myobj, "itest", (void *)&amp;str);在ARC下不允许使用</span></div><div class="line">    [myobj setValue:str forKey:<span class="string">@"itest"</span>];</div><div class="line">    <span class="comment">//调用myclasstest方法，也就是给myobj这个接受者发送myclasstest这个消息</span></div><div class="line">    [myobj myclasstest:<span class="number">10</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//这个方法实际上没有被调用,但是必须实现否则编译都不能通过</span></div><div class="line">- (<span class="keyword">void</span>)myclasstest:(<span class="keyword">int</span>)a</div><div class="line">&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">//调用的是这个方法</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> myclasstest(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">int</span> a) <span class="comment">//self和_cmd是必须的，在之后可以随意添加其他参数</span></div><div class="line">&#123;</div><div class="line">    </div><div class="line">    Ivar v = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"itest"</span>);</div><div class="line">    <span class="comment">//返回名为itest的ivar的变量的值</span></div><div class="line">    <span class="keyword">id</span> o = object_getIvar(<span class="keyword">self</span>, v);</div><div class="line">    <span class="comment">//成功打印出结果</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, o);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"int a is %d"</span>, a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>此部分参考自<a href="http://blog.csdn.net/horkychen/article/details/8532087" target="_blank" rel="external">Objective-C的方法替换</a>、<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a>等系列文章</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span> </span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>) </span></div><div class="line"> </div><div class="line">+ (<span class="keyword">void</span>)load &#123; </div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class="line">        Class aClass = [<span class="keyword">self</span> <span class="keyword">class</span>]; </div><div class="line"> </div><div class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:); </div><div class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:); </div><div class="line"> </div><div class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </div><div class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </div><div class="line">        </div><div class="line">        <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">        <span class="comment">// Class aClass = object_getClass((id)self);</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class="line">        <span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div><div class="line"> </div><div class="line">        <span class="built_in">BOOL</span> didAddMethod = </div><div class="line">            class_addMethod(aClass, </div><div class="line">                originalSelector, </div><div class="line">                method_getImplementation(swizzledMethod), </div><div class="line">                method_getTypeEncoding(swizzledMethod)); </div><div class="line"> </div><div class="line">        <span class="keyword">if</span> (didAddMethod) &#123; </div><div class="line">            class_replaceMethod(aClass, </div><div class="line">                swizzledSelector, </div><div class="line">                method_getImplementation(originalMethod), </div><div class="line">                method_getTypeEncoding(originalMethod)); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </div><div class="line">        &#125; </div><div class="line">    &#125;); </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="meta">#pragma mark - Method Swizzling </span></div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123; </div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>); </div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>
<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。如下图<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_1.png?raw=true" alt="runtime_swizzling_1"></p>
<p>通过Swizzling需要实现的是偷换selector的IMP，如下图所示：<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_swizzling_2.png?raw=true" alt="runtime_swizzling_2"></p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>
<p>实现Swizzling需要考虑两种情况，第一种是被替换方法没有在当前类中重写过，而是只在其父类中实现了;第二种情况是这个方法已经存在于当前类中，就如本例中想要替换掉<code>UIViewController</code>中的<code>viewWillAppear:</code>方法。这两种情况要区别对待。</p>
<p>对于第一种情况，由于当前类内没有这个方法，应当现在当前类中添加一个新的实现方法(<code>xxx_viewWillAppear:</code>)，然后将复写的方法替换为原先的实现(<code>viewWillAppear:</code>).</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> didAddMethod = </div><div class="line">    class_addMethod(aClass, </div><div class="line">        originalSelector, </div><div class="line">        method_getImplementation(swizzledMethod), </div><div class="line">        method_getTypeEncoding(swizzledMethod));</div></pre></td></tr></table></figure>
<p><code>class_addMethod</code>将本来不存在于被操作的Class里的<code>swizzledMethod</code>的实现添加在被操作的Class里,并使用<code>originalSelector</code>作为其选择子。如果发现方法已经存在，会失败返回。</p>
<hr>
<p>通过上一篇<a href="https://zhang759740844.github.io/2016/08/22/runtime原理/">runtime原理</a>的分析，<code>class_addMethod</code>应该是先在类的method数组里找是否有这个<code>SEL</code>,如果没有就添加一个<code>method_t</code>。</p>
<hr>
<p>如果添加成功(当前类中没有重写过父类的该方法)，再把目标类中的方法替换为旧有的实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (didAddMethod) &#123; </div><div class="line">    class_replaceMethod(aClass, </div><div class="line">        swizzledSelector, </div><div class="line">        method_getImplementation(originalMethod), </div><div class="line">        method_getTypeEncoding(originalMethod));</div></pre></td></tr></table></figure></p>
<p><code>addMethod</code>会让当前类的方法(IMP)指向新的实现(SEL)，使用<code>replaceMethod</code>再将新的方法(IMP)指向原先的实现(SEL)，这样就完成了交换操作。现在通过旧方法<code>SEL</code>来调用，就会实现新方法的<code>IMP</code>，通过新方法的<code>SEL</code>来调用，就会实现旧方法的<code>IMP</code>。</p>
<p>如果添加失败了，就是第二情况(方法已经在当前类中实现过了)。这时可以通过<code>method_exchangeImplementations</code>直接交换两个<code>method_t</code>的<code>IMP</code>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    method_exchangeImplementations(originalMethod, overrideMethod);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以本例中由于<code>viewWillAppear:</code>已经在UIViewController中实现过了，所以，<code>class_addMethod</code>失败，通过<code>method_exchangeImplementations</code>达到交换实现。如果要通过<code>class_addMethod</code>添加，需要自定义一个View继承UIViewController，再在这个类中替换<code>viewWillAppear:</code>。</p>
<p>如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现。</p>
<p><code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IMP imp1 = method_getImplementation(m1);</div><div class="line">IMP imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p>
<p>直接设置了<code>method</code>:<code>m1</code>,<code>m2</code>的<code>IMP</code>，简单暴力。</p>
<p>对于注释了的这几行:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// When swizzling a class method, use the following:</span></div><div class="line"><span class="comment">// Class aClass = object_getClass((id)self);</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></div><div class="line"><span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></div></pre></td></tr></table></figure></p>
<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object实例 class]</code> 的区别：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>object_getClass()</code>方法返回对象的<code>isa</code>。</p>
<p>最后，<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]换成[self viewWillAppear:animated]</code>反而会引发死循环。</p>
<blockquote>
<p>Demo 详见RuntimeLearn</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 常用內建模块]]></title>
      <url>http://zhang759740844.github.io/2016/08/23/python_%E5%B8%B8%E7%94%A8%E5%85%A7%E5%BB%BA%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><h4 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h4><p>datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime导入的才是datetime这个类。<br>如果仅导入import datetime，则必须引用全名datetime.datetime。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now() <span class="comment"># 获取当前datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(now)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">07.198690</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(now))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">datetime</span>.<span class="title">datetime</span>'&gt;</span></div></pre></td></tr></table></figure></p>
<p>datetime.now()返回当前日期和时间，其类型是datetime。</p>
<h4 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h4><p>要指定某个日期和时间，我们直接用参数构造一个datetime：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(dt)</div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p>
<h4 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h4><p>把一个datetime类型转换为timestamp只需要简单调用<strong>timestamp()</strong>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></div><div class="line"><span class="number">1429417200.0</span></div></pre></td></tr></table></figure></p>
<p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。<br>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法.</p>
<h4 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h4><p>要把timestamp转换为datetime，使用datetime提供的<strong>fromtimestamp()</strong>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p>
<h4 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h4><p>转换方法是通过<strong>datetime.strptime()</strong>实现，需要一个日期和时间的格式化字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2015-6-1 18:19:59'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(cday)</div><div class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-01</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></div></pre></td></tr></table></figure></p>
<h4 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h4><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</div><div class="line">Mon, May <span class="number">05</span> <span class="number">16</span>:<span class="number">28</span></div></pre></td></tr></table></figure></p>
<h4 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h4><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</div></pre></td></tr></table></figure></p>
<p>使用timedelta你可以很容易地算出前几天和后几天的时刻</p>
<h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>
<h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</div><div class="line"><span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment"># namedtuple('名称', [属性list]):</span></div><div class="line">Circle = namedtuple(<span class="string">'Circle'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'r'</span>])</div></pre></td></tr></table></figure></p>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。<br><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">'x'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">'y'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q</div><div class="line">deque([<span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'x'</span>])</div></pre></td></tr></table></figure></p>
<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">'N/A'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] = <span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] <span class="comment"># key1存在</span></div><div class="line"><span class="string">'abc'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key2'</span>] <span class="comment"># key2不存在，返回默认值</span></div><div class="line"><span class="string">'N/A'</span></div></pre></td></tr></table></figure></p>
<p>注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h4><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></div><div class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></div><div class="line">OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</div></pre></td></tr></table></figure></p>
<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>
<h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'programming'</span>:</div><div class="line"><span class="meta">... </span>    c[ch] = c[ch] + <span class="number">1</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c</div><div class="line">Counter(&#123;<span class="string">'g'</span>: <span class="number">2</span>, <span class="string">'m'</span>: <span class="number">2</span>, <span class="string">'r'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'i'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">1</span>, <span class="string">'p'</span>: <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure></p>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime原理笔记]]></title>
      <url>http://zhang759740844.github.io/2016/08/22/runtime%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近尝试往category中添加实例变量失败，但是可以添加方法。于是，研究了一下runtime的实现和使用。runtime的原理展开来分析的话还是挺复杂的。下载了最新的源码（objc4-680）,发现和现在网上的多数教程还是有出入的，跟进起来很困难。<br>所以尝试自己整理了一下，加了一些自己的理解，具体细节可能有些小出入。参考文章：<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a><br><a id="more"></a></p>
<h2 id="Runtime基础"><a href="#Runtime基础" class="headerlink" title="Runtime基础"></a>Runtime基础</h2><p>在Objective-C中，使用<code>[receiver message]</code>语法并不会马上执行<code>receiver</code>对象的<code>message</code>方法的代码，而是向<code>receiver</code>发送一条<code>message</code>消息。<br>其实<code>[receiver message]</code>被编译器转化为:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> objc_msgSend ( <span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ... );</div></pre></td></tr></table></figure></p>
<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>,它是一个指向<code>objc_object</code>结构体指针,它包含一个<code>Class isa</code>指针(完整的定义在<code>objc_private.h</code>中)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型.<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>这个结构体在<code>runtime.h</code>中有定义:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>其中<code>OBJC2_UNAVAILABLE</code>表示：在objc2中这些属性已经不在此定义。</p>
<p>在objc2中，<code>objc_class</code>的完整定义在<code>objc-runtime-new.h</code>中：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></div><div class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></div><div class="line"></div><div class="line">    class_rw_t *data() &#123; </div><div class="line">        <span class="keyword">return</span> bits.data();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>和<code>runtime.h</code>中的定义对比，少了许多属性，多出一个<code>bits</code>属性。这些属性都包含在了<code>class_rw_t</code>的<code>data</code>对象中。</p>
<p>注意到<code>objc_class</code>中也有一个<code>isa</code>对象(继承自<code>objc_object</code>)，这是因为一个ObjC类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做 <strong>元类 (Meta Class)</strong>的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。<strong>类方法就定义于此处</strong>，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。<br>当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个<strong>类对象 (Class Object)</strong> ，这个类对象必须是一个元类的实例，而这个元类同时也是一个<strong>根元类 (root meta class)</strong>的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code>这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。<br><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/runtime_principle.jpg?raw=true" alt="Class isa and superclass relationship"></p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> class_rw_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>const class_ro_t *ro</code>包含了所有<strong>成员变量</strong>的一维数组以及<strong>各个基础的(base)属性、方法和协议</strong><br><code>method_array_t methods</code>、<code>property_array_t properties</code>、<code>protocol_array_t protocols</code>则包含了所有<strong>拓展的属性方法和协议</strong>。<strong>注意：这里的属性只是getset方法，不包含成员变量。</strong><br>这也就解释了，开篇不能添加成员变量的原因。</p>
<p>具体如何应用可看下一篇。</p>
<h3 id="部分类的声明"><a href="#部分类的声明" class="headerlink" title="部分类的声明"></a>部分类的声明</h3><p>这部分将上面涉及的类的声明贴出以供参照，可以直接跳过。</p>
<h4 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t:"></a>class_ro_t:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> class_ro_t &#123;</div><div class="line">	...</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h4><p><code>method_list_t</code>和<code>method_array_t</code>内都是<code>method_t</code>类型:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> method_t &#123;</div><div class="line">    SEL name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</div><div class="line">    IMP imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>方法名类型为<code>SEL</code></li>
<li>方法类型<code>types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>imp</code>指向了方法的实现，本质上是一个函数指针</li>
</ul>
<h4 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ivar_t &#123;</div><div class="line">    int32_t *offset;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h4><p><code>ivar_list_t</code>和<code>ivar_array_t</code>内都是<code>ivar_t</code>类型:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> property_t &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h4><p><code>protocol_list_t</code>和<code>protocol_array_t</code>内都是<code>protocol_t</code>类型:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> protocol_t : objc_object &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</div><div class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</div><div class="line">    method_list_t *instanceMethods;</div><div class="line">    method_list_t *classMethods;</div><div class="line">    method_list_t *optionalInstanceMethods;</div><div class="line">    method_list_t *optionalClassMethods;</div><div class="line">    property_list_t *instanceProperties;</div><div class="line">    uint32_t size;   <span class="comment">// sizeof(protocol_t)</span></div><div class="line">    uint32_t flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="Ivar-Method-Category-objc-property-t"><a href="#Ivar-Method-Category-objc-property-t" class="headerlink" title="Ivar,Method,Category,objc_property_t"></a>Ivar,Method,Category,objc_property_t</h4><p>外部可以通过一系列的方法获得类的信息，诸如：<code>class_copyIvarList</code>,<code>class_copyPropertyList</code>等方法，可以获得类的实例变量和属性，对应的类型是<code>Ivar</code>、<code>objc_property_t</code>，它们分别是<code>ivar_t</code>,<code>property_t</code>类型的指针。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ivar_t *Ivar;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> category_t *Category;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t *objc_property_t;</div></pre></td></tr></table></figure>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h3 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h3><p>看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 <code>selector</code> 是不是要忽略的。比如有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>
<li>检测这个 <code>target</code> 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code>对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了.</li>
</ol>
<p>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>Super</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>stret</code>的函数。</p>
<p>当我们调用<code>[super selector]</code> 时，Runtime 会调用 <code>objc_msgSendSuper</code>方法，<code>objc_msgSendSuper</code> 方法有两个参数，<code>super</code> 和 <code>op</code>，<code>Runtime</code> 会把 <code>selector</code> 方法选择器赋值给 <code>op</code>。而 <code>super</code> 是一个 <code>objc_super</code> 结构体指针，<code>objc_super</code> 结构体定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_super &#123; <span class="keyword">id</span> receiver; Class <span class="keyword">class</span>; &#125;;</div></pre></td></tr></table></figure></p>
<p>需要注意的是：这里的<code>receiver</code>仍然是<code>self</code>本身。当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>
<p>举个栗子，问下面的代码输出什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></div><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>答案是全部输出 <code>Son</code>.</p>
<p>当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 函数：</p>
<ol>
<li>先构造 <code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code>。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>.</li>
<li>去 <code>Father</code> 这个类里去找 <code>- (Class)class</code>，没有，然后去 <code>NSObject</code> 类去找，找到了。最后内部是使用 <code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code> 去调用，此时已经和 <code>[self class]</code> 调用相同了，所以两个输出结果都是 <code>Son</code>。</li>
</ol>
<p>这里调用<code>class</code>只是举例，所有调用<code>super</code>的方法，最后都变成了<code>self</code>的调用。</p>
<h2 id="Category-的实现原理"><a href="#Category-的实现原理" class="headerlink" title="Category 的实现原理"></a>Category 的实现原理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</div><div class="line">└──<span class="keyword">const</span> <span class="keyword">char</span> \*map_2_images(...)</div><div class="line">    └──<span class="keyword">const</span> <span class="keyword">char</span> \*map_images_nolock(...)</div><div class="line">        └──<span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount)</div><div class="line">        	└──<span class="keyword">static</span> <span class="keyword">void</span> remethodizeClass(Class cls)</div><div class="line">        		└──<span class="keyword">static</span> <span class="keyword">void</span> attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</div></pre></td></tr></table></figure></p>
<h3 id="Category-相关的数据结构"><a href="#Category-相关的数据结构" class="headerlink" title="Category 相关的数据结构"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> category_t &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    classref_t cls;</div><div class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</div><div class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</div><div class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</div><div class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>
<h3 id="处理-Category"><a href="#处理-Category" class="headerlink" title="处理 Category"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 attachCategories 的简化版代码:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches) &#123;</div><div class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</div><div class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></div><div class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = cats-&gt;count;</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        auto&amp; entry = cats-&gt;list[i];</div><div class="line"></div><div class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        <span class="keyword">if</span> (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    auto rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">    free(mlists);</div><div class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，通过 <code>while</code> 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。</p>
<p>在 <code>while</code> 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto rw = cls-&gt;data();</div><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div></pre></td></tr></table></figure></p>
<p><code>rw</code> 是一个 <code>class_rw_t</code>类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</div><div class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    uint32_t oldCount = array()-&gt;count;</div><div class="line">    uint32_t newCount = oldCount + addedCount;</div><div class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">    array()-&gt;count = newCount;</div><div class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</div><div class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>
<p><a href="http://www.jianshu.com/p/9d649ce6d0b8" target="_blank" rel="external">runtime的一篇较好的参考资料</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 正则表达式]]></title>
      <url>http://zhang759740844.github.io/2016/08/20/python_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>\d可以匹配一个数字</li>
<li>\w可以匹配一个字母或数字</li>
<li>.可以匹配任意字符</li>
<li>*表示任意个字符（包括0个）</li>
<li>用+表示至少一个字符</li>
<li>用?表示0个或1个字符</li>
<li>用{n}表示n个字符</li>
<li>用{n,m}表示n-m个字符</li>
<li>\s可以匹配一个空格（也包括Tab等空白符）</li>
<li>要做更精确地匹配，可以用[]表示范围    <ul>
<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线</li>
</ul>
</li>
<li>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线<ul>
<li>(P|p)ython可以匹配’Python’或者’python’</li>
</ul>
</li>
<li>^表示行的开头</li>
<li>$表示行的结束</li>
<li>^py$就变成了整行匹配,就只能匹配’py’</li>
</ul>
<h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>Python提供re模块，包含所有正则表达式的功能。<br>Python的字符串本身也用\转义，因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = <span class="string">r'ABC\-001'</span> <span class="comment"># Python的字符串</span></div><div class="line"><span class="comment"># 对应的正则表达式字符串不变：</span></div><div class="line"><span class="comment"># 'ABC\-001'</span></div></pre></td></tr></table></figure></p>
<p>match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test = <span class="string">'用户输入的字符串'</span></div><div class="line"><span class="keyword">if</span> re.match(<span class="string">r'正则表达式'</span>, test):</div><div class="line">    print(<span class="string">'ok'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'failed'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[\s\,\;]+'</span>, <span class="string">'a,b;; c  d'</span>)</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：<strong>^(\d{3})-(\d{3,8})$</strong>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)</div><div class="line"><span class="string">'010-12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'010'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'12345'</span></div></pre></td></tr></table></figure></p>
<p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure></p>
<p>由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。<br>必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 编译:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</div><div class="line"><span class="comment"># 使用：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</div></pre></td></tr></table></figure></p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 进程与线程]]></title>
      <url>http://zhang759740844.github.io/2016/08/18/python_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><h4 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h4><p>multiprocessing模块就是跨平台版本的多进程模块。<br>multiprocessing模块提供了一个Process类来代表一个进程对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 子进程要执行的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</div><div class="line">    print(<span class="string">'Child process will start.'</span>)</div><div class="line">    p.start()</div><div class="line">    p.join()</div><div class="line">    print(<span class="string">'Child process end.'</span>)</div></pre></td></tr></table></figure></p>
<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。<br>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class="line">    start = time.time()</div><div class="line">    time.sleep(random.random() * <span class="number">3</span>)</div><div class="line">    end = time.time()</div><div class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">    p = Pool(<span class="number">4</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        p.apply_async(long_time_task, args=(i,))</div><div class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</div><div class="line">    p.close()</div><div class="line">    p.join()</div><div class="line">    print(<span class="string">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Parent process <span class="number">669.</span></div><div class="line">Waiting <span class="keyword">for</span> all subprocesses done...</div><div class="line">Run task <span class="number">0</span> (<span class="number">671</span>)...</div><div class="line">Run task <span class="number">1</span> (<span class="number">672</span>)...</div><div class="line">Run task <span class="number">2</span> (<span class="number">673</span>)...</div><div class="line">Run task <span class="number">3</span> (<span class="number">674</span>)...</div><div class="line">Task <span class="number">2</span> runs <span class="number">0.14</span> seconds.</div><div class="line">Run task <span class="number">4</span> (<span class="number">673</span>)...</div><div class="line">Task <span class="number">1</span> runs <span class="number">0.27</span> seconds.</div><div class="line">Task <span class="number">3</span> runs <span class="number">0.86</span> seconds.</div><div class="line">Task <span class="number">0</span> runs <span class="number">1.41</span> seconds.</div><div class="line">Task <span class="number">4</span> runs <span class="number">1.91</span> seconds.</div><div class="line">All subprocesses done.</div></pre></td></tr></table></figure></p>
<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。<br>注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = ool(5)</code>就可以同时跑5个进程。</p>
<h4 id="子进程-amp-进程间通信"><a href="#子进程-amp-进程间通信" class="headerlink" title="子进程&amp;进程间通信"></a>子进程&amp;进程间通信</h4><p>到时候再看</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time, threading</div><div class="line"></div><div class="line"><span class="comment"># 新线程执行的代码:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</div><div class="line">    n = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">        print(<span class="string">'thread %s &gt;&gt;&gt; %s'</span> % (threading.current_thread().name, n))</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</div><div class="line"></div><div class="line">print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</div><div class="line">t = threading.Thread(target=loop, name=<span class="string">'LoopThread'</span>)</div><div class="line">t.start()</div><div class="line">t.join()</div><div class="line">print(<span class="string">'thread %s ended.'</span> % threading.current_thread().name)</div></pre></td></tr></table></figure></p>
<p>执行结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">thread MainThread <span class="keyword">is</span> running...</div><div class="line">thread LoopThread <span class="keyword">is</span> running...</div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">1</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">2</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">3</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">4</span></div><div class="line">thread LoopThread &gt;&gt;&gt; <span class="number">5</span></div><div class="line">thread LoopThread ended.</div><div class="line">thread MainThread ended.</div></pre></td></tr></table></figure>
<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">balance = <span class="number">0</span></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">        <span class="comment"># 先要获取锁:</span></div><div class="line">        lock.acquire()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="comment"># 放心地改吧:</span></div><div class="line">            change_it(n)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            <span class="comment"># 改完了一定要释放锁:</span></div><div class="line">            lock.release()</div></pre></td></tr></table></figure></p>
<p>创建一个锁就是通过threading.Lock()来实现.当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></div><div class="line">local_school = threading.local()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 获取当前线程关联的student:</span></div><div class="line">    std = local_school.student</div><div class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></div><div class="line">    local_school.student = name</div><div class="line">    process_student()</div><div class="line"></div><div class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</div><div class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</div><div class="line">t1.start()</div><div class="line">t2.start()</div><div class="line">t1.join()</div><div class="line">t2.join()</div></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, Alice (<span class="keyword">in</span> Thread-A)</div><div class="line">Hello, Bob (<span class="keyword">in</span> Thread-B)</div></pre></td></tr></table></figure>
<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>
<p>可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<h3 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h3><p>用到再看</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios核心动画]]></title>
      <url>http://zhang759740844.github.io/2016/08/16/ios%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>依旧是<a href="http://www.cnblogs.com/wendingding/tag/UI高级/" target="_blank" rel="external">文顶顶的ios开发UI篇</a>关于核心动画的内容。作为入门</p>
<p><strong>核心动画主要就是按照设定的规则(重复，延迟，持续时间等)，操作layer或者view的一些属性(position,bound,transform等)。</strong></p>
<a id="more"></a>
<h2 id="核心动画简介"><a href="#核心动画简介" class="headerlink" title="核心动画简介"></a>核心动画简介</h2><p>CAAnimation是所有动画类的父类，但是它不能直接使用，能用的动画类只有4个子类：CABasicAnimation、CAKeyframeAnimation、CATransition、CAAnimationGroup。</p>
<p>CAPropertyAnimation是CAAnimation的子类，但是不能直接使用，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation<br>它有个NSString类型的keyPath属性，你可以指定CALayer的某个属性名为keyPath，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就会修改CALayer的position属性的值，以达到平移的动画效果</p>
<p>常见属性：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatDuration：动画的重复时间</li>
<li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li>
<li>fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后</li>
<li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li>
<li>timingFunction：速度控制函数，控制动画运行的节奏</li>
<li>delegate：动画代理</li>
</ul>
<h2 id="基础动画"><a href="#基础动画" class="headerlink" title="基础动画"></a>基础动画</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CABasicAnimation，是CApropertyAnimation的子类</p>
<p>属性：</p>
<ul>
<li>fromValue：keyPath相应属性的初始值</li>
<li>toValue：keyPath相应属性的结束值</li>
</ul>
<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>
<p>如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但<strong>在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</strong>比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">CALayer</span> *myLayer;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">//创建layer</span></div><div class="line">    <span class="built_in">CALayer</span> *myLayer=[<span class="built_in">CALayer</span> layer];</div><div class="line">    <span class="comment">//设置layer的属性</span></div><div class="line">    myLayer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">80</span>);</div><div class="line">    myLayer.backgroundColor=[<span class="built_in">UIColor</span> yellowColor].CGColor;</div><div class="line">    myLayer.position=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">50</span>);</div><div class="line">    myLayer.anchorPoint=<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    myLayer.cornerRadius=<span class="number">20</span>;</div><div class="line">    <span class="comment">//添加layer</span></div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:myLayer];</div><div class="line">    <span class="keyword">self</span>.myLayer=myLayer;</div><div class="line">&#125;</div><div class="line"><span class="comment">//设置 平移 动画</span></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.创建核心动画</span></div><div class="line">    <span class="comment">//    CABasicAnimation *anima=[CABasicAnimation animationWithKeyPath:&lt;#(NSString *)#&gt;]</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> *anima=[<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    </div><div class="line">    <span class="comment">//1.1告诉系统要执行什么样的动画</span></div><div class="line">    anima.keyPath=<span class="string">@"position"</span>;</div><div class="line">    <span class="comment">//设置通过动画，将layer从哪儿移动到哪儿</span></div><div class="line">    anima.fromValue=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>)];</div><div class="line">    anima.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">300</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">//1.2设置动画执行完毕之后不删除动画</span></div><div class="line">    anima.removedOnCompletion=<span class="literal">NO</span>;</div><div class="line">    <span class="comment">//1.3设置保存动画的最新状态</span></div><div class="line">    anima.fillMode=kCAFillModeForwards;</div><div class="line"></div><div class="line">    <span class="comment">//2.添加核心动画到layer</span></div><div class="line">    [<span class="keyword">self</span>.myLayer addAnimation:anima forKey:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始执行动画"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag</div><div class="line">&#123;</div><div class="line">    <span class="comment">//动画执行完毕，打印执行完毕后的position值</span></div><div class="line">    <span class="built_in">NSString</span> *str=<span class="built_in">NSStringFromCGPoint</span>(<span class="keyword">self</span>.myLayer.position);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行后：%@"</span>,str);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其中keypath的值决定产生什么动画</p>
<ol>
<li>position：执行平移动画</li>
<li>bounds：执行缩放动画</li>
<li>transform：执行旋转动画</li>
</ol>
<h2 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CAKeyframeAnimation，是CApropertyAnimation的子类。CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>
<p>属性：</p>
<ul>
<li>values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>
<li>path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</li>
<li>keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>
</ul>
<p>说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="使用value"><a href="#使用value" class="headerlink" title="使用value"></a>使用value</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *customView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.创建核心动画</span></div><div class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyAnima=[<span class="built_in">CAKeyframeAnimation</span> animation];</div><div class="line">    <span class="comment">//平移</span></div><div class="line">    keyAnima.keyPath=<span class="string">@"position"</span>;</div><div class="line">    <span class="comment">//1.1告诉系统要执行什么动画</span></div><div class="line">    <span class="built_in">NSValue</span> *value1=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</div><div class="line">    <span class="built_in">NSValue</span> *value2=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">100</span>)];</div><div class="line">    <span class="built_in">NSValue</span> *value3=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">200</span>)];</div><div class="line">    <span class="built_in">NSValue</span> *value4=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">200</span>)];</div><div class="line">    <span class="built_in">NSValue</span> *value5=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</div><div class="line">    keyAnima.values=@[value1,value2,value3,value4,value5];</div><div class="line">    <span class="comment">//1.2设置动画执行完毕后，不删除动画</span></div><div class="line">    keyAnima.removedOnCompletion=<span class="literal">NO</span>;</div><div class="line">    <span class="comment">//1.3设置保存动画的最新状态</span></div><div class="line">    keyAnima.fillMode=kCAFillModeForwards;</div><div class="line">    <span class="comment">//1.4设置动画执行的时间</span></div><div class="line">    keyAnima.duration=<span class="number">4.0</span>;</div><div class="line">    <span class="comment">//1.5设置动画的节奏</span></div><div class="line">    keyAnima.timingFunction=[<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    </div><div class="line">    <span class="comment">//设置代理，开始—结束</span></div><div class="line">    keyAnima.delegate=<span class="keyword">self</span>;</div><div class="line">    <span class="comment">//2.添加核心动画</span></div><div class="line">    [<span class="keyword">self</span>.customView.layer addAnimation:keyAnima forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始动画"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"结束动画"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="使用path"><a href="#使用path" class="headerlink" title="使用path"></a>使用path</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *customView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.创建核心动画</span></div><div class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyAnima=[<span class="built_in">CAKeyframeAnimation</span> animation];</div><div class="line">    <span class="comment">//平移</span></div><div class="line">    keyAnima.keyPath=<span class="string">@"position"</span>;</div><div class="line">    <span class="comment">//1.1告诉系统要执行什么动画</span></div><div class="line">    <span class="comment">//创建一条路径</span></div><div class="line">    <span class="built_in">CGMutablePathRef</span> path=<span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="comment">//设置一个圆的路径</span></div><div class="line">    <span class="built_in">CGPathAddEllipseInRect</span>(path, <span class="literal">NULL</span>, <span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    keyAnima.path=path;</div><div class="line">    </div><div class="line">    <span class="comment">//有create就一定要有release</span></div><div class="line">    <span class="built_in">CGPathRelease</span>(path);</div><div class="line">    <span class="comment">//1.2设置动画执行完毕后，不删除动画</span></div><div class="line">    keyAnima.removedOnCompletion=<span class="literal">NO</span>;</div><div class="line">    <span class="comment">//1.3设置保存动画的最新状态</span></div><div class="line">    keyAnima.fillMode=kCAFillModeForwards;</div><div class="line">    <span class="comment">//1.4设置动画执行的时间</span></div><div class="line">    keyAnima.duration=<span class="number">5.0</span>;</div><div class="line">    <span class="comment">//1.5设置动画的节奏</span></div><div class="line">    keyAnima.timingFunction=[<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    </div><div class="line">    <span class="comment">//设置代理，开始—结束</span></div><div class="line">    keyAnima.delegate=<span class="keyword">self</span>;</div><div class="line">    <span class="comment">//2.添加核心动画</span></div><div class="line">    [<span class="keyword">self</span>.customView.layer addAnimation:keyAnima forKey:<span class="string">@"wendingding"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)stopOnClick:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    <span class="comment">//停止self.customView.layer上名称标示为wendingding的动画</span></div><div class="line">    [<span class="keyword">self</span>.customView.layer removeAnimationForKey:<span class="string">@"wendingding"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开始动画"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"结束动画"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>点击停止动画，程序内部会调用  <code>[self.customView.layer removeAnimationForKey:@&quot;wendingding&quot;];</code>停止<code>self.customView.layer</code>上名称标示为wendingding的动画。</p>
<h4 id="图标抖动"><a href="#图标抖动" class="headerlink" title="图标抖动"></a>图标抖动</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"><span class="meta">#define angle2Radian(angle)  ((angle)/180.0*M_PI)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *iconView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.创建核心动画</span></div><div class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyAnima=[<span class="built_in">CAKeyframeAnimation</span> animation];</div><div class="line">    keyAnima.keyPath=<span class="string">@"transform.rotation"</span>;</div><div class="line">    <span class="comment">//设置动画时间</span></div><div class="line">    keyAnima.duration=<span class="number">0.1</span>;</div><div class="line">    <span class="comment">//设置图标抖动弧度</span></div><div class="line">    <span class="comment">//把度数转换为弧度  度数/180*M_PI</span></div><div class="line">    keyAnima.values=@[@(-angle2Radian(<span class="number">4</span>)),@(angle2Radian(<span class="number">4</span>)),@(-angle2Radian(<span class="number">4</span>))];</div><div class="line">    <span class="comment">//设置动画的重复次数(设置为最大值)</span></div><div class="line">    keyAnima.repeatCount=MAXFLOAT;</div><div class="line">    </div><div class="line">    keyAnima.fillMode=kCAFillModeForwards;</div><div class="line">    keyAnima.removedOnCompletion=<span class="literal">NO</span>;</div><div class="line">    <span class="comment">//2.添加动画</span></div><div class="line">    [<span class="keyword">self</span>.iconView.layer addAnimation:keyAnima forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其中，<code>keyAnima.values=@[@(-angle2Radian(4)),@(angle2Radian(4)),@(-angle2Radian(4))];</code>表示从-angle2Radian(4)转到angle2Radian(4)再转回-angle2Radian(4))。</p>
<p><strong>@()表示初始化oc对象，即将double转换为oc对象。因为oc的数组中不允许出现非oc得对象</strong></p>
<h2 id="转场动画和组动画"><a href="#转场动画和组动画" class="headerlink" title="转场动画和组动画"></a>转场动画和组动画</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>CATransition用于做转场动画<br>属性：</p>
<ul>
<li>type：动画过渡类型</li>
<li>subtype：动画过渡方向</li>
<li>startProgress：动画起点(在整体动画的百分比)</li>
<li>endProgress：动画终点(在整体动画的百分比)</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> index;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *iconView;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)preOnClick:(<span class="built_in">UIButton</span> *)sender;</div><div class="line">- (<span class="keyword">IBAction</span>)nextOnClick:(<span class="built_in">UIButton</span> *)sender;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.index=<span class="number">1</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)preOnClick:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    <span class="keyword">self</span>.index--;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.index&lt;<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.index=<span class="number">7</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.iconView.image=[<span class="built_in">UIImage</span> imageNamed: [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d.jpg"</span>,<span class="keyword">self</span>.index]];</div><div class="line">    </div><div class="line">    <span class="comment">//创建核心动画</span></div><div class="line">    <span class="built_in">CATransition</span> *ca=[<span class="built_in">CATransition</span> animation];</div><div class="line">    <span class="comment">//告诉要执行什么动画</span></div><div class="line">    <span class="comment">//设置过度效果</span></div><div class="line">    ca.type=<span class="string">@"cube"</span>;</div><div class="line">    <span class="comment">//设置动画的过度方向（向左）</span></div><div class="line">    ca.subtype=kCATransitionFromLeft;</div><div class="line">    <span class="comment">//设置动画的时间</span></div><div class="line">    ca.duration=<span class="number">2.0</span>;</div><div class="line">    <span class="comment">//添加动画</span></div><div class="line">    [<span class="keyword">self</span>.iconView.layer addAnimation:ca forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下一张</span></div><div class="line">- (<span class="keyword">IBAction</span>)nextOnClick:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    <span class="keyword">self</span>.index++;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.index&gt;<span class="number">7</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.index=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">self</span>.iconView.image=[<span class="built_in">UIImage</span> imageNamed: [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d.jpg"</span>,<span class="keyword">self</span>.index]];</div><div class="line">    </div><div class="line">    <span class="comment">//1.创建核心动画</span></div><div class="line">    <span class="built_in">CATransition</span> *ca=[<span class="built_in">CATransition</span> animation];</div><div class="line">    </div><div class="line">    <span class="comment">//1.1告诉要执行什么动画</span></div><div class="line">    <span class="comment">//1.2设置过度效果</span></div><div class="line">    ca.type=<span class="string">@"cube"</span>;</div><div class="line">    <span class="comment">//1.3设置动画的过度方向（向右）</span></div><div class="line">    ca.subtype=kCATransitionFromRight;</div><div class="line">    <span class="comment">//1.4设置动画的时间</span></div><div class="line">    ca.duration=<span class="number">2.0</span>;</div><div class="line">    <span class="comment">//1.5设置动画的起点</span></div><div class="line">    ca.startProgress=<span class="number">0.5</span>;</div><div class="line">    <span class="comment">//1.6设置动画的终点</span></div><div class="line"><span class="comment">//    ca.endProgress=0.5;</span></div><div class="line">    </div><div class="line">    <span class="comment">//2.添加动画</span></div><div class="line">    [<span class="keyword">self</span>.iconView.layer addAnimation:ca forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="组动画"><a href="#组动画" class="headerlink" title="组动画"></a>组动画</h3><p>将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性解析.</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *iconView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NJViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">// 平移动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> *a1 = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    a1.keyPath = <span class="string">@"transform.translation.y"</span>;</div><div class="line">    a1.toValue = @(<span class="number">100</span>);</div><div class="line">    <span class="comment">// 缩放动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> *a2 = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    a2.keyPath = <span class="string">@"transform.scale"</span>;</div><div class="line">    a2.toValue = @(<span class="number">0.0</span>);</div><div class="line">    <span class="comment">// 旋转动画</span></div><div class="line">    <span class="built_in">CABasicAnimation</span> *a3 = [<span class="built_in">CABasicAnimation</span> animation];</div><div class="line">    a3.keyPath = <span class="string">@"transform.rotation"</span>;</div><div class="line">    a3.toValue = @(M_PI_2);</div><div class="line">    <span class="comment">// 组动画</span></div><div class="line">    <span class="built_in">CAAnimationGroup</span> *groupAnima = [<span class="built_in">CAAnimationGroup</span> animation];</div><div class="line">    </div><div class="line">    groupAnima.animations = @[a1, a2, a3];</div><div class="line">    </div><div class="line">    <span class="comment">//设置组动画的时间</span></div><div class="line">    groupAnima.duration = <span class="number">2</span>;</div><div class="line">    groupAnima.fillMode = kCAFillModeForwards;</div><div class="line">    groupAnima.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.iconView.layer addAnimation:groupAnima forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="UIView封装动画"><a href="#UIView封装动画" class="headerlink" title="UIView封装动画"></a>UIView封装动画</h2><h3 id="UIView动画（首尾）"><a href="#UIView动画（首尾）" class="headerlink" title="UIView动画（首尾）"></a>UIView动画（首尾）</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间。<br>常见方法：</p>
<ul>
<li><strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象</li>
<li><strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>
<li><strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</li>
<li><strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位</li>
<li><strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始</li>
<li><strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now</li>
<li><strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制</li>
<li><strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数</li>
<li><strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</li>
<li><strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"YYViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *customView;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//打印动画块的位置</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动画执行之前的位置：%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(<span class="keyword">self</span>.customView.center));</div><div class="line">    </div><div class="line">    <span class="comment">//首尾式动画</span></div><div class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">//执行动画</span></div><div class="line">    <span class="comment">//设置动画执行时间</span></div><div class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">2.0</span>];</div><div class="line">    <span class="comment">//设置代理</span></div><div class="line">    [<span class="built_in">UIView</span> setAnimationDelegate:<span class="keyword">self</span>];</div><div class="line">    <span class="comment">//设置动画执行完毕调用的事件</span></div><div class="line">    [<span class="built_in">UIView</span> setAnimationDidStopSelector:<span class="keyword">@selector</span>(didStopAnimation)];</div><div class="line">    <span class="keyword">self</span>.customView.center=<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">300</span>);</div><div class="line">    [<span class="built_in">UIView</span> commitAnimations];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)didStopAnimation</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动画执行完毕"</span>);</div><div class="line">    <span class="comment">//打印动画块的位置</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动画执行之后的位置：%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(<span class="keyword">self</span>.customView.center));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="UIView封装的动画与CALayer动画的对比"><a href="#UIView封装的动画与CALayer动画的对比" class="headerlink" title="UIView封装的动画与CALayer动画的对比"></a>UIView封装的动画与CALayer动画的对比</h4><p>使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>
<p><strong>CALayer核心动画与UIView动画的区别</strong>：<br>UIView封装的动画，改变<code>view</code>或者<code>layer</code>执行完毕之后不会反弹。如果是通过<strong>CALayer核心动画</strong>改变<code>layer</code>的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</p>
<h3 id="block动画"><a href="#block动画" class="headerlink" title="block动画"></a>block动画</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li><strong>+(void)animateWithDuration:delay:options:animations:completion:</strong></li>
<li><strong>+(void)transitionWithView:duration:options:animations:completion:</strong></li>
<li><strong>+(void)transitionFromView:toView:duration:options:completion:</strong><br>属性简介：</li>
</ul>
<ol>
<li>duration：动画的持续时间</li>
<li>delay：动画延迟delay秒后开始</li>
<li>options：动画的节奏控制/转场动画的类型(重复，转场等)</li>
<li>animations：将改变视图属性的代码放在这个block中</li>
<li>completion：动画结束后，会自动调用这个block</li>
</ol>
<p>前两个方法用起来好像没什么区别。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">//block代码块动画</span></div><div class="line">        [<span class="built_in">UIView</span> transitionWithView:<span class="keyword">self</span>.customView duration:<span class="number">3.0</span> options:<span class="number">0</span> animations:^&#123;</div><div class="line">            <span class="comment">//执行的动画</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"动画开始执行前的位置：%@"</span>,<span class="built_in">NSStringFromCGPoint</span>(<span class="keyword">self</span>.customView.center));</div><div class="line">            <span class="keyword">self</span>.customView.center=<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">300</span>);</div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            <span class="comment">//动画执行完毕后的首位操作</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"动画执行完毕"</span>);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"动画执行完毕后的位置：%@"</span>,<span class="built_in">NSStringFromCGPoint</span>( <span class="keyword">self</span>.customView.center));</div><div class="line">        &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Demo详见CALayer_Transform</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 IO编程]]></title>
      <url>http://zhang759740844.github.io/2016/08/15/python_IO%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>使用Python内置的open()函数，传入文件名和标示符<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/test.txt'</span>, <span class="string">'r'</span>)</div></pre></td></tr></table></figure></p>
<p>标示符’r’表示读.</p>
<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">'Hello, world!'</span></div></pre></td></tr></table></figure></p>
<p>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</div><div class="line">    print(f.read())</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">if</span> f:</div><div class="line">        f.close()</div></pre></td></tr></table></figure></p>
<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    print(f.read())</div></pre></td></tr></table></figure></p>
<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</div><div class="line">    print(line.strip()) <span class="comment"># 把末尾的'\n'删掉</span></div></pre></td></tr></table></figure></p>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/test.jpg'</span>, <span class="string">'rb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...'</span> <span class="comment"># 十六进制表示的字节</span></div></pre></td></tr></table></figure></p>
<h4 id="文件读写-1"><a href="#文件读写-1" class="headerlink" title="文件读写"></a>文件读写</h4><p>阅读: 100273<br>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<p>读文件</p>
<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = open(‘/Users/michael/test.txt’, ‘r’)<br>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<blockquote>
<blockquote>
<blockquote>
<p>f=open(‘/Users/michael/notfound.txt’, ‘r’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>FileNotFoundError: [Errno 2] No such file or directory: ‘/Users/michael/notfound.txt’<br>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示：</module></stdin></p>
<p>f.read()<br>‘Hello, world!’<br>最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的：</p>
<p>f.close()<br>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
</blockquote>
</blockquote>
</blockquote>
<p>try:<br>    f = open(‘/path/to/file’, ‘r’)<br>    print(f.read())<br>finally:<br>    if f:<br>        f.close()<br>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<p>with open(‘/path/to/file’, ‘r’) as f:<br>    print(f.read())<br>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p>
<p>for line in f.readlines():<br>    print(line.strip()) # 把末尾的’\n’删掉<br>file-like Object</p>
<p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>
<p>StringIO就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h4 id="二进制文件-1"><a href="#二进制文件-1" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：</p>
<blockquote>
<blockquote>
<blockquote>
<p>f = open(‘/Users/michael/test.jpg’, ‘rb’)<br>f.read()<br>b’\xff\xd8\xff\xe1\x00\x18Exif\x00\x00…’ # 十六进制表示的字节<br>字符编码</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</div><div class="line"><span class="string">'测试'</span></div></pre></td></tr></table></figure></p>
<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/gbk.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>, errors=<span class="string">'ignore'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'w'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'Hello, world!'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>
<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    f.write(<span class="string">'Hello, world!'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h3><p>读取写内容到内存中，不写了。用到再看。</p>
<h3 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="comment"># 查看当前目录的绝对路径:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">'.'</span>)</div><div class="line"><span class="string">'/Users/michael'</span></div><div class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">'/Users/michael'</span>, <span class="string">'testdir'</span>)</div><div class="line"><span class="string">'/Users/michael/testdir'</span></div><div class="line"><span class="comment"># 然后创建一个目录:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">'/Users/michael/testdir'</span>)</div><div class="line"><span class="comment"># 删掉一个目录:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">'/Users/michael/testdir'</span>)</div></pre></td></tr></table></figure>
<p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。<br>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">'/Users/michael/testdir/file.txt'</span>)</div><div class="line">(<span class="string">'/Users/michael/testdir'</span>, <span class="string">'file.txt'</span>)</div></pre></td></tr></table></figure></p>
<p>文件操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 对文件重命名:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">'test.txt'</span>, <span class="string">'test.py'</span>)</div><div class="line"><span class="comment"># 删掉文件:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">'test.py'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<p>Python提供了pickle模块来实现序列化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure></p>
<p>pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'rb'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = pickle.load(f)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</div><div class="line"><span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。</p>
<p>要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</div><div class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CALayer学习小结]]></title>
      <url>http://zhang759740844.github.io/2016/08/12/CALayer%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>这两天想大致学习下animation的使用方法。看了<a href="http://www.cnblogs.com/wendingding/tag/UI高级/" target="_blank" rel="external">文顶顶的ios开发UI篇</a>专题，写的很好，学习了很多。再摘录部分，以作备忘。</p>
<a id="more"></a>
<h2 id="CALayer简介"><a href="#CALayer简介" class="headerlink" title="CALayer简介"></a>CALayer简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>UIView之所以能显示在屏幕上，因为内部的layer。创建UIView的时候自动创建CALayer对象。<br>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。<br>UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置边框的宽度为20</span></div><div class="line"><span class="keyword">self</span>.customView.layer.borderWidth=<span class="number">20</span>;</div><div class="line"><span class="comment">//设置边框的颜色(borderColor是CGColor类型)</span></div><div class="line"><span class="keyword">self</span>.customView.layer.borderColor=[<span class="built_in">UIColor</span> greenColor].CGColor;</div><div class="line"></div><div class="line"><span class="comment">//设置layer的圆角</span></div><div class="line"><span class="keyword">self</span>.customView.layer.cornerRadius=<span class="number">20</span>;</div><div class="line"><span class="comment">//设置超过子图层的部分裁减掉</span></div><div class="line"><span class="keyword">self</span>.iconView.layer.masksToBounds=<span class="literal">YES</span>;</div><div class="line"></div><div class="line"><span class="comment">//在view的图层上添加一个image，contents表示接受内容</span></div><div class="line"><span class="keyword">self</span>.customView.layer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"cat"</span>].CGImage;</div><div class="line"></div><div class="line"><span class="comment">//设置阴影的颜色</span></div><div class="line"><span class="keyword">self</span>.customView.layer.shadowColor=[<span class="built_in">UIColor</span> blackColor].CGColor;</div><div class="line"><span class="comment">//设置阴影的偏移量，如果为正数，则代表为往右边偏移</span></div><div class="line"><span class="keyword">self</span>.customView.layer.shadowOffset=<span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">//设置阴影的透明度(0~1之间，0表示完全透明)</span></div><div class="line"><span class="keyword">self</span>.customView.layer.shadowOpacity=<span class="number">0.6</span>;</div><div class="line"></div><div class="line"><span class="comment">//通过uiview设置（2D效果）</span></div><div class="line"><span class="keyword">self</span>.customView.transform=<span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, <span class="number">-100</span>);</div><div class="line"><span class="comment">//通过layer来设置（3D效果,x，y，z三个方向）</span></div><div class="line"><span class="keyword">self</span>.iconView.layer.transform=<span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">100</span>, <span class="number">20</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">//旋转</span></div><div class="line"><span class="keyword">self</span>.iconView.layer.transform=<span class="built_in">CATransform3DMakeRotation</span>(M_PI_4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div></pre></td></tr></table></figure></p>
<h2 id="创建图层"><a href="#创建图层" class="headerlink" title="创建图层"></a>创建图层</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//创建一个layer</span></div><div class="line">    <span class="built_in">CALayer</span> *Mylayer=[<span class="built_in">CALayer</span> layer];</div><div class="line">    <span class="comment">//设置layer的属性</span></div><div class="line">    Mylayer.bounds=<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    Mylayer.position=<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//设置需要显示的图片</span></div><div class="line">    Mylayer.contents=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"me"</span>].CGImage;</div><div class="line">    <span class="comment">//设置圆角半径为10</span></div><div class="line">    Mylayer.cornerRadius=<span class="number">10</span>;</div><div class="line">    <span class="comment">//如果设置了图片，那么需要设置这个属性为YES才能显示圆角效果</span></div><div class="line">    Mylayer.masksToBounds=<span class="literal">YES</span>;</div><div class="line">    <span class="comment">//设置边框</span></div><div class="line">    Mylayer.borderWidth=<span class="number">3</span>;</div><div class="line">    Mylayer.borderColor=[<span class="built_in">UIColor</span> brownColor].CGColor;</div><div class="line">    </div><div class="line">    <span class="comment">//把layer添加到界面上</span></div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:Mylayer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以。<br>如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以</p>
<h2 id="CAlayer属性"><a href="#CAlayer属性" class="headerlink" title="CAlayer属性"></a>CAlayer属性</h2><h3 id="position和anchorPoint"><a href="#position和anchorPoint" class="headerlink" title="position和anchorPoint"></a>position和anchorPoint</h3><ul>
<li>position:设置CALayer在父层中的位置，这个位置要和锚点重合。</li>
<li>anchorPoint:决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，<strong>默认值为（0.5, 0.5）</strong></li>
</ul>
<h3 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h3><p>每个View内部都关联着一个Root Layer。所有非rootlayer都存在着隐式动画。隐式动画就是对于layer的部分属性进行修改时，默认会产生的一些动画。</p>
<p>常见的动画属性：</p>
<ul>
<li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li>
<li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li>
<li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li>
</ul>
<h2 id="自定义layer"><a href="#自定义layer" class="headerlink" title="自定义layer"></a>自定义layer</h2><h3 id="第一种方式：新建layer类"><a href="#第一种方式：新建layer类" class="headerlink" title="第一种方式：新建layer类"></a>第一种方式：新建layer类</h3><p>想要在view中画东西，需要自定义view,创建一个类与之关联，让这个类继承自UIView，然后重写它的DrawRect：方法，然后在该方法中画图。</p>
<p>如果在layer上画东西，与上面的过程类似。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"YYMylayer.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYMylayer</span></span></div><div class="line"><span class="comment">//重写该方法，在该方法内绘制图形</span></div><div class="line">-(<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.绘制图形</span></div><div class="line">    <span class="comment">//画一个圆</span></div><div class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    <span class="comment">//设置属性（颜色）</span></div><div class="line"><span class="comment">//    [[UIColor yellowColor]set];	不能这样设置</span></div><div class="line">    <span class="built_in">CGContextSetRGBFillColor</span>(ctx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">     <span class="comment">//2.渲染</span></div><div class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>默认为无色，不会显示。要想让绘制的图形显示出来，还需要设置图形的颜色。注意不能直接使用UI框架中的类</li>
<li>在自定义layer中<code>drawInContext:</code>方法不会自己调用，只能自己通过<code>setNeedDisplay</code>方法调用，在view中画东西<code>DrawRect:</code>方法在view第一次显示的时候会自动调用。</li>
</ol>
<p>在view中绘图：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"YYVIEW.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYVIEW</span></span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</div><div class="line">&#123;</div><div class="line">    <span class="comment">//1.获取上下文</span></div><div class="line">    <span class="built_in">CGContextRef</span> ctx=<span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="comment">//2.绘制图形</span></div><div class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    <span class="comment">//设置属性（颜色）</span></div><div class="line">    <span class="comment">//    [[UIColor yellowColor]set];</span></div><div class="line">    <span class="built_in">CGContextSetRGBFillColor</span>(ctx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    <span class="comment">//3.渲染</span></div><div class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</div><div class="line">    <span class="comment">//在执行渲染操作的时候，本质上它的内部相当于调用了下面的方法</span></div><div class="line">    <span class="comment">//[self.layer drawInContext:ctx];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第二种方式：实现delegate方法"><a href="#第二种方式：实现delegate方法" class="headerlink" title="第二种方式：实现delegate方法"></a>第二种方式：实现delegate方法</h3><p>设置viewcontroller为CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//1.创建自定义的layer</span></div><div class="line">    <span class="built_in">CALayer</span> *layer=[<span class="built_in">CALayer</span> layer];</div><div class="line">    <span class="comment">//2.设置layer的属性</span></div><div class="line">	...</div><div class="line">    <span class="comment">//设置代理</span></div><div class="line">    layer.delegate=<span class="keyword">self</span>;</div><div class="line">    [layer setNeedsDisplay];</div><div class="line">    <span class="comment">//3.添加layer</span></div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:layer];</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="comment">//1.绘制图形</span></div><div class="line">    <span class="comment">//画一个圆</span></div><div class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>));</div><div class="line">    <span class="comment">//设置属性（颜色）</span></div><div class="line">    <span class="comment">//    [[UIColor yellowColor]set];</span></div><div class="line">    <span class="built_in">CGContextSetRGBFillColor</span>(ctx, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);   </div><div class="line">    <span class="comment">//2.渲染</span></div><div class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>在设置代理的时候，它并不要求我们遵守协议，说明这个方法是nsobject中的，就不需要再额外的显示遵守协议了。</li>
<li>不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。</li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>
<li><strong>当UIView需要显示时</strong>，它内部的层会准备好一个CGContextRef(图形上下文)，然后<strong>调用delegate(这里就是UIView)</strong>的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。</li>
</ol>
<blockquote>
<p>Demo 详见 CALayer-transform</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[删除Storyboard]]></title>
      <url>http://zhang759740844.github.io/2016/08/11/%E5%88%A0%E9%99%A4storyboard/</url>
      <content type="html"><![CDATA[<p>xcode版本升级后，storyboard成了ios新建项目后默认的布局。但是尝试了一会后发觉很不习惯，于是研究了下删除storyboard的方法。<br><a id="more"></a></p>
<p>storyboard的入口在<strong>targets-&gt;General-&gt;Deployment Info-&gt;Main Interface</strong>，默认的值为Main，即初始默认storyboard的名字。因此，想要不加载storyboard，需要将这个默认值删掉，就不会再从storyboard进入了。</p>
<p>删除后，viewController需要一个布局，需要手动创建一个xib文件。需要对xib文件和viewcontroller进行关联。</p>
<ul>
<li>点击placeholders下的File’s Owner将Custom Class的Class设置为viewcController的名字。</li>
<li>将File’s Owner的view和xib的View进行关联。</li>
</ul>
<p>使用storyboard的时候application:didFinishWithOptions:方法只返回一个YES。删除后，需要添加代码对window初始化，否则app什么也显示不了。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">	<span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</div><div class="line">	ViewController *uv = [[ViewController alloc] initWithNibName:<span class="string">@"ViewController"</span> bundle:<span class="literal">nil</span>];</div><div class="line">	[<span class="keyword">self</span>.window setRootViewController:uv];</div><div class="line">	[<span class="keyword">self</span>.window makeKeyAndVisible];</div><div class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：这里的<code>ViewController</code>是你自定义的ViewController。</p>
<p>如果要使用NavigationController需要写成这样:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">// Override point for customization after application launch.</span></div><div class="line">   	<span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</div><div class="line">    ViewController *vc = [[ViewController alloc]initWithNibName:<span class="string">@"ViewController"</span> bundle:<span class="literal">nil</span>];</div><div class="line">    vc.title = <span class="string">@"AutoHeightTableView"</span>;</div><div class="line">    <span class="built_in">UINavigationController</span> *uv = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:vc];</div><div class="line">    [<span class="keyword">self</span>.window setRootViewController:uv];</div><div class="line">    [<span class="keyword">self</span>.window makeKeyAndVisible];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，app就可以显示新建的xib文件的布局了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用xib设置view的border的宽度和颜色]]></title>
      <url>http://zhang759740844.github.io/2016/08/10/xib%E8%AE%BE%E7%BD%AEborder/</url>
      <content type="html"><![CDATA[<p>使用User Defined Runtime Attributes可以配置一些在interface builder 中不能配置的属性。有助于编写更加轻量级的viewcontroller。</p>
<a id="more"></a>
<p>写一个button的时候经常会需要设置其cornerRadious，borderWidth和borderColor三个属性。如果在代码中实现，需要设置一个button属性，再与xib进行关联。<br>可以使用User Defined Runtime Attributes在xib中进行设置。</p>
<p>对一个view进行设置主要还是设置它的layer。因此，设置的key,type依次是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">layer.cornerRadius				Number</div><div class="line">layer.borderWidth				Number</div><div class="line">layer.borderColor				Color</div></pre></td></tr></table></figure></p>
<p>但是，进过设置后会发现borderColor属性设置并不成功。这是因为这里设置的颜色类型是UIColor而borderColor是CGColor因此显示不出来。</p>
<p>需要使用category定义一个CALayer的方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CALayer+Additions.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CALayer</span> (<span class="title">Additions</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setBorderColorFromUIColor:(<span class="built_in">UIColor</span> *)color&#123;</div><div class="line">    <span class="keyword">self</span>.borderColor = color.CGColor;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>通过这个方法可以把Color设置为borderColor。<br>xib中的key需要改成此方法名<br><strong>layer.borderColorFromUIColor</strong></p>
<p>在xib中设置borderColorFromUIColor的时候，不需要将新建的CALayer+Additions.h头文件import入任何类，编译的时候会自动调用。</p>
<p>设置masksToBounds为YES（也就是xib中的clip bounds）可以将图层里面东西截取，否则，超出父布局的子视图也将全部显示。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 面向对象高级编程]]></title>
      <url>http://zhang759740844.github.io/2016/08/10/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h3><p>我们可以给实例绑定任何属性和方法。<br>创建实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>给实例绑定方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span> <span class="comment"># 定义一个函数作为实例方法</span></div><div class="line"><span class="meta">... </span>    self.age = age</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ol>
<li>这里使用MethodType方法给实例绑定方法，之后调用的时候就不用设置self了。如果使用s.set_age = set_age的方式绑定，那么调用时要自己传入self变量。 </li>
<li>MethodType()这个方法不要用在给类绑定属性上。</li>
</ol>
<p>给类绑定方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></div><div class="line"><span class="meta">... </span>    self.score = score</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>像这样给类绑定方法后，实例变量不用自己传入self了。</p>
<p>如果我们想要限制实例的属性。比如，只允许对Student实例添加name和age属性。我们可以使用<strong>slots</strong>来限制属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></div></pre></td></tr></table></figure></p>
<p>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的,即<strong><strong>slots</strong>属性并不会被继承</strong></p>
<p>slots的本质不是限制实例添加属性，而是优化性能。slots绑定的实例属性不保存在dict中，所以在有大量实例存在的情况下能减少hash table的内存开销。不能给实例增加,不能给实例动态添加属性只是<strong>slots</strong>的副作用。</p>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h3><p>类的属性都是暴露出来的，写起来方便，但是没办法检查参数。如果使用get，set方法又显得麻烦。可以使用装饰器(decorator)中的@property装饰器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._score</div><div class="line"></div><div class="line"><span class="meta">    @score.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</div><div class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</div><div class="line">        self._score = value</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值.</li>
<li>只定义getter方法，不定义setter方法就是一个只读属性。</li>
</ol>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>python允许多重继承：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p><strong>如果继承的类有同名方法，按照继承的顺序执行，即先执行Mammal里的，没有再执行Runnable里的。</strong></p>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>感觉MixIn就是个约定啊，并没有太多实质效果啊=。=</p>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><p>形如<strong>xxx</strong>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<h4 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h4><p>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line"><span class="meta">... </span>        self.name = name</div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</div><div class="line">Student object (name: Michael)</div></pre></td></tr></table></figure></p>
<h4 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h4><p>如果一个类想被用于<strong>for…in</strong>循环，类似list或tuple那样，就必须实现一个<strong><strong>iter</strong>()</strong>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong><strong>next</strong>()</strong>方法拿到循环的下一个值，直到遇到<strong>StopIteration</strong>错误时退出循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></div><div class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></div><div class="line">            <span class="keyword">raise</span> StopIteration();</div><div class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</div><div class="line"><span class="meta">... </span>    print(n)</div></pre></td></tr></table></figure></p>
<h4 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h4><p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法。<strong>getitem</strong>()传入的参数可能是一个int，也可能是一个切片对象slice:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></div><div class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></div><div class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</div><div class="line">                a, b = b, a + b</div><div class="line">            <span class="keyword">return</span> a</div><div class="line">        <span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></div><div class="line">            start = n.start</div><div class="line">            stop = n.stop</div><div class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                start = <span class="number">0</span></div><div class="line">            a, b = <span class="number">1</span>, <span class="number">1</span></div><div class="line">            L = []</div><div class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(stop):</div><div class="line">                <span class="keyword">if</span> x &gt;= start:</div><div class="line">                    L.append(a)</div><div class="line">                a, b = b, a + b</div><div class="line">            <span class="keyword">return</span> L</div></pre></td></tr></table></figure></p>
<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>
<h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a><strong>getattr</strong></h4><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个<strong>getattr</strong>()方法，动态返回一个属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.name = <span class="string">'Michael'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">if</span> attr==<span class="string">'score'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">99</span></div></pre></td></tr></table></figure></p>
<p>当调用<strong>不存在的属性</strong>时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性，这样，我们就有机会返回score的值.</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h4><p>任何类，只需要定义一个<strong>call</strong>()方法，就可以直接对实例进行调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'My name is %s.'</span> % self.name)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></div><div class="line">My name <span class="keyword">is</span> Michael.</div></pre></td></tr></table></figure></p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Python提供了Enum类来实现这个功能<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</div><div class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</div><div class="line"></div><div class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</div><div class="line">    print(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</div></pre></td></tr></table></figure></p>
<p>value属性则是自动赋给成员的int常量，默认从1开始计数。<br>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weekday</span><span class="params">(Enum)</span>:</span></div><div class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></div><div class="line">    Mon = <span class="number">1</span></div><div class="line">    Tue = <span class="number">2</span></div><div class="line">    Wed = <span class="number">3</span></div><div class="line">    Thu = <span class="number">4</span></div><div class="line">    Fri = <span class="number">5</span></div><div class="line">    Sat = <span class="number">6</span></div></pre></td></tr></table></figure>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>没看</p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 面向对象编程]]></title>
      <url>http://zhang759740844.github.io/2016/08/09/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><p>定义类是通过class关键字，后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Student(object)</div><div class="line">	pass</div></pre></td></tr></table></figure></p>
<p>定义好类，就可以创建出实例了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bart = Student()</div></pre></td></tr></table></figure></p>
<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例bart绑定一个name属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bart.name = <span class="string">'Zachary'</span></div></pre></td></tr></table></figure></p>
<p>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。</p>
<p>创建实例的时候可以使用特殊的<strong><strong>init</strong></strong>方法初始化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.score = score</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ol>
<li>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</li>
<li>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。</li>
</ol>
<p>另外：</p>
<ol>
<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数</li>
<li>如果是类的方法，不需要传入self，使用类名.方法名调用。和其他语言一样。</li>
</ol>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>oc中使用.h和.m定义属性的方式区分共有私有。<br>Java中通过public，private的方式区分共有私有。<br>python通过__的方式区分共有私有。</p>
<p>以_开头的变量表示：可以访问，但是最好视为私有变量。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>继承和多态和其他语言没什么不同，就不重复了。</p>
<p>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。<br>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了</p>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>使用type()函数,判断对象类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">pass</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x: x)==types.LambdaType</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h4><p>使用isinstance()函数,判断class的继承关系<br>判断基本类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'a'</span>, str)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">b'a'</span>, bytes)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><p>如果要获得一个对象的<strong>所有属性和方法</strong>，可以使用dir()函数，它返回一个包含字符串的list.</p>
<p>仅仅把属性和方法列出来是不够的，配合<strong>getattr()</strong>、<strong>setattr()</strong>以及<strong>hasattr()</strong>，我们可以直接<strong>操作一个对象的状态</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        self.x = <span class="number">9</span></div><div class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.x * self.x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</div></pre></td></tr></table></figure></p>
<p>紧接着，可以测试该对象的属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></div><div class="line"><span class="number">19</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure></p>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误<br>可以传入一个default参数，如果属性不存在，就返回默认值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></div><div class="line"><span class="number">404</span></div></pre></td></tr></table></figure></p>
<p>也可以获得对象的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></div><div class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></div><div class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></div><div class="line"><span class="number">81</span></div></pre></td></tr></table></figure></p>
<p><strong>感觉上，用set，get，has方法和直接设置没什么太大区别。</strong></p>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>python中并没有static修饰符，在一个class中定义的属性，实例和类都可以访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>    name = <span class="string">'Student'</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 打印类的name属性</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></div><div class="line">Michael</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></div><div class="line">Student</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></div><div class="line">Student</div></pre></td></tr></table></figure></p>
<p>在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 模块]]></title>
      <url>http://zhang759740844.github.io/2016/08/09/python_%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<p>Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。<br>请注意，每一个包目录下面都会有一个<strong>init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</strong>init__.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">	test()</div></pre></td></tr></table></figure>
<p>导入sys模块后,就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。<br>sys模块有一个argv变量，用list存储了<strong>命令行的所有参数</strong>。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。<br>在命令行运行该模块文件时，Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>作用域：</p>
<ul>
<li>正常的函数和变量名是公开的（public），可以被直接引用</li>
<li>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用，但是有特殊用途。</li>
<li>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用。</li>
</ul>
<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p>使用pip3 install XXX 安装第三方库<br>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。<br>搜索路径存放在sys模块的path变量中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">print(sys.path)</div></pre></td></tr></table></figure></p>
<p>当要添加自己的搜索目录时可以</p>
<ol>
<li>直接修改sys.path:<strong>sys.path.append(‘/Users/xxx/xxx’)</strong></li>
<li>设置环境变量PYTHONPATH</li>
</ol>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 模块]]></title>
      <url>http://zhang759740844.github.io/2016/08/08/python_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h4><p>把函数本身赋值给变量,即：变量可以指向函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</div><div class="line"><span class="number">10</span></div></pre></td></tr></table></figure></p>
<p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<h4 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h4><p>那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></div><div class="line">    <span class="keyword">return</span> f(x) + f(y)</div></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div></pre></td></tr></table></figure></p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数<strong>必须接收两个参数</strong>，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></pre></td></tr></table></figure></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter()也接收一个函数和一个序列.filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></div><div class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</div><div class="line"><span class="comment"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>使用sorted()函数就可以对list进行排序。<br>sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p><strong>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list = [<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>]</div><div class="line">keys = [<span class="number">36</span>, <span class="number">5</span>,  <span class="number">12</span>, <span class="number">9</span>,  <span class="number">21</span>]</div></pre></td></tr></table></figure></p>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>高阶函数除了接收函数作为参数外，还能将函数作为结果返回。好处是，不需要立即执行，在想要调用的时候执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">             <span class="keyword">return</span> i*i</div><div class="line">        fs.append(f)</div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count()</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure></p>
<p>本例中，执行count()返回了一个以f函数作为元素的数组，分别赋给f1，f2，f3。这里面执行三个函数的结果都是9，因为外层i在循环的时候并没有执行i*i，当循环完后，i为3，由于闭包性，i=3被保存在栈中，直到函数执行。<br>因此，返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lambda</span> x: x * x</div><div class="line">=&gt;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x * x</div></pre></td></tr></table></figure>
<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是<strong>只能有一个表达式</strong>，不用写return，返回值就是该表达式的结果。<br>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">    	<span class="comment"># 函数对象有一个__name__属性，可以拿到函数的名字</span></div><div class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</div><div class="line">        <span class="keyword">return</span> func(*args, **kw)</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"><span class="meta">@log</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2015-3-25'</span>)</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now()</div><div class="line">call now():</div><div class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></div></pre></td></tr></table></figure></p>
<p>此处把<strong>@log</strong>放到<strong>now()</strong>定义处，相当于执行了<br><strong>now = log(now)</strong>: <strong>now() =&gt; wrapper()</strong><br>将原方法作为参数传入。类似于装饰者模式，只不过由于python的动态性，不需要调用新定义的方法，只要调用原方法就可以动态解析。</p>
<h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><p>如果log带参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</div><div class="line">            <span class="keyword">return</span> func(*args, **kw)</div><div class="line">        <span class="keyword">return</span> wrapper</div><div class="line">    <span class="keyword">return</span> decorator</div><div class="line"></div><div class="line"><span class="meta">@log('execute')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'2015-3-25'</span>)</div></pre></td></tr></table></figure></p>
<p>首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。即<strong>now()=&gt;wrapper()</strong></p>
<h4 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h4><p>上面的过程解析已经说明，最后now()的调用，都转化成了wrapper()的调用。那么，在调用<strong>now.<strong>name</strong></strong>时，结果就会使wrapper，而不是now。<br>因此，需要将<strong>wrapper.<strong>name</strong> = func.<strong>name</strong></strong>。可以使用python内置的方法<strong>functools.wraps</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import functools</div><div class="line">def log(func):</div><div class="line">    @functools.wraps(func)</div><div class="line">    def wrapper(*args, **kw):</div><div class="line">        print(&apos;call %s():&apos; % func.__name__)</div><div class="line">        return func(*args, **kw)</div><div class="line">    return wrapper</div><div class="line"># 或者</div><div class="line">import functools</div><div class="line">def log(text):</div><div class="line">    def decorator(func):</div><div class="line">        @functools.wraps(func)</div><div class="line">        def wrapper(*args, **kw):</div><div class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</div><div class="line">            return func(*args, **kw)</div><div class="line">        return wrapper</div><div class="line">    return decorator</div></pre></td></tr></table></figure>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>
<p>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> int(x, base)</div></pre></td></tr></table></figure></p>
<p>我们可以使用<strong>functools.partial</strong>创建一个偏函数，不需要自己定义int2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</div><div class="line"><span class="number">64</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</div><div class="line"><span class="number">85</span></div></pre></td></tr></table></figure></p>
<p>简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>
<p>创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max2 = functools.partial(max, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>实际上会把10作为*args的一部分<strong>自动加到左边</strong>，也就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">相当于：</div><div class="line">args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">max(*args)</div></pre></td></tr></table></figure></p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 高级特性]]></title>
      <url>http://zhang759740844.github.io/2016/08/08/python_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片（Slice）操作符用来简化经常取指定索引范围的操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>从索引0开始取，直到索引3为止，但不包括索引3,正好是3个元素.</p>
<p>各种用法示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python支持L[-1]取倒数第一个元素,同样支持倒数切片</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</div><div class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</div><div class="line">[<span class="string">'Bob'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 前10个数，每两个取一个：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div><div class="line"></div><div class="line"><span class="comment"># 所有数，每5个取一个：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</div><div class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</div><div class="line"></div><div class="line"><span class="comment"># 什么都不写，只写[:]就可以原样复制一个list</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L[:]</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</div><div class="line"></div><div class="line"><span class="comment"># tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</div><div class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]</div><div class="line"><span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]</div><div class="line"><span class="string">'ACEG'</span></div></pre></td></tr></table></figure></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。只要是可迭代对象，无论有无下标，都可以迭代。</p>
<p>判断一个对象是否是可迭代对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</div><div class="line">isinstance(<span class="string">'abc'</span>, Iterable)</div></pre></td></tr></table></figure></p>
<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>感觉没啥用。</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>列表元素可以按照某种算法在不断循环的过程中推算出后续元素，不必创建完整的list，节省大量空间。这种一边循环一边计算的机制，叫做generator。<br>例如实现斐波那契函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &lt; max:</div><div class="line">        <span class="keyword">yield</span> b</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line">    </div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</div><div class="line">	print(n)</div></pre></td></tr></table></figure></p>
<p>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.<br>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>
<p>其实就相当于在yield处有个断点，可以获得当时的yield处的值，供for循环内使用。</p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 基础语法]]></title>
      <url>http://zhang759740844.github.io/2016/08/07/python%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>python还是大一时学的第一门课编程课，学的时候由于没有编程基础，最主要的是完全没有好好学，很煎熬。现在真是悔不当初。<br>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<p>Python采用缩进方式,写出来的代码就像下面的样子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># print absolute value of an integer:</span></div><div class="line">a = <span class="number">100</span></div><div class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</div><div class="line">    print(a)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(-a)</div></pre></td></tr></table></figure></p>
<p>以#开头的语句是注释<br>其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块.</p>
<h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本.如果字符串内部既包含’又包含”,可以用转义字符\来标识。<br>要计算str包含多少个字符，可以用len()函数。<br>%运算符就是用来格式化字符串，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></div><div class="line"><span class="string">'Hello, world'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</div><div class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>
<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%.</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>一个布尔值只有True、False两种值<br>布尔值可以用and、or和not运算。</p>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>空值是Python里一个特殊的值，用None表示。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p>
<h3 id="数组和元组"><a href="#数组和元组" class="headerlink" title="数组和元组"></a>数组和元组</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list是一种<strong>可变的</strong>有序的集合，用len()函数可以获得list元素的个数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置<br>list里面的元素的数据类型也可以不同<br>列表可以看成一个多维数组 s[2][1]拿到元素。<br>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</p>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>另一种有序列表叫元组，但是tuple一旦初始化就不能修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</div></pre></td></tr></table></figure></p>
<p>因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。<br>当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来.</p>
<p>如果要定义一个空的tuple，可以写成(),但是，要定义一个只有1个元素的tuple,必须写成如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t = (<span class="number">1</span>,)</div></pre></td></tr></table></figure></p>
<p>这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>if-else语句实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">age = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</div><div class="line">    print(<span class="string">'your age is'</span>, age)</div><div class="line">    print(<span class="string">'adult'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'your age is'</span>, age)</div><div class="line">    print(<span class="string">'teenager'</span>)</div></pre></td></tr></table></figure></p>
<p>注意不要少写了冒号:<br>完全可以用elif做更细致的判断,elif是else if的缩写</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>依次把list或tuple中的每个元素迭代出来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</div><div class="line">    print(name)</div></pre></td></tr></table></figure></p>
<p>Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list.在for…in中可以简写成range()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</div><div class="line">    sum = sum + x</div><div class="line">print(sum)</div></pre></td></tr></table></figure></p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sum = <span class="number">0</span></div><div class="line">n = <span class="number">99</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">    sum = sum + n</div><div class="line">    n = n - <span class="number">2</span></div><div class="line">print(sum)</div></pre></td></tr></table></figure>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</div></pre></td></tr></table></figure>
<p><strong>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</strong></p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set和dict类似，<strong>也是一组key的集合</strong>，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>要创建一个set，需要<strong>提供一个list作为输入集合</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p>
<p>重复元素在set中自动被过滤<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 3.5 函数]]></title>
      <url>http://zhang759740844.github.io/2016/08/07/python_%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>当时学的是2.x版本，有点过时了，现在看了<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的博客</a>的3.5版本的语法介绍，做一些摘录。</p>
<a id="more"></a>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数</p>
<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> -x</div></pre></td></tr></table></figure></p>
<p>可以使用from abstest import my_abs来导入my_abs()函数，abstest是my_abs所在的文件名.</p>
<h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p>用pass语句定义一个什么事都不做的空函数，不用pass会报错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="comment"># 或者    </span></div><div class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    <span class="keyword">return</span> nx, ny</div></pre></td></tr></table></figure>
<p>得到返回值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y)</div><div class="line"><span class="number">151.96152422706632</span> <span class="number">70.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</div><div class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</div></pre></td></tr></table></figure></p>
<p>其实Python函数返回的仍然是单一值.返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>python不支持重载，可以使用默认参数的方式替代。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></div><div class="line">    s = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">        n = n - <span class="number">1</span></div><div class="line">        s = s * x</div><div class="line">    <span class="keyword">return</span> s</div></pre></td></tr></table></figure></p>
<p>第二个参数n的默认值设定为2.这样，当我们调用power(5)时，相当于调用power(5, 2).</p>
<p>但是需要注意：</p>
<ol>
<li>必选参数在前，默认参数在后，否则Python的解释器会报错。<strong>如果不按顺序提供参数时，需要写成 参数名=xx 的形式。</strong></li>
<li>默认参数必须指向不变对象。<br>例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</div><div class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当L缺省后，L指向一个数组对象的地址。每次append后，那个地址的数组元素发生改变。</p>
<p>如果要默认是list，可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        L = []</div><div class="line">    L.append(<span class="string">'END'</span>)</div><div class="line">    <span class="keyword">return</span> L</div></pre></td></tr></table></figure></p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>通常可以通过list或tuple实现传入不确定数量的参数。python支持可变参数，写法如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></div><div class="line">    sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        sum = sum + n * n</div><div class="line">    <span class="keyword">return</span> sum</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="number">14</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</div><div class="line"><span class="number">84</span></div></pre></td></tr></table></figure></p>
<p><strong>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。因此无法再内部函数改变传入的list</strong><br><strong>不是可变参数的话，参数需要一一对应</strong></p>
<p>如果已经有一个list或者tuple，要调用一个可变参数可以写成这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(nums)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(*nums)</div><div class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line"><span class="comment"># 调用</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</div><div class="line"><span class="number">14</span></div></pre></td></tr></table></figure></p>
<p><strong>nums表示一个数组或者元组<br>*nums表示取出nums这个list里的所有元素，代表多个参数</strong></p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></div><div class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</div><div class="line"><span class="comment"># 调用</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</div><div class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="comment"># 另一种简化写法</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</div><div class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</div></pre></td></tr></table></figure></p>
<p><strong>kw表示一个dict<br>**kw表示取出kw中的所有键值对元素，代表多个参数</strong></p>
<p><strong>另外，和上面的list传入的是tuple一样，kw获得的dict是外部传入的一份拷贝，在函数内部对kw的修改不会影响到外部dict。</strong></p>
<h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><p>不知道这么脑残的语法有什么意义。</p>
<p>最后再次感谢廖老师的辛勤劳动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UICollectionView 使用方法总结]]></title>
      <url>http://zhang759740844.github.io/2016/08/05/UICollectionView/</url>
      <content type="html"><![CDATA[<p>UICollectionView最强大、同时显著超出UITableView的特色就是其完全灵活的布局结构。本篇将对UICollectionView的基本使用方法进行总结。</p>
<a id="more"></a>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>UICollectionView上面显示内容的视图有三种<strong>Cell</strong>视图、<strong>Supplementary View</strong>和<strong>Decoration View</strong>。</p>
<ul>
<li>Cell视图<br>CollectionView中主要的内容都是由它展示的，它是从数据源对象获取的。</li>
<li>Supplementary View<br>它展示了每一组当中的信息，与cell类似，它是从数据源方法当中获取的，但是与cell不同的是，它并不是强制需要的。<br>例如flow layout当中的headers和footers就是可选的Supplementary View。</li>
<li>Decoration View<br>这个视图是一个装饰视图，它没有什么功能性，它不跟数据源有任何关系，它完全属于layout对象。</li>
</ul>
<h2 id="注册与重用"><a href="#注册与重用" class="headerlink" title="注册与重用"></a>注册与重用</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在使用数据源返回cell或者Supplementary View给collectionView之前，我们必须先要注册。</p>
<ul>
<li>registerClass: forCellWithReuseIdentifier:</li>
<li>registerNib: forCellWithReuseIdentifier:</li>
<li>registerClass: forSupplementaryViewOfKind: withReuseIdentifier:</li>
<li>registerNib: forSupplementaryViewOfKind: withReuseIdentifier:</li>
</ul>
<p>前面两个方法是注册cell，后两个方法注册Supplementary View。注册Supplementary View时需要指定是headerview还是footer。</p>
<h3 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h3><p>注册后，调用一下方法进行重用:</p>
<ul>
<li>dequeueReusableCellWithReuseIdentifier:forIndexPath:</li>
<li>dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:</li>
</ul>
<h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>数据源方法与UITableView类似，主要有：</p>
<ul>
<li>numberOfSectionsInCollectionView:</li>
<li>collectionView: numberOfItemsInSection:</li>
<li>collectionView: cellForItemAtIndexPath:</li>
<li>collectionView: viewForSupplementaryElementOfKind: atIndexPath:</li>
</ul>
<h3 id="添加头部和尾部视图"><a href="#添加头部和尾部视图" class="headerlink" title="添加头部和尾部视图"></a>添加头部和尾部视图</h3><p>collection view 额外管理着两种视图：supplementary views ， Supplementary views 相当于 table view 的 section header 和 footer views。像cells一样，他们的内容都由数据源对象驱动。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UICollectionReusableView</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class="built_in">NSString</span> *)kind atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">if</span> ([kind isEqual:<span class="built_in">UICollectionElementKindSectionFooter</span>] ) &#123;</div><div class="line">        MineTicketListReusableView *mineTicketListReusableView = [collectionView dequeueReusableSupplementaryViewOfKind:<span class="built_in">UICollectionElementKindSectionFooter</span> withReuseIdentifier:MineTicketListReusableViewIdentifier forIndexPath:indexPath];</div><div class="line">        mineTicketListReusableView.delegate = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">return</span> mineTicketListReusableView;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="部分代理方法"><a href="#部分代理方法" class="headerlink" title="部分代理方法"></a>部分代理方法</h2><h3 id="移动cell"><a href="#移动cell" class="headerlink" title="移动cell"></a>移动cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回YES允许其item移动</span></div><div class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//移动item时回调</span></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class="built_in">NSIndexPath</span>*)destinationIndexPath &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//collectionView不像tableView可以设置setEditing属性切换是否能够编辑，需要声明长按手势</span></div><div class="line"><span class="built_in">UILongPressGestureRecognizer</span> *longGesture = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(handlelongGesture:)];</div><div class="line">    [<span class="keyword">self</span>.collectionView addGestureRecognizer:longGesture];</div><div class="line">    </div><div class="line"><span class="comment">//再实现手势操作</span></div><div class="line">- (<span class="keyword">void</span>)handlelongGesture:(<span class="built_in">UILongPressGestureRecognizer</span> *)longGesture &#123;</div><div class="line">    <span class="comment">//判断手势状态</span></div><div class="line">    <span class="keyword">switch</span> (longGesture.state) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:&#123;</div><div class="line">            <span class="comment">//判断手势落点位置是否在路径上</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.collectionView indexPathForItemAtPoint:[longGesture locationInView:<span class="keyword">self</span>.collectionView]];</div><div class="line">            <span class="keyword">if</span> (indexPath == <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//在路径上则开始移动该路径上的cell</span></div><div class="line">            [<span class="keyword">self</span>.collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</div><div class="line">            <span class="comment">//移动过程当中随时更新cell位置</span></div><div class="line">            [<span class="keyword">self</span>.collectionView updateInteractiveMovementTargetPosition:[longGesture locationInView:<span class="keyword">self</span>.collectionView]];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</div><div class="line">            <span class="comment">//移动结束后关闭cell移动</span></div><div class="line">            [<span class="keyword">self</span>.collectionView endInteractiveMovement];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            [<span class="keyword">self</span>.collectionView cancelInteractiveMovement];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="点击cell高亮"><a href="#点击cell高亮" class="headerlink" title="点击cell高亮"></a>点击cell高亮</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 允许选中时，高亮</span></div><div class="line">-(<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView shouldHighlightItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 高亮完成后回调  </span></div><div class="line"><span class="comment">// 放大缩小效果</span></div><div class="line">-(<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class="line">        selectedCell.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">2.0</span>f, <span class="number">2.0</span>f);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 由高亮转成非高亮完成时的回调  </span></div><div class="line">-(<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">UICollectionViewCell</span> *selectedCell = [collectionView cellForItemAtIndexPath:indexPath];</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:kAnimationDuration animations:^&#123;</div><div class="line">        selectedCell.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>f, <span class="number">1.0</span>f);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="点击cell选中"><a href="#点击cell选中" class="headerlink" title="点击cell选中"></a>点击cell选中</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置是否允许选中  </span></div><div class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView shouldSelectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __FUNCTION__);  </div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">// 设置是否允许取消选中  </span></div><div class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView shouldDeselectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __FUNCTION__);  </div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">// 选中操作  </span></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __FUNCTION__);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">// 取消选中操作  </span></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didDeselectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;  </div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __FUNCTION__);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="FlowLayout代理方法"><a href="#FlowLayout代理方法" class="headerlink" title="FlowLayout代理方法"></a>FlowLayout代理方法</h2><h3 id="设置每个item大小"><a href="#设置每个item大小" class="headerlink" title="设置每个item大小"></a>设置每个item大小</h3><ul>
<li>@property (CGSize)itemSize</li>
<li>-collectionView:ayout:sizeForItemAtIndexPath:</li>
</ul>
<p>可以设置全局属性也可以对某个cell定制尺寸。</p>
<h3 id="item间隔"><a href="#item间隔" class="headerlink" title="item间隔"></a>item间隔</h3><ul>
<li>@property (CGSize) minimumInteritemSpacing</li>
<li>@property (CGSize) minimumLineSpacing</li>
<li>-collectionView:layout:minimumInteritemSpacingForSectionAtIndex:</li>
<li>-collectionView:layout:minimumLineSpacingForSectionAtIndex:</li>
</ul>
<p>同itemsize，可以设置全局属性也可以定制。</p>
<h3 id="缩进（padding）"><a href="#缩进（padding）" class="headerlink" title="缩进（padding）"></a>缩进（padding）</h3><ul>
<li>@property UIEdgeInsets sectionInset;</li>
<li>-collectionView:layout:insetForSectionAtIndex:</li>
</ul>
<p>同上。</p>
<h3 id="设置headerview的layout"><a href="#设置headerview的layout" class="headerlink" title="设置headerview的layout"></a>设置headerview的layout</h3><ul>
<li>@property (CGSize) headerReferenceSize</li>
<li>@property (CGSize) footerReferenceSize</li>
<li>-collectionView:layout:referenceSizeForHeaderInSection:</li>
<li>-collectionView:layout:referenceSizeForFooterInSection:</li>
</ul>
<p>同上。</p>
<h2 id="UICollectionViewLayout子类"><a href="#UICollectionViewLayout子类" class="headerlink" title="UICollectionViewLayout子类"></a>UICollectionViewLayout子类</h2><h2 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h2><p>UICollectionView和UITableView最重要的区别就是UICollectionView并不知道如何布局，它把布局机制委托给了UICollectionViewLayout子类，默认的布局方式是UICollectionFlowViewLayout类提供的流式布局。不过也可以创建自己的布局方式，通过继承UICollectionViewLayout。</p>
<p>子类需要覆盖父类以下3个方法：</p>
<ul>
<li>prepareLayout</li>
<li>layoutAttributesForElementsInRect:(CGRect)rect</li>
<li>collectionViewContentSize</li>
</ul>
<hr>
<p>应用场景示例：<br>为了实现大小不同的cell，可以应用在上文实现UICollectionViewDelegateFlowLayout的协议方法collectionView:layout:sizeForItemAtIndexPath:。但是它会计算每排的最大高度，并不是一个流式视图。<br>因此就需要继承UICollectionViewLayout来自己实现一个流式布局的效果。</p>
<hr>
<h3 id="void-prepareLayout"><a href="#void-prepareLayout" class="headerlink" title="-(void)prepareLayout"></a>-(void)prepareLayout</h3><p>初始化参数</p>
<h3 id="CGSize-collectionViewContentSize"><a href="#CGSize-collectionViewContentSize" class="headerlink" title="-(CGSize)collectionViewContentSize"></a>-(CGSize)collectionViewContentSize</h3><p>布局首先要提供的信息就是滚动区域大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。</p>
<h3 id="NSArray-layoutAttributesForElementsInRect-CGRect-rect"><a href="#NSArray-layoutAttributesForElementsInRect-CGRect-rect" class="headerlink" title="-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect"></a>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</h3><p>实现必须返回一个包含<strong>UICollectionViewLayoutAttributes</strong>对象的数组.其中包括：中心(center)，尺寸(size)，透明度(alpha)，层级(zIndex)，动画效果(transform3D),隐藏(hidden)等。UICollectionViewLayoutAttributes对象决定了cell的摆设位置（frame）。</p>
<p>传入参数rect是一个包含要显示区域的块。这个块的大小一般为2倍的collectionview的长度，只有滑动即将超过rect的范围，rect才会改变数值，保证了显示范围内的所有元素都在rect内。这个参数只是框定了显示范围，自定义layout的时候并不需要用到这个参数，而是使用contentOffset等属性，设置位置信息。</p>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><ul>
<li><strong>-(CGPoint)targetContentOffsetForProposedContentOffset:withScrollingVelocity：</strong><br>当手放开时调用，返回值以及参数proposedContentOffset决定了collectionview停止滚动时的偏移量。velocity是滚动速率，有x和y两个分量，正表示向右或向下运动。<br>每次移动整数个view的长度，示例代码：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGPoint</span>)targetContentOffsetForProposedContentOffset:(<span class="built_in">CGPoint</span>)proposedContentOffset withScrollingVelocity:(<span class="built_in">CGPoint</span>)velocity &#123;</div><div class="line">    <span class="built_in">CGFloat</span> index = roundf((<span class="keyword">self</span>.scrollDirection == <span class="built_in">UICollectionViewScrollDirectionVertical</span> ? proposedContentOffset.y : proposedContentOffset.x)/ _itemHeight);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollDirection == <span class="built_in">UICollectionViewScrollDirectionVertical</span>) &#123;</div><div class="line">        proposedContentOffset.y = _itemHeight * index;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        proposedContentOffset.x = _itemHeight * index;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> proposedContentOffset;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对item缩放翻转"><a href="#对item缩放翻转" class="headerlink" title="对item缩放翻转"></a>对item缩放翻转</h3><p>在layoutAttributesForElementsInRect:(CGRect)rect方法中设置<strong>transform3D</strong>的值。transform3D是一个4*4的矩阵，用来控制view的形状。其中：</p>
<ul>
<li>m11主要负责x轴缩放</li>
<li>m22主要负责y轴缩放</li>
<li>m33主要负责z轴缩放</li>
<li>其余值综合控制旋转与翻折</li>
</ul>
<p>具体使用方法以后再写。</p>
<h3 id="是否刷新布局"><a href="#是否刷新布局" class="headerlink" title="是否刷新布局"></a>是否刷新布局</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> !<span class="built_in">CGRectEqualToRect</span>(newBounds, <span class="keyword">self</span>.collectionView.bounds);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>划出范围就会调用该方法，控制是否刷新视图。如果返回no，那么久不会再调用prepareLayout以及layoutAttributesForElementsInRect等方法。</p>
<h3 id="删除item"><a href="#删除item" class="headerlink" title="删除item"></a>删除item</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    [self.dataArr removeObjectAtIndex:indexPath.item];</div><div class="line">    //TODO:  这个方法 特别注意 删除item的方法</div><div class="line">    [self.myCollectionView deleteItemsAtIndexPaths:@[indexPath]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCD队列 学习与整理]]></title>
      <url>http://zhang759740844.github.io/2016/08/02/GCD%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>Serial vs. Concurrent 串行 vs. 并发</strong><br>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</li>
<li><strong>Synchronous vs. Asynchronous 同步 vs. 异步</strong><br>在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个同步函数只在完成了它预定的任务后才返回。一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</li>
</ul>
<h3 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h3><ol>
<li><strong>Serial Queues 串行队列</strong><br>这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。<br>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区，实现了锁的功能。</li>
<li><strong>Concurrent Queues 并发队列</strong><br>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。</li>
</ol>
<h3 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h3><ol>
<li><strong>The main queue</strong><br>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。因为main queue是与主线程相关的，所以这是一个串行队列。由于是系统默认生成的，所以无法调用dispatch_resume()和dispatch_suspend()来控制执行继续或中断。这是在一个并发队列上完成任务后更新 UI 的共同选择。</li>
<li><strong>Global queues</strong><br>全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。同样无法控制主线程dispatch队列的执行继续或中断。需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数。</li>
<li><strong>用户队列</strong><br>用户自己创建的队列。可以创建单线程的串行队列，也可以创建多线程的并行队列。</li>
</ol>
<h3 id="队列创建方式"><a href="#队列创建方式" class="headerlink" title="队列创建方式"></a>队列创建方式</h3><ol>
<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.serial”, DISPATCH_QUEUE_SERIAL);</strong><br>生成一个串行队列。第一个参数是队列的名称，在调试程序时会非常有用，所有尽量不要重名。第二个参数表示生成的队列是串行的，如果传入 null 默认是串行的。</li>
<li><strong>dispatch_queue_t queue = dispatch_queue_create(“com.dispatch.concurrent”, DISPATCH_QUEUE_CONCURRENT);</strong><br>生成一个并发执行队列。</li>
<li><strong>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</strong><br>获得全局队列。</li>
<li><strong>dispatch_queue_t queue = dispatch_get_main_queue()</strong><br>获得主线程队列。</li>
</ol>
<h3 id="提交-Job"><a href="#提交-Job" class="headerlink" title="提交 Job"></a>提交 Job</h3><p>向一个队列提交Job很简单：调用dispatch_async或dispatch_sync函数，传入一个队列和一个block。队列会在轮到这个block执行时执行这个block的代码。</p>
<ol>
<li><p><strong>dispatch_async</strong><br>dispatch_async 函数会立即返回, block会在后台异步执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        [<span class="keyword">self</span> goDoSomethingLongAndInvolved];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Done doing something long and involved"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 在典型的Cocoa程序中，你很有可能希望在任务完成时更新界面，这就意味着需要在主线程中执行一些代码。你可以简单地完成这个任务——使用嵌套的dispatch，在外层中执行后台任务，在内层中将任务dispatch到main queue：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        [<span class="keyword">self</span> goDoSomethingLongAndInvolved];</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [textField setStringValue:<span class="string">@"Done doing something long and involved"</span>];</div><div class="line">        &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>dispatch_sync</strong><br>dispatch_sync 同步执行block，函数不返回，一直等到block执行完毕。一般情况下是在当前线程中完成，因为派发同步任务，本身就要等到任务完成才能继续执行，那么就没有必要再开一个线程去专门执行这个同步任务，执行完后，再返回该线程了。但是如果在其他线程里往主队列里派发同步任务，那么这个同步任务还是会在主线程里执行，当前线程阻塞。</p>
</li>
</ol>
<p>实际编程经验告诉我们，尽可能避免使用dispatch_sync，嵌套使用同一个队列时极易产生程序死锁，比如嵌套调用主线程：</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/gcd_死锁.png?raw=true" alt="gcd_死锁"></p>
<p><strong>总结：队列是串行或并发的，操作队列的函数是同步或者异步执行的。一个队列中的任务可以在不同线程中执行。</strong></p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><p><strong>dispatch_apply</strong><br>重复执行block，需要注意的是这个方法是同步返回，也就是说等到所有block执行完毕才返回。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class="line">    [<span class="keyword">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class="line">&#125;);</div><div class="line">[<span class="keyword">self</span> doSomethingWith:array];</div></pre></td></tr></table></figure>
<p> 如果需要异步执行这些代码，只需要用dispatch_async方法，将所有代码推至后台。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    dispatch_apply([array count], queue, ^(size_t index)&#123;</div><div class="line">        [<span class="keyword">self</span> doSomethingIntensiveWith:[array objectAtIndex:index]];</div><div class="line">    &#125;);</div><div class="line">    [<span class="keyword">self</span> doSomethingWith:array];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 那何时才适合用 dispatch_apply 呢？</p>
<ul>
<li><p>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</p>
</li>
<li><p>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</p>
</li>
<li><p>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</p>
</li>
</ul>
</li>
<li><p><strong>dispatch_after</strong><br>延迟提交 block：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>; </div><div class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">     <span class="comment">// code to be executed on the main queue after delay</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>dispatch_after 是延迟提交，不是延迟运行，<strong>不是在特定的时间后立即运行！</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">//立即打印一条信息</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Begin add block..."</span>);</div><div class="line"></div><div class="line"><span class="comment">//提交一个block</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="comment">//Sleep 10秒</span></div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"First block done..."</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//5 秒以后提交block</span></div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After..."</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">27.122</span> GCDTest[<span class="number">45633</span>:<span class="number">1812016</span>] Begin add block...</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">37.127</span> GCDTest[<span class="number">45633</span>:<span class="number">1812041</span>] First block done...</div><div class="line"><span class="number">2015</span><span class="number">-03</span><span class="number">-31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">37.127</span> GCDTest[<span class="number">45633</span>:<span class="number">1812041</span>] After...</div></pre></td></tr></table></figure>
<p>对于这个串行的队列，先 async 执行了阻塞10秒，此时，添加一个5秒的延时任务。由于5秒前一个任务还未返回，所以延迟任务不能立刻执行。当前一个任务返回后，延迟任务执行时发现已经过了预定时间，那么立即执行。</p>
<ol>
<li><strong>dispatch_once</strong><br>保证在APP运行期间，block中的代码只执行一次<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// code to be executed once</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>一定要注意的是 <code>dispatch_once_t</code> <strong>必须是全局或 static 变量</strong>。否则使用时会导致非常不好排查的 bug。</p>
<ol>
<li><strong>dispatch_group</strong><br>一个dispatch group可以用来将多个block组成一组以监测这些Block全部完成或者等待全部完成时发出的消息。</li>
</ol>
<ul>
<li><em>dispatch_group_create</em>创建一个调度任务组</li>
<li><em>dispatch_group_async</em> 把一个任务异步提交到任务组里</li>
<li><em>dispatch_group_notify</em> 用来监听任务组事件的执行完毕</li>
<li><em>dispatch_group_wait</em> 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)</div><div class="line">    dispatch_group_async(group, queue, ^&#123;</div><div class="line">        [<span class="keyword">self</span> doSomethingIntensiveWith:obj];</div><div class="line">    &#125;);</div><div class="line">dispatch_group_notify(group, queue, ^&#123;</div><div class="line">    [<span class="keyword">self</span> doSomethingWith:array];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一个参考文章：<br><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解TCP-IP学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/07/31/%E5%9B%BE%E8%A7%A3TCP_IP/</url>
      <content type="html"><![CDATA[<p>本文是对《图解TCP-IP》一书学习后摘录的笔记。都是网络中最基础的知识。虽然是图解，但是传图太麻烦。就不截图了。˙<br><a id="more"></a></p>
<h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p>ISO制定了国际标准OSI，对通信系统进行了标准化。</p>
<ul>
<li><strong>应用层</strong>：针对特定应用的协议。</li>
<li><strong>表示层</strong>：设备固有数据格式和网络标准设局格式的转换。</li>
<li><strong>会话层</strong>：通信管理，负责建立和断开通信连接。</li>
<li><strong>传输层</strong>：管理两个节点之间的数据传输。</li>
<li><strong>网络层</strong>：地址管理和路由选择。</li>
<li><strong>数据链路层</strong>：互联设备间传送和识别数据帧。</li>
<li><strong>物理层</strong>：01代表高低平的互换</li>
</ul>
<h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><ul>
<li><strong>电路交换</strong>：交换机负责数据中转处理。计算机首先被连接到交换机上，交换机与交换机之间由众多通信线路再继续连接。因此计算机间发送数据时，需要通过交换机与目标主机建立通信电路。建立好后，可以一直使用该条电路，直到断开连接。一台计算机在收发信息时会独占整条电路，其他计算机只能等待该计算机处理结束。如电话线路。</li>
<li><strong>分组交换</strong>：将要发送的数据分成多个数据包，按照一定的顺序排列后发送。数据被细分后，所有计算机可以一齐发送数据。</li>
</ul>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><ul>
<li><strong>MAC地址</strong>：MAC地址由设备的制造厂商针对每块网卡进行制定。通过制造商识别号，内部产品编号等确保MAC地址的唯一性。</li>
<li><strong>IP地址</strong>：IP地址由网络号和主机号两部分组成。具有层次性。</li>
</ul>
<p>MAC寻址参考的表叫地址转发表，IP寻址参考的是路由控制表。交换机通过地址转发表，将数据转发至对应路由器。路由器通过路由控制表将数据转发给对应路由。再由路由转发给接收的交换机，进而转给接收的主机。。</p>
<h3 id="网络的构成元素"><a href="#网络的构成元素" class="headerlink" title="网络的构成元素"></a>网络的构成元素</h3><ul>
<li><strong>网卡</strong>：计算机连接网络需要使用网卡，全称：网络接口卡(NIC)。</li>
<li><strong>中继器</strong>：OSI模型第一层，物理层面上延长网路的设备。对电缆传来的减弱的信号进行放大和发送给另外一个电缆的设备。</li>
<li><strong>网桥</strong>：OSI模型第二层，数据链路上连接两个网络设备。能够识别数据链路层中的数据帧，将数据帧存储于内存，在重新生成一个全新的帧转发给相连的另一个网段。</li>
<li><strong>路由器/3层交换机</strong>：OSI第三层，连接两个网络，并对分组报文进行转发的设备。网桥更具MAC地址进行处理，而路由器/3层交换机更具IP地址进行处理。</li>
<li><strong>4-7层交换机</strong>：负责处理OSI模型中从传输层到应用层的数据。</li>
<li><strong>网关</strong>：负责OSI传输层到应用层的数据进行转换和转发的设备。还可以根据两个不能通行的协议之间进行翻译，最终实现两者的通信。代理服务器也是网关的一种，客户端和服务器间不是在网络层上直接通信，而是从传输层到应用层对数据的访问进行各种控制和处理。防火墙也是一种网关。</li>
</ul>
<h2 id="TCP-IP基础知识"><a href="#TCP-IP基础知识" class="headerlink" title="TCP/IP基础知识"></a>TCP/IP基础知识</h2><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><ul>
<li><strong>硬件(物理层)</strong></li>
<li><strong>网络接口层(数据链路层)</strong></li>
<li><strong>互联网层(网络层)</strong><ul>
<li>IP：跨越网络发送数据包，使整个互联网都能收到数据的协议。</li>
<li>ICMP：IP数据包发送途中出现异常无法发送到目标地址时，给发送端一个异常通知。ICMP就是为这一功能定制的</li>
<li>ARP：从分组数据包的IP地址解析出物理地址(MAC地址)的一种协议。</li>
</ul>
</li>
<li><strong>传输层</strong><ul>
<li>TCP：面向连接的传输层协议。可以保证两端通信主机间的通信可达。</li>
<li>UDP：面向无连接的传输层协议。</li>
</ul>
</li>
<li><strong>应用层(会话层以上的分层)</strong><ul>
<li>WWW</li>
<li>电子邮件(E-Mail)</li>
<li>文件传输(FTP)</li>
<li>远程登录(TELNET,SSH)</li>
<li>网络管理(SNMP)</li>
</ul>
</li>
</ul>
<h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><h3 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h3><p>数据链路层定义了一个通过通信媒介互连的设备之间传输的规范。</p>
<p>数据链路的<strong>段</strong>是指一个被分割的网络。引入中继器，将两条网线连接组成一个网络。</p>
<p>网络的连接和构成形态成为<strong>网络拓扑</strong>。</p>
<h3 id="数据链路相关技术"><a href="#数据链路相关技术" class="headerlink" title="数据链路相关技术"></a>数据链路相关技术</h3><p><strong>共享介质型网络</strong>：多个设备共享一个通信介质的一种网络。共享介质网络两种访问方式：争用方式，令牌传递方式。早期以太网就是共享介质型网络。</p>
<p><strong>非共享介质网络</strong>：网络中每个站直连交换机，由交换机转发数据帧。此方法下，发送端和接收端并不共享通信介质。</p>
<p>以太网交换机是持有多个端口的网桥，根据数据链路层中每个帧的目标MAC地址，决定从哪个网络接口发送数据。这时所参考的，用以记录发送接口的表就是转发表。</p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>众多数据链路中最著名，使用最广发的是以太网。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="IP即网络协议"><a href="#IP即网络协议" class="headerlink" title="IP即网络协议"></a>IP即网络协议</h3><p>网络层的下一层——数据链路层主要作用是在互连<strong>同一种数据链路节点</strong>之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同数据链路，即使在不同数据链路上也能实现两端节点之间的数据包传输。</p>
<p>配有IP的地址的设备称为主机。和路由器不同，路由器即配有IP地址，又具有路由控制能力。节点是主机和路由器的统称。</p>
<p><strong>网络层与数据链路层关系</strong>：数据链路层提供直连两个设备的能力。与之相比，网络层的IP则负责在没有直连的两个网络之间进行通信传输。比如旅行，数据链路相当于各个中转的火车票，而IP相当于真个旅行表。没有车票，无法达到目的地，没有旅行表，则不知道做什么车。</p>
<h3 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h3><p>IP大致分为三大模块，IP寻址，路由，IP分包和组包。</p>
<p>为识别通信对端，必须有一个类似于地址的识别码进行标识。MAC地址正是用来标识同一个链路中不同计算机的一种识别码。IP也有这种地址信息，用于在连接到网络中的所有主机中识别出进行通信的目标地址。因此，TCP/IP中所有主机或路由必须设定自己的IP地址。</p>
<p>路由控制将分组数据发送到最终目标地址。为了将数据发给目标主机，所有主机都维护着一张路由控制表。该表记录IP数据在下一步应该发给哪个路由器。IP包将更具这个路由表在各个数据链路上传输。</p>
<p>IP是实现多个数据链路之间通信的协议。数据链路根据种类不同各有特点。不同数据链路最大区别在于它们各自的最大传输单位不同。为解决这个问题，IP进行分片处理。将较大的IP包分成多个较小的IP包，到达对端目标地址后再组合传输给上一层。</p>
<h3 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h3><p>IP地址由网络标识和主机标识组成。网络标识必须保证相互连接的每个段的地址不重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。</p>
<p>IP地址的分类：</p>
<ol>
<li>A类：以0开头的地址，即0.0.0.0-127.0.0.0，地址后24位为主机标识</li>
<li>B类：以10开头的地址，即128.0.0.1-191.255.0.0 地址后16为为主机标识</li>
<li>C类：以110开头的地址，即192.168.0.0-239.255.255.0 地址后8位为主机标识</li>
<li>D类：以1110开头的地址，即224.0.0.0-239.255.255.255 无主机标识，多用于多播。</li>
</ol>
<p><strong>广播地址</strong>用于在同一个链路中互相连接的主机间发送数据。将主机地址部分全部设置为1，就成了广播地址。</p>
<p><strong>多播</strong>用于将包发送给特定组内的所有主机。凡是以1110开头的都是多播地址，剩下的28为是多播的组编号。</p>
<p>网络标识相同的计算机必须属于同一链路，但如A类B类将产生大量浪费的地址，因为不可能有那么多主机连接在一个链路上。现在，可以通过一个叫做”<strong>子网掩码</strong>“的识别码通过子网网络地址细分出比ABC更小粒度的网络。<br>子网掩码也是32位，对应网络地址的部分为1，对应主机地址的部分对应为0.</p>
<p>由于互联网的普及，IP地址不足问题严重。于是出现私有网络的IP地址。它的地址范围：A类，10.0.0.0-10.2555.255.255；B类，172.16.0.0-172.31.255.255；C类，12.168.0.0-192.168.255.255。包含在这个范围内的IP都属于<strong>私有IP</strong>，在此之外的IP称为<strong>全局IP</strong>。内部每个终端使用私有IP，而在路由器(宽带路由器)或必要服务器上设置全局IP。当配有私有IP的主机联网时，使用NAT进行通信。</p>
<p>对于FTTH和ADSL服务，网络供应商直接给用户分配全局IP地址，并且每次用户重连，该IP地址都可能发生变化。这里的IP地址由供应商维护，不需要用户自己申请全局IP。</p>
<h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>仅仅有IP地址不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要指明路由器或主机的信息，以便真正发往目标地址。保存这种信息的就是<strong>路由控制表</strong>。</p>
<p>路由控制表记录着网络地址和下一步应该发送至路由器的地址。发送IP包时，先确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。</p>
<h2 id="IP协议相关"><a href="#IP协议相关" class="headerlink" title="IP协议相关"></a>IP协议相关</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS将主机名字符串转换为具体的IP地址。</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>只要确定了IP地址，就可以想这个目标发送IP数据包，但是底层数据链路层，进行实际通信是却要了解每个IP地址所对应的MAC地址。</p>
<p>ARP是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不再同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。</p>
<p>从一个IP地址发送ARP请求包以了解其MAC地址。目标地址将自己的MAC地址填入其中的ARP响应包返回到IP地址。由此，可以通过<strong>ARP</strong>从IP地址获得MAC地址，实现链路内的IP通信。</p>
<p>根据ARP可以进行动态的地址解析。因此，在TCP/IP网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios编程(第四版) 学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/07/31/ios%E7%BC%96%E7%A8%8B%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      <content type="html"><![CDATA[<p>本文是对《ios编程(第四版)》一书学习后摘录的笔记，属于ios开发基础。</p>
<a id="more"></a>
<h2 id="第一个ios应用"><a href="#第一个ios应用" class="headerlink" title="第一个ios应用"></a>第一个ios应用</h2><h3 id="声明插座变量"><a href="#声明插座变量" class="headerlink" title="声明插座变量"></a>声明插座变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>
<p>声明了一个叫questionLabel的插座变量.<br><strong>IBOutlet</strong>告诉Xcode需要使用Interface Builder关联该插座变量。</p>
<h3 id="声明动作方法"><a href="#声明动作方法" class="headerlink" title="声明动作方法"></a>声明动作方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)showQuestion:(<span class="keyword">id</span>)sender&#123;</div><div class="line">	……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>IBAction</strong>关键字告诉Xcode会使用Interface Builder关联该数据。之后创建关联。</p>
<h3 id="应用图标"><a href="#应用图标" class="headerlink" title="应用图标"></a>应用图标</h3><p>Images.xcassets目录下存放着所有图片，其中LaunchImage保存启动图片。</p>
<h2 id="objective-c"><a href="#objective-c" class="headerlink" title="objective-c"></a>objective-c</h2><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>实例方法使用的字符是-，类方法使用字符+。<br>类方法作用通常是创建对象，获取类的某些全局属性。</p>
<h2 id="通过ARC管理内存"><a href="#通过ARC管理内存" class="headerlink" title="通过ARC管理内存"></a>通过ARC管理内存</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>当某个属性是指向其他对象的指针，并且该对象的类有可修改的子类，如NSString、NSArray时，应该将该属性的内存管理特性设置为copy。相当于发送一个copy消息。<br>当一个不可修改的对象进行copy时，返回原来对象。当一个可修改对象进行copy时，返回新创建的不可修改对象。</p>
<p>举个例子，比如有个<code>@property(nonatomic,copy) NSString *name</code>。如果不用<code>copy</code>而用<code>strong</code>那么将一个可修改的<code>NSMutableString</code>对象赋给<code>name</code>时，那就直接将<code>name</code>指向<code>NSMutableString</code>对象。此时，<code>NSMutableString</code>修改了自身的string值，那么相当于<code>name</code>的值也改变了，这和设计原则相悖。因此，需要使用<code>copy</code>,当<code>NSMutableString</code>对象赋给<code>name</code>时，深复制一个新的不可修改的对象，让<code>name</code>指向它，如果<code>NSString</code>对象赋给<code>name</code>时，浅赋值，将<code>NSString</code>的引用计数器加一。</p>
<p>copy和strong的区别就是：</p>
<ul>
<li>对于不可修改对象没有区别，都是直接返回对象地址</li>
<li>对于可修改对象，copy新创建一个不可修改的原对象的实例，并返回地址。strong直接返回原对象地址。</li>
</ul>
<h2 id="视图与视图层次结构"><a href="#视图与视图层次结构" class="headerlink" title="视图与视图层次结构"></a>视图与视图层次结构</h2><h3 id="视图层次结构"><a href="#视图层次结构" class="headerlink" title="视图层次结构"></a>视图层次结构</h3><p>任何一个应用有且只有一个UIWindow对象。UIWindow包含应用中的所有视图。应用需要在启动时创建并设置UIWindow对象，然后为其添加其他视图。<br>层次结构中每个视图分别绘制自己。视图会将自己绘制到图层(layer)上，每个UIView对象都有一个layer属性，指向一个CALayer类的对象。</p>
<h3 id="创建UIView子类"><a href="#创建UIView子类" class="headerlink" title="创建UIView子类"></a>创建UIView子类</h3><p>UIView子类模板会自动生成一个方法 <strong>initWithFrame:</strong>，该方法是UIView的指定初始化方法，带有一个CGRect结构类型的参数，该参数会被赋给UIView的frame属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> （<span class="keyword">nonatomic</span>） <span class="built_in">CGRect</span> frame；</div></pre></td></tr></table></figure>
<p>CGRect结构包含另外两个结构：origin和size。origin是CGPoint类型，包含两个float类型的x，y。size是CGSize结构，包含两个float类型的width和height。<br>创建CGRect对象：CGRect firstFrame = CGRectMake（160，240，100，150）；</p>
<p>可以使用addSubView方法来添加子视图： [self.window addSubview:firstView]。<br>每个UIView对象都还有一个superView属性，将一个视图作为子视图加入另一个视图后，会自动创建相应的反向关联。为避免强引用循环，superview是弱引用。<br>bounds表示的矩形位于自己的坐标系，frame表示的矩形位于父视图的坐标系。</p>
<h3 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h3><p>没看</p>
<h2 id="视图：重绘与UIScrollView"><a href="#视图：重绘与UIScrollView" class="headerlink" title="视图：重绘与UIScrollView"></a>视图：重绘与UIScrollView</h2><h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3><p>设置scrollView.contentSize = bigRect.size;这是整个滚动范围的大小。<br>在scrollview中addSubView。</p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><h3 id="视图控制器-1"><a href="#视图控制器-1" class="headerlink" title="视图控制器"></a>视图控制器</h3><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器都负责管理一个视图层次结构。<br>使用UITabBarController的类在两个视图控制器间切换。  </p>
<p>UIViewController有一个重要属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</div></pre></td></tr></table></figure>
<p>这个view就是视图的根视图。</p>
<h3 id="创建视图层次结构"><a href="#创建视图层次结构" class="headerlink" title="创建视图层次结构"></a>创建视图层次结构</h3><ol>
<li><p>覆盖UIViewController的loadView方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)loadView&#123;</div><div class="line">        BNRHypnosisView *backgroundView = [[BNRHypnosisView alloc] init];</div><div class="line">        <span class="keyword">self</span>.view = backgroundView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 此时view尚未创建，不能对其进行addview操作。只能创建一个view让self.view指向。</p>
</li>
<li><p>通过xib创建<br>.m中声明各个控件(注意控件使用弱引用)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *questionLabel</div></pre></td></tr></table></figure>
<p> 再通过连线将File’s Owner的view以及各种控件连接到xib的图像上。</p>
</li>
</ol>
<h3 id="设置根视图控制器"><a href="#设置根视图控制器" class="headerlink" title="设置根视图控制器"></a>设置根视图控制器</h3><p>UIWindow对象提供了setRootViewController：方法。当程序将某个视图控制器设置为UIWindow对象的rootViewController时，UIWindow对象会将该视图控制器的view作为子视图加入窗口。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BNRHypnosisViewController *hvc = [[BNRHypnosisViewController alloc] init];</div><div class="line"><span class="keyword">self</span>.window.rootViewController = hvc;</div></pre></td></tr></table></figure></p>
<p>setRootViewController其实就是将ViewController的view设置为其subview。</p>
<h3 id="加载nib文件"><a href="#加载nib文件" class="headerlink" title="加载nib文件"></a>加载nib文件</h3><p>加载不同名的nib文件时，需要使用<strong>initWithNibName:Bundle:</strong>方法。该方法的两个参数，分别用于指定NIB文件文件名和其<strong>所在的程序包</strong>。如果是Bundle传入nil默认是[NSBundle mainBundle];</p>
<h3 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h3><p>UITabBarController对象可以保存一组视图控制器。该对象会在屏幕底部显示一个标签栏，标签栏会有多个标签项，分别对应UITabBarController对象所保存的每一个视图控制器。单击某个标签项，UITabBarController对象就会显示该标签项所对应的视图控制器的视图。   </p>
<p>在APPDelegate中创建两个视图控制器，加入Tabbar的<strong>viewControllers</strong>属性中，并将tabbar设置为rootViewController<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITabBarController</span> *tabBarController = [[<span class="built_in">UITabBarController</span> alloc] init];</div><div class="line">tabBarController.viewControllers = @[hvc,rvc] <span class="comment">//两个viewController 可以写在tabbarController的viewDidLoad方法里</span></div><div class="line"><span class="keyword">self</span>.window.rootViewController = tabBarController;</div></pre></td></tr></table></figure></p>
<p>设置标签项，使用<strong>tabBarItem</strong>属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *orderImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"tab_order"</span>];</div><div class="line"><span class="built_in">UIImage</span> *orderImageSel = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"tab_order_active"</span>];</div><div class="line">orderImage = [orderImage imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysTemplate</span>];</div><div class="line">orderImageSel = [orderImageSel imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysTemplate</span>];</div><div class="line"><span class="built_in">UITabBarItem</span> *orderTabBarItem = [[<span class="built_in">UITabBarItem</span> alloc] initWithTitle:<span class="string">@"订单"</span> image:orderImage selectedImage:orderImageSel];</div><div class="line">orderNav.tabBarItem = orderTabBarItem;</div></pre></td></tr></table></figure>
<p>为tabbar添加subview，UITabBarController里有一个<strong>tabBar</strong>的view</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *backview = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.tabBar.bounds];</div><div class="line">[backview setBackgroundColor:[<span class="built_in">UIColor</span> whiteColor]];</div><div class="line">[<span class="keyword">self</span>.tabBar addSubview:backview];</div></pre></td></tr></table></figure>
<h3 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a>本地通知</h3><p>本地通知需要创建一个UILocalNotification对象并设置其显示内容和提醒时间，然后调用UIApplication单例对象的scheduleLocalNotification:方法就实现了注册通知。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILocalNotification</span> *note = [][<span class="built_in">UILocalNotification</span> alloc] init];</div><div class="line">note.alertBody = <span class="string">@"xxx"</span>;</div><div class="line">note.fireDate = date;</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:note];</div></pre></td></tr></table></figure></p>
<h3 id="加载和显示视图"><a href="#加载和显示视图" class="headerlink" title="加载和显示视图"></a>加载和显示视图</h3><p>viewDidLoad方法检查视图控制器是否已经加载，每个UIViewController对象实现了viewDidLoad方法，该方法会在载入视图后被调用。为了实现视图延迟加载，在initWithNibName方法中不能访问任何view和view的任何子视图。凡是和view或view子视图有关的初始化代码，都应该在viewDidLoad方法中实现。<br>另外一个方法viewWillAppear方法会在视图控制器的view添加到应用窗口之前被调用。</p>
<p>如果只要在应用启动后设置一次视图对象，那么用viewDidLoad，如果每次看到视图都需要对其进行设置，那么用viewWillAppear，类似于onCreate和onResume的区别。</p>
<h3 id="与视图控制器及其视图交互"><a href="#与视图控制器及其视图交互" class="headerlink" title="与视图控制器及其视图交互"></a>与视图控制器及其视图交互</h3><p><strong>application:didFinishLaunchingWithOptions:</strong>    该方法中设置和初始化应用窗口的根视图控制器。该方法只会在应用启动后调用一次。如果从其他应用切换回本地应用，该方法不会被调用，如果关闭应用后台在重启才会再次调用。<br><strong>initWithNibName：bundle：</strong>该方法是UIViewController的指定初始化方法，创建视图控制器时，就会调用该方法。<br><strong>loadView：</strong>覆盖该方法，使用代码方式设置视图控制的的view属性。<br><strong>viewDidLoad：</strong>该方法会在视图控制器加载完视图后被调用。<br><strong>viewWillAppear：</strong>该方法会在视图控制器的view显示在屏幕上时被调用。  </p>
<h2 id="委托与文本输入"><a href="#委托与文本输入" class="headerlink" title="委托与文本输入"></a>委托与文本输入</h2><h3 id="委托（代理模式）"><a href="#委托（代理模式）" class="headerlink" title="委托（代理模式）"></a>委托（代理模式）</h3><p>当某个特定事件发生时，发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。<br>例：UITextField对象有一个委托属性，通过为UITextField对象设置委托，委托实现一个协议中的各个方法，UITextField对象会在发生事件时向委托发送相应消息，由委托处理该事件。  </p>
<p>类似于android中setOnClickListener(this); 继承onClickListener接口，这里则是设置delegate为self，遵守相应协议。不过android可以使用匿名内部类代替这里的this。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>凡是支持委托的对象，背后都有一个相应的协议，声明可以向该对象的委托对象发送的消息。委托对象需要更具这个协议选取需要的方法实现。如果一个类实现了某个协议中规定的方法，则称类遵守该协议。  </p>
<p>协议声明使用@protocol指令开头，后面跟协议的名称。最后使用@end结束<br>使用@optional指令，可以将写在指令后的全部声明为可选的。<br>发送方在发送可选方法前，会先向其委托发送另一个名为respondsToSelector的消息。所有oc对象都从NSObject继承 respondsToSelector：方法，该方法在运行时检查对象是否实现了指定的方法。  </p>
<p>声明示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BNRHypnosisViewController</span>()&lt;<span class="title">UITextFieldDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="设置异常断点"><a href="#设置异常断点" class="headerlink" title="设置异常断点"></a>设置异常断点</h3><p>当有问题无法找到错误原因时，可以通过添加异常断点定位有问题的代码。</p>
<h3 id="类方法与实例方法"><a href="#类方法与实例方法" class="headerlink" title="类方法与实例方法"></a>类方法与实例方法</h3><p>这里需要注意：</p>
<ol>
<li>类方法可以调用类方法。</li>
<li>类方法不可以调用实例方法，但是类方法可以通过创建对象来访问实例方法。</li>
<li>类方法不可以使用实例变量。类方法可以使用self，因为self不是实例变量。<ul>
<li>实例方法里面的self，是对象的首地址。</li>
<li>类方法里面的self，是Class.</li>
</ul>
</li>
<li>类方法作为消息，可以被发送到类或者对象里面去（实际上，就是可以通过类或者对象调用类方法的意思）。</li>
</ol>
<h2 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h2><h3 id="UINavigationController对象"><a href="#UINavigationController对象" class="headerlink" title="UINavigationController对象"></a>UINavigationController对象</h3><p>UINavigationController独享显示多个屏幕信息时，相应的UINavigationController对象会以栈的形式保存所有屏幕信息。初始化UINavigationController对象时，需要传入一个UIViewController对象作为UINavigationController对象的根视图控制器，且根视图控制器将永远位于栈底。</p>
<p>UINavigationController对象有一个名为<strong>viewControllers</strong>的属性，指向一个负责保存视图控制器的数组。<strong>topViewController</strong>属性是一个指针，指向当前位于栈顶的视图控制器。</p>
<p>UINavigationController是UIViewController的子类，所以UINavigationController有自己的视图。该视图有<strong>两个子视图</strong>：一个是<strong>UINavigationBar对象</strong>，一个是<strong>topViewController的视图</strong>。</p>
<p>初始化UINavigationController对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINavigationController</span> *navController = [[<span class="built_in">UINavigationController</span> alloc]initWithRootViewController:viewController];</div></pre></td></tr></table></figure></p>
<h3 id="关联xib"><a href="#关联xib" class="headerlink" title="关联xib"></a>关联xib</h3><p>不要将子视图设置在view的最顶端。在视图控制器中，view会衬于UINavigationBar下方，导致UInavigationBar遮挡view最顶端内容。（UITabBar同样）</p>
<p>在xib中按住Control拖拽到类拓展中，可以快速创建一个带IBOutlet前缀的属性。</p>
<p>设置xib文件时，要确保关联正确，产生错误的常见原因是：修改了某个插座变量的变量名，但是没有更新xib文件中的相应关联。</p>
<h3 id="将视图控制器压入栈"><a href="#将视图控制器压入栈" class="headerlink" title="将视图控制器压入栈"></a>将视图控制器压入栈</h3><p>使用UINavigationController对象时，通常会由处于栈顶的视图控制器来负责压入另一个视图控制器。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.navigationController pushViewController:detailController animated:<span class="literal">YES</span>];</div></pre></td></tr></table></figure></p>
<p>视图控制器发送navigationController消息，可以得到指向UINavigationController对象的指针。</p>
<h3 id="视图控制器间传递数据"><a href="#视图控制器间传递数据" class="headerlink" title="视图控制器间传递数据"></a>视图控制器间传递数据</h3><h3 id="NavigationBar"><a href="#NavigationBar" class="headerlink" title="NavigationBar"></a>NavigationBar</h3><p>UIViewController对象有一个navigationItem属性，类型为UINavigationItem。和NavigationBar不同，不是UIView的子类，不能显示，而是为UINavigationBar提供绘图所需内容。当UIViewController成为UINavigationController的栈顶对象时，UINavigationBar对象会访问该UIViewController对象的navigationItem，获取和界面显示相关的内容。</p>
<p>UINavigationItem除了设置title属性外，还可以设置其他属性：leftBarButtonItem，rightBarButtonItem和titleView。titleView可以将原有title的位置替换为一个view。</p>
<p>创建一个buttonItem：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initNavigationView&#123;</div><div class="line">    <span class="built_in">UIButton</span> *backBtn = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">44</span>)];</div><div class="line">    [backBtn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"systemback"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [backBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(backButtonPressedForOrder:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">    <span class="built_in">UIBarButtonItem</span> *leftItem  = [[<span class="built_in">UIBarButtonItem</span> alloc]initWithCustomView:backBtn];</div><div class="line">    [<span class="keyword">self</span>.navigationItem setLeftBarButtonItem:leftItem];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[objective-c 学习笔记]]></title>
      <url>http://zhang759740844.github.io/2016/07/31/objectice-c/</url>
      <content type="html"><![CDATA[<p>开始IOS开发必然要先学会objective-c，本篇是阅读了《object-c编程》一书后摘录的笔记，比较浅显。</p>
<a id="more"></a>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以有很多局部变量，这些变量都会保存在函数的帧中。这些帧存于栈内。执行函数时，函数的帧会在栈的顶部被创建。函数返回时，帧退出栈，等待下一个调用它的函数继续执行。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数外声明的变量，只要类被import就能使用。<br>Java中不存在这种全局变量，只能定义一个类，通过类名，资源名访问。<br>为了防止混淆问题，引用静态变量。与全局变量一样，也需要在函数外声明。不过只有某个声明静态变量的文件才能访问。好处是：既保留了非局部的、存在于任何函数之外的优点，又避免了其他文件修改的问题。<br><strong>那么这和@property有什么区别？</strong>静态变量是持久的，存储于静态存储区，在程序刚运行时就被唯一一次初始化，不会像property随着实例化而变化。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>&amp;表示取地址，*表示取值。<br>空指针用nil而不是null。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>使用结构保存多个相关数据。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Person&#123;</div><div class="line">	<span class="keyword">float</span> height；</div><div class="line">	<span class="keyword">int</span> age；</div><div class="line">&#125;；</div></pre></td></tr></table></figure></p>
<p>使用：<code>struct Person mikey；</code><br>使用typedef简化。typedef可以为某类型声明一个等价的别名，该别名用法和常规数据类型无异。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="keyword">float</span> height；</div><div class="line">	<span class="keyword">int</span> age；</div><div class="line">&#125; Person；</div></pre></td></tr></table></figure></p>
<p>使用：<code>Person mikey；</code></p>
<h3 id="获取结构中的属性："><a href="#获取结构中的属性：" class="headerlink" title="获取结构中的属性："></a>获取结构中的属性：</h3><p>当结构的使用者是一个指针时，使用-&gt;表示先获取指针p指向的数据结构，然后返回该结构的成员变量。<br>当结构的使用者是一个实例时，使用.表示访问属性。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id %@"></a>id %@</h3><p>id表示可以指向任意类型的指针。变量声明不使用星号。id已经隐含了星号的作用。<br>InstanceType表示方法的返回类型。<br>%@表示占位符，代表指针，会向相应指针变量对象发送description消息。</p>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><p>@“…”表示创建一个NSString对象。需要知道字符串完整内容。<br>也可使用stringWithFormat方法动态创建：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *dateString = [<span class="built_in">NSString</span> stringWithFormat:@“The date is %@”, now]</div></pre></td></tr></table></figure></p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><p>创建：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dateList = @[now, tomorrow ,yesterday];</div></pre></td></tr></table></figure></p>
<p>NSArray是无法改变的，被创建后无法添加删除以及改变顺序。<br>快速遍历数组：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">NSDate</span> *d <span class="keyword">in</span> daeList)&#123;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h3><p>可变数组，可添加删除和修改顺序。<br>insertObject：atIndex在指定位置插入<br>removeObject：atIndex删除数组中对象<br>快速遍历时不能添加删除数组内数据。</p>
<h3 id="自定义一个类"><a href="#自定义一个类" class="headerlink" title="自定义一个类"></a>自定义一个类</h3><p>头文件以@interface开始，@end结束。花括号内声明实例变量，实例变量以下划线”_”开始<br>取方法名字和相应实例变量一样，弹药去掉实例变量开头的下划线。存方法以set开头，后面更上去掉下划线的实例变量名。</p>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>self是指针，指向运行当前方法的对象。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性的声明以@property开头，然后是类型和名称。属性自动声明存取方法。<br>使用”.”获取属性其实是在发送消息，调用getset方法。语法糖。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>NSObject是所有类的基类，拥有一个实例变量：isa指针。任何一个对象的isa指针都指向创建爱你该对象的类。发送消息时，对象查询是否有该消息名的方法。没有则继续查询父类。父类也没有，查找参数超类。</p>
<h3 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h3><p>一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.<br>如果ClassA.h中仅需要声明一个ClassB的指针，那么就可以在ClassA.h中声明@ClassB</p>
<h3 id="类拓展"><a href="#类拓展" class="headerlink" title="类拓展"></a>类拓展</h3><p>类拓展是一组私有的声明。只有类和其实例才能使用在类拓展中声明的属性方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import “BNREmployee.h”</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BNREmployee</span>()	</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">unsigned</span> <span class="keyword">int</span> officeAlarmCode;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意要有括号，写在implement前面。<br>头文件中的属性相当于公有，可以通过同样公有的getset方法获取。类拓展无法则无法在其它类中直接获得，必须手动设置getset方法。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>通过弱引用可以解决强引用循环。强引用会保留对象的拥有方，使其不会释放。弱引用则不会保留。</p>
<h3 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a>Collection类</h3><p>NSSet对象包含的内容是无序的，并且在NSSet对象中，特定对象只能出现一次。其最大用处是检查某个对象是否存在。NSMutableSet可以添加删除set内数据。<br>NSDictionary对象是键值对集合。字典的字面量语法由@和{}组成。字典里的键是独一无二的。<br>NSMutable是NS的子类。<br>collection不能保存nil。如果要保存nil则要保存NSNull类的实例。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[hotel addObject:[<span class="built_in">NSNull</span> null]];</div></pre></td></tr></table></figure></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>可以通过两种途径定义常量，#define和全局变量。  </p>
<ol>
<li>#define A B 告诉编译器看到A用B替换</li>
<li>extern NSString const *NSLocaleCurrencyCode；<br>const表示指针的不会变化,extern表示指针是存在的，但是会在另一个文件里定义。提示编译器遇到此变量和函数时在其他模块中寻找其定义</li>
</ol>
<h3 id="include和-import"><a href="#include和-import" class="headerlink" title="#include和#import"></a>#include和#import</h3><p>import会确保预处理器只导入特定的文件一次，include允许多次导入同一个文件。最好使用import。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议可以为一个对象指定角色。类似于接口。如果某个对象要扮演特定的角色，就一定要实现相应的必须方法，并选择实现部分可选方法。<br>UITableView数据源协议是UITableViewDataSource，方法声明如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@protocal <span class="built_in">UITableViewDataSource</span>&lt;<span class="built_in">NSObject</span>&gt;</div><div class="line"><span class="keyword">@required</span></div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tv</div><div class="line">	numberOfRowsInSection:(<span class="built_in">NSInteger</span>) section;</div><div class="line"><span class="keyword">@optional</span></div><div class="line">…….</div></pre></td></tr></table></figure></p>
<h3 id="范畴"><a href="#范畴" class="headerlink" title="范畴"></a>范畴</h3><p>通过范畴（category）可以为任何已有的类添加方法。<br>创建一个新文件，类型为Objective-c category，将新范畴命名为BNRVowelCounting，对应类为NSString。<br>打开NSString+BNRVowelCounting.h为范畴声明一个方法。该方法会被加入NSString类。<br>声明示例：NSString+MD5.h<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">MD5</span>)</span></div><div class="line">+ (<span class="built_in">NSString</span> *)md5:(<span class="built_in">NSString</span> *)originalStr;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="编程的一些建议"><a href="#编程的一些建议" class="headerlink" title="编程的一些建议"></a>编程的一些建议</h3><ul>
<li>应该是哪个类的工作，就将相关的东西放到那个类中，能让思路更清晰。</li>
<li>类之间操作，我可以直接操作那个类，也可以等到一个触发事件后，让那个类问我如何操作。这条要灵活运用。一般来说，等那个类问我要再操作，是个比较好的方法，类似于懒加载，而且如果那种类多的话，不需要我一个个去操作，哪个类要执行了，找我就可以了。但是，这也是有限制的，一个就是必须要有触发条件，那个类能主动找我要操作方法，还有一个是，我必须把要给其他类的东西先存起来，这样才能让别的类读取。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重新开始]]></title>
      <url>http://zhang759740844.github.io/2016/07/30/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>时隔接近一年，终于还是准备重开个人网站。过去一年学了很多，记了很多，这是我感到非常宽慰的。知识是要不断巩固的，个人网页不见得要给别人看到，自己没事的时候经常翻翻自己曾经做了什么，学了什么。无形中，也是一种记忆的脚印。</p>
<a id="more"></a>
<p>不过，之前一来对于git，hexo的掌握程度较低，二来没有仔细检查备份，导致在迁移的时候，辛辛苦苦写的十几篇笔记都丢失了。一度非常懊恼，不想再做这些费时费力的事了。</p>
<p>今天，终于又耐下性子，把整个个人网站又弄起来了。虽然功能还是很简单，全当是一个记录的地方吧。总之，这就算是重新开始了。这也算是一个新的起点吧。多做总结，多做分享。希望自己能够保持学习的动力，再接再厉！</p>
<p><img src="https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/Come_on.jpg?raw=true" alt="fighting"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://zhang759740844.github.io/2016/07/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
