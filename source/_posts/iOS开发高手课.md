title: 《iOS开发高手课阅读笔记》
date: 2019/9/9 14:07:12  
categories: iOS
tags: 

 - 学习笔记
	
---

很早就买了戴铭老师的专栏，每一篇都是干货。也正是因为干货太多，所以不太愿意零碎的去学，怕知识点看过就忘了。因此，花了两个晚上，把**我能看明白的**高手课做了整理。

<!--more-->

## App 启动速度优化与监控

### 冷启动与热启动

- 冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 
- 热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。

### App 启动三个阶段

1. main() 函数执行前；
2. main() 函数执行后；
3. 首屏渲染完成后。

#### main() 函数执行前

在 main() 函数执行前，系统主要会做下面几件事情：

1. 加载可执行文件（App 的.o 文件的集合）；
2. 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； 
3. Objc runtime 的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等；
4.  初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。

因此，我们可以通过相应的一下几种方式优化：

1. 减少动态库。尽量将动态库合并。
2. 减少不用的类或者方法。
3. +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 替换。
4. 控制 C++ 全局变量的数量

#### main() 函数执行后

main()函数执行后的阶段，指的是从main()函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里首屏渲染相关方法执行完成。

因此，我们应该考虑哪些初始化操作是首屏渲染必须的，哪些是对应功能开始时才需要初始化的。

#### 首屏渲染完成后

首屏渲染完成后，就要进行非首屏其他业务模块的初始化，监听的注册，配置文件的读取等。这个阶段就是从渲染完成开始，到 didFinishLaunchingWithOptions 方法作用域结束。

### 监控方法时长

- **定时抓取主线程上方法调用堆栈，计算一段时间里各个方法的耗时。** Xcode 中的 Time Profile 就是这么做的。时间间隔一般设置为 0.01s。间隔太长容易监听不到所有方法的执行。
- **对objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时**。hook objc_msgSend 方法能够精确获取 OC 方法执行时间。对于 c 和 block，可以使用 libffi 的 ffi_call 完成 hook。

我们可以通过 fishhook hook objc_msgSend。fishhook 的原理可以看我之前的博客。

>  emmmm。一大段一大段的汇编代码有点难懂。。。暂时先知道通过这种方式可以实现方法调用时间就行了



## 链接器

### 为什么要有链接器？

没有这个绑定过程的话，单个文件生成的 Mach-O 文件是无法正常运行起来的。因为，如果运行时碰到调用在其他文件中实现的函数的情况时，就会找不到这个调用函数的地址，从而无法继续执行。

链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。链接时如果出现相同符号的情况，就会出现“ld: dumplicate symbols”的错误信息；如果在其他目标文件里没有找到符号，就会提示“Undefined symbols”的错误信息。

### 链接器做了什么？

1. 去项目文件里查找目标代码文件里没有定义的变量。 
2. 扫描项目中的不同文件，将所有符号定义和引用地址收集起来，并放到全局符号表中。 
3. 计算合并后长度及位置，生成同类型的段进行合并，建立绑定。 
4. 对项目中不同文件里的变量进行地址重定位。

### 动态库链接

Mach-O 文件是编译后的产物，而动态库在运行时才会被链接，并没参与 Mach-O 文件的编译和链接，所以 Mach-O 文件中并没有包含动态库里的符号定义。也就是说，这些符号会显示为“未定义”，但它们的名字和对应的库的路径会被记录下来。运行时通过 dlopen 和 dlsym 导入动态库时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。 dlopen 会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。

加载过程开始会修正地址偏移，iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 Clang Attribute 的 constructor 修饰函数。

### dyld 做了什么？

1. 先执行 Mach-O 文件，根据 Mach-O 文件里 undefined 的符号加载对应的动态库，系统会设置一个共享缓存来解决加载的递归依赖问题； 
2. 加载后，将 undefined 的符号绑定到动态库里对应的地址上； 
3. 最后再处理 +load 方法，main 函数返回后运行 static terminator。
4. 



