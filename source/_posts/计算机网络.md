title: 计算机网络
date: 2017/9/25 10:07:12  
categories: 计算机
tags:

	- 学习笔记
---

大学的时候没有学过计算机网络，现在补一下，啃啃书

<!--more-->



## 计算机网络与因特网

#### 分组交换

在各种网络应用中，端系统彼此交换**报文**(message)。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为**分组**(packet)。在源和目的之间，每个分组都通过通信链路和**分组交换机**(主要由**路由器**和**链路层交换机**)传送。

##### 存储转发传输

多数分组交换机在链路输入端使用**存储转发传输**机制。存储转发机制指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。

##### 排队时延和分组丢失

每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个**输出缓存**，它用于存储路由器准备发往那个链路的分组。如果到达的分组发现链路正忙于传输其他分组，那么该分组必须在该输出缓存中等待。缓存空间是有限的，如果该缓存已被其他等待传输的分组充满了。就会出现**分组丢失(丢包)**，到达的分组或已经排队的分组之一将被丢弃。

##### 转发表和路由选择协议

每一个端系统具有一个称为 IP 的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的 IP。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。每台路由器具有一个**转发表**，用于将目的地址隐射成输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。因特网具有一些特殊的**路由选择协议**，用于自动的设置这些转发表。

#### 封装

在发送主机端，一个**应用层报文**被传送给运输层。传输层收到报文并附上附加信息(Ht)，被接收端的传输层使用。应用层报文和传输层首部信息构成了**传输层报文段**。传输层向网络层传递该报文段，网络层添加了如源和目的端系统地址等网络层首部信息(Hn)，产生**网络层数据报**。该数据接下来传递给链路层，链路层怎家它自己的链路层首部信息并创建**链路层帧**。

我们看到在每一层，一个分组具有两种类型的字段：首部字段和**有效载荷字段**。有效载荷通常来自于上一层的分组。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network1.png?raw=true)



## 应用层

### 应用层协议原理

#### 进程通信

进行通信的是**进程**。一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则是由端系统上的操作系统确定。在两个不同端系统上的进程，通过跨越计算机网络交换**报文(message)**通信。

##### 进程与计算机网络之间的接口

进程通过一个称谓**套接字(socket)**的软件接口向网络发送报文和从网络接收报文。如图所示，套接字是同一台主机内应用层与传输层之间**应用程序编程接口(API)**:

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network2.png?raw=true)

##### 进程寻址

在一台主机上的进程为了向另一台主机上的进程发送分组，需要一个地址。为了标识接收进程，需要定义两种信息：1.主机地址。2.目的主机中的接收进程的标识符。主机由**IP地址**标识。接收进程的标识符由**端口号**标识。已经给主流的引用分配了特定的端口号。如Web服务器的端口号为80；邮件服务器进程(使用SMTP协议)的端口号为25。

#### 可供引用使用的传输服务

传输层协议要为应用程序提供的服务的要求大致为：可靠数据传输、吞吐量、实时、安全。

#### 因特网提供的运输服务

因特网为应用程序提供两个传输层协议，**TCP** 和 **UDP**。

TCP 包括面向连接服务(握手)和可靠数据传输服务。对于安全性，因特网界研制了 TCP 的加强版，**安全套接字层(Secure Sockets Layer,SSL)**。UDP 是无连接的，是一种不可靠数据传送服务。

### Web 和 HTTP

#### HTTP 概况

Web 的应用层协议是**超文本传输协议**。HTTP 定义了报文的结构以及客户和服务器进行报文交换的方式。

HTTP 使用 TCP 作为它的支撑运输协议。HTTP 客户首先发起一个与服务器的 TCP 连接。连接一旦建立，浏览器和服务器进程就可以通过套接字接口访问 TCP，向它的套接字接口发送 HTTP 请求报文并从它的套接字接口接受 HTTP 响应报文。

#### 非持续连接和持续连接

每个请求/响应对是一个单独的 TCP 连接发送，该应用程序被称为使用**非持续连接**，所有的请求及其响应经相同的 TCP 连接发送，该应用程序被称为使用**持续连接**。

非持续连接在 HTTP 服务器进程经它的套接字向客户发送响应报文后，通知 TCP 断开 TCP 连接。

TCP 的三次握手过程：客户向服务器发送一个小 TCP 报文段，服务器用一个小 TCP 报文段做出确认和响应，最后，客户向服务器发送一个 HTTP 请求(握手成功)，服务器随后在该 TCP 连接上返回响应。整个请求响应过程如图：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network3.png?raw=true)

持续连接的情况下，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与与服务器之间的后续请求和响应报文能够通过相同的连接传送。如果一个连接经过一段时间未被使用，HTTP 服务器就会关闭。

#### HTTP 报文格式

HTTP 报文分为两种：请求报文和响应报文。

##### 请求报文

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network4.png?raw=true)

上图是一个典型的请求报文。HTTP 请求报文的第一行叫做**请求行**，其后继的行叫做**首部行**。请求行有3个字段：方法字段，URL 字段和 HTTP 版本字段。首部行包括很多字段：

- Host 指明对象所在的主机。
- Connection:close 告诉服务器使用非持续连接。
- User-agent 表示浏览器类型为 Mozila/5.0 即火狐浏览器。
- Accept-language 表示用户想要的是法语版本

在首部行以及一行空行之后，有一个**实体主体**。使用 GET 方式时实体体为空，POST 方法才用到。当使用 POST 时，实体体中包含的就是用户在表单字段中的输入值。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network5.png?raw=true)

##### 响应报文

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network7.png?raw=true)

这个响应报文有三个部分：一个初始**状态行**，6个**首部行**，然后是**实体体**。实体体部分是报文的主要部分，包含了请求的对象本身。状态行有三个字段：协议版本字段、状态码和相应状态信息。首部行中的字段除了上面说过的还有：

- Server 表示该报文是由一台 Apache Web 服务器产生的
- Data 表示服务器发送该响应报文的日期和时间
- Last-Modified 表示对象最后修改的日期和时间

#### 用户与服务器的交互：cookie

一个 Web 站点通常希望能够识别用户。为此，HTTP 提供了 cookie。它允许站点对用户进行跟踪。当请求到达服务器时，该站点将产生一个唯一识别码，一次作为索引在后端数据库中产生一个表项。接下来服务器用一个包含 Set-cookie 首部的 HTTP 响应报文对客户进行响应，其中 Set-cookie 首部包含该识别码：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network6.png?raw=true)

#### Web 缓存

**Web缓存器**也叫**代理服务器**。Web 缓存器有自己的存储空间，存储空间中保存最近请求过的对象的副本。

对于某个请求，在 Web 缓存器中有的，就走 Web 缓存器。没有的，由 Web 缓存器请求服务器，然后返回给客户端。所以 Web 缓存器既是服务器也是客户。当它接受浏览器的请求并且返回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。

通过使用**内容分发网络(Content Distribution Network,CDN)**，Web 缓存器正在因特网中发挥着越来越重要的作用。CDN 公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。

#### 条件 GET 方法

现在有一个问题是存放在缓存器中的对象副本可能是陈旧的。HTTP 协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是**条件GET**。如果请求报文使用 GET方法，并且请求报文中包含一个`If-Modified-Since:` 首部行。那么这个 HTTP 请求报文就是一个 条件 GET 请求报文。

浏览器发送一个条件 GET 请求给缓存器，然后缓存器向服务器发送一个条件 GET 请求。之后服务器向该缓存器发送一个相应报文，如果状态行为 `304 Not Modified`，它告诉缓存器可以使用该对象，能向请求的浏览器转发其缓存的对象副本。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network8.png?raw=true)

### 文件传输协议：FTP

FTP 使用两个并行的 TCP 连接来传输文件，一个是**控制连接**，一个是**数据连接**。控制链接用于在两台主机之间传输控制信息，如用户标识、口令、改变远程目录等。数据连接用于实际发送一个文件。

对 FTP 传输而言，控制连接贯穿了整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接(即控制连接是持续的，数据连接是非持续的)。

### 电子邮件

一个典型的邮件发送过程是：发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。

#### 邮件访问协议

**简单邮件传输协议(Simple Mail Transfer Protocol,SMTP)**被设计成将电子邮件从一台主机推送到另一台主机。但是接收方的用户代理不能使用 SMTP 取回报文，因为取报文是一个拉操作，而 SMPT 协议是一个推协议。目前有一些流行的邮件访问协议，包括**第三版的邮局协议(Post Office Protocol—Version 3,POP3)**、**因特网邮件访问协议(Intenrnet Mail Access Protocol,IMAP)**。看一个具体流程，注意标注的协议：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network9.png?raw=true)

使用 POP3 访问时，接收方可以将邮件下载到主机后，在本地建立邮件文件夹。但是 POP3 协议没有给用户提供任何创建远程文件夹并未报文指派文件夹的方法。为了解决这个问题，IMAP 应用而生，它管理远程的邮件。

现在更多的人习惯于用 Web 浏览器发送接收邮件。使用 Web 发送邮件的协议是 HTTP，不过这指的是客户端和服务器之间的协议，服务器与服务器之间还是以 SMTP 发送的。

### DNS：因特网的目录服务

主机需要进行标识。一种表示方法是使用**主机名**，这种便于记忆，但是没有提供主机在网络中的位置信息。另一种使用**IP地址**，便于路由器处理，但是不便于人记忆。因此，我们需要两者之间的映射。

#### DNS 提供的服务

**域名系统(Domain Name System,DNS)**的主要任务是IP地址和域名的转换。DNS 表示一个由分层的 **DNS 服务器** 实现的分布式数据库，也表示一个使得主机能够查询分布式数据库的应用层协议。DNS 协议运行在 UDP 上，使用 53号端口。

浏览器在请求某个网页时，取出主机名，向 DNS 服务器发送一个包含主机名的请求。DNS 客户最终会收到一份回答报文，抱恨了主机名对应的 IP 地址。

DNS 能够实现**负载分配**。繁忙的站点会有多台服务器，每台都有着不同的IP地址，即一个域名对应多个IP。当客户发起一个 DNS 请求时，DNS 服务器会返回该域名的所有 IP。DNS 服务器会在每个回答中循环这些地址次序。因为客户总是想 IP 地址排在最前面的服务器发送 HTTP 请求报文，所以 DNS 就分配了负载。

#### DNS 工作机理

没有一台 DNS 服务器拥有所有的主机的映射，该映射分布在所有的 DNS 服务器上。大致来说，有三种类型的 DNS 服务器：**根 DNS 服务器**。**顶级域(Top-Level Domain,TLD) DNS 服务器**和**权威 DNS 服务器**。

比如要获取 `www.amazon.com` 的IP地址。客户首先和根服务器之一联系，它将返回顶级域名(.com)的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一联系，它将为 `amazon.com` 返回权威服务器的IP地址。最后，该客户与 `amazon.com` 权威服务器之一联系，它为主机名 `www.amazon.com` 返回IP地址。

除了上面说的三种 DNS 服务器，还有一类中昂要的 DNS，**本地 DNS 服务器**。主机向它的本地 DNS 服务器发送一个 DNS 查询报文。本地 DNS 服务器查看是否有未过期的IP地址(或权威 DNS 服务器地址，或 TLD DNS 服务器地址)。如果有，直接返回，如果没有再请求根 DNS 服务器。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network10.png?raw=true)

事实上，本地 DNS 服务器也可以是多级的，比如你的路由器是本地 DNS 服务器的第一级，然后它再将运营商提供的服务器或者其它服务器作为本地 DNS 服务器的第二级。

DNS 劫持是指本地 DNS 服务器返回一个错误的IP地址，如要打开谷歌结果打开百度。HTTP 劫持指的是在返回的报文中添加自己代码，如广告。

### P2P应用

在客户-服务器文件分发中，服务器必须向每个对等放发送一个文件的副本，消耗量大量的服务器贷款。在 P2P 文件分发中，每个对等方能重新分发它所有的该文件的任何部分，从而在分发过程中协助该服务器。



## 传输层

### 概述与传输层服务

传输层协议是在端系统同而不是在路由器中实现的。发送端，传输层将报文转换为传输层分组。具体是将应用报文划分为较小的块，并为每块加上一个传输层首部来完成**报文段**。然后将报文段交给网络层。网络层只作用域网络层字段，不检查封装在传输层报文段中的字段。

#### 传输层和网络层关系

网络层提供了主机之间的逻辑通信，传输层为运行在不同主机上的进程之间提供逻辑通信。

#### 因特网传输层概述

传输层提供两个协议 TCP 和 UDP，网络层提供一个 IP 协议。IP 的服务模型是**尽力而为交付服务**，即不确保报文段的交付，不确保报文段按序交付，不确保报文段中数据的完整性，所以 IP 是**不可靠服务**。

TCP 和 UDP 的最基本责任是将两个端系统的 IP 交付服务拓展为两个进程的交付服务。将主机间交付拓展到进程间交付被称为**传输层的多路复用**与**多路分解**

UDP 和 IP 一样，是一种不可靠服务。TCP 则提供**可靠数据传输**，并且还提供**拥塞控制**，即控制流量速度。

### 多路复用与多路分解

一个进程可能有多个**套接字**。传输层实际上没有将数据直接交给进程，而是交给了中间的套接字。每一个套接字都有唯一标识符。每个传输层报文段中有几个字段用来将数据交付到正确的套接字，这个过程称为**多路分解**。在源主机从不同套接字中手机数据块，并加上首部信息生成报文段，然后将报文段传送到网络层，这个过程叫做**多路复用**

其实上面说的字段就是不同端口号，分为**源端口号字段**，**目的端口号字段**。在主机上，每个套接字可以分配一个端口号，当报文到达主机后，传输层检查报文段中的目的端口号，并将其定向到对应的套接字。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network11.png?raw=true)



### 无连接传输：UDP

传输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据。UDP 就是如此，除了复用/分解以及少量的差错检测外，基本没有对 IP 增加别的东西。UDP 首部包括如下四个字段：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network12.png?raw=true)

### 可靠数据传输原理

这一节从浅入深介绍了可靠数据传输会发生的问题。我这里就简单的总结一下。

#### 构造可靠数据传输协议

第一点，底层信道是不可靠的，分组中的比特可能受损。对于这种情况，解决方式是接收方返回一个确认信息。如果获得**肯定确认**，则继续下一个分组的传递，如果**否定确认**，则重传，这叫做**自动重传请求协议**。当发送方处于等待确认信息的时候，它不能从上层获得更多的数据，这样的协议叫做**停等协议**。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network13.png?raw=true)

第二点，在上一点的基础上，我们不能保证确认信息是否受损。解决办法是当收到含糊不清的确认信息的时候重新发送当前分组。这样产生的问题是如果接收方返回的是肯定确认，那么发送发重发分组，接收方就会以为是下一个分组的信息了。解决办法是为每一个分组添加一个序号，它可以让接收方知道是否正在重传前一个分组。如果序号与上次相同，就表示重传了，只要把本次分组丢弃，再次返回肯定确认就行了。下图所示的是 0 号分组和 1 号分组的交替传递：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network14.png?raw=true)

第三点，在第二点的基础上，发送方需要接收到接收方的确认信息才会选择继续还是重新发包，如果发送方没有收到接受消息呢？发送方需要选择一个时间值，以判定是否丢包。图示和上面的都一样，只是加了个定时器。

#### 流水线可靠数据传输协议

上面面临另一个问题，停等协议这种发一条确认一条非常的慢，我们需要允许发送多个分组而无需等待确认，这种技术叫做**流水线**。有两种方式：**回退N步**，**选择重传**。

#### 回退N步

**回退N步(GBN)协议**，允许发送多个分组，不需等待确认。如果确认信息有误，发送方重传所有已发送但还未被确认的分组。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network15.png?raw=true)

如图所示，分组2丢失了，接收方会丢弃后面的分组，然后依旧发送分组1的确认信息，表示没有接收到分组2。当发送方收到两次分组1的确认信息，或者像该图一样确认信息超时时，发送方重新发送分组2及以后的信息。

#### 选择重传

GBN协议存在着一定的性能问题。**选择重传(SR)** 接收方将确认一个正确接收的分组而不管其他是否按序。失序的分组将被缓存知道所有丢失分组都收到为止。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network16.png?raw=true)

分组依次发送，窗口满的时候等待确认信息。接收方收到那条分组就发送哪条分组的确认信息。

### 面向连接的传输：TCP

#### TCP 连接

客户首先发送一个特殊的 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后客户在用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据，第三个报文段可以承载有效载荷。由于在两台主机之间发送了3个报文段，所以这种连接建立过程被称为**三次握手**

客户进程通过套接字传递数据流。数据一旦通过套接字，就由 TCP 控制了。TCP 将这些数据引导到该连接的发送缓存里，时不时从缓存里取出一块数据。TCP 可从缓存中取出并放入报文段中数据数量受限于**最大报文段长度(Maximum Segment Size,MSS)**。当 TCP 发送一个大文件，例如某 Web 页面上的一个图像时，TCP 通常是将该文件划分成长度为 MSS 的若干块。

TCP 为每块客户数据配上一个TCP 首部，从而形成多个 **TCP 报文段**。当 TCP 在另一端接收到一个报文段后，该报文段的数据就被放入 TCP 连接的接收缓存中。TCP 每一端都有各自的发送缓存和接收缓存。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/network17.png?raw=true)

#### TCP 报文段结构

TCP 的报文结构和 UDP 一样，都包含**源端口号**，**目的端口号**，**校验和字段**。TCP 报文段还包含以下字段：

- 32bit 的**序号字段**和 32bit 的**确认号字段**。这两者用来实现可靠数据传输服务。
- 16bit 的**接收窗口字段**，用于流量控制，指示接收方愿意接受的字节数量。
- 4bit 的**首部长度字段**，该字段只是了以 32bit 的字为单位的 TCP 首部长度。由于 TCP 选项字段的原因，TCP 首部长度是可变的。
- 可选与变长的**选项字段**，用于标识发送方和接收方协商的最大报文长度(MSS)，一般为空
- 6bit 的**标志字段**，RST、SYN、FIN 用于连接建立和拆除。其他三个用到再说。



#### 往返时间的估计与超时











































































