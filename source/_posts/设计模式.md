title: 设计模式学习
date: 2017/8/5 10:07:12  
categories: 计算机
tags:
	- 架构
---

学习架构的时候复习一下设计模式

<!--more-->



## 面向对象设计原则

### 单一职责原则

> **单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。**

一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。

 单一职责原则是实现**高内聚、低耦合**的指导方针，需要设计人员**发现类的不同职责并将其分离**。

#### 例子

比如一个类即创建了数据库连接，又查询客户信息，还生成和展示图表。它的职责就有点多了。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_1.png?raw=true)

重构后将各个功能拆分成不同的类，然后加以组合：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_2.png?raw=true)

> 其实就是，把一个大的功能模块划分为一个个小的功能模块，然后以组合的方式合并这些功能

### 开闭原则

开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。

> **开闭原则：一个软件实体，应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。**

**抽象化是开闭原则的关键**。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成拓展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

#### 例子

下面这个例子主要是通过**里氏代换原则**（抽象类可以转换为实体类）和**依赖倒转原则**（即用抽象类来代替实体类）来实现开闭原则的。开闭原则是目的，里氏代换和依赖倒转是手段。

下面调用两个 Chart 的展示方法，如果是硬编码就会在 ChartDisplay 中写明要调用的类型，通过 if.else 判断：	![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_3.png?raw=true)

```java
......  
if (type.equals("pie")) {  
    PieChart chart = new PieChart();  
    chart.display();  
}else if (type.equals("bar")) {  
    BarChart chart = new BarChart();  
    chart.display();  
}  
...... 
```

现在可以将这个方法抽象出来，通过调用抽象方法来解决：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_4.png?raw=true)

> 其实就是，将多个类中类似的功能抽取出来，作为一个抽象类，以后所有有这个功能的就继承这个抽象类，要调用的时候就调用这个抽象类的方法。

### 接口隔离原则

> **接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。**

每一个接口应该承担一种相对独立的角色，不干不该干的事。接口可以有两种不同的定义：

1. 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“**角色隔离原则**”。
2. 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指**接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口**。

在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。

### 合成复用原则

> **合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的。**

通过继承来进行复用的主要问题在于继承复用会**破坏系统的封装性**，因为继承会将基类的实现细节暴露给子类；从基类**继承而来的实现是静态**的（组合就可以通过抽象类的方式，在运行时随时变换具体的实例），不可能在运行时发生改变，没有足够的灵活性。

#### 例子

比如你想自定义一个 button，那么你可以通过继承实现，重写 `initWithFrame:` 方法。也可以通过为 `UIButton` 添加一个分类 `UIButton+Custom`，在其中添加自己的自定义方法。当然，按照本原则，尽量使用组合的方式。

> 其实就是，组合就是在原来的基础上添加新的方法，可以直接添加（如 iOS 中的分类），也可以通过添加一个属性，由这个属性来执行要实现的方法。
>
> 继承则是在原来方法的基础上修改原方法。

### 迪米特法则

> **迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。**

应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过**引入一个合理的第三者来降低现有对象之间的耦合度**。

#### 例子

下面点击 button 后，会调用各种控件产生变化，这样 button 就要和各种空间耦合。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_5.png?raw=true)

可以通过加入中间件，解耦 button 和其他控件：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_6.png?raw=true)

> 其实就是，通过中间层，减少类与类的耦合



## 六种创建型模式

### 简单工厂模式

难度：2	频率：3

首先，为什么要有工厂？为了**将对象的创建和使用分离**。这样的好处：

1. 这样使得系统更符合单一职责原则。
2. 防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中
3. 可以在一个类拥有多个构造函数

> **简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。**

要点在于：**当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节**。

**缺点**：但是创建具体产品实例的时候，一般是通过 if…else 进行判断的，其实是违反了开闭原则的，所以适用于创建的对象较少时，这样不会造成工厂方法中业务逻辑过于复杂

#### 例子

下面工厂 `ChartFactory` 通过 `getChart:` 方法创建不同的 `Chart` 对象。其内部是通过 if…else 实现的。`HistogramChart`，`LineChart`，`PieChart` 分别实现了**接口** `Chart` 的 `display()` 方法： 

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_7.png?raw=true)

> 其实就是，在抽象类中提供一个静态方法，通过输入参数的不同，创建不同的具体子类实例。





### 工厂方法模式

难度：2	频率：5

> **工厂方法模式：定义一个抽象工厂类，让其子类决定将哪一个产品类实例化。工厂方法模式让一个产品类的实例化延迟到其工厂子类中。**

工厂模式中**不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**

抽象工厂通过反射的方式，动态的创建具体工厂实例，代替简单工厂中的 if…else，满足了开闭原则。

那为什么不直接在简单工厂里使用反射动态地创建具体产品实例呢？反射生成对象只能适用一些最简单的情况，如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。

**缺点**：工厂模式，每一个具体产品都要对应一个具体的工厂方法，会造成类成倍增长。

#### 例子

提供了**接口** `LoggerFactory` 和**接口** `Logger`。`FileLoggerFactory` 和 `DatabaseLoggerFactory` 实现了接口 `LoggerFactory` 的 `createLogger()` 方法；`FileLogger` 和 `DatabaseLogger` 实现了接口 `Logger` 的 `writeLog()` 方法。在实现的时候可以通过反射，动态地创建具体工厂类 `FileLoggerFactory` 和 `DatabaseLoggerFactory`。然后调用各自实现的接口方法  `createLogger:` 创建具体的产品类

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_8.png?raw=true)

> 其实就是，为每一个具体的产品类都创建一个具体的工厂类，来包裹一些复杂的创建过程。抽象类通过反射方式创建具体的工厂，再由工厂实例创建产品实例。



### 抽象工厂模式

难度：4	频率：5

> **抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。**

先要了解两个概念：

1. **产品等级结构**：**产品等级结构即产品的继承结构**，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
2. **产品族**：在抽象工厂模式中，**产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品**，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_9.png?raw=true)

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。

对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改；对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。

**缺点**：在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦

#### 例子

下面是一个定制不同皮肤的例子。由 `SpringSkinFactory` 和 `SummerSkinFactory` 实现了接口 `SkinFactory` 的三个创建对象的方法。同样的，通过反射，动态的创建工厂实例。调用其实现的创建方法获取产品实例：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_10.png?raw=true)

> 其实就是，抽象工厂模式和工厂方法模式没啥大的差别，只不过把几个不同类别(即不同产品等级结构)的东西的创建方法放在一起，减少了工厂类的数量。



### 单例模式

难度：1	频率：4

> **单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。**

**缺点**：单例类没有抽象层，不易于扩展。同时单例类职责过重，即充当了工厂角色，又充当了产品角色

#### 结构

单例类中有一个对象属性，并且声明了一个静态方法。这个静态方法被调用时，会先判断对象是否为空，如果为空就创建一个，然后返回:

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_11.png?raw=true)

### 原型模式

难度：3	频率：3

> 原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。

**缺点**：要为每一个类提供一个克隆方法，当对类进行改造时，需要修改源代码，违反了开闭原则。另外，嵌套多层时，实现代码会较为复杂。

#### 结构

每个要 clone 的类都继承于 Prototype 抽象类，然后实现其 clone 方法，注意这里的方法是实例方法：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_12.png?raw=true)

调用的代码类似：

```java
Prototype obj1  = new ConcretePrototype();
obj1.setAttr("Sunny");
Prototype obj2  = obj1.clone();
```

> 其实就类似于 iOS 中的实现 NSCopy 协议，完成 copyWithZone 方法，然后调用 copy。



### 建造者模式

难度：4	频率：2

> **建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

**建造者模式其实是为了给一个特定对象在不同情况下赋不同值的**。比如你要初始化一个对象，这个对象会根据你给出的 type 不同，将属性初始化为不同的值。你可以用 if…else 判断不同属性赋不同值，但是这样显然违背了开闭原则。所以建造者模式就需要你为每一种 type 创建一个 builder 类，在 builder 中提供对对象的属性进行赋值的方法。然后，创建的时候传入不同的 builder（你也可以通过反射的方式，只传入字符串），调用这些赋值方法，以此达到分拆 if…else 的目的。

#### 结构

抽象类 `Builder` （因为 `Builder` 中含有创建的对象属性，所以不能设置为接口）提供了创建对象的方法以及设置这个对象中的属性的各种方法。会有多个 `ConcreteBuilder` 实现了抽象 `Builder` 的方法。每个 `ConcreteBuilder` 中设置属性方法所设置的属性都是不同的。`Director` 中会保存一个 `Builder` 的实例，可以通过反射创建不同的 `Builder` 设置给 `Director`。同时，`Director` 提供了一个 `construct` 方法，用来调用 `Builder` 中设置属性的方法，我们可以自由控制是否需要设置某一属性（即控制是否调用 `builder` 中设置属性的方法）。最后通过 `getResult()` 返回设置好的对象：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_14.png?raw=true)

建造者模式与抽象工厂模式有点相似，但是**建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品**；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导指挥者如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。**如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。**

#### 例子

下面例子中，`ActorController` 充当指挥者(`Director`)，`ActorBuilder` 充当抽象建造者，`HeroBuilder`、`AngelBuilder` 和 `DevilBuilder` 充当具体建造者，`Actor` 充当复杂产品:

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_13.png?raw=true)

`ActorController` 中预先设置一个 `builder`，然后通过 `construct` 方法调用 `builder` 的各种设置方法，达到设置 `Actor` 的目的。具体的流程上面已经叙述过了。

这里就能看出和工厂方法的不同了，工厂方法会创建出各种类型的 `Actor`，但是建造者模式，只会返回一种类型的 `Actor`，但是属性值会根据 `builder` 的不同而变化。

类比工厂模式，`builder` 其实和 `factory` 基本一致。但是**为什么这里要有一个指挥者(`Director`)**呢？因为有了指挥者就可以控制一个 `builder` 到底要 build 哪些属性。工厂模式的话就不关心要设置哪些属性了，所以工厂模式只创建对象，具体如何设置属性的，隐藏在每个 `factory` 的 create 方法中。

> 其实就是，你只要记住，工厂模式是为了创建不同类型的对象，建造者模式是为了为某个类型的对象设置不同的属性，并且建造者模式多了一个指挥者就行了。两者的实现方式是类似的。



## 七种结构型模式

### 适配器模式

> **适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。**

根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，**在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系**。在实际开发中，**对象适配器的使用频率更高.**

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_15.png?raw=true)

调用目标抽象类的某个方法的时候，通过适配器，转而调用了适配者类的某个方法，完成适配。

#### 例子

##### 对象适配器

对象适配器的适配器（adapter）和适配者（adaptee）是关联关系。下面的 `OperationAdapter` 是实现了接口 `ScoreOperation` 的 `sort` 以及 `search` 方法。可以通过反射的方式自由更改接口 `ScoreOperation` 的实现类以满足开闭原则。在适配器中，真正的实现对象 `QuickSort` 以及 `BinarySearch` 是作为其属性 `sortObj`,`searchObj` 存在的，所以称为关联关系。在调用 `sort`，`search` 方法后，将调用真正的实现方法：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_16.png?raw=true)

##### 类适配器

类适配器的适配器和适配者是继承关系， `Adapter` 是继承于 `Adaptee` 的，实现了 `specificRequest()` 方法.同时， `Adapter` 也实现了接口 `Target` 的 `request()` 方法，在 `request()` 方法中调用实现方法 `specificRequest()`。注意下图和上面结构图的区别：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_17.png?raw=true)



### 桥接模式

难度：3	频率：3

> **桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。**

如果软件系统中某个类存在**两个独立变化的维度**，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。

**缺点**：要能正确识别系统中两个**独立变化**的维度。如果不是独立变化的，那还是不可避免的要通过 if…else 判断。

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_18.png?raw=true)

如图，抽象类 `Abstraction` 为一个维度，它要求它的子类都实现 `operation()` 方法。接口 `Implementor`  是另一个维度，它要求实现它接口的类都需要实现 `operationImpl` 方法。在抽象类 `Abstraction` 中保留有接口 `Implementor` 的具体实现属性 `impl`。两者通过组合的方式实现了同一，能够实现两个维度需要的方法 `operation()` 和 `operationImpl()`。

仍然可以通过反射的方式获得抽象类的实现，和接口的实现。增加新的抽象类或接口实现就可以拓展系统，符合开闭原则。

#### 例子

比如要实现一个图像浏览系统，要能够显示不同格式的图片文件，又要兼容不同的平台。如果不用桥接模式，会产生如下的继承树。因为有格式和平台两个维度，所以继承树有两层：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_19.png?raw=true)

但是使用桥接模式，可以将平台维度作为接口独立出来。以图片维度作为主维度，设置抽象类 `Image`，其中除了自己维度需要的方法 `parseFile()` 外，还保存了平台维度 `ImageImp` 的实例 `imp`。可以通过 `imp.doPaint()` 调用平台维度的方法。

> 其实就是，将主要维度作为抽象类用于继承。次要维度分离为接口。最终还是通过组合的方式，代替继承。





























## 备注

**本文中的所有示意图：紫色的都表示接口类型，蓝色的都表示实体类（如果要在某个类内部保存属性，那么就不能将其设置为接口）**

**本文中的所有示意图：“+” 表示方法，"-" 表示对象**

感谢[史上最全设计模式导学目录](http://blog.csdn.net/lovelion/article/details/17517213)