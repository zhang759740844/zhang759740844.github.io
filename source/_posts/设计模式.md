title: 设计模式学习
date: 2017/8/5 10:07:12  
categories: 计算机
tags:
	- 架构
---

学习架构的时候复习一下设计模式

<!--more-->



## 面向对象设计原则

### 单一职责原则

> **单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。**

一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。

 单一职责原则是实现**高内聚、低耦合**的指导方针，需要设计人员**发现类的不同职责并将其分离**。

#### 例子

比如一个类即创建了数据库连接，又查询客户信息，还生成和展示图表。它的职责就有点多了。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_1.png?raw=true)

重构后将各个功能拆分成不同的类，然后加以组合：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_2.png?raw=true)

> 其实就是，把一个大的功能模块划分为一个个小的功能模块，然后以组合的方式合并这些功能

### 开闭原则

开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。

> **开闭原则：一个软件实体，应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。**

**抽象化是开闭原则的关键**。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成拓展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。

#### 例子

下面这个例子主要是通过**里氏代换原则**（抽象类可以转换为实体类）和**依赖倒转原则**（即用抽象类来代替实体类）来实现开闭原则的。开闭原则是目的，里氏代换和依赖倒转是手段。

下面调用两个 Chart 的展示方法，如果是硬编码就会在 ChartDisplay 中写明要调用的类型，通过 if.else 判断：	![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_3.png?raw=true)

```java
......  
if (type.equals("pie")) {  
    PieChart chart = new PieChart();  
    chart.display();  
}else if (type.equals("bar")) {  
    BarChart chart = new BarChart();  
    chart.display();  
}  
...... 
```

现在可以将这个方法抽象出来，通过调用抽象方法来解决：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_4.png?raw=true)

> 其实就是，将多个类中类似的功能抽取出来，作为一个抽象类，以后所有有这个功能的就继承这个抽象类，要调用的时候就调用这个抽象类的方法。

### 接口隔离原则

> **接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。**

每一个接口应该承担一种相对独立的角色，不干不该干的事。接口可以有两种不同的定义：

1. 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“**角色隔离原则**”。
2. 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指**接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口**。

在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。

### 合成复用原则

> **合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的。**

通过继承来进行复用的主要问题在于继承复用会**破坏系统的封装性**，因为继承会将基类的实现细节暴露给子类；从基类**继承而来的实现是静态**的（组合就可以通过抽象类的方式，在运行时随时变换具体的实例），不可能在运行时发生改变，没有足够的灵活性。

#### 例子

比如你想自定义一个 button，那么你可以通过继承实现，重写 `initWithFrame:` 方法。也可以通过为 `UIButton` 添加一个分类 `UIButton+Custom`，在其中添加自己的自定义方法。当然，按照本原则，尽量使用组合的方式。

> 其实就是，组合就是在原来的基础上添加新的方法，可以直接添加（如 iOS 中的分类），也可以通过添加一个属性，由这个属性来执行要实现的方法。
>
> 继承则是在原来方法的基础上修改原方法。

### 迪米特法则

> **迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。**

应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过**引入一个合理的第三者来降低现有对象之间的耦合度**。

#### 例子

下面点击 button 后，会调用各种控件产生变化，这样 button 就要和各种空间耦合。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_5.png?raw=true)

可以通过加入中间件，解耦 button 和其他控件：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_6.png?raw=true)

> 其实就是，通过中间层，减少类与类的耦合



## 六种创建型模式

### 简单工厂模式

难度：2	频率：3

首先，为什么要有工厂？为了**将对象的创建和使用分离**。这样的好处：

1. 这样使得系统更符合单一职责原则。
2. 防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中
3. 可以在一个类拥有多个构造函数

> **简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。**

要点在于：**当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节**。

**缺点**：但是创建具体产品实例的时候，一般是通过 if…else 进行判断的，其实是违反了开闭原则的，所以适用于创建的对象较少时，这样不会造成工厂方法中业务逻辑过于复杂

#### 例子

下面工厂 `ChartFactory` 通过 `getChart:` 方法创建不同的 `Chart` 对象。其内部是通过 if…else 实现的。`HistogramChart`，`LineChart`，`PieChart` 分别实现了**接口** `Chart` 的 `display()` 方法： 

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_7.png?raw=true)

> 其实就是，在抽象类中提供一个静态方法，通过输入参数的不同，创建不同的具体子类实例。





### 工厂方法模式

难度：2	频率：5

> **工厂方法模式：定义一个抽象工厂类，让其子类决定将哪一个产品类实例化。工厂方法模式让一个产品类的实例化延迟到其工厂子类中。**

工厂模式中**不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构**

工厂方法通过反射的方式，动态的创建具体工厂实例，代替简单工厂中的 if…else，满足了开闭原则。

那为什么不直接在简单工厂里使用反射动态地创建具体产品实例呢？反射生成对象只能适用一些最简单的情况，如果对象的创建过程比较复杂，例如要调用有参构造函数、创建之前要配置环境等等，需要将这些代码封装到工厂中。

**缺点**：工厂模式，每一个具体产品都要对应一个具体的工厂方法，会造成类成倍增长。

#### 例子

提供了**接口** `LoggerFactory` 和**接口** `Logger`。`FileLoggerFactory` 和 `DatabaseLoggerFactory` 实现了接口 `LoggerFactory` 的 `createLogger()` 方法；`FileLogger` 和 `DatabaseLogger` 实现了接口 `Logger` 的 `writeLog()` 方法。在实现的时候可以通过反射，动态地创建具体工厂类 `FileLoggerFactory` 和 `DatabaseLoggerFactory`。然后调用各自实现的接口方法  `createLogger:` 创建具体的产品类

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_8.png?raw=true)

> 其实就是，为每一个具体的产品类都创建一个具体的工厂类，来包裹一些复杂的创建过程。抽象类通过反射方式创建具体的工厂，再由工厂实例创建产品实例。



### 抽象工厂模式

难度：4	频率：5

> **抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。**

先要了解两个概念：

1. **产品等级结构**：**产品等级结构即产品的继承结构**，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
2. **产品族**：在抽象工厂模式中，**产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品**，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_9.png?raw=true)

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。

对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改；对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。

**缺点**：在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦

#### 例子

下面是一个定制不同皮肤的例子。由 `SpringSkinFactory` 和 `SummerSkinFactory` 实现了接口 `SkinFactory` 的三个创建对象的方法。同样的，通过反射，动态的创建工厂实例。调用其实现的创建方法获取产品实例：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_10.png?raw=true)

> 其实就是，抽象工厂模式和工厂方法模式没啥大的差别，只不过把几个不同类别(即不同产品等级结构)的东西的创建方法放在一起，减少了工厂类的数量。



### 单例模式

难度：1	频率：4

> **单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。**

**缺点**：单例类没有抽象层，不易于扩展。同时单例类职责过重，即充当了工厂角色，又充当了产品角色

#### 结构

单例类中有一个对象属性，并且声明了一个静态方法。这个静态方法被调用时，会先判断对象是否为空，如果为空就创建一个，然后返回:

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_11.png?raw=true)

### 原型模式

难度：3	频率：3

> 原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。

**缺点**：要为每一个类提供一个克隆方法，当对类进行改造时，需要修改源代码，违反了开闭原则。另外，嵌套多层时，实现代码会较为复杂。

#### 结构

每个要 clone 的类都继承于 Prototype 抽象类，然后实现其 clone 方法，注意这里的方法是实例方法：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_12.png?raw=true)

调用的代码类似：

```java
Prototype obj1  = new ConcretePrototype();
obj1.setAttr("Sunny");
Prototype obj2  = obj1.clone();
```

> 其实就类似于 iOS 中的实现 NSCopy 协议，完成 copyWithZone 方法，然后调用 copy。



### 建造者模式

难度：4	频率：2

> **建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

**建造者模式其实是为了给一个特定对象在不同情况下赋不同值的**。比如你要初始化一个对象，这个对象会根据你给出的 type 不同，将属性初始化为不同的值。你可以用 if…else 判断不同属性赋不同值，但是这样显然违背了开闭原则。所以建造者模式就需要你为每一种 type 创建一个 builder 类，在 builder 中提供对对象的属性进行赋值的方法。然后，创建的时候传入不同的 builder（你也可以通过反射的方式，只传入字符串），调用这些赋值方法，以此达到分拆 if…else 的目的。

#### 结构

抽象类 `Builder` （因为 `Builder` 中含有创建的对象属性，所以不能设置为接口）提供了创建对象的方法以及设置这个对象中的属性的各种方法。会有多个 `ConcreteBuilder` 实现了抽象 `Builder` 的方法。每个 `ConcreteBuilder` 中设置属性方法所设置的属性都是不同的。`Director` 中会保存一个 `Builder` 的实例，可以通过反射创建不同的 `Builder` 设置给 `Director`。同时，`Director` 提供了一个 `construct` 方法，用来调用 `Builder` 中设置属性的方法，我们可以自由控制是否需要设置某一属性（即控制是否调用 `builder` 中设置属性的方法）。最后通过 `getResult()` 返回设置好的对象：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_14.png?raw=true)

建造者模式与抽象工厂模式有点相似，但是**建造者模式返回一个完整的复杂产品，而抽象工厂模式返回一系列相关的产品**；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型并指导指挥者如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。**如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。**

#### 例子

下面例子中，`ActorController` 充当指挥者(`Director`)，`ActorBuilder` 充当抽象建造者，`HeroBuilder`、`AngelBuilder` 和 `DevilBuilder` 充当具体建造者，`Actor` 充当复杂产品:

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_13.png?raw=true)

`ActorController` 中预先设置一个 `builder`，然后通过 `construct` 方法调用 `builder` 的各种设置方法，达到设置 `Actor` 的目的。具体的流程上面已经叙述过了。

这里就能看出和工厂方法的不同了，工厂方法会创建出各种类型的 `Actor`，但是建造者模式，只会返回一种类型的 `Actor`，但是属性值会根据 `builder` 的不同而变化。

类比工厂模式，`builder` 其实和 `factory` 基本一致。但是**为什么这里要有一个指挥者(`Director`)**呢？因为有了指挥者就可以控制一个 `builder` 到底要 build 哪些属性。工厂模式的话就不关心要设置哪些属性了，所以工厂模式只创建对象，具体如何设置属性的，隐藏在每个 `factory` 的 create 方法中。

> 其实就是，你只要记住，工厂模式是为了创建不同类型的对象，建造者模式是为了为某个类型的对象设置不同的属性，并且建造者模式多了一个指挥者就行了。两者的实现方式是类似的。



## 七种结构型模式

### 适配器模式

> **适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。**

根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，**在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系**。在实际开发中，**对象适配器的使用频率更高.**

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_15.png?raw=true)

调用目标抽象类的某个方法的时候，通过适配器，转而调用了适配者类的某个方法，完成适配。

#### 例子

##### 对象适配器

对象适配器的适配器（adapter）和适配者（adaptee）是关联关系。下面的 `OperationAdapter` 是实现了接口 `ScoreOperation` 的 `sort` 以及 `search` 方法。可以通过反射的方式自由更改接口 `ScoreOperation` 的实现类以满足开闭原则。在适配器中，真正的实现对象 `QuickSort` 以及 `BinarySearch` 是作为其属性 `sortObj`,`searchObj` 存在的，所以称为关联关系。在调用 `sort`，`search` 方法后，将调用真正的实现方法：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_16.png?raw=true)

##### 类适配器

类适配器的适配器和适配者是继承关系， `Adapter` 是继承于 `Adaptee` 的，实现了 `specificRequest()` 方法.同时， `Adapter` 也实现了接口 `Target` 的 `request()` 方法，在 `request()` 方法中调用实现方法 `specificRequest()`。注意下图和上面结构图的区别：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_17.png?raw=true)



### 桥接模式

难度：3	频率：3

> **桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。**

如果软件系统中某个类存在**两个独立变化的维度**，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。

**缺点**：要能正确识别系统中两个**独立变化**的维度。如果不是独立变化的，那还是不可避免的要通过 if…else 判断。

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_18.png?raw=true)

如图，抽象类 `Abstraction` 为一个维度，它要求它的子类都实现 `operation()` 方法。接口 `Implementor`  是另一个维度，它要求实现它接口的类都需要实现 `operationImpl` 方法。在抽象类 `Abstraction` 中保留有接口 `Implementor` 的具体实现属性 `impl`。两者通过组合的方式实现了同一，能够实现两个维度需要的方法 `operation()` 和 `operationImpl()`。

仍然可以通过反射的方式获得抽象类的实现，和接口的实现。增加新的抽象类或接口实现就可以拓展系统，符合开闭原则。

#### 例子

比如要实现一个图像浏览系统，要能够显示不同格式的图片文件，又要兼容不同的平台。如果不用桥接模式，会产生如下的继承树。因为有格式和平台两个维度，所以继承树有两层：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_19.png?raw=true)

但是使用桥接模式，可以将平台维度作为接口独立出来。以图片维度作为主维度，设置抽象类 `Image`，其中除了自己维度需要的方法 `parseFile()` 外，还保存了平台维度 `ImageImp` 的实例 `imp`。可以通过 `imp.doPaint()` 调用平台维度的方法。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_31.png?raw=true)

> 其实就是，将主要维度作为抽象类用于继承。次要维度分离为接口。最终还是通过组合的方式，代替继承。



### 组合模式

难度：3	频率：4

> **组合模式：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。**

组合模式为处理**树形结构**提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得**用户在使用时无须对它们进行区分，可以一致地对待容器和叶子**

组合模式的关键是定义了一个抽象构件类，它**既可以代表叶子，又可以代表容器**，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理.

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_20.png?raw=true)

抽象类 `Component` 定义了一系列方法，`operation()` 方法用来做实际业务处理，`add()` 和 `remove()` 用来添加和删除对象，这个对象可以是叶子也可以是容器，`getChild()` 用来返回叶子或者容器。在**容器**的 `opeartion()` 方法中，会调用其所有子对象的 `operation()` 方法。

#### 例子

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_21.png?raw=true)

抽象类 `AbstractFile` 定义了多个方法，其中 `killVirus()` 就是上面的 `operation()` 方法。`ImageFile`,`VideoFile`,`TextFile` 就是叶子对象。`Folder` 就是容器对象，容器对象里可能还有很多图像视图文本文件。

> 组合模式叶子和容器的关系；建造者模式是一个维度和另一个维度的关系。组合模式中叶子和容器其实是一类的，他们都继承于同一个抽象类；建造者模式中两个维度是不同的，继承于不同的抽象类或者接口。
>
> 组合模式不是我们通常讲的组合。通常将的组合是指把一个对象放在另一个对象中作为其属性。而组合模式则是指把一堆类似的叶子对象放在一起作为一个容器。



### 装饰模式

难度：3	频率：3

> **装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。**

如果我们不适用装饰模式，那么对一个功能添加新的功能就要继承成为一个新类：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_23.png?raw=true)

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_22.png?raw=true)

如图所示，`component` 是一个抽象类，也可以是一个接口，定义了一个 `operation()` 方法。`concreteComponent` 是这个抽象类或接口的实现，也是被装饰对象。现在 `Decorator` 是一个抽象类，其中含有一个 `concreteComponent` 的具体实例 `component`，在其 `operation()` 方法中，每次都会调用这个 `component` 的方法。会有许多具体的实现类 `ConcreteDecorateX` 实现 `Decorator`，它们会在自身 `operation()` 方法中调用父类的方法，并且加上自己的实现。

调用的话，需要先创建一个 `ConcreteComponent`，然后把它设置给装饰者的 `Component`，然后调用装饰者中的处理方法。如果有多个装饰者，可以将某个装饰者作为另一个装饰者的 `Component` 设置进去。

**缺点**：会产生多个小对象。更容易出错，且排错困难。

#### 例子

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_24.png?raw=true)

上面的那个例子的正确打开方式是，在装饰类 `ComponentDecorator` 的子类中实现方法 `display()` 的拓展。调用方式如下：

```java
Component  component,componentSB,componentBB; //全部使用抽象构件定义
component = new Window();
componentSB = new  ScrollBarDecorator(component);
componentBB = new  BlackBorderDecorator(componentSB); //将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰
componentBB.display();
```

#### 装饰模式和适配器模式 区别

装设模式的装饰者(Decorator)和被装饰的目标对象都是继承于原对象，实现了同样的方法。**装饰模式是对原功能的拓展**。

适配器模式一般只有适配器(Adapter)继承于原对象，被适配的目标对象通常以组合的方式作为适配器的一个属性。对于类适配器，适配器还继承于被适配对象，被适配的接口直接就在适配器对象中实现。**适配器模式是一种接口的转换**。



### 外观模式

难度：1	频率：5

> **外观模式(Facade)：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**

外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。

外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不能表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_25.png?raw=true)

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_26.png?raw=true)

`Client` 不和 `SubSystem` 直接接触，而是通过一个中间层 `Facade` 交互。

在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入**抽象外观类**来对系统进行改进，在一定程度上可以解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。

#### 例子

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_27.png?raw=true)

上面的例子中提供了两个子系统类，它们的 `cipher` 是不同的。但是它们都实现了 `AbstractEncryptFacade` 的 `FileEncrypt()` 方法，可以通过反射的方式决定最终使用哪个 Facade。`Client` 只要调用 `FileEncrypt()` 即可，不需要再和 `FileReader`,`FileWriter`,`CipherMachine` 耦合了。

> 外观模式的目的是减少耦合，让调用者不需要知道具体的实现方式

### 享元模式

难度：4	频率：1

> **享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。**

享元模式很像是由多个单例模式和工厂模式组成的。

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_28.png?raw=true)

首先是一个抽象享元类 `Flyweight`，定义了抽象方法 `operation()`，可以接收外部状态(后面解释)。可以创建多个具体享元类`ConcreteFlyweight`(不用关心 `UnsharedConcreteFlyweight`)，在创建的时候，设好其内部状态 `intrinsicState`。现在有一个享元类的工厂 `FlyweightFactory`，其内部有一个哈希表用来存储 `ConcreteFlyweight`，键是 `ConcreteFlyweigjt` 的内部状态 `intrinsicState`，值就是这个具体享元类 `ConcreteFlyweight`。工厂提供了一个方法使外部可以通过状态值，获取这个具体享元类。



#### 例子

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_29.png?raw=true)

这是一个关于围棋的例子。棋子抽象类 `IgoChessman` 有一个获取当前棋子颜色的方法 `getColor()`，并且还有一个展示方法 `display()`，展示方法需要传入外部参数棋子的坐标 `Coordinates`,`display()` 会根据内部参数棋子的颜色 `Color` 和外部参数坐标 `Coordinates` 进行展示。

棋子工厂 `IgoChessmanFactory` 通过 `getIgoChessman()` 方法获取棋子的实例，并将其以内部参数 `Color` 为键，保存在哈希表 `ht` 中。 

看一下具体的调用方法：

```java
        IgoChessman black1,black2,black3,white1,white2;  
        IgoChessmanFactory factory;  
          
        //获取享元工厂对象  
        factory = IgoChessmanFactory.getInstance();  
  
        //通过享元工厂获取三颗黑子  
        black1 = factory.getIgoChessman("b");  
        black2 = factory.getIgoChessman("b");  
        black3 = factory.getIgoChessman("b");  
        System.out.println("判断两颗黑子是否相同：" + (black1==black2));  
  
        //通过享元工厂获取两颗白子  
        white1 = factory.getIgoChessman("w");  
        white2 = factory.getIgoChessman("w");  
        System.out.println("判断两颗白子是否相同：" + (white1==white2));  
  
        //显示棋子，同时设置棋子的坐标位置  
        black1.display(new Coordinates(1,2));  
        black2.display(new Coordinates(3,4));  
        black3.display(new Coordinates(1,3));  
        white1.display(new Coordinates(2,5));  
        white2.display(new Coordinates(2,4));  
```

> 其实就是通过工厂模式获取多个单例对象，如果没有多个具体的享元类，那就直接用单例。



### 代理模式

难度：3	频率：4

> **代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。**

在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_30.png?raw=true)

 抽象主题角色 `Subject` 中有一个方法 `request()`，代理主题角色 `Proxy` 和真实主题角色 `RealSubject` 都实现了其方法。`Proxy` 会自己创建 `RealSubject` 的实例，其 `request()` 方法中，不仅调用 `RealSubject` 的相应方法，还在其前后各加上自己的方法 `PreRequest()` 以及 `PostRequest()`。可以通过反射动态替换代理主题类名。

#### 装饰器模式和代理模式的区别

装饰器模式和代理模式在结构上几乎一模一样，那么两者的区别是什么呢？

装饰器模式关注于在一个对象上动态的**添加方法**，然而代理模式关注于**控制对对象的访问**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，**当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例**。并且，**当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。**

因为这个区别，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。



## 十一个行为型模式

### 职责链模式

难度：3	频率：2

> **职责链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。**

我们经常会写出很长的 if…else 来分别处理不同的情况。例如

```java
if (request.getAmount() < 50000) {  
            //主任可审批该采购单  
            this.handleByDirector(request);  
        }  
        else if (request.getAmount() < 100000) {  
            //副董事长可审批该采购单  
            this.handleByVicePresident(request);  
        }  
        else if (request.getAmount() < 500000) {  
            //董事长可审批该采购单  
            this.handleByPresident(request);  
        }  
        else {  
            //董事会可审批该采购单  
            this.handleByCongress(request);  
        }  
```

这样各个方法都几种在一个类中，违反了单一职责原则。并且有 if…else 的地方基本都是违反开闭原则的。我们需要使用职责链模式修改。

#### 结构

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_32.png?raw=true)

定义了一个抽象处理者`handler` ，它有一个 `successor` 属性，用来标识谁是响应链的下一级。 `handler` 还定义了一个抽象处理方法 `handleRequest()`，每一个具体处理者 `concreteHandler` 继承该方法都会先判断自己能否处理，如果能就走自己的实现逻辑，如果不能就调用 `successor.handleRequest()` 。

职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 

#### 例子

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/pattern_33.png?raw=true)

上图中 `Approver` 是抽象处理者，`successor` 的类型是自己本身，用来标记处理链中的下一级处理者。`processRequest()` 方法用来处理具体的事件，接收一个 `PurchaseRequest` 对象，这是一个具体要处理的事件。然后就是各个具体处理者。他们会在初始化的时候设置好处理层级。

> 主要还是解决 if…else 产生的问题。之前也有几个设计模式是为了解决这一问题的
>
> 比如工厂方法模式，解决了判断不同 type 生成不同类的问题。比如建造者模式，解决了判断不同 type 生成不同属性的问题。**这两都是通过反射，动态生成了负责处理的类的实例。**从根本上消除了 if…else 的判断。
>
> 本例并没有消除 if…else，不过是把一个完整的 if…else，拆分成了多个小的判断，分别塞进各个 handler 类里去了。**适用于不能简单判等的情况，即不能将判断条件合并**。



### 命令模式

难度：3	频率：4





## 备注

**本文中的所有示意图：紫色的都表示接口类型，蓝色的都表示实体类（如果要在某个类内部保存属性，那么就不能将其设置为接口）**

**本文中的所有示意图：“+” 表示方法，"-" 表示对象**

感谢[史上最全设计模式导学目录](http://blog.csdn.net/lovelion/article/details/17517213)