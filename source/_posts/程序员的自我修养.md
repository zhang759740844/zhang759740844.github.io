title: 《程序员的自我修养》读书笔记
date: 2019/5/28 14:07:12  
categories: 计算机
tags: 

 - 读书笔记
	
---

最近又重读了《程序员的自我修养》一书。有了许多新的感受。书需要重复的读。最开始的一遍很多都看不懂，也觉得没必要知道。现在很多知识都已经有了印象，看书的过程更像是查漏补缺的过程。以下是这本书的部分笔记。

<!--more-->

## CP1 温故而知新

### 内存

#### 虚拟地址

物理地址对应于物理内存，是实际存在的。虚拟地址是不存在的地址空间，每个进程有自己独立的虚拟空间，然后通过某些映射方式，将虚拟地址转化为实际的物理地址。

虚拟地址主要为了解决使用物理地址时，地址空间不隔离，内存使用效率低，运行地址不确定等问题。对于程序来说，它永远从 0x00000000 开始的连续地址，不需要考虑重定位。

#### 分段

将一个完整的虚拟空间分为若干段，每段都与物理地址上的某个区域对应，叫做分段。虚拟地址中的每个字节都对应于物理空间中的每个字节。

分段的映射过程由操作系统完成，实际的地址转换由硬件完成。

分段解决了地址空间不隔离，运行地址不确定的问题。

#### 分页

分段没有解决内存使用效率低的问题。从磁盘到物理内存的数据置换如果以段为单位，仍将进行大量的置换。因此将段更细的拆分为页，一般为 4kb 大小。

**虚拟内存到物理内存的映射关系是以页为单位的**。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_1.png?raw=true)

可以看到不同进程的页可能映射到相同的物理内存中。这会造成两种情况：

1. 非活跃进程某页的物理地址上的数据会被置换为活跃进程的某页的数据。
2. 两个进程通过共享这一物理地址上的数据进行 IPC (应用进程间通信)


### 线程

#### 线程的访问权限

线程可以访问进程里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址)

#### Linux 多线程

Linux 中并不存在真正的线程。它的执行实体(无论线程还是进程)都被称为任务。每个任务相当于一个单线程的进程。

它有三种方式创建任务：

1. fork
2. exec
3. clone

其中，fork 产生新任务的速度最快。因为 fork 不会立即复制任务的内存，而是写时复制。

#### 线程安全

线程安全就不得不提锁。iOS 中最常见的有两种锁：

1. NSLock，@synchronize：本质上都是互斥锁
2. dispatch_semaphone_t：信号量

多元信号量与互斥锁的差别在于：**多元信号量可以实现在多个任务完成后的回调，互斥锁显然是无法完成的**。

那么二元信号量和互斥锁有什么区别呢？一般情况下我们认为二元信号量和互斥锁相同。其实他们的本质区别是：**同一个信号量可以被系统中的一个线程获取，由另一个线程释放。而互斥锁则要求哪个线程获取了互斥锁，哪个线程就要释放，其他线程无法越俎代庖的去释放**。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_2.png?raw=true)

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_3.png?raw=true)

由于在主线程中释放二元信号，可以看到第二个任务没有等第一个结束就开始执行了。而如果主线程没有释放信号量，那么第二个任务是要等第一个任务结束，释放信号量，才能执行的。这就是信号量和互斥锁的区别

#### 多线程内部

上面我们所说的多线程是指由操作系统调度的**内核线程**。而用户实际使用的线程并不是内核线程，而是出于用户态的**用户线程**。用户线程的数量不一定对应于内核线程的数量。一般有三种线程模型：

1. 一对一模型：即一个用户线程对应一个内核线程
2. 多对一模型：即多个用户线程对应一个内核线程
3. 多对多模型：即多个用户线程对应多个内核线程

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_4.png?raw=true)

对于一对一模型，用户的线程切换也就是内核线程的切换，存在线程**切换上下文**时的开销。对于多对一模型，用户的线程切换不是内核线程的切换，因此也就不存在切换上下文时的开销。但是对于多对一模型，如果一个用户线程阻塞了，那么内核线程阻塞，其他用户线程也就无法继续执行了。

**Linux 中的线程模型是一对一模型**

## CP2 编译和连接

### 基本流程

当我们 Build 一个项目的时候，一般分为四个步骤：**预处理**，**编译**，**汇编**，**链接**

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_5.png?raw=true)

预处理主要处理代码中以 `#` 开头的预编译指令。编译将文件转为汇编代码文件。汇编将汇编代码替换为对应的机器指令。链接将各个汇编后产生的文件链接。

### 静态链接                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

静态链接主要包含**地址空间分配**，**符号解析**，**重定位**等步骤。

链接不只是把代码堆叠到一起(代码堆叠可以理解为地址空间分配)。在编译的时候，会有一个**符号表**记录出现的所有类，全局变量，方法等符号。这些符号所指向的是当前文件的偏移位置，而在链接的时候将会被修改为链接后完整文件的偏移。编译的同时，有一些引用的类，方法等的地址是未知的，这些未知的地址就是一个个空洞。

符号表中的符号以及这些位置的空洞都是需要在链接的时候进行地址偏移修正的。因此，编译的时候还会生成一个**重定位表**需要地址修正的各个符号以及需要链接的空洞。

符号解析就是将每个**符号引用**和其对应的**符号定义**联系起来。也就是修正符号表中符号所指向的全局变量、方法的地址。

重定位就是链接器把每个**符号定义**与一个**虚拟地址**联系起来。也就是将代码段中原本未链接的符号的地址修改为链接后修正偏移后的符号的地址。

> 其实可以更朴素的理解：
>
>   链接之后有两部分地址发生变化，一部分是符号指向的全局变量、方法的地址的偏移，还有一部分是各个文件的符号表中符号本身的地址发生偏移。
>
> 因此就要有两步操作，第一步纠正全局符号表中符号指向的全局变量或方法的位置，第二步纠正代码中使用的未链接时相对于本文件的符号的地址，将其改为全局符号表中修正过的符号的地址。

## CP3 目标文件

### 可执行文件中的段

目标文件即在汇编之后，在链接之前的文件。除了包含编译后的机器指令、数据外，还包含符号表，调试信息等。目标文件将不同属性保存在不同的**段（Section）**中。

> 除了 **Section**，我们再看 Mach-o 文件的时候，经常会碰到 **Segment**。这两者都可以成为段(虽然 Segment 的意思才是段，Section 的意思是节)。
>
> Section 和 Segment 的区别在于：目标文件是以 Section 为单位分段的，但是加载到内存中是以 Segment 为单位加载。
>
> 我们所说的 .text, .data, .bss 指的都是 Section。而代码段，数据段指的都是 Segment。

可执行文件的文件头包含了文件属性，还包含一个**段表（Section Table）**，段表是一个用来描述文件中各个段的数组，包含了文件中各个段的偏移位置及属性。

一个可执行文件一般包含以下的段：

1. **.text段**：即**代码段**，保存了编译后的执行语句。
2. **.data段**：和 .bss 段统称**数据段**，保存了**已初始化**的全局变量和局部静态变量的**值**。
3. **.bss 段**：存放**未初始化**的全局变量和局部静态变量。由于是未初始化的变量，所以**可执行文件中不会分配空间给 bss 段，只会在段头中记录 bss 段的大小。bss 段空间由系统初始化。**bss 段 的目的就是减少程序大小。

除了上面所述的三个段，还有很多常见的段如下图：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_6.png?raw=true)

### 自定义段

处了上述的段，我们还可以自定义段：`__attribute__((section("name")))`。如：

```c
__attribut__((section("FOO"))) int global = 42;
```

就是创建了一个叫 FOO 的段，并且把全局变量 global 放了进去。使用的时候再通过相应的 c 方法获取即可。

阿里的模块化框架 BeeHive 就是通过这种方式全局注册模块信息。这样的好处是不需要维护一个数组取保存，使用的时候直接把自定义段中的所有变量拿到即可。自定义段本身就相当于是一个数组。(当然，其实就把模块信息保存在 .data 段中的一个数组中其实也没什么问题)

### ELF 文件结构

ELF 文件结构如下：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_7.png?raw=true)

#### ELF 文件头

ELF 文件头主要包含可执行文件的基本信息。包含 ELF 魔数，版本，运行平台，ABI 版本，程序头入口和长度，段表的位置和长度，段的数量等。

关于什么是 **ABI**。ABI 涵盖了各种细节：如数据类型、大小和对齐；调用约定（控制着函数的参数如何传送以及如何接受返回值）；系统调用的编码和一个应用如何向操作系统进行系统调用。

关于什么是**魔数**。魔数用来确定文件的类型，操作系统在加载可执行文件的时候会确定是否正确。

#### 段表

段表是一个数组，描述了段的**段名**，段的**长度**，文件中的**偏移**，读写权限等属性。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_9.png?raw=true)

#### 重定位表

每个文件的重定位表都记录了该文件中在链接时需要重定位的符号以及引用的外部符号的信息，以及它们在当前文件的偏移位置。

#### 字符串表

可执行文件中的很多字符串，如**段名**，**变量名**保存在这里。使用字符串在表中的偏移来引用字符串。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_8.png?raw=true)

如图所示，就是字符串表的保存方式，每个字符串以 `\0` 结尾，这样就只需要给出一个数字下标就可以表示一个字符串了。

### 符号

#### 什么是符号表

链接就是把变量或函数的地址填到编译后空洞的过程。链接中的变量和函数统称为**符号**

每一个目标文件都有一个相应的**符号表（Symbol Tabel）**，记录了用到的所有的符号，每个符号有一个对应的值，叫做**符号值**，对于变量和函数来说，**符号值就是它们的地址**。

> 代码中的变量方法最终编译后都替换为了符号表中的偏移，然后在找到对应的符号后，到相应的位置取出对象（可以是 .data 段，字符串表，堆栈等）。

#### 符号表结构

符号表结构如下：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_10.png?raw=true)

其中 `st_info` 用来标识符号是局部符号，全局符号，还是弱符号；以及符号的类型，是变量还是数组，还是函数。

一般通过 `st_shndx` 和 `st_value` 定位符号的所表示的位置。然后通过 `st_size` 拿出相应大小的值。

#### 强符号和弱符号

编译期认为函数和初始化了的全局变量为强符号，没有初始化的全局变量为弱符号。也可以通过 `__attribute__((weak))` 声明弱符号：

```c
extern int ext;

int weak;
int strong = 1;
__attribute ((weak)) weak2 = 2;
```

上面 `weak` 和 `weak2` 为弱符号，`strong` 为强符号。`ext` 即非强符号也非弱符号，它是一个外部变量的引用。

编译期针对强符号和弱符号制定了一些规则：

1. 强符号不可以定义多次。否则报错
2. 如果一个符号在某个目标文件是强符号，其他文件是弱符号，那么它的类型以强符号为准。
3. 如果一个符号在所有文件中都是弱符号，那么选择占用控件最大的一个符号的类型。

由上可见，符号是不带类型的。

## CP4 静态链接

### 链接过程

对于多个输入目标文件，链接器如何将它们合并到一个输出文件的？一般讲一个个文件的**相似度段合并**：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_11.png?raw=true)

一般会经历两步：

1. 空间和地址分配
2. 符号解析和重定位

#### 空间和地址分配

首先扫描所有的目标文件，获得所有各个段的长度属性和位置，然后将目标文件的所有符号定义和符号引用收集起来，放到一个**全局符号表**中。这一步中，链接器能获取所有段的长度，并将它们合并，计算出合并后的各个段的长度和位置，并建立映射关系。

> 这其实就是纠正符号指向的变量、方法的位置偏移

#### 符号解析和重定位

ELF 文件中有一个**重定位表**专门用来保存于重定位相关的信息。重定位表是一个数组，数组的元素非常简单：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_12.png?raw=true)

`r_offset` 表示符号在当前文件的偏移量，`r_info` 表示这个符号的信息。

在重定位的时候，会根据 `r_info` 的信息，在全局符号表中查找相应的符号。然后把符号的地址写到 `r_offset` 所指向的其在当前文件的位置偏移。

> 这其实就是将单个文件中原本相对于本文件的偏移，转化为相对于链接后所有文件的位置的偏移。

### ABI

我们把符号修饰标准，变量内存布局，函数调用方式等跟可执行代码二进制兼容性相关的内容称为 ABI。

ABI 不稳定就是说变量的内存布局，函数调用方式等可能会变，也就是编译规则可能会变。

ABI 稳定就是在不同编译器下，编译出来的可执行文件能够被正确的链接到一起。

影响 ABI 的因素很多，比如：

- 内置类型（如 int float 等）的大小和在存储器中的放置方式(大端，小端，对其方式)
- 组合类型(如 struct， union，数组等)的存储方式和内存布局
- 外部符号与用户定义的符号之间的命名方式和解析方式，如函数名 func 在 C 语言的目标文件中是否被解析成外部符号 _func
- 函数调用方式，如参数入栈熟悉怒，返回值如何保持
- 堆栈分布方式，如参数和局部变量在堆栈中的位置，参数传递方式
- 寄存器使用约定，函数调用时哪些寄存器可以修改哪些需要保存

> 由此可见 ABI 主要影响着编译和汇编的过程：
>
> 编译主要影响函数调用相关的汇编代码的生成
>
> 链接主要影响生成的可执行文件的内存分布

## CP6 可执行文件的装载与进程

### 进程虚拟地址空间

程序被运行起来后，将拥有独立的**虚拟地址空间(Virtual Address)**。这个虚拟地址空间大小由计算机的硬件平台决定，具体地说是由 CPU 位数决定的。硬件决定了地址空间的最大理论上限，即硬件寻址空间的大小。一个32位处理器的最大寻址空间是 4GB。

对于一个 32 位的处理器，他的最大寻址空间是 4GB。一般在 Linux 系统中将会有 1 GB被划分给操作系统。我们的进程最多使用 3GB 的虚拟空间。也就是说，整个进程在执行的时候，所有的代码，数据包包括 C 语言 malloc() 等方法申请的虚拟空间之和不可以超过 3GB。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_13.png?raw=true)

### 装载方式

很多时候，我们的程序实际需要的内存要大于物理能够同时装载的内存。在这种情况下，需要有一种动态装载的方式可以将最常用的部分驻留内存，而将不常用的数据存放在磁盘中。

**页映射**是现在最常用的动态装载方法。思想史程序用到哪个模块，九江哪个模块装入内存，如果不用就暂不装入，存放在磁盘中。

#### 页映射

将内存和磁盘中的所有数据和指令按照**页(page)**为单位划分成若干个页，以后所有的装载和操作单位都是页。一般以 4kb 作为一个页。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_14.png?raw=true)

### 操作系统角度看可执行文件的装载

创建一个进程，操作系统主要需要做以下三件事情：

1. 创建独立的虚拟地址空间。创建一个页目录，用于确定物理内存和虚拟空间的映射关系。
2. 读取可执行文件头，建立虚拟空间和和执行文件的映射关系。
3. 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行

当 CPU 将要执行某个地址的指令，并且该地址是一个空页的时候（即页所指向的物理地址上存放的不是虚拟空间想要的数据和指令），就被认为是一个**页错误（Page Fault）**。CPU 将控制权交给操作系统。操作系统会在物理内存中分配一个物理页面，或者收回一个已使用的物理页，将虚拟页所需的数据和指令加载进来，然后将进程中的虚拟页和分配的物理页建立映射关系，最后把控制权交还给进程，进程从刚才页错误的位置重新执行。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_15.png?raw=true)

### 进程虚拟控件分布

#### section 和 segment

前文说过，可执行文件的区域是以 **section** 为单位区分的，装载进内存中是以 **segment** 为单位区分的。segment 中包含了多个权限相同的 section。

这是因为 ELF 文件被映射时，是以系统的页长度为单位的，每个段在映射时的长度应该是系统页长度的整数倍。如果不是，那么多余部分也要占用一个页。一个 ELF 文件中往往有十几个段，会造成内存空间的浪费。因此把相同权限的 section 合并到一起当做一个 segment 进行映射。

如图所示，在虚拟内存中占用三个页的 .text段和 .init段，会被合并为一个 segment 载入。在物理内存中就只占两个页：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_16.png?raw=true)

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_17.png?raw=true)

#### 堆和栈

当我们以 Segment 划分的时候，进程可以划分为以下几个区域：

- 代码段
- 数据段
- 堆段
- 栈段

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_18.png?raw=true)

## 动态链接

### 动态链接的目的

静态链接浪费内存和磁盘，动态链接在磁盘和内存中只会保存一份，因此节约了内存。动态链接把链接的过程推迟到了运行时再进行。

### 地址无关代码















