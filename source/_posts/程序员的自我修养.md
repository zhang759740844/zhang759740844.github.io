title: 《程序员的自我修养》读书笔记
date: 2019/5/28 14:07:12  
categories: 计算机
tags: 

 - 读书笔记
	
---

最近又重读了《程序员的自我修养》一书。有了许多新的感受。书需要重复的读。最开始的一遍很多都看不懂，也觉得没必要知道。现在很多知识都已经有了印象，看书的过程更像是查漏补缺的过程。以下是这本书的部分笔记。

<!--more-->



### 线程

#### 线程的访问权限

线程可以访问进程里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址)

#### Linux 多线程

Linux 中并不存在真正的线程。它的执行实体(无论线程还是进程)都被称为任务。每个任务相当于一个单线程的进程。

它有三种方式创建任务：

1. fork
2. exec
3. clone

其中，fork 产生新任务的速度最快。因为 fork 不会立即复制任务的内存，而是写时复制。

#### 线程安全

线程安全就不得不提锁。iOS 中最常见的有两种锁：

1. NSLock，@synchronize：本质上都是互斥锁
2. dispatch_semaphone_t：信号量

多元信号量与互斥锁的差别在于：**多元信号量可以实现在多个任务完成后的回调，互斥锁显然是无法完成的**。

那么二元信号量和互斥锁有什么区别呢？一般情况下我们认为二元信号量和互斥锁相同。其实他们的本质区别是：**同一个信号量可以被系统中的一个线程获取，由另一个线程释放。而互斥锁则要求哪个线程获取了互斥锁，哪个线程就要释放，其他线程无法越俎代庖的去释放**。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_2.png?raw=true)

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_3.png?raw=true)

由于在主线程中释放二元信号，可以看到第二个任务没有等第一个结束就开始执行了。而如果主线程没有释放信号量，那么第二个任务是要等第一个任务结束，释放信号量，才能执行的。这就是信号量和互斥锁的区别