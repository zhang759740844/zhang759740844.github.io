title: 《程序员的自我修养》读书笔记
date: 2019/5/28 14:07:12  
categories: 计算机
tags: 

 - 读书笔记
	
---

最近又重读了《程序员的自我修养》一书。有了许多新的感受。书需要重复的读。最开始的一遍很多都看不懂，也觉得没必要知道。现在很多知识都已经有了印象，看书的过程更像是查漏补缺的过程。以下是这本书的部分笔记。

<!--more-->



### 线程

#### 线程的访问权限

线程可以访问进程里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址)

#### Linux 多线程

Linux 中并不存在真正的线程。它的执行实体(无论线程还是进程)都被称为任务。每个任务相当于一个单线程的进程。

它有三种方式创建任务：

1. fork
2. exec
3. clone

其中，fork 产生新任务的速度最快。因为 fork 不会立即复制任务的内存，而是写时复制。

#### 线程安全

线程安全就不得不提锁。iOS 中最常见的有两种锁：

1. NSLock，@synchronize：本质上都是互斥锁
2. dispatch_semaphone_t：信号量

多元信号量与互斥锁的差别在于：**多元信号量可以实现在多个任务完成后的回调，互斥锁显然是无法完成的**。

那么二元信号量和互斥锁有什么区别呢？一般情况下我们认为二元信号量和互斥锁相同。其实他们的本质区别是：**同一个信号量可以被系统中的一个线程获取，由另一个线程释放。而互斥锁则要求哪个线程获取了互斥锁，哪个线程就要释放，其他线程无法越俎代庖的去释放**。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_2.png?raw=true)

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_3.png?raw=true)

由于在主线程中释放二元信号，可以看到第二个任务没有等第一个结束就开始执行了。而如果主线程没有释放信号量，那么第二个任务是要等第一个任务结束，释放信号量，才能执行的。这就是信号量和互斥锁的区别

#### 多线程内部

上面我们所说的多线程是指由操作系统调度的**内核线程**。而用户实际使用的线程并不是内核线程，而是出于用户态的**用户线程**。用户线程的数量不一定对应于内核线程的数量。一般有三种线程模型：

1. 一对一模型：即一个用户线程对应一个内核线程
2. 多对一模型：即多个用户线程对应一个内核线程
3. 多对多模型：即多个用户线程对应多个内核线程

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_4.png?raw=true)

对于一对一模型，用户的线程切换也就是内核线程的切换，存在线程**切换上下文**时的开销。对于多对一模型，用户的线程切换不是内核线程的切换，因此也就不存在切换上下文时的开销。但是对于多对一模型，如果一个用户线程阻塞了，那么内核线程阻塞，其他用户线程也就无法继续执行了。

**Linux 中的线程模型是一对一模型**

## CP2 编译和连接

### 基本流程

当我们 Build 一个项目的时候，一般分为四个步骤：**预处理**，**编译**，**汇编**，**链接**

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_5.png?raw=true)

预处理主要处理代码中以 `#` 开头的预编译指令。编译将文件转为汇编代码文件。汇编将汇编代码替换为对应的机器指令。链接将各个汇编后产生的文件链接。

### 静态链接

静态链接主要包含**地址空间分配**，**符号绑定**，**重定位**等步骤。

链接不只是把代码堆叠到一起(代码堆叠可以理解为地址空间分配)。在编译的时候，引用的类，方法等地址是未知的。这些位置的地址就是一个个空洞。编译的同时，会有一个符号表记录出现的所有类，变量，方法。链接的时候就会把符号表中的这些元素的地址记录下来(也就是符号绑定)，然后把这些地址填到之前的各个空洞中(也就是重定位)。

## CP3 目标文件

### 可执行文件中的段

目标文件即在汇编之后，在链接之前的文件。除了包含编译后的机器指令、数据外，还包含符号表，调试信息等。目标文件将不同属性保存在不同的**段（Segment）**中，段又可以细分为**节（section）**。

可执行文件的文件头包含了文件属性，还包含一个**段表（Section Table）**，段表是一个用来描述文件中各个段的数组，包含了文件中各个段的偏移位置及属性。

一个可执行文件一般包含以下的段：

1. **代码段**：即 text 段，保存了编译后的执行语句。
2. **数据段**：即 data 段，保存了**已初始化**的全局变量和局部静态变量的**值**。
3. **bss 段**：存放**未初始化**的全局变量和局部静态变量。由于是未初始化的变量，所以**可执行文件中不会分配空间给 bss 段，只会在段头中记录 bss 段的大小。bss 段空间由系统初始化。**bss 段 的目的就是减少程序大小。

除了上面所述的三个段，还有很多常见的段如下图：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_6.png?raw=true)

它们的地址分布类似于下图。当然不同的架构段的位置可能不同：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_7.png?raw=true)







