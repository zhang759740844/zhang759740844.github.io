title: 《程序员的自我修养》读书笔记
date: 2019/5/28 14:07:12  
categories: 计算机
tags: 

 - 读书笔记
	
---

最近又重读了《程序员的自我修养》一书。有了许多新的感受。书需要重复的读。最开始的一遍很多都看不懂，也觉得没必要知道。现在很多知识都已经有了印象，看书的过程更像是查漏补缺的过程。以下是这本书的部分笔记。

<!--more-->

## CP1 温故而知新

### 内存

#### 虚拟地址

物理地址对应于物理内存，是实际存在的。虚拟地址是不存在的地址空间，每个进程有自己独立的虚拟空间，然后通过某些映射方式，将虚拟地址转化为实际的物理地址。

虚拟地址主要为了解决使用物理地址时，地址空间不隔离，内存使用效率低，运行地址不确定等问题。对于程序来说，它永远从 0x00000000 开始的连续地址，不需要考虑重定位。

#### 分段

将一个完整的虚拟空间分为若干段，每段都与物理地址上的某个区域对应，叫做分段。虚拟地址中的每个字节都对应于物理空间中的每个字节。

分段的映射过程由操作系统完成，实际的地址转换由硬件完成。

分段解决了地址空间不隔离，运行地址不确定的问题。

#### 分页

分段没有解决内存使用效率低的问题。从磁盘到物理内存的数据置换如果以段为单位，仍将进行大量的置换。因此将段更细的拆分为页，一般为 4kb 大小。

**虚拟内存到物理内存的映射关系是以页为单位的**。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_1.png?raw=true)

可以看到不同进程的页可能映射到相同的物理内存中。这会造成两种情况：

1. 非活跃进程某页的物理地址上的数据会被置换为活跃进程的某页的数据。
2. 两个进程通过共享这一物理地址上的数据进行 IPC (应用进程间通信)


### 线程

#### 线程的访问权限

线程可以访问进程里的所有数据，甚至包括其他线程的堆栈(如果它知道其他线程的堆栈地址)

#### Linux 多线程

Linux 中并不存在真正的线程。它的执行实体(无论线程还是进程)都被称为任务。每个任务相当于一个单线程的进程。

它有三种方式创建任务：

1. fork
2. exec
3. clone

其中，fork 产生新任务的速度最快。因为 fork 不会立即复制任务的内存，而是写时复制。

#### 线程安全

线程安全就不得不提锁。iOS 中最常见的有两种锁：

1. NSLock，@synchronize：本质上都是互斥锁
2. dispatch_semaphone_t：信号量

多元信号量与互斥锁的差别在于：**多元信号量可以实现在多个任务完成后的回调，互斥锁显然是无法完成的**。

那么二元信号量和互斥锁有什么区别呢？一般情况下我们认为二元信号量和互斥锁相同。其实他们的本质区别是：**同一个信号量可以被系统中的一个线程获取，由另一个线程释放。而互斥锁则要求哪个线程获取了互斥锁，哪个线程就要释放，其他线程无法越俎代庖的去释放**。如图所示：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_2.png?raw=true)

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_3.png?raw=true)

由于在主线程中释放二元信号，可以看到第二个任务没有等第一个结束就开始执行了。而如果主线程没有释放信号量，那么第二个任务是要等第一个任务结束，释放信号量，才能执行的。这就是信号量和互斥锁的区别

#### 多线程内部

上面我们所说的多线程是指由操作系统调度的**内核线程**。而用户实际使用的线程并不是内核线程，而是出于用户态的**用户线程**。用户线程的数量不一定对应于内核线程的数量。一般有三种线程模型：

1. 一对一模型：即一个用户线程对应一个内核线程
2. 多对一模型：即多个用户线程对应一个内核线程
3. 多对多模型：即多个用户线程对应多个内核线程

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_4.png?raw=true)

对于一对一模型，用户的线程切换也就是内核线程的切换，存在线程**切换上下文**时的开销。对于多对一模型，用户的线程切换不是内核线程的切换，因此也就不存在切换上下文时的开销。但是对于多对一模型，如果一个用户线程阻塞了，那么内核线程阻塞，其他用户线程也就无法继续执行了。

**Linux 中的线程模型是一对一模型**

## CP2 编译和连接

### 基本流程

当我们 Build 一个项目的时候，一般分为四个步骤：**预处理**，**编译**，**汇编**，**链接**

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_5.png?raw=true)

预处理主要处理代码中以 `#` 开头的预编译指令。编译将文件转为汇编代码文件。汇编将汇编代码替换为对应的机器指令。链接将各个汇编后产生的文件链接。

### 静态链接

// TODO:

静态链接主要包含**地址空间分配**，**符号绑定**，**重定位**等步骤。

链接不只是把代码堆叠到一起(代码堆叠可以理解为地址空间分配)。在编译的时候，引用的类，方法等地址是未知的。这些位置的地址就是一个个空洞。编译的同时，会有一个**符号表**记录出现的所有类，变量，方法。并且有一个**重定位表**记录这些符号所指向的位置

符号解析就是将每个**符号引用**和其对应的**符号定义**联系起来。

重定位就是链接器把每个**符号定义**与一个**虚拟地址**联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储位置，从而重定位这些节。

## CP3 目标文件

### 可执行文件中的段

目标文件即在汇编之后，在链接之前的文件。除了包含编译后的机器指令、数据外，还包含符号表，调试信息等。目标文件将不同属性保存在不同的**段（Section）**中。

> 除了 **Section**，我们再看 Mach-o 文件的时候，经常会碰到 **Segment**。这两者都可以成为段(虽然 Segment 的意思才是段，Section 的意思是节)。
>
> Section 和 Segment 的区别在于：目标文件是以 Section 为单位分段的，但是加载到内存中是以 Segment 为单位加载。
>
> 我们所说的 .text, .data, .bss 指的都是 Section。而代码段，数据段指的都是 Segment。

可执行文件的文件头包含了文件属性，还包含一个**段表（Section Table）**，段表是一个用来描述文件中各个段的数组，包含了文件中各个段的偏移位置及属性。

一个可执行文件一般包含以下的段：

1. **.text段**：即**代码段**，保存了编译后的执行语句。
2. **.data段**：和 .bss 段统称**数据段**，保存了**已初始化**的全局变量和局部静态变量的**值**。
3. **.bss 段**：存放**未初始化**的全局变量和局部静态变量。由于是未初始化的变量，所以**可执行文件中不会分配空间给 bss 段，只会在段头中记录 bss 段的大小。bss 段空间由系统初始化。**bss 段 的目的就是减少程序大小。

除了上面所述的三个段，还有很多常见的段如下图：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_6.png?raw=true)

### 自定义段

处了上述的段，我们还可以自定义段：`__attribute__((section("name")))`。如：

```c
__attribut__((section("FOO"))) int global = 42;
```

就是创建了一个叫 FOO 的段，并且把全局变量 global 放了进去。使用的时候再通过相应的 c 方法获取即可。

阿里的模块化框架 BeeHive 就是通过这种方式全局注册模块信息。这样的好处是不需要维护一个数组取保存，使用的时候直接把自定义段中的所有变量拿到即可。自定义段本身就相当于是一个数组。(当然，其实就把模块信息保存在 .data 段中的一个数组中其实也没什么问题)

### ELF 文件结构

ELF 文件结构如下：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_7.png?raw=true)

#### ELF 文件头

ELF 文件头主要包含可执行文件的基本信息。包含 ELF 魔数，版本，运行平台，ABI 版本，程序头入口和长度，段表的位置和长度，段的数量等。

关于什么是 **ABI**。ABI 涵盖了各种细节：如数据类型、大小和对齐；调用约定（控制着函数的参数如何传送以及如何接受返回值）；系统调用的编码和一个应用如何向操作系统进行系统调用。

关于什么是**魔数**。魔数用来确定文件的类型，操作系统在加载可执行文件的时候会确定是否正确。

#### 段表

段表是一个数组，描述了段的**段名**，段的**长度**，文件中的**偏移**，读写权限等属性。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_9.png?raw=true)

#### 重定位表

// TODO:

#### 字符串表

可执行文件中的很多字符串，如**段名**，**变量名**保存在这里。使用字符串在表中的偏移来引用字符串。

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_8.png?raw=true)

如图所示，就是字符串表的保存方式，每个字符串以 `\0` 结尾，这样就只需要给出一个数字下标就可以表示一个字符串了。

### 符号

链接就是把变量或函数的地址填到编译后空洞的过程。链接中的变量和函数统称为**符号**

每一个目标文件都有一个相应的**符号表（Symbol Tabel）**，记录了用到的所有的符号，每个符号有一个对应的值，叫做**符号值**，对于变量和函数来说，**符号值就是它们的地址**。

> 代码中的变量方法最终编译后都替换为了符号表中的偏移，然后在找到对应的符号后，到相应的位置取出对象（可以是 .data 段，字符串表，堆栈等）。

#### 符号表结构

符号表结构如下：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/cxy_10.png?raw=true)

其中 `st_info` 用来标识符号是局部符号，全局符号，还是弱引用符号；以及符号的类型，是变量还是数组，还是函数。

一般通过 `st_shndx` 和 `st_value` 定位符号的所表示的位置。然后通过 `st_size` 拿出相应大小的值。

