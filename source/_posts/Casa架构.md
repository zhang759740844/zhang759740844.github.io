title: 读 Casa 应用架构的一些笔记
date: 2017/5/13 10:07:12  
categories: iOS
tags:
	- 架构
---

读了 Casa 的一系列架构的文章 [Archives for Casa Taloyum](https://casatwy.com/archives.html)，自己再总结消化一下。

<!--more-->

## View 层组织和调用方案

### 代码结构的规定

代码需要遵循一定的规范：

![](https://github.com/zhang759740844/MyImgs/blob/master/MyBlog/casa_1.png?raw=true)

> delegate 要写上对应的 protocol 名字，delegate 方法要写在一块区域

老老实实的写成 `#pragma mark - xxxxDelegate`。

> event response 写在一个区域

所有的 button，gestureRecognizer 的响应事件写在一个区域里面。

> 减少 private methods

所有方法，如果是那种小功能如日期转换，图片裁剪，最好把它写成一个 category，有利于复用。



### 胖瘦 model

瘦 model 专门表达数据，存储、处理都交由外部处理。瘦 model 的目的是，尽可能编写细粒度 model，然后配套各种 helper 对弱业务做抽象，强业务依旧交给 Controller。

胖 model 包含了部分弱业务逻辑。胖 model 的目的是，Controller 从胖 model 拿到数据后，不用额外操作或者很少的操作，就能够将数据直接应用在 View 上。胖 model 相对难以移植一些。

我倾向于瘦 model + helper 的形式，这样更加抽象一些。



### 跨业务页面调用

跨业务指的是 App 中存在 A 业务和 B 业务，B 业务有可能要展示 A 业务的某个页面，A 业务也可能要展示 B 业务的某个页面。如果直接 import 会出现以下问题：

1. 如果要新开一个业务 C，且 C 依赖于业务 B，那么就需要连 A 也塞入开发环境中。
2. 如果业务中的某个页面修改了，比如改名，那么除了该业务中的其他页面的逻辑要修改，其他业务与其相关的逻辑也要修改。

因此，我们需要使用一个 Mediator 将业务解耦。具体如何实现的，参考后面的组件化。



### Q&A

#### 关于 BaseViewController 和 AOP

我觉得用 aop 代替继承还是要看使用范围。如果像埋点这样的所有情况都要走埋点接口的就适合 aop，而 ViewController 这种自己的要还是要写个 base 重写 `viewDidLoad` 的。比如设置背景色，如果用 aop，那么系统的各种弹窗也会同样设置了背景色。这就需要判断是不是系统的，就还要在所有的基础上做减法，就感觉很蠢。

当然，base 绝对不能乱用，我觉得设置设置背景色，代理类应该是没有问题的。base 还有一个好处是能设置一个代码规范，告诉业务开发者，哪些东西要写在哪个方法里。

####  关于 cell 处理事件

场景：点击一个 cell 要跳转另一个 VC，那么是直接在 cell 里跳转，还是先通知所在 VC，让 VC 跳转？

应该设置一个 delegate 为当前 VC，然后通知 delegate 跳转。cell 这种层次的 View 不应该参合在页面调度这种 VC 才应该做的事情上。



## 网络层设计方案

### 网络层安全

#### 防爬

本地保存一个密钥，然后每次请求的时候将请求的 API 名，API 参数，以及这个密钥结合算出一个 hash。服务器拿到后，用同样的密钥同样的算法也算出一个 hash 进行比对。密钥一般直接写死在代码中。

hash 的方式比加密的方式的优点在于快。hash 的作用在于验证数据的完整性，但是前提在于 hash 值不能被篡改的情况下，比如非对称加密中用私钥加密 hash 值。如果只对 API 名和 API 参数取 hash 值，别人知道取 hash 的所有值，当然可以随意替换 hash。但是如果我们添加了一个别人不知道的参数（也就是这里的密钥），那么别人就无法针对 API 名和参数，仿造出正确的 hash 了。



### 网络层优化

网络层优化主要有三个方面：

1. 链接建立环节的优化
2. 链接传输数据量的优化
3. 链接复用的优化

#### 链接建立环节的优化

**使用缓存**。一般将 API 名字和参数拼成一个字符然后取 MD5 作为 key，存储对应返回的数据。下次有同样请求的时候就可以直接读取。可以用 NSCache，也可以将其保存在本地。

**减少请求发起次数**。减少重复请求，比如不断的下拉刷新，就要取消后面的请求。再比如条件筛选，就要取消之前的筛选请求。能不发的就不发，能合并的就合并。

**直接使用 IP**。DNS 请求需要花一定的事件，如果直接走 IP，那么就绕过 DNS 的耗时了。另外，要尽量让用户使用快速的 IP。可以本地存一份 IP 列表，保存 API 的服务器。在启动的时候，针对所有 IP ping 延时时间。选取延时时间最小的 IP，然后通过 NSURLProtocol 的手段将 URL 中的 HOST 修改为我们找到的最快的 IP。

#### 链接传输数据量的优化

也就是压缩。

#### 链接复用的优化

HTTP 每次建立连接都要进行三次握手，可以将链接进行复用，比如使用 HTTP/2.0











