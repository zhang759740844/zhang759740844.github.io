title: 自定义 ViewController 的过场动画
date: 2017/6/13 10:07:12  
categories: iOS
tags:
	- Animation
---

pop、push 和 present 的动画效果都是系统的。我们可以自定义一些有意思的过场动画效果

<!--more-->

自定义过场动画涉及到几个 API：
- UIViewControllerAnimatedTransitioning 动画协议
- UIViewControllerInteractiveTransitioning 交互协议
- UIViewControllerContextTransitioning 上下文协议
- UIPercentDrivenInteractiveTransition 遵守协议的一个官方类



## 转场动画

### push 和 pop

首先，我们要创建一个遵循 `UIViewControllerAnimatedTransitioning` 动画协议的一个转场动画类：

```objc
@interface PushTransition : NSObject<UIViewControllerAnimatedTransitioning>
@end
```

这个类要实现协议其中的两个方法：

```objc
-(NSTimeInterval)transitionDuration:(id<UIViewControllerContextTransitioning>)transitionContext
{
    return 0.8f;
}

-(void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext
{
    UIViewController * fromVc = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    UIViewController * toVc = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    
    CGRect finalFrameForVc = [transitionContext finalFrameForViewController:toVc];
    CGRect bounds = [[UIScreen mainScreen] bounds];
    
    toVc.view.frame = CGRectOffset(finalFrameForVc, 0, bounds.size.height);
    
    [[transitionContext containerView] addSubview:toVc.view];
    
    
    [UIView animateWithDuration:[self transitionDuration:transitionContext]
                          delay:0.0
         usingSpringWithDamping:0.5
          initialSpringVelocity:0.0
                        options:UIViewAnimationOptionCurveLinear
                     animations:^{
                         fromVc.view.alpha = 0.8;
                         toVc.view.frame = finalFrameForVc;
                     }
                     completion:^(BOOL finished) {
                         [transitionContext completeTransition:YES];
                         fromVc.view.alpha = 1.0;
                     }];
}
```

第一个方法返回的是动画时间。

第二个方法是动画的具体执行，方法的参数 `transitionContext` 遵守了 `UIViewControllerContextTransitioning` 协议，所以它包含了许多关于专场所需要的内容，包括转入ViewController和转出Viewcontroller，还有动画容器 `containerView` 等，ViewController 一定要添加到 `containerView` 中。

在 `UIViewControllerContextTransitioning` 协议中，有多个属性和方法，最重要的几个方法如下：

```objc
– (UIView*)containerView;                                       //获取容器View

– (void)completeTransition:(BOOL)didComplete;                   //通过此参数获知动画是否结束

– (UIViewController*)viewControllerForKey:(NSString*)key;       //获取转入、转出VC

– (CGRect)initialFrameForViewController:(UIViewController*)vc   //获取动画前VC的frame

– (CGRect)finalFrameForViewController:(UIViewController*)vc;    //获取动画后VC的frame
```



`PopTransition` 的实现和 `PushTransition` 几乎一模一样，完全可以将两者放在一个类中，复用 push 的代码。稍有不同的是，如果 push 的页面是从上往下的，那么一般 pop 的页面则是从下往上的。所以两者不同的是，在 pop 中要将 `toView` 的 frame 修改成：

```objc
toVc.view.frame = CGRectOffset(finalFrameForVc, 0, -bounds.size.height);
```

我们可以通过添加一个 BOOL 变量来判断是 push 还是 pop。

### ViewController

创建好了动画效果的类，现在就可以在 ViewController 中注册专场动画了：

```objc
#pragma mark - **************** Navgation delegate
/** 返回转场动画实例*/
- (id<UIViewControllerAnimatedTransitioning>)navigationController:(UINavigationController *)navigationController
                                  animationControllerForOperation:(UINavigationControllerOperation)operation
                                               fromViewController:(UIViewController *)fromVC
                                                 toViewController:(UIViewController *)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.pushAnimation;
    }else if (operation == UINavigationControllerOperationPop){
        return self.popAnimation;
    }
    return nil;
}
```

## 转场交互

上面的效果是自动的，我们也可以为其添加转场交互，使其能响应交互。可以利用系统提供的 `UIPercentDrivenInteractiveTransition` 类完成 pop 操作。

### gesture

创建一个继承自 `UIPercentDrivenInteractiveTransition` 的类：

```objc
@interface InteractionTransitionAnimation : UIPercentDrivenInteractiveTransition

@property (assign , nonatomic) BOOL isActing;/** 判断动画正在进行中*/

-(void)writeToViewcontroller:(UIViewController *)toVc;/** 写入二级ViewController*/

@end

  
@interface InteractionTransitionAnimation ()

@property (assign , nonatomic) BOOL canReceive;

@property (strong, nonatomic) UIViewController * remVc;

@end

@implementation InteractionTransitionAnimation

- (void)writeToViewcontroller:(UIViewController *)toVc
{
    self.remVc = toVc;
    [self addPanGestureRecognizer:toVc.view];
}

- (void)addPanGestureRecognizer:(UIView *)view
{
    UIPanGestureRecognizer * pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panRecognizer:)];
    [view addGestureRecognizer:pan];
}

-(void)panRecognizer:(UIPanGestureRecognizer *)pan
{
    CGPoint panPoint = [pan translationInView:pan.view.superview];
    CGPoint locationPoint = [pan locationInView:pan.view.superview];
    
    if (pan.state == UIGestureRecognizerStateBegan) {
        self.isActing = YES;
        // ------判断初始位置，在屏幕上半段才能触发Pop
        if (locationPoint.y <= self.remVc.view.bounds.size.height/2.0) {
            [self.remVc.navigationController popViewControllerAnimated:YES];
        }
    }else if (pan.state == UIGestureRecognizerStateChanged){
        if (locationPoint.y >= self.remVc.view.bounds.size.height/2.0) {
            self.canReceive = YES;
        }else{
            self.canReceive = NO;
        }
        CGFloat a = panPoint.y/self.remVc.view.frame.size.height/5;
        [self updateInteractiveTransition:a];
        
    }else if (pan.state == UIGestureRecognizerStateCancelled || pan.state == UIGestureRecognizerStateEnded){
        self.isActing = NO;
        if(!self.canReceive || pan.state == UIGestureRecognizerStateCancelled)
        {
            [self cancelInteractiveTransition];
        }else{
            [self finishInteractiveTransition];
        }
    }
}

@end
  
```

这个类中提供了一个 `writeToViewController：` 的方法，为一个 ViewController 提供一个拖拽手势。该手势在屏幕上半段才能触发 `popViewControllerAnimated:`，在拖拽到屏幕下半部时才能完成pop，这个判断用 BOOL 值 `canReceive` 实现。

其中方法 `updateInteractiveTransition:` 用来更新显示的动画的程度（就是页面随着拖动露出越来越多）；`cancelInteractiveTransition` 方法取消 pop 动画；`finishInteractiveTransition` 方法标示整个 pop 动画完成。

### ViewController

将上面的手势手动添加给第二个 ViewController：

```objc
[self.popInteraction writeToViewcontroller:nextViewController];
```

但是，如果要正确的实现 update 以及 cancel 实现效果，还需要让前一个页面实现 `UINavigationControllerDelegate` 协议，以及下面方法：

```objc
-(id<UIViewControllerInteractiveTransitioning>)navigationController:(UINavigationController *)navigationController
                        interactionControllerForAnimationController:(id<UIViewControllerAnimatedTransitioning>)animationController
{
    return self.popInteraction.isActing ? self.popInteraction : nil;
//    return self.popInteractive.isActing ? self.popInteractive : nil;
}
```

上面的示例中，在调用了 `[self.remVc.navigationController popViewControllerAnimated:YES];` 方法后，前一个页面就会调用该方法，该方法返回返回交互手势的实例。



[Demo](https://github.com/zhang759740844/MyOCDemo/tree/develop/NavTransitionAnimation)



