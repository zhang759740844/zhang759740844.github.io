title: 自定义 ViewController 的过场动画
date: 2017/6/13 10:07:12  
categories: iOS
tags:
	- Animation
---

pop、push 和 present 的动画效果都是系统的。我们可以自定义一些有意思的过场动画效果

<!--more-->

自定义过场动画涉及到几个 API：
- UIViewControllerAnimatedTransitioning 动画协议
- UIViewControllerInteractiveTransitioning 交互协议
- UIViewControllerContextTransitioning 上下文协议
- UIPercentDrivenInteractiveTransition 遵守协议的一个官方类



## 转场动画

### push 和 pop

首先，我们要创建一个遵循 `UIViewControllerAnimatedTransitioning` 动画协议的一个转场动画类：

```objc
@interface PushTransition : NSObject<UIViewControllerAnimatedTransitioning>
@end
```

这个类要实现协议其中的两个方法：

```objc
-(NSTimeInterval)transitionDuration:(id<UIViewControllerContextTransitioning>)transitionContext
{
    return 0.8f;
}

-(void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext
{
    UIViewController * fromVc = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    UIViewController * toVc = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    
    CGRect finalFrameForVc = [transitionContext finalFrameForViewController:toVc];
    CGRect bounds = [[UIScreen mainScreen] bounds];
    
    toVc.view.frame = CGRectOffset(finalFrameForVc, 0, bounds.size.height);
    
    [[transitionContext containerView] addSubview:toVc.view];
    
    
    [UIView animateWithDuration:[self transitionDuration:transitionContext]
                          delay:0.0
         usingSpringWithDamping:0.5
          initialSpringVelocity:0.0
                        options:UIViewAnimationOptionCurveLinear
                     animations:^{
                         fromVc.view.alpha = 0.8;
                         toVc.view.frame = finalFrameForVc;
                     }
                     completion:^(BOOL finished) {
                         [transitionContext completeTransition:YES];
                         fromVc.view.alpha = 1.0;
                     }];
}
```

第一个方法返回的是动画时间。

第二个方法是动画的具体执行，方法的参数 `transitionContext` 遵守了 `UIViewControllerContextTransitioning` 协议，所以它包含了许多关于专场所需要的内容，包括转入ViewController和转出Viewcontroller，还有动画容器 `containerView` 等，ViewController 一定要添加到 `containerView` 中。

在 `UIViewControllerContextTransitioning` 协议中，有多个属性和方法，最重要的几个方法如下：

```objc
– (UIView*)containerView;                                       //获取容器View

– (void)completeTransition:(BOOL)didComplete;                   //通过此参数获知动画是否结束

– (UIViewController*)viewControllerForKey:(NSString*)key;       //获取转入、转出VC

– (CGRect)initialFrameForViewController:(UIViewController*)vc   //获取动画前VC的frame

– (CGRect)finalFrameForViewController:(UIViewController*)vc;    //获取动画后VC的frame
```



`PopTransition` 的实现和 `PushTransition` 几乎一模一样，完全可以将两者放在一个类中，复用 push 的代码。稍有不同的是，如果 push 的页面是从上往下的，那么一般 pop 的页面则是从下往上的。所以两者不同的是，在 pop 中要将 `toView` 的 frame 修改成：

```objc
toVc.view.frame = CGRectOffset(finalFrameForVc, 0, -bounds.size.height);
```

我们可以通过添加一个 BOOL 变量来判断是 push 还是 pop。

### ViewController

创建好了动画效果的类，现在就可以在第二个 ViewController 中注册专场动画了，第二个 ViewController 需要遵守 `UINavigationControllerDelegate`，然后设置 `self.navigationController.delegate = self`，最后实现其方法：

```objc
#pragma mark - **************** Navgation delegate
/** 返回转场动画实例*/
- (id<UIViewControllerAnimatedTransitioning>)navigationController:(UINavigationController *)navigationController
                                  animationControllerForOperation:(UINavigationControllerOperation)operation
                                               fromViewController:(UIViewController *)fromVC
                                                 toViewController:(UIViewController *)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.pushAnimation;
    }else if (operation == UINavigationControllerOperationPop){
        return self.popAnimation;
    }
    return nil;
}
```

## 转场交互

上面的效果是自动的，我们也可以为其添加转场交互，使其能响应交互。可以利用系统提供的 `UIPercentDrivenInteractiveTransition` 类完成 pop 操作。

### gesture

创建一个继承自 `UIPercentDrivenInteractiveTransition` 的类：

```objc
@interface InteractionTransitionAnimation : UIPercentDrivenInteractiveTransition

@property (assign , nonatomic) BOOL isActing;/** 判断动画正在进行中*/

-(void)writeToViewcontroller:(UIViewController *)toVc;/** 写入二级ViewController*/

@end

  
@interface InteractionTransitionAnimation ()

@property (assign , nonatomic) BOOL canReceive;

@property (strong, nonatomic) UIViewController * remVc;

@end

@implementation InteractionTransitionAnimation

- (void)writeToViewcontroller:(UIViewController *)toVc
{
    self.remVc = toVc;
    [self addPanGestureRecognizer:toVc.view];
}

- (void)addPanGestureRecognizer:(UIView *)view
{
    UIPanGestureRecognizer * pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panRecognizer:)];
    [view addGestureRecognizer:pan];
}

-(void)panRecognizer:(UIPanGestureRecognizer *)pan
{
    CGPoint panPoint = [pan translationInView:pan.view.superview];
    CGPoint locationPoint = [pan locationInView:pan.view.superview];
    
    if (pan.state == UIGestureRecognizerStateBegan) {
        self.isActing = YES;
        // ------判断初始位置，在屏幕上半段才能触发Pop
        if (locationPoint.y <= self.remVc.view.bounds.size.height/2.0) {
            [self.remVc.navigationController popViewControllerAnimated:YES];
        }
    }else if (pan.state == UIGestureRecognizerStateChanged){
        if (locationPoint.y >= self.remVc.view.bounds.size.height/2.0) {
            self.canReceive = YES;
        }else{
            self.canReceive = NO;
        }
        CGFloat a = panPoint.y/self.remVc.view.frame.size.height/5;
        [self updateInteractiveTransition:a];
        
    }else if (pan.state == UIGestureRecognizerStateCancelled || pan.state == UIGestureRecognizerStateEnded){
        self.isActing = NO;
        if(!self.canReceive || pan.state == UIGestureRecognizerStateCancelled)
        {
            [self cancelInteractiveTransition];
        }else{
            [self finishInteractiveTransition];
        }
    }
}

@end
  
```

这个类中提供了一个 `writeToViewController：` 的方法，为一个 ViewController 提供一个拖拽手势。该手势在屏幕上半段才能触发 `popViewControllerAnimated:`，在拖拽到屏幕下半部时才能完成pop，这个判断用 BOOL 值 `canReceive` 实现。

其中方法 `updateInteractiveTransition:` 用来更新显示的动画的程度（就是页面随着拖动露出越来越多）；`cancelInteractiveTransition` 方法取消 pop 动画；`finishInteractiveTransition` 方法标示整个 pop 动画完成。

### ViewController

将上面的手势手动添加给第二个 ViewController：

```objc
[self.popInteraction writeToViewcontroller:nextViewController];
```

但是，如果要正确的实现 update 以及 cancel 实现效果，还需要让前一个页面实现 `UINavigationControllerDelegate` 协议，以及下面方法：

```objc
-(id<UIViewControllerInteractiveTransitioning>)navigationController:(UINavigationController *)navigationController
                        interactionControllerForAnimationController:(id<UIViewControllerAnimatedTransitioning>)animationController
{
    return self.popInteraction.isActing ? self.popInteraction : nil;
//    return self.popInteractive.isActing ? self.popInteractive : nil;
}
```

上面的示例中，在调用了 `[self.remVc.navigationController popViewControllerAnimated:YES];` 方法后，前一个页面就会调用该方法，该方法返回返回交互手势的实例。



## Demo：查看图片的转场（类微信）

在微信中点击图片会弹出一个放大动画效果的图片的视图。这个动画效果的关键是：先对点击的图片进行截图，然后这个截图添加到弹出的页面上，通过动画效果使其移动到理想的位置，然后隐藏这个截图。

截图用 `snapshotViewAfterScreenUpdates`，如果参数为 NO，则立即生成快照

```objc
UIView *tempView = [cell.imageView snapshotViewAfterScreenUpdates:NO];
```

过度动画的部分关键代码:

```objc
    UIView *containerView = [transitionContext containerView];
    //snapshotViewAfterScreenUpdates 对cell的imageView截图保存成另一个视图用于过渡，并将视图转换到当前控制器的坐标
    UIView *tempView = [cell.imageView snapshotViewAfterScreenUpdates:NO];
    tempView.frame = [containerView convertRect:cell.imageView.bounds fromView:cell.imageView];
//    tempView.frame = [cell.imageView convertRect:cell.imageView.bounds toView: containerView];
    //设置动画前的各个控件的状态
    cell.imageView.hidden = YES;
    toVC.view.alpha = 0;
    toVC.imageView.hidden = YES;
    //tempView 添加到containerView中，要保证在最前方，所以后添加
    [containerView addSubview:toVC.view];
    [containerView addSubview:tempView];
    //开始做动画
    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 usingSpringWithDamping:0.55 initialSpringVelocity:1 / 0.55 options:0 animations:^{
        tempView.frame = [toVC.imageView convertRect:toVC.imageView.bounds toView:containerView];
        toVC.view.alpha = 1;
    } completion:^(BOOL finished) {
        tempView.hidden = YES;
        toVC.imageView.hidden = NO;
        //如果动画过渡取消了就标记不完成，否则才完成，这里可以直接写YES，如果有手势过渡才需要判断，必须标记，否则系统不会中动画完成的部署，会出现无法交互之类的bug
        [transitionContext completeTransition:YES];
    }];
```

先生成了当前 View 的截图，然后通过 `convertRect:toView:` 方法计算该截图在下一个页面的位置，之后通过 UIView 的 Animation 移动截图，完成后，隐藏截图。

返回动画的关键代码：

```objc
	UIView *containerView = [transitionContext containerView];
    //这里的lastView就是push时候初始化的那个tempView
    UIView *tempView = containerView.subviews.lastObject;
    //设置初始状态
    cell.imageView.hidden = YES;
    fromVC.imageView.hidden = YES;
    tempView.hidden = NO;
    [containerView insertSubview:toVC.view atIndex:0];
    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 usingSpringWithDamping:0.55 initialSpringVelocity:1 / 0.55 options:0 animations:^{
        tempView.frame = [cell.imageView convertRect:cell.imageView.bounds toView:containerView];
        fromVC.view.alpha = 0;
    } completion:^(BOOL finished) {
        //由于加入了手势必须判断
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
        if ([transitionContext transitionWasCancelled]) {//手势取消了，原来隐藏的imageView要显示出来
            //失败了隐藏tempView，显示fromVC.imageView
            tempView.hidden = YES;
            fromVC.imageView.hidden = NO;
        }else{//手势成功，cell的imageView也要显示出来
            //成功了移除tempView，下一次pop的时候又要创建，然后显示cell的imageView
            cell.imageView.hidden = NO;
            [tempView removeFromSuperview];
        }
    }];

```

这里基本就是上面的反转。不同的是，由于添加了手势，需要在动画完成回调中判断是否是否成功，如果不成功，需要将原先隐藏的复原：

```objc
 	UIView *containerView = [transitionContext containerView];
    //这里的lastView就是push时候初始化的那个tempView
    UIView *tempView = containerView.subviews.lastObject;
    //设置初始状态
    cell.imageView.hidden = YES;
    fromVC.imageView.hidden = YES;
    tempView.hidden = NO;
    [containerView insertSubview:toVC.view atIndex:0];
    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0.0 usingSpringWithDamping:0.55 initialSpringVelocity:1 / 0.55 options:0 animations:^{
        tempView.frame = [cell.imageView convertRect:cell.imageView.bounds toView:containerView];
        fromVC.view.alpha = 0;
    } completion:^(BOOL finished) {
        //由于加入了手势必须判断
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
        if ([transitionContext transitionWasCancelled]) {//手势取消了，原来隐藏的imageView要显示出来
            //失败了隐藏tempView，显示fromVC.imageView
            //不知道为什么这个时候tempView的宽高就都为0了，必须要将其宽高设置回来
            tempView.frame = fromVC.imageView.frame;
            fromVC.imageView.hidden = NO;
            tempView.hidden = YES;
            
        }else{//手势成功，cell的imageView也要显示出来
            //成功了移除tempView，下一次pop的时候又要创建，然后显示cell的imageView
            cell.imageView.hidden = NO;
            [tempView removeFromSuperview];
        }
    }];

```

上面的代码是控制后面 View 的透明度来实现切换页面的。参考自[iOS自定义转场动画](http://www.jianshu.com/p/45434f73019e) 详细[Demo](https://github.com/zhang759740844/MyOCDemo/tree/develop/XWTrasitionPractice-master)



[更详细的转场Demo](http://www.jianshu.com/p/e498b956491c)[地址](https://github.com/wazrx/XWTransition)









[Demo](https://github.com/zhang759740844/MyOCDemo/tree/develop/NavTransitionAnimation)



